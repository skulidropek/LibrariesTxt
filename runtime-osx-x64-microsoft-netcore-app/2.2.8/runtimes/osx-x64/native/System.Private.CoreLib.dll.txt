internal static class FxResources.System.Private.CoreLib.SR : object {
}
public static class Internal.Console : object {
    private static SafeFileHandle _outputHandle;
    private static Console();
    public static void Write(string s);
    public static void WriteLine(string s);
    public static void WriteLine();
}
internal static class Internal.IO.File : object {
    public static bool Exists(string path);
    public static Byte[] ReadAllBytes(string path);
    internal static bool InternalExists(string fullPath);
}
internal class Internal.PaddingFor32 : ValueType {
}
public static class Internal.Runtime.Augments.EnvironmentAugments : object {
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static int TickCount { get; }
    public static int ProcessorCount { get; }
    public static string StackTrace { get; }
    public static int get_CurrentManagedThreadId();
    public static void Exit(int exitCode);
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static void FailFast(string message, Exception error);
    public static String[] GetCommandLineArgs();
    public static bool get_HasShutdownStarted();
    public static int get_TickCount();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables();
    public static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables(EnvironmentVariableTarget target);
    public static int get_ProcessorCount();
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    public static string get_StackTrace();
}
public class Internal.Runtime.Augments.RuntimeThread : CriticalFinalizerObject {
    private static int s_optimalMaxSpinWaitsPerSpinIteration;
    [ThreadStaticAttribute]
private static int t_currentProcessorIdCache;
    public static RuntimeThread CurrentThread { get; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public bool IsThreadPoolThread { get; }
    public int ManagedThreadId { get; }
    public string Name { get; public set; }
    public ThreadPriority Priority { get; public set; }
    internal static ulong CurrentOSThreadId { get; }
    public ThreadState ThreadState { get; }
    internal static int OptimalMaxSpinWaitsPerSpinIteration { get; }
    public static RuntimeThread Create(ThreadStart start);
    public static RuntimeThread Create(ThreadStart start, int maxStackSize);
    public static RuntimeThread Create(ParameterizedThreadStart start);
    public static RuntimeThread Create(ParameterizedThreadStart start, int maxStackSize);
    private Thread AsThread();
    public static RuntimeThread get_CurrentThread();
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    private bool IsBackgroundNative();
    private void SetBackgroundNative(bool isBackground);
    public bool get_IsThreadPoolThread();
    public int get_ManagedThreadId();
    public string get_Name();
    public void set_Name(string value);
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    private int GetPriorityNative();
    private void SetPriorityNative(int priority);
    internal static ulong get_CurrentOSThreadId();
    private static ulong GetCurrentOSThreadId();
    public ThreadState get_ThreadState();
    private int GetThreadStateNative();
    public ApartmentState GetApartmentState();
    public bool TrySetApartmentState(ApartmentState state);
    public void DisableComObjectEagerCleanup();
    public void Interrupt();
    private void InterruptInternal();
    public void Join();
    public bool Join(int millisecondsTimeout);
    private bool JoinInternal(int millisecondsTimeout);
    public static void Sleep(int millisecondsTimeout);
    private static int GetOptimalMaxSpinWaitsPerSpinIterationInternal();
    internal static int get_OptimalMaxSpinWaitsPerSpinIteration();
    private static int GetCurrentProcessorNumber();
    private static int RefreshCurrentProcessorId();
    public static int GetCurrentProcessorId();
    public static void SpinWait(int iterations);
    public static bool Yield();
    public void Start();
    public void Start(object parameter);
}
[CLSCompliantAttribute("False")]
public static class Internal.Runtime.CompilerServices.Unsafe : object {
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static int SizeOf();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T As(object value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static TTo& As(TFrom& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static Void* Add(Void* source, int elementOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
internal static T& AddByteOffset(T& source, ulong byteOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool AreSame(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T ReadUnaligned(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void WriteUnaligned(Void* destination, T value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T Read(Void* source);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T Read(Byte& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Void* destination, T value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void Write(Byte& destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AsRef(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
}
internal static class Interop : object {
    private static void ThrowExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static void CheckIo(Error error, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static long CheckIo(long result, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static IntPtr CheckIo(IntPtr result, string path, bool isDirectory, Func`2<ErrorInfo, ErrorInfo> errorRewriter);
    internal static Exception GetExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirectory);
    internal static Exception GetIOException(ErrorInfo errorInfo);
    internal static bool CallStringMethod(Func`5<TArg1, TArg2, TArg3, StringBuilder, ResultCode> interopCall, TArg1 arg1, TArg2 arg2, TArg3 arg3, String& result);
    internal static void GetRandomBytes(Byte* buffer, int length);
}
[ExtensionAttribute]
internal static class InteropErrorExtensions : object {
    [ExtensionAttribute]
public static ErrorInfo Info(Error error);
}
[ExtensionAttribute]
internal static class Microsoft.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool ReflectionOnly(Assembly assm);
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeDirectoryHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static IntPtr s_invalidHandle;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsAsync>k__BackingField;
    internal Nullable`1<bool> IsAsync { get; internal set; }
    public bool IsInvalid { get; }
    private SafeFileHandle(bool ownsHandle);
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    private static SafeFileHandle();
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsAsync();
    [CompilerGeneratedAttribute]
internal void set_IsAsync(Nullable`1<bool> value);
    internal static SafeFileHandle Open(string path, OpenFlags flags, int mode);
    private static bool DirectoryExists(string fullPath);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
}
internal static class Microsoft.Win32.Win32Native : object {
    internal static IntPtr INVALID_HANDLE_VALUE;
    private static Win32Native();
    internal static IntPtr LocalAlloc_NoSafeHandle(int uFlags, UIntPtr sizetdwBytes);
    internal static IntPtr LocalFree(IntPtr handle);
    internal static int lstrlenA(IntPtr ptr);
    internal static int lstrlenW(IntPtr ptr);
    internal static IntPtr SysAllocStringLen(string src, int len);
    internal static UInt32 SysStringLen(IntPtr bstr);
    internal static void SysFreeString(IntPtr bstr);
    internal static IntPtr SysAllocStringByteLen(Byte[] str, UInt32 len);
    internal static UInt32 SysStringByteLen(IntPtr bstr);
    internal static bool SetEvent(SafeWaitHandle handle);
    internal static bool ResetEvent(SafeWaitHandle handle);
    internal static SafeWaitHandle CreateEventEx(SECURITY_ATTRIBUTES lpSecurityAttributes, string name, UInt32 flags, UInt32 desiredAccess);
    internal static SafeWaitHandle CreateMutexEx(SECURITY_ATTRIBUTES lpSecurityAttributes, string name, UInt32 flags, UInt32 desiredAccess);
    internal static SafeWaitHandle OpenMutex(UInt32 desiredAccess, bool inheritHandle, string name);
    internal static bool ReleaseMutex(SafeWaitHandle handle);
    internal static bool CloseHandle(IntPtr handle);
    internal static int WriteFile(SafeFileHandle handle, Byte* bytes, int numBytesToWrite, Int32& numBytesWritten, IntPtr mustBeZero);
    internal static SafeWaitHandle CreateSemaphoreEx(SECURITY_ATTRIBUTES lpSecurityAttributes, int initialCount, int maximumCount, string name, UInt32 flags, UInt32 desiredAccess);
    internal static bool ReleaseSemaphore(SafeWaitHandle handle, int releaseCount, Int32& previousCount);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static int WideCharToMultiByte(UInt32 cp, UInt32 flags, Char* pwzSource, int cchSource, Byte* pbDestBuffer, int cbDestBuffer, IntPtr null1, IntPtr null2);
    internal static bool SetEnvironmentVariable(string lpName, string lpValue);
    private static int GetEnvironmentVariable(string lpName, Char* lpValue, int size);
    internal static int GetEnvironmentVariable(string lpName, Span`1<char> lpValue);
    internal static Char* GetEnvironmentStrings();
    internal static bool FreeEnvironmentStrings(Char* pStrings);
    internal static UInt32 GetCurrentProcessId();
    internal static IntPtr CoTaskMemAlloc(UIntPtr cb);
    internal static void CoTaskMemFree(IntPtr ptr);
    internal static IntPtr CoTaskMemRealloc(IntPtr pv, UIntPtr cb);
    internal static IntPtr LocalReAlloc(IntPtr handle, IntPtr sizetcbBytes, int uFlags);
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
internal class System.__Canon : object {
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
internal class System.__DTString : ValueType {
    internal ReadOnlySpan`1<char> Value;
    internal int Index;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    private static Char[] WhiteSpaceChecks;
    internal int Length { get; }
    internal CompareInfo CompareInfo { get; }
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi);
    private static __DTString();
    internal int get_Length();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool AtEnd();
    internal bool Advance(int count);
    internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AccessViolationException : SystemException {
    private IntPtr _ip;
    private IntPtr _target;
    private int _accessType;
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Activator : object {
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static object CreateInstance(Type type, Object[] args);
    public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    public static object CreateInstance(Type type);
    public static object CreateInstance(Type type, bool nonPublic);
    internal static object CreateInstance(Type type, bool nonPublic, bool wrapExceptions);
    public static T CreateInstance();
}
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AggregateException : Exception {
    private ReadOnlyCollection`1<Exception> m_innerExceptions;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    private int InnerExceptionCount { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, IList`1<Exception> innerExceptions);
    internal AggregateException(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    private AggregateException(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string get_Message();
    public virtual string ToString();
    private int get_InnerExceptionCount();
}
public static class System.AppContext : object {
    private static Dictionary`2<string, SwitchValueState> s_switchMap;
    [CompilerGeneratedAttribute]
private static EventHandler ProcessExit;
    [CompilerGeneratedAttribute]
private static EventHandler Unloading;
    public static string BaseDirectory { get; }
    public static string TargetFrameworkName { get; }
    private static AppContext();
    public static string get_BaseDirectory();
    public static string get_TargetFrameworkName();
    public static object GetData(string name);
    public static void SetData(string name, object data);
    public static void add_UnhandledException(UnhandledExceptionEventHandler value);
    public static void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public static void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public static void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_Unloading(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_Unloading(EventHandler value);
    private static void OnProcessExit(object sender, EventArgs e);
    private static void OnUnloading(object sender, EventArgs e);
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    public static void SetSwitch(string switchName, bool isEnabled);
    internal static void DefineSwitchDefault(string switchName, bool isEnabled);
}
internal static class System.AppContextDefaultValues : object {
    internal static string SwitchNoAsyncCurrentCulture;
    internal static string SwitchFormatJapaneseFirstYearAsANumber;
    internal static string SwitchEnforceLegacyJapaneseDateParsing;
    internal static string SwitchEnforceJapaneseEraYearRanges;
    internal static string SwitchPreserveEventListnerObjectIdentity;
    private static AppContextDefaultValues();
    public static void PopulateDefaultValues();
    private static void ParseTargetFrameworkName(String& identifier, String& profile, Int32& version);
    private static bool TryParseFrameworkName(string frameworkName, String& identifier, Int32& version, String& profile);
    private static void TryGetSwitchOverridePartial(string switchName, Boolean& overrideFound, Boolean& overrideValue);
    private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version);
    public static bool TryGetSwitchOverride(string switchName, Boolean& overrideValue);
}
internal static class System.AppContextSwitches : object {
    private static int _formatJapaneseFirstYearAsANumber;
    private static int _enforceJapaneseEraYearRanges;
    private static int _enforceLegacyJapaneseDateParsing;
    private static int _preserveEventListnerObjectIdentity;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    public static bool FormatJapaneseFirstYearAsANumber { get; }
    public static bool EnforceJapaneseEraYearRanges { get; }
    public static bool EnforceLegacyJapaneseDateParsing { get; }
    public static bool PreserveEventListnerObjectIdentity { get; }
    private static bool DisableCaching { get; private set; }
    private static AppContextSwitches();
    public static bool get_FormatJapaneseFirstYearAsANumber();
    public static bool get_EnforceJapaneseEraYearRanges();
    public static bool get_EnforceLegacyJapaneseDateParsing();
    public static bool get_PreserveEventListnerObjectIdentity();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
}
internal class System.AppDomain : object {
    private AppDomainManager _domainManager;
    private Dictionary`2<string, object> _LocalStore;
    private AppDomainSetup _FusionStore;
    [CompilerGeneratedAttribute]
private AssemblyLoadEventHandler AssemblyLoad;
    private ResolveEventHandler _TypeResolve;
    private ResolveEventHandler _ResourceResolve;
    private ResolveEventHandler _AssemblyResolve;
    private EventHandler _processExit;
    private EventHandler _domainUnload;
    private UnhandledExceptionEventHandler _unhandledException;
    private Dictionary`2<string, object> _compatFlags;
    private EventHandler`1<FirstChanceExceptionEventArgs> _firstChanceException;
    private IntPtr _pDomain;
    private bool _compatFlagsInitialized;
    public AppDomainManager DomainManager { get; }
    public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    internal AppDomainSetup FusionStore { get; }
    private Dictionary`2<string, object> LocalStore { get; }
    public AppDomainSetup SetupInformation { get; }
    [CompilerGeneratedAttribute]
public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    private void CreateAppDomainManager();
    private void InitializeCompatibilityFlags();
    internal static void CheckLoadFromSupported();
    internal static void CheckLoadFileSupported();
    internal static void CheckLoadByteArraySupported();
    public AppDomainManager get_DomainManager();
    public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    private Assembly[] nGetAssemblies(bool forIntrospection);
    internal Assembly[] GetAssemblies(bool forIntrospection);
    public bool IsFinalizingForUnload();
    internal static void PublishAnonymouslyHostedDynamicMethodsAssembly(RuntimeAssembly assemblyHandle);
    public void SetData(string name, object data);
    public object GetData(string name);
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    internal void nCreateContext();
    private static void nSetupBindingPaths(string trustedPlatformAssemblies, string platformResourceRoots, string appPath, string appNiPaths, string appLocalWinMD);
    internal void SetupBindingPaths(string trustedPlatformAssemblies, string platformResourceRoots, string appPath, string appNiPaths, string appLocalWinMD);
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    public void add_DomainUnload(EventHandler value);
    public void remove_DomainUnload(EventHandler value);
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    private void OnAssemblyLoadEvent(RuntimeAssembly LoadedAssembly);
    private RuntimeAssembly OnResourceResolveEvent(RuntimeAssembly assembly, string resourceName);
    private RuntimeAssembly OnTypeResolveEvent(RuntimeAssembly assembly, string typeName);
    private RuntimeAssembly OnAssemblyResolveEvent(RuntimeAssembly assembly, string assemblyFullName);
    private RuntimeAssembly InvokeResolveEvent(ResolveEventHandler eventHandler, RuntimeAssembly assembly, string name);
    internal AppDomainSetup get_FusionStore();
    private static RuntimeAssembly GetRuntimeAssembly(Assembly asm);
    private Dictionary`2<string, object> get_LocalStore();
    private static void nSetNativeDllSearchDirectories(string paths);
    private void SetupFusionStore(AppDomainSetup info, AppDomainSetup oldInfo);
    private static object PrepareDataForSetup(string friendlyName, AppDomainSetup setup, String[] propertyNames, String[] propertyValues);
    private static object Setup(object arg);
    private static string NormalizeAppPaths(string values);
    internal static string NormalizePath(string path, bool fullCheck);
    private void SetupDomain(bool allowRedirects, string path, string configFile, String[] propertyNames, String[] propertyValues);
    private void nSetupFriendlyName(string friendlyName);
    public AppDomainSetup get_SetupInformation();
    internal string IsStringInterned(string str);
    internal string GetOrInternString(string str);
    internal int GetId();
}
internal class System.AppDomainManager : MarshalByRefObject {
    private Assembly m_entryAssembly;
    public Assembly EntryAssembly { get; }
    private static void GetEntryAssembly(ObjectHandleOnStack retAssembly);
    public virtual Assembly get_EntryAssembly();
}
internal class System.AppDomainSetup : object {
    private static string LOADER_OPTIMIZATION;
    private static string ACTAG_APP_BASE_URL;
    private String[] _Entries;
    private string _AppBase;
    private Dictionary`2<string, object> _CompatFlags;
    internal String[] Value { get; }
    public string ApplicationBase { get; public set; }
    public string TargetFrameworkName { get; }
    unknown string ApplicationName {public set; }
    internal AppDomainSetup(AppDomainSetup copy, bool copyDomainBoundData);
    internal void SetupDefaults(string imageLocation, bool imageLocationAlreadyNormalized);
    internal String[] get_Value();
    public string get_ApplicationBase();
    public void set_ApplicationBase(string value);
    internal Dictionary`2<string, object> GetCompatibilityFlags();
    public void SetCompatibilitySwitches(IEnumerable`1<string> switches);
    public string get_TargetFrameworkName();
    public void set_ApplicationName(string value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
internal class System.AppDomainUnloadedException : SystemException {
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    protected ApplicationException(SerializationInfo info, StreamingContext context);
}
[IsByRefLikeAttribute]
public class System.ArgIterator : ValueType {
    private IntPtr ArgCookie;
    private IntPtr sigPtr;
    private IntPtr sigPtrLen;
    private IntPtr ArgPtr;
    private int RemainingArgs;
    public ArgIterator(RuntimeArgumentHandle arglist);
    [CLSCompliantAttribute("False")]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    public void End();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    public RuntimeTypeHandle GetNextArgType();
    public int GetRemainingCount();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentException : SystemException {
    private string _paramName;
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_ParamName();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentOutOfRangeException : ArgumentException {
    private object _actualValue;
    public string Message { get; }
    public object ActualValue { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string paramName, string message);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual object get_ActualValue();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Array : object {
    public int Length { get; }
    public long LongLength { get; }
    public int Rank { get; }
    private int System.Collections.ICollection.Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static void Resize(T[]& array, int newSize);
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    private static Array InternalCreate(Void* elementType, int rank, Int32* pLengths, Int32* pLowerBounds);
    internal static Array UnsafeCreateInstance(Type elementType, int length);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    internal static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public static void Clear(Array array, int index, int length);
    private static Byte& GetRawArrayGeometry(Array array, UInt32& numComponents, UInt32& elementSize, Int32& lowerBound, Boolean& containsGCPointers);
    public object GetValue(Int32[] indices);
    public object GetValue(int index);
    public object GetValue(int index1, int index2);
    public object GetValue(int index1, int index2, int index3);
    public object GetValue(long index);
    public object GetValue(long index1, long index2);
    public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public void SetValue(object value, int index);
    public void SetValue(object value, int index1, int index2);
    public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    public void SetValue(object value, long index);
    public void SetValue(object value, long index1, long index2);
    public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    private void InternalGetReference(Void* elemRef, int rank, Int32* pIndices);
    private static void InternalSetValue(Void* target, object value);
    public int get_Length();
    private static int GetMedian(int low, int hi);
    public long get_LongLength();
    public int GetLength(int dimension);
    public long GetLongLength(int dimension);
    public int get_Rank();
    public int GetUpperBound(int dimension);
    public int GetLowerBound(int dimension);
    internal int GetDataPtrOffsetInternal();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    internal static int CombineHashCodes(int h1, int h2);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    private static bool TrySZBinarySearch(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public sealed virtual IEnumerator GetEnumerator();
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    private static bool TrySZIndexOf(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    private static bool TrySZLastIndexOf(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    private static bool TrySZReverse(Array array, int index, int count);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    private static bool TrySZSort(Array keys, Array items, int left, int right);
    public static void Sort(T[] array);
    public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    public void Initialize();
}
[DefaultMemberAttribute("Item")]
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArraySegment`1 : ValueType {
    [CompilerGeneratedAttribute]
private static ArraySegment`1<T> <Empty>k__BackingField;
    private T[] _array;
    private int _offset;
    private int _count;
    public static ArraySegment`1<T> Empty { get; }
    public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    private static ArraySegment`1();
    [CompilerGeneratedAttribute]
public static ArraySegment`1<T> get_Empty();
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowInvalidOperationIfDefault();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.AssemblyLoadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    [CompilerGeneratedAttribute]
public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    private static Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit);
    private static bool InternalIsDefined(PropertyInfo element, Type attributeType, bool inherit);
    private static PropertyInfo GetParentDefinition(PropertyInfo property, Type[] propertyParameters);
    private static Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit);
    private static EventInfo GetParentDefinition(EventInfo ev);
    private static bool InternalIsDefined(EventInfo element, Type attributeType, bool inherit);
    private static ParameterInfo GetParentDefinition(ParameterInfo param);
    private static Attribute[] InternalParamGetCustomAttributes(ParameterInfo param, Type type, bool inherit);
    private static bool InternalParamIsDefined(ParameterInfo param, Type type, bool inherit);
    private static void CopyToArrayList(List`1<Attribute> attributeList, Attribute[] attributes, Dictionary`2<Type, AttributeUsageAttribute> types);
    private static Type[] GetIndexParameterTypes(PropertyInfo element);
    private static void AddAttributesToList(List`1<Attribute> attributeList, Attribute[] attributes, Dictionary`2<Type, AttributeUsageAttribute> types);
    private static AttributeUsageAttribute InternalGetAttributeUsage(Type type);
    private static Attribute[] CreateAttributeArrayHelper(Type elementType, int elementCount);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public virtual bool Equals(object obj);
    private static bool AreFieldValuesEqual(object thisValue, object thatValue);
    public virtual int GetHashCode();
    public virtual object get_TypeId();
    public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    private AttributeTargets _attributeTarget;
    private bool _allowMultiple;
    private bool _inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.BadImageFormatException : SystemException {
    private string _fileName;
    private string _fusionLog;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private BadImageFormatException(string fileName, string fusionLog, int hResult);
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    public string get_FileName();
    public virtual string ToString();
    public string get_FusionLog();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    public static Byte[] GetBytes(char value);
    public static bool TryWriteBytes(Span`1<byte> destination, char value);
    public static Byte[] GetBytes(short value);
    public static bool TryWriteBytes(Span`1<byte> destination, short value);
    public static Byte[] GetBytes(int value);
    public static bool TryWriteBytes(Span`1<byte> destination, int value);
    public static Byte[] GetBytes(long value);
    public static bool TryWriteBytes(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
    public static Byte[] GetBytes(float value);
    public static bool TryWriteBytes(Span`1<byte> destination, float value);
    public static Byte[] GetBytes(double value);
    public static bool TryWriteBytes(Span`1<byte> destination, double value);
    public static char ToChar(Byte[] value, int startIndex);
    public static char ToChar(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    public static long ToInt64(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value, int startIndex, int length);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    public static long DoubleToInt64Bits(double value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static float Int32BitsToSingle(int value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Boolean : ValueType {
    private bool m_value;
    public static string TrueString;
    public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(bool obj);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    public static bool Parse(string value);
    public static bool Parse(ReadOnlySpan`1<char> value);
    public static bool TryParse(string value, Boolean& result);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    private static ReadOnlySpan`1<char> TrimWhiteSpaceAndNull(ReadOnlySpan`1<char> value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    private static bool IsPrimitiveTypeArray(Array array);
    private static byte _GetByte(Array array, int index);
    public static byte GetByte(Array array, int index);
    private static void _SetByte(Array array, int index, byte value);
    public static void SetByte(Array array, int index, byte value);
    private static int _ByteLength(Array array);
    public static int ByteLength(Array array);
    internal static void ZeroMemory(Byte* src, long len);
    internal static void Memcpy(Byte[] dest, int destIndex, Byte* src, int srcIndex, int len);
    internal static void Memcpy(Byte* pDest, int destIndex, Byte[] src, int srcIndex, int len);
    internal static void Memcpy(Byte* dest, Byte* src, int len);
    internal static void Memmove(Byte* dest, Byte* src, ulong len);
    internal static void Memmove(T& destination, T& source, ulong elementCount);
    private static void Memmove(ByReference`1<byte> dest, ByReference`1<byte> src, ulong len);
    private static void _Memmove(Byte* dest, Byte* src, ulong len);
    private static void _Memmove(Byte& dest, Byte& src, ulong len);
    private static void __Memmove(Byte* dest, Byte* src, ulong len);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
}
public abstract class System.Buffers.ArrayPool`1 : object {
    [CompilerGeneratedAttribute]
private static ArrayPool`1<T> <Shared>k__BackingField;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    [CompilerGeneratedAttribute]
public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
    [EventAttribute("4")]
internal void BufferTrimmed(int bufferId, int bufferSize, int poolId);
    [EventAttribute("5")]
internal void BufferTrimPoll(int milliseconds, int pressure);
}
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    private Bucket[] _buckets;
    private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
public interface System.Buffers.IMemoryOwner`1 {
    public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(ulong value);
}
internal class System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
    private Int32[] _bucketArraySizes;
    private PerCoreLockedStacks[] _buckets;
    [ThreadStaticAttribute]
private static T[][] t_tlsBuckets;
    private int _callbackCreated;
    private static bool s_trimBuffers;
    private static ConditionalWeakTable`2<T[][], object> s_allTlsBuckets;
    private int Id { get; }
    private static TlsOverPerCoreLockedStacksArrayPool`1();
    private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
    public bool Trim();
    private static bool Gen2GcCallbackFunc(object target);
    private static MemoryPressure<T> GetMemoryPressure();
    private static bool GetTrimBuffers();
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NonVersionableAttribute]
internal class System.ByReference`1 : ValueType {
    private IntPtr _value;
    public T& Value { get; }
    public ByReference`1(T& value);
    public T& get_Value();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Byte : ValueType {
    private byte m_value;
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, IFormatProvider provider);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Byte& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Char : ValueType {
    private char m_value;
    public static char MaxValue;
    public static char MinValue;
    private static Byte[] s_categoryForLatin1;
    private static Char();
    private static bool IsLatin1(char ch);
    private static bool IsAscii(char ch);
    private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(char obj);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public static string ToString(char c);
    public static char Parse(string s);
    public static bool TryParse(string s, Char& result);
    public static bool IsDigit(char c);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    private static bool IsWhiteSpaceLatin1(char c);
    public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    public static bool IsLetterOrDigit(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(string s, int index);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    private static bool IsSeparatorLatin1(char c);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
}
public class System.CharEnumerator : object {
    private string _str;
    private int _index;
    private char _currentElement;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
internal class System.CLRConfig : object {
    internal static bool GetBoolValue(string switchName, Boolean& exist);
    internal static bool GetBoolValueWithFallbacks(string switchName, string environmentName, bool defaultValue);
    private static bool GetConfigBoolValue(string configSwitchName, Boolean& exist);
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    private bool _compliant;
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Comparer : object {
    private CompareInfo _compareInfo;
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    private static Comparer();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual int Compare(object a, object b);
}
internal class System.Collections.CompatibleComparer : object {
    private IComparer _comparer;
    private IHashCodeProvider _hcp;
    internal CompatibleComparer(IComparer comparer, IHashCodeProvider hashCodeProvider);
    public int Compare(object a, object b);
    public sealed virtual bool Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    private Tables modreq(System.Runtime.CompilerServices.IsVolatile) _tables;
    private IEqualityComparer`1<TKey> _comparer;
    private bool _growLockArray;
    private int _budget;
    private static bool s_isValueWriteAtomic;
    public TValue Item { get; public set; }
    public int Count { get; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static int DefaultConcurrencyLevel { get; }
    internal ConcurrentDictionary`2(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<TKey> comparer);
    private static ConcurrentDictionary`2();
    private static bool IsValueWriteAtomic();
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool TryRemove(TKey key, TValue& value);
    private bool TryRemoveInternal(TKey key, TValue& value, bool matchValue, TValue oldValue);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private bool TryGetValueInternal(TKey key, int hashcode, TValue& value);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private void CopyToPairs(KeyValuePair`2[] array, int index);
    private void CopyToEntries(DictionaryEntry[] array, int index);
    private void CopyToObjects(Object[] array, int index);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentDictionary`2/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfExists, bool acquireLock, TValue& resultingValue);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private static void ThrowKeyNotFoundException(object key);
    private static void ThrowKeyNullException();
    public sealed virtual int get_Count();
    private int GetCountInternal();
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void GrowTable(Tables<TKey, TValue> tables);
    private static int GetBucket(int hashcode, int bucketCount);
    private static void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount);
    private static int get_DefaultConcurrencyLevel();
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private ReadOnlyCollection`1<TKey> GetKeys();
    private ReadOnlyCollection`1<TValue> GetValues();
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private object _crossSegmentLock;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    private static int GetCount(Segment<T> s, int head, int tail);
    private static long GetCount(Segment<T> head, int headHead, Segment<T> tail, int tailTail);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void SnapForObservation(Segment& head, Int32& headHead, Segment& tail, Int32& tailTail);
    private T GetItemWhenAvailable(Segment<T> segment, int i);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentQueue`1/<Enumerate>d__25")]
private IEnumerator`1<T> Enumerate(Segment<T> head, int headHead, Segment<T> tail, int tailTail);
    public void Enqueue(T item);
    private void EnqueueSlow(T item);
    public bool TryDequeue(T& result);
    private bool TryDequeueSlow(T& item);
    private bool TryPeek(T& result, bool resultUsed);
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Concurrent.ConcurrentStack`1 : object {
    private Node modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void Push(T item);
    private void PushCore(Node<T> head, Node<T> tail);
    public bool TryPop(T& result);
    private bool TryPopCore(T& result);
    private int TryPopCore(int count, Node& poppedHead);
    private List`1<T> ToList();
    private List`1<T> ToList(Node<T> curr);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentStack`1/<GetEnumerator>d__21")]
private IEnumerator`1<T> GetEnumerator(Node<T> head);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
}
[DebuggerDisplayAttribute("Head = {Head}, Tail = {Tail}")]
internal class System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
    public int Head;
    public int Tail;
}
internal class System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> m_collection;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.EmptyReadOnlyDictionaryInternal : object {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`1")]
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    private static IArraySortHelper`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultArraySortHelper;
    public static IArraySortHelper`1<T> Default { get; }
    public static IArraySortHelper`1<T> get_Default();
    private static IArraySortHelper`1<T> CreateArraySortHelper();
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(T[] keys, int index, int length, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`2")]
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    private static IArraySortHelper`2 modreq(System.Runtime.CompilerServices.IsVolatile) defaultArraySortHelper;
    public static IArraySortHelper`2<TKey, TValue> Default { get; }
    public static IArraySortHelper`2<TKey, TValue> get_Default();
    private static IArraySortHelper`2<TKey, TValue> CreateArraySortHelper();
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, IComparer`1<TKey> comparer, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte b);
    internal virtual int IndexOf(Byte[] array, byte value, int startIndex, int count);
    internal virtual int LastIndexOf(Byte[] array, byte value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectComparer`1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    [CompilerGeneratedAttribute]
private static Comparer`1<T> <Default>k__BackingField;
    public static Comparer`1<T> Default { get; }
    private static Comparer`1();
    [CompilerGeneratedAttribute]
public static Comparer`1<T> get_Default();
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    public abstract virtual int Compare(T x, T y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal static class System.Collections.Generic.ComparerHelpers : object {
    internal static object CreateDefaultComparer(Type type);
    private static object TryCreateNullableComparer(RuntimeType nullableType);
    private static object TryCreateEnumComparer(RuntimeType enumType);
    internal static object CreateDefaultEqualityComparer(Type type);
    private static object TryCreateNullableEqualityComparer(RuntimeType nullableType);
    private static object TryCreateEnumEqualityComparer(RuntimeType enumType);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] _buckets;
    private Entry[] _entries;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    private object _syncRoot;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private int FindEntry(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    public virtual void OnDeserialization(object sender);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    private EnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectEqualityComparer`1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<T> <Default>k__BackingField;
    public static EqualityComparer`1<T> Default { get; }
    private static EqualityComparer`1();
    [IntrinsicAttribute]
[CompilerGeneratedAttribute]
public static EqualityComparer`1<T> get_Default();
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(T[] array, int index, int length, T value);
    private static void SwapIfGreaterWithItems(T[] keys, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi);
    private static void Heapsort(T[] keys, int lo, int hi);
    private static void DownHeap(T[] keys, int i, int n, int lo);
    private static void InsertionSort(T[] keys, int lo, int hi);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface System.Collections.Generic.IArraySortHelper`1 {
    public abstract virtual void Sort(TKey[] keys, int index, int length, IComparer`1<TKey> comparer);
    public abstract virtual int BinarySearch(TKey[] keys, int index, int length, TKey value, IComparer`1<TKey> comparer);
}
internal interface System.Collections.Generic.IArraySortHelper`2 {
    public abstract virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
internal enum System.Collections.Generic.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
internal class System.Collections.Generic.Int32EnumComparer`1 : Comparer`1<T> {
    private Int32EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Collections.Generic.Int64EnumComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal static class System.Collections.Generic.IntrospectiveSortUtilities : object {
    internal static int FloorLog2PlusOne(int n);
    internal static void ThrowOrIgnoreBadComparer(object comparer);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
    internal static string PairToString(object key, object value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.List`1 : object {
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    private void AddEnumerable(IEnumerable`1<T> enumerable);
}
internal class System.Collections.Generic.LongEnumEqualityComparer`1 : EqualityComparer`1<T> {
    private LongEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
}
public class System.Collections.Generic.NonRandomizedStringEqualityComparer : EqualityComparer`1<string> {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<string> <Default>k__BackingField;
    internal static IEqualityComparer`1<string> Default { get; }
    private NonRandomizedStringEqualityComparer(SerializationInfo information, StreamingContext context);
    private static NonRandomizedStringEqualityComparer();
    [CompilerGeneratedAttribute]
internal static IEqualityComparer`1<string> get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    public virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    public virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public virtual int GetHashCode(Nullable`1<T> obj);
    internal virtual int IndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    internal virtual int LastIndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.UInt32EnumComparer`1 : Comparer`1<T> {
    private UInt32EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Collections.Generic.UInt64EnumComparer`1 : Comparer`1<T> {
    private UInt64EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public void Append(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow();
}
internal static class System.Collections.HashHelpers : object {
    public static Int32[] primes;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    internal static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    internal static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Hashtable : object {
    private bucket[] buckets;
    private int count;
    private int occupancy;
    private int loadsize;
    private float loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isWriterInProgress;
    private ICollection keys;
    private ICollection values;
    private IEqualityComparer _keycomparer;
    private object _syncRoot;
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    public Hashtable(IEqualityComparer equalityComparer);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize, bool forceNewHashCode);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode);
    public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
internal interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ListDictionaryInternal : object {
    private DictionaryNode head;
    private int version;
    private int count;
    private object _syncRoot;
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.Collection`1 : object {
    private IList`1<T> items;
    private object _syncRoot;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static bool IsCompatibleObject(object value);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private IList`1<T> list;
    private object _syncRoot;
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
internal static class System.CommonlyUsedGenericInstantiations : object {
    private static CommonlyUsedGenericInstantiations();
    private static T NullableHelper();
    private static void SZArrayHelper(SZArrayHelper oSZArrayHelper);
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper>d__3`1")]
private static void AsyncHelper();
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper2>d__4`1")]
private static Task`1<string> AsyncHelper2();
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper3>d__5")]
private static Task AsyncHelper3();
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    private object _value;
    public object Value { get; }
    public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    private EditorBrowsableState browsableState;
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
[ExtensionAttribute]
public static class System.Convert : object {
    internal static Type[] ConvertTypes;
    private static Type EnumType;
    internal static Char[] base64Table;
    public static object DBNull;
    private static SByte[] s_decodingMap;
    private static Convert();
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    private static void ThrowCharOverflowException();
    private static void ThrowByteOverflowException();
    private static void ThrowSByteOverflowException();
    private static void ThrowInt16OverflowException();
    private static void ThrowUInt16OverflowException();
    private static void ThrowInt32OverflowException();
    private static void ThrowUInt32OverflowException();
    private static void ThrowInt64OverflowException();
    private static void ThrowUInt64OverflowException();
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    public static string ToString(byte value, int toBase);
    public static string ToString(short value, int toBase);
    public static string ToString(int value, int toBase);
    public static string ToString(long value, int toBase);
    public static string ToBase64String(Byte[] inArray);
    public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
    private static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks);
    private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
    public static Byte[] FromBase64String(string s);
    public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private static void CopyToTempBufferWithoutWhiteSpace(ReadOnlySpan`1<char> chars, Span`1<char> tempBuffer, Int32& consumed, Int32& charsWritten);
    [ExtensionAttribute]
private static bool IsSpace(char c);
    public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    private static Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength);
    private static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
    private static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> utf16, Span`1<byte> bytes, Int32& consumed, Int32& written);
    private static int Decode(Char& encodedChars, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
internal class System.CoreLib : object {
    public static string FixupCoreLibName(string strToFixup);
}
internal class System.CrossAppDomainMarshaledException : SystemException {
    public CrossAppDomainMarshaledException(string message, int errorCode);
    internal virtual string InternalToString();
}
internal class System.CtorDelegate : MulticastDelegate {
    public CtorDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CultureAwareComparer : StringComparer {
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    internal CultureAwareComparer(CultureInfo culture, CompareOptions options);
    internal CultureAwareComparer(CompareInfo compareInfo, CompareOptions options);
    private CultureAwareComparer(SerializationInfo info, StreamingContext context);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Currency : ValueType {
    internal long m_value;
    public Currency(decimal value);
    internal Currency(long value, int ignored);
    public static Currency FromOACurrency(long cy);
    public long ToOACurrency();
    public static decimal ToDecimal(Currency c);
    private static void FCallToDecimal(Decimal& result, Currency c);
}
[ObsoleteAttribute("System.CurrentSystemTimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo.Local instead.")]
internal class System.CurrentSystemTimeZone : TimeZone {
    private Hashtable m_CachedDaylightChanges;
    private long m_ticksOffset;
    private string m_standardName;
    private string m_daylightName;
    public string StandardName { get; }
    public string DaylightName { get; }
    private DaylightTime GetCachedDaylightChanges(int year);
    public virtual string get_StandardName();
    public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DaylightTime GetDaylightChanges(int year);
    private static DaylightTime CreateDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    internal DataMisalignedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DateTime : ValueType {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    public static DateTime UnixEpoch;
    private ulong _dateData;
    public static DateTime UtcNow { get; }
    internal long InternalTicks { get; }
    private ulong InternalKind { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public DateTime(long ticks);
    private DateTime(ulong dateData);
    public DateTime(long ticks, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    private DateTime(SerializationInfo info, StreamingContext context);
    private static DateTime();
    public static DateTime get_UtcNow();
    internal static long GetSystemTimeAsFileTime();
    internal long get_InternalTicks();
    private ulong get_InternalKind();
    public DateTime Add(TimeSpan value);
    private DateTime Add(double value, int scale);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    private static long DateToTicks(int year, int month, int day);
    private static long TimeToTicks(int hour, int minute, int second);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    internal static DateTime FromBinaryRaw(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    public DateTime get_Date();
    private int GetDatePart(int part);
    internal void GetDatePart(Int32& year, Int32& month, Int32& day);
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public virtual int GetHashCode();
    public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private static double TicksToOADate(long value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    internal DateTime ToLocalTime(bool throwOnOverflow);
    public string ToLongDateString();
    public string ToLongTimeString();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
}
internal static class System.DateTimeFormat : object {
    internal static TimeSpan NullOffset;
    internal static Char[] allStandardFormats;
    internal static DateTimeFormatInfo InvariantFormatInfo;
    internal static String[] InvariantAbbreviatedMonthNames;
    internal static String[] InvariantAbbreviatedDayNames;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
    private static void HebrewFormatDigits(StringBuilder outputBuffer, int digits);
    internal static int ParseRepeatPattern(ReadOnlySpan`1<char> format, int pos, char patternChar);
    private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
    private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
    private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
    internal static int ParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result);
    internal static int ParseNextChar(ReadOnlySpan`1<char> format, int pos);
    private static bool IsUseGenitiveForm(ReadOnlySpan`1<char> format, int index, int tokenLen, char patternToMatch);
    private static StringBuilder FormatCustomized(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset, StringBuilder result);
    private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, ReadOnlySpan`1<char> format, int tokenLen, bool timeOnly, StringBuilder result);
    private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result);
    private static void Append2DigitNumber(StringBuilder result, int val);
    internal static string GetRealFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan& offset);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider, TimeSpan offset);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider, TimeSpan offset);
    private static StringBuilder FormatStringBuilder(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset);
    private static bool TryFormatO(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static bool TryFormatR(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static void WriteTwoDecimalDigits(UInt32 value, Span`1<char> destination, int offset);
    private static void WriteFourDecimalDigits(UInt32 value, Span`1<char> buffer, int startingIndex);
    private static void WriteDigits(ulong value, Span`1<char> buffer);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
    internal static void InvalidFormatForLocal(ReadOnlySpan`1<char> format, DateTime dateTime);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DateTimeOffset : ValueType {
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset UnixEpoch;
    private DateTime _dateTime;
    private short _offsetMinutes;
    public static DateTimeOffset Now { get; }
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    private DateTime ClockDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    private DateTimeOffset(SerializationInfo info, StreamingContext context);
    private static DateTimeOffset();
    public static DateTimeOffset get_Now();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    private DateTime get_ClockDateTime();
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public long ToUnixTimeSeconds();
    public long ToUnixTimeMilliseconds();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    private static short ValidateOffset(TimeSpan offset);
    private static DateTime ValidateDate(DateTime dateTime, TimeSpan offset);
    private static DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
}
internal static class System.DateTimeParse : object {
    internal static MatchNumberDelegate m_hebrewNumberParser;
    private static DS[][] dateParsingStates;
    private static DateTimeParse();
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    private static bool MatchWord(__DTString& str, string target);
    private static bool GetTimeZoneName(__DTString& str);
    internal static bool IsDigit(char ch);
    private static bool ParseFraction(__DTString& str, Double& result);
    private static bool ParseTimeZone(__DTString& str, TimeSpan& result);
    private static bool HandleTimeZone(__DTString& str, DateTimeResult& result);
    private static bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles);
    private static bool VerifyValidPunctuation(__DTString& str);
    private static bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear);
    private static bool SetDateYMD(DateTimeResult& result, int year, int month, int day);
    private static bool SetDateMDY(DateTimeResult& result, int month, int day, int year);
    private static bool SetDateDMY(DateTimeResult& result, int day, int month, int year);
    private static bool SetDateYDM(DateTimeResult& result, int year, int day, int month);
    private static void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles);
    private static bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw);
    private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw);
    private static bool AdjustHour(Int32& hour, TM timeMark);
    private static bool GetTimeOfN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok);
    internal static bool ProcessHebrewTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    private static bool DetermineTimeZoneAdjustments(__DTString& str, DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly);
    private static bool DateTimeOffsetTimeZonePostProcessing(__DTString& str, DateTimeResult& result, DateTimeStyles styles);
    private static bool AdjustTimeZoneToUniversal(DateTimeResult& result);
    private static bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly);
    private static bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    private static bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result);
    private static bool ParseSign(__DTString& str, Boolean& result);
    private static bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result);
    private static bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result);
    private static DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles);
    private static bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseJapaneseEraStart(__DTString& str, DateTimeFormatInfo dtfi);
    private static bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result);
    internal static bool TryParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result, Int32& returnValue);
    private static bool DoStrictParse(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result);
    private static Exception GetDateTimeParseException(DateTimeResult& result);
}
internal class System.DateTimeRawInfo : ValueType {
    private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool hasSameDateAndTimeSeparators;
    internal void Init(Int32* numberBuffer);
    internal void AddNumber(int value);
    internal int GetNumber(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal string failureMessageID;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal ReadOnlySpan`1<char> originalDateTimeString;
    internal ReadOnlySpan`1<char> failedFormatSpecifier;
    internal void Init(ReadOnlySpan`1<char> originalDateTimeString);
    internal void SetDate(int year, int month, int day);
    internal void SetBadFormatSpecifierFailure();
    internal void SetBadFormatSpecifierFailure(ReadOnlySpan`1<char> failedFormatSpecifier);
    internal void SetBadDateTimeFailure();
    internal void SetFailure(ParseFailureKind failure, string failureMessageID);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
public class System.DBNull : object {
    public static DBNull Value;
    private DBNull(SerializationInfo info, StreamingContext context);
    private static DBNull();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NonVersionableAttribute]
public class System.Decimal : ValueType {
    private static UInt32[] Powers10;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("27", "128", "0", "0", "1")]
private static decimal NearNegativeZero;
    [DecimalConstantAttribute("27", "0", "0", "0", "1")]
private static decimal NearPositiveZero;
    private int flags;
    private int hi;
    private int lo;
    private int mid;
    internal UInt32 High { get; }
    internal UInt32 Low { get; }
    internal UInt32 Mid { get; }
    internal bool IsNegative { get; }
    internal int Scale { get; }
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public Decimal(float value);
    public Decimal(double value);
    internal Decimal(Currency value);
    public Decimal(Int32[] bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private Decimal(int lo, int mid, int hi, int flags);
    private static Decimal();
    internal UInt32 get_High();
    internal UInt32 get_Low();
    internal UInt32 get_Mid();
    public static long ToOACurrency(decimal value);
    public static decimal FromOACurrency(long cy);
    private void SetBits(Int32[] bits);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    internal static decimal Abs(Decimal& d);
    public static decimal Add(decimal d1, decimal d2);
    internal bool get_IsNegative();
    internal int get_Scale();
    private static void FCallAddSub(Decimal& d1, Decimal& d2, byte bSign);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    private static int FCallCompare(Decimal& d1, Decimal& d2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    private static void FCallDivide(Decimal& d1, Decimal& d2);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(decimal value);
    public virtual int GetHashCode();
    public static bool Equals(decimal d1, decimal d2);
    public static decimal Floor(decimal d);
    private static void FCallFloor(Decimal& d);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static Int32[] GetBits(decimal d);
    internal static void GetBytes(decimal d, Byte[] buffer);
    internal static decimal ToDecimal(Byte[] buffer);
    private static void InternalAddUInt32RawUnchecked(Decimal& value, UInt32 i);
    private static UInt32 InternalDivRemUInt32(Decimal& value, UInt32 divisor);
    private static void InternalRoundFromZero(Decimal& d, int decimalCount);
    internal static decimal Max(Decimal& d1, Decimal& d2);
    internal static decimal Min(Decimal& d1, Decimal& d2);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Multiply(decimal d1, decimal d2);
    private static void FCallMultiply(Decimal& d1, Decimal& d2);
    public static decimal Negate(decimal d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static void FCallRound(Decimal& d, int decimals);
    internal static int Sign(Decimal& d);
    public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    internal static Currency ToCurrency(decimal d);
    private static void FCallToCurrency(Currency& result, decimal d);
    public static double ToDouble(decimal d);
    internal static int FCallToInt32(decimal d);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static float ToSingle(decimal d);
    public static decimal Truncate(decimal d);
    private static void FCallTruncate(Decimal& d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_Increment(decimal d);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Division(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static UInt32 DecDivMod1E9(Decimal& value);
    [CompilerGeneratedAttribute]
internal static UInt32 <DecDivMod1E9>g__D32DivMod1E9|160_0(UInt32 hi32, UInt32& lo32);
}
internal class System.DefaultBinder : Binder {
    private static bool CanChangePrimitive(Type source, Type target);
    private static bool CanChangePrimitiveObjectToType(object source, Type type);
    private static bool CanConvertPrimitive(RuntimeType source, RuntimeType target);
    private static bool CanConvertPrimitiveObjectToType(object source, RuntimeType type);
    public sealed virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    public sealed virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public sealed virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    public static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    private static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("2")]
public abstract class System.Delegate : object {
    internal object _target;
    internal object _methodBase;
    internal IntPtr _methodPtr;
    internal IntPtr _methodPtrAux;
    public MethodInfo Method { get; }
    public object Target { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    public object DynamicInvoke(Object[] args);
    protected virtual object DynamicInvokeImpl(Object[] args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Combine(Delegate[] delegates);
    public virtual Delegate[] GetInvocationList();
    public MethodInfo get_Method();
    protected virtual MethodInfo GetMethodImpl();
    public object get_Target();
    public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    protected virtual Delegate CombineImpl(Delegate d);
    protected virtual Delegate RemoveImpl(Delegate d);
    public virtual object Clone();
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static Delegate CreateDelegateNoSecurityCheck(Type type, object target, RuntimeMethodHandle method);
    internal static Delegate CreateDelegateNoSecurityCheck(RuntimeType type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    internal static Delegate CreateDelegateInternal(RuntimeType rtType, RuntimeMethodInfo rtMethod, object firstArgument, DelegateBindingFlags flags);
    private bool BindToMethodName(object target, RuntimeType methodType, string method, DelegateBindingFlags flags);
    private bool BindToMethodInfo(object target, IRuntimeMethodInfo method, RuntimeType methodType, DelegateBindingFlags flags);
    private static MulticastDelegate InternalAlloc(RuntimeType type);
    internal static MulticastDelegate InternalAllocLike(Delegate d);
    internal static bool InternalEqualTypes(object a, object b);
    private void DelegateConstruct(object target, IntPtr slot);
    internal IntPtr GetMulticastInvoke();
    internal IntPtr GetInvokeMethod();
    internal IRuntimeMethodInfo FindMethodHandle();
    internal static bool InternalEqualMethodHandles(Delegate left, Delegate right);
    internal IntPtr AdjustTarget(object target, IntPtr methodPtr);
    internal IntPtr GetCallStub(IntPtr methodPtr);
    internal virtual object GetTarget();
    internal static bool CompareUnmanagedFunctionPtrs(Delegate d1, Delegate d2);
}
internal enum System.DelegateBindingFlags : Enum {
    public int value__;
    public static DelegateBindingFlags StaticMethodOnly;
    public static DelegateBindingFlags InstanceMethodOnly;
    public static DelegateBindingFlags OpenDelegateOnly;
    public static DelegateBindingFlags ClosedDelegateOnly;
    public static DelegateBindingFlags NeverCloseOverNull;
    public static DelegateBindingFlags CaselessMatching;
    public static DelegateBindingFlags SkipSecurityChecks;
    public static DelegateBindingFlags RelaxedSignature;
}
[ConditionalAttribute("CODE_ANALYSIS")]
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public SuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConditionString>k__BackingField;
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    [CompilerGeneratedAttribute]
public string get_ConditionString();
}
public static class System.Diagnostics.Contracts.Contract : object {
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition, string userMessage);
    public static void Requires(bool condition);
    public static void Requires(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    public static T Result();
    public static T ValueAtReturn(T& value);
    public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EndContractBlock();
    private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
    [DebuggerNonUserCodeAttribute]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[AttributeUsageAttribute("5124")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    private Type _typeWithContracts;
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    private Type _typeIAmAContractFor;
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Diagnostics.Contracts.ContractException : Exception {
    private ContractFailureKind _kind;
    private string _userMessage;
    private string _condition;
    public ContractFailureKind Kind { get; }
    public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    private ContractException(SerializationInfo info, StreamingContext context);
    public ContractFailureKind get_Kind();
    public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    private ContractFailureKind _failureKind;
    private string _message;
    private string _condition;
    private Exception _originalException;
    private bool _handled;
    private bool _unwind;
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    public void SetHandled();
    public bool get_Unwind();
    public void SetUnwind();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    private string _category;
    private string _setting;
    private bool _enabled;
    private string _value;
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    public string get_Value();
}
[AttributeUsageAttribute("256")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    private string _publicName;
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("237")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    private bool _value;
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[AttributeUsageAttribute("6884")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
public static class System.Diagnostics.Debug : object {
    private static object s_lock;
    [ThreadStaticAttribute]
private static int s_indentLevel;
    private static int s_indentSize;
    private static bool s_needIndent;
    private static string s_indentString;
    internal static Action`4<string, string, string, string> s_ShowDialog;
    internal static Action`1<string> s_WriteCore;
    private static bool s_shouldWriteToStdErr;
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static Debug();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    internal static void ContractFailure(bool condition, string message, string detailMessage, string failureKindMessage);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    private static string FormatAssert(string stackTrace, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
    private static string GetIndentString();
    private static void ShowDialog(string stackTrace, string message, string detailMessage, string errorSource);
    private static void WriteCore(string message);
    private static void WriteToDebugger(string message);
    private static void WriteToStderr(string message);
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggingModes <DebuggingFlags>k__BackingField;
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    [CompilerGeneratedAttribute]
public DebuggingModes get_DebuggingFlags();
}
public static class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    private static Debugger();
    public static void Break();
    private static void BreakCanThrow();
    private static void BreakInternal();
    public static bool Launch();
    private static void NotifyOfCrossThreadDependencySlow();
    public static void NotifyOfCrossThreadDependency();
    private static bool LaunchInternal();
    public static bool get_IsAttached();
    public static void Log(int level, string category, string message);
    public static bool IsLogging();
    private static void CustomNotification(ICustomDebuggerNotification data);
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggerBrowsableState <State>k__BackingField;
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    [CompilerGeneratedAttribute]
public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <ProxyTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerTypeProxyAttribute(Type type);
    public DebuggerTypeProxyAttribute(string typeName);
    [CompilerGeneratedAttribute]
public string get_ProxyTypeName();
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <VisualizerObjectSourceTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualizerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string VisualizerObjectSourceTypeName { get; }
    public string VisualizerTypeName { get; }
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerVisualizerAttribute(string visualizerTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer);
    public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    [CompilerGeneratedAttribute]
public string get_VisualizerObjectSourceTypeName();
    [CompilerGeneratedAttribute]
public string get_VisualizerTypeName();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
internal class System.Diagnostics.EditAndContinueHelper : object {
    private object _objectReference;
}
internal interface System.Diagnostics.ICustomDebuggerNotification {
}
public class System.Diagnostics.StackFrame : object {
    private MethodBase method;
    private int offset;
    private int ILOffset;
    private string strFileName;
    private int iLineNumber;
    private int iColumnNumber;
    [OptionalFieldAttribute]
private bool fIsLastFrameFromForeignExceptionStackTrace;
    public static int OFFSET_UNKNOWN;
    public StackFrame(bool fNeedFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool fNeedFileInfo);
    internal StackFrame(bool DummyFlag1, bool DummyFlag2);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    internal void InitMembers();
    internal virtual void SetMethodBase(MethodBase mb);
    internal virtual void SetOffset(int iOffset);
    internal virtual void SetILOffset(int iOffset);
    internal virtual void SetFileName(string strFName);
    internal virtual void SetLineNumber(int iLine);
    internal virtual void SetColumnNumber(int iCol);
    internal virtual void SetIsLastFrameFromForeignExceptionStackTrace(bool fIsLastFrame);
    internal virtual bool GetIsLastFrameFromForeignExceptionStackTrace();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual int GetILOffset();
    public virtual string GetFileName();
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    public virtual string ToString();
    private void BuildStackFrame(int skipFrames, bool fNeedFileInfo);
}
internal class System.Diagnostics.StackFrameHelper : object {
    private Thread targetThread;
    private Int32[] rgiOffset;
    private Int32[] rgiILOffset;
    private object dynamicMethods;
    private IntPtr[] rgMethodHandle;
    private String[] rgAssemblyPath;
    private IntPtr[] rgLoadedPeAddress;
    private Int32[] rgiLoadedPeSize;
    private IntPtr[] rgInMemoryPdbAddress;
    private Int32[] rgiInMemoryPdbSize;
    private Int32[] rgiMethodToken;
    private String[] rgFilename;
    private Int32[] rgiLineNumber;
    private Int32[] rgiColumnNumber;
    private Boolean[] rgiLastFrameFromForeignExceptionStackTrace;
    private int iFrameCount;
    private static GetSourceLineInfoDelegate s_getSourceLineInfo;
    [ThreadStaticAttribute]
private static int t_reentrancy;
    public StackFrameHelper(Thread target);
    private static StackFrameHelper();
    internal void InitializeSourceInfo(int iSkip, bool fNeedFileInfo, Exception exception);
    public virtual MethodBase GetMethodBase(int i);
    public virtual int GetOffset(int i);
    public virtual int GetILOffset(int i);
    public virtual string GetFilename(int i);
    public virtual int GetLineNumber(int i);
    public virtual int GetColumnNumber(int i);
    public virtual bool IsLastFrameFromForeignExceptionStackTrace(int i);
    public virtual int GetNumberOfFrames();
}
public class System.Diagnostics.StackTrace : object {
    private StackFrame[] frames;
    private int m_iNumOfFrames;
    public static int METHODS_TO_SKIP;
    private int m_iMethodsToSkip;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    internal static void GetStackFramesInternal(StackFrameHelper sfh, int iSkip, bool fNeedFileInfo, Exception e);
    internal static int CalculateFramesToSkip(StackFrameHelper StackF, int iNumFrames);
    private void CaptureStackTrace(int iSkip, bool fNeedFileInfo, Thread targetThread, Exception e);
    public virtual int get_FrameCount();
    public virtual StackFrame GetFrame(int index);
    public virtual StackFrame[] GetFrames();
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
    private static bool ShowInStackTrace(MethodBase mb);
    private static bool TryResolveStateMachineMethod(MethodBase& method, Type& declaringType);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetSource(Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
}
internal interface System.Diagnostics.SymbolStore.ISymbolWriter {
    public abstract virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void CloseMethod();
    public abstract virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual int OpenScope(int startOffset);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public abstract virtual void UsingNamespace(string fullName);
}
internal enum System.Diagnostics.SymbolStore.SymAddressKind : Enum {
    public int value__;
    public static SymAddressKind ILOffset;
    public static SymAddressKind NativeRVA;
    public static SymAddressKind NativeRegister;
    public static SymAddressKind NativeRegisterRelative;
    public static SymAddressKind NativeOffset;
    public static SymAddressKind NativeRegisterRegister;
    public static SymAddressKind NativeRegisterStack;
    public static SymAddressKind NativeStackRegister;
    public static SymAddressKind BitField;
    public static SymAddressKind NativeSectionOffset;
}
internal class System.Diagnostics.SymbolStore.SymbolToken : ValueType {
    internal int m_token;
    public SymbolToken(int val);
    public int GetToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SymbolToken obj);
}
internal class System.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    public static ActivityTracker Instance { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId);
    public void Enable();
    public static ActivityTracker get_Instance();
    private ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class System.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class System.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
internal class System.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddNullTerminatedString(string value);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class System.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class System.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class System.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum System.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventProviderType eventProviderType;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    public EventCommand Command { get; internal set; }
    public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
}
internal class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    internal string Name { get; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public class System.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    public static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
internal class System.Diagnostics.Tracing.EventParameterInfo : ValueType {
    internal string ParameterName;
    internal Type ParameterType;
    internal TraceLoggingTypeInfo TypeInfo;
    internal void SetInfo(string name, Type type, TraceLoggingTypeInfo typeInfo);
    internal bool GenerateMetadata(Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    private static bool GenerateMetadataForProperty(PropertyAnalysis property, Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    internal int GetMetadataLength();
    private static UInt32 GetMetadataLengthForProperty(PropertyAnalysis property);
    private static TypeCode GetTypeCodeExtended(Type parameterType);
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.EventPayload : object {
    private List`1<string> m_names;
    private List`1<object> m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(List`1<string> payloadNames, List`1<object> payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.EventPayload/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal static class System.Diagnostics.Tracing.EventPipe : object {
    private static ulong s_sessionID;
    private static EventPipe();
    internal static void Enable(EventPipeConfiguration configuration);
    internal static void Disable();
}
internal class System.Diagnostics.Tracing.EventPipeConfiguration : object {
    private string m_outputFile;
    private UInt32 m_circularBufferSizeInMB;
    private List`1<EventPipeProviderConfiguration> m_providers;
    private TimeSpan m_minTimeBetweenSamples;
    private ulong m_multiFileTraceLengthInSeconds;
    internal string OutputFile { get; }
    internal UInt32 CircularBufferSizeInMB { get; }
    internal ulong MultiFileTraceLengthInSeconds { get; }
    internal EventPipeProviderConfiguration[] Providers { get; }
    internal long ProfilerSamplingRateInNanoseconds { get; }
    internal EventPipeConfiguration(string outputFile, UInt32 circularBufferSizeInMB);
    internal string get_OutputFile();
    internal UInt32 get_CircularBufferSizeInMB();
    internal ulong get_MultiFileTraceLengthInSeconds();
    internal EventPipeProviderConfiguration[] get_Providers();
    internal long get_ProfilerSamplingRateInNanoseconds();
    internal void EnableProvider(string providerName, ulong keywords, UInt32 loggingLevel);
    internal void EnableProviderWithFilter(string providerName, ulong keywords, UInt32 loggingLevel, string filterData);
    private void EnableProviderConfiguration(EventPipeProviderConfiguration providerConfig);
    internal void EnableProviderRange(EventPipeProviderConfiguration[] providerConfigs);
    internal void SetProfilerSamplingRate(TimeSpan minTimeBetweenSamples);
    internal void SetMultiFileTraceLength(ulong traceLengthInSeconds);
}
internal class System.Diagnostics.Tracing.EventPipeController : object {
    private static string DefaultAppName;
    private static string NetPerfFileExtension;
    private static string ConfigFileSuffix;
    private static int EnabledPollingIntervalMilliseconds;
    private static int DisabledPollingIntervalMilliseconds;
    private static UInt32 DefaultCircularBufferMB;
    private static Char[] ProviderConfigDelimiter;
    private static Char[] ConfigComponentDelimiter;
    private static String[] ConfigFileLineDelimiters;
    private static char ConfigEntryDelimiter;
    private static string ConfigKey_Providers;
    private static string ConfigKey_CircularMB;
    private static string ConfigKey_OutputPath;
    private static string ConfigKey_ProcessID;
    private static string ConfigKey_MultiFileSec;
    private static EventPipeProviderConfiguration[] DefaultProviderConfiguration;
    private static EventPipeController s_controllerInstance;
    private Timer m_timer;
    private string m_configFilePath;
    private DateTime m_configFileUpdateTime;
    private string m_traceFilePath;
    private bool m_configFileExists;
    private static int s_Config_EnableEventPipe;
    private static string s_Config_EventPipeConfig;
    private static UInt32 s_Config_EventPipeCircularMB;
    private static string s_Config_EventPipeOutputPath;
    private static int Config_EnableEventPipe { get; }
    private static string Config_EventPipeConfig { get; }
    private static UInt32 Config_EventPipeCircularMB { get; }
    private static string Config_EventPipeOutputPath { get; }
    private static EventPipeController();
    internal static void Initialize();
    private void PollForTracingCommand(object state);
    private static EventPipeConfiguration BuildConfigFromFile(string configFilePath);
    private static EventPipeConfiguration BuildConfigFromEnvironment();
    private static string BuildConfigFileName();
    private static string BuildTraceFileName();
    private static string GetAppName();
    private static void SetProviderConfiguration(string strConfig, EventPipeConfiguration config);
    private static int get_Config_EnableEventPipe();
    private static string get_Config_EventPipeConfig();
    private static UInt32 get_Config_EventPipeCircularMB();
    private static string get_Config_EventPipeOutputPath();
}
internal class System.Diagnostics.Tracing.EventPipeEventDispatcher : object {
    internal static EventPipeEventDispatcher Instance;
    private IntPtr m_RuntimeProviderID;
    private ulong m_sessionID;
    private DateTime m_syncTimeUtc;
    private long m_syncTimeQPC;
    private long m_timeQPCFrequency;
    private bool m_stopDispatchTask;
    private Task m_dispatchTask;
    private object m_dispatchControlLock;
    private Dictionary`2<EventListener, EventListenerSubscription> m_subscriptions;
    private static EventPipeEventDispatcher();
    internal void SendCommand(EventListener eventListener, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeywords);
    internal void RemoveEventListener(EventListener listener);
    private void CommitDispatchConfiguration();
    private void StartDispatchTask();
    private void StopDispatchTask();
    private void DispatchEventsToEventListeners();
    private DateTime TimeStampToDateTime(long timeStamp);
}
internal class System.Diagnostics.Tracing.EventPipeEventInstanceData : ValueType {
    internal IntPtr ProviderID;
    internal UInt32 EventID;
    internal UInt32 ThreadID;
    internal long TimeStamp;
    internal Guid ActivityId;
    internal Guid ChildActivityId;
    internal IntPtr Payload;
    internal UInt32 PayloadLength;
}
internal class System.Diagnostics.Tracing.EventPipeEventProvider : object {
    private IntPtr m_provHandle;
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventWriteTransferWrapper(long registrationHandle, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal static class System.Diagnostics.Tracing.EventPipeInternal : object {
    internal static ulong Enable(string outputFile, UInt32 circularBufferSizeInMB, long profilerSamplingRateInNanoseconds, EventPipeProviderConfiguration[] providers, int numProviders, ulong multiFileTraceLengthInSeconds);
    internal static void Disable(ulong sessionID);
    internal static IntPtr CreateProvider(string providerName, EtwEnableCallback callbackFunc);
    internal static IntPtr DefineEvent(IntPtr provHandle, UInt32 eventID, long keywords, UInt32 eventVersion, UInt32 level, Void* pMetadata, UInt32 metadataLength);
    internal static IntPtr GetProvider(string providerName);
    internal static void DeleteProvider(IntPtr provHandle);
    internal static int EventActivityIdControl(UInt32 controlCode, Guid& activityId);
    internal static void WriteEvent(IntPtr eventHandle, UInt32 eventID, Void* pData, UInt32 length, Guid* activityId, Guid* relatedActivityId);
    internal static void WriteEventData(IntPtr eventHandle, UInt32 eventID, EventData* pEventData, UInt32 dataCount, Guid* activityId, Guid* relatedActivityId);
    internal static bool GetSessionInfo(ulong sessionID, EventPipeSessionInfo* pSessionInfo);
    internal static bool GetNextEvent(EventPipeEventInstanceData* pInstance);
}
internal class System.Diagnostics.Tracing.EventPipeMetadataGenerator : object {
    public static EventPipeMetadataGenerator Instance;
    private static EventPipeMetadataGenerator();
    public Byte[] GenerateEventMetadata(EventMetadata eventMetadata);
    public Byte[] GenerateEventMetadata(int eventId, string eventName, EventKeywords keywords, EventLevel level, UInt32 version, TraceLoggingEventTypes eventTypes);
    private Byte[] GenerateMetadata(int eventId, string eventName, long keywords, UInt32 level, UInt32 version, EventParameterInfo[] parameters);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, Byte* src, UInt32 srcLength);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, UInt32 value);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, long value);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, char value);
}
internal static class System.Diagnostics.Tracing.EventPipePayloadDecoder : object {
    internal static Object[] DecodePayload(EventMetadata& metadata, ReadOnlySpan`1<byte> payload);
    private static ulong ReadUnalignedUInt64(ReadOnlySpan`1& payload);
    private static Guid ReadUnalignedGuid(ReadOnlySpan`1& payload);
}
internal class System.Diagnostics.Tracing.EventPipeProviderConfiguration : ValueType {
    private string m_providerName;
    private ulong m_keywords;
    private UInt32 m_loggingLevel;
    private string m_filterData;
    internal string ProviderName { get; }
    internal ulong Keywords { get; }
    internal UInt32 LoggingLevel { get; }
    internal string FilterData { get; }
    internal EventPipeProviderConfiguration(string providerName, ulong keywords, UInt32 loggingLevel, string filterData);
    internal string get_ProviderName();
    internal ulong get_Keywords();
    internal UInt32 get_LoggingLevel();
    internal string get_FilterData();
}
internal class System.Diagnostics.Tracing.EventPipeSessionInfo : ValueType {
    internal long StartTimeAsUTCFileTime;
    internal long StartTimeStamp;
    internal long TimeStampFrequency;
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    internal IEventProvider m_eventProvider;
    private EtwEnableCallback m_etwCallback;
    private long m_regHandle;
    private byte m_level;
    private long m_anyKeywordMask;
    private long m_allKeywordMask;
    private List`1<SessionInfo> m_liveSessions;
    private bool m_enabled;
    private string m_providerName;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static Int32[] nibblebits;
    protected EventLevel Level { get; }
    protected EventKeywords MatchAnyKeyword { get; }
    internal EventProvider(EventProviderType providerType);
    private static EventProvider();
    internal void Register(EventSource eventSource);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, long anyKeyword, long allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected EventKeywords get_MatchAnyKeyword();
    private static int FindNull(Byte[] buffer, int idx);
    private List`1<Tuple`2<SessionInfo, bool>> GetSessions();
    private static void GetSessionInfoCallback(int etwSessionId, long matchAllKeywords, List`1& sessionList);
    private void GetSessionInfo(SessionInfoCallback action, List`1& sessionList);
    private static int IndexOfSessionInList(List`1<SessionInfo> sessions, int etwSessionId);
    private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(int error);
    private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    protected internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    internal bool WriteEventRaw(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback);
    private UInt32 EventUnregister(long registrationHandle);
    private static int bitcount(UInt32 n);
    private static int bitindex(UInt32 n);
}
internal enum System.Diagnostics.Tracing.EventProviderType : Enum {
    public int value__;
    public static EventProviderType None;
    public static EventProviderType ETW;
    public static EventProviderType EventPipe;
}
public class System.Diagnostics.Tracing.EventSource : object {
    private static bool m_EventSourcePreventRecursion;
    private static EventListener persistent_Xplat_Listener;
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceDisposed;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_etwProvider;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_eventPipeProvider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    internal static UInt32 s_currentPid;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    [ThreadStaticAttribute]
private static bool m_EventSourceInDecodeObject;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    private static Byte[] namespaceBytes;
    private Byte[] providerMetadata;
    private TraceLoggingEventHandleTable m_eventHandleTable;
    public static Guid CurrentThreadActivityId { get; }
    public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    internal static Guid InternalCurrentThreadActivityId { get; }
    internal static Guid FallbackActivityId { get; }
    public Exception ConstructionException { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; private set; }
    private bool SelfDescribingEvents { get; private set; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    public EventSource(string eventSourceName);
    public EventSource(string eventSourceName, EventSourceSettings config);
    public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    public static Guid get_CurrentThreadActivityId();
    private int GetParameterCount(EventMetadata eventData);
    private Type GetDataType(EventMetadata eventData, int parameterId);
    private static string GetResourceString(string key, Object[] args);
    public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    public static IEnumerable`1<EventSource> GetSources();
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    internal static Guid get_InternalCurrentThreadActivityId();
    internal static Guid get_FallbackActivityId();
    public Exception get_ConstructionException();
    public string GetTrait(string key);
    public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    private void DefineEventPipeEvents();
    internal virtual void GetMetadata(Guid& eventSourceGuid, String& eventSourceName, EventMetadata[]& eventData, Byte[]& manifestBytes);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void WriteEventRaw(string eventName, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private object DecodeObject(int eventId, int parameterId, EventData*& data);
    private EventDispatcher GetDispatcher(EventListener listener);
    private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(ParameterInfo[] infos, Object[] args);
    private void WriteToAllListeners(int eventId, Guid* activityID, Guid* childActivityID, int eventDataCount, EventData* data);
    internal void WriteToAllListeners(int eventId, UInt32* osThreadId, DateTime* timeStamp, Guid* activityID, Guid* childActivityID, Object[] args);
    private void DispatchToAllListeners(int eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs);
    private void WriteEventString(EventLevel level, long keywords, string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(string eventName, Exception innerEx);
    private void ValidateEventOpcodeForTransfer(EventMetadata& eventData, string eventName);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, EventProviderType eventProviderType, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    private void EnsureDescriptorsInitialized();
    private bool SendManifest(Byte[] rawManifest);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    private EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private void set_ThrowOnEventWriteErrors(bool value);
    private bool get_SelfDescribingEvents();
    private void set_SelfDescribingEvents(bool value);
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, Guid* pChildActivityId, EventPayload payload);
    [NonEventAttribute]
[ReliabilityContractAttribute("3", "2")]
private void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    private string m_message;
    private string m_eventName;
    private EventSource m_eventSource;
    private ReadOnlyCollection`1<string> m_payloadNames;
    private Guid m_activityId;
    private Nullable`1<long> m_osThreadId;
    internal EventTags m_tags;
    internal EventOpcode m_opcode;
    internal EventLevel m_level;
    internal EventKeywords m_keywords;
    public string EventName { get; internal set; }
    public int EventId { get; internal set; }
    public Guid ActivityId { get; internal set; }
    public Guid RelatedActivityId { get; internal set; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public EventTags Tags { get; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; }
    public long OSThreadId { get; internal set; }
    public DateTime TimeStamp { get; internal set; }
    internal EventWrittenEventArgs(EventSource eventSource);
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    public Guid get_ActivityId();
    internal void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public EventTags get_Tags();
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
    public long get_OSThreadId();
    internal void set_OSThreadId(long value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
internal void set_TimeStamp(DateTime value);
}
internal class System.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, ushort fixedCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, Byte[] custom);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.FrameworkEventSource : EventSource {
    public static FrameworkEventSource Log;
    public static bool IsInitialized { get; }
    private static FrameworkEventSource();
    public static bool get_IsInitialized();
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3, bool arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3);
    [EventAttribute("30")]
public void ThreadPoolEnqueueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolEnqueueWorkObject(object workID);
    [EventAttribute("31")]
public void ThreadPoolDequeueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolDequeueWorkObject(object workID);
    [EventAttribute("150")]
public void ThreadTransferSend(long id, int kind, string info, bool multiDequeues);
    [NonEventAttribute]
public void ThreadTransferSendObj(object id, int kind, string info, bool multiDequeues);
    [EventAttribute("151")]
public void ThreadTransferReceive(long id, int kind, string info);
    [NonEventAttribute]
public void ThreadTransferReceiveObj(object id, int kind, string info);
}
internal interface System.Diagnostics.Tracing.IEventProvider {
    public abstract virtual UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    public abstract virtual UInt32 EventUnregister(long registrationHandle);
    public abstract virtual int EventWriteTransferWrapper(long registrationHandle, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    public abstract virtual int EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    public abstract virtual IntPtr DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal class System.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    internal PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    private static String[] s_escapes;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    private ulong nextChannelKeywordBit;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    private static ManifestBuilder();
    private string GetTypeNameHelper(Type type);
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private EventChannelType EventChannelToChannelType(EventChannel channel);
    private EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel, ulong channelKeyword);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static List`1<CultureInfo> GetSupportedCultures(ResourceManager resources);
    private static string GetLevelName(EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private string GetKeywords(ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class System.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
    public IntPtr GetOrCreateEventHandle(EventProvider provider, TraceLoggingEventHandleTable eventHandleTable, EventDescriptor descriptor, TraceLoggingEventTypes eventTypes);
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.NoOpEventProvider : object {
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventWriteTransferWrapper(long registrationHandle, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal class System.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    private Func`2<PropertyValue, PropertyValue> valueGetter;
    public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    public static Func`2<object, PropertyValue> GetFactory(Type type);
    public object get_ReferenceValue();
    public Scalar get_ScalarValue();
    public int get_ScalarLength();
    public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
internal static class System.Diagnostics.Tracing.Resources : object {
    internal static string GetResourceString(string key, Object[] args);
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.RuntimeEventSource : EventSource {
    internal static string EventSourceName;
    internal static RuntimeEventSource Log;
    private static RuntimeEventSource();
    [EventAttribute("1")]
private void GCStart_V2(UInt32 Count, UInt32 Depth, UInt32 Reason, UInt32 Type, ushort ClrInstanceID, ulong ClientSequenceNumber);
    [EventAttribute("2")]
private void GCEnd_V1(UInt32 Count, UInt32 Depth, ushort ClrInstanceID);
    [EventAttribute("3")]
private void GCRestartEEEnd_V1(ushort ClrInstanceID);
    [EventAttribute("4")]
private void GCHeapStats_V1(ulong GenerationSize0, ulong TotalPromotedSize0, ulong GenerationSize1, ulong TotalPromotedSize1, ulong GenerationSize2, ulong TotalPromotedSize2, ulong GenerationSize3, ulong TotalPromotedSize3, ulong FinalizationPromotedSize, ulong FinalizationPromotedCount, UInt32 PinnedObjectCount, UInt32 SinkBlockCount, UInt32 GCHandleCount, ushort ClrInstanceID);
    [EventAttribute("5")]
private void GCCreateSegment_V1(ulong Address, ulong Size, UInt32 Type, ushort ClrInstanceID);
    [EventAttribute("6")]
private void GCFreeSegment_V1(ulong Address, ushort ClrInstanceID);
    [EventAttribute("7")]
private void GCRestartEEBegin_V1(ushort ClrInstanceID);
    [EventAttribute("8")]
private void GCSuspendEEEnd_V1(ushort ClrInstanceID);
    [EventAttribute("9")]
private void GCSuspendEEBegin_V1(UInt32 Reason, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("10")]
private void GCAllocationTick_V3(UInt32 AllocationAmount, UInt32 AllocationKind, ushort ClrInstanceID, ulong AllocationAmount64, IntPtr TypeID, string TypeName, UInt32 HeapIndex, IntPtr Address);
    [EventAttribute("11")]
private void GCCreateConcurrentThread_V1(ushort ClrInstanceID);
    [EventAttribute("12")]
private void GCTerminateConcurrentThread_V1(ushort ClrInstanceID);
    [EventAttribute("13")]
private void GCFinalizersEnd_V1(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("14")]
private void GCFinalizersBegin_V1(ushort ClrInstanceID);
    [EventAttribute("15")]
private void BulkType(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("16")]
private void GCBulkRootEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("17")]
private void GCBulkRootConditionalWeakTableElementEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("18")]
private void GCBulkNode(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("19")]
private void GCBulkEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("20")]
private void GCSampledObjectAllocationHigh(IntPtr Address, IntPtr TypeID, UInt32 ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID);
    [EventAttribute("21")]
private void GCBulkSurvivingObjectRanges(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("22")]
private void GCBulkMovedObjectRanges(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("23")]
private void GCGenerationRange(byte Generation, IntPtr RangeStart, ulong RangeUsedLength, ulong RangeReservedLength, ushort ClrInstanceID);
    [EventAttribute("25")]
private void GCMarkStackRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("26")]
private void GCMarkFinalizeQueueRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("27")]
private void GCMarkHandles(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("28")]
private void GCMarkOlderGenerationRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("29")]
private void FinalizeObject(IntPtr TypeID, IntPtr ObjectID, ushort ClrInstanceID);
    [EventAttribute("30")]
private void SetGCHandle(IntPtr HandleID, IntPtr ObjectID, UInt32 Kind, UInt32 Generation, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("31")]
private void DestroyGCHandle(IntPtr HandleID, ushort ClrInstanceID);
    [EventAttribute("32")]
private void GCSampledObjectAllocationLow(IntPtr Address, IntPtr TypeID, UInt32 ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID);
    [EventAttribute("33")]
private void PinObjectAtGCTime(IntPtr HandleID, IntPtr ObjectID, ulong ObjectSize, string TypeName, ushort ClrInstanceID);
    [EventAttribute("35")]
private void GCTriggered(UInt32 Reason, ushort ClrInstanceID);
    [EventAttribute("36")]
private void GCBulkRootCCW(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("37")]
private void GCBulkRCW(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("38")]
private void GCBulkRootStaticVar(UInt32 Count, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("39")]
private void GCDynamicEvent(string Name, UInt32 DataSize);
    [EventAttribute("40")]
private void WorkerThreadCreate(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("41")]
private void WorkerThreadTerminate(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("42")]
private void WorkerThreadRetire(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("43")]
private void WorkerThreadUnretire(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("44")]
private void IOThreadCreate_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("45")]
private void IOThreadTerminate_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("46")]
private void IOThreadRetire_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("47")]
private void IOThreadUnretire_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("48")]
private void ThreadpoolSuspensionSuspendThread(UInt32 ClrThreadID, UInt32 CpuUtilization);
    [EventAttribute("49")]
private void ThreadpoolSuspensionResumeThread(UInt32 ClrThreadID, UInt32 CpuUtilization);
    [EventAttribute("50")]
private void ThreadPoolWorkerThreadStart(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("51")]
private void ThreadPoolWorkerThreadStop(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("52")]
private void ThreadPoolWorkerThreadRetirementStart(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("53")]
private void ThreadPoolWorkerThreadRetirementStop(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("54")]
private void ThreadPoolWorkerThreadAdjustmentSample(double Throughput, ushort ClrInstanceID);
    [EventAttribute("55")]
private void ThreadPoolWorkerThreadAdjustmentAdjustment(double AverageThroughput, UInt32 NewWorkerThreadCount, UInt32 Reason, ushort ClrInstanceID);
    [EventAttribute("56")]
private void ThreadPoolWorkerThreadAdjustmentStats(double Duration, double Throughput, double ThreadWave, double ThroughputWave, double ThroughputErrorEstimate, double AverageThroughputErrorEstimate, double ThroughputRatio, double Confidence, double NewControlSetting, ushort NewThreadWaveMagnitude, ushort ClrInstanceID);
    [EventAttribute("57")]
private void ThreadPoolWorkerThreadWait(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("60")]
private void ThreadPoolWorkingThreadCount(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("61")]
private void ThreadPoolEnqueue(IntPtr WorkID, ushort ClrInstanceID);
    [EventAttribute("62")]
private void ThreadPoolDequeue(IntPtr WorkID, ushort ClrInstanceID);
    [EventAttribute("63")]
private void ThreadPoolIOEnqueue(IntPtr NativeOverlapped, IntPtr Overlapped, bool MultiDequeues, ushort ClrInstanceID);
    [EventAttribute("64")]
private void ThreadPoolIODequeue(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [EventAttribute("65")]
private void ThreadPoolIOPack(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [EventAttribute("70")]
private void ThreadCreating(IntPtr ID, ushort ClrInstanceID);
    [EventAttribute("71")]
private void ThreadRunning(IntPtr ID, ushort ClrInstanceID);
    [EventAttribute("80")]
private void ExceptionThrown_V1(string ExceptionType, string ExceptionMessage, IntPtr ExceptionEIP, UInt32 ExceptionHRESULT, ushort ExceptionFlags, ushort ClrInstanceID);
    [EventAttribute("250")]
private void ExceptionCatchStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("251")]
private void ExceptionCatchStop();
    [EventAttribute("252")]
private void ExceptionFinallyStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("253")]
private void ExceptionFinallyStop();
    [EventAttribute("254")]
private void ExceptionFilterStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("255")]
private void ExceptionFilterStop();
    [EventAttribute("256")]
private void ExceptionThrownStop();
    [EventAttribute("81")]
private void ContentionStart_V1(byte ContentionFlags, ushort ClrInstanceID);
    [EventAttribute("91")]
private void ContentionStop(byte ContentionFlags, ushort ClrInstanceID);
    [EventAttribute("82")]
private void CLRStackWalk(ushort ClrInstanceID, byte Reserved1, byte Reserved2, UInt32 FrameCount);
    [EventAttribute("83")]
private void AppDomainMemAllocated(ulong AppDomainID, ulong Allocated, ushort ClrInstanceID);
    [EventAttribute("84")]
private void AppDomainMemSurvived(ulong AppDomainID, ulong Survived, ulong ProcessSurvived, ushort ClrInstanceID);
    [EventAttribute("85")]
private void ThreadCreated(ulong ManagedThreadID, ulong AppDomainID, UInt32 Flags, UInt32 ManagedThreadIndex, UInt32 OSThreadID, ushort ClrInstanceID);
    [EventAttribute("86")]
private void ThreadTerminated(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("87")]
private void ThreadDomainEnter(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("88")]
private void ILStubGenerated(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, UInt32 StubFlags, UInt32 ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature, string NativeMethodSignature, string StubMethodSignature, string StubMethodILCode);
    [EventAttribute("89")]
private void ILStubCacheHit(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, UInt32 ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature);
    [EventAttribute("135")]
private void DCStartCompleteV2();
    [EventAttribute("136")]
private void DCEndCompleteV2();
    [EventAttribute("137")]
private void MethodDCStartV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags);
    [EventAttribute("138")]
private void MethodDCEndV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags);
    [EventAttribute("139")]
private void MethodDCStartVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("140")]
private void MethodDCEndVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("141")]
private void MethodLoad_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("142")]
private void MethodUnload_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("143")]
private void MethodLoadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("144")]
private void MethodUnloadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("145")]
private void MethodJittingStarted_V1(ulong MethodID, ulong ModuleID, UInt32 MethodToken, UInt32 MethodILSize, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID);
    [EventAttribute("185")]
private void MethodJitInliningSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, ushort ClrInstanceID);
    [EventAttribute("186")]
private void MethodJitInliningFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways);
    [EventAttribute("188")]
private void MethodJitTailCallSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, UInt32 TailCallType, ushort ClrInstanceID);
    [EventAttribute("189")]
private void MethodJitTailCallFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix);
    [EventAttribute("190")]
private void MethodILToNativeMap(ulong MethodID, ulong ReJITID, byte MethodExtent, ushort CountOfMapEntries);
    [EventAttribute("191")]
private void MethodJitTailCallFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, string FailReason, ushort ClrInstanceID);
    [EventAttribute("192")]
private void MethodJitInliningFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways, string FailReason, ushort ClrInstanceID);
    [EventAttribute("149")]
private void ModuleDCStartV2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath);
    [EventAttribute("150")]
private void ModuleDCEndV2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath);
    [EventAttribute("151")]
private void DomainModuleLoad_V1(ulong ModuleID, ulong AssemblyID, ulong AppDomainID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID);
    [EventAttribute("152")]
private void ModuleLoad_V2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, UInt32 ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, UInt32 NativePdbAge, string NativePdbBuildPath);
    [EventAttribute("153")]
private void ModuleUnload_V2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, UInt32 ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, UInt32 NativePdbAge, string NativePdbBuildPath);
    [EventAttribute("154")]
private void AssemblyLoad_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, UInt32 AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("155")]
private void AssemblyUnload_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, UInt32 AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("156")]
private void AppDomainLoad_V1(ulong AppDomainID, UInt32 AppDomainFlags, string AppDomainName, UInt32 AppDomainIndex, ushort ClrInstanceID);
    [EventAttribute("157")]
private void AppDomainUnload_V1(ulong AppDomainID, UInt32 AppDomainFlags, string AppDomainName, UInt32 AppDomainIndex, ushort ClrInstanceID);
    [EventAttribute("158")]
private void ModuleRangeLoad(ushort ClrInstanceID, ulong ModuleID, UInt32 RangeBegin, UInt32 RangeSize, byte RangeType);
    [EventAttribute("181")]
private void StrongNameVerificationStart_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("182")]
private void StrongNameVerificationStop_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("183")]
private void AuthenticodeVerificationStart_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string ModulePath, ushort ClrInstanceID);
    [EventAttribute("184")]
private void AuthenticodeVerificationStop_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string ModulePath, ushort ClrInstanceID);
    [EventAttribute("187")]
private void RuntimeInformationStart(ushort ClrInstanceID, ushort Sku, ushort BclMajorVersion, ushort BclMinorVersion, ushort BclBuildNumber, ushort BclQfeNumber, ushort VMMajorVersion, ushort VMMinorVersion, ushort VMBuildNumber, ushort VMQfeNumber, UInt32 StartupFlags, byte StartupMode, string CommandLine, Guid ComObjectGuid, string RuntimeDllPath);
    [EventAttribute("200")]
private void IncreaseMemoryPressure(ulong BytesAllocated, ushort ClrInstanceID);
    [EventAttribute("201")]
private void DecreaseMemoryPressure(ulong BytesFreed, ushort ClrInstanceID);
    [EventAttribute("202")]
private void GCMarkWithType(UInt32 HeapNum, ushort ClrInstanceID, UInt32 Type, ulong Bytes);
    [EventAttribute("203")]
private void GCJoin_V2(UInt32 Heap, UInt32 JoinTime, UInt32 JoinType, ushort ClrInstanceID, UInt32 JoinID);
    [EventAttribute("204")]
private void GCPerHeapHistory_V3(ushort ClrInstanceID, IntPtr FreeListAllocated, IntPtr FreeListRejected, IntPtr EndOfSegAllocated, IntPtr CondemnedAllocated, IntPtr PinnedAllocated, IntPtr PinnedAllocatedAdvance, UInt32 RunningFreeListEfficiency, UInt32 CondemnReasons0, UInt32 CondemnReasons1, UInt32 CompactMechanisms, UInt32 ExpandMechanisms, UInt32 HeapIndex, IntPtr ExtraGen0Commit, UInt32 Count);
    [EventAttribute("205")]
private void GCGlobalHeapHistory_V2(ulong FinalYoungestDesired, int NumHeaps, UInt32 CondemnedGeneration, UInt32 Gen0ReductionCount, UInt32 Reason, UInt32 GlobalMechanisms, ushort ClrInstanceID, UInt32 PauseMode, UInt32 MemoryPressure);
    [EventAttribute("240")]
private void DebugIPCEventStart();
    [EventAttribute("241")]
private void DebugIPCEventEnd();
    [EventAttribute("242")]
private void DebugExceptionProcessingStart();
    [EventAttribute("243")]
private void DebugExceptionProcessingEnd();
    [EventAttribute("260")]
private void CodeSymbols(ulong ModuleId, ushort TotalChunks, ushort ChunkNumber, UInt32 ChunkLength);
    [EventAttribute("270")]
private void EventSource(int EventID, string EventName, string EventSourceName, string Payload);
    [NonEventAttribute]
internal void ProcessEvent(UInt32 eventID, UInt32 osThreadID, DateTime timeStamp, Guid activityId, Guid childActivityId, ReadOnlySpan`1<byte> payload);
}
internal class System.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class System.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    public static SessionMask All { get; }
    public SessionMask(UInt32 mask);
    public static SessionMask get_All();
    public ulong ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal static class System.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    public static TraceLoggingEventTypes get_Instance();
    private static TraceLoggingEventTypes InitInstance();
}
internal static class System.Diagnostics.Tracing.Statics : object {
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    internal static TraceLoggingDataCollector Instance;
    private static TraceLoggingDataCollector();
    public int BeginBufferedArray();
    public void EndBufferedArray(int bookmark, int count);
    public void AddScalar(PropertyValue value);
    public void AddScalar(long value);
    public void AddScalar(double value);
    public void AddScalar(bool value);
    public void AddNullTerminatedString(string value);
    public void AddArray(PropertyValue value, int elementSize);
}
internal enum System.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.TraceLoggingEventHandleTable : object {
    private IntPtr[] m_innerTable;
    internal IntPtr Item { get; }
    internal IntPtr get_Item(int eventID);
    internal void SetEventHandle(int eventID, IntPtr eventHandle);
}
public class System.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal String[] paramNames;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    internal string Name { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
    private static String[] MakeParamNameArray(ParameterInfo[] paramInfos);
}
internal class System.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddNullTerminatedString(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class System.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
    public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.XplatEventLogger : EventListener {
    private static Lazy`1<string> eventSourceNameFilter;
    private static Lazy`1<string> eventSourceEventFilter;
    private static bool initializedPersistentListener;
    private static List`1<char> escape_seq;
    private static Dictionary`2<char, string> seq_mapping;
    private static XplatEventLogger();
    public static EventListener InitializePersistentListener();
    private static bool IsEventSourceLoggingEnabled();
    private static void LogEventSource(int eventID, string eventName, string eventSourceName, string payload);
    private static void minimalJsonserializer(string payload, StringBuilder sb);
    private static string Serialize(ReadOnlyCollection`1<string> payloadName, ReadOnlyCollection`1<object> payload, string eventMessage);
    private static void AppendByteArrayAsHexString(StringBuilder builder, Byte[] byteArray);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    private void LogOnEventWritten(EventWrittenEventArgs eventData);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Double : ValueType {
    private double m_value;
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    [NonVersionableAttribute]
public static bool IsFinite(double d);
    [NonVersionableAttribute]
public static bool IsInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNaN(double d);
    [NonVersionableAttribute]
public static bool IsNegative(double d);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNormal(double d);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(double d);
    [NonVersionableAttribute]
public static bool IsSubnormal(double d);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public static bool op_Equality(double left, double right);
    [NonVersionableAttribute]
public static bool op_Inequality(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, IFormatProvider provider);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
[IsByRefLikeAttribute]
internal class System.DTSubString : ValueType {
    internal ReadOnlySpan`1<char> s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DuplicateWaitObjectException : ArgumentException {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_duplicateWaitObjectMessage;
    private static string DuplicateWaitObjectMessage { get; }
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    private static DuplicateWaitObjectException();
    private static string get_DuplicateWaitObjectMessage();
}
internal class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Enum : ValueType {
    private static TypeValuesAndNames GetCachedValuesAndNames(RuntimeType enumType, bool getNames);
    private string InternalFormattedHexString();
    private static string InternalFormattedHexString(object value);
    internal static string GetEnumName(RuntimeType eT, ulong ulValue);
    private static string InternalFormat(RuntimeType eT, ulong value);
    private static string InternalFlagsFormat(RuntimeType eT, ulong result);
    private static string InternalFlagsFormat(RuntimeType eT, TypeValuesAndNames entry, ulong result);
    internal static ulong ToUInt64(object value);
    private static int InternalCompareTo(object o1, object o2);
    internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
    private static void GetEnumValuesAndNames(RuntimeTypeHandle enumType, ObjectHandleOnStack values, ObjectHandleOnStack names, bool getNames);
    private static object InternalBoxEnum(RuntimeType enumType, long value);
    public static bool TryParse(Type enumType, string value, Object& result);
    public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParse(string value, TEnum& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static TEnum Parse(string value);
    public static TEnum Parse(string value, bool ignoreCase);
    private static bool TryParseEnum(Type enumType, string value, bool ignoreCase, EnumResult& parseResult);
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    internal static UInt64[] InternalGetValues(RuntimeType enumType);
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    internal static String[] InternalGetNames(RuntimeType enumType);
    public static object ToObject(Type enumType, object value);
    public static bool IsDefined(Type enumType, object value);
    public static string Format(Type enumType, object value, string format);
    internal object GetValue();
    private ulong ToUInt64();
    private bool InternalHasFlag(Enum flags);
    private CorElementType InternalGetCorElementType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual int CompareTo(object target);
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    [IntrinsicAttribute]
public bool HasFlag(Enum flag);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    public static object ToObject(Type enumType, short value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, byte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    public static object ToObject(Type enumType, long value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    private static object ToObject(Type enumType, char value);
    private static object ToObject(Type enumType, bool value);
}
internal static class System.Environment : object {
    private static String[] s_CommandLineArgs;
    public static int TickCount { get; }
    public static int ExitCode { get; public set; }
    public static int ProcessorCount { get; }
    public static string NewLine { get; }
    public static bool HasShutdownStarted { get; }
    public static int CurrentManagedThreadId { get; }
    private static Environment();
    internal static string GetResourceStringLocal(string key);
    public static int get_TickCount();
    internal static void _Exit(int exitCode);
    public static void Exit(int exitCode);
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static void FailFast(string message);
    public static void FailFast(string message, Exception exception);
    public static void FailFast(string message, Exception exception, string errorMessage);
    private static int GetProcessorCount();
    public static int get_ProcessorCount();
    public static String[] GetCommandLineArgs();
    private static String[] GetCommandLineArgsNative();
    private static void SetCommandLineArgs(String[] cmdLineArgs);
    private static Char[] GetEnvironmentCharArray();
    public static string get_NewLine();
    internal static string GetStackTrace(Exception e, bool needFileInfo);
    public static bool get_HasShutdownStarted();
    public static int get_CurrentManagedThreadId();
    public static string GetEnvironmentVariable(string variable);
    internal static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    internal static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    private static void ValidateVariableAndValue(string variable, String& value);
    private static void ValidateTarget(EnvironmentVariableTarget target);
    private static string GetEnvironmentVariableCore(string variable);
    private static string GetEnvironmentVariableCoreHelper(string variable, Span`1<char> buffer);
    private static string GetEnvironmentVariableCore(string variable, EnvironmentVariableTarget target);
    [IteratorStateMachineAttribute("System.Environment/<EnumerateEnvironmentVariables>d__44")]
internal static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables();
    internal static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables(EnvironmentVariableTarget target);
    [IteratorStateMachineAttribute("System.Environment/<EnumerateEnvironmentVariablesFromRegistry>d__46")]
internal static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariablesFromRegistry(EnvironmentVariableTarget target);
    private static void SetEnvironmentVariableCore(string variable, string value);
    private static void SetEnvironmentVariableCore(string variable, string value, EnvironmentVariableTarget target);
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EventArgs : object {
    public static EventArgs Empty;
    private static EventArgs();
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Exception : object {
    [OptionalFieldAttribute]
private static object s_EDILock;
    private string _className;
    private MethodBase _exceptionMethod;
    internal string _message;
    private IDictionary _data;
    private Exception _innerException;
    private string _helpURL;
    private object _stackTrace;
    [OptionalFieldAttribute]
private object _watsonBuckets;
    private string _stackTraceString;
    private string _remoteStackTraceString;
    private int _remoteStackIndex;
    private object _dynamicMethods;
    internal int _HResult;
    private string _source;
    private IntPtr _xptrs;
    private int _xcode;
    [OptionalFieldAttribute]
private UIntPtr _ipForWatsonBuckets;
    private static int _COMPlusExceptionCode;
    public string Message { get; }
    public IDictionary Data { get; }
    public Exception InnerException { get; }
    public MethodBase TargetSite { get; }
    public string StackTrace { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    internal UIntPtr IPForWatsonBuckets { get; }
    internal object WatsonBuckets { get; }
    internal string RemoteStackTrace { get; }
    public int HResult { get; protected set; }
    internal bool IsTransient { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    protected Exception(SerializationInfo info, StreamingContext context);
    private static Exception();
    private void Init();
    public virtual string get_Message();
    public virtual IDictionary get_Data();
    private static bool IsImmutableAgileException(Exception e);
    private string GetClassName();
    public virtual Exception GetBaseException();
    public Exception get_InnerException();
    private static IRuntimeMethodInfo GetMethodFromStackTrace(object stackTrace);
    private MethodBase GetExceptionMethodFromStackTrace();
    public MethodBase get_TargetSite();
    private MethodBase GetTargetSiteInternal();
    public virtual string get_StackTrace();
    private string GetStackTrace(bool needFileInfo);
    internal void SetErrorCode(int hr);
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string ToString();
    private string ToString(bool needFileLineInfo, bool needMessage);
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    internal void InternalPreserveStackTrace();
    internal UIntPtr get_IPForWatsonBuckets();
    internal object get_WatsonBuckets();
    internal string get_RemoteStackTrace();
    private static void PrepareForForeignExceptionRaise();
    private static void GetStackTracesDeepCopy(Exception exception, Object& currentStackTrace, Object& dynamicMethodArray);
    internal static void SaveStackTracesFromDeepCopy(Exception exception, object currentStackTrace, object dynamicMethodArray);
    private static object CopyStackTrace(object currentStackTrace);
    private static object CopyDynamicMethods(object currentDynamicMethods);
    internal object DeepCopyStackTrace(object currentStackTrace);
    internal object DeepCopyDynamicMethods(object currentDynamicMethods);
    internal void GetStackTracesDeepCopy(Object& currentStackTrace, Object& dynamicMethodArray);
    internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo);
    public int get_HResult();
    protected void set_HResult(int value);
    internal virtual string InternalToString();
    public Type GetType();
    internal bool get_IsTransient();
    private static bool nIsTransient(int hr);
    internal static string GetMessageFromNativeResources(ExceptionMessageKind kind);
    private static void GetMessageFromNativeResources(ExceptionMessageKind kind, StringHandleOnStack retMesg);
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument collection;
    public static ExceptionArgument list;
    public static ExceptionArgument match;
    public static ExceptionArgument converter;
    public static ExceptionArgument capacity;
    public static ExceptionArgument index;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument value;
    public static ExceptionArgument count;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument name;
    public static ExceptionArgument item;
    public static ExceptionArgument options;
    public static ExceptionArgument view;
    public static ExceptionArgument sourceBytesToCopy;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument offset;
    public static ExceptionArgument newSize;
    public static ExceptionArgument elementType;
    public static ExceptionArgument length;
    public static ExceptionArgument length1;
    public static ExceptionArgument length2;
    public static ExceptionArgument length3;
    public static ExceptionArgument lengths;
    public static ExceptionArgument len;
    public static ExceptionArgument lowerBounds;
    public static ExceptionArgument sourceArray;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument sourceIndex;
    public static ExceptionArgument destinationIndex;
    public static ExceptionArgument indices;
    public static ExceptionArgument index1;
    public static ExceptionArgument index2;
    public static ExceptionArgument index3;
    public static ExceptionArgument other;
    public static ExceptionArgument comparer;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument keys;
    public static ExceptionArgument creationOptions;
    public static ExceptionArgument timeout;
    public static ExceptionArgument tasks;
    public static ExceptionArgument scheduler;
    public static ExceptionArgument continuationFunction;
    public static ExceptionArgument millisecondsTimeout;
    public static ExceptionArgument millisecondsDelay;
    public static ExceptionArgument function;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument cancellationToken;
    public static ExceptionArgument delay;
    public static ExceptionArgument asyncResult;
    public static ExceptionArgument endMethod;
    public static ExceptionArgument endFunction;
    public static ExceptionArgument beginMethod;
    public static ExceptionArgument continuationOptions;
    public static ExceptionArgument continuationAction;
    public static ExceptionArgument concurrencyLevel;
    public static ExceptionArgument text;
    public static ExceptionArgument callBack;
    public static ExceptionArgument type;
    public static ExceptionArgument stateMachine;
    public static ExceptionArgument pHandle;
    public static ExceptionArgument values;
    public static ExceptionArgument task;
    public static ExceptionArgument s;
    public static ExceptionArgument keyValuePair;
    public static ExceptionArgument input;
    public static ExceptionArgument pointer;
    public static ExceptionArgument start;
    public static ExceptionArgument format;
    public static ExceptionArgument culture;
    public static ExceptionArgument comparable;
    public static ExceptionArgument source;
    public static ExceptionArgument state;
    public static ExceptionArgument comparisonType;
    public static ExceptionArgument manager;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource Argument_ImplementIComparable;
    public static ExceptionResource Argument_InvalidType;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Argument_InvalidRegistryKeyPermissionCheck;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_RegKeyDelHive;
    public static ExceptionResource Arg_RegKeyStrLenBug;
    public static ExceptionResource Arg_RegSetStrArrNull;
    public static ExceptionResource Arg_RegSetMismatchedKind;
    public static ExceptionResource Arg_RegSubKeyAbsent;
    public static ExceptionResource Arg_RegSubKeyValueAbsent;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Serialization_InvalidOnDeser;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource Argument_InvalidArrayType;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource Argument_ItemNotExist;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource ArgumentOutOfRange_InvalidThreshold;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue;
    public static ExceptionResource InvalidOperation_EmptyQueue;
    public static ExceptionResource InvalidOperation_EnumOpCantHappen;
    public static ExceptionResource InvalidOperation_EnumFailedVersion;
    public static ExceptionResource InvalidOperation_EmptyStack;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource InvalidOperation_EnumNotStarted;
    public static ExceptionResource InvalidOperation_EnumEnded;
    public static ExceptionResource NotSupported_SortedListNestedWrite;
    public static ExceptionResource InvalidOperation_NoValue;
    public static ExceptionResource InvalidOperation_RegRemoveSubKey;
    public static ExceptionResource Security_RegistryPermission;
    public static ExceptionResource UnauthorizedAccess_RegistryNoWrite;
    public static ExceptionResource ObjectDisposed_RegKeyClosed;
    public static ExceptionResource NotSupported_InComparableType;
    public static ExceptionResource Argument_InvalidRegistryOptionsCheck;
    public static ExceptionResource Argument_InvalidRegistryViewCheck;
    public static ExceptionResource InvalidOperation_NullArray;
    public static ExceptionResource Arg_MustBeType;
    public static ExceptionResource Arg_NeedAtLeast1Rank;
    public static ExceptionResource ArgumentOutOfRange_HugeArrayNotSupported;
    public static ExceptionResource Arg_RanksAndBounds;
    public static ExceptionResource Arg_RankIndices;
    public static ExceptionResource Arg_Need1DArray;
    public static ExceptionResource Arg_Need2DArray;
    public static ExceptionResource Arg_Need3DArray;
    public static ExceptionResource NotSupported_FixedSizeCollection;
    public static ExceptionResource ArgumentException_OtherNotArrayOfCorrectLength;
    public static ExceptionResource Rank_MultiDimNotSupported;
    public static ExceptionResource InvalidOperation_IComparerFailed;
    public static ExceptionResource ArgumentOutOfRange_EndIndexStartIndex;
    public static ExceptionResource Arg_LowerBoundsMustMatch;
    public static ExceptionResource Arg_BogusIComparer;
    public static ExceptionResource Task_WaitMulti_NullTask;
    public static ExceptionResource Task_ThrowIfDisposed;
    public static ExceptionResource Task_Start_TaskCompleted;
    public static ExceptionResource Task_Start_Promise;
    public static ExceptionResource Task_Start_ContinuationTask;
    public static ExceptionResource Task_Start_AlreadyStarted;
    public static ExceptionResource Task_RunSynchronously_TaskCompleted;
    public static ExceptionResource Task_RunSynchronously_Continuation;
    public static ExceptionResource Task_RunSynchronously_Promise;
    public static ExceptionResource Task_RunSynchronously_AlreadyStarted;
    public static ExceptionResource Task_MultiTaskContinuation_NullTask;
    public static ExceptionResource Task_MultiTaskContinuation_EmptyTaskList;
    public static ExceptionResource Task_Dispose_NotCompleted;
    public static ExceptionResource Task_Delay_InvalidMillisecondsDelay;
    public static ExceptionResource Task_Delay_InvalidDelay;
    public static ExceptionResource Task_ctor_LRandSR;
    public static ExceptionResource Task_ContinueWith_NotOnAnything;
    public static ExceptionResource Task_ContinueWith_ESandLR;
    public static ExceptionResource TaskT_TransitionToFinal_AlreadyCompleted;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NullException;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NoExceptions;
    public static ExceptionResource MemoryDisposed;
    public static ExceptionResource Memory_OutstandingReferences;
    public static ExceptionResource InvalidOperation_WrongAsyncResultOrEndCalledMultiple;
    public static ExceptionResource ConcurrentDictionary_ConcurrencyLevelMustBePositive;
    public static ExceptionResource ConcurrentDictionary_CapacityMustNotBeNegative;
    public static ExceptionResource ConcurrentDictionary_TypeOfValueIncorrect;
    public static ExceptionResource ConcurrentDictionary_TypeOfKeyIncorrect;
    public static ExceptionResource ConcurrentDictionary_KeyAlreadyExisted;
    public static ExceptionResource ConcurrentDictionary_ItemKeyIsNull;
    public static ExceptionResource ConcurrentDictionary_IndexIsNegative;
    public static ExceptionResource ConcurrentDictionary_ArrayNotLargeEnough;
    public static ExceptionResource ConcurrentDictionary_ArrayIncorrectType;
    public static ExceptionResource ConcurrentCollection_SyncRoot_NotSupported;
    public static ExceptionResource ArgumentOutOfRange_Enum;
    public static ExceptionResource InvalidOperation_HandleIsNotInitialized;
    public static ExceptionResource AsyncMethodBuilder_InstanceNotInitialized;
    public static ExceptionResource ArgumentNull_SafeHandle;
    public static ExceptionResource NotSupported_StringComparison;
    public static ExceptionResource InvalidOperation_ConcurrentOperationsNotSupported;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    internal ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    protected FormatException(SerializationInfo info, StreamingContext context);
}
public abstract class System.FormattableString : object {
    public string Format { get; }
    public int ArgumentCount { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] GetArguments();
    public abstract virtual int get_ArgumentCount();
    public abstract virtual object GetArgument(int index);
    public abstract virtual string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    public virtual string ToString();
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    public static int MaxGeneration { get; }
    internal static int GetGCLatencyMode();
    internal static int SetGCLatencyMode(int newLatencyMode);
    internal static void GetMemoryInfo(UInt32& highMemLoadThreshold, UInt64& totalPhysicalMem, UInt32& lastRecordedMemLoad, UIntPtr& lastRecordedHeapSize, UIntPtr& lastRecordedFragmentation);
    internal static int _StartNoGCRegion(long totalSize, bool lohSizeKnown, long lohSize, bool disallowFullBlockingGC);
    internal static int _EndNoGCRegion();
    internal static int GetLOHCompactionMode();
    internal static void SetLOHCompactionMode(int newLOHCompactionMode);
    private static int GetGenerationWR(IntPtr handle);
    private static long GetTotalMemory();
    private static void _Collect(int generation, int mode);
    private static int GetMaxGeneration();
    private static int _CollectionCount(int generation, int getSpecialGCCount);
    internal static bool IsServerGC();
    private static void _AddMemoryPressure(ulong bytesAllocated);
    private static void _RemoveMemoryPressure(ulong bytesAllocated);
    public static void AddMemoryPressure(long bytesAllocated);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static int GetGeneration(object obj);
    public static void Collect(int generation);
    public static void Collect();
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    public static void KeepAlive(object obj);
    public static int GetGeneration(WeakReference wo);
    public static int get_MaxGeneration();
    private static void _WaitForPendingFinalizers();
    public static void WaitForPendingFinalizers();
    private static void _SuppressFinalize(object o);
    public static void SuppressFinalize(object obj);
    private static void _ReRegisterForFinalize(object o);
    public static void ReRegisterForFinalize(object obj);
    public static long GetTotalMemory(bool forceFullCollection);
    private static long _GetAllocatedBytesForCurrentThread();
    public static long GetAllocatedBytesForCurrentThread();
    private static bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage);
    private static bool _CancelFullGCNotification();
    private static int _WaitForFullGCApproach(int millisecondsTimeout);
    private static int _WaitForFullGCComplete(int millisecondsTimeout);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void CancelFullGCNotification();
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    private static bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    private static EndNoGCRegionStatus EndNoGCRegionWorker();
    public static void EndNoGCRegion();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Func`2<object, bool> _callback;
    private GCHandle _weakTargetObj;
    public static void Register(Func`2<object, bool> callback, object targetObj);
    private void Setup(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
internal enum System.Globalization.BidiCategory : Enum {
    public int value__;
    public static BidiCategory LeftToRight;
    public static BidiCategory LeftToRightEmbedding;
    public static BidiCategory LeftToRightOverride;
    public static BidiCategory RightToLeft;
    public static BidiCategory RightToLeftArabic;
    public static BidiCategory RightToLeftEmbedding;
    public static BidiCategory RightToLeftOverride;
    public static BidiCategory PopDirectionalFormat;
    public static BidiCategory EuropeanNumber;
    public static BidiCategory EuropeanNumberSeparator;
    public static BidiCategory EuropeanNumberTerminator;
    public static BidiCategory ArabicNumber;
    public static BidiCategory CommonNumberSeparator;
    public static BidiCategory NonSpacingMark;
    public static BidiCategory BoundaryNeutral;
    public static BidiCategory ParagraphSeparator;
    public static BidiCategory SegmentSeparator;
    public static BidiCategory Whitespace;
    public static BidiCategory OtherNeutrals;
    public static BidiCategory LeftToRightIsolate;
    public static BidiCategory RightToLeftIsolate;
    public static BidiCategory FirstStrongIsolate;
    public static BidiCategory PopDirectionIsolate;
}
public abstract class System.Globalization.Calendar : object {
    private int _currentEraValue;
    private bool _isReadOnly;
    public static int CurrentEra;
    internal int twoDigitYearMax;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays);
    private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal static int GetSystemTwoDigitYearSetting(CalendarId CalID, int defaultYearValue);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    internal int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    internal CalendarData(string localeName, CalendarId calendarId, bool bUseUserOverrides);
    private static CalendarData();
    private static CalendarData CreateInvariant();
    private void InitializeEraNames(string localeName, CalendarId calendarId);
    private void InitializeAbbreviatedEraNames(string localeName, CalendarId calendarId);
    internal static CalendarData GetCalendarData(CalendarId calendarId);
    private static string CalendarIdToCultureName(CalendarId calendarId);
    private bool LoadCalendarDataFromSystem(string localeName, CalendarId calendarId);
    internal static int GetTwoDigitYearMax(CalendarId calendarId);
    internal static int GetCalendars(string localeName, bool useUserOverride, CalendarId[] calendars);
    private static bool SystemSupportsTaiwaneseCalendar();
    private static bool GetCalendarInfo(string localeName, CalendarId calendarId, CalendarDataType dataType, String& calendarString);
    private static bool EnumDatePatterns(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& datePatterns);
    private static string NormalizeDatePattern(string input);
    private static void NormalizeDayOfWeek(string input, StringBuilder destination, Int32& index);
    private static int CountOccurrences(string input, char value, Int32& index);
    private static bool EnumMonthNames(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& monthNames, String& leapHebrewMonthName);
    private static bool EnumEraNames(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& eraNames);
    internal static bool EnumCalendarInfo(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& calendarData);
    private static bool EnumCalendarInfo(string localeName, CalendarId calendarId, CalendarDataType dataType, EnumCalendarsData& callbackContext);
    private static void EnumCalendarInfoCallback(string calendarString, IntPtr context);
}
internal enum System.Globalization.CalendarDataType : Enum {
    public int value__;
    public static CalendarDataType Uninitialized;
    public static CalendarDataType NativeName;
    public static CalendarDataType MonthDay;
    public static CalendarDataType ShortDates;
    public static CalendarDataType LongDates;
    public static CalendarDataType YearMonths;
    public static CalendarDataType DayNames;
    public static CalendarDataType AbbrevDayNames;
    public static CalendarDataType MonthNames;
    public static CalendarDataType AbbrevMonthNames;
    public static CalendarDataType SuperShortDayNames;
    public static CalendarDataType MonthGenitiveNames;
    public static CalendarDataType AbbrevMonthGenitiveNames;
    public static CalendarDataType EraNames;
    public static CalendarDataType AbbrevEraNames;
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId UNINITIALIZED_VALUE;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
internal class System.Globalization.CalendricalCalculationsHelper : object {
    private static long s_startOf1810;
    private static long s_startOf1900Century;
    private static Double[] s_coefficients1900to1987;
    private static Double[] s_coefficients1800to1899;
    private static Double[] s_coefficients1700to1799;
    private static Double[] s_coefficients1620to1699;
    private static Double[] s_lambdaCoefficients;
    private static Double[] s_anomalyCoefficients;
    private static Double[] s_eccentricityCoefficients;
    private static Double[] s_coefficients;
    private static Double[] s_coefficientsA;
    private static Double[] s_coefficientsB;
    private static EphemerisCorrectionAlgorithmMap[] s_ephemerisCorrectionTable;
    private static CalendricalCalculationsHelper();
    private static double RadiansFromDegrees(double degree);
    private static double SinOfDegree(double degree);
    private static double CosOfDegree(double degree);
    private static double TanOfDegree(double degree);
    public static double Angle(int degrees, int minutes, double seconds);
    private static double Obliquity(double julianCenturies);
    internal static long GetNumberOfDays(DateTime date);
    private static int GetGregorianYear(double numberOfDays);
    private static double Reminder(double divisor, double dividend);
    private static double NormalizeLongitude(double longitude);
    public static double AsDayFraction(double longitude);
    private static double PolynomialSum(Double[] coefficients, double indeterminate);
    private static double CenturiesFrom1900(int gregorianYear);
    private static double DefaultEphemerisCorrection(int gregorianYear);
    private static double EphemerisCorrection1988to2019(int gregorianYear);
    private static double EphemerisCorrection1900to1987(int gregorianYear);
    private static double EphemerisCorrection1800to1899(int gregorianYear);
    private static double EphemerisCorrection1700to1799(int gregorianYear);
    private static double EphemerisCorrection1620to1699(int gregorianYear);
    private static double EphemerisCorrection(double time);
    public static double JulianCenturies(double moment);
    private static bool IsNegative(double value);
    private static double CopySign(double value, double sign);
    private static double EquationOfTime(double time);
    private static double AsLocalTime(double apparentMidday, double longitude);
    public static double Midday(double date, double longitude);
    private static double InitLongitude(double longitude);
    public static double MiddayAtPersianObservationSite(double date);
    private static double PeriodicTerm(double julianCenturies, int x, double y, double z);
    private static double SumLongSequenceOfPeriodicTerms(double julianCenturies);
    private static double Aberration(double julianCenturies);
    private static double Nutation(double julianCenturies);
    public static double Compute(double time);
    public static double AsSeason(double longitude);
    private static double EstimatePrior(double longitude, double time);
    internal static long PersianNewYearOnOrBefore(long numberOfDays);
}
public static class System.Globalization.CharUnicodeInfo : object {
    private static UInt16[] s_pCategoryLevel1Index;
    private static Byte[] s_pCategoriesValue;
    private static UInt16[] s_pNumericLevel1Index;
    private static Byte[] s_pNumericValues;
    private static UInt16[] s_pDigitValues;
    private static CharUnicodeInfo();
    internal static int InternalConvertToUtf32(string s, int index);
    internal static int InternalConvertToUtf32(string s, int index, Int32& charLength);
    internal static bool IsWhiteSpace(string s, int index);
    internal static bool IsWhiteSpace(char c);
    internal static double InternalGetNumericValue(int ch);
    internal static ushort InternalGetDigitValues(int ch);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    internal static byte InternalGetCategoryValue(int ch, int offset);
    internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
    internal static BidiCategory GetBidiCategory(string s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength);
    internal static bool IsCombiningCategory(UnicodeCategory uc);
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CompareInfo : object {
    internal static CompareInfo Invariant;
    [OptionalFieldAttribute]
private string m_name;
    private string _sortName;
    [OptionalFieldAttribute]
private SortVersion m_SortVersion;
    private bool _invariantMode;
    private int culture;
    private SafeSortHandle _sortHandle;
    private bool _isAsciiEqualityOrdinal;
    private static Boolean[] s_highCharTable;
    public string Name { get; }
    public SortVersion Version { get; }
    public int LCID { get; }
    internal CompareInfo(CultureInfo culture);
    private static CompareInfo();
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private void OnDeserialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public virtual string get_Name();
    public virtual int Compare(string string1, string string2);
    public virtual int Compare(string string1, string string2, CompareOptions options);
    internal int Compare(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    internal int CompareOptionNone(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    internal int CompareOptionIgnoreCase(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    internal static int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
    internal static int CompareOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    internal bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    internal bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int IndexOfOrdinal(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    internal int IndexOf(string source, string value, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal static int GetIgnoreCaseHash(string source);
    internal int GetHashCodeOfString(string source, CompareOptions options);
    public virtual int GetHashCode(string source, CompareOptions options);
    public virtual string ToString();
    public SortVersion get_Version();
    public int get_LCID();
    internal static int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int InvariantIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal static int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    private static int InvariantFindString(Char* source, int sourceCount, Char* value, int valueCount, bool ignoreCase, bool start);
    private static char InvariantToUpper(char c);
    private SortKey InvariantCreateSortKey(string source, CompareOptions options);
    private void InitSort(CultureInfo culture);
    internal static int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int IndexOfOrdinalCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal static int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    private static int CompareStringOrdinalIgnoreCase(Char* string1, int count1, Char* string2, int count2);
    private int CompareString(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    private int CompareString(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    internal int IndexOfCore(string source, string target, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr);
    private int IndexOfOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr);
    private int IndexOfOrdinalHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr);
    private int LastIndexOfCore(string source, string target, int startIndex, int count, CompareOptions options);
    private bool StartsWith(string source, string prefix, CompareOptions options);
    private bool StartsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    private bool StartsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    private bool StartsWithOrdinalHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    private bool EndsWith(string source, string suffix, CompareOptions options);
    private bool EndsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    private bool EndsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    private bool EndsWithOrdinalHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    private SortKey CreateSortKey(string source, CompareOptions options);
    private static bool IsSortable(Char* text, int length);
    internal int GetHashCodeOfStringCore(string source, CompareOptions options);
    private static CompareOptions GetOrdinalCompareOptions(CompareOptions options);
    private static bool CanUseAsciiOrdinalForOptions(CompareOptions options);
    private static Byte[] GetNullTerminatedUtf8String(string s);
    private SortVersion GetSortVersion();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
internal class System.Globalization.CultureData : object {
    private string _sRealName;
    private string _sWindowsName;
    private string _sName;
    private string _sParent;
    private string _sLocalizedDisplayName;
    private string _sEnglishDisplayName;
    private string _sNativeDisplayName;
    private string _sSpecificCulture;
    private string _sISO639Language;
    private string _sISO639Language2;
    private string _sLocalizedLanguage;
    private string _sEnglishLanguage;
    private string _sNativeLanguage;
    private string _sAbbrevLang;
    private string _sConsoleFallbackName;
    private int _iInputLanguageHandle;
    private string _sRegionName;
    private string _sLocalizedCountry;
    private string _sEnglishCountry;
    private string _sNativeCountry;
    private string _sISO3166CountryName;
    private string _sISO3166CountryName2;
    private int _iGeoId;
    private string _sPositiveSign;
    private string _sNegativeSign;
    private int _iDigits;
    private int _iNegativeNumber;
    private Int32[] _waGrouping;
    private string _sDecimalSeparator;
    private string _sThousandSeparator;
    private string _sNaN;
    private string _sPositiveInfinity;
    private string _sNegativeInfinity;
    private int _iNegativePercent;
    private int _iPositivePercent;
    private string _sPercent;
    private string _sPerMille;
    private string _sCurrency;
    private string _sIntlMonetarySymbol;
    private string _sEnglishCurrency;
    private string _sNativeCurrency;
    private int _iCurrencyDigits;
    private int _iCurrency;
    private int _iNegativeCurrency;
    private Int32[] _waMonetaryGrouping;
    private string _sMonetaryDecimal;
    private string _sMonetaryThousand;
    private int _iMeasure;
    private string _sListSeparator;
    private string _sAM1159;
    private string _sPM2359;
    private string _sTimeSeparator;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saLongTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saShortTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saDurationFormats;
    private int _iFirstDayOfWeek;
    private int _iFirstWeekOfYear;
    private CalendarId[] modreq(System.Runtime.CompilerServices.IsVolatile) _waCalendars;
    private CalendarData[] _calendars;
    private int _iReadingLayout;
    private int _iDefaultAnsiCodePage;
    private int _iDefaultOemCodePage;
    private int _iDefaultMacCodePage;
    private int _iDefaultEbcdicCodePage;
    private int _iLanguage;
    private bool _bUseOverrides;
    private bool _bNeutral;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedRegions;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_RegionNames;
    private static CultureData modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCultures;
    private static object s_lock;
    private static Dictionary`2<string, string> RegionNames { get; }
    internal static CultureData Invariant { get; }
    internal string CultureName { get; }
    internal bool UseUserOverride { get; }
    internal string SNAME { get; }
    internal string SPARENT { get; }
    internal string SLOCALIZEDDISPLAYNAME { get; }
    internal string SENGDISPLAYNAME { get; }
    internal string SNATIVEDISPLAYNAME { get; }
    internal string SSPECIFICCULTURE { get; }
    internal string SISO639LANGNAME { get; }
    internal string SISO639LANGNAME2 { get; }
    internal string SABBREVLANGNAME { get; }
    internal string SLOCALIZEDLANGUAGE { get; }
    internal string SENGLISHLANGUAGE { get; }
    internal string SNATIVELANGUAGE { get; }
    internal string SREGIONNAME { get; }
    internal int IGEOID { get; }
    internal string SLOCALIZEDCOUNTRY { get; }
    internal string SENGCOUNTRY { get; }
    internal string SNATIVECOUNTRY { get; }
    internal string SISO3166CTRYNAME { get; }
    internal string SISO3166CTRYNAME2 { get; }
    internal int IINPUTLANGUAGEHANDLE { get; }
    internal string SCONSOLEFALLBACKNAME { get; }
    internal Int32[] WAGROUPING { get; }
    internal string SNAN { get; }
    internal string SPOSINFINITY { get; }
    internal string SNEGINFINITY { get; }
    internal int INEGATIVEPERCENT { get; }
    internal int IPOSITIVEPERCENT { get; }
    internal string SPERCENT { get; }
    internal string SPERMILLE { get; }
    internal string SCURRENCY { get; }
    internal string SINTLSYMBOL { get; }
    internal string SENGLISHCURRENCY { get; }
    internal string SNATIVECURRENCY { get; }
    internal Int32[] WAMONGROUPING { get; }
    internal int IMEASURE { get; }
    internal string SLIST { get; }
    internal string SAM1159 { get; }
    internal string SPM2359 { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal int IFIRSTDAYOFWEEK { get; }
    internal int IFIRSTWEEKOFYEAR { get; }
    internal CalendarId[] CalendarIds { get; }
    internal bool IsRightToLeft { get; }
    private int IREADINGLAYOUT { get; }
    internal string STEXTINFO { get; }
    internal string SCOMPAREINFO { get; }
    internal bool IsSupplementalCustomCulture { get; }
    internal int IDEFAULTANSICODEPAGE { get; }
    internal int IDEFAULTOEMCODEPAGE { get; }
    internal int IDEFAULTMACCODEPAGE { get; }
    internal int IDEFAULTEBCDICCODEPAGE { get; }
    internal int ILANGUAGE { get; }
    internal bool IsNeutralCulture { get; }
    internal bool IsInvariantCulture { get; }
    internal Calendar DefaultCalendar { get; }
    internal string TimeSeparator { get; }
    internal bool IsFramework { get; }
    internal bool IsWin32Installed { get; }
    internal bool IsReplacementCulture { get; }
    private static CultureData();
    private static Dictionary`2<string, string> get_RegionNames();
    internal static CultureData GetCultureDataForRegion(string cultureName, bool useUserOverride);
    internal static void ClearCachedData();
    internal static CultureInfo[] GetCultures(CultureTypes types);
    private static CultureData CreateCultureWithInvariantData();
    internal static CultureData get_Invariant();
    internal static CultureData GetCultureData(string cultureName, bool useUserOverride);
    private static string NormalizeCultureName(string name, Boolean& isNeutralName);
    private static CultureData CreateCultureData(string cultureName, bool useUserOverride);
    private bool InitCompatibilityCultureData();
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    internal string get_CultureName();
    internal bool get_UseUserOverride();
    internal string get_SNAME();
    internal string get_SPARENT();
    internal string get_SLOCALIZEDDISPLAYNAME();
    internal string get_SENGDISPLAYNAME();
    internal string get_SNATIVEDISPLAYNAME();
    internal string get_SSPECIFICCULTURE();
    internal string get_SISO639LANGNAME();
    internal string get_SISO639LANGNAME2();
    internal string get_SABBREVLANGNAME();
    internal string get_SLOCALIZEDLANGUAGE();
    internal string get_SENGLISHLANGUAGE();
    internal string get_SNATIVELANGUAGE();
    internal string get_SREGIONNAME();
    internal int get_IGEOID();
    internal string get_SLOCALIZEDCOUNTRY();
    internal string get_SENGCOUNTRY();
    internal string get_SNATIVECOUNTRY();
    internal string get_SISO3166CTRYNAME();
    internal string get_SISO3166CTRYNAME2();
    internal int get_IINPUTLANGUAGEHANDLE();
    internal string get_SCONSOLEFALLBACKNAME();
    internal Int32[] get_WAGROUPING();
    internal string get_SNAN();
    internal string get_SPOSINFINITY();
    internal string get_SNEGINFINITY();
    internal int get_INEGATIVEPERCENT();
    internal int get_IPOSITIVEPERCENT();
    internal string get_SPERCENT();
    internal string get_SPERMILLE();
    internal string get_SCURRENCY();
    internal string get_SINTLSYMBOL();
    internal string get_SENGLISHCURRENCY();
    internal string get_SNATIVECURRENCY();
    internal Int32[] get_WAMONGROUPING();
    internal int get_IMEASURE();
    internal string get_SLIST();
    internal string get_SAM1159();
    internal string get_SPM2359();
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    private String[] AdjustShortTimesForMac(String[] shortTimes);
    private String[] DeriveShortTimesFromLong();
    private static string StripSecondsFromPattern(string time);
    private static int GetIndexOfNextTokenAfterSeconds(string time, int index, Boolean& containsSpace);
    internal int get_IFIRSTDAYOFWEEK();
    internal int get_IFIRSTWEEKOFYEAR();
    internal String[] ShortDates(CalendarId calendarId);
    internal String[] LongDates(CalendarId calendarId);
    internal String[] YearMonths(CalendarId calendarId);
    internal String[] DayNames(CalendarId calendarId);
    internal String[] AbbreviatedDayNames(CalendarId calendarId);
    internal String[] SuperShortDayNames(CalendarId calendarId);
    internal String[] MonthNames(CalendarId calendarId);
    internal String[] GenitiveMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(CalendarId calendarId);
    internal String[] LeapYearMonthNames(CalendarId calendarId);
    internal string MonthDay(CalendarId calendarId);
    internal CalendarId[] get_CalendarIds();
    internal string CalendarName(CalendarId calendarId);
    internal CalendarData GetCalendar(CalendarId calendarId);
    internal bool get_IsRightToLeft();
    private int get_IREADINGLAYOUT();
    internal string get_STEXTINFO();
    internal string get_SCOMPAREINFO();
    internal bool get_IsSupplementalCustomCulture();
    internal int get_IDEFAULTANSICODEPAGE();
    internal int get_IDEFAULTOEMCODEPAGE();
    internal int get_IDEFAULTMACCODEPAGE();
    internal int get_IDEFAULTEBCDICCODEPAGE();
    internal int get_ILANGUAGE();
    internal bool get_IsNeutralCulture();
    internal bool get_IsInvariantCulture();
    internal Calendar get_DefaultCalendar();
    internal String[] EraNames(CalendarId calendarId);
    internal String[] AbbrevEraNames(CalendarId calendarId);
    internal String[] AbbreviatedEnglishEraNames(CalendarId calendarId);
    internal string get_TimeSeparator();
    internal string DateSeparator(CalendarId calendarId);
    private static string UnescapeNlsString(string str, int start, int end);
    private static string GetTimeSeparator(string format);
    private static string GetDateSeparator(string format);
    private static string GetSeparator(string format, string timeParts);
    private static int IndexOfTimePart(string format, int startIndex, string timeParts);
    internal static bool IsCustomCultureId(int cultureId);
    internal void GetNFIValues(NumberFormatInfo nfi);
    internal static string AnsiToLower(string testString);
    private bool InitCultureData();
    internal static bool GetLocaleName(string localeName, String& windowsName);
    internal static bool GetDefaultLocaleName(String& windowsName);
    private string GetLocaleInfo(LocaleStringData type);
    private string GetLocaleInfo(string localeName, LocaleStringData type);
    private int GetLocaleInfo(LocaleNumberData type);
    private Int32[] GetLocaleInfo(LocaleGroupingData type);
    private string GetTimeFormatString();
    private string GetTimeFormatString(bool shortFormat);
    private int GetFirstDayOfWeek();
    private String[] GetTimeFormats();
    private String[] GetShortTimeFormats();
    private static CultureData GetCultureDataFromRegionName(string regionName);
    private static string GetLanguageDisplayName(string cultureName);
    private static string GetRegionDisplayName(string isoCountryCode);
    private static CultureInfo GetUserDefaultCulture();
    private static string ConvertIcuTimeFormatString(string icuFormatString);
    private static string LCIDToLocaleName(int culture);
    private static int LocaleNameToLCID(string cultureName);
    private static int GetAnsiCodePage(string cultureName);
    private static int GetOemCodePage(string cultureName);
    private static int GetMacCodePage(string cultureName);
    private static int GetEbcdicCodePage(string cultureName);
    private static int GetGeoId(string cultureName);
    private static int GetDigitSubstitution(string cultureName);
    private static string GetThreeLetterWindowsLanguageName(string cultureName);
    private static CultureInfo[] EnumCultures(CultureTypes types);
    private static string GetConsoleFallbackName(string cultureName);
    internal bool get_IsFramework();
    internal bool get_IsWin32Installed();
    internal bool get_IsReplacementCulture();
}
public class System.Globalization.CultureInfo : object {
    private bool _isReadOnly;
    private CompareInfo compareInfo;
    private TextInfo textInfo;
    internal NumberFormatInfo numInfo;
    internal DateTimeFormatInfo dateTimeInfo;
    private Calendar calendar;
    internal CultureData _cultureData;
    internal bool _isInherited;
    private CultureInfo _consoleFallbackCulture;
    internal string _name;
    private string _nonSortName;
    private string _sortName;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultCulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultUICulture;
    private static CultureInfo s_InvariantCultureInfo;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture;
    internal static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture;
    internal static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture;
    private static object _lock;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_NameCachedCultures;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_LcidCachedCultures;
    private CultureInfo _parent;
    internal static int LOCALE_NEUTRAL;
    private static int LOCALE_USER_DEFAULT;
    private static int LOCALE_SYSTEM_DEFAULT;
    internal static int LOCALE_CUSTOM_UNSPECIFIED;
    internal static int LOCALE_CUSTOM_DEFAULT;
    internal static int LOCALE_INVARIANT;
    private bool _useUserOverride;
    internal static CultureInfo UserDefaultUICulture { get; }
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public static CultureInfo InvariantCulture { get; }
    public CultureInfo Parent { get; }
    public int LCID { get; }
    public int KeyboardLayoutId { get; }
    public string Name { get; }
    internal string SortName { get; }
    public string IetfLanguageTag { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string EnglishName { get; }
    public string TwoLetterISOLanguageName { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public CompareInfo CompareInfo { get; }
    public TextInfo TextInfo { get; }
    public bool IsNeutralCulture { get; }
    public CultureTypes CultureTypes { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public Calendar Calendar { get; }
    public Calendar[] OptionalCalendars { get; }
    public bool UseUserOverride { get; }
    public bool IsReadOnly { get; }
    internal bool HasInvariantCultureName { get; }
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    private CultureInfo(CultureData cultureData, bool isReadOnly);
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    internal CultureInfo(string cultureName, string textAndCompareCultureName);
    private static CultureInfo();
    internal static void AsyncLocalSetCurrentCulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    internal static void AsyncLocalSetCurrentUICulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static CultureInfo InitializeUserDefaultCulture();
    private static CultureInfo InitializeUserDefaultUICulture();
    private static CultureInfo CreateCultureInfoNoThrow(string name, bool useUserOverride);
    private void InitializeFromCultureId(int culture, bool useUserOverride);
    private void InitializeFromName(string name, bool useUserOverride);
    private static CultureInfo GetCultureByName(string name, bool userOverride);
    public static CultureInfo CreateSpecificCulture(string name);
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
    internal static CultureInfo GetCurrentUICultureNoAppX();
    internal static CultureInfo get_UserDefaultUICulture();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_DefaultThreadCurrentCulture();
    public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public static CultureInfo get_InvariantCulture();
    public virtual CultureInfo get_Parent();
    public virtual int get_LCID();
    public virtual int get_KeyboardLayoutId();
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual string get_Name();
    internal string get_SortName();
    public string get_IetfLanguageTag();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_EnglishName();
    public virtual string get_TwoLetterISOLanguageName();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual CompareInfo get_CompareInfo();
    public virtual TextInfo get_TextInfo();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual object GetFormat(Type formatType);
    public virtual bool get_IsNeutralCulture();
    public CultureTypes get_CultureTypes();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public void ClearCachedData();
    internal static Calendar GetCalendarInstance(CalendarId calType);
    internal static Calendar GetCalendarInstanceRare(CalendarId calType);
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public bool get_UseUserOverride();
    public CultureInfo GetConsoleFallbackUICulture();
    public virtual object Clone();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public bool get_IsReadOnly();
    private void VerifyWritable();
    internal bool get_HasInvariantCultureName();
    internal static CultureInfo GetCultureInfoHelper(int lcid, string name, string altName);
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    private static CultureInfo GetUserDefaultCultureCacheOverride();
    internal static CultureInfo GetUserDefaultCulture();
    private static CultureInfo GetUserDefaultUICulture();
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CultureNotFoundException : ArgumentException {
    private string _invalidCultureName;
    private Nullable`1<int> _invalidCultureId;
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    private static string DefaultMessage { get; }
    private string FormatedInvalidCultureId { get; }
    public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    private static string get_DefaultMessage();
    private string get_FormatedInvalidCultureId();
    public virtual string get_Message();
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
public class System.Globalization.DateTimeFormatInfo : object {
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    private CultureData _cultureData;
    private string _name;
    private string _langName;
    private CompareInfo _compareInfo;
    private CultureInfo _cultureInfo;
    private string amDesignator;
    private string pmDesignator;
    private string dateSeparator;
    private string generalShortTimePattern;
    private string generalLongTimePattern;
    private string timeSeparator;
    private string monthDayPattern;
    private string dateTimeOffsetPattern;
    private Calendar calendar;
    private int firstDayOfWeek;
    private int calendarWeekRule;
    private string fullDateTimePattern;
    private String[] abbreviatedDayNames;
    private String[] m_superShortDayNames;
    private String[] dayNames;
    private String[] abbreviatedMonthNames;
    private String[] monthNames;
    private String[] genitiveMonthNames;
    private String[] m_genitiveAbbreviatedMonthNames;
    private String[] leapYearMonthNames;
    private string longDatePattern;
    private string shortDatePattern;
    private string yearMonthPattern;
    private string longTimePattern;
    private string shortTimePattern;
    private String[] allYearMonthPatterns;
    private String[] allShortDatePatterns;
    private String[] allLongDatePatterns;
    private String[] allShortTimePatterns;
    private String[] allLongTimePatterns;
    private String[] m_eraNames;
    private String[] m_abbrevEraNames;
    private String[] m_abbrevEnglishEraNames;
    private CalendarId[] optionalCalendars;
    internal bool _isReadOnly;
    private DateTimeFormatFlags formatFlags;
    private static Char[] s_monthSpaces;
    private string _fullTimeSpanPositivePattern;
    private string _fullTimeSpanNegativePattern;
    private TokenHashValue[] _dtfiTokenHash;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI;
    private string CultureName { get; }
    private CultureInfo Culture { get; }
    private string LanguageName { get; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    private CalendarId[] OptionalCalendars { get; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    private String[] AllYearMonthPatterns { get; }
    private String[] AllShortDatePatterns { get; }
    private String[] AllShortTimePatterns { get; }
    private String[] AllLongDatePatterns { get; }
    private String[] AllLongTimePatterns { get; }
    private String[] UnclonedYearMonthPatterns { get; }
    private String[] UnclonedShortDatePatterns { get; }
    private String[] UnclonedLongDatePatterns { get; }
    private String[] UnclonedShortTimePatterns { get; }
    private String[] UnclonedLongTimePatterns { get; }
    public bool IsReadOnly { get; }
    public string NativeCalendarName { get; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private static DateTimeFormatInfo();
    private string get_CultureName();
    private CultureInfo get_Culture();
    private string get_LanguageName();
    private String[] internalGetAbbreviatedDayOfWeekNames();
    private String[] internalGetAbbreviatedDayOfWeekNamesCore();
    private String[] internalGetSuperShortDayNames();
    private String[] internalGetSuperShortDayNamesCore();
    private String[] internalGetDayOfWeekNames();
    private String[] internalGetDayOfWeekNamesCore();
    private String[] internalGetAbbreviatedMonthNames();
    private String[] internalGetAbbreviatedMonthNamesCore();
    private String[] internalGetMonthNames();
    private String[] internalGetMonthNamesCore();
    private void InitializeOverridableProperties(CultureData cultureData, CalendarId calendarId);
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    private CalendarId[] get_OptionalCalendars();
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    private static void CheckNullValue(String[] values, int length);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    private String[] internalGetGenitiveMonthNames(bool abbreviated);
    internal String[] internalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    private static String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    private static String[] GetMergedPatterns(String[] patterns, string defaultPattern);
    private String[] get_AllYearMonthPatterns();
    private String[] get_AllShortDatePatterns();
    private String[] get_AllShortTimePatterns();
    private String[] get_AllLongDatePatterns();
    private String[] get_AllLongTimePatterns();
    private String[] get_UnclonedYearMonthPatterns();
    private String[] get_UnclonedShortDatePatterns();
    private String[] get_UnclonedLongDatePatterns();
    private String[] get_UnclonedShortTimePatterns();
    private String[] get_UnclonedLongTimePatterns();
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, string parameterName);
    internal DateTimeFormatFlags get_FormatFlags();
    private DateTimeFormatFlags InitializeFormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    private void ClearTokenHashTable();
    internal TokenHashValue[] CreateTokenHashTable();
    private void AddMonthNames(TokenHashValue[] temp, string monthPostfix);
    private static bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number);
    private static bool IsHebrewChar(char ch);
    private bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
    internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
    private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
    private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
    private bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal List`1<string> m_dateWords;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_knownWords;
    private FoundDatePattern _ymdFlags;
    private static Dictionary`2<string, string> KnownWords { get; }
    private static Dictionary`2<string, string> get_KnownWords();
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
    private static bool EqualStringArrays(String[] array1, String[] array2);
    private static bool ArrayElementsHaveSpace(String[] array);
    private static bool ArrayElementsBeginWithDigit(String[] array);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    private DateTime _start;
    private DateTime _end;
    private TimeSpan _delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
[IsReadOnlyAttribute]
internal class System.Globalization.DaylightTimeStruct : ValueType {
    public DateTime Start;
    public DateTime End;
    public TimeSpan Delta;
    public DaylightTimeStruct(DateTime start, DateTime end, TimeSpan delta);
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static EastAsianLunisolarCalendar();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    private static int GregorianIsLeapYear(int y);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal void GregorianToLunar(int nSYear, int nSMonth, int nSDate, Int32& nLYear, Int32& nLMonth, Int32& nLDate);
    internal bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, Int32& nSolarYear, Int32& nSolarMonth, Int32& nSolarDay);
    internal DateTime LunarToTime(DateTime time, int year, int month, int day);
    internal void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    internal string eraName;
    internal string abbrevEraName;
    internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
internal class System.Globalization.GlobalizationMode : object {
    [CompilerGeneratedAttribute]
private static bool <Invariant>k__BackingField;
    internal static bool Invariant { get; }
    private static GlobalizationMode();
    [CompilerGeneratedAttribute]
internal static bool get_Invariant();
    internal static bool GetInvariantSwitchValue();
    private static bool GetGlobalizationInvariantMode();
}
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    internal GregorianCalendarTypes m_type;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    private static GregorianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual CalendarId get_ID();
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal virtual long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    internal int m_maxYear;
    internal int m_minYear;
    internal Calendar m_Cal;
    internal EraInfo[] m_EraInfo;
    internal Int32[] m_eras;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    private static GregorianCalendarHelper();
    internal int get_MaxYear();
    private int GetYearOffset(int year, int era, bool throwOnError);
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    private static Byte[] s_hebrewTable;
    private static Byte[] s_lunarMonthLen;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    private static void CheckHebrewYearValue(int y, int era, string varName);
    private void CheckHebrewMonthValue(int year, int month, int era);
    private void CheckHebrewDayValue(int year, int month, int day, int era);
    internal static void CheckEraRange(int era);
    private static void CheckTicksRange(long ticks);
    internal static int GetResult(__DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    private static int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
    private static DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.HebrewNumber : object {
    private static HebrewValue[] s_hebrewValues;
    private static char s_maxHebrewNumberCh;
    private static HS[] s_numberPasingState;
    private static HebrewNumber();
    internal static string ToString(int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    internal static Int32[] HijriMonthDays;
    private int _hijriAdvance;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private long GetAbsoluteDateHijri(int y, int m, int d);
    private long DaysUpToHijriYear(int HijriYear);
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    private static int GetHijriDateAdjustment();
}
public class System.Globalization.IdnMapping : object {
    private bool _allowUnassigned;
    private bool _useStd3AsciiRules;
    private static Char[] c_Dots;
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    private UInt32 Flags { get; }
    private static IdnMapping();
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetStringForOutput(string originalString, Char* input, int inputLength, Char* output, int outputLength);
    private string GetAsciiInvariant(string unicode, int index, int count);
    private static bool ValidateStd3AndAscii(string unicode, bool bUseStd3, bool bCheckAscii);
    private static string PunycodeEncode(string unicode);
    private static bool IsDot(char c);
    private static bool IsSupplementary(int cTest);
    private static bool Basic(UInt32 cp);
    private static void ValidateStd3(char c, bool bNextToDot);
    private string GetUnicodeInvariant(string ascii, int index, int count);
    private static string PunycodeDecode(string ascii);
    private static int DecodeDigit(char cp);
    private static int Adapt(int delta, int numpoints, bool firsttime);
    private static char EncodeBasic(char bcp);
    private static bool HasUpperCaseFlag(char punychar);
    private static char EncodeDigit(int d);
    private string GetAsciiCore(string unicodeString, Char* unicode, int count);
    private string GetUnicodeCore(string asciiString, Char* ascii, int count);
    private string GetUnicodeCore(string asciiString, Char* ascii, int count, UInt32 flags, Char* output, int outputLength, bool reattempt);
    private UInt32 get_Flags();
    private static void CheckInvalidIdnCharacters(Char* s, int count, UInt32 flags, string paramName);
}
internal class System.Globalization.InternalGlobalizationHelper : object {
    internal static long TimeToTicks(int hour, int minute, int second);
}
public class System.Globalization.JapaneseCalendar : Calendar {
    internal static DateTime calendarMinValue;
    internal static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) japaneseEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    internal static Calendar GetDefaultInstance();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    private static EraInfo[] GetJapaneseEras();
    private static string GetAbbreviatedEraName(String[] eraNames, int eraIndex);
    private static bool GetJapaneseEraStartDate(int era, DateTime& dateTime);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    internal GregorianCalendarHelper helper;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    private static EraInfo[] TrimEras(EraInfo[] baseEras);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    internal int MaxYear;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    internal static EraInfo[] koreanEraInfo;
    internal GregorianCalendarHelper helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
internal class System.Globalization.LocaleData : object {
    private static Int32[] s_localeNamesIndices;
    private static Int32[] s_nameIndexToNumericData;
    private static Int32[] s_lcids;
    private static Int32[] s_lcidToCultureNameIndices;
    private static LocaleData();
    internal static string LCIDToLocaleName(int culture);
    internal static int GetLocaleDataNumericPart(string cultureName, LocaleDataParts part);
    internal static string GetThreeLetterWindowsLangageName(string cultureName);
    internal static string GetLocaleDataMappedCulture(string cultureName, LocaleDataParts part);
    internal static string GetSpecificCultureName(string cultureName);
    internal static string GetConsoleUICulture(string cultureName);
    private static int SearchCultureName(string name);
    private static int CompareOrdinal(string s1, string s2, int index, int length);
}
internal enum System.Globalization.LocaleDataParts : Enum {
    public int value__;
    public static LocaleDataParts Lcid;
    public static LocaleDataParts AnsiCodePage;
    public static LocaleDataParts OemCodePage;
    public static LocaleDataParts MacCodePage;
    public static LocaleDataParts EbcdicCodePage;
    public static LocaleDataParts GeoId;
    public static LocaleDataParts DigitSubstitution;
    public static LocaleDataParts SpecificLocaleIndex;
    public static LocaleDataParts ConsoleLocaleIndex;
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
internal static class System.Globalization.Normalization : object {
    internal static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    internal static string Normalize(string strInput, NormalizationForm normalizationForm);
    private static void ValidateArguments(string strInput, NormalizationForm normalizationForm);
    private static bool HasInvalidUnicodeSequence(string s);
}
public class System.Globalization.NumberFormatInfo : object {
    private static NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    internal Int32[] numberGroupSizes;
    internal Int32[] currencyGroupSizes;
    internal Int32[] percentGroupSizes;
    internal string positiveSign;
    internal string negativeSign;
    internal string numberDecimalSeparator;
    internal string numberGroupSeparator;
    internal string currencyGroupSeparator;
    internal string currencyDecimalSeparator;
    internal string currencySymbol;
    internal string nanSymbol;
    internal string positiveInfinitySymbol;
    internal string negativeInfinitySymbol;
    internal string percentDecimalSeparator;
    internal string percentGroupSeparator;
    internal string percentSymbol;
    internal string perMilleSymbol;
    internal String[] nativeDigits;
    internal int numberDecimalDigits;
    internal int currencyDecimalDigits;
    internal int currencyPositivePattern;
    internal int currencyNegativePattern;
    internal int numberNegativePattern;
    internal int percentPositivePattern;
    internal int percentNegativePattern;
    internal int percentDecimalDigits;
    internal int digitSubstitution;
    internal bool isReadOnly;
    internal bool m_isInvariant;
    private static NumberStyles InvalidNumberStyles;
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public DigitShapes DigitSubstitution { get; public set; }
    internal NumberFormatInfo(CultureData cultureData);
    private static void VerifyDecimalSeparator(string decSep, string propertyName);
    private static void VerifyGroupSeparator(string groupSep, string propertyName);
    private static void VerifyNativeDigits(String[] nativeDig, string propertyName);
    private static void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName);
    private void VerifyWritable();
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
    [CompilerGeneratedAttribute]
internal static NumberFormatInfo <GetInstance>g__GetProviderNonNull|39_0(IFormatProvider provider);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    internal static long PersianEpoch;
    internal static Int32[] DaysToMonth;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    private long GetAbsoluteDatePersian(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static int MonthFromOrdinalDay(int ordinalDay);
    private static int DaysInPreviousMonths(int month);
    internal int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.RegionInfo : object {
    internal string _name;
    internal CultureData _cultureData;
    internal static RegionInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_currentRegionInfo;
    public static RegionInfo CurrentRegion { get; }
    public string Name { get; }
    public string EnglishName { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string TwoLetterISORegionName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public bool IsMetric { get; }
    public int GeoId { get; }
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public string ISOCurrencySymbol { get; }
    public RegionInfo(string name);
    public RegionInfo(int culture);
    internal RegionInfo(CultureData cultureData);
    private void SetName(string name);
    public static RegionInfo get_CurrentRegion();
    public virtual string get_Name();
    public virtual string get_EnglishName();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_TwoLetterISORegionName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual bool get_IsMetric();
    public virtual int get_GeoId();
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public virtual string get_ISOCurrencySymbol();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortKey : object {
    internal string _localeName;
    internal CompareOptions _options;
    internal string _string;
    internal Byte[] _keyData;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(string localeName, string str, CompareOptions options, Byte[] keyData);
    public virtual string get_OriginalString();
    public virtual Byte[] get_KeyData();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.SortVersion : object {
    private int m_NlsVersion;
    private Guid m_SortId;
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
public class System.Globalization.StringInfo : object {
    private string _str;
    private Int32[] _indexes;
    private Int32[] Indexes { get; }
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    private Int32[] get_Indexes();
    public string get_String();
    public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    internal static int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
public class System.Globalization.TaiwanCalendar : Calendar {
    internal static EraInfo[] taiwanEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    internal static DateTime calendarMinValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    internal static EraInfo[] taiwanLunisolarEraInfo;
    internal GregorianCalendarHelper helper;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
public class System.Globalization.TextElementEnumerator : object {
    private string _str;
    private int _index;
    private int _startIndex;
    private int _strLen;
    private int _currTextElementLen;
    private UnicodeCategory _uc;
    private int _charLen;
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex, int strLen);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
public class System.Globalization.TextInfo : object {
    private string _listSeparator;
    private bool _isReadOnly;
    private string _cultureName;
    private CultureData _cultureData;
    private string _textInfoName;
    private Tristate _isAsciiCasingSameAsInvariant;
    private bool _invariantMode;
    private Tristate _needsTurkishCasing;
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    public int LCID { get; }
    public string CultureName { get; }
    public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    private bool IsAsciiCasingSameAsInvariant { get; }
    public bool IsRightToLeft { get; }
    private bool IsInvariant { get; }
    internal TextInfo(CultureData cultureData);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual int get_ANSICodePage();
    public virtual int get_OEMCodePage();
    public virtual int get_MacCodePage();
    public virtual int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    public virtual string get_ListSeparator();
    public virtual void set_ListSeparator(string value);
    public virtual char ToLower(char c);
    public virtual string ToLower(string str);
    private char ChangeCase(char c, bool toUpper);
    private string ChangeCase(string source, bool toUpper);
    internal void ChangeCase(ReadOnlySpan`1<char> source, Span`1<char> destination, bool toUpper);
    private string ToLowerAsciiInvariant(string s);
    internal void ToLowerAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private string ToUpperAsciiInvariant(string s);
    internal void ToUpperAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private static char ToLowerAsciiInvariant(char c);
    public virtual char ToUpper(char c);
    public virtual string ToUpper(string str);
    internal static char ToUpperAsciiInvariant(char c);
    private static bool IsAscii(char c);
    private bool get_IsAsciiCasingSameAsInvariant();
    public bool get_IsRightToLeft();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    private static int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private static bool IsWordSeparator(UnicodeCategory category);
    private static bool IsLetterCategory(UnicodeCategory uc);
    private void FinishInitialization();
    private bool NeedsTurkishCasing(string localeName);
    private bool get_IsInvariant();
    internal void ChangeCase(Char* src, int srcLen, Char* dstBuffer, int dstBufferCapacity, bool bToUpper);
}
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    internal static EraInfo[] thaiBuddhistEraInfo;
    public static int ThaiBuddhistEra;
    internal GregorianCalendarHelper helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    private static void AppendNonNegativeInt32(StringBuilder sb, int n, int digits);
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    internal static bool TryFormat(TimeSpan value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    private static StringBuilder FormatToBuilder(TimeSpan value, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    private static StringBuilder FormatStandard(TimeSpan value, bool isInvariant, ReadOnlySpan`1<char> format, Pattern pattern);
    private static StringBuilder FormatCustomized(TimeSpan value, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, StringBuilder result);
}
internal static class System.Globalization.TimeSpanParse : object {
    internal static long Pow10(int pow);
    private static bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result);
    internal static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    internal static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    private static bool TryParseTimeSpan(ReadOnlySpan`1<char> input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result);
    private static bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool TryParseExactTimeSpan(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool TryParseByFormat(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result);
    private static bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, StringBuilder enquotedString);
    private static bool TryParseTimeSpanConstant(ReadOnlySpan`1<char> input, TimeSpanResult& result);
    private static bool TryParseExactMultipleTimeSpan(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    private static DateMapping[] s_hijriYearInfo;
    public static int UmAlQuraEra;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    private static DateMapping[] InitDateMapping();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private static void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg);
    private static long GetAbsoluteDateUmAlQura(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay);
    internal virtual int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    public Guid(Byte[] b);
    public Guid(ReadOnlySpan`1<byte> b);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(string g);
    private static Guid();
    public static Guid Parse(string input);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Guid& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    public static Guid ParseExact(string input, string format);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    public static bool TryParseExact(string input, string format, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    private static bool TryParseGuid(ReadOnlySpan`1<char> guidString, GuidStyles flags, GuidResult& result);
    private static bool TryParseGuidWithHexPrefix(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseGuidWithNoStyle(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseGuidWithDashes(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool StringToShort(ReadOnlySpan`1<char> str, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToShort(ReadOnlySpan`1<char> str, Int32& parsePos, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToInt(ReadOnlySpan`1<char> str, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToInt(ReadOnlySpan`1<char> str, Int32& parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToLong(ReadOnlySpan`1<char> str, Int32& parsePos, int flags, Int64& result, GuidResult& parseResult);
    private static ReadOnlySpan`1<char> EatAllWhitespace(ReadOnlySpan`1<char> str);
    private static bool IsHexPrefix(ReadOnlySpan`1<char> str, int i);
    private void WriteByteHelper(Span`1<byte> destination);
    public Byte[] ToByteArray();
    public bool TryWriteBytes(Span`1<byte> destination);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    private int GetResult(UInt32 me, UInt32 them);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public string ToString(string format);
    private static char HexToChar(int a);
    private static int HexsToChars(Char* guidChars, int a, int b);
    private static int HexsToCharsHexOutput(Char* guidChars, int a, int b);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static Guid NewGuid();
}
public class System.HashCode : ValueType {
    private static UInt32 s_seed;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static UInt32 Rol(UInt32 value, int count);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
public virtual bool Equals(object obj);
}
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
public interface System.ICloneable {
    public abstract virtual object Clone();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
    internal InsufficientExecutionStackException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
    private InsufficientMemoryException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int16 : ValueType {
    private short m_value;
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, IFormatProvider provider);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int32 : ValueType {
    private int m_value;
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(int value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, IFormatProvider provider);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int64 : ValueType {
    private long m_value;
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, IFormatProvider provider);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IntPtr : ValueType {
    private Void* _value;
    [IntrinsicAttribute]
public static IntPtr Zero;
    public static int Size { get; }
    [IntrinsicAttribute]
[NonVersionableAttribute]
public IntPtr(int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public IntPtr(long value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public IntPtr(Void* value);
    private IntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
    public virtual int GetHashCode();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public int ToInt32();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public long ToInt64();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Explicit(int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Explicit(long value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static IntPtr op_Explicit(Void* value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int op_Explicit(IntPtr value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static long op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static IntPtr Add(IntPtr pointer, int offset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int get_Size();
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public Void* ToPointer();
    public virtual string ToString();
    public string ToString(string format);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    internal InvalidProgramException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
public class System.IO.BinaryReader : object {
    private Stream _stream;
    private Byte[] _buffer;
    private Decoder _decoder;
    private Byte[] _charBytes;
    private Char[] _singleChar;
    private Char[] _charBuffer;
    private int _maxCharsSize;
    private bool _2BytesPerChar;
    private bool _isMemoryStream;
    private bool _leaveOpen;
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual int PeekChar();
    public virtual int Read();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual char ReadChar();
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    private int InternalReadChars(Span`1<char> buffer);
    private int InternalReadOneChar();
    public virtual Char[] ReadChars(int count);
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Byte[] ReadBytes(int count);
    protected virtual void FillBuffer(int numBytes);
    protected internal int Read7BitEncodedInt();
}
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    private Byte[] _buffer;
    private Encoding _encoding;
    private Encoder _encoder;
    private bool _leaveOpen;
    private Byte[] _largeByteBuffer;
    private int _maxChars;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<char> chars);
    protected void Write7BitEncodedInt(int value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.EncodingCache : object {
    internal static Encoding UTF8NoBOM;
    private static EncodingCache();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.Error : object {
    internal static Exception GetStreamIsClosed();
    internal static Exception GetEndOfFile();
    internal static Exception GetFileNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileLoadException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private FileLoadException(string fileName, string fusionLog, int hResult);
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
    private static void GetFileLoadExceptionMessage(int hResult, StringHandleOnStack retString);
    private static void GetMessageForHR(int hresult, StringHandleOnStack retString);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileNotFoundException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private FileNotFoundException(string fileName, string fusionLog, int hResult);
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
public class System.IO.FileStream : Stream {
    private Byte[] _buffer;
    private int _bufferLength;
    private SafeFileHandle _fileHandle;
    private FileAccess _access;
    private string _path;
    private int _readPos;
    private int _readLength;
    private int _writePos;
    private bool _useAsyncIO;
    private Task`1<int> _lastSynchronouslyCompletedTask;
    private long _filePosition;
    private bool _exposedHandle;
    private FileMode _mode;
    private FileOptions _options;
    private long _appendStart;
    private AsyncState _asyncState;
    private Nullable`1<bool> _canSeek;
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public string Name { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool IsClosed { get; }
    public bool CanSeek { get; }
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    private void ValidateAndInitFromHandle(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    private static bool GetDefaultIsAsync(SafeFileHandle handle);
    public virtual IntPtr get_Handle();
    public virtual void Lock(long position, long length);
    public virtual void Unlock(long position, long length);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private Task`1<int> ReadAsyncTask(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    private void ValidateReadWriteArgs(Byte[] array, int offset, int count);
    public virtual void SetLength(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual string get_Name();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    private void VerifyOSHandlePosition();
    [ConditionalAttribute("DEBUG")]
private void AssertBufferInvariants();
    private void PrepareForReading();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal virtual bool get_IsClosed();
    private static bool IsIoRelatedException(Exception e);
    private Byte[] GetBuffer();
    private void FlushInternalBuffer();
    private void FlushReadBuffer();
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    private void PrepareForWriting();
    protected virtual override void Finalize();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void LockInternal(long position, long length);
    private void UnlockInternal(long position, long length);
    private SafeFileHandle OpenHandle(FileMode mode, FileShare share, FileOptions options);
    private void Init(FileMode mode, FileShare share);
    private void InitFromHandle(SafeFileHandle handle, FileAccess access, bool useAsyncIO);
    private static OpenFlags PreOpenConfigurationFromOptions(FileMode mode, FileAccess access, FileShare share, FileOptions options);
    public virtual bool get_CanSeek();
    private bool CanSeekCore(SafeFileHandle fileHandle);
    private long GetLengthInternal();
    protected virtual void Dispose(bool disposing);
    private void FlushOSBuffer();
    private void FlushWriteBufferForWriteByte();
    private void FlushWriteBuffer();
    private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void SetLengthInternal(long value);
    private int ReadSpan(Span`1<byte> destination);
    private int ReadNative(Span`1<byte> buffer);
    private Task`1<int> ReadAsyncInternal(Memory`1<byte> destination, CancellationToken cancellationToken, Int32& synchronousResult);
    private int FillReadBufferForReadByte();
    private void WriteSpan(ReadOnlySpan`1<byte> source);
    private void WriteNative(ReadOnlySpan`1<byte> source);
    private ValueTask WriteAsyncInternal(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    private long SeekCore(SafeFileHandle fileHandle, long offset, SeekOrigin origin);
    private long CheckFileCall(long result, bool ignoreNotSupported);
    private int CheckFileCall(int result, bool ignoreNotSupported);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, int hresult);
    public IOException(string message, Exception innerException);
    protected IOException(SerializationInfo info, StreamingContext context);
}
public class System.IO.MemoryStream : Stream {
    private Byte[] _buffer;
    private int _origin;
    private int _position;
    private int _length;
    private int _capacity;
    private bool _expandable;
    private bool _writable;
    private bool _exposable;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureNotClosed();
    private void EnsureWriteable();
    protected virtual void Dispose(bool disposing);
    private bool EnsureCapacity(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    internal Byte[] InternalGetBuffer();
    internal int InternalGetPosition();
    internal int InternalReadInt32();
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
public static class System.IO.Path : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static char PathSeparator;
    [ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    private static Char[] s_base32Char;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static Path();
    public static string ChangeExtension(string path, string extension);
    public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    private static int GetDirectoryNameOffset(ReadOnlySpan`1<char> path);
    public static string GetExtension(string path);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    public static string GetFileName(string path);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    public static string GetFileNameWithoutExtension(string path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    public static string GetRandomFileName();
    public static bool IsPathFullyQualified(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    public static bool HasExtension(string path);
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    private static string CombineInternal(string first, string second);
    private static string CombineInternal(string first, string second, string third);
    private static string CombineInternal(string first, string second, string third, string fourth);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third, ReadOnlySpan`1<char> fourth);
    private static void Populate83FileNameFromRandomBytes(Byte* bytes, int byteCount, Char* chars, int charCount);
    public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    internal static StringComparison get_StringComparison();
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static string GetFullPath(string path);
    public static string GetFullPath(string path, string basePath);
    public static string GetTempPath();
    public static string GetTempFileName();
    public static bool IsPathRooted(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    public static string GetPathRoot(string path);
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    internal static bool get_IsCaseSensitive();
}
internal static class System.IO.PathInternal : object {
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsEffectivelyEmpty(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    private Byte[] _array;
    private GCHandle _pinningHandle;
    internal PinnedBufferMemoryStream(Byte[] array);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    private ReadWriteTask _activeReadWriteTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private static Stream();
    internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<CopyToAsyncInternal>d__28")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    private int GetCopyBufferSize();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    public virtual int EndRead(IAsyncResult asyncResult);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private bool HasOverriddenBeginEndRead();
    private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    private void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask);
    private void RunReadWriteTask(ReadWriteTask readWriteTask);
    private void FinishTrackingAsyncOperation();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<FinishWriteAsync>d__58")]
private Task FinishWriteAsync(Task writeTask, Byte[] localBuffer);
    private bool HasOverriddenBeginEndWrite();
    private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static int BlockingEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static void BlockingEndWrite(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.IO.Stream/<<ReadAsync>g__FinishReadAsync|44_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|44_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    private Stream _stream;
    private Encoding _encoding;
    private Decoder _decoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private int _byteLen;
    private int _bytePos;
    private int _maxCharsPerBuffer;
    private bool _detectEncoding;
    private bool _checkPreamble;
    private bool _isBlocked;
    private bool _closable;
    private Task _asyncReadTask;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    private static StreamReader();
    private void CheckAsyncTaskInProgress();
    private static void ThrowAsyncIOInProgress();
    private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    internal void Init(Stream stream);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    public void DiscardBufferedData();
    public bool get_EndOfStream();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    private int ReadSpan(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    private void CompressBuffer(int n);
    private void DetectEncoding();
    private bool IsPreamble();
    internal virtual int ReadBuffer();
    private int ReadBuffer(Span`1<char> userBuffer, Boolean& readToUserBuffer);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadLineAsyncInternal>d__61")]
private Task`1<string> ReadLineAsyncInternal();
    public virtual Task`1<string> ReadToEndAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadToEndAsyncInternal>d__63")]
private Task`1<string> ReadToEndAsyncInternal();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadAsyncInternal>d__66")]
internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadBufferAsync>d__69")]
private Task`1<int> ReadBufferAsync();
}
public class System.IO.StreamWriter : TextWriter {
    public static StreamWriter Null;
    private Stream _stream;
    private Encoding _encoding;
    private Encoder _encoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private bool _autoFlush;
    private bool _haveWrittenPreamble;
    private bool _closable;
    private Task _asyncWriteTask;
    private static Encoding UTF8NoBOM { get; }
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    unknown bool HaveWrittenPreamble {internal set; }
    public Encoding Encoding { get; }
    unknown int CharPos_Prop {private set; }
    unknown bool HaveWrittenPreamble_Prop {private set; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    private static StreamWriter();
    private void CheckAsyncTaskInProgress();
    private static void ThrowAsyncIOInProgress();
    private static Encoding get_UTF8NoBOM();
    private void Init(Stream streamArg, Encoding encodingArg, int bufferSize, bool shouldLeaveOpen);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    private void Flush(bool flushStream, bool flushEncoder);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    internal void set_HaveWrittenPreamble(bool value);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    private void WriteSpan(ReadOnlySpan`1<char> buffer, bool appendNewLine);
    public virtual void Write(string value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> value);
    public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__54")]
private static Task WriteAsyncInternal(StreamWriter _this, char value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(string value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__56")]
private static Task WriteAsyncInternal(StreamWriter _this, string value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__59")]
private static Task WriteAsyncInternal(StreamWriter _this, ReadOnlyMemory`1<char> source, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    private void set_CharPos_Prop(int value);
    private void set_HaveWrittenPreamble_Prop(bool value);
    private Task FlushAsyncInternal(bool flushStream, bool flushEncoder, Char[] sCharBuffer, int sCharPos, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<FlushAsyncInternal>d__71")]
private static Task FlushAsyncInternal(StreamWriter _this, bool flushStream, bool flushEncoder, Char[] charBuffer, int charPos, bool haveWrittenPreamble, Encoding encoding, Encoder encoder, Byte[] byteBuffer, Stream stream, CancellationToken cancellationToken);
}
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    private static TextReader();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadToEndAsync>d__14")]
public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadBlockAsyncInternal>d__20")]
internal ValueTask`1<int> ReadBlockAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public static TextReader Synchronized(TextReader reader);
}
public abstract class System.IO.TextWriter : MarshalByRefObject {
    public static TextWriter Null;
    private static Char[] s_coreNewLine;
    protected Char[] CoreNewLine;
    private string CoreNewLineStr;
    private IFormatProvider _internalFormatProvider;
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    protected TextWriter(IFormatProvider formatProvider);
    private static TextWriter();
    public virtual IFormatProvider get_FormatProvider();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual void Flush();
    public abstract virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(string value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
}
public class System.IO.UnmanagedMemoryAccessor : object {
    private SafeBuffer _buffer;
    private long _offset;
    private long _capacity;
    private FileAccess _access;
    private bool _isOpen;
    private bool _canRead;
    private bool _canWrite;
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    public decimal ReadDecimal(long position);
    public float ReadSingle(long position);
    public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    public void Write(long position, decimal value);
    public void Write(long position, float value);
    public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void Write(long position, T& structure);
    public void WriteArray(long position, T[] array, int offset, int count);
    private void EnsureSafeToRead(long position, int sizeOfType);
    private void EnsureSafeToWrite(long position, int sizeOfType);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    private SafeBuffer _buffer;
    private Byte* _mem;
    private long _length;
    private long _capacity;
    private long _position;
    private long _offset;
    private FileAccess _access;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    private void EnsureNotClosed();
    private void EnsureReadable();
    private void EnsureWriteable();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public long get_Capacity();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    internal int ReadCore(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    private UnmanagedMemoryStream _unmanagedStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static string GetMessage(int errorCode);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
internal interface System.IRuntimeFieldInfo {
    public RuntimeFieldHandleInternal Value { get; }
    public abstract virtual RuntimeFieldHandleInternal get_Value();
}
internal interface System.IRuntimeMethodInfo {
    public RuntimeMethodHandleInternal Value { get; }
    public abstract virtual RuntimeMethodHandleInternal get_Value();
}
internal interface System.ISpanFormattable {
    public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
internal interface System.ITupleInternal {
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
internal interface System.IValueTupleInternal {
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual string ToStringEnd();
}
[DebuggerTypeProxyAttribute("System.LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
public class System.Lazy`1 : object {
    private LazyHelper modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Func`1<T> _factory;
    private T _value;
    internal T ValueForDebugDisplay { get; }
    internal Nullable`1<LazyThreadSafetyMode> Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode, bool useDefaultConstructor);
    private static T CreateViaDefaultConstructor();
    private void ViaConstructor();
    private void ViaFactory(LazyThreadSafetyMode mode);
    private void ExecutionAndPublication(LazyHelper executionAndPublication, bool useDefaultConstructor);
    private void PublicationOnly(LazyHelper publicationOnly, T possibleValue);
    private void PublicationOnlyViaConstructor(LazyHelper initializer);
    private void PublicationOnlyViaFactory(LazyHelper initializer);
    private void PublicationOnlyWaitForOtherThreadToPublish();
    private T CreateValue();
    public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal Nullable`1<LazyThreadSafetyMode> get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
internal class System.LazyDebugView`1 : object {
    private Lazy`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Nullable`1<LazyThreadSafetyMode> Mode { get; }
    public bool IsValueFaulted { get; }
    public LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public Nullable`1<LazyThreadSafetyMode> get_Mode();
    public bool get_IsValueFaulted();
}
internal class System.LazyHelper : object {
    internal static LazyHelper NoneViaConstructor;
    internal static LazyHelper NoneViaFactory;
    internal static LazyHelper PublicationOnlyViaConstructor;
    internal static LazyHelper PublicationOnlyViaFactory;
    internal static LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
    [CompilerGeneratedAttribute]
private LazyState <State>k__BackingField;
    private ExceptionDispatchInfo _exceptionDispatch;
    internal LazyState State { get; }
    internal LazyHelper(LazyState state);
    internal LazyHelper(LazyThreadSafetyMode mode, Exception exception);
    private static LazyHelper();
    [CompilerGeneratedAttribute]
internal LazyState get_State();
    internal void ThrowException();
    private LazyThreadSafetyMode GetMode();
    internal static Nullable`1<LazyThreadSafetyMode> GetMode(LazyHelper state);
    internal static bool GetIsValueFaulted(LazyHelper state);
    internal static LazyHelper Create(LazyThreadSafetyMode mode, bool useDefaultConstructor);
    internal static object CreateViaDefaultConstructor(Type type);
    internal static LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
}
internal enum System.LazyState : Enum {
    public int value__;
    public static LazyState NoneViaConstructor;
    public static LazyState NoneViaFactory;
    public static LazyState NoneException;
    public static LazyState PublicationOnlyViaConstructor;
    public static LazyState PublicationOnlyViaFactory;
    public static LazyState PublicationOnlyWait;
    public static LazyState PublicationOnlyException;
    public static LazyState ExecutionAndPublicationViaConstructor;
    public static LazyState ExecutionAndPublicationViaFactory;
    public static LazyState ExecutionAndPublicationException;
}
public abstract class System.MarshalByRefObject : object {
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
internal static class System.Marvin : object {
    [CompilerGeneratedAttribute]
private static ulong <DefaultSeed>k__BackingField;
    public static ulong DefaultSeed { get; }
    private static Marvin();
    public static int ComputeHash32(ReadOnlySpan`1<byte> data, ulong seed);
    public static int ComputeHash32(Byte& data, int count, ulong seed);
    private static void Block(UInt32& rp0, UInt32& rp1);
    private static UInt32 _rotl(UInt32 value, int shift);
    [CompilerGeneratedAttribute]
public static ulong get_DefaultSeed();
    private static ulong GenerateSeed();
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    private static double doubleRoundLimit;
    private static Double[] roundPower10Double;
    private static Math();
    public static double Abs(double value);
    public static float Abs(float value);
    public static double Acos(double d);
    public static double Acosh(double d);
    public static double Asin(double d);
    public static double Asinh(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static double Atanh(double d);
    public static double Cbrt(double d);
    public static double Ceiling(double a);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static double Exp(double d);
    public static double Floor(double d);
    public static double Log(double d);
    public static double Log10(double d);
    public static double Pow(double x, double y);
    public static double Sin(double a);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    private static double FMod(double x, double y);
    private static double ModF(double x, Double* intptr);
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static decimal Abs(decimal value);
    [StackTraceHiddenAttribute]
private static void ThrowAbsOverflow();
    public static long BigMul(int a, int b);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    public static decimal Ceiling(decimal d);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    public static decimal Floor(decimal d);
    public static double IEEERemainder(double x, double y);
    public static double Log(double a, double newBase);
    [NonVersionableAttribute]
public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    [NonVersionableAttribute]
public static short Max(short val1, short val2);
    [NonVersionableAttribute]
public static int Max(int val1, int val2);
    [NonVersionableAttribute]
public static long Max(long val1, long val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Max(ulong val1, ulong val2);
    [NonVersionableAttribute]
public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    [NonVersionableAttribute]
public static short Min(short val1, short val2);
    [NonVersionableAttribute]
public static int Min(int val1, int val2);
    [NonVersionableAttribute]
public static long Min(long val1, long val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong Min(ulong val1, ulong val2);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    [IntrinsicAttribute]
public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
    private static double copysign(double x, double y);
    private static void ThrowMinMaxException(T min, T max);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    private static Single[] roundPower10Single;
    private static float singleRoundLimit;
    private static MathF();
    public static float Acos(float x);
    public static float Acosh(float x);
    public static float Asin(float x);
    public static float Asinh(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Atanh(float x);
    public static float Cbrt(float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float Log(float x);
    public static float Log10(float x);
    public static float Pow(float x, float y);
    public static float Sin(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    private static float FMod(float x, float y);
    private static float ModF(float x, Single* intptr);
    public static float Abs(float x);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x, float y);
    public static float Max(float x, float y);
    public static float Min(float x, float y);
    [IntrinsicAttribute]
public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, MidpointRounding mode);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static int Sign(float x);
    public static float Truncate(float x);
    private static float CopySign(float x, float y);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
public class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    private static int RemoveFlagsBitMask;
    public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    private static bool IsTypeComparableAsBytes(UInt64& size);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool EqualsOrdinal(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool Contains(ReadOnlySpan`1<char> source, char value);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public MissingFieldException(string className, string fieldName);
    public virtual string get_Message();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public MissingMemberException(string className, string memberName);
    public virtual string get_Message();
    internal static string FormatSignature(Byte[] signature);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
    public MissingMethodException(string className, string methodName);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
public class System.ModuleHandle : ValueType {
    public static ModuleHandle EmptyHandle;
    private RuntimeModule m_ptr;
    public int MDStreamVersion { get; }
    internal ModuleHandle(RuntimeModule module);
    private static ModuleHandle();
    private static ModuleHandle GetEmptyMH();
    internal RuntimeModule GetRuntimeModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ModuleHandle handle);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    internal static IRuntimeMethodInfo GetDynamicMethod(DynamicMethod method, RuntimeModule module, string name, Byte[] sig, Resolver resolver);
    internal static int GetToken(RuntimeModule module);
    private static void ValidateModulePointer(RuntimeModule module);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static RuntimeType ResolveTypeHandleInternal(RuntimeModule module, int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    private static void ResolveType(RuntimeModule module, int typeToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount, ObjectHandleOnStack type);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static RuntimeMethodHandleInternal ResolveMethodHandleInternalCore(RuntimeModule module, int methodToken, IntPtr[] typeInstantiationContext, int typeInstCount, IntPtr[] methodInstantiationContext, int methodInstCount);
    private static RuntimeMethodHandleInternal ResolveMethod(RuntimeModule module, int methodToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static IRuntimeFieldInfo ResolveFieldHandleInternal(RuntimeModule module, int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    private static void ResolveField(RuntimeModule module, int fieldToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount, ObjectHandleOnStack retField);
    private static bool _ContainsPropertyMatchingHash(RuntimeModule module, int propertyToken, UInt32 hash);
    internal static bool ContainsPropertyMatchingHash(RuntimeModule module, int propertyToken, UInt32 hash);
    internal static void GetModuleType(RuntimeModule handle, ObjectHandleOnStack type);
    internal static RuntimeType GetModuleType(RuntimeModule module);
    private static void GetPEKind(RuntimeModule handle, Int32& peKind, Int32& machine);
    internal static void GetPEKind(RuntimeModule module, PortableExecutableKinds& peKind, ImageFileMachine& machine);
    internal static int GetMDStreamVersion(RuntimeModule module);
    public int get_MDStreamVersion();
    private static IntPtr _GetMetadataImport(RuntimeModule module);
    internal static MetadataImport GetMetadataImport(RuntimeModule module);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public abstract class System.MulticastDelegate : Delegate {
    private object _invocationList;
    private IntPtr _invocationCount;
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    internal bool IsUnmanagedFunctionPtr();
    internal bool InvocationListLogicallyNull();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual bool Equals(object obj);
    private bool InvocationListEquals(MulticastDelegate d);
    private bool TrySetSlot(Object[] a, int index, object o);
    private MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount, bool thisIsMultiCastAlready);
    internal MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount);
    internal void StoreDynamicMethod(MethodInfo dynamicMethod);
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    private Object[] DeleteFromInvocationList(Object[] invocationList, int invocationCount, int deleteIndex, int deleteCount);
    private bool EqualInvocationLists(Object[] a, Object[] b, int start, int count);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
    public sealed virtual Delegate[] GetInvocationList();
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    public sealed virtual int GetHashCode();
    internal virtual object GetTarget();
    protected virtual MethodInfo GetMethodImpl();
    [DebuggerNonUserCodeAttribute]
private void ThrowNullThisInDelegateToInstance();
    [DebuggerNonUserCodeAttribute]
private void CtorClosed(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorClosedStatic(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorRTClosed(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk);
    [DebuggerNonUserCodeAttribute]
private void CtorVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleClosedStatic(object target, IntPtr methodPtr, IntPtr gchandle);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr gchandle);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr gchandle);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotFiniteNumberException : ArithmeticException {
    private double _offendingNumber;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NonVersionableAttribute]
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [NonVersionableAttribute]
public Nullable`1(T value);
    [NonVersionableAttribute]
public bool get_HasValue();
    public T get_Value();
    [NonVersionableAttribute]
public T GetValueOrDefault();
    [NonVersionableAttribute]
public T GetValueOrDefault(T defaultValue);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NonVersionableAttribute]
public static Nullable`1<T> op_Implicit(T value);
    [NonVersionableAttribute]
public static T op_Explicit(Nullable`1<T> value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
internal static class System.Number : object {
    private static String[] s_posCurrencyFormats;
    private static String[] s_negCurrencyFormats;
    private static String[] s_posPercentFormats;
    private static String[] s_negPercentFormats;
    private static String[] s_negNumberFormats;
    private static Number();
    public static void DoubleToNumber(double value, int precision, NumberBuffer& number);
    public static double NumberToDouble(NumberBuffer& number);
    public static bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value);
    public static string FormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static bool TryFormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static void DecimalToNumber(decimal value, NumberBuffer& number);
    public static string FormatDouble(double value, string format, NumberFormatInfo info);
    public static bool TryFormatDouble(double value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatDouble(ValueStringBuilder& sb, double value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static string FormatSingle(float value, string format, NumberFormatInfo info);
    public static bool TryFormatSingle(float value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatSingle(ValueStringBuilder& sb, float value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static bool TryCopyTo(string source, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    private static void Int32ToNumber(int value, NumberBuffer& number);
    private static string NegativeInt32ToDecStr(int value, int digits, string sNegative);
    private static bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int32ToHexStr(int value, char hexBase, int digits);
    private static bool TryInt32ToHexStr(int value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static Char* Int32ToHexChars(Char* buffer, UInt32 value, int hexBase, int digits);
    private static void UInt32ToNumber(UInt32 value, NumberBuffer& number);
    internal static Char* UInt32ToDecChars(Char* bufferEnd, UInt32 value, int digits);
    private static string UInt32ToDecStr(UInt32 value, int digits);
    private static bool TryUInt32ToDecStr(UInt32 value, int digits, Span`1<char> destination, Int32& charsWritten);
    private static void Int64ToNumber(long input, NumberBuffer& number);
    private static string NegativeInt64ToDecStr(long input, int digits, string sNegative);
    private static bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int64ToHexStr(long value, char hexBase, int digits);
    private static bool TryInt64ToHexStr(long value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static void UInt64ToNumber(ulong value, NumberBuffer& number);
    private static string UInt64ToDecStr(ulong value, int digits);
    private static bool TryUInt64ToDecStr(ulong value, int digits, Span`1<char> destination, Int32& charsWritten);
    internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    internal static void NumberToString(ValueStringBuilder& sb, NumberBuffer& number, char format, int nMaxDigits, NumberFormatInfo info, bool isDecimal);
    internal static void NumberToStringFormat(ValueStringBuilder& sb, NumberBuffer& number, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static void FormatCurrency(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info);
    private static void FormatFixed(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info, Int32[] groupDigits, string sDecimal, string sGroup);
    private static void FormatNumber(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info);
    private static void FormatScientific(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info, char expChar);
    private static void FormatExponent(ValueStringBuilder& sb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
    private static void FormatGeneral(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info, char expChar, bool bSuppressScientific);
    private static void FormatPercent(ValueStringBuilder& sb, NumberBuffer& number, int nMinDigits, int nMaxDigits, NumberFormatInfo info);
    private static void RoundNumber(NumberBuffer& number, int pos);
    private static int FindSection(ReadOnlySpan`1<char> format, int section);
    private static UInt32 Low32(ulong value);
    private static UInt32 High32(ulong value);
    private static UInt32 Int64DivMod1E9(UInt64& value);
    private static bool HexNumberToInt32(NumberBuffer& number, Int32& value);
    private static bool HexNumberToInt64(NumberBuffer& number, Int64& value);
    private static bool HexNumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool HexNumberToUInt64(NumberBuffer& number, UInt64& value);
    private static bool NumberToInt32(NumberBuffer& number, Int32& value);
    private static bool NumberToInt64(NumberBuffer& number, Int64& value);
    private static bool NumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool NumberToUInt64(NumberBuffer& number, UInt64& value);
    internal static int ParseInt32(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    internal static long ParseInt64(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt);
    internal static UInt32 ParseUInt32(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt);
    internal static ulong ParseUInt64(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt);
    private static bool ParseNumber(Char*& str, Char* strEnd, NumberStyles options, NumberBuffer& number, NumberFormatInfo numfmt, bool parseDecimal);
    internal static bool TryParseInt32(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Int32& result);
    internal static bool TryParseInt64(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Int64& result);
    internal static bool TryParseUInt32(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, UInt32& result);
    internal static bool TryParseUInt64(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, UInt64& result);
    internal static decimal ParseDecimal(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt);
    internal static double ParseDouble(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt);
    internal static float ParseSingle(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt);
    internal static bool TryParseDecimal(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt, Decimal& result);
    internal static bool TryParseDouble(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt, Double& result);
    internal static bool TryParseSingle(ReadOnlySpan`1<char> value, NumberStyles options, NumberFormatInfo numfmt, Single& result);
    private static void StringToNumber(ReadOnlySpan`1<char> str, NumberStyles options, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    internal static bool TryStringToNumber(ReadOnlySpan`1<char> str, NumberStyles options, NumberBuffer& number, NumberFormatInfo numfmt, bool parseDecimal);
    private static bool TrailingZeros(ReadOnlySpan`1<char> s, int index);
    private static Char* MatchChars(Char* p, Char* pEnd, string str);
    private static Char* MatchChars(Char* p, Char* pEnd, Char* str);
    private static bool IsWhite(char ch);
    private static bool NumberBufferToDouble(NumberBuffer& number, Double& value);
}
internal class System.Numerics.ConstantHelper : object {
    public static byte GetByteWithAllBitsSet();
    public static sbyte GetSByteWithAllBitsSet();
    public static ushort GetUInt16WithAllBitsSet();
    public static short GetInt16WithAllBitsSet();
    public static UInt32 GetUInt32WithAllBitsSet();
    public static int GetInt32WithAllBitsSet();
    public static ulong GetUInt64WithAllBitsSet();
    public static long GetInt64WithAllBitsSet();
    public static float GetSingleWithAllBitsSet();
    public static double GetDoubleWithAllBitsSet();
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int RandomSeed;
    private static HashHelpers();
    public static int Combine(int h1, int h2);
}
internal class System.Numerics.Register : ValueType {
    internal byte byte_0;
    internal byte byte_1;
    internal byte byte_2;
    internal byte byte_3;
    internal byte byte_4;
    internal byte byte_5;
    internal byte byte_6;
    internal byte byte_7;
    internal byte byte_8;
    internal byte byte_9;
    internal byte byte_10;
    internal byte byte_11;
    internal byte byte_12;
    internal byte byte_13;
    internal byte byte_14;
    internal byte byte_15;
    internal sbyte sbyte_0;
    internal sbyte sbyte_1;
    internal sbyte sbyte_2;
    internal sbyte sbyte_3;
    internal sbyte sbyte_4;
    internal sbyte sbyte_5;
    internal sbyte sbyte_6;
    internal sbyte sbyte_7;
    internal sbyte sbyte_8;
    internal sbyte sbyte_9;
    internal sbyte sbyte_10;
    internal sbyte sbyte_11;
    internal sbyte sbyte_12;
    internal sbyte sbyte_13;
    internal sbyte sbyte_14;
    internal sbyte sbyte_15;
    internal ushort uint16_0;
    internal ushort uint16_1;
    internal ushort uint16_2;
    internal ushort uint16_3;
    internal ushort uint16_4;
    internal ushort uint16_5;
    internal ushort uint16_6;
    internal ushort uint16_7;
    internal short int16_0;
    internal short int16_1;
    internal short int16_2;
    internal short int16_3;
    internal short int16_4;
    internal short int16_5;
    internal short int16_6;
    internal short int16_7;
    internal UInt32 uint32_0;
    internal UInt32 uint32_1;
    internal UInt32 uint32_2;
    internal UInt32 uint32_3;
    internal int int32_0;
    internal int int32_1;
    internal int int32_2;
    internal int int32_3;
    internal ulong uint64_0;
    internal ulong uint64_1;
    internal long int64_0;
    internal long int64_1;
    internal float single_0;
    internal float single_1;
    internal float single_2;
    internal float single_3;
    internal double double_0;
    internal double double_1;
}
[IntrinsicAttribute]
public static class System.Numerics.Vector : object {
    public static bool IsHardwareAccelerated { get; }
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<byte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Widen(Vector`1<ushort> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<UInt32> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<sbyte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<short> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<int> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<float> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<byte> Narrow(Vector`1<ushort> low, Vector`1<ushort> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> low, Vector`1<UInt32> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> low, Vector`1<ulong> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<sbyte> Narrow(Vector`1<short> low, Vector`1<short> high);
    [IntrinsicAttribute]
public static Vector`1<short> Narrow(Vector`1<int> low, Vector`1<int> high);
    [IntrinsicAttribute]
public static Vector`1<int> Narrow(Vector`1<long> low, Vector`1<long> high);
    [IntrinsicAttribute]
public static Vector`1<float> Narrow(Vector`1<double> low, Vector`1<double> high);
    [IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    [IntrinsicAttribute]
public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [IntrinsicAttribute]
public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    public static Vector`1<T> Abs(Vector`1<T> value);
    public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    public static T Dot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> SquareRoot(Vector`1<T> value);
    public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Negate(Vector`1<T> value);
    public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> OnesComplement(Vector`1<T> value);
    public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Vector`1 : ValueType {
    private Register register;
    private static int s_count;
    private static Vector`1<T> s_zero;
    private static Vector`1<T> s_one;
    private static Vector`1<T> s_allOnes;
    public static int Count { get; }
    public static Vector`1<T> Zero { get; }
    public static Vector`1<T> One { get; }
    internal static Vector`1<T> AllOnes { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public Vector`1(T value);
    [IntrinsicAttribute]
public Vector`1(T[] values);
    public Vector`1(T[] values, int index);
    internal Vector`1(Void* dataPointer);
    internal Vector`1(Void* dataPointer, int offset);
    private Vector`1(Register& existingRegister);
    public Vector`1(Span`1<T> values);
    private static Vector`1();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector`1<T> get_Zero();
    [IntrinsicAttribute]
public static Vector`1<T> get_One();
    internal static Vector`1<T> get_AllOnes();
    private static int InitializeCount();
    [IntrinsicAttribute]
public void CopyTo(T[] destination);
    [IntrinsicAttribute]
public void CopyTo(T[] destination, int startIndex);
    [IntrinsicAttribute]
public T get_Item(int index);
    public virtual bool Equals(object obj);
    [IntrinsicAttribute]
public sealed virtual bool Equals(Vector`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Abs(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static T DotProduct(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> SquareRoot(Vector`1<T> value);
    private static bool ScalarEquals(T left, T right);
    private static bool ScalarLessThan(T left, T right);
    private static bool ScalarGreaterThan(T left, T right);
    private static T ScalarAdd(T left, T right);
    private static T ScalarSubtract(T left, T right);
    private static T ScalarMultiply(T left, T right);
    private static T ScalarDivide(T left, T right);
    private static T GetOneValue();
    private static T GetAllBitsSetValue();
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Object {
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    [NonVersionableAttribute]
public static bool ReferenceEquals(object objA, object objB);
    public virtual int GetHashCode();
    public Type GetType();
    [NonVersionableAttribute]
protected virtual void Finalize();
    protected object MemberwiseClone();
    private void FieldSetter(string typeName, string fieldName, object val);
    private void FieldGetter(string typeName, string fieldName, Object& val);
    private FieldInfo GetFieldInfo(string typeName, string fieldName);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ObjectDisposedException : InvalidOperationException {
    private string _objectName;
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string objectName, string message);
    public ObjectDisposedException(string message, Exception innerException);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    private string _message;
    private bool _error;
    public string Message { get; }
    public bool IsError { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_Message();
    public bool get_IsError();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OperationCanceledException : SystemException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalCaseSensitiveComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OrdinalComparer : StringComparer {
    private bool _ignoreCase;
    internal OrdinalComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.OrdinalIgnoreCaseComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
[IsReadOnlyAttribute]
internal class System.ParamsArray : ValueType {
    private static Object[] s_oneArgArray;
    private static Object[] s_twoArgArray;
    private static Object[] s_threeArgArray;
    private object _arg0;
    private object _arg1;
    private object _arg2;
    private Object[] _args;
    public int Length { get; }
    public object Item { get; }
    public ParamsArray(object arg0);
    public ParamsArray(object arg0, object arg1);
    public ParamsArray(object arg0, object arg1, object arg2);
    public ParamsArray(Object[] args);
    private static ParamsArray();
    public int get_Length();
    public object get_Item(int index);
    private object GetAtSlow(int index);
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull;
    public static ParseFailureKind Format;
    public static ParseFailureKind FormatWithParameter;
    public static ParseFailureKind FormatWithOriginalDateTime;
    public static ParseFailureKind FormatWithFormatSpecifier;
    public static ParseFailureKind FormatWithOriginalDateTimeAndParameter;
    public static ParseFailureKind FormatBadDateTimeCalendar;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags);
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static string IntToString(int n, int radix, int width, char paddingChar, int flags);
    public static string LongToString(long n, int radix, int width, char paddingChar, int flags);
    private static void EatWhiteSpace(ReadOnlySpan`1<char> s, Int32& i);
    private static long GrabLongs(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static int GrabInts(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static void ThrowOverflowInt32Exception();
    private static void ThrowOverflowInt64Exception();
    private static void ThrowOverflowUInt32Exception();
    private static void ThrowOverflowUInt64Exception();
    private static bool IsDigit(char c, int radix, Int32& result);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fCustomNumberParser;
    internal MatchNumberDelegate parseNumberDelegate;
    internal void Init();
}
internal class System.PinnableBufferCache : object {
    private string m_CacheName;
    private Func`1<object> m_factory;
    private ConcurrentStack`1<object> m_FreeList;
    private List`1<object> m_NotGen2;
    private int m_gen1CountAtLastRestock;
    private int m_msecNoUseBeyondFreeListSinceThisTime;
    private bool m_moreThanFreeListNeeded;
    private int m_buffersUnderManagement;
    private int m_restockSize;
    private bool m_trimmingExperimentInProgress;
    private int m_minBufferCount;
    private int m_numAllocCalls;
    internal PinnableBufferCache(string cacheName, Func`1<object> factory);
    internal object Allocate();
    internal void Free(object buffer);
    private void Restock(Object& returnBuffer);
    private bool AgePendingBuffers();
    private void CreateNewBuffers();
    private static bool Gen2GcCallbackFunc(object targetObj);
    private bool TrimFreeListIfNeeded();
}
internal class System.PinnableBufferCacheEventSource : object {
    public static PinnableBufferCacheEventSource Log;
    private static PinnableBufferCacheEventSource();
    public bool IsEnabled();
    public void DebugMessage(string message);
    public void Create(string cacheName);
    public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter);
    public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter);
    public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount);
    public void AllocateBufferAged(string cacheName, int agedCount);
    public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore);
    public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore);
    public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore);
    public void TrimCheck(string cacheName, int totalBuffs, bool neededMoreThanFreeList, int deltaMSec);
    public void TrimFree(string cacheName, int totalBuffs, int freeListCount, int toBeFreed);
    public void TrimExperiment(string cacheName, int totalBuffs, int freeListCount, int numTrimTrial);
    public void TrimFreeSizeOK(string cacheName, int totalBuffs, int freeListCount);
    public void TrimFlush(string cacheName, int totalBuffs, int freeListCount, int notGen2CountBefore);
    public void AgePendingBuffersResults(string cacheName, int promotedToFreeListCount, int heldBackCount);
    public void WalkFreeListResult(string cacheName, int freeListCount, int gen0BuffersInFreeList);
    internal static ulong AddressOf(object obj);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Progress`1 : object {
    private SynchronizationContext _synchronizationContext;
    private Action`1<T> _handler;
    private SendOrPostCallback _invokeHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<T> ProgressChanged;
    public Progress`1(Action`1<T> handler);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    private void InvokeHandlers(object state);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
public class System.Random : object {
    private int _inext;
    private int _inextp;
    private Int32[] _seedArray;
    [ThreadStaticAttribute]
private static Random t_threadRandom;
    private static Random s_globalRandom;
    public Random(int Seed);
    private static Random();
    protected virtual double Sample();
    private int InternalSample();
    private static int GenerateSeed();
    private static int GenerateGlobalSeed();
    public virtual int Next();
    private double GetSampleForLargeRange();
    public virtual int Next(int minValue, int maxValue);
    public virtual int Next(int maxValue);
    public virtual double NextDouble();
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Span`1<byte> buffer);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    protected RankException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
[IsByRefLikeAttribute]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
public class System.ReadOnlySpan`1 : ValueType {
    internal ByReference`1<T> _pointer;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static ReadOnlySpan`1<T> Empty { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(T& ptr, int length);
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Assembly : object {
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_LoadFromResolveHandlerSetup;
    private static object s_syncRootLoadFrom;
    private static List`1<string> s_LoadFromAssemblyList;
    private static object s_syncLoadFromAssemblyList;
    private static Dictionary`2<string, Assembly> s_loadfile;
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public bool IsFullyTrusted { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string EscapedCodeBase { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    private static Assembly();
    private static Assembly LoadFromResolveHandler(object sender, ResolveEventArgs args);
    public static Assembly LoadFrom(string assemblyFile);
    public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public static Assembly Load(string assemblyString);
    public static Assembly Load(AssemblyName assemblyRef);
    internal static Assembly Load(AssemblyName assemblyRef, IntPtr ptrLoadContextBinder);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly LoadFile(string path);
    public static Assembly GetExecutingAssembly();
    public static Assembly GetCallingAssembly();
    public static Assembly GetEntryAssembly();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Type[] GetTypes();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual Type[] GetExportedTypes();
    public virtual Type[] GetForwardedTypes();
    public virtual string get_CodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_FullName();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public bool get_IsFullyTrusted();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string get_EscapedCodeBase();
    public object CreateInstance(string typeName);
    public object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual Module get_ManifestModule();
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual IEnumerable`1<Module> get_Modules();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    public static Assembly Load(Byte[] rawAssembly);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    public static Assembly UnsafeLoadFrom(string assemblyFile);
    public Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual SecurityRuleSet get_SecurityRuleSet();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <AlgorithmId>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    [CompilerGeneratedAttribute]
public UInt32 get_AlgorithmId();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    [CompilerGeneratedAttribute]
public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultAlias>k__BackingField;
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    [CompilerGeneratedAttribute]
public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    private AssemblyNameFlags _flags;
    [ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Reflection.AssemblyName : object {
    private string _Name;
    private Byte[] _PublicKey;
    private Byte[] _PublicKeyToken;
    private CultureInfo _CultureInfo;
    private string _CodeBase;
    private Version _Version;
    private StrongNameKeyPair _StrongNameKeyPair;
    private SerializationInfo m_siInfo;
    private Byte[] _HashForControl;
    private AssemblyHashAlgorithm _HashAlgorithm;
    private AssemblyHashAlgorithm _HashAlgorithmForControl;
    private AssemblyVersionCompatibility _VersionCompatibility;
    private AssemblyNameFlags _Flags;
    private static Char[] s_hexUpperChars;
    internal static char c_DummyChar;
    private static short c_MaxAsciiCharsReallocate;
    private static short c_MaxUnicodeCharsReallocate;
    private static short c_MaxUTF_8BytesPerUnicodeChar;
    private static short c_EncodedCharsPerByte;
    private static string RFC3986ReservedMarks;
    private static string RFC3986UnreservedMarks;
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    public string CodeBase { get; public set; }
    public string EscapedCodeBase { get; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public string FullName { get; }
    public AssemblyName(string assemblyName);
    private static AssemblyName();
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public string get_EscapedCodeBase();
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public sealed virtual object Clone();
    public static AssemblyName GetAssemblyName(string assemblyFile);
    public Byte[] GetPublicKey();
    public void SetPublicKey(Byte[] publicKey);
    public Byte[] GetPublicKeyToken();
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public string get_FullName();
    public virtual string ToString();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    internal void nInit(RuntimeAssembly& assembly, bool raiseResolveEvent);
    internal void nInit();
    internal void SetProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm);
    internal static ProcessorArchitecture CalculateProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm, AssemblyNameFlags flags);
    internal void Init(string name, Byte[] publicKey, Byte[] publicKeyToken, Version version, CultureInfo cultureInfo, AssemblyHashAlgorithm hashAlgorithm, AssemblyVersionCompatibility versionCompatibility, string codeBase, AssemblyNameFlags flags, StrongNameKeyPair keyPair);
    internal static AssemblyName nGetFileInformation(string s);
    private Byte[] nGetPublicKeyToken();
    internal static string EscapeCodeBase(string codebase);
    internal static Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd);
    private static Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos);
    internal static void EscapeAsciiChar(char ch, Char[] to, Int32& pos);
    internal static char EscapedAscii(char digit, char next);
    private static bool IsReservedUnreservedOrHash(char c);
    internal static bool IsUnreserved(char c);
    internal static bool IsAsciiLetter(char character);
    internal static bool IsAsciiLetterOrDigit(char character);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
[ExtensionAttribute]
internal static class System.Reflection.AssemblyNameFormatter : object {
    public static KeyValuePair`2[] EscapeSequences;
    private static AssemblyNameFormatter();
    public static string ComputeDisplayName(string name, Version version, string cultureName, Byte[] pkt, AssemblyNameFlags flags, AssemblyContentType contentType);
    [ExtensionAttribute]
private static void AppendQuoted(StringBuilder sb, string s);
    [ExtensionAttribute]
private static Version CanonicalizeVersion(Version version);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    [CompilerGeneratedAttribute]
public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Countersignature>k__BackingField;
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public string get_Countersignature();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Trademark>k__BackingField;
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    [CompilerGeneratedAttribute]
public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
internal static class System.Reflection.Associates : object {
    internal static bool IncludeAccessor(MethodInfo associate, bool nonPublic);
    private static RuntimeMethodInfo AssignAssociates(int tkMethod, RuntimeType declaredType, RuntimeType reflectedType);
    internal static void AssignAssociates(MetadataImport scope, int mdPropEvent, RuntimeType declaringType, RuntimeType reflectedType, RuntimeMethodInfo& addOn, RuntimeMethodInfo& removeOn, RuntimeMethodInfo& fireOn, RuntimeMethodInfo& getter, RuntimeMethodInfo& setter, MethodInfo[]& other, Boolean& composedOfAllPrivateMethods, BindingFlags& bindingFlags);
}
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags DoNotWrapExceptions;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.CerHashtable`2 : ValueType {
    private Table<K, V> m_Table;
    internal V Item { get; internal set; }
    private static int GetHashCodeHelper(K key);
    private void Rehash(int newSize);
    internal void set_Item(K key, V value);
    internal V get_Item(K key);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.ConstArray : ValueType {
    internal int m_length;
    internal IntPtr m_constArray;
    public IntPtr Signature { get; }
    public int Length { get; }
    public byte Item { get; }
    public IntPtr get_Signature();
    public int get_Length();
    public byte get_Item(int index);
}
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    public static string ConstructorName;
    public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
internal enum System.Reflection.CorElementType : Enum {
    public byte value__;
    public static CorElementType End;
    public static CorElementType Void;
    public static CorElementType Boolean;
    public static CorElementType Char;
    public static CorElementType I1;
    public static CorElementType U1;
    public static CorElementType I2;
    public static CorElementType U2;
    public static CorElementType I4;
    public static CorElementType U4;
    public static CorElementType I8;
    public static CorElementType U8;
    public static CorElementType R4;
    public static CorElementType R8;
    public static CorElementType String;
    public static CorElementType Ptr;
    public static CorElementType ByRef;
    public static CorElementType ValueType;
    public static CorElementType Class;
    public static CorElementType Var;
    public static CorElementType Array;
    public static CorElementType GenericInst;
    public static CorElementType TypedByRef;
    public static CorElementType I;
    public static CorElementType U;
    public static CorElementType FnPtr;
    public static CorElementType Object;
    public static CorElementType SzArray;
    public static CorElementType MVar;
    public static CorElementType CModReqd;
    public static CorElementType CModOpt;
    public static CorElementType Internal;
    public static CorElementType Max;
    public static CorElementType Modifier;
    public static CorElementType Sentinel;
    public static CorElementType Pinned;
}
internal static class System.Reflection.CustomAttribute : object {
    private static RuntimeType Type_RuntimeType;
    private static RuntimeType Type_Type;
    private static CustomAttribute();
    internal static bool IsDefined(RuntimeType type, RuntimeType caType, bool inherit);
    internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
    internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeType type, RuntimeType caType, bool inherit);
    internal static Object[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    internal static Object[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeModule module, RuntimeType caType);
    private static bool IsCustomAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType);
    private static bool IsCustomAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType, int attributeCtorToken, bool mustBeInheritable);
    private static Object[] GetCustomAttributes(RuntimeModule decoratedModule, int decoratedMetadataToken, int pcaCount, RuntimeType attributeFilterType);
    private static Object[] GetCustomAttributes(RuntimeModule decoratedModule, int decoratedMetadataToken, int pcaCount, RuntimeType attributeFilterType, bool mustBeInheritable, IList derivedAttributes);
    private static bool FilterCustomAttributeRecord(CustomAttributeRecord caRecord, MetadataImport scope, Assembly& lastAptcaOkAssembly, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, bool mustBeInheritable, Object[] attributes, IList derivedAttributes, RuntimeType& attributeType, IRuntimeMethodInfo& ctor, Boolean& ctorHasParameters, Boolean& isVarArg);
    private static bool AttributeUsageCheck(RuntimeType attributeType, bool mustBeInheritable, Object[] attributes, IList derivedAttributes);
    internal static AttributeUsageAttribute GetAttributeUsage(RuntimeType decoratedAttribute);
    private static void _ParseAttributeUsageAttribute(IntPtr pCa, int cCa, Int32& targets, Boolean& inherited, Boolean& allowMultiple);
    private static void ParseAttributeUsageAttribute(ConstArray ca, AttributeTargets& targets, Boolean& inherited, Boolean& allowMultiple);
    private static object _CreateCaObject(RuntimeModule pModule, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs);
    private static object CreateCaObject(RuntimeModule module, IRuntimeMethodInfo ctor, IntPtr& blob, IntPtr blobEnd, Int32& namedArgs);
    private static void _GetPropertyOrFieldData(RuntimeModule pModule, Byte** ppBlobStart, Byte* pBlobEnd, String& name, Boolean& bIsProperty, RuntimeType& type, Object& value);
    private static void GetPropertyOrFieldData(RuntimeModule module, IntPtr& blobStart, IntPtr blobEnd, String& name, Boolean& isProperty, RuntimeType& type, Object& value);
    private static Object[] CreateAttributeArrayHelper(Type elementType, int elementCount);
}
internal class System.Reflection.CustomAttributeCtorParameter : ValueType {
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument CustomAttributeEncodedArgument { get; }
    public CustomAttributeCtorParameter(CustomAttributeType type);
    public CustomAttributeEncodedArgument get_CustomAttributeEncodedArgument();
}
public class System.Reflection.CustomAttributeData : object {
    private ConstructorInfo m_ctor;
    private RuntimeModule m_scope;
    private MemberInfo[] m_members;
    private CustomAttributeCtorParameter[] m_ctorParams;
    private CustomAttributeNamedParameter[] m_namedParams;
    private IList`1<CustomAttributeTypedArgument> m_typedCtorArgs;
    private IList`1<CustomAttributeNamedArgument> m_namedArgs;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    private CustomAttributeData(RuntimeModule scope, CustomAttributeRecord caRecord);
    internal CustomAttributeData(Attribute attribute);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeFieldInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeMethodInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeConstructorInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeEventInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimePropertyInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeModule target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeAssembly target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeParameterInfo target);
    private static CustomAttributeEncoding TypeToCustomAttributeEncoding(RuntimeType type);
    private static CustomAttributeType InitCustomAttributeType(RuntimeType parameterType);
    private static IList`1<CustomAttributeData> GetCustomAttributes(RuntimeModule module, int tkTarget);
    internal static CustomAttributeRecord[] GetCustomAttributeRecords(RuntimeModule module, int targetToken);
    internal static CustomAttributeTypedArgument Filter(IList`1<CustomAttributeData> attrs, Type caType, int parameter);
    private void Init(DllImportAttribute dllImport);
    private void Init(FieldOffsetAttribute fieldOffset);
    private void Init(MarshalAsAttribute marshalAs);
    private void Init(TypeForwardedToAttribute forwardedTo);
    private void Init(object pca);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
internal class System.Reflection.CustomAttributeEncodedArgument : ValueType {
    private long m_primitiveValue;
    private CustomAttributeEncodedArgument[] m_arrayValue;
    private string m_stringValue;
    private CustomAttributeType m_type;
    public CustomAttributeType CustomAttributeType { get; }
    public long PrimitiveValue { get; }
    public CustomAttributeEncodedArgument[] ArrayValue { get; }
    public string StringValue { get; }
    private static void ParseAttributeArguments(IntPtr pCa, int cCa, CustomAttributeCtorParameter[]& CustomAttributeCtorParameters, CustomAttributeNamedParameter[]& CustomAttributeTypedArgument, RuntimeAssembly assembly);
    internal static void ParseAttributeArguments(ConstArray attributeBlob, CustomAttributeCtorParameter[]& customAttributeCtorParameters, CustomAttributeNamedParameter[]& customAttributeNamedParameters, RuntimeModule customAttributeModule);
    public CustomAttributeType get_CustomAttributeType();
    public long get_PrimitiveValue();
    public CustomAttributeEncodedArgument[] get_ArrayValue();
    public string get_StringValue();
}
internal enum System.Reflection.CustomAttributeEncoding : Enum {
    public int value__;
    public static CustomAttributeEncoding Undefined;
    public static CustomAttributeEncoding Boolean;
    public static CustomAttributeEncoding Char;
    public static CustomAttributeEncoding SByte;
    public static CustomAttributeEncoding Byte;
    public static CustomAttributeEncoding Int16;
    public static CustomAttributeEncoding UInt16;
    public static CustomAttributeEncoding Int32;
    public static CustomAttributeEncoding UInt32;
    public static CustomAttributeEncoding Int64;
    public static CustomAttributeEncoding UInt64;
    public static CustomAttributeEncoding Float;
    public static CustomAttributeEncoding Double;
    public static CustomAttributeEncoding String;
    public static CustomAttributeEncoding Array;
    public static CustomAttributeEncoding Type;
    public static CustomAttributeEncoding Object;
    public static CustomAttributeEncoding Field;
    public static CustomAttributeEncoding Property;
    public static CustomAttributeEncoding Enum;
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private MemberInfo m_memberInfo;
    private CustomAttributeTypedArgument m_value;
    internal Type ArgumentType { get; }
    public MemberInfo MemberInfo { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public string MemberName { get; }
    public bool IsField { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal Type get_ArgumentType();
    public MemberInfo get_MemberInfo();
    public CustomAttributeTypedArgument get_TypedValue();
    public string get_MemberName();
    public bool get_IsField();
}
internal class System.Reflection.CustomAttributeNamedParameter : ValueType {
    private string m_argumentName;
    private CustomAttributeEncoding m_fieldOrProperty;
    private CustomAttributeEncoding m_padding;
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument EncodedArgument { get; }
    public CustomAttributeNamedParameter(string argumentName, CustomAttributeEncoding fieldOrProperty, CustomAttributeType type);
    public CustomAttributeEncodedArgument get_EncodedArgument();
}
internal class System.Reflection.CustomAttributeRecord : ValueType {
    internal ConstArray blob;
    internal MetadataToken tkCtor;
}
internal class System.Reflection.CustomAttributeType : ValueType {
    private string m_enumName;
    private CustomAttributeEncoding m_encodedType;
    private CustomAttributeEncoding m_encodedEnumType;
    private CustomAttributeEncoding m_encodedArrayType;
    private CustomAttributeEncoding m_padding;
    public CustomAttributeEncoding EncodedType { get; }
    public CustomAttributeEncoding EncodedEnumType { get; }
    public CustomAttributeEncoding EncodedArrayType { get; }
    public string EnumName { get; }
    public CustomAttributeType(CustomAttributeEncoding encodedType, CustomAttributeEncoding encodedArrayType, CustomAttributeEncoding encodedEnumType, string enumName);
    public CustomAttributeEncoding get_EncodedType();
    public CustomAttributeEncoding get_EncodedEnumType();
    public CustomAttributeEncoding get_EncodedArrayType();
    public string get_EnumName();
}
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object m_value;
    private Type m_argumentType;
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public CustomAttributeTypedArgument(object value);
    internal CustomAttributeTypedArgument(RuntimeModule scope, CustomAttributeEncodedArgument encodedArg);
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    private static Type CustomAttributeEncodingToType(CustomAttributeEncoding encodedType);
    private static object EncodedValueToRawValue(long val, CustomAttributeEncoding encodedType);
    private static RuntimeType ResolveType(RuntimeModule scope, string typeName);
    private static object CanonicalizeValue(object value);
    public virtual string ToString();
    internal string ToString(bool typed);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Type get_ArgumentType();
    public object get_Value();
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
internal class System.Reflection.Emit.__ExceptionInfo : object {
    internal int m_startAddr;
    internal Int32[] m_filterAddr;
    internal Int32[] m_catchAddr;
    internal Int32[] m_catchEndAddr;
    internal Int32[] m_type;
    internal Type[] m_catchClass;
    internal Label m_endLabel;
    internal Label m_finallyEndLabel;
    internal int m_endAddr;
    internal int m_endFinally;
    internal int m_currentCatch;
    private int m_currentState;
    internal __ExceptionInfo(int startAddr, Label endLabel);
    private void MarkHelper(int catchorfilterAddr, int catchEndAddr, Type catchClass, int type);
    internal void MarkFilterAddr(int filterAddr);
    internal void MarkFaultAddr(int faultAddr);
    internal void MarkCatchAddr(int catchAddr, Type catchException);
    internal void MarkFinallyAddr(int finallyAddr, int endCatchAddr);
    internal void Done(int endAddr);
    internal int GetStartAddress();
    internal int GetEndAddress();
    internal int GetFinallyEndAddress();
    internal Label GetEndLabel();
    internal Int32[] GetFilterAddresses();
    internal Int32[] GetCatchAddresses();
    internal Int32[] GetCatchEndAddresses();
    internal Type[] GetCatchClass();
    internal int GetNumberOfCatches();
    internal Int32[] GetExceptionTypes();
    internal void SetFinallyEndLabel(Label lbl);
    internal Label GetFinallyEndLabel();
    internal bool IsInner(__ExceptionInfo exc);
    internal int GetCurrentState();
}
internal class System.Reflection.Emit.__FixupData : ValueType {
    internal Label m_fixupLabel;
    internal int m_fixupPos;
    internal int m_fixupInstSize;
}
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    internal AssemblyBuilderData m_assemblyData;
    private InternalAssemblyBuilder m_internalAssemblyBuilder;
    private ModuleBuilder m_manifestModuleBuilder;
    private bool m_fManifestModuleUsedAsDefinedModule;
    internal object SyncRoot { get; }
    internal InternalAssemblyBuilder InternalAssembly { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    internal AssemblyBuilder(AppDomain domain, AssemblyName name, AssemblyBuilderAccess access, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes);
    private static RuntimeModule GetInMemoryAssemblyModule(RuntimeAssembly assembly);
    private Module nGetInMemoryAssemblyModule();
    internal ModuleBuilder GetModuleBuilder(InternalModuleBuilder module);
    internal object get_SyncRoot();
    internal InternalAssemblyBuilder get_InternalAssembly();
    internal RuntimeAssembly GetNativeHandle();
    private void InitManifestModule();
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    private static Assembly nCreateDynamicAssembly(AppDomain domain, AssemblyName name, StackCrawlMark& stackMark, AssemblyBuilderAccess access);
    internal static AssemblyBuilder InternalDefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes);
    public ModuleBuilder DefineDynamicModule(string name);
    public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
    private ModuleBuilder DefineDynamicModuleInternal(string name, bool emitSymbolInfo, StackCrawlMark& stackMark);
    private ModuleBuilder DefineDynamicModuleInternalNoLock(string name, bool emitSymbolInfo, StackCrawlMark& stackMark);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    public virtual string get_CodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual Type[] GetExportedTypes();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual string get_FullName();
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module get_ManifestModule();
    public virtual bool get_ReflectionOnly();
    public virtual Module GetModule(string name);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual bool get_IsDynamic();
    public ModuleBuilder GetDynamicModule(string name);
    private ModuleBuilder GetDynamicModuleNoLock(string name);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private void SetCustomAttributeNoLock(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private void SetCustomAttributeNoLock(CustomAttributeBuilder customBuilder);
}
[FlagsAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess RunAndCollect;
}
internal class System.Reflection.Emit.AssemblyBuilderData : object {
    internal List`1<ModuleBuilder> m_moduleBuilderList;
    internal List`1<ResWriterData> m_resWriterList;
    internal string m_strAssemblyName;
    internal AssemblyBuilderAccess m_access;
    private InternalAssemblyBuilder m_assembly;
    internal CustomAttributeBuilder[] m_CABuilders;
    internal int m_iCABuilder;
    internal Byte[][] m_CABytes;
    internal ConstructorInfo[] m_CACons;
    internal int m_iCAs;
    internal PEFileKinds m_peFileKind;
    internal MethodInfo m_entryPointMethod;
    internal AssemblyBuilderData(InternalAssemblyBuilder assembly, string strAssemblyName, AssemblyBuilderAccess access);
    internal void AddModule(ModuleBuilder dynModule);
    internal void AddCustomAttribute(CustomAttributeBuilder customBuilder);
    internal void AddCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    internal void CheckTypeNameConflict(string strTypeName, TypeBuilder enclosingType);
}
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    private MethodBuilder m_methodBuilder;
    internal bool m_isDefaultConstructor;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public CallingConventions CallingConvention { get; }
    public string Signature { get; }
    public bool InitLocals { get; public set; }
    internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers, ModuleBuilder mod, TypeBuilder type);
    internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, ModuleBuilder mod, TypeBuilder type);
    internal virtual Type[] GetParameterTypes();
    private TypeBuilder GetTypeBuilder();
    public virtual string ToString();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public MethodToken GetToken();
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual CallingConventions get_CallingConvention();
    public Module GetModule();
    internal virtual Type GetReturnType();
    public string get_Signature();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
}
internal class System.Reflection.Emit.ConstructorOnTypeBuilderInstantiation : ConstructorInfo {
    internal ConstructorInfo m_ctor;
    private TypeBuilderInstantiation m_type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    internal ConstructorOnTypeBuilderInstantiation(ConstructorInfo constructor, TypeBuilderInstantiation type);
    internal static ConstructorInfo GetConstructor(ConstructorInfo Constructor, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethod();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    internal ConstructorInfo m_con;
    internal Object[] m_constructorArgs;
    internal Byte[] m_blob;
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private bool ValidateType(Type t);
    internal void InitCustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private static void VerifyTypeAndPassedObjectType(Type type, Type passedType, string paramName);
    private void EmitType(BinaryWriter writer, Type type);
    private void EmitString(BinaryWriter writer, string str);
    private void EmitValue(BinaryWriter writer, Type type, object value);
    internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner);
    internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner, int tkAttrib, bool toDisk);
}
internal class System.Reflection.Emit.DynamicILGenerator : ILGenerator {
    internal DynamicScope m_scope;
    private int m_methodSigToken;
    internal DynamicILGenerator(DynamicMethod method, Byte[] methodSignature, int size);
    internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type type);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void UsingNamespace(string ns);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    private int GetMemberRefToken(MethodBase methodInfo, Type[] optionalParameterTypes);
    internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    internal virtual void RecordTokenFixup();
    private int GetTokenFor(RuntimeType rtType);
    private int GetTokenFor(RuntimeFieldInfo runtimeField);
    private int GetTokenFor(RuntimeFieldInfo runtimeField, RuntimeType rtType);
    private int GetTokenFor(RuntimeConstructorInfo rtMeth);
    private int GetTokenFor(RuntimeConstructorInfo rtMeth, RuntimeType rtType);
    private int GetTokenFor(RuntimeMethodInfo rtMeth);
    private int GetTokenFor(RuntimeMethodInfo rtMeth, RuntimeType rtType);
    private int GetTokenFor(DynamicMethod dm);
    private int GetTokenForVarArgMethod(RuntimeMethodInfo rtMeth, SignatureHelper sig);
    private int GetTokenForVarArgMethod(DynamicMethod dm, SignatureHelper sig);
    private int GetTokenForString(string s);
    private int GetTokenForSig(Byte[] sig);
}
internal class System.Reflection.Emit.DynamicILInfo : object {
    private DynamicMethod m_method;
    private DynamicScope m_scope;
    private Byte[] m_exceptions;
    private Byte[] m_code;
    private Byte[] m_localSignature;
    private int m_maxStackSize;
    private int m_methodSignature;
    internal Byte[] LocalSignature { get; }
    internal Byte[] Exceptions { get; }
    internal Byte[] Code { get; }
    internal int MaxStackSize { get; }
    public DynamicMethod DynamicMethod { get; }
    internal DynamicScope DynamicScope { get; }
    internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    internal Byte[] get_LocalSignature();
    internal Byte[] get_Exceptions();
    internal Byte[] get_Code();
    internal int get_MaxStackSize();
    public DynamicMethod get_DynamicMethod();
    internal DynamicScope get_DynamicScope();
}
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    private RuntimeType[] m_parameterTypes;
    internal IRuntimeMethodInfo m_methodHandle;
    private RuntimeType m_returnType;
    private DynamicILGenerator m_ilGenerator;
    private DynamicILInfo m_DynamicILInfo;
    private bool m_fInitLocals;
    private RuntimeModule m_module;
    internal bool m_skipVisibility;
    internal RuntimeType m_typeOwner;
    private RTDynamicMethod m_dynMethod;
    internal DynamicResolver m_resolver;
    internal bool m_restrictedSkipVisibility;
    private static InternalModuleBuilder modreq(System.Runtime.CompilerServices.IsVolatile) s_anonymouslyHostedDynamicMethodsModule;
    private static object s_anonymouslyHostedDynamicMethodsModuleLock;
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public bool InitLocals { get; public set; }
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    private static DynamicMethod();
    private static void CheckConsistency(MethodAttributes attributes, CallingConventions callingConvention);
    private static RuntimeModule GetDynamicMethodsModule();
    private void Init(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] signature, Type owner, Module m, bool skipVisibility, bool transparentMethod);
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    internal RuntimeMethodHandle GetMethodDescriptor();
    public virtual string ToString();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal MethodInfo GetMethodInfo();
}
internal class System.Reflection.Emit.DynamicResolver : Resolver {
    private __ExceptionInfo[] m_exceptions;
    private Byte[] m_exceptionHeader;
    private DynamicMethod m_method;
    private Byte[] m_code;
    private Byte[] m_localSignature;
    private int m_stackSize;
    private DynamicScope m_scope;
    internal DynamicResolver(DynamicILGenerator ilGenerator);
    internal DynamicResolver(DynamicILInfo dynamicILInfo);
    protected virtual override void Finalize();
    internal virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    private static int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal virtual Byte[] GetLocalsSignature();
    internal virtual Byte[] GetRawEHInfo();
    internal virtual void GetEHInfo(int excNumber, Void* exc);
    internal virtual string GetStringLiteral(int token);
    internal virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal virtual MethodInfo GetDynamicMethod();
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Emit.DynamicScope : object {
    internal List`1<object> m_tokens;
    internal object Item { get; }
    internal object get_Item(int token);
    internal int GetTokenFor(VarArgMethod varArgMethod);
    internal string GetString(int token);
    internal Byte[] ResolveSignature(int token, int fromMethod);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle typeContext);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle typeContext);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(Byte[] signature);
}
public class System.Reflection.Emit.EnumBuilder : TypeInfo {
    internal TypeBuilder m_typeBuilder;
    private FieldBuilder m_underlyingField;
    public TypeToken TypeToken { get; }
    public FieldBuilder UnderlyingField { get; }
    public string Name { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal EnumBuilder(string name, Type underlyingType, TypeAttributes visibility, ModuleBuilder module);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    public TypeInfo CreateTypeInfo();
    public Type CreateType();
    public TypeToken get_TypeToken();
    public FieldBuilder get_UnderlyingField();
    public virtual string get_Name();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type GetEnumUnderlyingType();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
}
public class System.Reflection.Emit.EventBuilder : object {
    private string m_name;
    private EventToken m_evToken;
    private ModuleBuilder m_module;
    private EventAttributes m_attributes;
    private TypeBuilder m_type;
    internal EventBuilder(ModuleBuilder mod, string name, EventAttributes attr, TypeBuilder type, EventToken evToken);
    public EventToken GetEventToken();
    private void SetMethodSemantics(MethodBuilder mdBuilder, MethodSemanticsAttributes semantics);
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public class System.Reflection.Emit.EventToken : ValueType {
    public static EventToken Empty;
    internal int m_event;
    public int Token { get; }
    internal EventToken(int str);
    private static EventToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(EventToken obj);
    public static bool op_Equality(EventToken a, EventToken b);
    public static bool op_Inequality(EventToken a, EventToken b);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Emit.ExceptionHandler : ValueType {
    internal int m_exceptionClass;
    internal int m_tryStartOffset;
    internal int m_tryEndOffset;
    internal int m_filterOffset;
    internal int m_handlerStartOffset;
    internal int m_handlerEndOffset;
    internal ExceptionHandlingClauseOptions m_kind;
    internal ExceptionHandler(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExceptionHandler other);
}
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    private int m_fieldTok;
    private FieldToken m_tkField;
    private TypeBuilder m_typeBuilder;
    private string m_fieldName;
    private FieldAttributes m_Attributes;
    private Type m_fieldType;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    internal FieldBuilder(TypeBuilder typeBuilder, string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    internal void SetData(Byte[] data, int size);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public FieldToken GetToken();
    public void SetOffset(int iOffset);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
internal class System.Reflection.Emit.FieldOnTypeBuilderInstantiation : FieldInfo {
    private FieldInfo m_field;
    private TypeBuilderInstantiation m_type;
    internal FieldInfo FieldInfo { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    internal FieldOnTypeBuilderInstantiation(FieldInfo field, TypeBuilderInstantiation type);
    internal static FieldInfo GetField(FieldInfo Field, TypeBuilderInstantiation type);
    internal FieldInfo get_FieldInfo();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual object GetValueDirect(TypedReference obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual FieldAttributes get_Attributes();
}
public class System.Reflection.Emit.FieldToken : ValueType {
    public static FieldToken Empty;
    internal int m_fieldTok;
    internal object m_class;
    public int Token { get; }
    internal FieldToken(int field, Type fieldClass);
    private static FieldToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(FieldToken obj);
    public static bool op_Equality(FieldToken a, FieldToken b);
    public static bool op_Inequality(FieldToken a, FieldToken b);
}
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal class System.Reflection.Emit.GenericFieldInfo : object {
    internal RuntimeFieldHandle m_fieldHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericFieldInfo(RuntimeFieldHandle fieldHandle, RuntimeTypeHandle context);
}
internal class System.Reflection.Emit.GenericMethodInfo : object {
    internal RuntimeMethodHandle m_methodHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericMethodInfo(RuntimeMethodHandle methodHandle, RuntimeTypeHandle context);
}
public class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    internal TypeBuilder m_type;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public MethodBase DeclaringMethod { get; }
    internal GenericTypeParameterBuilder(TypeBuilder type);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual bool get_ContainsGenericParameters();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] typeArguments);
    protected virtual bool IsValueTypeImpl();
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetBaseTypeConstraint(Type baseTypeConstraint);
    public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
}
public class System.Reflection.Emit.ILGenerator : object {
    private int m_length;
    private Byte[] m_ILStream;
    private Int32[] m_labelList;
    private int m_labelCount;
    private __FixupData[] m_fixupData;
    private int m_fixupCount;
    private Int32[] m_RelocFixupList;
    private int m_RelocFixupCount;
    private int m_exceptionCount;
    private int m_currExcStackCount;
    private __ExceptionInfo[] m_exceptions;
    private __ExceptionInfo[] m_currExcStack;
    internal ScopeTree m_ScopeTree;
    internal LineNumberInfo m_LineNumberInfo;
    internal MethodInfo m_methodBuilder;
    internal int m_localCount;
    internal SignatureHelper m_localSignature;
    private int m_maxStackSize;
    private int m_maxMidStack;
    private int m_maxMidStackCur;
    internal int CurrExcStackCount { get; }
    internal __ExceptionInfo[] CurrExcStack { get; }
    public int ILOffset { get; }
    internal ILGenerator(MethodInfo methodBuilder);
    internal ILGenerator(MethodInfo methodBuilder, int size);
    internal static T[] EnlargeArray(T[] incoming);
    internal static T[] EnlargeArray(T[] incoming, int requiredSize);
    private static Byte[] EnlargeArray(Byte[] incoming);
    private static Byte[] EnlargeArray(Byte[] incoming, int requiredSize);
    internal int get_CurrExcStackCount();
    internal __ExceptionInfo[] get_CurrExcStack();
    internal virtual void RecordTokenFixup();
    internal void InternalEmit(OpCode opcode);
    internal void UpdateStackSize(OpCode opcode, int stackchange);
    private int GetMethodToken(MethodBase method, Type[] optionalParameterTypes, bool useMethodDef);
    internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    private SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes, int cGenericParameters);
    internal Byte[] BakeByteArray();
    internal __ExceptionInfo[] GetExceptions();
    internal void EnsureCapacity(int size);
    internal void PutInteger4(int value);
    private static int PutInteger4InArray(int value, int startPos, Byte[] array);
    private int GetLabelPos(Label lbl);
    private void AddFixup(Label lbl, int pos, int instSize);
    internal int GetMaxStackSize();
    private static void SortExceptions(__ExceptionInfo[] exceptions);
    internal Int32[] GetTokenFixups();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual Label BeginExceptionBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual Label DefineLabel();
    public virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    private static Type GetConsoleType();
    public virtual void EmitWriteLine(string value);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void UsingNamespace(string usingNamespace);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    public virtual int get_ILOffset();
}
internal class System.Reflection.Emit.InternalAssemblyBuilder : RuntimeAssembly {
    public string Location { get; }
    public string CodeBase { get; }
    public string ImageRuntimeVersion { get; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_CodeBase();
    public virtual Type[] GetExportedTypes();
    public virtual string get_ImageRuntimeVersion();
}
internal class System.Reflection.Emit.InternalModuleBuilder : RuntimeModule {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Reflection.Emit.Label : ValueType {
    internal int m_label;
    internal Label(int label);
    internal int GetLabelValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
internal class System.Reflection.Emit.LineNumberInfo : object {
    private int m_DocumentCount;
    private REDocument[] m_Documents;
    private int m_iLastFound;
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    private int FindDocument(ISymbolDocumentWriter document);
    private void EnsureCapacity();
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    private int m_localIndex;
    private Type m_localType;
    private MethodInfo m_methodBuilder;
    private bool m_isPinned;
    public bool IsPinned { get; }
    public Type LocalType { get; }
    public int LocalIndex { get; }
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder);
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder, bool isPinned);
    internal int GetLocalIndex();
    internal MethodInfo GetMethodBuilder();
    public virtual bool get_IsPinned();
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public void SetLocalSymInfo(string name);
    public void SetLocalSymInfo(string name, int startOffset, int endOffset);
}
internal class System.Reflection.Emit.LocalSymInfo : object {
    internal String[] m_strName;
    internal Byte[][] m_ubSignature;
    internal Int32[] m_iLocalSlot;
    internal Int32[] m_iStartOffset;
    internal Int32[] m_iEndOffset;
    internal int m_iLocalSymCount;
    internal String[] m_namespace;
    internal int m_iNameSpaceCount;
    private void EnsureCapacityNamespace();
    private void EnsureCapacity();
    internal void AddLocalSymInfo(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespace(string strNamespace);
    internal virtual void EmitLocalSymInfo(ISymbolWriter symWriter);
}
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    internal string m_strName;
    private MethodToken m_tkMethod;
    private ModuleBuilder m_module;
    internal TypeBuilder m_containingType;
    private Int32[] m_mdMethodFixups;
    private Byte[] m_localSignature;
    internal LocalSymInfo m_localSymInfo;
    internal ILGenerator m_ilGenerator;
    private Byte[] m_ubBody;
    private ExceptionHandler[] m_exceptions;
    private int m_maxStack;
    internal bool m_bIsBaked;
    private bool m_bIsGlobalMethod;
    private bool m_fInitLocals;
    private MethodAttributes m_iAttributes;
    private CallingConventions m_callingConvention;
    private MethodImplAttributes m_dwMethodImplFlags;
    private SignatureHelper m_signature;
    internal Type[] m_parameterTypes;
    private Type m_returnType;
    private Type[] m_returnTypeRequiredCustomModifiers;
    private Type[] m_returnTypeOptionalCustomModifiers;
    private Type[][] m_parameterTypeRequiredCustomModifiers;
    private Type[][] m_parameterTypeOptionalCustomModifiers;
    private GenericTypeParameterBuilder[] m_inst;
    private bool m_bIsGenMethDef;
    private List`1<SymCustomAttr> m_symCustomAttrs;
    internal bool m_canBeRuntimeImpl;
    internal bool m_isDllImport;
    internal int ExceptionHandlerCount { get; }
    public string Name { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReflectedType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool InitLocals { get; public set; }
    public string Signature { get; }
    internal MethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    private void Init(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    internal void CreateMethodBodyHelper(ILGenerator il);
    internal void ReleaseBakedStructures();
    internal virtual Type[] GetParameterTypes();
    internal static Type GetMethodBaseReturnType(MethodBase method);
    internal Byte[] GetBody();
    internal Int32[] GetTokenFixups();
    internal SignatureHelper GetMethodSignature();
    internal Byte[] GetLocalSignature(Int32& signatureLength);
    internal int GetMaxStack();
    internal ExceptionHandler[] GetExceptionHandlers();
    internal int get_ExceptionHandlerCount();
    internal int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal bool IsTypeCreated();
    internal TypeBuilder GetTypeBuilder();
    internal ModuleBuilder GetModuleBuilder();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_Name();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Type get_ReflectedType();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo[] GetParameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    internal void ThrowIfGeneric();
    public MethodToken GetToken();
    private MethodToken GetTokenNoLock();
    public void SetParameters(Type[] parameterTypes);
    public void SetReturnType(Type returnType);
    public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    private void ThrowIfShouldNotHaveBody();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public Module GetModule();
    public string get_Signature();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private bool IsKnownCA(ConstructorInfo con);
    private void ParseCA(ConstructorInfo con, Byte[] blob);
}
internal class System.Reflection.Emit.MethodBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    private Type[] m_inst;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodBuilderInstantiation(MethodInfo method, Type[] inst);
    internal static MethodInfo MakeGenericMethod(MethodInfo method, Type[] inst);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] arguments);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
internal class System.Reflection.Emit.MethodOnTypeBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    private TypeBuilderInstantiation m_type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodOnTypeBuilderInstantiation(MethodInfo method, TypeBuilderInstantiation type);
    internal static MethodInfo GetMethod(MethodInfo method, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArgs);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
public class System.Reflection.Emit.MethodToken : ValueType {
    public static MethodToken Empty;
    internal int m_method;
    public int Token { get; }
    internal MethodToken(int str);
    private static MethodToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(MethodToken obj);
    public static bool op_Equality(MethodToken a, MethodToken b);
    public static bool op_Inequality(MethodToken a, MethodToken b);
}
public class System.Reflection.Emit.ModuleBuilder : Module {
    private Dictionary`2<string, Type> m_TypeBuilderDict;
    private ISymbolWriter m_iSymWriter;
    internal ModuleBuilderData m_moduleData;
    internal InternalModuleBuilder m_internalModuleBuilder;
    private AssemblyBuilder m_assemblyBuilder;
    internal AssemblyBuilder ContainingAssemblyBuilder { get; }
    internal object SyncRoot { get; }
    internal InternalModuleBuilder InternalModule { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    internal ModuleBuilder(AssemblyBuilder assemblyBuilder, InternalModuleBuilder internalModuleBuilder);
    internal static IntPtr nCreateISymWriterForDynamicModule(Module module, string filename);
    internal static string UnmangleTypeName(string typeName);
    internal AssemblyBuilder get_ContainingAssemblyBuilder();
    internal void AddType(string name, Type type);
    internal void CheckTypeNameConflict(string strTypeName, Type enclosingType);
    private Type GetType(string strFormat, Type baseType);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    private static int GetTypeRef(RuntimeModule module, string strFullName, RuntimeModule refedModule, string strRefedModuleFileName, int tkResolution);
    private static int GetMemberRef(RuntimeModule module, RuntimeModule refedModule, int tr, int defToken);
    private int GetMemberRef(Module refedModule, int tr, int defToken);
    private static int GetMemberRefFromSignature(RuntimeModule module, int tr, string methodName, Byte[] signature, int length);
    private int GetMemberRefFromSignature(int tr, string methodName, Byte[] signature, int length);
    private static int GetMemberRefOfMethodInfo(RuntimeModule module, int tr, IRuntimeMethodInfo method);
    private int GetMemberRefOfMethodInfo(int tr, RuntimeMethodInfo method);
    private int GetMemberRefOfMethodInfo(int tr, RuntimeConstructorInfo method);
    private static int GetMemberRefOfFieldInfo(RuntimeModule module, int tkType, RuntimeTypeHandle declaringType, int tkField);
    private int GetMemberRefOfFieldInfo(int tkType, RuntimeTypeHandle declaringType, RuntimeFieldInfo runtimeField);
    private static int GetTokenFromTypeSpec(RuntimeModule pModule, Byte[] signature, int length);
    private int GetTokenFromTypeSpec(Byte[] signature, int length);
    private static int GetArrayMethodToken(RuntimeModule module, int tkTypeSpec, string methodName, Byte[] signature, int sigLength);
    private static int GetStringConstant(RuntimeModule module, string str, int length);
    internal static void SetFieldRVAContent(RuntimeModule module, int fdToken, Byte[] data, int length);
    internal virtual Type FindTypeBuilderWithName(string strTypeName, bool ignoreCase);
    private int GetTypeRefNested(Type type, Module refedModule, string strRefedModuleFileName);
    internal MethodToken InternalGetConstructorToken(ConstructorInfo con, bool usingRef);
    internal void Init(string strModuleName, string strFileName, int tkFile);
    internal void SetSymWriter(ISymbolWriter writer);
    internal object get_SyncRoot();
    internal InternalModuleBuilder get_InternalModule();
    protected virtual ModuleHandle GetModuleHandleImpl();
    internal RuntimeModule GetNativeHandle();
    private static RuntimeModule GetRuntimeModuleFromModule(Module m);
    private int GetMemberRefToken(MethodBase method, IEnumerable`1<Type> optionalParameterTypes);
    internal SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, IEnumerable`1<Type> optionalParameterTypes, int cGenericParameters);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetTypes();
    internal Type[] GetTypesNoLock();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    private Type GetTypeNoLock(string className, bool throwOnError, bool ignoreCase);
    public virtual string get_FullyQualifiedName();
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    private TypeBuilder DefineTypeNoLock(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    private TypeBuilder DefineTypeNoLock(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    private EnumBuilder DefineEnumNoLock(string name, TypeAttributes visibility, Type underlyingType);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    private MethodBuilder DefineGlobalMethodNoLock(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public void CreateGlobalFunctions();
    private void CreateGlobalFunctionsNoLock();
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    private FieldBuilder DefineInitializedDataNoLock(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineUninitializedDataNoLock(string name, int size, FieldAttributes attributes);
    internal TypeToken GetTypeTokenInternal(Type type);
    private TypeToken GetTypeTokenInternal(Type type, bool getGenericDefinition);
    public TypeToken GetTypeToken(Type type);
    private TypeToken GetTypeTokenWorkerNoLock(Type type, bool getGenericDefinition);
    public TypeToken GetTypeToken(string name);
    public MethodToken GetMethodToken(MethodInfo method);
    internal MethodToken GetMethodTokenInternal(MethodInfo method);
    private MethodToken GetMethodTokenNoLock(MethodInfo method, bool getGenericTypeDefinition);
    internal int GetMethodTokenInternal(MethodBase method, IEnumerable`1<Type> optionalParameterTypes, bool useMethodDef);
    public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    private MethodToken GetArrayMethodTokenNoLock(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodToken GetConstructorToken(ConstructorInfo con);
    public FieldToken GetFieldToken(FieldInfo field);
    private FieldToken GetFieldTokenNoLock(FieldInfo field);
    public StringToken GetStringConstant(string str);
    public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
    public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    internal ISymbolWriter GetSymWriter();
    public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    private ISymbolDocumentWriter DefineDocumentNoLock(string url, Guid language, Guid languageVendor, Guid documentType);
    public bool IsTransient();
}
internal class System.Reflection.Emit.ModuleBuilderData : object {
    internal string m_strModuleName;
    internal string m_strFileName;
    internal bool m_fGlobalBeenCreated;
    internal bool m_fHasGlobal;
    internal TypeBuilder m_globalTypeBuilder;
    internal ModuleBuilder m_module;
    private int m_tkFile;
    internal ModuleBuilderData(ModuleBuilder module, string strModuleName, string strFileName, int tkFile);
    private void InitNames(string strModuleName, string strFileName);
}
public class System.Reflection.Emit.OpCode : ValueType {
    private OpCodeValues m_value;
    private int m_flags;
    private static String[] modreq(System.Runtime.CompilerServices.IsVolatile) g_nameCache;
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public int Size { get; }
    public short Value { get; }
    public string Name { get; }
    internal OpCode(OpCodeValues value, int flags);
    internal bool EndsUncondJmpBlk();
    internal int StackChange();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public int get_Size();
    public short get_Value();
    public string get_Name();
    public virtual bool Equals(object obj);
    public bool Equals(OpCode obj);
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum System.Reflection.Emit.OpCodeValues : Enum {
    public int value__;
    public static OpCodeValues Nop;
    public static OpCodeValues Break;
    public static OpCodeValues Ldarg_0;
    public static OpCodeValues Ldarg_1;
    public static OpCodeValues Ldarg_2;
    public static OpCodeValues Ldarg_3;
    public static OpCodeValues Ldloc_0;
    public static OpCodeValues Ldloc_1;
    public static OpCodeValues Ldloc_2;
    public static OpCodeValues Ldloc_3;
    public static OpCodeValues Stloc_0;
    public static OpCodeValues Stloc_1;
    public static OpCodeValues Stloc_2;
    public static OpCodeValues Stloc_3;
    public static OpCodeValues Ldarg_S;
    public static OpCodeValues Ldarga_S;
    public static OpCodeValues Starg_S;
    public static OpCodeValues Ldloc_S;
    public static OpCodeValues Ldloca_S;
    public static OpCodeValues Stloc_S;
    public static OpCodeValues Ldnull;
    public static OpCodeValues Ldc_I4_M1;
    public static OpCodeValues Ldc_I4_0;
    public static OpCodeValues Ldc_I4_1;
    public static OpCodeValues Ldc_I4_2;
    public static OpCodeValues Ldc_I4_3;
    public static OpCodeValues Ldc_I4_4;
    public static OpCodeValues Ldc_I4_5;
    public static OpCodeValues Ldc_I4_6;
    public static OpCodeValues Ldc_I4_7;
    public static OpCodeValues Ldc_I4_8;
    public static OpCodeValues Ldc_I4_S;
    public static OpCodeValues Ldc_I4;
    public static OpCodeValues Ldc_I8;
    public static OpCodeValues Ldc_R4;
    public static OpCodeValues Ldc_R8;
    public static OpCodeValues Dup;
    public static OpCodeValues Pop;
    public static OpCodeValues Jmp;
    public static OpCodeValues Call;
    public static OpCodeValues Calli;
    public static OpCodeValues Ret;
    public static OpCodeValues Br_S;
    public static OpCodeValues Brfalse_S;
    public static OpCodeValues Brtrue_S;
    public static OpCodeValues Beq_S;
    public static OpCodeValues Bge_S;
    public static OpCodeValues Bgt_S;
    public static OpCodeValues Ble_S;
    public static OpCodeValues Blt_S;
    public static OpCodeValues Bne_Un_S;
    public static OpCodeValues Bge_Un_S;
    public static OpCodeValues Bgt_Un_S;
    public static OpCodeValues Ble_Un_S;
    public static OpCodeValues Blt_Un_S;
    public static OpCodeValues Br;
    public static OpCodeValues Brfalse;
    public static OpCodeValues Brtrue;
    public static OpCodeValues Beq;
    public static OpCodeValues Bge;
    public static OpCodeValues Bgt;
    public static OpCodeValues Ble;
    public static OpCodeValues Blt;
    public static OpCodeValues Bne_Un;
    public static OpCodeValues Bge_Un;
    public static OpCodeValues Bgt_Un;
    public static OpCodeValues Ble_Un;
    public static OpCodeValues Blt_Un;
    public static OpCodeValues Switch;
    public static OpCodeValues Ldind_I1;
    public static OpCodeValues Ldind_U1;
    public static OpCodeValues Ldind_I2;
    public static OpCodeValues Ldind_U2;
    public static OpCodeValues Ldind_I4;
    public static OpCodeValues Ldind_U4;
    public static OpCodeValues Ldind_I8;
    public static OpCodeValues Ldind_I;
    public static OpCodeValues Ldind_R4;
    public static OpCodeValues Ldind_R8;
    public static OpCodeValues Ldind_Ref;
    public static OpCodeValues Stind_Ref;
    public static OpCodeValues Stind_I1;
    public static OpCodeValues Stind_I2;
    public static OpCodeValues Stind_I4;
    public static OpCodeValues Stind_I8;
    public static OpCodeValues Stind_R4;
    public static OpCodeValues Stind_R8;
    public static OpCodeValues Add;
    public static OpCodeValues Sub;
    public static OpCodeValues Mul;
    public static OpCodeValues Div;
    public static OpCodeValues Div_Un;
    public static OpCodeValues Rem;
    public static OpCodeValues Rem_Un;
    public static OpCodeValues And;
    public static OpCodeValues Or;
    public static OpCodeValues Xor;
    public static OpCodeValues Shl;
    public static OpCodeValues Shr;
    public static OpCodeValues Shr_Un;
    public static OpCodeValues Neg;
    public static OpCodeValues Not;
    public static OpCodeValues Conv_I1;
    public static OpCodeValues Conv_I2;
    public static OpCodeValues Conv_I4;
    public static OpCodeValues Conv_I8;
    public static OpCodeValues Conv_R4;
    public static OpCodeValues Conv_R8;
    public static OpCodeValues Conv_U4;
    public static OpCodeValues Conv_U8;
    public static OpCodeValues Callvirt;
    public static OpCodeValues Cpobj;
    public static OpCodeValues Ldobj;
    public static OpCodeValues Ldstr;
    public static OpCodeValues Newobj;
    public static OpCodeValues Castclass;
    public static OpCodeValues Isinst;
    public static OpCodeValues Conv_R_Un;
    public static OpCodeValues Unbox;
    public static OpCodeValues Throw;
    public static OpCodeValues Ldfld;
    public static OpCodeValues Ldflda;
    public static OpCodeValues Stfld;
    public static OpCodeValues Ldsfld;
    public static OpCodeValues Ldsflda;
    public static OpCodeValues Stsfld;
    public static OpCodeValues Stobj;
    public static OpCodeValues Conv_Ovf_I1_Un;
    public static OpCodeValues Conv_Ovf_I2_Un;
    public static OpCodeValues Conv_Ovf_I4_Un;
    public static OpCodeValues Conv_Ovf_I8_Un;
    public static OpCodeValues Conv_Ovf_U1_Un;
    public static OpCodeValues Conv_Ovf_U2_Un;
    public static OpCodeValues Conv_Ovf_U4_Un;
    public static OpCodeValues Conv_Ovf_U8_Un;
    public static OpCodeValues Conv_Ovf_I_Un;
    public static OpCodeValues Conv_Ovf_U_Un;
    public static OpCodeValues Box;
    public static OpCodeValues Newarr;
    public static OpCodeValues Ldlen;
    public static OpCodeValues Ldelema;
    public static OpCodeValues Ldelem_I1;
    public static OpCodeValues Ldelem_U1;
    public static OpCodeValues Ldelem_I2;
    public static OpCodeValues Ldelem_U2;
    public static OpCodeValues Ldelem_I4;
    public static OpCodeValues Ldelem_U4;
    public static OpCodeValues Ldelem_I8;
    public static OpCodeValues Ldelem_I;
    public static OpCodeValues Ldelem_R4;
    public static OpCodeValues Ldelem_R8;
    public static OpCodeValues Ldelem_Ref;
    public static OpCodeValues Stelem_I;
    public static OpCodeValues Stelem_I1;
    public static OpCodeValues Stelem_I2;
    public static OpCodeValues Stelem_I4;
    public static OpCodeValues Stelem_I8;
    public static OpCodeValues Stelem_R4;
    public static OpCodeValues Stelem_R8;
    public static OpCodeValues Stelem_Ref;
    public static OpCodeValues Ldelem;
    public static OpCodeValues Stelem;
    public static OpCodeValues Unbox_Any;
    public static OpCodeValues Conv_Ovf_I1;
    public static OpCodeValues Conv_Ovf_U1;
    public static OpCodeValues Conv_Ovf_I2;
    public static OpCodeValues Conv_Ovf_U2;
    public static OpCodeValues Conv_Ovf_I4;
    public static OpCodeValues Conv_Ovf_U4;
    public static OpCodeValues Conv_Ovf_I8;
    public static OpCodeValues Conv_Ovf_U8;
    public static OpCodeValues Refanyval;
    public static OpCodeValues Ckfinite;
    public static OpCodeValues Mkrefany;
    public static OpCodeValues Ldtoken;
    public static OpCodeValues Conv_U2;
    public static OpCodeValues Conv_U1;
    public static OpCodeValues Conv_I;
    public static OpCodeValues Conv_Ovf_I;
    public static OpCodeValues Conv_Ovf_U;
    public static OpCodeValues Add_Ovf;
    public static OpCodeValues Add_Ovf_Un;
    public static OpCodeValues Mul_Ovf;
    public static OpCodeValues Mul_Ovf_Un;
    public static OpCodeValues Sub_Ovf;
    public static OpCodeValues Sub_Ovf_Un;
    public static OpCodeValues Endfinally;
    public static OpCodeValues Leave;
    public static OpCodeValues Leave_S;
    public static OpCodeValues Stind_I;
    public static OpCodeValues Conv_U;
    public static OpCodeValues Prefix7;
    public static OpCodeValues Prefix6;
    public static OpCodeValues Prefix5;
    public static OpCodeValues Prefix4;
    public static OpCodeValues Prefix3;
    public static OpCodeValues Prefix2;
    public static OpCodeValues Prefix1;
    public static OpCodeValues Prefixref;
    public static OpCodeValues Arglist;
    public static OpCodeValues Ceq;
    public static OpCodeValues Cgt;
    public static OpCodeValues Cgt_Un;
    public static OpCodeValues Clt;
    public static OpCodeValues Clt_Un;
    public static OpCodeValues Ldftn;
    public static OpCodeValues Ldvirtftn;
    public static OpCodeValues Ldarg;
    public static OpCodeValues Ldarga;
    public static OpCodeValues Starg;
    public static OpCodeValues Ldloc;
    public static OpCodeValues Ldloca;
    public static OpCodeValues Stloc;
    public static OpCodeValues Localloc;
    public static OpCodeValues Endfilter;
    public static OpCodeValues Unaligned_;
    public static OpCodeValues Volatile_;
    public static OpCodeValues Tail_;
    public static OpCodeValues Initobj;
    public static OpCodeValues Constrained_;
    public static OpCodeValues Cpblk;
    public static OpCodeValues Initblk;
    public static OpCodeValues Rethrow;
    public static OpCodeValues Sizeof;
    public static OpCodeValues Refanytype;
    public static OpCodeValues Readonly_;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
public class System.Reflection.Emit.ParameterBuilder : object {
    private string m_strParamName;
    private int m_iPosition;
    private ParameterAttributes m_attributes;
    private MethodBuilder m_methodBuilder;
    private ParameterToken m_pdToken;
    public string Name { get; }
    public int Position { get; }
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsOptional { get; }
    internal ParameterBuilder(MethodBuilder methodBuilder, int sequence, ParameterAttributes attributes, string strParamName);
    public virtual void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual ParameterToken GetToken();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOut();
    public bool get_IsOptional();
}
public class System.Reflection.Emit.ParameterToken : ValueType {
    public static ParameterToken Empty;
    internal int m_tkParameter;
    public int Token { get; }
    internal ParameterToken(int tkParam);
    private static ParameterToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ParameterToken obj);
    public static bool op_Equality(ParameterToken a, ParameterToken b);
    public static bool op_Inequality(ParameterToken a, ParameterToken b);
}
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    private string m_name;
    private PropertyToken m_prToken;
    private int m_tkProperty;
    private ModuleBuilder m_moduleBuilder;
    private SignatureHelper m_signature;
    private PropertyAttributes m_attributes;
    private Type m_returnType;
    private MethodInfo m_getMethod;
    private MethodInfo m_setMethod;
    private TypeBuilder m_containingType;
    public PropertyToken PropertyToken { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal PropertyBuilder(ModuleBuilder mod, string name, SignatureHelper sig, PropertyAttributes attr, Type returnType, PropertyToken prToken, TypeBuilder containingType);
    public void SetConstant(object defaultValue);
    public PropertyToken get_PropertyToken();
    public virtual Module get_Module();
    private void SetMethodSemantics(MethodBuilder mdBuilder, MethodSemanticsAttributes semantics);
    public void SetGetMethod(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual Type get_PropertyType();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
}
public class System.Reflection.Emit.PropertyToken : ValueType {
    public static PropertyToken Empty;
    internal int m_property;
    public int Token { get; }
    internal PropertyToken(int str);
    private static PropertyToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PropertyToken obj);
    public static bool op_Equality(PropertyToken a, PropertyToken b);
    public static bool op_Inequality(PropertyToken a, PropertyToken b);
}
internal class System.Reflection.Emit.PunkSafeHandle : SafeHandle {
    private static DRelease m_Release;
    public bool IsInvalid { get; }
    private static PunkSafeHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    private static IntPtr nGetDReleaseTarget();
}
internal class System.Reflection.Emit.REDocument : object {
    private Int32[] m_iOffsets;
    private Int32[] m_iLines;
    private Int32[] m_iColumns;
    private Int32[] m_iEndLines;
    private Int32[] m_iEndColumns;
    internal ISymbolDocumentWriter m_document;
    private int m_iLineNumberCount;
    internal REDocument(ISymbolDocumentWriter document);
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    private void EnsureCapacity();
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
internal class System.Reflection.Emit.ResWriterData : object {
}
internal enum System.Reflection.Emit.ScopeAction : Enum {
    public int value__;
    public static ScopeAction Open;
    public static ScopeAction Close;
}
internal class System.Reflection.Emit.ScopeTree : object {
    internal Int32[] m_iOffsets;
    internal ScopeAction[] m_ScopeActions;
    internal int m_iCount;
    internal int m_iOpenScopeCount;
    internal LocalSymInfo[] m_localSymInfos;
    internal int GetCurrentActiveScopeIndex();
    internal void AddLocalSymInfoToCurrentScope(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespaceToCurrentScope(string strNamespace);
    internal void AddScopeInfo(ScopeAction sa, int iOffset);
    internal void EnsureCapacity();
    internal void EmitScopeTree(ISymbolWriter symWriter);
}
public class System.Reflection.Emit.SignatureHelper : object {
    private Byte[] m_signature;
    private int m_currSig;
    private int m_sizeLoc;
    private ModuleBuilder m_module;
    private bool m_sigDone;
    private int m_argCount;
    internal int ArgumentCount { get; }
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention);
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention, int cGenericParameters, Type returnType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention, Type returnType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private SignatureHelper(Module mod, Type type);
    public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    internal static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType, int cGenericParam);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    internal static SignatureHelper GetMethodSpecSigHelper(Module scope, Type[] inst);
    internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, int cGenericParam, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    internal static SignatureHelper GetTypeSigToken(Module module, Type type);
    private void Init(Module mod);
    private void Init(Module mod, MdSigCallingConvention callingConvention);
    private void Init(Module mod, MdSigCallingConvention callingConvention, int cGenericParam);
    private void AddOneArgTypeHelper(Type argument, bool pinned);
    private void AddOneArgTypeHelper(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private void AddOneArgTypeHelper(Type clsArgument);
    private void AddOneArgTypeHelperWorker(Type clsArgument, bool lastWasGenericInst);
    private void AddData(int data);
    private void AddElementType(CorElementType cvt);
    private void AddToken(int token);
    private void InternalAddTypeToken(TypeToken clsToken, CorElementType CorType);
    private void InternalAddRuntimeType(Type type);
    private Byte[] ExpandArray(Byte[] inArray);
    private Byte[] ExpandArray(Byte[] inArray, int requiredLength);
    private void IncrementArgCounts();
    private void SetNumberOfSignatureElements(bool forceCopy);
    internal int get_ArgumentCount();
    internal static bool IsSimpleType(CorElementType type);
    internal Byte[] InternalGetSignature(Int32& length);
    internal Byte[] InternalGetSignatureArray();
    public void AddArgument(Type clsArgument);
    public void AddArgument(Type argument, bool pinned);
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddSentinel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetSignature();
    internal Byte[] GetSignature(bool appendEndOfSig);
    public virtual string ToString();
}
public class System.Reflection.Emit.SignatureToken : ValueType {
    public static SignatureToken Empty;
    internal int m_signature;
    internal ModuleBuilder m_moduleBuilder;
    public int Token { get; }
    internal SignatureToken(int str, ModuleBuilder mod);
    private static SignatureToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SignatureToken obj);
    public static bool op_Equality(SignatureToken a, SignatureToken b);
    public static bool op_Inequality(SignatureToken a, SignatureToken b);
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
public class System.Reflection.Emit.StringToken : ValueType {
    internal int m_string;
    public int Token { get; }
    internal StringToken(int str);
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(StringToken obj);
    public static bool op_Equality(StringToken a, StringToken b);
    public static bool op_Inequality(StringToken a, StringToken b);
}
internal class System.Reflection.Emit.SymbolMethod : MethodInfo {
    private ModuleBuilder m_module;
    private Type m_containingType;
    private string m_name;
    private CallingConventions m_callingConvention;
    private Type m_returnType;
    private MethodToken m_mdMethod;
    private Type[] m_parameterTypes;
    private SignatureHelper m_signature;
    public Module Module { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal SymbolMethod(ModuleBuilder mod, MethodToken token, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    internal virtual Type[] GetParameterTypes();
    internal MethodToken GetToken(ModuleBuilder mod);
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public Module GetModule();
    public MethodToken GetToken();
}
internal class System.Reflection.Emit.SymbolType : TypeInfo {
    internal TypeKind m_typeKind;
    internal Type m_baseType;
    internal int m_cRank;
    internal Int32[] m_iaLowerBound;
    internal Int32[] m_iaUpperBound;
    private string m_format;
    private bool m_isSzArray;
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    internal SymbolType(TypeKind typeKind);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type FormCompoundType(string format, Type baseType, int curIndex);
    internal void SetElementType(Type baseType);
    private void SetBounds(int lower, int upper);
    internal void SetFormat(string format, int curIndex, int length);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual int GetArrayRank();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Emit.SymWrapperCore : object {
}
public class System.Reflection.Emit.TypeBuilder : TypeInfo {
    public static int UnspecifiedTypeSize;
    private List`1<CustAttr> m_ca;
    private TypeToken m_tdType;
    private ModuleBuilder m_module;
    private string m_strName;
    private string m_strNameSpace;
    private string m_strFullQualName;
    private Type m_typeParent;
    private List`1<Type> m_typeInterfaces;
    private TypeAttributes m_iAttr;
    private GenericParameterAttributes m_genParamAttributes;
    internal List`1<MethodBuilder> m_listMethods;
    internal int m_lastTokenizedMethod;
    private int m_constructorCount;
    private int m_iTypeSize;
    private PackingSize m_iPackingSize;
    private TypeBuilder m_DeclaringType;
    private Type m_enumUnderlyingType;
    internal bool m_isHiddenGlobalType;
    private bool m_hasBeenCreated;
    private RuntimeType m_bakedRuntimeType;
    private int m_genParamPos;
    private GenericTypeParameterBuilder[] m_inst;
    private bool m_bIsGenParam;
    private MethodBuilder m_declMeth;
    private TypeBuilder m_genTypeDef;
    internal object SyncRoot { get; }
    internal RuntimeType BakedRuntimeType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type UnderlyingSystemType { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    public int Size { get; }
    public PackingSize PackingSize { get; }
    public TypeToken TypeToken { get; }
    internal TypeBuilder(ModuleBuilder module);
    internal TypeBuilder(string szName, int genParamPos, MethodBuilder declMeth);
    private TypeBuilder(string szName, int genParamPos, TypeBuilder declType);
    internal TypeBuilder(string name, TypeAttributes attr, Type parent, Type[] interfaces, ModuleBuilder module, PackingSize iPackingSize, int iTypeSize, TypeBuilder enclosingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    public static FieldInfo GetField(Type type, FieldInfo field);
    private static void SetParentType(RuntimeModule module, int tdTypeDef, int tkParent);
    private static void AddInterfaceImpl(RuntimeModule module, int tdTypeDef, int tkInterface);
    internal static int DefineMethod(RuntimeModule module, int tkParent, string name, Byte[] signature, int sigLength, MethodAttributes attributes);
    internal static int DefineMethodSpec(RuntimeModule module, int tkParent, Byte[] signature, int sigLength);
    internal static int DefineField(RuntimeModule module, int tkParent, string name, Byte[] signature, int sigLength, FieldAttributes attributes);
    private static void SetMethodIL(RuntimeModule module, int tk, bool isInitLocals, Byte[] body, int bodyLength, Byte[] LocalSig, int sigLength, int maxStackSize, ExceptionHandler[] exceptions, int numExceptions, Int32[] tokenFixups, int numTokenFixups);
    private static void DefineCustomAttribute(RuntimeModule module, int tkAssociate, int tkConstructor, Byte[] attr, int attrLength, bool toDisk, bool updateCompilerFlags);
    internal static void DefineCustomAttribute(ModuleBuilder module, int tkAssociate, int tkConstructor, Byte[] attr, bool toDisk, bool updateCompilerFlags);
    internal static int DefineProperty(RuntimeModule module, int tkParent, string name, PropertyAttributes attributes, Byte[] signature, int sigLength);
    internal static int DefineEvent(RuntimeModule module, int tkParent, string name, EventAttributes attributes, int tkEventType);
    internal static void DefineMethodSemantics(RuntimeModule module, int tkAssociation, MethodSemanticsAttributes semantics, int tkMethod);
    internal static void DefineMethodImpl(RuntimeModule module, int tkType, int tkBody, int tkDecl);
    internal static void SetMethodImpl(RuntimeModule module, int tkMethod, MethodImplAttributes MethodImplAttributes);
    internal static int SetParamInfo(RuntimeModule module, int tkMethod, int iSequence, ParameterAttributes iParamAttributes, string strParamName);
    internal static int GetTokenFromSig(RuntimeModule module, Byte[] signature, int sigLength);
    internal static void SetFieldLayoutOffset(RuntimeModule module, int fdToken, int iOffset);
    internal static void SetClassLayout(RuntimeModule module, int tk, PackingSize iPackingSize, int iTypeSize);
    private static void SetConstantValue(RuntimeModule module, int tk, int corType, Void* pValue);
    internal static bool IsTypeEqual(Type t1, Type t2);
    internal static void SetConstantValue(ModuleBuilder module, int tk, Type destType, object value);
    private void InitAsGenericParam(string szName, int genParamPos);
    private void Init(string fullname, TypeAttributes attr, Type parent, Type[] interfaces, ModuleBuilder module, PackingSize iPackingSize, int iTypeSize, TypeBuilder enclosingType);
    private FieldBuilder DefineDataHelper(string name, Byte[] data, int size, FieldAttributes attributes);
    private void VerifyTypeAttributes(TypeAttributes attr);
    public bool IsCreated();
    private static int DefineType(RuntimeModule module, string fullname, int tkParent, TypeAttributes attributes, int tkEnclosingType, Int32[] interfaceTokens);
    private static int DefineGenericParam(RuntimeModule module, string name, int tkParent, GenericParameterAttributes attributes, int position, Int32[] constraints);
    private static void TermCreateClass(RuntimeModule module, int tk, ObjectHandleOnStack type);
    internal void ThrowIfCreated();
    internal object get_SyncRoot();
    internal ModuleBuilder GetModuleBuilder();
    internal RuntimeType get_BakedRuntimeType();
    internal void SetGenParamAttributes(GenericParameterAttributes genericParameterAttributes);
    internal void SetGenParamCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    internal void SetGenParamCustomAttribute(CustomAttributeBuilder customBuilder);
    private void SetGenParamCustomAttributeNoLock(CustAttr ca);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual bool IsAssignableFrom(Type c);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    internal void SetInterfaces(Type[] interfaces);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    private void DefineMethodOverrideNoLock(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    private MethodBuilder DefineMethodNoLock(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ConstructorBuilder DefineTypeInitializer();
    private ConstructorBuilder DefineTypeInitializerNoLock();
    public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    private ConstructorBuilder DefineDefaultConstructorNoLock(MethodAttributes attributes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    private ConstructorBuilder DefineConstructorNoLock(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    private TypeBuilder DefineNestedTypeNoLock(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    private FieldBuilder DefineFieldNoLock(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    private FieldBuilder DefineInitializedDataNoLock(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineUninitializedDataNoLock(string name, int size, FieldAttributes attributes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    private PropertyBuilder DefinePropertyNoLock(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    private EventBuilder DefineEventNoLock(string name, EventAttributes attributes, Type eventtype);
    public TypeInfo CreateTypeInfo();
    public Type CreateType();
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    private TypeInfo CreateTypeNoLock();
    public int get_Size();
    public PackingSize get_PackingSize();
    public void SetParent(Type parent);
    public void AddInterfaceImplementation(Type interfaceType);
    public TypeToken get_TypeToken();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
internal class System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
    private Type m_type;
    private Type[] m_inst;
    private string m_strFullQualName;
    internal Hashtable m_hashtable;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    private TypeBuilderInstantiation(Type type, Type[] inst);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type MakeGenericType(Type type, Type[] typeArguments);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    private Type Substitute(Type[] substitutes);
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] inst);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal enum System.Reflection.Emit.TypeKind : Enum {
    public int value__;
    public static TypeKind IsArray;
    public static TypeKind IsPointer;
    public static TypeKind IsByRef;
}
internal class System.Reflection.Emit.TypeNameBuilder : object {
    private IntPtr m_typeNameBuilder;
    private TypeNameBuilder(IntPtr typeNameBuilder);
    private static IntPtr CreateTypeNameBuilder();
    private static void ReleaseTypeNameBuilder(IntPtr pAQN);
    private static void OpenGenericArguments(IntPtr tnb);
    private static void CloseGenericArguments(IntPtr tnb);
    private static void OpenGenericArgument(IntPtr tnb);
    private static void CloseGenericArgument(IntPtr tnb);
    private static void AddName(IntPtr tnb, string name);
    private static void AddPointer(IntPtr tnb);
    private static void AddByRef(IntPtr tnb);
    private static void AddSzArray(IntPtr tnb);
    private static void AddArray(IntPtr tnb, int rank);
    private static void AddAssemblySpec(IntPtr tnb, string assemblySpec);
    private static void ToString(IntPtr tnb, StringHandleOnStack retString);
    private static void Clear(IntPtr tnb);
    internal static string ToString(Type type, Format format);
    internal void Dispose();
    private void AddElementType(Type elementType);
    private void ConstructAssemblyQualifiedNameWorker(Type type, Format format);
    private void OpenGenericArguments();
    private void CloseGenericArguments();
    private void OpenGenericArgument();
    private void CloseGenericArgument();
    private void AddName(string name);
    private void AddPointer();
    private void AddByRef();
    private void AddSzArray();
    private void AddArray(int rank);
    private void AddAssemblySpec(string assemblySpec);
    public virtual string ToString();
    private void Clear();
}
public class System.Reflection.Emit.TypeToken : ValueType {
    public static TypeToken Empty;
    internal int m_class;
    public int Token { get; }
    internal TypeToken(int str);
    private static TypeToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(TypeToken obj);
    public static bool op_Equality(TypeToken a, TypeToken b);
    public static bool op_Inequality(TypeToken a, TypeToken b);
}
internal class System.Reflection.Emit.VarArgMethod : object {
    internal RuntimeMethodInfo m_method;
    internal DynamicMethod m_dynamicMethod;
    internal SignatureHelper m_signature;
    internal VarArgMethod(DynamicMethod dm, SignatureHelper signature);
    internal VarArgMethod(RuntimeMethodInfo method, SignatureHelper signature);
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
    public static EventAttributes ReservedMask;
}
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public bool IsMulticast { get; }
    public Type EventHandlerType { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual EventAttributes get_Attributes();
    public bool get_IsSpecialName();
    public MethodInfo[] GetOtherMethods();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public MethodInfo GetAddMethod();
    public MethodInfo GetRemoveMethod();
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual bool get_IsMulticast();
    public virtual Type get_EventHandlerType();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
}
public class System.Reflection.ExceptionHandlingClause : object {
    private MethodBody m_methodBody;
    private ExceptionHandlingClauseOptions m_flags;
    private int m_tryOffset;
    private int m_tryLength;
    private int m_handlerOffset;
    private int m_handlerLength;
    private int m_catchMetadataToken;
    private int m_filterOffset;
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes ReservedMask;
}
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public virtual MemberTypes get_MemberType();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual Type get_FieldType();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public abstract virtual object GetValue(object obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public virtual object GetRawConstantValue();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
public class System.Reflection.InterfaceMapping : ValueType {
    public Type TargetType;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum System.Reflection.INVOCATION_FLAGS : Enum {
    public UInt32 value__;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_UNKNOWN;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_INITIALIZED;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_CTOR_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_RISKY_METHOD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_DELEGATE_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONTAINS_STACK_POINTERS;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_SPECIAL_FIELD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_FIELD_SPECIAL_CAST;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONSTRUCTOR_INVOKE;
}
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
internal class System.Reflection.LoaderAllocator : object {
    private LoaderAllocatorScout m_scout;
    private Object[] m_slots;
    internal CerHashtable`2<RuntimeMethodInfo, RuntimeMethodInfo> m_methodInstantiations;
    private int m_slotsUsed;
}
internal class System.Reflection.LoaderAllocatorScout : object {
    internal IntPtr m_nativeLoaderAllocator;
    private static bool Destroy(IntPtr nativeLoaderAllocator);
    protected virtual override void Finalize();
}
public class System.Reflection.LocalVariableInfo : object {
    private RuntimeType m_type;
    private int m_isPinned;
    private int m_localIndex;
    public Type LocalType { get; }
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public virtual string ToString();
    public virtual Type get_LocalType();
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
}
public class System.Reflection.ManifestResourceInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <ReferencedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceLocation <ResourceLocation>k__BackingField;
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    [CompilerGeneratedAttribute]
public virtual Assembly get_ReferencedAssembly();
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
public virtual ResourceLocation get_ResourceLocation();
}
internal static class System.Reflection.MdConstant : object {
    public static object GetValue(MetadataImport scope, int token, RuntimeTypeHandle fieldTypeHandle, bool raw);
}
internal class System.Reflection.MdFieldInfo : RuntimeFieldInfo {
    private int m_tkField;
    private string m_name;
    private RuntimeType m_fieldType;
    private FieldAttributes m_fieldAttributes;
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type FieldType { get; }
    internal MdFieldInfo(int tkField, FieldAttributes fieldAttributes, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    internal virtual bool CacheEquals(object o);
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    private object GetValue(bool raw);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual Type get_FieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
[FlagsAttribute]
internal enum System.Reflection.MdSigCallingConvention : Enum {
    public byte value__;
    public static MdSigCallingConvention CallConvMask;
    public static MdSigCallingConvention Default;
    public static MdSigCallingConvention C;
    public static MdSigCallingConvention StdCall;
    public static MdSigCallingConvention ThisCall;
    public static MdSigCallingConvention FastCall;
    public static MdSigCallingConvention Vararg;
    public static MdSigCallingConvention Field;
    public static MdSigCallingConvention LocalSig;
    public static MdSigCallingConvention Property;
    public static MdSigCallingConvention Unmgd;
    public static MdSigCallingConvention GenericInst;
    public static MdSigCallingConvention Generic;
    public static MdSigCallingConvention HasThis;
    public static MdSigCallingConvention ExplicitThis;
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    internal virtual bool CacheEquals(object o);
    internal bool HasSameMetadataDefinitionAsCore(MemberInfo other);
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.AssemblyExtensions : object {
    private static bool InternalTryGetRawMetadata(RuntimeAssembly assembly, Byte*& blob, Int32& length);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetRawMetadata(Assembly assembly, Byte*& blob, Int32& length);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.MetadataEnumResult : ValueType {
    private Int32[] largeResult;
    private int length;
    [FixedBufferAttribute("System.Int32", "16")]
private <smallResult>e__FixedBuffer smallResult;
    public int Length { get; }
    public int Item { get; }
    public int get_Length();
    public int get_Item(int index);
}
internal class System.Reflection.MetadataException : Exception {
    private int m_hr;
    internal MetadataException(int hr);
    public virtual string ToString();
}
internal class System.Reflection.MetadataImport : ValueType {
    private IntPtr m_metadataImport2;
    private object m_keepalive;
    internal static MetadataImport EmptyImport;
    internal MetadataImport(IntPtr metadataImport2, object keepalive);
    private static MetadataImport();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool Equals(MetadataImport import);
    private static void _GetMarshalAs(IntPtr pNativeType, int cNativeType, Int32& unmanagedType, Int32& safeArraySubType, String& safeArrayUserDefinedSubType, Int32& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void GetMarshalAs(ConstArray nativeType, UnmanagedType& unmanagedType, VarEnum& safeArraySubType, String& safeArrayUserDefinedSubType, UnmanagedType& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void ThrowError(int hResult);
    private static void _Enum(IntPtr scope, int type, int parent, MetadataEnumResult& result);
    public void Enum(MetadataTokenType type, int parent, MetadataEnumResult& result);
    public void EnumNestedTypes(int mdTypeDef, MetadataEnumResult& result);
    public void EnumCustomAttributes(int mdToken, MetadataEnumResult& result);
    public void EnumParams(int mdMethodDef, MetadataEnumResult& result);
    public void EnumFields(int mdTypeDef, MetadataEnumResult& result);
    public void EnumProperties(int mdTypeDef, MetadataEnumResult& result);
    public void EnumEvents(int mdTypeDef, MetadataEnumResult& result);
    private static string _GetDefaultValue(IntPtr scope, int mdToken, Int64& value, Int32& length, Int32& corElementType);
    public string GetDefaultValue(int mdToken, Int64& value, Int32& length, CorElementType& corElementType);
    private static void _GetUserString(IntPtr scope, int mdToken, Void** name, Int32& length);
    public string GetUserString(int mdToken);
    private static void _GetName(IntPtr scope, int mdToken, Void** name);
    public Utf8String GetName(int mdToken);
    private static void _GetNamespace(IntPtr scope, int mdToken, Void** namesp);
    public Utf8String GetNamespace(int mdToken);
    private static void _GetEventProps(IntPtr scope, int mdToken, Void** name, Int32& eventAttributes);
    public void GetEventProps(int mdToken, Void*& name, EventAttributes& eventAttributes);
    private static void _GetFieldDefProps(IntPtr scope, int mdToken, Int32& fieldAttributes);
    public void GetFieldDefProps(int mdToken, FieldAttributes& fieldAttributes);
    private static void _GetPropertyProps(IntPtr scope, int mdToken, Void** name, Int32& propertyAttributes, ConstArray& signature);
    public void GetPropertyProps(int mdToken, Void*& name, PropertyAttributes& propertyAttributes, ConstArray& signature);
    private static void _GetParentToken(IntPtr scope, int mdToken, Int32& tkParent);
    public int GetParentToken(int tkToken);
    private static void _GetParamDefProps(IntPtr scope, int parameterToken, Int32& sequence, Int32& attributes);
    public void GetParamDefProps(int parameterToken, Int32& sequence, ParameterAttributes& attributes);
    private static void _GetGenericParamProps(IntPtr scope, int genericParameter, Int32& flags);
    public void GetGenericParamProps(int genericParameter, GenericParameterAttributes& attributes);
    private static void _GetScopeProps(IntPtr scope, Guid& mvid);
    public void GetScopeProps(Guid& mvid);
    public ConstArray GetMethodSignature(MetadataToken token);
    private static void _GetSigOfMethodDef(IntPtr scope, int methodToken, ConstArray& signature);
    public ConstArray GetSigOfMethodDef(int methodToken);
    private static void _GetSignatureFromToken(IntPtr scope, int methodToken, ConstArray& signature);
    public ConstArray GetSignatureFromToken(int token);
    private static void _GetMemberRefProps(IntPtr scope, int memberTokenRef, ConstArray& signature);
    public ConstArray GetMemberRefProps(int memberTokenRef);
    private static void _GetCustomAttributeProps(IntPtr scope, int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    public void GetCustomAttributeProps(int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    private static void _GetClassLayout(IntPtr scope, int typeTokenDef, Int32& packSize, Int32& classSize);
    public void GetClassLayout(int typeTokenDef, Int32& packSize, Int32& classSize);
    private static bool _GetFieldOffset(IntPtr scope, int typeTokenDef, int fieldTokenDef, Int32& offset);
    public bool GetFieldOffset(int typeTokenDef, int fieldTokenDef, Int32& offset);
    private static void _GetSigOfFieldDef(IntPtr scope, int fieldToken, ConstArray& fieldMarshal);
    public ConstArray GetSigOfFieldDef(int fieldToken);
    private static void _GetFieldMarshal(IntPtr scope, int fieldToken, ConstArray& fieldMarshal);
    public ConstArray GetFieldMarshal(int fieldToken);
    private static void _GetPInvokeMap(IntPtr scope, int token, Int32& attributes, Void** importName, Void** importDll);
    public void GetPInvokeMap(int token, PInvokeAttributes& attributes, String& importName, String& importDll);
    private static bool _IsValidToken(IntPtr scope, int token);
    public bool IsValidToken(int token);
}
internal class System.Reflection.MetadataToken : ValueType {
    public int Value;
    public bool IsGlobalTypeDefToken { get; }
    public MetadataTokenType TokenType { get; }
    public bool IsTypeRef { get; }
    public bool IsTypeDef { get; }
    public bool IsFieldDef { get; }
    public bool IsMethodDef { get; }
    public bool IsMemberRef { get; }
    public bool IsEvent { get; }
    public bool IsProperty { get; }
    public bool IsParamDef { get; }
    public bool IsTypeSpec { get; }
    public bool IsMethodSpec { get; }
    public bool IsString { get; }
    public bool IsSignature { get; }
    public bool IsGenericPar { get; }
    public MetadataToken(int token);
    public static int op_Implicit(MetadataToken token);
    public static MetadataToken op_Implicit(int token);
    public static bool IsNullToken(int token);
    public bool get_IsGlobalTypeDefToken();
    public MetadataTokenType get_TokenType();
    public bool get_IsTypeRef();
    public bool get_IsTypeDef();
    public bool get_IsFieldDef();
    public bool get_IsMethodDef();
    public bool get_IsMemberRef();
    public bool get_IsEvent();
    public bool get_IsProperty();
    public bool get_IsParamDef();
    public bool get_IsTypeSpec();
    public bool get_IsMethodSpec();
    public bool get_IsString();
    public bool get_IsSignature();
    public bool get_IsGenericPar();
    public virtual string ToString();
}
internal enum System.Reflection.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldDef;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamDef;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType Permission;
    public static MetadataTokenType Signature;
    public static MetadataTokenType Event;
    public static MetadataTokenType Property;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType GenericPar;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType String;
    public static MetadataTokenType Name;
    public static MetadataTokenType BaseType;
    public static MetadataTokenType Invalid;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsAbstract { get; }
    public bool IsConstructor { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public static MethodBase GetCurrentMethod();
    private IntPtr GetMethodDesc();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    internal static string ConstructParameters(Type[] parameterTypes, CallingConventions callingConvention, bool serialization);
    internal string FormatNameAndSig();
    internal virtual string FormatNameAndSig(bool serialization);
    internal virtual Type[] GetParameterTypes();
    internal Object[] CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig);
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodBody GetMethodBody();
    public virtual CallingConventions get_CallingConvention();
    public bool get_IsAbstract();
    public bool get_IsConstructor();
    public bool get_IsFinal();
    public bool get_IsHideBySig();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
}
public class System.Reflection.MethodBody : object {
    private Byte[] m_IL;
    private ExceptionHandlingClause[] m_exceptionHandlingClauses;
    private LocalVariableInfo[] m_localVariables;
    internal MethodBase m_methodBase;
    private int m_localSignatureMetadataToken;
    private int m_maxStackSize;
    private bool m_initLocals;
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
}
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal int GenericParameterCount { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodInfo GetBaseDefinition();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    public static bool op_Inequality(MethodInfo left, MethodInfo right);
    internal virtual int get_GenericParameterCount();
}
[FlagsAttribute]
internal enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public class System.Reflection.Missing : object {
    public static Missing Value;
    private static Missing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private static Module();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public ModuleHandle get_ModuleHandle();
    protected virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual bool IsResource();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual Type[] GetTypes();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual int get_MetadataToken();
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public virtual string ToString();
    private static bool FilterTypeNameImpl(Type cls, object filterCriteria);
    private static bool FilterTypeNameIgnoreCaseImpl(Type cls, object filterCriteria);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AssemblyIsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    [CompilerGeneratedAttribute]
public bool get_AssemblyIsPrivate();
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
}
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToMembers();
    [CompilerGeneratedAttribute]
public void set_ApplyToMembers(bool value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    protected Type ClassImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    protected string NameImpl;
    protected int PositionImpl;
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_MetadataToken();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[FlagsAttribute]
internal enum System.Reflection.PInvokeAttributes : Enum {
    public int value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    private Void* _ptr;
    private Type _ptrType;
    private Pointer(Void* ptr, Type ptrType);
    public static object Box(Void* ptr, Type type);
    public static Void* Unbox(object ptr);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal Type GetPointerType();
    internal IntPtr GetPointerValue();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual Type get_PropertyType();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public bool get_IsSpecialName();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo get_GetMethod();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo get_SetMethod();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public void SetValue(object obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
}
internal static class System.Reflection.PseudoCustomAttribute : object {
    private static Dictionary`2<RuntimeType, RuntimeType> s_pca;
    private static PseudoCustomAttribute();
    private static Dictionary`2<RuntimeType, RuntimeType> CreatePseudoCustomAttributeDictionary();
    internal static Attribute[] GetCustomAttributes(RuntimeType type, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeType type, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeModule module, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
    private static DllImportAttribute GetDllImportCustomAttribute(RuntimeMethodInfo method);
    private static MarshalAsAttribute GetMarshalAsCustomAttribute(RuntimeParameterInfo parameter);
    private static MarshalAsAttribute GetMarshalAsCustomAttribute(RuntimeFieldInfo field);
    private static MarshalAsAttribute GetMarshalAsCustomAttribute(int token, RuntimeModule scope);
    private static FieldOffsetAttribute GetFieldOffsetCustomAttribute(RuntimeFieldInfo field);
    internal static StructLayoutAttribute GetStructLayoutCustomAttribute(RuntimeType type);
}
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception[] <LoaderExceptions>k__BackingField;
    public Type[] Types { get; }
    public Exception[] LoaderExceptions { get; }
    public string Message { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    private ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public Exception[] get_LoaderExceptions();
    public virtual string get_Message();
    public virtual string ToString();
    private string CreateString(bool isMessage);
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
internal class System.Reflection.RtFieldInfo : RuntimeFieldInfo {
    private IntPtr m_fieldHandle;
    private FieldAttributes m_fieldAttributes;
    private string m_name;
    private RuntimeType m_fieldType;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    internal RtFieldInfo(RuntimeFieldHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
    internal void CheckConsistency(object target);
    internal virtual bool CacheEquals(object o);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture, StackCrawlMark& stackMark);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object InternalGetValue(object obj, StackCrawlMark& stackMark);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal object UnsafeGetValue(object obj);
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual RuntimeFieldHandle get_FieldHandle();
    internal IntPtr GetFieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_FieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
internal class System.Reflection.RuntimeAssembly : Assembly {
    [CompilerGeneratedAttribute]
private ModuleResolveEventHandler _ModuleResolve;
    private string m_fullname;
    private object m_syncRoot;
    private IntPtr m_assembly;
    private static string s_localFilePrefix;
    internal object SyncRoot { get; }
    public string CodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    [CompilerGeneratedAttribute]
private void add__ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__ModuleResolve(ModuleResolveEventHandler value);
    internal object get_SyncRoot();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    private static void GetCodeBase(RuntimeAssembly assembly, bool copiedName, StringHandleOnStack retString);
    internal string GetCodeBase(bool copiedName);
    public virtual string get_CodeBase();
    internal RuntimeAssembly GetNativeHandle();
    public virtual AssemblyName GetName(bool copiedName);
    private static void GetFullName(RuntimeAssembly assembly, StringHandleOnStack retString);
    public virtual string get_FullName();
    private static void GetEntryPoint(RuntimeAssembly assembly, ObjectHandleOnStack retMethod);
    public virtual MethodInfo get_EntryPoint();
    private static void GetType(RuntimeAssembly assembly, string name, bool throwOnError, bool ignoreCase, ObjectHandleOnStack type, ObjectHandleOnStack keepAlive);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    private static void GetExportedTypes(RuntimeAssembly assembly, ObjectHandleOnStack retTypes);
    public virtual Type[] GetExportedTypes();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Module get_ManifestModule();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal static RuntimeAssembly InternalLoad(string assemblyString, StackCrawlMark& stackMark);
    internal static RuntimeAssembly InternalLoad(string assemblyString, StackCrawlMark& stackMark, IntPtr pPrivHostBinder);
    internal static AssemblyName CreateAssemblyName(string assemblyString, RuntimeAssembly& assemblyFromResolveEvent);
    internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, bool throwOnFileNotFound, IntPtr ptrLoadContextBinder);
    internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool throwOnFileNotFound, IntPtr ptrLoadContextBinder);
    private static RuntimeAssembly nLoad(AssemblyName fileName, string codeBase, RuntimeAssembly locationHint, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool throwOnFileNotFound, IntPtr ptrLoadContextBinder);
    public virtual bool get_ReflectionOnly();
    private static void GetModule(RuntimeAssembly assembly, string name, ObjectHandleOnStack retModule);
    public virtual Module GetModule(string name);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    private static String[] GetManifestResourceNames(RuntimeAssembly assembly);
    public virtual String[] GetManifestResourceNames();
    private static void GetExecutingAssembly(StackCrawlMarkHandle stackMark, ObjectHandleOnStack retAssembly);
    internal static RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark);
    private static AssemblyName[] GetReferencedAssemblies(RuntimeAssembly assembly);
    public virtual AssemblyName[] GetReferencedAssemblies();
    private static int GetManifestResourceInfo(RuntimeAssembly assembly, string resourceName, ObjectHandleOnStack assemblyRef, StringHandleOnStack retFileName, StackCrawlMarkHandle stackMark);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    private static void GetLocation(RuntimeAssembly assembly, StringHandleOnStack retString);
    public virtual string get_Location();
    private static void GetImageRuntimeVersion(RuntimeAssembly assembly, StringHandleOnStack retString);
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    private static string VerifyCodeBase(string codebase);
    internal Stream GetManifestResourceStream(Type type, string name, bool skipSecurityCheck, StackCrawlMark& stackMark);
    private static Byte* GetResource(RuntimeAssembly assembly, string resourceName, UInt64& length, StackCrawlMarkHandle stackMark, bool skipSecurityCheck);
    internal Stream GetManifestResourceStream(string name, StackCrawlMark& stackMark, bool skipSecurityCheck);
    private static void GetVersion(RuntimeAssembly assembly, Int32& majVer, Int32& minVer, Int32& buildNum, Int32& revNum);
    internal Version GetVersion();
    private static void GetLocale(RuntimeAssembly assembly, StringHandleOnStack retString);
    internal CultureInfo GetLocale();
    private static bool FCallIsDynamic(RuntimeAssembly assembly);
    public virtual bool get_IsDynamic();
    private static void GetSimpleName(RuntimeAssembly assembly, StringHandleOnStack retSimpleName);
    internal string GetSimpleName();
    private static AssemblyHashAlgorithm GetHashAlgorithm(RuntimeAssembly assembly);
    private AssemblyHashAlgorithm GetHashAlgorithm();
    private static AssemblyNameFlags GetFlags(RuntimeAssembly assembly);
    private AssemblyNameFlags GetFlags();
    private static void GetPublicKey(RuntimeAssembly assembly, ObjectHandleOnStack retPublicKey);
    internal Byte[] GetPublicKey();
    private RuntimeModule OnModuleResolveEvent(string moduleName);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    internal Assembly InternalGetSatelliteAssembly(CultureInfo culture, Version version, StackCrawlMark& stackMark);
    internal RuntimeAssembly InternalGetSatelliteAssembly(string name, CultureInfo culture, Version version, bool throwOnFileNotFound, StackCrawlMark& stackMark);
    private static void GetModules(RuntimeAssembly assembly, bool loadIfNotFound, bool getResourceModules, ObjectHandleOnStack retModuleHandles);
    private RuntimeModule[] GetModulesInternal(bool loadIfNotFound, bool getResourceModules);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    internal static RuntimeModule GetManifestModule(RuntimeAssembly assembly);
    internal static int GetToken(RuntimeAssembly assembly);
    public sealed virtual Type[] GetForwardedTypes();
    private static void AddPublicNestedTypes(Type type, List`1<Type> types, List`1<Exception> exceptions);
    private static void GetForwardedType(RuntimeAssembly assembly, MetadataToken mdtExternalType, ObjectHandleOnStack type);
}
internal class System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
    private RuntimeType modreq(System.Runtime.CompilerServices.IsVolatile) m_declaringType;
    private RuntimeTypeCache m_reflectedTypeCache;
    private string m_toString;
    private ParameterInfo[] m_parameters;
    private object _empty1;
    private object _empty2;
    private object _empty3;
    private IntPtr m_handle;
    private MethodAttributes m_methodAttributes;
    private BindingFlags m_bindingFlags;
    private Signature modreq(System.Runtime.CompilerServices.IsVolatile) m_signature;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    private Signature Signature { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    internal BindingFlags BindingFlags { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeConstructorInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    internal virtual bool CacheEquals(object o);
    private Signature get_Signature();
    private RuntimeType get_ReflectedTypeInternal();
    private void CheckConsistency(object target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    internal virtual Type GetReturnType();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    internal static void CheckCanCreateInstance(Type declaringType, bool isVarArg);
    internal void ThrowNoInvokeException();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodBody GetMethodBody();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
internal class System.Reflection.RuntimeEventInfo : EventInfo {
    private int m_token;
    private EventAttributes m_flags;
    private string m_name;
    private Void* m_utf8name;
    private RuntimeTypeCache m_reflectedTypeCache;
    private RuntimeMethodInfo m_addMethod;
    private RuntimeMethodInfo m_removeMethod;
    private RuntimeMethodInfo m_raiseMethod;
    private MethodInfo[] m_otherMethod;
    private RuntimeType m_declaringType;
    private BindingFlags m_bindingFlags;
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public EventAttributes Attributes { get; }
    internal RuntimeEventInfo(int tkEvent, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    internal virtual bool CacheEquals(object o);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    private RuntimeType get_ReflectedTypeInternal();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual EventAttributes get_Attributes();
}
internal abstract class System.Reflection.RuntimeFieldInfo : FieldInfo {
    private BindingFlags m_bindingFlags;
    protected RuntimeTypeCache m_reflectedTypeCache;
    protected RuntimeType m_declaringType;
    internal BindingFlags BindingFlags { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    protected RuntimeFieldInfo(RuntimeTypeCache reflectedTypeCache, RuntimeType declaringType, BindingFlags bindingFlags);
    internal BindingFlags get_BindingFlags();
    private RuntimeType get_ReflectedTypeInternal();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeType GetRuntimeType();
    internal abstract virtual RuntimeModule GetRuntimeModule();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Module get_Module();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class System.Reflection.RuntimeMethodInfo : MethodInfo {
    private IntPtr m_handle;
    private RuntimeTypeCache m_reflectedTypeCache;
    private string m_name;
    private string m_toString;
    private ParameterInfo[] m_parameters;
    private ParameterInfo m_returnParameter;
    private BindingFlags m_bindingFlags;
    private MethodAttributes m_methodAttributes;
    private Signature m_signature;
    private RuntimeType m_declaringType;
    private object m_keepalive;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    internal int GenericParameterCount { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeMethodInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags, object keepalive);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    private RuntimeType get_ReflectedTypeInternal();
    private ParameterInfo[] FetchNonReturnParameters();
    private ParameterInfo FetchReturnParameter();
    internal virtual string FormatNameAndSig(bool serialization);
    internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal BindingFlags get_BindingFlags();
    internal RuntimeMethodInfo GetParentDefinition();
    internal RuntimeType GetDeclaringTypeInternal();
    internal sealed virtual int get_GenericParameterCount();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodBody GetMethodBody();
    private void CheckConsistency(object target);
    private void ThrowNoInvokeException();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
private Object[] InvokeArgumentsCheck(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    private Delegate CreateDelegateInternal(Type delegateType, object firstArgument, DelegateBindingFlags bindingFlags);
    public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    internal static MethodBase InternalGetCurrentMethod(StackCrawlMark& stackMark);
}
internal class System.Reflection.RuntimeModule : Module {
    private RuntimeType m_runtimeType;
    private RuntimeAssembly m_runtimeAssembly;
    private IntPtr m_pRefClass;
    private IntPtr m_pData;
    private IntPtr m_pGlobals;
    private IntPtr m_pFields;
    public int MDStreamVersion { get; }
    internal RuntimeType RuntimeType { get; }
    internal MetadataImport MetadataImport { get; }
    public string FullyQualifiedName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    private static void GetType(RuntimeModule module, string className, bool throwOnError, bool ignoreCase, ObjectHandleOnStack type, ObjectHandleOnStack keepAlive);
    private static bool nIsTransientInternal(RuntimeModule module);
    private static void GetScopeName(RuntimeModule module, StringHandleOnStack retString);
    private static void GetFullyQualifiedName(RuntimeModule module, StringHandleOnStack retString);
    private static RuntimeType[] GetTypes(RuntimeModule module);
    internal RuntimeType[] GetDefinedTypes();
    private static bool IsResource(RuntimeModule module);
    private static RuntimeTypeHandle[] ConvertToTypeHandleArray(Type[] genericArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    private FieldInfo ResolveLiteralField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal MethodInfo GetMethodInternal(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal RuntimeType get_RuntimeType();
    internal bool IsTransientInternal();
    internal MetadataImport get_MetadataImport();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    internal string GetFullyQualifiedName();
    public virtual string get_FullyQualifiedName();
    public virtual Type[] GetTypes();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    protected virtual ModuleHandle GetModuleHandleImpl();
    internal RuntimeModule GetNativeHandle();
}
internal class System.Reflection.RuntimeParameterInfo : ParameterInfo {
    private static Type s_DecimalConstantAttributeType;
    private static Type s_CustomConstantAttributeType;
    private int m_tkParamDef;
    private MetadataImport m_scope;
    private Signature m_signature;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_nameIsCached;
    private bool m_noMetadata;
    private bool m_noDefaultValue;
    private MethodBase m_originalMember;
    public Type ParameterType { get; }
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int MetadataToken { get; }
    internal RuntimeParameterInfo(RuntimeParameterInfo accessor, RuntimePropertyInfo property);
    private RuntimeParameterInfo(RuntimeParameterInfo accessor, MemberInfo member);
    private RuntimeParameterInfo(Signature signature, MetadataImport scope, int tkParamDef, int position, ParameterAttributes attributes, MemberInfo member);
    internal RuntimeParameterInfo(MethodInfo owner, string name, Type parameterType, int position);
    private static RuntimeParameterInfo();
    internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    internal static ParameterInfo GetReturnParameter(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo& returnParameter, bool fetchReturnParameter);
    internal void SetName(string name);
    internal void SetAttributes(ParameterAttributes attributes);
    public virtual Type get_ParameterType();
    public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    private object GetDefaultValue(bool raw);
    private object GetDefaultValueInternal(bool raw);
    private static decimal GetRawDecimalConstant(CustomAttributeData attr);
    private static DateTime GetRawDateTimeConstant(CustomAttributeData attr);
    private static object GetRawConstant(CustomAttributeData attr);
    internal RuntimeModule GetRuntimeModule();
    public virtual int get_MetadataToken();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class System.Reflection.RuntimePropertyInfo : PropertyInfo {
    private int m_token;
    private string m_name;
    private Void* m_utf8name;
    private PropertyAttributes m_flags;
    private RuntimeTypeCache m_reflectedTypeCache;
    private RuntimeMethodInfo m_getterMethod;
    private RuntimeMethodInfo m_setterMethod;
    private MethodInfo[] m_otherMethod;
    private RuntimeType m_declaringType;
    private BindingFlags m_bindingFlags;
    private Signature m_signature;
    private ParameterInfo[] m_parameters;
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal RuntimePropertyInfo(int tkProperty, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal bool EqualsSig(RuntimePropertyInfo target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    private string FormatNameAndSig(bool serialization);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    private RuntimeType get_ReflectedTypeInternal();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    internal object GetConstantValue(bool raw);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Type get_PropertyType();
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    internal ParameterInfo[] GetIndexParametersNoCopy();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
}
internal class System.Reflection.SignatureArrayType : SignatureHasElementType {
    private int _rank;
    private bool _isMultiDim;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureArrayType(SignatureType elementType, int rank, bool isMultiDim);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureByRefType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureByRefType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureConstructedGenericType : SignatureType {
    private Type _genericTypeDefinition;
    private Type[] _genericTypeArguments;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal SignatureConstructedGenericType(Type genericTypeDefinition, Type[] genericTypeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal class System.Reflection.SignatureGenericMethodParameterType : SignatureGenericParameterType {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public string Name { get; }
    internal SignatureGenericMethodParameterType(int position);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual string get_Name();
}
internal abstract class System.Reflection.SignatureGenericParameterType : SignatureType {
    private int _position;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected SignatureGenericParameterType(int position);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public abstract virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal abstract class System.Reflection.SignatureHasElementType : SignatureType {
    private SignatureType _elementType;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected string Suffix { get; }
    protected SignatureHasElementType(SignatureType elementType);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    protected abstract virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public abstract virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
    protected abstract virtual string get_Suffix();
}
internal class System.Reflection.SignaturePointerType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignaturePointerType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal abstract class System.Reflection.SignatureType : Type {
    public bool IsSignatureType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MemberTypes MemberType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    internal SignatureType ElementType { get; }
    public Type UnderlyingSystemType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type BaseType { get; }
    public int MetadataToken { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public Guid GUID { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsEnum { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public sealed virtual bool get_IsSignatureType();
    public abstract virtual bool get_IsTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    public abstract virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public sealed virtual bool get_IsGenericType();
    public abstract virtual bool get_IsGenericTypeDefinition();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_ContainsGenericParameters();
    public sealed virtual MemberTypes get_MemberType();
    public sealed virtual Type MakeArrayType();
    public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakePointerType();
    public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type GetElementType();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetGenericTypeDefinition();
    public abstract virtual Type[] get_GenericTypeArguments();
    public abstract virtual Type[] GetGenericArguments();
    public abstract virtual int get_GenericParameterPosition();
    internal abstract virtual SignatureType get_ElementType();
    public sealed virtual Type get_UnderlyingSystemType();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public sealed virtual string get_FullName();
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string ToString();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual Type get_BaseType();
    public sealed virtual Type[] GetInterfaces();
    public sealed virtual bool IsAssignableFrom(Type c);
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual bool IsEnumDefined(object value);
    public sealed virtual string GetEnumName(object value);
    public sealed virtual String[] GetEnumNames();
    public sealed virtual Type GetEnumUnderlyingType();
    public sealed virtual Array GetEnumValues();
    public sealed virtual Guid get_GUID();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetDefaultMembers();
    public sealed virtual EventInfo[] GetEvents();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Type GetInterface(string name, bool ignoreCase);
    protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual bool IsCOMObjectImpl();
    protected sealed virtual bool IsPrimitiveImpl();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    protected sealed virtual bool IsContextfulImpl();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool IsEquivalentTo(Type other);
    public sealed virtual bool IsInstanceOfType(object o);
    protected sealed virtual bool IsMarshalByRefImpl();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool IsSubclassOf(Type c);
    protected sealed virtual bool IsValueTypeImpl();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
}
[ExtensionAttribute]
internal static class System.Reflection.SignatureTypeExtensions : object {
    [ExtensionAttribute]
public static bool MatchesParameterTypeExactly(Type pattern, ParameterInfo parameter);
    [ExtensionAttribute]
internal static bool MatchesExactly(SignatureType pattern, Type actual);
    [ExtensionAttribute]
internal static Type TryResolveAgainstGenericMethod(SignatureType signatureType, MethodInfo genericMethod);
    [ExtensionAttribute]
private static Type TryResolve(SignatureType signatureType, Type[] genericMethodParameters);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type, int rank);
    [ExtensionAttribute]
private static Type TryMakeByRefType(Type type);
    [ExtensionAttribute]
private static Type TryMakePointerType(Type type);
    [ExtensionAttribute]
private static Type TryMakeGenericType(Type type, Type[] instantiation);
}
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(FileStream keyPairFile);
    public StrongNameKeyPair(Byte[] keyPairArray);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    protected TargetException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    internal TargetInvocationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    internal TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
}
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsCollectible { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsCollectible();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.TypeInfo : Type {
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<GetDeclaredMethods>d__10")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<get_DeclaredNestedTypes>d__22")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
}
internal class System.ReflectionOnlyType : RuntimeType {
    public RuntimeTypeHandle TypeHandle { get; }
    public virtual RuntimeTypeHandle get_TypeHandle();
}
public class System.ResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal abstract class System.Resolver : object {
    internal abstract virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    internal abstract virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal abstract virtual Byte[] GetLocalsSignature();
    internal abstract virtual void GetEHInfo(int EHNumber, Void* exception);
    internal abstract virtual Byte[] GetRawEHInfo();
    internal abstract virtual string GetStringLiteral(int token);
    internal abstract virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal abstract virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal abstract virtual MethodInfo GetDynamicMethod();
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    private string FindResourceFile(CultureInfo culture, string fileName);
    private ResourceSet CreateResourceSet(string file);
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture);
    internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    private Stream GetManifestResourceStream(RuntimeAssembly satellite, string fileName, StackCrawlMark& stackMark);
    private Stream CaseInsensitiveManifestResourceStreamLookup(RuntimeAssembly satellite, string name);
    private RuntimeAssembly GetSatelliteAssembly(CultureInfo lookForCulture, StackCrawlMark& stackMark);
    private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
    private string GetSatelliteAssemblyName();
    private void HandleSatelliteMissing();
    private void HandleResourceStreamMissing(string fileName);
    internal static bool GetNeutralResourcesLanguageAttribute(RuntimeAssembly assemblyHandle, StringHandleOnStack cultureName, Int16& fallbackLocation);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    private string _cultureName;
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
[AttributeUsageAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private UltimateResourceFallbackLocation <Location>k__BackingField;
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public UltimateResourceFallbackLocation get_Location();
}
internal class System.Resources.ResourceFallbackManager : object {
    private CultureInfo m_startingCulture;
    private CultureInfo m_neutralResourcesCulture;
    private bool m_useParents;
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Resources.ResourceFallbackManager/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
internal class System.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
public class System.Resources.ResourceManager : object {
    protected string BaseNameField;
    [ObsoleteAttribute("call InternalGetResourceSet instead")]
internal Hashtable ResourceSets;
    private Dictionary`2<string, ResourceSet> _resourceSets;
    private string moduleDir;
    protected Assembly MainAssembly;
    private Type _locationInfo;
    private Type _userResourceSet;
    private CultureInfo _neutralResourcesCulture;
    private CultureNameResourceSetPair _lastUsedResourceCache;
    private bool _ignoreCase;
    private bool UseManifest;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _installedSatelliteInfo;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _checkedConfigFile;
    private UltimateResourceFallbackLocation _fallbackLoc;
    private Version _satelliteContractVersion;
    private bool _lookedForSatelliteContractVersion;
    private RuntimeAssembly _callingAssembly;
    private IResourceGroveler resourceGroveler;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    private static Type _minResourceSet;
    internal static string ResReaderTypeName;
    internal static string ResSetTypeName;
    internal static string MscorlibName;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    private ResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    private void Init();
    private void CommonAssemblyInit();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    private ResourceSet InternalGetResourceSet(CultureInfo requestedCulture, bool createIfNotExists, bool tryParents, StackCrawlMark& stackMark);
    private static void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs);
    protected static Version GetSatelliteContractVersion(Assembly a);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2);
    private void SetAppXConfiguration();
    public virtual string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, CultureInfo culture);
    private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream);
    public UnmanagedMemoryStream GetStream(string name);
    public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    private bool TryLookingForSatellite(CultureInfo lookForCulture);
    private Hashtable GetSatelliteAssembliesFromConfig();
}
public class System.Resources.ResourceReader : object {
    private BinaryReader _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    private Int32* _namePositionsPtr;
    private RuntimeType[] _typeTable;
    private Int32[] _typeNamePositions;
    private int _numResources;
    private UnmanagedMemoryStream _ums;
    private int _version;
    public ResourceReader(string fileName);
    public ResourceReader(Stream stream);
    internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static int ReadUnalignedI4(Int32* p);
    private void SkipString();
    private int GetNameHash(int index);
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    private bool CompareStringEqualsName(string name);
    private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    private object _LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private void ReadResources();
    private void _ReadResources();
    private RuntimeType FindType(int typeIndex);
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
}
public class System.Resources.ResourceSet : object {
    protected IResourceReader Reader;
    internal Hashtable Table;
    private Hashtable _caseInsensitiveTable;
    internal ResourceSet(bool junk);
    public ResourceSet(string fileName);
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    private void CommonInit();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private object GetObjectInternal(string name);
    private object GetCaseInsensitiveObjectInternal(string name);
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
internal class System.Resources.RuntimeResourceSet : ResourceSet {
    private Dictionary`2<string, ResourceLocator> _resCache;
    private ResourceReader _defaultReader;
    private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable;
    private bool _haveReadFromReader;
    internal RuntimeResourceSet(string fileName);
    internal RuntimeResourceSet(Stream stream);
    protected virtual void Dispose(bool disposing);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string key);
    public virtual string GetString(string key, bool ignoreCase);
    public virtual object GetObject(string key);
    public virtual object GetObject(string key, bool ignoreCase);
    private object GetObject(string key, bool ignoreCase, bool isString);
    private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<string, ResourceLocator> copyOfCache, bool keyInWrongCase);
}
[AttributeUsageAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
internal class System.Runtime.CompilerServices.ArrayPinningHelper : object {
    public IntPtr m_lengthAndPadding;
    public byte m_arrayData;
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal static class System.Runtime.CompilerServices.AsyncMethodBuilderCore : object {
    internal static bool TrackAsyncMethodCompletion { get; }
    [DebuggerStepThroughAttribute]
public static void Start(TStateMachine& stateMachine);
    internal static bool get_TrackAsyncMethodCompletion();
    internal static string GetAsyncStateMachineDescription(IAsyncStateMachine stateMachine);
    internal static Action CreateContinuationWrapper(Action continuation, Action`2<Action, Task> invokeAction, Task innerTask);
    internal static Action TryGetStateMachineForDebugger(Action action);
    internal static Task TryGetContinuationTask(Action continuation);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
internal static class System.Runtime.CompilerServices.AsyncTaskCache : object {
    internal static Task`1<bool> TrueTask;
    internal static Task`1<bool> FalseTask;
    internal static Task`1[] Int32Tasks;
    private static AsyncTaskCache();
    private static Task`1[] CreateInt32Tasks();
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private static Task`1<VoidTaskResult> s_cachedCompleted;
    private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder;
    public Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder();
    public static AsyncTaskMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task get_Task();
    public void SetResult();
    public void SetException(Exception exception);
    internal object get_ObjectIdForDebugger();
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    internal static Task`1<TResult> s_defaultResultTask;
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder`1();
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    private IAsyncStateMachineBox GetStateMachineBox(TStateMachine& stateMachine);
    public Task`1<TResult> get_Task();
    private Task`1<TResult> InitializeTaskAsPromise();
    private Task`1<TResult> InitializeTaskAsStateMachineBox();
    public void SetResult(TResult result);
    private void SetExistingTaskResult(TResult result);
    private void LogExistingTaskCompletion();
    internal void SetResult(Task`1<TResult> completedTask);
    public void SetException(Exception exception);
    internal object get_ObjectIdForDebugger();
    internal static Task`1<TResult> GetTaskForResult(TResult result);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask Task { get; }
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private AsyncTaskMethodBuilder`1<TResult> _methodBuilder;
    private TResult _result;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask`1<TResult> Task { get; }
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private SynchronizationContext _synchronizationContext;
    private AsyncTaskMethodBuilder _builder;
    private Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    public static AsyncVoidMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    private void NotifySynchronizationContextOfCompletion();
    private Task get_Task();
    internal object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <CompilationRelaxations>k__BackingField;
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    [CompilerGeneratedAttribute]
public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    private object _lock;
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private int _activeEnumeratorRefCount;
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    private TValue GetValueLocked(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public TValue GetOrCreateValue(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CreateEntry(TKey key, TValue value);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable(Task task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1<TResult> value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
public static class System.Runtime.CompilerServices.ContractHelper : object {
    private static EventHandler`1 modreq(System.Runtime.CompilerServices.IsVolatile) contractFailedEvent;
    private static object lockObject;
    private static ContractHelper();
    internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    private static string GetResourceNameForFailure(ContractFailureKind failureKind);
    private static string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText);
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    private DateTime _date;
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    private decimal _dec;
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DependentAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public string get_DependentAssembly();
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
internal class System.Runtime.CompilerServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    public object GetPrimary();
    public object GetPrimaryAndSecondary(Object& secondary);
    public void SetPrimary(object primary);
    public void SetSecondary(object secondary);
    public void Free();
    private static IntPtr nInitialize(object primary, object secondary);
    private static object nGetPrimary(IntPtr dependentHandle);
    private static object nGetPrimaryAndSecondary(IntPtr dependentHandle, Object& secondary);
    private static void nSetPrimary(IntPtr dependentHandle, object primary);
    private static void nSetSecondary(IntPtr dependentHandle, object secondary);
    private static void nFree(IntPtr dependentHandle);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] arguments);
}
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
internal interface System.Runtime.CompilerServices.IAsyncStateMachineBox {
    public Action MoveNextAction { get; }
    public abstract virtual void MoveNext();
    public abstract virtual Action get_MoveNextAction();
    public abstract virtual IAsyncStateMachine GetStateMachineObject();
}
public interface System.Runtime.CompilerServices.ICastable {
    public abstract virtual bool IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    public abstract virtual RuntimeTypeHandle GetImplType(RuntimeTypeHandle interfaceType);
}
internal class System.Runtime.CompilerServices.ICastableHelpers : object {
    internal static bool IsInstanceOfInterface(ICastable castable, RuntimeType type, Exception& castError);
    internal static RuntimeType GetImplType(ICastable castable, RuntimeType interfaceType);
}
internal interface System.Runtime.CompilerServices.IConfiguredTaskAwaiter {
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllInternalsVisible>k__BackingField;
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public bool get_AllInternalsVisible();
    [CompilerGeneratedAttribute]
public void set_AllInternalsVisible(bool value);
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal interface System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter {
    public abstract virtual void AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
internal interface System.Runtime.CompilerServices.ITaskAwaiter {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
[ExtensionAttribute]
internal static class System.Runtime.CompilerServices.JitHelpers : object {
    internal static StringHandleOnStack GetStringHandleOnStack(String& s);
    internal static ObjectHandleOnStack GetObjectHandleOnStack(T& o);
    internal static StackCrawlMarkHandle GetStackCrawlMarkHandle(StackCrawlMark& stackMark);
    internal static int UnsafeEnumCast(T val);
    internal static long UnsafeEnumCastLong(T val);
    internal static IntPtr UnsafeCastToStackPointer(T& val);
    internal static void UnsafeSetArrayElement(Object[] target, int index, object element);
    internal static PinningHelper GetPinningHelper(object o);
    [ExtensionAttribute]
internal static Byte& GetRawSzArrayData(Array array);
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    [CompilerGeneratedAttribute]
private MethodImplOptions <Value>k__BackingField;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    [CompilerGeneratedAttribute]
public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions InternalCall;
}
internal class System.Runtime.CompilerServices.ObjectHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal ObjectHandleOnStack(IntPtr pObject);
}
internal class System.Runtime.CompilerServices.PinningHelper : object {
    public byte m_data;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WrapNonExceptionThrows>k__BackingField;
    public bool WrapNonExceptionThrows { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WrapNonExceptionThrows();
    [CompilerGeneratedAttribute]
public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string PortablePdb;
    public static bool IsSupported(string feature);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    public static object GetUninitializedObject(Type type);
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static object GetObjectValue(object obj);
    private static void _RunClassConstructor(RuntimeType type);
    public static void RunClassConstructor(RuntimeTypeHandle type);
    private static void _RunModuleConstructor(RuntimeModule module);
    public static void RunModuleConstructor(ModuleHandle module);
    internal static void _CompileMethod(IRuntimeMethodInfo method);
    private static void _PrepareMethod(IRuntimeMethodInfo method, IntPtr* pInstantiation, int cInstantiation);
    public static void PrepareMethod(RuntimeMethodHandle method);
    public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareDelegate(Delegate d);
    public static int GetHashCode(object o);
    public static bool Equals(object o1, object o2);
    [NonVersionableAttribute]
public static int get_OffsetToStringData();
    public static void EnsureSufficientExecutionStack();
    public static bool TryEnsureSufficientExecutionStack();
    public static void ProbeForSufficientStack();
    public static void PrepareConstrainedRegions();
    public static void PrepareConstrainedRegionsNoOP();
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    internal static void ExecuteBackoutCodeHelper(object backoutCode, object userData, bool exceptionThrown);
    public static bool IsReferenceOrContainsReferences();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    private object _wrappedException;
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    private RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StackCrawlMarkHandle : ValueType {
    private IntPtr m_ptr;
    internal StackCrawlMarkHandle(IntPtr stackMark);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <StateMachineType>k__BackingField;
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StringHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal StringHandleOnStack(IntPtr pString);
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    internal Task m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter(Task task);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public void GetResult();
    [StackTraceHiddenAttribute]
internal static void ValidateEnd(Task task);
    [StackTraceHiddenAttribute]
private static void HandleNonSuccessAndDebuggerNotification(Task task);
    [StackTraceHiddenAttribute]
private static void ThrowForNonSuccess(Task task);
    internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
    internal static void UnsafeOnCompletedInternal(Task task, IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext);
    private static Action OutputWaitEtwEvents(Task task, Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter`1(Task`1<TResult> task);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public TResult GetResult();
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("11148")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("1036")]
internal class System.Runtime.CompilerServices.TypeDependencyAttribute : Attribute {
    private string typeName;
    public TypeDependencyAttribute(string typeName);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Destination>k__BackingField;
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    [CompilerGeneratedAttribute]
public Type get_Destination();
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    internal static Action`1<object> s_invokeAsyncStateMachineBox;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    private sealed virtual override void System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1<TResult> value);
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    private sealed virtual override void System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Consistency <ConsistencyGuarantee>k__BackingField;
    [CompilerGeneratedAttribute]
private Cer <Cer>k__BackingField;
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    [CompilerGeneratedAttribute]
public Consistency get_ConsistencyGuarantee();
    [CompilerGeneratedAttribute]
public Cer get_Cer();
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    private Exception m_Exception;
    private string m_remoteStackTrace;
    private object m_stackTrace;
    private object m_dynamicMethods;
    private UIntPtr m_IPForWatsonBuckets;
    private object m_WatsonBuckets;
    internal UIntPtr IPForWatsonBuckets { get; }
    internal object WatsonBuckets { get; }
    internal object BinaryStackTraceArray { get; }
    internal object DynamicMethodArray { get; }
    internal string RemoteStackTrace { get; }
    public Exception SourceException { get; }
    private ExceptionDispatchInfo(Exception exception);
    internal UIntPtr get_IPForWatsonBuckets();
    internal object get_WatsonBuckets();
    internal object get_BinaryStackTraceArray();
    internal object get_DynamicMethodArray();
    internal string get_RemoteStackTrace();
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    [StackTraceHiddenAttribute]
public void Throw();
    public static void Throw(Exception source);
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static bool IsServerGC { get; }
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
    public static bool get_IsServerGC();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private object m_array;
    private int m_offset;
    private int m_count;
    public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
    private int CalculateCount();
}
[AttributeUsageAttribute("1037")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <BestFitMapping>k__BackingField;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    [CompilerGeneratedAttribute]
public bool get_BestFitMapping();
}
public class System.Runtime.InteropServices.BStrWrapper : object {
    private string m_WrappedObject;
    public string WrappedObject { get; }
    public BStrWrapper(string value);
    public BStrWrapper(object value);
    public string get_WrappedObject();
}
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    internal ClassInterfaceType _val;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    public ClassInterfaceType get_Value();
}
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    internal Type _CoClass;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    public Type get_CoClass();
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    internal Type _val;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    public Type get_Value();
}
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.COMException : ExternalException {
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    protected COMException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
}
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    public static ComInterfaceType InterfaceIsIInspectable;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    public string get_Value();
}
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    [CompilerGeneratedAttribute]
public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private bool _isClosed;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    protected virtual override void Finalize();
    private void Cleanup();
    private void FireCustomerDebugProbe();
    protected void SetHandle(IntPtr handle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    private decimal m_WrappedObject;
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    public CurrencyWrapper(object obj);
    public decimal get_WrappedObject();
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CharSet <CharSet>k__BackingField;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    [CompilerGeneratedAttribute]
public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DllImportSearchPath <Paths>k__BackingField;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    [CompilerGeneratedAttribute]
public DllImportSearchPath get_Paths();
}
public class System.Runtime.InteropServices.DispatchWrapper : object {
    public object WrappedObject { get; }
    public DispatchWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    public int get_Value();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool PreserveSig;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    public DllImportAttribute(string dllName);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
public class System.Runtime.InteropServices.ErrorWrapper : object {
    private int m_ErrorCode;
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public ErrorWrapper(Exception e);
    public int get_ErrorCode();
}
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.Expando.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    [CompilerGeneratedAttribute]
public int get_Value();
}
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private IntPtr m_handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    internal GCHandle(object value, GCHandleType type);
    internal GCHandle(IntPtr handle);
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public void Free();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public bool get_IsAllocated();
    public static GCHandle op_Explicit(IntPtr value);
    public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static IntPtr ToIntPtr(GCHandle value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    internal IntPtr GetHandleValue();
    private static IntPtr GetHandleValue(IntPtr handle);
    internal bool IsPinned();
    internal static IntPtr InternalAlloc(object value, GCHandleType type);
    internal static void InternalFree(IntPtr handle);
    internal static object InternalGet(IntPtr handle);
    internal static void InternalSet(IntPtr handle, object value, bool isPinned);
    internal static object InternalCompareExchange(IntPtr handle, object value, object oldValue, bool isPinned);
    internal static IntPtr InternalAddrOfPinnedObject(IntPtr handle);
    private void ValidateHandle();
    private static void ValidateHandle(IntPtr handle);
    private static void ThrowArgumentOutOfRangeException_ArgumentOutOfRange_Enum();
    private static void ThrowInvalidOperationException_HandleIsNotInitialized();
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("5149")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public GuidAttribute(string guid);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Runtime.InteropServices.HandleRef : ValueType {
    private object _wrapper;
    private IntPtr _handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    internal ComInterfaceType _val;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    public ComInterfaceType get_Value();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    public int get_Value();
}
public static class System.Runtime.InteropServices.Marshal : object {
    public static int SystemDefaultCharSize;
    public static int SystemMaxDBCSCharSize;
    private static Marshal();
    private static bool IsWin32Atom(IntPtr ptr);
    private static bool IsNotWin32Atom(IntPtr ptr);
    private static int GetSystemMaxDBCSCharSize();
    public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringAuto(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringAuto(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    public static int SizeOf(object structure);
    public static int SizeOf(T structure);
    public static int SizeOf(Type t);
    public static int SizeOf();
    internal static int SizeOfHelper(Type t, bool throwIfNotMarshalable);
    public static IntPtr OffsetOf(Type t, string fieldName);
    public static IntPtr OffsetOf(string fieldName);
    private static IntPtr OffsetOfHelper(IRuntimeFieldInfo f);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    private static void CopyToNative(object source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    private static void CopyToManaged(IntPtr source, object destination, int startIndex, int length);
    public static byte ReadByte(object ptr, int ofs);
    public static byte ReadByte(IntPtr ptr, int ofs);
    public static byte ReadByte(IntPtr ptr);
    public static short ReadInt16(object ptr, int ofs);
    public static short ReadInt16(IntPtr ptr, int ofs);
    public static short ReadInt16(IntPtr ptr);
    public static int ReadInt32(object ptr, int ofs);
    public static int ReadInt32(IntPtr ptr, int ofs);
    public static int ReadInt32(IntPtr ptr);
    public static IntPtr ReadIntPtr(object ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr);
    public static long ReadInt64(object ptr, int ofs);
    public static long ReadInt64(IntPtr ptr, int ofs);
    public static long ReadInt64(IntPtr ptr);
    private static T ReadValueSlow(object ptr, int ofs, Func`3<IntPtr, int, T> readValueHelper);
    public static void WriteByte(IntPtr ptr, int ofs, byte val);
    public static void WriteByte(object ptr, int ofs, byte val);
    public static void WriteByte(IntPtr ptr, byte val);
    public static void WriteInt16(IntPtr ptr, int ofs, short val);
    public static void WriteInt16(object ptr, int ofs, short val);
    public static void WriteInt16(IntPtr ptr, short val);
    public static void WriteInt16(IntPtr ptr, int ofs, char val);
    public static void WriteInt16(object ptr, int ofs, char val);
    public static void WriteInt16(IntPtr ptr, char val);
    public static void WriteInt32(IntPtr ptr, int ofs, int val);
    public static void WriteInt32(object ptr, int ofs, int val);
    public static void WriteInt32(IntPtr ptr, int val);
    public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    public static void WriteInt64(IntPtr ptr, int ofs, long val);
    public static void WriteInt64(object ptr, int ofs, long val);
    public static void WriteInt64(IntPtr ptr, long val);
    private static void WriteValueSlow(object ptr, int ofs, T val, Action`3<IntPtr, int, T> writeValueHelper);
    public static int GetLastWin32Error();
    internal static void SetLastWin32Error(int error);
    public static int GetHRForLastWin32Error();
    public static void Prelink(MethodInfo m);
    private static void InternalPrelink(IRuntimeMethodInfo m);
    public static void PrelinkAll(Type c);
    public static IntPtr GetExceptionPointers();
    public static int GetExceptionCode();
    [ReliabilityContractAttribute("3", "1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    public static void PtrToStructure(IntPtr ptr, object structure);
    public static void PtrToStructure(IntPtr ptr, T structure);
    public static object PtrToStructure(IntPtr ptr, Type structureType);
    public static T PtrToStructure(IntPtr ptr);
    private static void PtrToStructureHelper(IntPtr ptr, object structure, bool allowValueClasses);
    public static void DestroyStructure(IntPtr ptr, Type structuretype);
    public static void DestroyStructure(IntPtr ptr);
    public static void ThrowExceptionForHR(int errorCode);
    public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    internal static void ThrowExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    public static Exception GetExceptionForHR(int errorCode);
    public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    internal static Exception GetExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static IntPtr AllocHGlobal(int cb);
    public static void FreeHGlobal(IntPtr hglobal);
    public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    public static IntPtr StringToHGlobalAnsi(string s);
    public static IntPtr StringToHGlobalUni(string s);
    public static IntPtr StringToHGlobalAuto(string s);
    public static IntPtr GetIDispatchForObject(object o);
    public static IntPtr AllocCoTaskMem(int cb);
    public static IntPtr StringToCoTaskMemUni(string s);
    public static IntPtr StringToCoTaskMemUTF8(string s);
    public static IntPtr StringToCoTaskMemAuto(string s);
    public static IntPtr StringToCoTaskMemAnsi(string s);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    public static void FreeBSTR(IntPtr ptr);
    public static IntPtr StringToBSTR(string s);
    public static string PtrToStringBSTR(IntPtr ptr);
    public static object GetComObjectData(object obj, object key);
    public static bool SetComObjectData(object obj, object key, object data);
    public static Guid GenerateGuidForType(Type type);
    public static string GenerateProgIdForType(Type type);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    internal static Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t);
    public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    internal static IntPtr GetFunctionPointerForDelegateInternal(Delegate d);
    public static IntPtr SecureStringToBSTR(SecureString s);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static void ZeroFreeBSTR(IntPtr s);
    public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
    public static int GetHRForException(Exception e);
    public static int AddRef(IntPtr pUnk);
    public static bool AreComObjectsAvailableForCleanup();
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    public static object BindToMoniker(string monikerName);
    public static void CleanupUnusedObjectsInCurrentContext();
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    public static object CreateWrapperOfType(object o, Type t);
    public static TWrapper CreateWrapperOfType(T o);
    public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    public static int FinalReleaseComObject(object o);
    public static IntPtr GetComInterfaceForObject(object o, Type T);
    public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    public static IntPtr GetComInterfaceForObject(T o);
    public static IntPtr GetHINSTANCE(Module m);
    public static IntPtr GetIUnknownForObject(object o);
    public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static int GetStartComSlot(Type t);
    public static Type GetTypeFromCLSID(Guid clsid);
    public static string GetTypeInfoName(ITypeInfo typeInfo);
    public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    public static bool IsComObject(object o);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int Release(IntPtr pUnk);
    public static int ReleaseComObject(object o);
}
[AttributeUsageAttribute("10496")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UnmanagedType <Value>k__BackingField;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int IidParameterIndex;
    public UnmanagedType ArraySubType;
    public short SizeParamIndex;
    public int SizeConst;
    public string MarshalType;
    public Type MarshalTypeRef;
    public string MarshalCookie;
    public UnmanagedType Value { get; }
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public MarshalAsAttribute(short unmanagedType);
    [CompilerGeneratedAttribute]
public UnmanagedType get_Value();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static T& GetReference(Span`1<T> span);
    public static T& GetReference(ReadOnlySpan`1<T> span);
    internal static T& GetNonNullPinnableReference(Span`1<T> span);
    internal static T& GetNonNullPinnableReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    public static Span`1<T> CreateSpan(T& reference, int length);
    public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
    public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__14`1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
    public CallingConvention CallingConvention;
    public string EntryPoint;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
internal static class System.Runtime.InteropServices.PInvokeMarshal : object {
    public static IntPtr AllocBSTR(int length);
    public static void FreeBSTR(IntPtr ptr);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    public string get_Value();
}
internal static class System.Runtime.InteropServices.RuntimeEnvironment : object {
    internal static string GetModuleFileName();
    public static string GetSystemVersion();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    private static UIntPtr Uninitialized;
    private UIntPtr _numBytes;
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static SafeBuffer();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    public ulong get_ByteLength();
    private void SpaceCheck(Byte* ptr, ulong sizeInBytes);
    private static void NotEnoughRoom();
    private static InvalidOperationException NotInitialized();
    internal static UInt32 AlignedSizeOf();
    internal static UInt32 SizeOf();
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private int _state;
    private bool _ownsHandle;
    private bool _fullyInitialized;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual override void Finalize();
    private void InternalFinalize();
    protected void SetHandle(IntPtr handle);
    public IntPtr DangerousGetHandle();
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void InternalDispose();
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
    public void DangerousAddRef(Boolean& success);
    public void DangerousRelease();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LayoutKind <Value>k__BackingField;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    [CompilerGeneratedAttribute]
public LayoutKind get_Value();
}
[AttributeUsageAttribute("5144")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    internal string Scope_;
    internal string Identifier_;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    public string get_Scope();
    public string get_Identifier();
}
public class System.Runtime.InteropServices.UnknownWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CallingConvention <CallingConvention>k__BackingField;
    public bool BestFitMapping;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public CharSet CharSet;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public CallingConvention get_CallingConvention();
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    public static UnmanagedType IDispatch;
    public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    public static UnmanagedType VBByRefStr;
    public static UnmanagedType AnsiBStr;
    public static UnmanagedType TBStr;
    public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType IInspectable;
    public static UnmanagedType HString;
    public static UnmanagedType LPUTF8Str;
}
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
public class System.Runtime.InteropServices.VariantWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    public object get_WrappedObject();
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Aes : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> MixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Base : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static int LeadingSignCount(int value);
    public static int LeadingSignCount(long value);
    public static int LeadingZeroCount(int value);
    public static int LeadingZeroCount(UInt32 value);
    public static int LeadingZeroCount(long value);
    public static int LeadingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Sha1 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashChoose(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashMajority(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashParity(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static UInt32 FixedRotate(UInt32 hash_e);
    public static Vector128`1<UInt32> SchedulePart1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7, Vector128`1<UInt32> w8_11);
    public static Vector128`1<UInt32> SchedulePart2(Vector128`1<UInt32> tw0_3, Vector128`1<UInt32> w12_15);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Sha256 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashLower(Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashUpper(Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> SchedulePart1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7);
    public static Vector128`1<UInt32> SchedulePart2(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w8_11, Vector128`1<UInt32> w12_15);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Simd : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector64`1<byte> Abs(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> Abs(Vector64`1<short> value);
    public static Vector64`1<UInt32> Abs(Vector64`1<int> value);
    public static Vector64`1<float> Abs(Vector64`1<float> value);
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<ulong> Abs(Vector128`1<long> value);
    public static Vector128`1<float> Abs(Vector128`1<float> value);
    public static Vector128`1<double> Abs(Vector128`1<double> value);
    public static Vector64`1<T> Add(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Add(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> And(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> And(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> AndNot(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> AndNot(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> BitwiseSelect(Vector64`1<T> sel, Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> BitwiseSelect(Vector128`1<T> sel, Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareEqual(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareEqual(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareGreaterThan(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareGreaterThan(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareGreaterThanZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareGreaterThanZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareGreaterThanOrEqual(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareGreaterThanOrEqual(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareGreaterThanOrEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareGreaterThanOrEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareLessThanZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareLessThanZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareLessThanOrEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareLessThanOrEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareTest(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareTest(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<float> Divide(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static T Extract(Vector64`1<T> vector, byte index);
    public static T Extract(Vector128`1<T> vector, byte index);
    public static Vector64`1<T> Insert(Vector64`1<T> vector, byte index, T data);
    public static Vector128`1<T> Insert(Vector128`1<T> vector, byte index, T data);
    public static Vector64`1<sbyte> LeadingSignCount(Vector64`1<sbyte> value);
    public static Vector64`1<short> LeadingSignCount(Vector64`1<short> value);
    public static Vector64`1<int> LeadingSignCount(Vector64`1<int> value);
    public static Vector128`1<sbyte> LeadingSignCount(Vector128`1<sbyte> value);
    public static Vector128`1<short> LeadingSignCount(Vector128`1<short> value);
    public static Vector128`1<int> LeadingSignCount(Vector128`1<int> value);
    public static Vector64`1<byte> LeadingZeroCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> LeadingZeroCount(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> LeadingZeroCount(Vector64`1<ushort> value);
    public static Vector64`1<short> LeadingZeroCount(Vector64`1<short> value);
    public static Vector64`1<UInt32> LeadingZeroCount(Vector64`1<UInt32> value);
    public static Vector64`1<int> LeadingZeroCount(Vector64`1<int> value);
    public static Vector128`1<byte> LeadingZeroCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> LeadingZeroCount(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> LeadingZeroCount(Vector128`1<ushort> value);
    public static Vector128`1<short> LeadingZeroCount(Vector128`1<short> value);
    public static Vector128`1<UInt32> LeadingZeroCount(Vector128`1<UInt32> value);
    public static Vector128`1<int> LeadingZeroCount(Vector128`1<int> value);
    public static Vector64`1<byte> Max(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Max(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Max(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Max(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Max(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Max(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Max(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<byte> Min(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Min(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Min(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Min(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Min(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Min(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Min(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<byte> Multiply(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Multiply(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Multiply(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Multiply(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Multiply(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Multiply(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Multiply(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Multiply(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Multiply(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Multiply(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Multiply(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<sbyte> Negate(Vector64`1<sbyte> value);
    public static Vector64`1<short> Negate(Vector64`1<short> value);
    public static Vector64`1<int> Negate(Vector64`1<int> value);
    public static Vector64`1<float> Negate(Vector64`1<float> value);
    public static Vector128`1<sbyte> Negate(Vector128`1<sbyte> value);
    public static Vector128`1<short> Negate(Vector128`1<short> value);
    public static Vector128`1<int> Negate(Vector128`1<int> value);
    public static Vector128`1<long> Negate(Vector128`1<long> value);
    public static Vector128`1<float> Negate(Vector128`1<float> value);
    public static Vector128`1<double> Negate(Vector128`1<double> value);
    public static Vector64`1<T> Not(Vector64`1<T> value);
    public static Vector128`1<T> Not(Vector128`1<T> value);
    public static Vector64`1<T> Or(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Or(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> OrNot(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> OrNot(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<byte> PopCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> PopCount(Vector64`1<sbyte> value);
    public static Vector128`1<byte> PopCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> PopCount(Vector128`1<sbyte> value);
    public static Vector64`1<T> SetAllVector64(T value);
    public static Vector128`1<T> SetAllVector128(T value);
    public static Vector64`1<float> Sqrt(Vector64`1<float> value);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector64`1<T> Subtract(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Subtract(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> Xor(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Xor(Vector128`1<T> left, Vector128`1<T> right);
}
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[IntrinsicAttribute]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector128DebugView`1")]
public class System.Runtime.Intrinsics.Vector128`1 : ValueType {
    private ulong _00;
    private ulong _01;
    private string DisplayString { get; }
    private string get_DisplayString();
}
internal class System.Runtime.Intrinsics.Vector128DebugView`1 : ValueType {
    private Vector128`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector128DebugView`1(Vector128`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[IntrinsicAttribute]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector256DebugView`1")]
public class System.Runtime.Intrinsics.Vector256`1 : ValueType {
    private ulong _00;
    private ulong _01;
    private ulong _02;
    private ulong _03;
    private string DisplayString { get; }
    private string get_DisplayString();
}
internal class System.Runtime.Intrinsics.Vector256DebugView`1 : ValueType {
    private Vector256`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector256DebugView`1(Vector256`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector64DebugView`1")]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[IntrinsicAttribute]
public class System.Runtime.Intrinsics.Vector64`1 : ValueType {
    private ulong _00;
    private string DisplayString { get; }
    private string get_DisplayString();
}
internal class System.Runtime.Intrinsics.Vector64DebugView`1 : ValueType {
    private Vector64`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector64DebugView`1(Vector64`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Aes : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<sbyte> Decrypt(Vector128`1<sbyte> value, Vector128`1<sbyte> roundKey);
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<sbyte> DecryptLast(Vector128`1<sbyte> value, Vector128`1<sbyte> roundKey);
    public static Vector128`1<byte> DecryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<sbyte> Encrypt(Vector128`1<sbyte> value, Vector128`1<sbyte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<sbyte> EncryptLast(Vector128`1<sbyte> value, Vector128`1<sbyte> roundKey);
    public static Vector128`1<byte> EncryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<sbyte> InvisibleMixColumn(Vector128`1<sbyte> value);
    public static Vector128`1<byte> InvisibleMixColumn(Vector128`1<byte> value);
    public static Vector128`1<sbyte> KeygenAssist(Vector128`1<sbyte> value, byte control);
    public static Vector128`1<byte> KeygenAssist(Vector128`1<byte> value, byte control);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Avx : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector256`1<float> Add(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Add(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AddSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AddSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> And(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> And(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AndNot(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AndNot(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Blend(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Blend(Vector256`1<double> left, Vector256`1<double> right, byte control);
    public static Vector256`1<float> BlendVariable(Vector256`1<float> left, Vector256`1<float> right, Vector256`1<float> mask);
    public static Vector256`1<double> BlendVariable(Vector256`1<double> left, Vector256`1<double> right, Vector256`1<double> mask);
    public static Vector128`1<float> BroadcastScalarToVector128(Single* source);
    public static Vector256`1<float> BroadcastScalarToVector256(Single* source);
    public static Vector256`1<double> BroadcastScalarToVector256(Double* source);
    public static Vector256`1<float> BroadcastVector128ToVector256(Single* address);
    public static Vector256`1<double> BroadcastVector128ToVector256(Double* address);
    public static Vector256`1<float> Ceiling(Vector256`1<float> value);
    public static Vector256`1<double> Ceiling(Vector256`1<double> value);
    public static Vector128`1<float> Compare(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static Vector128`1<double> Compare(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector256`1<float> Compare(Vector256`1<float> left, Vector256`1<float> right, FloatComparisonMode mode);
    public static Vector256`1<double> Compare(Vector256`1<double> left, Vector256`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<double> CompareScalar(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<float> CompareScalar(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static float ConvertToSingle(Vector256`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector256`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector256`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector256`1<float> value);
    public static Vector256`1<float> ConvertToVector256Single(Vector256`1<int> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<float> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<int> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector256`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32WithTruncation(Vector256`1<float> value);
    public static Vector256`1<float> Divide(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Divide(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> DotProduct(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<float> DuplicateEvenIndexed(Vector256`1<float> value);
    public static Vector256`1<double> DuplicateEvenIndexed(Vector256`1<double> value);
    public static Vector256`1<float> DuplicateOddIndexed(Vector256`1<float> value);
    public static sbyte Extract(Vector256`1<sbyte> value, byte index);
    public static byte Extract(Vector256`1<byte> value, byte index);
    public static short Extract(Vector256`1<short> value, byte index);
    public static ushort Extract(Vector256`1<ushort> value, byte index);
    public static int Extract(Vector256`1<int> value, byte index);
    public static UInt32 Extract(Vector256`1<UInt32> value, byte index);
    public static long Extract(Vector256`1<long> value, byte index);
    public static ulong Extract(Vector256`1<ulong> value, byte index);
    public static Vector128`1<T> ExtractVector128(Vector256`1<T> value, byte index);
    public static void ExtractVector128(Byte* address, Vector256`1<byte> value, byte index);
    public static void ExtractVector128(SByte* address, Vector256`1<sbyte> value, byte index);
    public static void ExtractVector128(Int16* address, Vector256`1<short> value, byte index);
    public static void ExtractVector128(UInt16* address, Vector256`1<ushort> value, byte index);
    public static void ExtractVector128(Int32* address, Vector256`1<int> value, byte index);
    public static void ExtractVector128(UInt32* address, Vector256`1<UInt32> value, byte index);
    public static void ExtractVector128(Int64* address, Vector256`1<long> value, byte index);
    public static void ExtractVector128(UInt64* address, Vector256`1<ulong> value, byte index);
    public static void ExtractVector128(Single* address, Vector256`1<float> value, byte index);
    public static void ExtractVector128(Double* address, Vector256`1<double> value, byte index);
    public static Vector256`1<T> ExtendToVector256(Vector128`1<T> value);
    public static Vector256`1<float> Floor(Vector256`1<float> value);
    public static Vector256`1<double> Floor(Vector256`1<double> value);
    public static Vector128`1<T> GetLowerHalf(Vector256`1<T> value);
    public static Vector256`1<float> HorizontalAdd(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalAdd(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> HorizontalSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<sbyte> Insert(Vector256`1<sbyte> value, sbyte data, byte index);
    public static Vector256`1<byte> Insert(Vector256`1<byte> value, byte data, byte index);
    public static Vector256`1<short> Insert(Vector256`1<short> value, short data, byte index);
    public static Vector256`1<ushort> Insert(Vector256`1<ushort> value, ushort data, byte index);
    public static Vector256`1<int> Insert(Vector256`1<int> value, int data, byte index);
    public static Vector256`1<UInt32> Insert(Vector256`1<UInt32> value, UInt32 data, byte index);
    public static Vector256`1<long> Insert(Vector256`1<long> value, long data, byte index);
    public static Vector256`1<ulong> Insert(Vector256`1<ulong> value, ulong data, byte index);
    public static Vector256`1<T> InsertVector128(Vector256`1<T> value, Vector128`1<T> data, byte index);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, SByte* address, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Byte* address, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Int16* address, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, UInt16* address, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Int32* address, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, UInt32* address, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Int64* address, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, UInt64* address, byte index);
    public static Vector256`1<float> InsertVector128(Vector256`1<float> value, Single* address, byte index);
    public static Vector256`1<double> InsertVector128(Vector256`1<double> value, Double* address, byte index);
    public static Vector256`1<sbyte> LoadVector256(SByte* address);
    public static Vector256`1<byte> LoadVector256(Byte* address);
    public static Vector256`1<short> LoadVector256(Int16* address);
    public static Vector256`1<ushort> LoadVector256(UInt16* address);
    public static Vector256`1<int> LoadVector256(Int32* address);
    public static Vector256`1<UInt32> LoadVector256(UInt32* address);
    public static Vector256`1<long> LoadVector256(Int64* address);
    public static Vector256`1<ulong> LoadVector256(UInt64* address);
    public static Vector256`1<float> LoadVector256(Single* address);
    public static Vector256`1<double> LoadVector256(Double* address);
    public static Vector256`1<sbyte> LoadAlignedVector256(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256(UInt64* address);
    public static Vector256`1<float> LoadAlignedVector256(Single* address);
    public static Vector256`1<double> LoadAlignedVector256(Double* address);
    public static Vector256`1<sbyte> LoadDquVector256(SByte* address);
    public static Vector256`1<byte> LoadDquVector256(Byte* address);
    public static Vector256`1<short> LoadDquVector256(Int16* address);
    public static Vector256`1<ushort> LoadDquVector256(UInt16* address);
    public static Vector256`1<int> LoadDquVector256(Int32* address);
    public static Vector256`1<UInt32> LoadDquVector256(UInt32* address);
    public static Vector256`1<long> LoadDquVector256(Int64* address);
    public static Vector256`1<ulong> LoadDquVector256(UInt64* address);
    public static Vector128`1<float> MaskLoad(Single* address, Vector128`1<UInt32> mask);
    public static Vector128`1<double> MaskLoad(Double* address, Vector128`1<ulong> mask);
    public static Vector256`1<float> MaskLoad(Single* address, Vector256`1<UInt32> mask);
    public static Vector256`1<double> MaskLoad(Double* address, Vector256`1<ulong> mask);
    public static void MaskStore(Single* address, Vector128`1<float> mask, Vector128`1<UInt32> source);
    public static void MaskStore(Double* address, Vector128`1<double> mask, Vector128`1<ulong> source);
    public static void MaskStore(Single* address, Vector256`1<float> mask, Vector256`1<UInt32> source);
    public static void MaskStore(Double* address, Vector256`1<double> mask, Vector256`1<ulong> source);
    public static Vector256`1<float> Max(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Max(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Min(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Min(Vector256`1<double> left, Vector256`1<double> right);
    public static int MoveMask(Vector256`1<float> value);
    public static int MoveMask(Vector256`1<double> value);
    public static Vector256`1<float> Multiply(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Multiply(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Or(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Or(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector128`1<float> Permute(Vector128`1<float> value, byte control);
    public static Vector128`1<double> Permute(Vector128`1<double> value, byte control);
    public static Vector256`1<float> Permute(Vector256`1<float> value, byte control);
    public static Vector256`1<double> Permute(Vector256`1<double> value, byte control);
    public static Vector256`1<T> Permute2x128(Vector256`1<T> left, Vector256`1<T> right, byte control);
    public static Vector128`1<float> PermuteVar(Vector128`1<float> left, Vector128`1<float> mask);
    public static Vector128`1<double> PermuteVar(Vector128`1<double> left, Vector128`1<double> mask);
    public static Vector256`1<float> PermuteVar(Vector256`1<float> left, Vector256`1<float> mask);
    public static Vector256`1<double> PermuteVar(Vector256`1<double> left, Vector256`1<double> mask);
    public static Vector256`1<float> Reciprocal(Vector256`1<float> value);
    public static Vector256`1<float> ReciprocalSqrt(Vector256`1<float> value);
    public static Vector256`1<float> RoundToNearestInteger(Vector256`1<float> value);
    public static Vector256`1<float> RoundToNegativeInfinity(Vector256`1<float> value);
    public static Vector256`1<float> RoundToPositiveInfinity(Vector256`1<float> value);
    public static Vector256`1<float> RoundToZero(Vector256`1<float> value);
    public static Vector256`1<float> RoundCurrentDirection(Vector256`1<float> value);
    public static Vector256`1<double> RoundToNearestInteger(Vector256`1<double> value);
    public static Vector256`1<double> RoundToNegativeInfinity(Vector256`1<double> value);
    public static Vector256`1<double> RoundToPositiveInfinity(Vector256`1<double> value);
    public static Vector256`1<double> RoundToZero(Vector256`1<double> value);
    public static Vector256`1<double> RoundCurrentDirection(Vector256`1<double> value);
    public static Vector256`1<sbyte> SetVector256(sbyte e31, sbyte e30, sbyte e29, sbyte e28, sbyte e27, sbyte e26, sbyte e25, sbyte e24, sbyte e23, sbyte e22, sbyte e21, sbyte e20, sbyte e19, sbyte e18, sbyte e17, sbyte e16, sbyte e15, sbyte e14, sbyte e13, sbyte e12, sbyte e11, sbyte e10, sbyte e9, sbyte e8, sbyte e7, sbyte e6, sbyte e5, sbyte e4, sbyte e3, sbyte e2, sbyte e1, sbyte e0);
    public static Vector256`1<byte> SetVector256(byte e31, byte e30, byte e29, byte e28, byte e27, byte e26, byte e25, byte e24, byte e23, byte e22, byte e21, byte e20, byte e19, byte e18, byte e17, byte e16, byte e15, byte e14, byte e13, byte e12, byte e11, byte e10, byte e9, byte e8, byte e7, byte e6, byte e5, byte e4, byte e3, byte e2, byte e1, byte e0);
    public static Vector256`1<short> SetVector256(short e15, short e14, short e13, short e12, short e11, short e10, short e9, short e8, short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0);
    public static Vector256`1<ushort> SetVector256(ushort e15, ushort e14, ushort e13, ushort e12, ushort e11, ushort e10, ushort e9, ushort e8, ushort e7, ushort e6, ushort e5, ushort e4, ushort e3, ushort e2, ushort e1, ushort e0);
    public static Vector256`1<int> SetVector256(int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0);
    public static Vector256`1<UInt32> SetVector256(UInt32 e7, UInt32 e6, UInt32 e5, UInt32 e4, UInt32 e3, UInt32 e2, UInt32 e1, UInt32 e0);
    public static Vector256`1<long> SetVector256(long e3, long e2, long e1, long e0);
    public static Vector256`1<ulong> SetVector256(ulong e3, ulong e2, ulong e1, ulong e0);
    public static Vector256`1<float> SetVector256(float e7, float e6, float e5, float e4, float e3, float e2, float e1, float e0);
    public static Vector256`1<double> SetVector256(double e3, double e2, double e1, double e0);
    public static Vector256`1<T> SetAllVector256(T value);
    public static Vector256`1<T> SetHighLow(Vector128`1<T> hi, Vector128`1<T> lo);
    public static Vector256`1<T> SetZeroVector256();
    public static Vector256`1<float> Shuffle(Vector256`1<float> value, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Shuffle(Vector256`1<double> value, Vector256`1<double> right, byte control);
    public static Vector256`1<float> Sqrt(Vector256`1<float> value);
    public static Vector256`1<double> Sqrt(Vector256`1<double> value);
    public static Vector256`1<U> StaticCast(Vector256`1<T> value);
    public static void StoreAligned(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector256`1<byte> source);
    public static void StoreAligned(Int16* address, Vector256`1<short> source);
    public static void StoreAligned(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector256`1<int> source);
    public static void StoreAligned(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector256`1<long> source);
    public static void StoreAligned(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAligned(Single* address, Vector256`1<float> source);
    public static void StoreAligned(Double* address, Vector256`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector256`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector256`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector256`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector256`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector256`1<float> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector256`1<double> source);
    public static void Store(SByte* address, Vector256`1<sbyte> source);
    public static void Store(Byte* address, Vector256`1<byte> source);
    public static void Store(Int16* address, Vector256`1<short> source);
    public static void Store(UInt16* address, Vector256`1<ushort> source);
    public static void Store(Int32* address, Vector256`1<int> source);
    public static void Store(UInt32* address, Vector256`1<UInt32> source);
    public static void Store(Int64* address, Vector256`1<long> source);
    public static void Store(UInt64* address, Vector256`1<ulong> source);
    public static void Store(Single* address, Vector256`1<float> source);
    public static void Store(Double* address, Vector256`1<double> source);
    public static Vector256`1<float> Subtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Subtract(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestC(Vector256`1<T> left, Vector256`1<T> right);
    public static bool TestNotZAndNotC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestNotZAndNotC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestNotZAndNotC(Vector256`1<T> left, Vector256`1<T> right);
    public static bool TestZ(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestZ(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestZ(Vector256`1<T> left, Vector256`1<T> right);
    public static Vector256`1<float> UnpackHigh(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackHigh(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> UnpackLow(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackLow(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Xor(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Xor(Vector256`1<double> left, Vector256`1<double> right);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Avx2 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector256`1<byte> Abs(Vector256`1<sbyte> value);
    public static Vector256`1<ushort> Abs(Vector256`1<short> value);
    public static Vector256`1<UInt32> Abs(Vector256`1<int> value);
    public static Vector256`1<sbyte> Add(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Add(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Add(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Add(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Add(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Add(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Add(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Add(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AddSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AddSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AddSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<sbyte> AlignRight(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte mask);
    public static Vector256`1<sbyte> And(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> And(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> And(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> And(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> And(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> And(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> And(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> And(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AndNot(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AndNot(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AndNot(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AndNot(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> AndNot(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> AndNot(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> AndNot(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> AndNot(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<byte> Average(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> Average(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector128`1<int> Blend(Vector128`1<int> left, Vector128`1<int> right, byte control);
    public static Vector128`1<UInt32> Blend(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte control);
    public static Vector256`1<short> Blend(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Blend(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Blend(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Blend(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<sbyte> BlendVariable(Vector256`1<sbyte> left, Vector256`1<sbyte> right, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> BlendVariable(Vector256`1<byte> left, Vector256`1<byte> right, Vector256`1<byte> mask);
    public static Vector128`1<T> BroadcastScalarToVector128(Vector128`1<T> value);
    public static Vector256`1<T> BroadcastScalarToVector256(Vector128`1<T> value);
    public static Vector256`1<sbyte> BroadcastVector128ToVector256(SByte* address);
    public static Vector256`1<byte> BroadcastVector128ToVector256(Byte* address);
    public static Vector256`1<short> BroadcastVector128ToVector256(Int16* address);
    public static Vector256`1<ushort> BroadcastVector128ToVector256(UInt16* address);
    public static Vector256`1<int> BroadcastVector128ToVector256(Int32* address);
    public static Vector256`1<UInt32> BroadcastVector128ToVector256(UInt32* address);
    public static Vector256`1<long> BroadcastVector128ToVector256(Int64* address);
    public static Vector256`1<ulong> BroadcastVector128ToVector256(UInt64* address);
    public static Vector256`1<sbyte> CompareEqual(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> CompareEqual(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> CompareEqual(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> CompareEqual(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> CompareEqual(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> CompareEqual(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> CompareEqual(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> CompareEqual(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> CompareGreaterThan(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> CompareGreaterThan(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> CompareGreaterThan(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<long> CompareGreaterThan(Vector256`1<long> left, Vector256`1<long> right);
    public static double ConvertToDouble(Vector256`1<double> value);
    public static int ConvertToInt32(Vector256`1<int> value);
    public static UInt32 ConvertToUInt32(Vector256`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector128`1<sbyte> value);
    public static Vector256`1<ushort> ConvertToVector256UInt16(Vector128`1<byte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<sbyte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<short> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector128`1<byte> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector128`1<ushort> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<sbyte> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<short> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<int> value);
    public static Vector256`1<ulong> ConvertToVector256UInt64(Vector128`1<byte> value);
    public static Vector256`1<ulong> ConvertToVector256UInt64(Vector128`1<ushort> value);
    public static Vector256`1<ulong> ConvertToVector256UInt64(Vector128`1<UInt32> value);
    public static Vector128`1<sbyte> ExtractVector128(Vector256`1<sbyte> value, byte index);
    public static void ExtractVector128(SByte* address, Vector256`1<sbyte> value, byte index);
    public static Vector128`1<byte> ExtractVector128(Vector256`1<byte> value, byte index);
    public static void ExtractVector128(Byte* address, Vector256`1<byte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector256`1<short> value, byte index);
    public static void ExtractVector128(Int16* address, Vector256`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector256`1<ushort> value, byte index);
    public static void ExtractVector128(UInt16* address, Vector256`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector256`1<int> value, byte index);
    public static void ExtractVector128(Int32* address, Vector256`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector256`1<UInt32> value, byte index);
    public static void ExtractVector128(UInt32* address, Vector256`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector256`1<long> value, byte index);
    public static void ExtractVector128(Int64* address, Vector256`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector256`1<ulong> value, byte index);
    public static void ExtractVector128(UInt64* address, Vector256`1<ulong> value, byte index);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector256`1<int> GatherVector256(Int32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<UInt32> GatherVector256(UInt32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<float> GatherVector256(Single* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<int> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<int> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<int> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector128`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<long> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<long> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<long> index, Vector128`1<double> mask, byte scale);
    public static Vector256`1<int> GatherMaskVector256(Vector256`1<int> source, Int32* baseAddress, Vector256`1<int> index, Vector256`1<int> mask, byte scale);
    public static Vector256`1<UInt32> GatherMaskVector256(Vector256`1<UInt32> source, UInt32* baseAddress, Vector256`1<int> index, Vector256`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector256`1<ulong> mask, byte scale);
    public static Vector256`1<float> GatherMaskVector256(Vector256`1<float> source, Single* baseAddress, Vector256`1<int> index, Vector256`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector256`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector256`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector256`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector256`1<long> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector256`1<long> index, Vector256`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector256`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector256`1<long> index, Vector256`1<double> mask, byte scale);
    public static Vector256`1<short> HorizontalAdd(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalAdd(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalAddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> HorizontalSubtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalSubtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalSubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, SByte* address, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Byte* address, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Vector128`1<short> data, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Int16* address, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, UInt16* address, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Vector128`1<int> data, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Int32* address, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, UInt32* address, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Vector128`1<long> data, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Int64* address, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, UInt64* address, byte index);
    public static Vector256`1<sbyte> LoadAlignedVector256NonTemporal(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256NonTemporal(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256NonTemporal(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256NonTemporal(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256NonTemporal(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256NonTemporal(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256NonTemporal(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256NonTemporal(UInt64* address);
    public static Vector128`1<int> MaskLoad(Int32* address, Vector128`1<int> mask);
    public static Vector128`1<UInt32> MaskLoad(UInt32* address, Vector128`1<UInt32> mask);
    public static Vector128`1<long> MaskLoad(Int64* address, Vector128`1<long> mask);
    public static Vector128`1<ulong> MaskLoad(UInt64* address, Vector128`1<ulong> mask);
    public static Vector256`1<int> MaskLoad(Int32* address, Vector256`1<int> mask);
    public static Vector256`1<UInt32> MaskLoad(UInt32* address, Vector256`1<UInt32> mask);
    public static Vector256`1<long> MaskLoad(Int64* address, Vector256`1<long> mask);
    public static Vector256`1<ulong> MaskLoad(UInt64* address, Vector256`1<ulong> mask);
    public static void MaskStore(Int32* address, Vector128`1<int> mask, Vector128`1<int> source);
    public static void MaskStore(UInt32* address, Vector128`1<UInt32> mask, Vector128`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector128`1<long> mask, Vector128`1<long> source);
    public static void MaskStore(UInt64* address, Vector128`1<ulong> mask, Vector128`1<ulong> source);
    public static void MaskStore(Int32* address, Vector256`1<int> mask, Vector256`1<int> source);
    public static void MaskStore(UInt32* address, Vector256`1<UInt32> mask, Vector256`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector256`1<long> mask, Vector256`1<long> source);
    public static void MaskStore(UInt64* address, Vector256`1<ulong> mask, Vector256`1<ulong> source);
    public static Vector256`1<int> MultiplyAddAdjacent(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyAddAdjacent(Vector256`1<byte> left, Vector256`1<sbyte> right);
    public static Vector256`1<sbyte> Max(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Max(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Max(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Max(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Max(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Max(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<sbyte> Min(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Min(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Min(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Min(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Min(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Min(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static int MoveMask(Vector256`1<sbyte> value);
    public static int MoveMask(Vector256`1<byte> value);
    public static Vector256`1<ushort> MultipleSumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right, byte mask);
    public static Vector256`1<long> Multiply(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<ulong> Multiply(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<short> MultiplyHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> MultiplyHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<short> MultiplyHighRoundScale(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> MultiplyLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Or(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Or(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Or(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Or(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Or(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Or(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Or(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Or(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> PackSignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> PackSignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<byte> PackUnsignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> PackUnsignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Permute2x128(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte control);
    public static Vector256`1<byte> Permute2x128(Vector256`1<byte> left, Vector256`1<byte> right, byte control);
    public static Vector256`1<short> Permute2x128(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Permute2x128(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Permute2x128(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Permute2x128(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<long> Permute2x128(Vector256`1<long> left, Vector256`1<long> right, byte control);
    public static Vector256`1<ulong> Permute2x128(Vector256`1<ulong> left, Vector256`1<ulong> right, byte control);
    public static Vector256`1<long> Permute4x64(Vector256`1<long> value, byte control);
    public static Vector256`1<ulong> Permute4x64(Vector256`1<ulong> value, byte control);
    public static Vector256`1<double> Permute4x64(Vector256`1<double> value, byte control);
    public static Vector256`1<int> PermuteVar8x32(Vector256`1<int> left, Vector256`1<int> mask);
    public static Vector256`1<UInt32> PermuteVar8x32(Vector256`1<UInt32> left, Vector256`1<UInt32> mask);
    public static Vector256`1<float> PermuteVar8x32(Vector256`1<float> left, Vector256`1<float> mask);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftLeftLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftLeftLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftLeftLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftLeftLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftLeftLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftLeftLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftLeftLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftLeftLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftLeftLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector128`1<int> ShiftLeftLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftLeftLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftLeftLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, byte count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, byte count);
    public static Vector256`1<int> ShiftRightArithmeticVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector128`1<int> ShiftRightArithmeticVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftRightLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftRightLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftRightLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftRightLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftRightLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftRightLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftRightLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftRightLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftRightLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector128`1<int> ShiftRightLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftRightLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftRightLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<sbyte> Shuffle(Vector256`1<sbyte> value, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> Shuffle(Vector256`1<byte> value, Vector256`1<byte> mask);
    public static Vector256`1<int> Shuffle(Vector256`1<int> value, byte control);
    public static Vector256`1<UInt32> Shuffle(Vector256`1<UInt32> value, byte control);
    public static Vector256`1<short> ShuffleHigh(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleHigh(Vector256`1<ushort> value, byte control);
    public static Vector256`1<short> ShuffleLow(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleLow(Vector256`1<ushort> value, byte control);
    public static Vector256`1<sbyte> Sign(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> Sign(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> Sign(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Subtract(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Subtract(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Subtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Subtract(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Subtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Subtract(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Subtract(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Subtract(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> SubtractSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> SubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<byte> SubtractSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> SubtractSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<ulong> SumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<sbyte> UnpackHigh(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackHigh(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackHigh(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackHigh(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackHigh(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackHigh(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> UnpackLow(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackLow(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackLow(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackLow(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackLow(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackLow(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> Xor(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Xor(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Xor(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Xor(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Xor(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Xor(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Xor(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Xor(Vector256`1<ulong> left, Vector256`1<ulong> right);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Bmi1 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 AndNot(UInt32 left, UInt32 right);
    public static ulong AndNot(ulong left, ulong right);
    public static UInt32 BitFieldExtract(UInt32 value, UInt32 start, UInt32 length);
    public static ulong BitFieldExtract(ulong value, ulong start, ulong length);
    public static UInt32 BitFieldExtract(UInt32 value, UInt32 control);
    public static ulong BitFieldExtract(ulong value, ulong control);
    public static UInt32 ExtractLowestSetBit(UInt32 value);
    public static ulong ExtractLowestSetBit(ulong value);
    public static UInt32 GetMaskUptoLowestSetBit(UInt32 value);
    public static ulong GetMaskUptoLowestSetBit(ulong value);
    public static UInt32 ResetLowestSetBit(UInt32 value);
    public static ulong ResetLowestSetBit(ulong value);
    public static UInt32 TrailingZeroCount(UInt32 value);
    public static ulong TrailingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Bmi2 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 ZeroHighBits(UInt32 value, UInt32 index);
    public static ulong ZeroHighBits(ulong value, ulong index);
    public static UInt32 MultiplyNoFlags(UInt32 left, UInt32 right, UInt32* high);
    public static ulong MultiplyNoFlags(ulong left, ulong right, UInt64* high);
    public static UInt32 ParallelBitDeposit(UInt32 value, UInt32 mask);
    public static ulong ParallelBitDeposit(ulong value, ulong mask);
    public static UInt32 ParallelBitExtract(UInt32 value, UInt32 mask);
    public static ulong ParallelBitExtract(ulong value, ulong mask);
}
public enum System.Runtime.Intrinsics.X86.FloatComparisonMode : Enum {
    public byte value__;
    public static FloatComparisonMode EqualOrderedNonSignaling;
    public static FloatComparisonMode LessThanOrderedSignaling;
    public static FloatComparisonMode LessThanOrEqualOrderedSignaling;
    public static FloatComparisonMode UnorderedNonSignaling;
    public static FloatComparisonMode NotEqualUnorderedNonSignaling;
    public static FloatComparisonMode NotLessThanUnorderedSignaling;
    public static FloatComparisonMode NotLessThanOrEqualUnorderedSignaling;
    public static FloatComparisonMode OrderedNonSignaling;
    public static FloatComparisonMode EqualUnorderedNonSignaling;
    public static FloatComparisonMode NotGreaterThanOrEqualUnorderedSignaling;
    public static FloatComparisonMode NotGreaterThanUnorderedSignaling;
    public static FloatComparisonMode FalseOrderedNonSignaling;
    public static FloatComparisonMode NotEqualOrderedNonSignaling;
    public static FloatComparisonMode GreaterThanOrEqualOrderedSignaling;
    public static FloatComparisonMode GreaterThanOrderedSignaling;
    public static FloatComparisonMode TrueUnorderedNonSignaling;
    public static FloatComparisonMode EqualOrderedSignaling;
    public static FloatComparisonMode LessThanOrderedNonSignaling;
    public static FloatComparisonMode LessThanOrEqualOrderedNonSignaling;
    public static FloatComparisonMode UnorderedSignaling;
    public static FloatComparisonMode NotEqualUnorderedSignaling;
    public static FloatComparisonMode NotLessThanUnorderedNonSignaling;
    public static FloatComparisonMode NotLessThanOrEqualUnorderedNonSignaling;
    public static FloatComparisonMode OrderedSignaling;
    public static FloatComparisonMode EqualUnorderedSignaling;
    public static FloatComparisonMode NotGreaterThanOrEqualUnorderedNonSignaling;
    public static FloatComparisonMode NotGreaterThanUnorderedNonSignaling;
    public static FloatComparisonMode FalseOrderedSignaling;
    public static FloatComparisonMode NotEqualOrderedSignaling;
    public static FloatComparisonMode GreaterThanOrEqualOrderedNonSignaling;
    public static FloatComparisonMode GreaterThanOrderedNonSignaling;
    public static FloatComparisonMode TrueUnorderedSignaling;
}
public static class System.Runtime.Intrinsics.X86.Fma : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> MultiplyAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplyAddSubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddSubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddSubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddSubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Lzcnt : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 LeadingZeroCount(UInt32 value);
    public static ulong LeadingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Pclmulqdq : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<long> CarryLessMultiply(Vector128`1<long> left, Vector128`1<long> right, byte control);
    public static Vector128`1<ulong> CarryLessMultiply(Vector128`1<ulong> left, Vector128`1<ulong> right, byte control);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Popcnt : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static int PopCount(UInt32 value);
    public static long PopCount(ulong value);
}
public enum System.Runtime.Intrinsics.X86.ResultsFlag : Enum {
    public byte value__;
    public static ResultsFlag CFlag;
    public static ResultsFlag NotCFlagAndNotZFlag;
    public static ResultsFlag OFlag;
    public static ResultsFlag SFlag;
    public static ResultsFlag ZFlag;
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Sse : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> Add(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AddScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> And(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AndNot(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanOrEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanOrEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanOrEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanOrEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareNotEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareNotEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareOrdered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareUnordered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static int ConvertToInt32(Vector128`1<float> value);
    public static long ConvertToInt64(Vector128`1<float> value);
    public static float ConvertToSingle(Vector128`1<float> value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, int value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, long value);
    public static int ConvertToInt32WithTruncation(Vector128`1<float> value);
    public static long ConvertToInt64WithTruncation(Vector128`1<float> value);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> DivideScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> LoadVector128(Single* address);
    public static Vector128`1<float> LoadScalarVector128(Single* address);
    public static Vector128`1<float> LoadAlignedVector128(Single* address);
    public static Vector128`1<float> LoadHigh(Vector128`1<float> lower, Single* address);
    public static Vector128`1<float> LoadLow(Vector128`1<float> upper, Single* address);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MaxScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MinScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> MoveHighToLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveLowToHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static int MoveMask(Vector128`1<float> value);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MultiplyScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Or(Vector128`1<float> left, Vector128`1<float> right);
    public static void Prefetch0(Void* address);
    public static void Prefetch1(Void* address);
    public static void Prefetch2(Void* address);
    public static void PrefetchNonTemporal(Void* address);
    public static Vector128`1<float> Reciprocal(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrt(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> SetAllVector128(float value);
    public static Vector128`1<float> SetScalarVector128(float value);
    public static Vector128`1<float> SetVector128(float e3, float e2, float e1, float e0);
    public static Vector128`1<float> SetZeroVector128();
    public static Vector128`1<U> StaticCast(Vector128`1<T> value);
    public static Vector128`1<float> Shuffle(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static void StoreAligned(Single* address, Vector128`1<float> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector128`1<float> source);
    public static void Store(Single* address, Vector128`1<float> source);
    public static void StoreFence();
    public static void StoreScalar(Single* address, Vector128`1<float> source);
    public static void StoreHigh(Single* address, Vector128`1<float> source);
    public static void StoreLow(Single* address, Vector128`1<float> source);
    public static Vector128`1<float> Subtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> SubtractScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Xor(Vector128`1<float> left, Vector128`1<float> right);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Sse2 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Add(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Add(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Add(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Add(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Add(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Add(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Add(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Add(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Add(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> AddScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> AddSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> And(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> And(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> And(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> And(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> And(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> And(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> And(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> And(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> And(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> AndNot(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> AndNot(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> AndNot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AndNot(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> AndNot(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> AndNot(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> AndNot(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> AndNot(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> AndNot(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Average(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> Average(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<sbyte> CompareEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> CompareEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareGreaterThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareGreaterThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareGreaterThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanOrEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanOrEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareLessThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareLessThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareLessThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanOrEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanOrEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareNotEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareNotEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareOrdered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareUnordered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<int> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<double> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<int> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<float> value);
    public static double ConvertToDouble(Vector128`1<double> value);
    public static int ConvertToInt32(Vector128`1<double> value);
    public static int ConvertToInt32(Vector128`1<int> value);
    public static long ConvertToInt64(Vector128`1<double> value);
    public static long ConvertToInt64(Vector128`1<long> value);
    public static UInt32 ConvertToUInt32(Vector128`1<UInt32> value);
    public static ulong ConvertToUInt64(Vector128`1<ulong> value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, int value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, long value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, Vector128`1<float> value);
    public static Vector128`1<int> ConvertScalarToVector128Int32(int value);
    public static Vector128`1<long> ConvertScalarToVector128Int64(long value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, Vector128`1<double> value);
    public static Vector128`1<UInt32> ConvertScalarToVector128UInt32(UInt32 value);
    public static Vector128`1<ulong> ConvertScalarToVector128UInt64(ulong value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<double> value);
    public static int ConvertToInt32WithTruncation(Vector128`1<double> value);
    public static long ConvertToInt64WithTruncation(Vector128`1<double> value);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> DivideScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static short Extract(Vector128`1<short> value, byte index);
    public static ushort Extract(Vector128`1<ushort> value, byte index);
    public static Vector128`1<short> Insert(Vector128`1<short> value, short data, byte index);
    public static Vector128`1<ushort> Insert(Vector128`1<ushort> value, ushort data, byte index);
    public static Vector128`1<sbyte> LoadVector128(SByte* address);
    public static Vector128`1<byte> LoadVector128(Byte* address);
    public static Vector128`1<short> LoadVector128(Int16* address);
    public static Vector128`1<ushort> LoadVector128(UInt16* address);
    public static Vector128`1<int> LoadVector128(Int32* address);
    public static Vector128`1<UInt32> LoadVector128(UInt32* address);
    public static Vector128`1<long> LoadVector128(Int64* address);
    public static Vector128`1<ulong> LoadVector128(UInt64* address);
    public static Vector128`1<double> LoadVector128(Double* address);
    public static Vector128`1<double> LoadScalarVector128(Double* address);
    public static Vector128`1<sbyte> LoadAlignedVector128(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128(UInt64* address);
    public static Vector128`1<double> LoadAlignedVector128(Double* address);
    public static void LoadFence();
    public static Vector128`1<double> LoadHigh(Vector128`1<double> lower, Double* address);
    public static Vector128`1<double> LoadLow(Vector128`1<double> upper, Double* address);
    public static Vector128`1<int> LoadScalarVector128(Int32* address);
    public static Vector128`1<UInt32> LoadScalarVector128(UInt32* address);
    public static Vector128`1<long> LoadScalarVector128(Int64* address);
    public static Vector128`1<ulong> LoadScalarVector128(UInt64* address);
    public static void MaskMove(Vector128`1<sbyte> source, Vector128`1<sbyte> mask, SByte* address);
    public static void MaskMove(Vector128`1<byte> source, Vector128`1<byte> mask, Byte* address);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MaxScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static void MemoryFence();
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MinScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MoveScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static int MoveMask(Vector128`1<sbyte> value);
    public static int MoveMask(Vector128`1<byte> value);
    public static int MoveMask(Vector128`1<double> value);
    public static Vector128`1<long> MoveScalar(Vector128`1<long> value);
    public static Vector128`1<ulong> MoveScalar(Vector128`1<ulong> value);
    public static Vector128`1<ulong> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MultiplyScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> MultiplyHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> MultiplyHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> MultiplyHorizontalAdd(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> Or(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Or(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Or(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Or(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Or(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Or(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Or(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Or(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Or(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> PackSignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> PackSignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<byte> PackUnsignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> SetAllVector128(byte value);
    public static Vector128`1<sbyte> SetAllVector128(sbyte value);
    public static Vector128`1<short> SetAllVector128(short value);
    public static Vector128`1<ushort> SetAllVector128(ushort value);
    public static Vector128`1<int> SetAllVector128(int value);
    public static Vector128`1<UInt32> SetAllVector128(UInt32 value);
    public static Vector128`1<long> SetAllVector128(long value);
    public static Vector128`1<ulong> SetAllVector128(ulong value);
    public static Vector128`1<double> SetAllVector128(double value);
    public static Vector128`1<double> SetScalarVector128(double value);
    public static Vector128`1<sbyte> SetVector128(sbyte e15, sbyte e14, sbyte e13, sbyte e12, sbyte e11, sbyte e10, sbyte e9, sbyte e8, sbyte e7, sbyte e6, sbyte e5, sbyte e4, sbyte e3, sbyte e2, sbyte e1, sbyte e0);
    public static Vector128`1<byte> SetVector128(byte e15, byte e14, byte e13, byte e12, byte e11, byte e10, byte e9, byte e8, byte e7, byte e6, byte e5, byte e4, byte e3, byte e2, byte e1, byte e0);
    public static Vector128`1<short> SetVector128(short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0);
    public static Vector128`1<ushort> SetVector128(ushort e7, ushort e6, ushort e5, ushort e4, ushort e3, ushort e2, ushort e1, ushort e0);
    public static Vector128`1<int> SetVector128(int e3, int e2, int e1, int e0);
    public static Vector128`1<UInt32> SetVector128(UInt32 e3, UInt32 e2, UInt32 e1, UInt32 e0);
    public static Vector128`1<long> SetVector128(long e1, long e0);
    public static Vector128`1<ulong> SetVector128(ulong e1, ulong e0);
    public static Vector128`1<double> SetVector128(double e1, double e0);
    public static Vector128`1<T> SetZeroVector128();
    public static Vector128`1<long> SumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> Shuffle(Vector128`1<int> value, byte control);
    public static Vector128`1<UInt32> Shuffle(Vector128`1<UInt32> value, byte control);
    public static Vector128`1<double> Shuffle(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<short> ShuffleHigh(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleHigh(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShuffleLow(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleLow(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftLeftLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftLeftLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftLeftLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftLeftLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftLeftLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftLeftLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftLeftLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftLeftLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, byte count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftRightLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftRightLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftRightLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftRightLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftRightLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftRightLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftRightLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static void StoreScalar(Double* address, Vector128`1<double> source);
    public static void StoreAligned(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector128`1<byte> source);
    public static void StoreAligned(Int16* address, Vector128`1<short> source);
    public static void StoreAligned(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector128`1<int> source);
    public static void StoreAligned(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector128`1<long> source);
    public static void StoreAligned(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAligned(Double* address, Vector128`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector128`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector128`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector128`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector128`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector128`1<double> source);
    public static void Store(SByte* address, Vector128`1<sbyte> source);
    public static void Store(Byte* address, Vector128`1<byte> source);
    public static void Store(Int16* address, Vector128`1<short> source);
    public static void Store(UInt16* address, Vector128`1<ushort> source);
    public static void Store(Int32* address, Vector128`1<int> source);
    public static void Store(UInt32* address, Vector128`1<UInt32> source);
    public static void Store(Int64* address, Vector128`1<long> source);
    public static void Store(UInt64* address, Vector128`1<ulong> source);
    public static void Store(Double* address, Vector128`1<double> source);
    public static void StoreHigh(Double* address, Vector128`1<double> source);
    public static void StoreLow(Int64* address, Vector128`1<long> source);
    public static void StoreLow(UInt64* address, Vector128`1<ulong> source);
    public static void StoreLow(Double* address, Vector128`1<double> source);
    public static void StoreNonTemporal(Int32* address, int value);
    public static void StoreNonTemporal(UInt32* address, UInt32 value);
    public static void StoreNonTemporal(Int64* address, long value);
    public static void StoreNonTemporal(UInt64* address, ulong value);
    public static Vector128`1<byte> Subtract(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Subtract(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Subtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Subtract(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Subtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Subtract(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Subtract(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Subtract(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Subtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> SubtractScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> SubtractSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> SubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> SubtractSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> UnpackHigh(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackHigh(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackHigh(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackHigh(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackHigh(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackHigh(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackHigh(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> UnpackLow(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackLow(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackLow(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackLow(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackLow(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackLow(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackLow(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Xor(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Xor(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Xor(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Xor(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Xor(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Xor(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Xor(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Xor(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Xor(Vector128`1<double> left, Vector128`1<double> right);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Sse3 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> AddSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> AddSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalAdd(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalAdd(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> LoadAndDuplicateToVector128(Double* address);
    public static Vector128`1<sbyte> LoadDquVector128(SByte* address);
    public static Vector128`1<byte> LoadDquVector128(Byte* address);
    public static Vector128`1<short> LoadDquVector128(Int16* address);
    public static Vector128`1<ushort> LoadDquVector128(UInt16* address);
    public static Vector128`1<int> LoadDquVector128(Int32* address);
    public static Vector128`1<UInt32> LoadDquVector128(UInt32* address);
    public static Vector128`1<long> LoadDquVector128(Int64* address);
    public static Vector128`1<ulong> LoadDquVector128(UInt64* address);
    public static Vector128`1<double> MoveAndDuplicate(Vector128`1<double> source);
    public static Vector128`1<float> MoveHighAndDuplicate(Vector128`1<float> source);
    public static Vector128`1<float> MoveLowAndDuplicate(Vector128`1<float> source);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Sse41 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<short> Blend(Vector128`1<short> left, Vector128`1<short> right, byte control);
    public static Vector128`1<ushort> Blend(Vector128`1<ushort> left, Vector128`1<ushort> right, byte control);
    public static Vector128`1<float> Blend(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> Blend(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<sbyte> BlendVariable(Vector128`1<sbyte> left, Vector128`1<sbyte> right, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> BlendVariable(Vector128`1<byte> left, Vector128`1<byte> right, Vector128`1<byte> mask);
    public static Vector128`1<float> BlendVariable(Vector128`1<float> left, Vector128`1<float> right, Vector128`1<float> mask);
    public static Vector128`1<double> BlendVariable(Vector128`1<double> left, Vector128`1<double> right, Vector128`1<double> mask);
    public static Vector128`1<float> Ceiling(Vector128`1<float> value);
    public static Vector128`1<double> Ceiling(Vector128`1<double> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<long> CompareEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<sbyte> value);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<sbyte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<short> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<sbyte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<byte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<short> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<int> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<UInt32> value);
    public static Vector128`1<float> DotProduct(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> DotProduct(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static sbyte Extract(Vector128`1<sbyte> value, byte index);
    public static byte Extract(Vector128`1<byte> value, byte index);
    public static int Extract(Vector128`1<int> value, byte index);
    public static UInt32 Extract(Vector128`1<UInt32> value, byte index);
    public static long Extract(Vector128`1<long> value, byte index);
    public static ulong Extract(Vector128`1<ulong> value, byte index);
    public static float Extract(Vector128`1<float> value, byte index);
    public static Vector128`1<float> Floor(Vector128`1<float> value);
    public static Vector128`1<double> Floor(Vector128`1<double> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<sbyte> Insert(Vector128`1<sbyte> value, sbyte data, byte index);
    public static Vector128`1<byte> Insert(Vector128`1<byte> value, byte data, byte index);
    public static Vector128`1<int> Insert(Vector128`1<int> value, int data, byte index);
    public static Vector128`1<UInt32> Insert(Vector128`1<UInt32> value, UInt32 data, byte index);
    public static Vector128`1<long> Insert(Vector128`1<long> value, long data, byte index);
    public static Vector128`1<ulong> Insert(Vector128`1<ulong> value, ulong data, byte index);
    public static Vector128`1<float> Insert(Vector128`1<float> value, float data, byte index);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> MinHorizontal(Vector128`1<ushort> value);
    public static Vector128`1<ushort> MultipleSumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right, byte mask);
    public static Vector128`1<long> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<ushort> PackUnsignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> RoundToNearestInteger(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZero(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirection(Vector128`1<float> value);
    public static Vector128`1<double> RoundToNearestInteger(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinity(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinity(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZero(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirection(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<sbyte> LoadAlignedVector128NonTemporal(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128NonTemporal(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128NonTemporal(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128NonTemporal(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128NonTemporal(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128NonTemporal(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128NonTemporal(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128NonTemporal(UInt64* address);
    public static bool TestAllOnes(Vector128`1<sbyte> value);
    public static bool TestAllOnes(Vector128`1<byte> value);
    public static bool TestAllOnes(Vector128`1<short> value);
    public static bool TestAllOnes(Vector128`1<ushort> value);
    public static bool TestAllOnes(Vector128`1<int> value);
    public static bool TestAllOnes(Vector128`1<UInt32> value);
    public static bool TestAllOnes(Vector128`1<long> value);
    public static bool TestAllOnes(Vector128`1<ulong> value);
    public static bool TestAllZeros(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestAllZeros(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestAllZeros(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestAllZeros(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestAllZeros(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestAllZeros(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestAllZeros(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestAllZeros(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestMixOnesZeros(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestMixOnesZeros(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestMixOnesZeros(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestMixOnesZeros(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestMixOnesZeros(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestMixOnesZeros(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestMixOnesZeros(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestMixOnesZeros(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestNotZAndNotC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestNotZAndNotC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestNotZAndNotC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestNotZAndNotC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestNotZAndNotC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestNotZAndNotC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestNotZAndNotC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestNotZAndNotC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestZ(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestZ(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestZ(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestZ(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestZ(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestZ(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestZ(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestZ(Vector128`1<ulong> left, Vector128`1<ulong> right);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Sse42 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static bool CompareImplicitLength(Vector128`1<sbyte> left, Vector128`1<sbyte> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareImplicitLength(Vector128`1<byte> left, Vector128`1<byte> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareImplicitLength(Vector128`1<short> left, Vector128`1<short> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareImplicitLength(Vector128`1<ushort> left, Vector128`1<ushort> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<sbyte> left, Vector128`1<sbyte> right, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<byte> left, Vector128`1<byte> right, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<short> left, Vector128`1<short> right, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<ushort> left, Vector128`1<ushort> right, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthBitMask(Vector128`1<sbyte> left, Vector128`1<sbyte> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthBitMask(Vector128`1<byte> left, Vector128`1<byte> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthBitMask(Vector128`1<short> left, Vector128`1<short> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthBitMask(Vector128`1<ushort> left, Vector128`1<ushort> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthUnitMask(Vector128`1<sbyte> left, Vector128`1<sbyte> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthUnitMask(Vector128`1<byte> left, Vector128`1<byte> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthUnitMask(Vector128`1<short> left, Vector128`1<short> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthUnitMask(Vector128`1<ushort> left, Vector128`1<ushort> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthBitMask(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthBitMask(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthBitMask(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthBitMask(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthUnitMask(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthUnitMask(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthUnitMask(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthUnitMask(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<long> CompareGreaterThan(Vector128`1<long> left, Vector128`1<long> right);
    public static UInt32 Crc32(UInt32 crc, byte data);
    public static UInt32 Crc32(UInt32 crc, ushort data);
    public static UInt32 Crc32(UInt32 crc, UInt32 data);
    public static ulong Crc32(ulong crc, ulong data);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.X86.Ssse3 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<sbyte> AlignRight(Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte mask);
    public static Vector128`1<short> HorizontalAdd(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalAdd(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalAddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> HorizontalSubtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalSubtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalSubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyAddAdjacent(Vector128`1<byte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> MultiplyHighRoundScale(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> Shuffle(Vector128`1<sbyte> value, Vector128`1<sbyte> mask);
    public static Vector128`1<sbyte> Sign(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Sign(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Sign(Vector128`1<int> left, Vector128`1<int> right);
}
public enum System.Runtime.Intrinsics.X86.StringComparisonMode : Enum {
    public byte value__;
    public static StringComparisonMode EqualAny;
    public static StringComparisonMode Ranges;
    public static StringComparisonMode EqualEach;
    public static StringComparisonMode EqualOrdered;
    public static StringComparisonMode NegativePolarity;
    public static StringComparisonMode MaskedNegativePolarity;
    public static StringComparisonMode LeastSignificant;
    public static StringComparisonMode MostSignificant;
}
internal class System.Runtime.Loader.AppPathAssemblyLoadContext : AssemblyLoadContext {
    protected virtual Assembly Load(AssemblyName assemblyName);
}
public abstract class System.Runtime.Loader.AssemblyLoadContext : object {
    [CompilerGeneratedAttribute]
private Func`3<AssemblyLoadContext, AssemblyName, Assembly> Resolving;
    [CompilerGeneratedAttribute]
private Action`1<AssemblyLoadContext> Unloading;
    private IntPtr m_pNativeAssemblyLoadContext;
    private static AssemblyLoadContext modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultAssemblyLoadContext;
    private static object s_initLock;
    public static AssemblyLoadContext Default { get; }
    internal AssemblyLoadContext(bool fRepresentsTPALoadContext);
    private static AssemblyLoadContext();
    private static bool CanUseAppPathAssemblyLoadContextInCurrentDomain();
    private static IntPtr InitializeAssemblyLoadContext(IntPtr ptrAssemblyLoadContext, bool fRepresentsTPALoadContext);
    private static IntPtr LoadFromStream(IntPtr ptrNativeAssemblyLoadContext, IntPtr ptrAssemblyArray, int iAssemblyArrayLen, IntPtr ptrSymbols, int iSymbolArrayLen, ObjectHandleOnStack retAssembly);
    internal static void InternalSetProfileRoot(string directoryPath);
    internal static void InternalStartProfile(string profile, IntPtr ptrNativeAssemblyLoadContext);
    private void InitializeLoadContext(bool fRepresentsTPALoadContext);
    private static void LoadFromPath(IntPtr ptrNativeAssemblyLoadContext, string ilPath, string niPath, ObjectHandleOnStack retAssembly);
    public static Assembly[] GetLoadedAssemblies();
    public Assembly LoadFromAssemblyPath(string assemblyPath);
    public Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath);
    public Assembly LoadFromStream(Stream assembly);
    public Assembly LoadFromStream(Stream assembly, Stream assemblySymbols);
    protected abstract virtual Assembly Load(AssemblyName assemblyName);
    private static Assembly Resolve(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private static Assembly ResolveUsingResolvingEvent(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private Assembly GetFirstResolvedAssembly(AssemblyName assemblyName);
    private Assembly ValidateAssemblyNameWithSimpleName(Assembly assembly, string requestedSimpleName);
    private Assembly ResolveUsingLoad(AssemblyName assemblyName);
    private Assembly ResolveUsingEvent(AssemblyName assemblyName);
    public Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    private static IntPtr InternalLoadUnmanagedDllFromPath(string unmanagedDllPath);
    protected IntPtr LoadUnmanagedDllFromPath(string unmanagedDllPath);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    private static IntPtr ResolveUnmanagedDll(string unmanagedDllName, IntPtr gchManagedAssemblyLoadContext);
    public static AssemblyLoadContext get_Default();
    public static AssemblyName GetAssemblyName(string assemblyPath);
    private static IntPtr GetLoadContextForAssembly(RuntimeAssembly assembly);
    public static AssemblyLoadContext GetLoadContext(Assembly assembly);
    public void SetProfileOptimizationRoot(string directoryPath);
    public void StartProfileOptimization(string profile);
    private void OnAppContextUnloading(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public void add_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
public void remove_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
public void add_Unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
public void remove_Unloading(Action`1<AssemblyLoadContext> value);
    public static void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public static void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public static void add_TypeResolve(ResolveEventHandler value);
    public static void remove_TypeResolve(ResolveEventHandler value);
    public static void add_ResourceResolve(ResolveEventHandler value);
    public static void remove_ResourceResolve(ResolveEventHandler value);
    public static void add_AssemblyResolve(ResolveEventHandler value);
    public static void remove_AssemblyResolve(ResolveEventHandler value);
}
internal class System.Runtime.Loader.IndividualAssemblyLoadContext : AssemblyLoadContext {
    protected virtual Assembly Load(AssemblyName assemblyName);
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    private static ulong TopOfMemory;
    private static ulong GCSegmentSize;
    private ulong _reservedMemory;
    private bool _mustSubtractReservation;
    private static MemoryFailPoint();
    public MemoryFailPoint(int sizeInMegabytes);
    private static void GetMemorySettings(UInt64& maxGCSegmentSize, UInt64& topOfMemory);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class System.Runtime.RuntimeImports : object {
    internal static void RhZeroMemory(Byte& b, ulong byteLength);
    internal static void RhZeroMemory(IntPtr p, UIntPtr byteLength);
    private static void RhZeroMemory(Void* b, ulong byteLength);
    internal static void RhBulkMoveWithWriteBarrier(Byte& destination, Byte& source, ulong byteCount);
}
internal static class System.Runtime.Serialization.FormatterServices : object {
    public static object GetUninitializedObject(Type type);
    private static object nativeGetUninitializedObject(RuntimeType type);
}
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    private int _versionAdded;
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    private List`1<object> _serializedStates;
    [CompilerGeneratedAttribute]
private StreamingContext <StreamingContext>k__BackingField;
    public StreamingContext StreamingContext { get; }
    public void AddSerializedState(ISafeSerializationData serializedState);
    [CompilerGeneratedAttribute]
public StreamingContext get_StreamingContext();
}
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private string _name;
    private object _value;
    private Type _type;
    public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.Serialization.SerializationException : SystemException {
    private static string s_nullMessage;
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
    private static SerializationException();
}
public class System.Runtime.Serialization.SerializationInfo : object {
    internal String[] m_members;
    internal Object[] m_data;
    internal Type[] m_types;
    private Dictionary`2<string, int> m_nameToIndex;
    internal int m_currMember;
    internal IFormatterConverter m_converter;
    private string m_fullTypeName;
    private string m_assemName;
    private Type objectType;
    private bool isFullTypeNameSetExplicit;
    private bool isAssemblyNameSetExplicit;
    private bool requireSameTokenInPartialTrust;
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public bool IsAssemblyNameSetExplicit { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public void SetType(Type type);
    internal static void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
    public int get_MemberCount();
    public Type get_ObjectType();
    public bool get_IsFullTypeNameSetExplicit();
    public bool get_IsAssemblyNameSetExplicit();
    public SerializationInfoEnumerator GetEnumerator();
    private void ExpandArrays();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValueInternal(string name, object value, Type type);
    public void UpdateValue(string name, object value, Type type);
    private int FindElement(string name);
    private object GetElement(string name, Type& foundType);
    private object GetElementNoThrow(string name, Type& foundType);
    public object GetValue(string name, Type type);
    internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
}
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private String[] _members;
    private Object[] _data;
    private Type[] _types;
    private int _numItems;
    private int _currItem;
    private bool _current;
    private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    public object get_Value();
    public Type get_ObjectType();
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _additionalContext;
    private StreamingContextStates _state;
    public StreamingContextStates State { get; }
    public object Context { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
    public object get_Context();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
internal static class System.Runtime.Versioning.CompatibilitySwitch : object {
    internal static string GetValueInternal(string compatibilitySwitchName);
    private static string GetValueInternalCall(string compatibilitySwitchName, bool onlyDB);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    private string _frameworkName;
    private string _frameworkDisplayName;
    public string FrameworkName { get; }
    public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
    private IntPtr m_ptr;
}
public class System.RuntimeFieldHandle : ValueType {
    private IRuntimeFieldInfo m_ptr;
    public IntPtr Value { get; }
    internal RuntimeFieldHandle(IRuntimeFieldInfo fieldInfo);
    internal IRuntimeFieldInfo GetRuntimeFieldInfo();
    public IntPtr get_Value();
    internal bool IsNullHandle();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    internal static string GetName(RtFieldInfo field);
    private static Void* _GetUtf8Name(RuntimeFieldHandleInternal field);
    internal static Utf8String GetUtf8Name(RuntimeFieldHandleInternal field);
    internal static bool MatchesNameHash(RuntimeFieldHandleInternal handle, UInt32 hash);
    internal static FieldAttributes GetAttributes(RuntimeFieldHandleInternal field);
    internal static RuntimeType GetApproxDeclaringType(RuntimeFieldHandleInternal field);
    internal static RuntimeType GetApproxDeclaringType(IRuntimeFieldInfo field);
    internal static int GetToken(RtFieldInfo field);
    internal static object GetValue(RtFieldInfo field, object instance, RuntimeType fieldType, RuntimeType declaringType, Boolean& domainInitialized);
    internal static object GetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType);
    internal static void SetValue(RtFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, Boolean& domainInitialized);
    internal static void SetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType);
    internal static RuntimeFieldHandleInternal GetStaticFieldForGenericType(RuntimeFieldHandleInternal field, RuntimeType declaringType);
    internal static bool AcquiresContextFromThis(RuntimeFieldHandleInternal field);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.RuntimeFieldHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal IntPtr Value { get; }
    internal RuntimeFieldHandleInternal(IntPtr value);
    internal IntPtr get_Value();
}
internal class System.RuntimeFieldInfoStub : object {
    private object m_keepalive;
    private object m_c;
    private object m_d;
    private int m_b;
    private object m_e;
    private RuntimeFieldHandleInternal m_fieldHandle;
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
}
public class System.RuntimeMethodHandle : ValueType {
    private IRuntimeMethodInfo m_value;
    public IntPtr Value { get; }
    internal RuntimeMethodHandle(IRuntimeMethodInfo method);
    internal static IRuntimeMethodInfo EnsureNonNullMethodInfo(IRuntimeMethodInfo method);
    internal IRuntimeMethodInfo GetMethodInfo();
    private static IntPtr GetValueInternal(RuntimeMethodHandle rmh);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public bool Equals(RuntimeMethodHandle handle);
    internal bool IsNullHandle();
    internal static IntPtr GetFunctionPointer(RuntimeMethodHandleInternal handle);
    public IntPtr GetFunctionPointer();
    internal static bool IsCAVisibleFromDecoratedType(RuntimeTypeHandle attrTypeHandle, IRuntimeMethodInfo attrCtor, RuntimeTypeHandle sourceTypeHandle, RuntimeModule sourceModule);
    private static IRuntimeMethodInfo _GetCurrentMethod(StackCrawlMark& stackMark);
    internal static IRuntimeMethodInfo GetCurrentMethod(StackCrawlMark& stackMark);
    internal static MethodAttributes GetAttributes(RuntimeMethodHandleInternal method);
    internal static MethodAttributes GetAttributes(IRuntimeMethodInfo method);
    internal static MethodImplAttributes GetImplAttributes(IRuntimeMethodInfo method);
    private static void ConstructInstantiation(IRuntimeMethodInfo method, TypeNameFormatFlags format, StringHandleOnStack retString);
    internal static string ConstructInstantiation(IRuntimeMethodInfo method, TypeNameFormatFlags format);
    internal static RuntimeType GetDeclaringType(RuntimeMethodHandleInternal method);
    internal static RuntimeType GetDeclaringType(IRuntimeMethodInfo method);
    internal static int GetSlot(RuntimeMethodHandleInternal method);
    internal static int GetSlot(IRuntimeMethodInfo method);
    internal static int GetMethodDef(IRuntimeMethodInfo method);
    internal static string GetName(RuntimeMethodHandleInternal method);
    internal static string GetName(IRuntimeMethodInfo method);
    private static Void* _GetUtf8Name(RuntimeMethodHandleInternal method);
    internal static Utf8String GetUtf8Name(RuntimeMethodHandleInternal method);
    internal static bool MatchesNameHash(RuntimeMethodHandleInternal method, UInt32 hash);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal static object InvokeMethod(object target, Object[] arguments, Signature sig, bool constructor, bool wrapExceptions);
    internal static INVOCATION_FLAGS GetSecurityFlags(IRuntimeMethodInfo handle);
    internal static UInt32 GetSpecialSecurityFlags(IRuntimeMethodInfo method);
    private static void GetMethodInstantiation(RuntimeMethodHandleInternal method, ObjectHandleOnStack types, bool fAsRuntimeTypeArray);
    internal static RuntimeType[] GetMethodInstantiationInternal(IRuntimeMethodInfo method);
    internal static RuntimeType[] GetMethodInstantiationInternal(RuntimeMethodHandleInternal method);
    internal static Type[] GetMethodInstantiationPublic(IRuntimeMethodInfo method);
    internal static bool HasMethodInstantiation(RuntimeMethodHandleInternal method);
    internal static bool HasMethodInstantiation(IRuntimeMethodInfo method);
    internal static RuntimeMethodHandleInternal GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation);
    internal static RuntimeMethodHandleInternal GetMethodFromCanonical(RuntimeMethodHandleInternal method, RuntimeType declaringType);
    internal static bool IsGenericMethodDefinition(RuntimeMethodHandleInternal method);
    internal static bool IsGenericMethodDefinition(IRuntimeMethodInfo method);
    internal static bool IsTypicalMethodDefinition(IRuntimeMethodInfo method);
    private static void GetTypicalMethodDefinition(IRuntimeMethodInfo method, ObjectHandleOnStack outMethod);
    internal static IRuntimeMethodInfo GetTypicalMethodDefinition(IRuntimeMethodInfo method);
    private static int GetGenericParameterCount(RuntimeMethodHandleInternal method);
    internal static int GetGenericParameterCount(IRuntimeMethodInfo method);
    private static void StripMethodInstantiation(IRuntimeMethodInfo method, ObjectHandleOnStack outMethod);
    internal static IRuntimeMethodInfo StripMethodInstantiation(IRuntimeMethodInfo method);
    internal static bool IsDynamicMethod(RuntimeMethodHandleInternal method);
    internal static void Destroy(RuntimeMethodHandleInternal method);
    internal static Resolver GetResolver(RuntimeMethodHandleInternal method);
    internal static MethodBody GetMethodBody(IRuntimeMethodInfo method, RuntimeType declaringType);
    internal static bool IsConstructor(RuntimeMethodHandleInternal method);
    internal static LoaderAllocator GetLoaderAllocator(RuntimeMethodHandleInternal method);
}
internal class System.RuntimeMethodHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal IntPtr Value { get; }
    internal RuntimeMethodHandleInternal(IntPtr value);
    internal bool IsNullHandle();
    internal IntPtr get_Value();
}
internal class System.RuntimeMethodInfoStub : object {
    private object m_keepalive;
    private object m_a;
    private object m_b;
    private object m_c;
    private object m_d;
    private object m_e;
    private object m_f;
    private object m_g;
    public RuntimeMethodHandleInternal m_value;
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    public RuntimeMethodInfoStub(RuntimeMethodHandleInternal methodHandleValue, object keepalive);
    public RuntimeMethodInfoStub(IntPtr methodHandleValue, object keepalive);
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
}
internal class System.RuntimeType : TypeInfo {
    private object m_keepalive;
    private IntPtr m_cache;
    internal IntPtr m_handle;
    internal static RuntimeType ValueType;
    private static RuntimeType ObjectType;
    private static RuntimeType StringType;
    private static int GenericParameterCountAny;
    private static BindingFlags MemberBindingMask;
    private static BindingFlags InvocationMask;
    private static BindingFlags BinderNonCreateInstance;
    private static BindingFlags BinderGetSetProperty;
    private static BindingFlags BinderSetInvokeProperty;
    private static BindingFlags BinderGetSetField;
    private static BindingFlags BinderSetInvokeField;
    private static BindingFlags BinderNonFieldGetSet;
    private static BindingFlags ClassicBindingMask;
    private static RuntimeType s_typedRef;
    private static ActivatorCache modreq(System.Runtime.CompilerServices.IsVolatile) s_ActivatorCache;
    internal object GenericCache { get; internal set; }
    internal bool DomainInitialized { get; internal set; }
    private RuntimeTypeCache Cache { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public bool IsCollectible { get; }
    public MethodBase DeclaringMethod { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSZArray { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsTypeDefinition { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    private static RuntimeType();
    internal static RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark);
    internal static MethodBase GetMethodBase(RuntimeModule scope, int typeMetadataToken);
    internal static MethodBase GetMethodBase(IRuntimeMethodInfo methodHandle);
    internal static MethodBase GetMethodBase(RuntimeType reflectedType, IRuntimeMethodInfo methodHandle);
    internal static MethodBase GetMethodBase(RuntimeType reflectedType, RuntimeMethodHandleInternal methodHandle);
    internal object get_GenericCache();
    internal void set_GenericCache(object value);
    internal bool get_DomainInitialized();
    internal void set_DomainInitialized(bool value);
    internal static FieldInfo GetFieldInfo(IRuntimeFieldInfo fieldHandle);
    internal static FieldInfo GetFieldInfo(RuntimeType reflectedType, IRuntimeFieldInfo field);
    private static PropertyInfo GetPropertyInfo(RuntimeType reflectedType, int tkProperty);
    private static void ThrowIfTypeNeverValidGenericArgument(RuntimeType type);
    internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters);
    internal static void ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e);
    private static void SplitName(string fullname, String& name, String& ns);
    internal static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, bool allowPrefixLookup, Boolean& prefixLookup, Boolean& ignoreCase, MemberListType& listType);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, Boolean& ignoreCase, MemberListType& listType);
    private static bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase);
    private static bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
    private static bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
    private static bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags methodFlags, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    internal virtual bool CacheEquals(object o);
    private RuntimeTypeCache get_Cache();
    private string GetDefaultMemberName();
    private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, int genericParameterCount, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetInterfaces();
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type ifaceType);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    private MethodInfo GetMethodImplCommon(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual Type GetInterface(string fullname, bool ignoreCase);
    public virtual Type GetNestedType(string fullname, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    internal sealed virtual RuntimeTypeHandle GetTypeHandleInternal();
    public sealed virtual bool get_IsCollectible();
    protected virtual TypeCode GetTypeCodeImpl();
    public virtual MethodBase get_DeclaringMethod();
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsSubclassOf(Type type);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    public virtual Type get_BaseType();
    private RuntimeType GetBaseType();
    public virtual Type get_UnderlyingSystemType();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_Namespace();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Guid get_GUID();
    private void GetGUID(Guid& result);
    protected virtual bool IsContextfulImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public sealed virtual bool get_IsByRefLike();
    internal bool IsDelegate();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool HasElementTypeImpl();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    public virtual int GetArrayRank();
    public virtual Type GetElementType();
    public virtual String[] GetEnumNames();
    public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual Type MakeGenericType(Type[] instantiation);
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual bool get_IsTypeDefinition();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    private static bool CanValueSpecialCast(RuntimeType valueType, RuntimeType targetType);
    private static object AllocateValueType(RuntimeType type, object value, bool fForceTypeChange);
    internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    private object TryChangeType(object value, Binder binder, CultureInfo culture, bool needsSpecialCast);
    public virtual MemberInfo[] GetDefaultMembers();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual object Clone();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    internal virtual string FormatTypeName(bool serialization);
    private string GetCachedName(TypeNameKind kind);
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    private void CreateInstanceCheckThis();
    internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    internal object CreateInstanceSlow(bool publicOnly, bool wrapExceptions, bool skipCheckThis, bool fillCache);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, bool wrapExceptions);
    internal void InvalidateCachedNestedType();
    internal bool IsGenericCOMObjectImpl();
    private static object _CreateEnum(RuntimeType enumType, long value);
    internal static object CreateEnum(RuntimeType enumType, long value);
    internal static Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError);
    internal static Type GetTypeFromCLSIDImpl(Guid clsid, string server, bool throwOnError);
}
public class System.RuntimeTypeHandle : ValueType {
    private RuntimeType m_type;
    public IntPtr Value { get; }
    internal RuntimeTypeHandle(RuntimeType type);
    internal RuntimeTypeHandle GetNativeHandle();
    internal RuntimeType GetTypeChecked();
    internal static bool IsInstanceOfType(RuntimeType type, object o);
    internal static Type GetTypeHelper(Type typeStart, Type[] genericArgs, IntPtr pModifiers, int cModifiers);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public IntPtr get_Value();
    internal static IntPtr GetValueInternal(RuntimeTypeHandle handle);
    internal static bool IsTypeDefinition(RuntimeType type);
    internal static bool IsPrimitive(RuntimeType type);
    internal static bool IsByRef(RuntimeType type);
    internal static bool IsPointer(RuntimeType type);
    internal static bool IsArray(RuntimeType type);
    internal static bool IsSZArray(RuntimeType type);
    internal static bool HasElementType(RuntimeType type);
    internal static IntPtr[] CopyRuntimeTypeHandles(RuntimeTypeHandle[] inHandles, Int32& length);
    internal static IntPtr[] CopyRuntimeTypeHandles(Type[] inHandles, Int32& length);
    internal static object CreateInstance(RuntimeType type, bool publicOnly, bool wrapExceptions, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor);
    internal static object CreateCaInstance(RuntimeType type, IRuntimeMethodInfo ctor);
    internal static object Allocate(RuntimeType type);
    internal static object CreateInstanceForAnotherGenericParameter(RuntimeType type, RuntimeType genericParameter);
    internal RuntimeType GetRuntimeType();
    internal static CorElementType GetCorElementType(RuntimeType type);
    internal static RuntimeAssembly GetAssembly(RuntimeType type);
    internal static RuntimeModule GetModule(RuntimeType type);
    public ModuleHandle GetModuleHandle();
    internal static RuntimeType GetBaseType(RuntimeType type);
    internal static TypeAttributes GetAttributes(RuntimeType type);
    internal static RuntimeType GetElementType(RuntimeType type);
    internal static bool CompareCanonicalHandles(RuntimeType left, RuntimeType right);
    internal static int GetArrayRank(RuntimeType type);
    internal static int GetToken(RuntimeType type);
    internal static RuntimeMethodHandleInternal GetMethodAt(RuntimeType type, int slot);
    internal static IntroducedMethodEnumerator GetIntroducedMethods(RuntimeType type);
    private static RuntimeMethodHandleInternal GetFirstIntroducedMethod(RuntimeType type);
    private static void GetNextIntroducedMethod(RuntimeMethodHandleInternal& method);
    internal static bool GetFields(RuntimeType type, IntPtr* result, Int32* count);
    internal static Type[] GetInterfaces(RuntimeType type);
    private static void GetConstraints(RuntimeTypeHandle handle, ObjectHandleOnStack types);
    internal Type[] GetConstraints();
    private static IntPtr GetGCHandle(RuntimeTypeHandle handle, GCHandleType type);
    internal IntPtr GetGCHandle(GCHandleType type);
    internal static int GetNumVirtuals(RuntimeType type);
    private static void VerifyInterfaceIsImplemented(RuntimeTypeHandle handle, RuntimeTypeHandle interfaceHandle);
    internal void VerifyInterfaceIsImplemented(RuntimeTypeHandle interfaceHandle);
    private static RuntimeMethodHandleInternal GetInterfaceMethodImplementation(RuntimeTypeHandle handle, RuntimeTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    internal RuntimeMethodHandleInternal GetInterfaceMethodImplementation(RuntimeTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
    internal static bool IsInterface(RuntimeType type);
    internal static bool IsByRefLike(RuntimeType type);
    private static bool _IsVisible(RuntimeTypeHandle typeHandle);
    internal static bool IsVisible(RuntimeType type);
    internal static bool IsValueType(RuntimeType type);
    private static void ConstructName(RuntimeTypeHandle handle, TypeNameFormatFlags formatFlags, StringHandleOnStack retString);
    internal string ConstructName(TypeNameFormatFlags formatFlags);
    private static Void* _GetUtf8Name(RuntimeType type);
    internal static Utf8String GetUtf8Name(RuntimeType type);
    internal static bool CanCastTo(RuntimeType type, RuntimeType target);
    internal static RuntimeType GetDeclaringType(RuntimeType type);
    internal static IRuntimeMethodInfo GetDeclaringMethod(RuntimeType type);
    private static void GetDefaultConstructor(RuntimeTypeHandle handle, ObjectHandleOnStack method);
    internal IRuntimeMethodInfo GetDefaultConstructor();
    private static void GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMarkHandle stackMark, IntPtr pPrivHostBinder, bool loadTypeFromPartialName, ObjectHandleOnStack type, ObjectHandleOnStack keepalive);
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, bool loadTypeFromPartialName);
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool loadTypeFromPartialName);
    private static void GetTypeByNameUsingCARules(string name, RuntimeModule scope, ObjectHandleOnStack type);
    internal static RuntimeType GetTypeByNameUsingCARules(string name, RuntimeModule scope);
    internal static void GetInstantiation(RuntimeTypeHandle type, ObjectHandleOnStack types, bool fAsRuntimeTypeArray);
    internal RuntimeType[] GetInstantiationInternal();
    internal Type[] GetInstantiationPublic();
    private static void Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, int numGenericArgs, ObjectHandleOnStack type);
    internal RuntimeType Instantiate(Type[] inst);
    private static void MakeArray(RuntimeTypeHandle handle, int rank, ObjectHandleOnStack type);
    internal RuntimeType MakeArray(int rank);
    private static void MakeSZArray(RuntimeTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakeSZArray();
    private static void MakeByRef(RuntimeTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakeByRef();
    private static void MakePointer(RuntimeTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakePointer();
    internal static bool IsCollectible(RuntimeTypeHandle handle);
    internal static bool HasInstantiation(RuntimeType type);
    private static void GetGenericTypeDefinition(RuntimeTypeHandle type, ObjectHandleOnStack retType);
    internal static RuntimeType GetGenericTypeDefinition(RuntimeType type);
    internal static bool IsGenericTypeDefinition(RuntimeType type);
    internal static bool IsGenericVariable(RuntimeType type);
    private static int GetGenericVariableIndex(RuntimeType type);
    internal int GetGenericVariableIndex();
    internal static bool ContainsGenericVariables(RuntimeType handle);
    internal bool ContainsGenericVariables();
    private static bool SatisfiesConstraints(RuntimeType paramType, IntPtr* pTypeContext, int typeContextLength, IntPtr* pMethodContext, int methodContextLength, RuntimeType toType);
    internal static bool SatisfiesConstraints(RuntimeType paramType, RuntimeType[] typeContext, RuntimeType[] methodContext, RuntimeType toType);
    private static IntPtr _GetMetadataImport(RuntimeType type);
    internal static MetadataImport GetMetadataImport(RuntimeType type);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.SafeTypeNameParserHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static void _ReleaseTypeNameParser(IntPtr pTypeNameParser);
    protected virtual bool ReleaseHandle();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    private sbyte m_value;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static sbyte Parse(string s, NumberStyles style, NumberFormatInfo info);
    private static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal enum System.Security.AccessControl.EventWaitHandleRights : Enum {
    public int value__;
}
internal class System.Security.AccessControl.EventWaitHandleSecurity : object {
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PartialTrustVisibilityLevel <PartialTrustVisibilityLevel>k__BackingField;
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    [CompilerGeneratedAttribute]
public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    [CompilerGeneratedAttribute]
public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    public CryptographicException(string message);
    public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
public class System.Security.SecureString : object {
    private object _methodLock;
    private bool _readOnly;
    private int _decryptedLength;
    private UnmanagedBuffer _buffer;
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    internal SecureString(SecureString str);
    public int get_Length();
    public void AppendChar(char c);
    public void Clear();
    public SecureString Copy();
    public sealed virtual void Dispose();
    public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    public void RemoveAt(int index);
    public void SetAt(int index, char c);
    private void EnsureNotReadOnly();
    internal IntPtr MarshalToString(bool globalAlloc, bool unicode);
    private static void MarshalFree(IntPtr ptr, bool globalAlloc);
    private void InitializeSecureString(Char* value, int length);
    private void DisposeCore();
    private void EnsureNotDisposed();
    private void ClearCore();
    private void AppendCharCore(char c);
    private void InsertAtCore(int index, char c);
    private void RemoveAtCore(int index);
    private void SetAtCore(int index, char c);
    internal IntPtr MarshalToBSTR();
    internal IntPtr MarshalToStringCore(bool globalAlloc, bool unicode);
    private void EnsureCapacity(int capacity);
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityCriticalScope <Scope>k__BackingField;
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    [CompilerGeneratedAttribute]
public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.SecurityException : SystemException {
    [CompilerGeneratedAttribute]
private object <Demanded>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DenySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <FailedAssemblyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GrantedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PermissionType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <PermitOnlySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefusedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    protected SecurityException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_Demanded();
    [CompilerGeneratedAttribute]
public void set_Demanded(object value);
    [CompilerGeneratedAttribute]
public object get_DenySetInstance();
    [CompilerGeneratedAttribute]
public void set_DenySetInstance(object value);
    [CompilerGeneratedAttribute]
public AssemblyName get_FailedAssemblyInfo();
    [CompilerGeneratedAttribute]
public void set_FailedAssemblyInfo(AssemblyName value);
    [CompilerGeneratedAttribute]
public string get_GrantedSet();
    [CompilerGeneratedAttribute]
public void set_GrantedSet(string value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public string get_PermissionState();
    [CompilerGeneratedAttribute]
public void set_PermissionState(string value);
    [CompilerGeneratedAttribute]
public Type get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(Type value);
    [CompilerGeneratedAttribute]
public object get_PermitOnlySetInstance();
    [CompilerGeneratedAttribute]
public void set_PermitOnlySetInstance(object value);
    [CompilerGeneratedAttribute]
public string get_RefusedSet();
    [CompilerGeneratedAttribute]
public void set_RefusedSet(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipVerificationInFullTrust>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityRuleSet <RuleSet>k__BackingField;
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    [CompilerGeneratedAttribute]
public bool get_SkipVerificationInFullTrust();
    [CompilerGeneratedAttribute]
public void set_SkipVerificationInFullTrust(bool value);
    [CompilerGeneratedAttribute]
public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    protected VerificationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
internal class System.SharedStatics : object {
    private static SharedStatics _sharedStatics;
    private long _memFailPointReservedMemory;
    internal static long AddMemoryFailPointReservation(long size);
}
internal class System.Signature : object {
    internal RuntimeType[] m_arguments;
    internal RuntimeType m_declaringType;
    internal RuntimeType m_returnTypeORfieldType;
    internal object m_keepalive;
    internal Void* m_sig;
    internal int m_managedCallingConventionAndArgIteratorFlags;
    internal int m_nSizeOfArgStack;
    internal int m_csig;
    internal RuntimeMethodHandleInternal m_pMethod;
    internal CallingConventions CallingConvention { get; }
    internal RuntimeType[] Arguments { get; }
    internal RuntimeType ReturnType { get; }
    internal RuntimeType FieldType { get; }
    public Signature(IRuntimeMethodInfo method, RuntimeType[] arguments, RuntimeType returnType, CallingConventions callingConvention);
    public Signature(IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    public Signature(IRuntimeFieldInfo fieldHandle, RuntimeType declaringType);
    public Signature(Void* pCorSig, int cCorSig, RuntimeType declaringType);
    private void GetSignature(Void* pCorSig, int cCorSig, RuntimeFieldHandleInternal fieldHandle, IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    internal CallingConventions get_CallingConvention();
    internal RuntimeType[] get_Arguments();
    internal RuntimeType get_ReturnType();
    internal RuntimeType get_FieldType();
    internal static bool CompareSig(Signature sig1, Signature sig2);
    internal Type[] GetCustomModifiers(int position, bool required);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Single : ValueType {
    private float m_value;
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    [NonVersionableAttribute]
public static bool IsFinite(float f);
    [NonVersionableAttribute]
public static bool IsInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNaN(float f);
    [NonVersionableAttribute]
public static bool IsNegative(float f);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNormal(float f);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(float f);
    [NonVersionableAttribute]
public static bool IsSubnormal(float f);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    [NonVersionableAttribute]
public static bool op_Equality(float left, float right);
    [NonVersionableAttribute]
public static bool op_Inequality(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(float left, float right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, IFormatProvider provider);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[IsReadOnlyAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
[IsByRefLikeAttribute]
public class System.Span`1 : ValueType {
    internal ByReference`1<T> _pointer;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static Span`1<T> Empty { get; }
    public T& Item { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(T& ptr, int length);
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public T& get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    public static int IndexOfCultureHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static int IndexOfCultureIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static int IndexOfOrdinalHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, bool ignoreCase);
    public static bool StartsWithCultureHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool StartsWithCultureIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool StartsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    public static bool EndsWithCultureHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool EndsWithCultureIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, CompareInfo compareInfo);
    public static bool EndsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    public static void ClearWithoutReferences(Byte& b, ulong byteLength);
    public static void ClearWithReferences(IntPtr& ip, ulong pointerSizeLength);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, ulong length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    private static int LocateLastFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    private static int LocateLastFoundByte(ulong match);
    private static Vector`1<byte> GetVector(byte vectorByte);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    private static int LocateFirstFoundChar(Vector`1<ushort> match);
    private static int LocateFirstFoundChar(ulong match);
    private static int LocateLastFoundChar(Vector`1<ushort> match);
    private static int LocateLastFoundChar(ulong match);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
}
internal static class System.SR : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool _resourceManagerInited;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; private set; }
    internal static Type ResourceType { get; }
    internal static string Acc_CreateAbstEx { get; }
    internal static string Acc_CreateArgIterator { get; }
    internal static string Acc_CreateGenericEx { get; }
    internal static string Acc_CreateInterfaceEx { get; }
    internal static string Acc_CreateVoid { get; }
    internal static string Acc_NotClassInit { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string Access_Void { get; }
    internal static string AggregateException_ctor_DefaultMessage { get; }
    internal static string AggregateException_ctor_InnerExceptionNull { get; }
    internal static string AggregateException_DeserializationFailure { get; }
    internal static string AggregateException_InnerException { get; }
    internal static string Arg_AccessException { get; }
    internal static string Arg_AccessViolationException { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string Arg_AppDomainUnloadedException { get; }
    internal static string Arg_ApplicationException { get; }
    internal static string Arg_ArgumentException { get; }
    internal static string Arg_ArgumentOutOfRangeException { get; }
    internal static string Arg_ArithmeticException { get; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_ArrayTypeMismatchException { get; }
    internal static string Arg_ArrayZeroError { get; }
    internal static string Arg_BadDecimal { get; }
    internal static string Arg_BadImageFormatException { get; }
    internal static string Arg_BadLiteralFormat { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string Arg_CannotBeNaN { get; }
    internal static string Arg_CannotHaveNegativeValue { get; }
    internal static string Arg_CATypeResolutionFailed { get; }
    internal static string Arg_COMException { get; }
    internal static string Arg_CreatInstAccess { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_CustomAttributeFormatException { get; }
    internal static string Arg_DataMisalignedException { get; }
    internal static string Arg_DateTimeRange { get; }
    internal static string Arg_DecBitCtor { get; }
    internal static string Arg_DirectoryNotFoundException { get; }
    internal static string Arg_DivideByZero { get; }
    internal static string Arg_DlgtNullInst { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_DlgtTypeMis { get; }
    internal static string Arg_DllNotFoundException { get; }
    internal static string Arg_DuplicateWaitObjectException { get; }
    internal static string Arg_EHClauseNotClause { get; }
    internal static string Arg_EHClauseNotFilter { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string Arg_EndOfStreamException { get; }
    internal static string Arg_EntryPointNotFoundException { get; }
    internal static string Arg_EnumAndObjectMustBeSameType { get; }
    internal static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_EnumLitValueNotFound { get; }
    internal static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumValueNotFound { get; }
    internal static string Arg_ExecutionEngineException { get; }
    internal static string Arg_ExternalException { get; }
    internal static string Arg_FieldAccessException { get; }
    internal static string Arg_FieldDeclTarget { get; }
    internal static string Arg_FldGetArgErr { get; }
    internal static string Arg_FldGetPropSet { get; }
    internal static string Arg_FldSetArgErr { get; }
    internal static string Arg_FldSetGet { get; }
    internal static string Arg_FldSetInvoke { get; }
    internal static string Arg_FldSetPropGet { get; }
    internal static string Arg_FormatException { get; }
    internal static string Arg_GenericParameter { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_GuidArrayCtor { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string Arg_HexStyleNotSupported { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_IndexMustBeInt { get; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_InsufficientExecutionStackException { get; }
    internal static string Arg_InvalidBase { get; }
    internal static string Arg_InvalidCastException { get; }
    internal static string Arg_InvalidComObjectException { get; }
    internal static string Arg_InvalidFilterCriteriaException { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidHexStyle { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc { get; }
    internal static string Arg_InvalidOleVariantTypeException { get; }
    internal static string Arg_InvalidOperationException { get; }
    internal static string Arg_InvalidTypeInRetType { get; }
    internal static string Arg_InvalidTypeInSignature { get; }
    internal static string Arg_IOException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanSrcString { get; }
    internal static string Arg_MarshalAsAnyRestriction { get; }
    internal static string Arg_MarshalDirectiveException { get; }
    internal static string Arg_MethodAccessException { get; }
    internal static string Arg_MissingFieldException { get; }
    internal static string Arg_MissingManifestResourceException { get; }
    internal static string Arg_MissingMemberException { get; }
    internal static string Arg_MissingMethodException { get; }
    internal static string Arg_MulticastNotSupportedException { get; }
    internal static string Arg_MustBeBoolean { get; }
    internal static string Arg_MustBeByte { get; }
    internal static string Arg_MustBeChar { get; }
    internal static string Arg_MustBeDateTime { get; }
    internal static string Arg_MustBeDateTimeOffset { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeDelegate { get; }
    internal static string Arg_MustBeDouble { get; }
    internal static string Arg_MustBeEnum { get; }
    internal static string Arg_MustBeEnumBaseTypeOrEnum { get; }
    internal static string Arg_MustBeGuid { get; }
    internal static string Arg_MustBeInt16 { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeInt64 { get; }
    internal static string Arg_MustBePointer { get; }
    internal static string Arg_MustBePrimArray { get; }
    internal static string Arg_MustBeSByte { get; }
    internal static string Arg_MustBeSingle { get; }
    internal static string Arg_MustBeString { get; }
    internal static string Arg_MustBeTimeSpan { get; }
    internal static string Arg_MustBeType { get; }
    internal static string Arg_MustBeUInt16 { get; }
    internal static string Arg_MustBeUInt32 { get; }
    internal static string Arg_MustBeUInt64 { get; }
    internal static string Arg_MustBeVersion { get; }
    internal static string Arg_NamedParamNull { get; }
    internal static string Arg_NamedParamTooBig { get; }
    internal static string Arg_NDirectBadObject { get; }
    internal static string Arg_NegativeArgCount { get; }
    internal static string Arg_NoAccessSpec { get; }
    internal static string Arg_NoDefCTor { get; }
    internal static string Arg_NoStaticVirtual { get; }
    internal static string Arg_NotFiniteNumberException { get; }
    internal static string Arg_NotGenericMethodDefinition { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_NotGenericTypeDefinition { get; }
    internal static string Arg_NotImplementedException { get; }
    internal static string Arg_NotSupportedException { get; }
    internal static string Arg_NullReferenceException { get; }
    internal static string Arg_ObjObjEx { get; }
    internal static string Arg_OleAutDateInvalid { get; }
    internal static string Arg_OleAutDateScale { get; }
    internal static string Arg_OverflowException { get; }
    internal static string Arg_ParamName_Name { get; }
    internal static string Arg_ParmArraySize { get; }
    internal static string Arg_ParmCnt { get; }
    internal static string Arg_PathEmpty { get; }
    internal static string Arg_PlatformNotSupported { get; }
    internal static string Arg_PropSetGet { get; }
    internal static string Arg_PropSetInvoke { get; }
    internal static string Arg_RankException { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_ReflectionOnlyCA { get; }
    internal static string Arg_ReflectionOnlyField { get; }
    internal static string Arg_ReflectionOnlyInvoke { get; }
    internal static string Arg_ResMgrNotResSet { get; }
    internal static string Arg_ResourceFileUnsupportedVersion { get; }
    internal static string Arg_ResourceNameNotExist { get; }
    internal static string Arg_SafeArrayRankMismatchException { get; }
    internal static string Arg_SafeArrayTypeMismatchException { get; }
    internal static string Arg_SecurityException { get; }
    internal static string SerializationException { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_StackOverflowException { get; }
    internal static string Arg_SurrogatesNotAllowedAsSingleChar { get; }
    internal static string Arg_SynchronizationLockException { get; }
    internal static string Arg_SystemException { get; }
    internal static string Arg_TargetInvocationException { get; }
    internal static string Arg_TargetParameterCountException { get; }
    internal static string Arg_ThreadStartException { get; }
    internal static string Arg_ThreadStateException { get; }
    internal static string Arg_TimeoutException { get; }
    internal static string Arg_TypeAccessException { get; }
    internal static string Arg_TypedReference_Null { get; }
    internal static string Arg_TypeLoadException { get; }
    internal static string Arg_TypeLoadNullStr { get; }
    internal static string Arg_TypeRefPrimitve { get; }
    internal static string Arg_TypeUnloadedException { get; }
    internal static string Arg_UnauthorizedAccessException { get; }
    internal static string Arg_UnboundGenField { get; }
    internal static string Arg_UnboundGenParam { get; }
    internal static string Arg_UnknownTypeCode { get; }
    internal static string Arg_VarMissNull { get; }
    internal static string Arg_VersionString { get; }
    internal static string Arg_WrongAsyncResult { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AbsolutePathRequired { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_AdjustmentRulesNoNulls { get; }
    internal static string Argument_AdjustmentRulesOutOfOrder { get; }
    internal static string Argument_ArrayGetInterfaceMap { get; }
    internal static string Argument_ArraysInvalid { get; }
    internal static string Argument_BadAttributeOnInterfaceMethod { get; }
    internal static string Argument_BadConstructor { get; }
    internal static string Argument_BadConstructorCallConv { get; }
    internal static string Argument_BadExceptionCodeGen { get; }
    internal static string Argument_BadFieldForConstructorBuilder { get; }
    internal static string Argument_BadFieldSig { get; }
    internal static string Argument_BadFieldType { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_BadImageFormatExceptionResolve { get; }
    internal static string Argument_BadLabel { get; }
    internal static string Argument_BadLabelContent { get; }
    internal static string Argument_BadNestedTypeFlags { get; }
    internal static string Argument_BadParameterCountsForConstructor { get; }
    internal static string Argument_BadParameterTypeForCAB { get; }
    internal static string Argument_BadPropertyForConstructorBuilder { get; }
    internal static string Argument_BadSigFormat { get; }
    internal static string Argument_BadSizeForData { get; }
    internal static string Argument_BadTypeAttrInvalidLayout { get; }
    internal static string Argument_BadTypeAttrNestedVisibilityOnNonNestedType { get; }
    internal static string Argument_BadTypeAttrNonNestedVisibilityNestedType { get; }
    internal static string Argument_BadTypeAttrReservedBitsSet { get; }
    internal static string Argument_BadTypeInCustomAttribute { get; }
    internal static string Argument_CannotGetTypeTokenForByRef { get; }
    internal static string Argument_CannotSetParentToInterface { get; }
    internal static string Argument_CodepageNotSupported { get; }
    internal static string Argument_CompareOptionOrdinal { get; }
    internal static string Argument_ConflictingDateTimeRoundtripStyles { get; }
    internal static string Argument_ConflictingDateTimeStyles { get; }
    internal static string Argument_ConstantDoesntMatch { get; }
    internal static string Argument_ConstantNotSupported { get; }
    internal static string Argument_ConstantNull { get; }
    internal static string Argument_ConstructorNeedGenericDeclaringType { get; }
    internal static string Argument_ConversionOverflow { get; }
    internal static string Argument_ConvertMismatch { get; }
    internal static string Argument_CultureIetfNotSupported { get; }
    internal static string Argument_CultureInvalidIdentifier { get; }
    internal static string Argument_CultureIsNeutral { get; }
    internal static string Argument_CultureNotSupported { get; }
    internal static string Argument_CustomAssemblyLoadContextRequestedNameMismatch { get; }
    internal static string Argument_CustomCultureCannotBePassedByNumber { get; }
    internal static string Argument_DateTimeBadBinaryData { get; }
    internal static string Argument_DateTimeHasTicks { get; }
    internal static string Argument_DateTimeHasTimeOfDay { get; }
    internal static string Argument_DateTimeIsInvalid { get; }
    internal static string Argument_DateTimeIsNotAmbiguous { get; }
    internal static string Argument_DateTimeKindMustBeUnspecified { get; }
    internal static string Argument_DateTimeKindMustBeUnspecifiedOrUtc { get; }
    internal static string Argument_DateTimeOffsetInvalidDateTimeStyles { get; }
    internal static string Argument_DateTimeOffsetIsNotAmbiguous { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_DuplicateTypeName { get; }
    internal static string Argument_EmitWriteLineType { get; }
    internal static string Argument_EmptyDecString { get; }
    internal static string Argument_EmptyName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_EmptyWaithandleArray { get; }
    internal static string Argument_EncoderFallbackNotEmpty { get; }
    internal static string Argument_EncodingConversionOverflowBytes { get; }
    internal static string Argument_EncodingConversionOverflowChars { get; }
    internal static string Argument_EncodingNotSupported { get; }
    internal static string Argument_EnumTypeDoesNotMatch { get; }
    internal static string Argument_FallbackBufferNotEmpty { get; }
    internal static string Argument_FieldDeclaringTypeGeneric { get; }
    internal static string Argument_FieldNeedGenericDeclaringType { get; }
    internal static string Argument_GenConstraintViolation { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_GenericsInvalid { get; }
    internal static string Argument_GlobalFunctionHasToBeStatic { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string Argument_IdnBadBidi { get; }
    internal static string Argument_IdnBadLabelSize { get; }
    internal static string Argument_IdnBadNameSize { get; }
    internal static string Argument_IdnBadPunycode { get; }
    internal static string Argument_IdnBadStd3 { get; }
    internal static string Argument_IdnIllegalName { get; }
    internal static string Argument_IllegalEnvVarName { get; }
    internal static string Argument_IllegalName { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string Argument_InvalidArrayLength { get; }
    internal static string Argument_InvalidCalendar { get; }
    internal static string Argument_InvalidCharSequence { get; }
    internal static string Argument_InvalidCharSequenceNoIndex { get; }
    internal static string Argument_InvalidCodePageBytesIndex { get; }
    internal static string Argument_InvalidCodePageConversionIndex { get; }
    internal static string Argument_InvalidConstructorDeclaringType { get; }
    internal static string Argument_InvalidConstructorInfo { get; }
    internal static string Argument_InvalidCultureName { get; }
    internal static string Argument_InvalidDateTimeKind { get; }
    internal static string Argument_InvalidDateTimeStyles { get; }
    internal static string Argument_InvalidDigitSubstitution { get; }
    internal static string Argument_InvalidEnum { get; }
    internal static string Argument_InvalidEnumValue { get; }
    internal static string Argument_InvalidFieldDeclaringType { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidGenericInstArray { get; }
    internal static string Argument_InvalidGroupSize { get; }
    internal static string Argument_InvalidHandle { get; }
    internal static string Argument_InvalidHighSurrogate { get; }
    internal static string Argument_InvalidId { get; }
    internal static string Argument_InvalidKindOfTypeForCA { get; }
    internal static string Argument_InvalidLabel { get; }
    internal static string Argument_InvalidLowSurrogate { get; }
    internal static string Argument_InvalidMemberForNamedArgument { get; }
    internal static string Argument_InvalidMethodDeclaringType { get; }
    internal static string Argument_InvalidName { get; }
    internal static string Argument_InvalidNativeDigitCount { get; }
    internal static string Argument_InvalidNativeDigitValue { get; }
    internal static string Argument_InvalidNeutralRegionName { get; }
    internal static string Argument_InvalidNormalizationForm { get; }
    internal static string Argument_InvalidNumberStyles { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOpCodeOnDynamicMethod { get; }
    internal static string Argument_InvalidParameterInfo { get; }
    internal static string Argument_InvalidParamInfo { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidResourceCultureName { get; }
    internal static string Argument_InvalidSafeBufferOffLen { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSerializedString { get; }
    internal static string Argument_InvalidStartupHookSyntax { get; }
    internal static string Argument_InvalidStartupHookSignature { get; }
    internal static string Argument_InvalidTimeSpanStyles { get; }
    internal static string Argument_InvalidToken { get; }
    internal static string Argument_InvalidTypeForCA { get; }
    internal static string Argument_InvalidTypeForDynamicMethod { get; }
    internal static string Argument_InvalidTypeName { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_InvalidUnity { get; }
    internal static string Argument_LargeInteger { get; }
    internal static string Argument_LongEnvVarValue { get; }
    internal static string Argument_MethodDeclaringTypeGeneric { get; }
    internal static string Argument_MethodDeclaringTypeGenericLcg { get; }
    internal static string Argument_MethodNeedGenericDeclaringType { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string Argument_MismatchedArrays { get; }
    internal static string Argument_MissingDefaultConstructor { get; }
    internal static string Argument_MustBeFalse { get; }
    internal static string Argument_MustBeRuntimeAssembly { get; }
    internal static string Argument_MustBeRuntimeFieldInfo { get; }
    internal static string Argument_MustBeRuntimeMethodInfo { get; }
    internal static string Argument_MustBeRuntimeReflectionObject { get; }
    internal static string Argument_MustBeRuntimeType { get; }
    internal static string Argument_MustBeTypeBuilder { get; }
    internal static string Argument_MustHaveAttributeBaseClass { get; }
    internal static string Argument_NativeOverlappedAlreadyFree { get; }
    internal static string Argument_NativeOverlappedWrongBoundHandle { get; }
    internal static string Argument_NeedGenericMethodDefinition { get; }
    internal static string Argument_NeedNonGenericType { get; }
    internal static string Argument_NeedStructWithNoRefs { get; }
    internal static string Argument_NeverValidGenericArgument { get; }
    internal static string Argument_NoEra { get; }
    internal static string Argument_NoModuleFileExtension { get; }
    internal static string Argument_NoRegionInvariantCulture { get; }
    internal static string Argument_NotAWritableProperty { get; }
    internal static string Argument_NotEnoughBytesToRead { get; }
    internal static string Argument_NotEnoughBytesToWrite { get; }
    internal static string Argument_NotEnoughGenArguments { get; }
    internal static string Argument_NotExceptionType { get; }
    internal static string Argument_NotInExceptionBlock { get; }
    internal static string Argument_NotMethodCallOpcode { get; }
    internal static string Argument_NotSerializable { get; }
    internal static string Argument_OffsetAndCapacityOutOfBounds { get; }
    internal static string Argument_OffsetLocalMismatch { get; }
    internal static string Argument_OffsetOfFieldNotFound { get; }
    internal static string Argument_OffsetOutOfRange { get; }
    internal static string Argument_OffsetPrecision { get; }
    internal static string Argument_OffsetUtcMismatch { get; }
    internal static string Argument_OneOfCulturesNotSupported { get; }
    internal static string Argument_OnlyMscorlib { get; }
    internal static string Argument_OutOfOrderDateTimes { get; }
    internal static string Argument_PreAllocatedAlreadyAllocated { get; }
    internal static string Argument_RecursiveFallback { get; }
    internal static string Argument_RecursiveFallbackBytes { get; }
    internal static string Argument_RedefinedLabel { get; }
    internal static string Argument_ResolveField { get; }
    internal static string Argument_ResolveFieldHandle { get; }
    internal static string Argument_ResolveMember { get; }
    internal static string Argument_ResolveMethod { get; }
    internal static string Argument_ResolveMethodHandle { get; }
    internal static string Argument_ResolveModuleType { get; }
    internal static string Argument_ResolveString { get; }
    internal static string Argument_ResolveType { get; }
    internal static string Argument_ResultCalendarRange { get; }
    internal static string Argument_SemaphoreInitialMaximum { get; }
    internal static string Argument_ShouldNotSpecifyExceptionType { get; }
    internal static string Argument_ShouldOnlySetVisibilityFlags { get; }
    internal static string Argument_SigIsFinalized { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Argument_StringFirstCharIsZero { get; }
    internal static string Argument_StringZeroLength { get; }
    internal static string Argument_TimeSpanHasSeconds { get; }
    internal static string Argument_TimeZoneInfoBadTZif { get; }
    internal static string Argument_TimeZoneInfoInvalidTZif { get; }
    internal static string Argument_ToExclusiveLessThanFromExclusive { get; }
    internal static string Argument_TooManyFinallyClause { get; }
    internal static string Argument_TransitionTimesAreIdentical { get; }
    internal static string Argument_TypedReferenceInvalidField { get; }
    internal static string Argument_TypeMustNotBeComImport { get; }
    internal static string Argument_TypeNameTooLong { get; }
    internal static string Argument_TypeNotValid { get; }
    internal static string Argument_UnclosedExceptionBlock { get; }
    internal static string Argument_UnknownUnmanagedCallConv { get; }
    internal static string Argument_UnmanagedMemAccessorWrapAround { get; }
    internal static string Argument_UnmatchedMethodForLocal { get; }
    internal static string Argument_UnmatchingSymScope { get; }
    internal static string Argument_UTCOutOfRange { get; }
    internal static string Argument_WaitHandleNameTooLong { get; }
    internal static string ArgumentException_BadMethodImplBody { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    internal static string ArgumentException_TupleIncorrectType { get; }
    internal static string ArgumentException_TupleLastArgumentNotATuple { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    internal static string ArgumentNull_Array { get; }
    internal static string ArgumentNull_ArrayElement { get; }
    internal static string ArgumentNull_ArrayValue { get; }
    internal static string ArgumentNull_Assembly { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentNull_Generic { get; }
    internal static string ArgumentNull_Key { get; }
    internal static string ArgumentNull_Obj { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentNull_Stream { get; }
    internal static string ArgumentNull_String { get; }
    internal static string ArgumentNull_Waithandles { get; }
    internal static string ArgumentOutOfRange_ActualValue { get; }
    internal static string ArgumentOutOfRange_AddressSpace { get; }
    internal static string ArgumentOutOfRange_AddValue { get; }
    internal static string ArgumentOutOfRange_BadHourMinuteSecond { get; }
    internal static string ArgumentOutOfRange_BadYearMonthDay { get; }
    internal static string ArgumentOutOfRange_BinaryReaderFillBuffer { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper { get; }
    internal static string ArgumentOutOfRange_CalendarRange { get; }
    internal static string ArgumentOutOfRange_Capacity { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_DateArithmetic { get; }
    internal static string ArgumentOutOfRange_DateTimeBadMonths { get; }
    internal static string ArgumentOutOfRange_DateTimeBadTicks { get; }
    internal static string ArgumentOutOfRange_DateTimeBadYears { get; }
    internal static string ArgumentOutOfRange_Day { get; }
    internal static string ArgumentOutOfRange_DayOfWeek { get; }
    internal static string ArgumentOutOfRange_DayParam { get; }
    internal static string ArgumentOutOfRange_DecimalRound { get; }
    internal static string ArgumentOutOfRange_DecimalScale { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_Era { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string ArgumentOutOfRange_FileTimeInvalid { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_GetByteCountOverflow { get; }
    internal static string ArgumentOutOfRange_GetCharCountOverflow { get; }
    internal static string ArgumentOutOfRange_HashtableLoadFactor { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_IndexCount { get; }
    internal static string ArgumentOutOfRange_IndexCountBuffer { get; }
    internal static string ArgumentOutOfRange_IndexLength { get; }
    internal static string ArgumentOutOfRange_IndexString { get; }
    internal static string ArgumentOutOfRange_InvalidEraValue { get; }
    internal static string ArgumentOutOfRange_InvalidHighSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidLowSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidUTF32 { get; }
    internal static string ArgumentOutOfRange_Length { get; }
    internal static string ArgumentOutOfRange_LengthGreaterThanCapacity { get; }
    internal static string ArgumentOutOfRange_LengthTooLarge { get; }
    internal static string ArgumentOutOfRange_LessEqualToIntegerMaxVal { get; }
    internal static string ArgumentOutOfRange_Month { get; }
    internal static string ArgumentOutOfRange_MonthParam { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegInt32 { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string ArgumentOutOfRange_NegativeCapacity { get; }
    internal static string ArgumentOutOfRange_NegativeCount { get; }
    internal static string ArgumentOutOfRange_NegativeLength { get; }
    internal static string ArgumentOutOfRange_OffsetLength { get; }
    internal static string ArgumentOutOfRange_OffsetOut { get; }
    internal static string ArgumentOutOfRange_ParamSequence { get; }
    internal static string ArgumentOutOfRange_PartialWCHAR { get; }
    internal static string ArgumentOutOfRange_PeriodTooLarge { get; }
    internal static string ArgumentOutOfRange_PositionLessThanCapacityRequired { get; }
    internal static string ArgumentOutOfRange_Range { get; }
    internal static string ArgumentOutOfRange_RoundingDigits { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string ArgumentOutOfRange_SmallMaxCapacity { get; }
    internal static string ArgumentOutOfRange_StartIndex { get; }
    internal static string ArgumentOutOfRange_StartIndexLargerThanLength { get; }
    internal static string ArgumentOutOfRange_StartIndexLessThanLength { get; }
    internal static string ArgumentOutOfRange_StreamLength { get; }
    internal static string ArgumentOutOfRange_TimeoutTooLarge { get; }
    internal static string ArgumentOutOfRange_UIntPtrMax { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamLength { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround { get; }
    internal static string ArgumentOutOfRange_UtcOffset { get; }
    internal static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta { get; }
    internal static string ArgumentOutOfRange_Version { get; }
    internal static string ArgumentOutOfRange_Week { get; }
    internal static string ArgumentOutOfRange_Year { get; }
    internal static string Arithmetic_NaN { get; }
    internal static string Arugment_EmitMixedContext1 { get; }
    internal static string Arugment_EmitMixedContext2 { get; }
    internal static string BadImageFormat_BadILFormat { get; }
    internal static string BadImageFormat_InvalidType { get; }
    internal static string BadImageFormat_NegativeStringLength { get; }
    internal static string BadImageFormat_ParameterSignatureMismatch { get; }
    internal static string BadImageFormat_ResourceDataLengthInvalid { get; }
    internal static string BadImageFormat_ResourceNameCorrupted { get; }
    internal static string BadImageFormat_ResourceNameCorrupted_NameIndex { get; }
    internal static string BadImageFormat_ResourcesDataInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesHeaderCorrupted { get; }
    internal static string BadImageFormat_ResourcesIndexTooLong { get; }
    internal static string BadImageFormat_ResourcesNameInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesNameTooLong { get; }
    internal static string BadImageFormat_TypeMismatch { get; }
    internal static string CancellationToken_CreateLinkedToken_TokensIsEmpty { get; }
    internal static string CancellationTokenSource_Disposed { get; }
    internal static string EventSource_AbstractMustNotDeclareEventMethods { get; }
    internal static string EventSource_AbstractMustNotDeclareKTOC { get; }
    internal static string EventSource_AddScalarOutOfRange { get; }
    internal static string EventSource_BadHexDigit { get; }
    internal static string EventSource_ChannelTypeDoesNotMatchEventChannelValue { get; }
    internal static string EventSource_DataDescriptorsOutOfRange { get; }
    internal static string EventSource_DuplicateStringKey { get; }
    internal static string EventSource_EnumKindMismatch { get; }
    internal static string EventSource_EvenHexDigits { get; }
    internal static string EventSource_EventChannelOutOfRange { get; }
    internal static string EventSource_EventIdReused { get; }
    internal static string EventSource_EventMustHaveTaskIfNonDefaultOpcode { get; }
    internal static string EventSource_EventMustNotBeExplicitImplementation { get; }
    internal static string EventSource_EventNameReused { get; }
    internal static string EventSource_EventParametersMismatch { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_EventTooBig { get; }
    internal static string EventSource_EventWithAdminChannelMustHaveMessage { get; }
    internal static string EventSource_IllegalKeywordsValue { get; }
    internal static string EventSource_IllegalOpcodeValue { get; }
    internal static string EventSource_IllegalTaskValue { get; }
    internal static string EventSource_IllegalValue { get; }
    internal static string EventSource_IncorrentlyAuthoredTypeInfo { get; }
    internal static string EventSource_InvalidCommand { get; }
    internal static string EventSource_InvalidEventFormat { get; }
    internal static string EventSource_KeywordCollision { get; }
    internal static string EventSource_KeywordNeedPowerOfTwo { get; }
    internal static string EventSource_ListenerCreatedInsideCallback { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_MaxChannelExceeded { get; }
    internal static string EventSource_MismatchIdToWriteEvent { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedPositiveId { get; }
    internal static string EventSource_NoFreeBuffers { get; }
    internal static string EventSource_NonCompliantTypeError { get; }
    internal static string EventSource_NoRelatedActivityId { get; }
    internal static string EventSource_NotSupportedArrayOfBinary { get; }
    internal static string EventSource_NotSupportedArrayOfNil { get; }
    internal static string EventSource_NotSupportedArrayOfNullTerminatedString { get; }
    internal static string EventSource_NotSupportedNestedArraysEnums { get; }
    internal static string EventSource_NullInput { get; }
    internal static string EventSource_OpcodeCollision { get; }
    internal static string EventSource_PinArrayOutOfRange { get; }
    internal static string EventSource_RecursiveTypeDefinition { get; }
    internal static string EventSource_StopsFollowStarts { get; }
    internal static string EventSource_TaskCollision { get; }
    internal static string EventSource_TaskOpcodePairReused { get; }
    internal static string EventSource_TooManyArgs { get; }
    internal static string EventSource_TooManyFields { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_TraitEven { get; }
    internal static string EventSource_TypeMustBeSealedOrAbstract { get; }
    internal static string EventSource_TypeMustDeriveFromEventSource { get; }
    internal static string EventSource_UndefinedChannel { get; }
    internal static string EventSource_UndefinedKeyword { get; }
    internal static string EventSource_UndefinedOpcode { get; }
    internal static string EventSource_UnknownEtwTrait { get; }
    internal static string EventSource_UnsupportedMessageProperty { get; }
    internal static string EventSource_VarArgsParameterMismatch { get; }
    internal static string Exception_EndOfInnerExceptionStack { get; }
    internal static string Exception_EndStackTraceFromPreviousThrow { get; }
    internal static string Exception_WasThrown { get; }
    internal static string ExecutionContext_ExceptionInAsyncLocalNotification { get; }
    internal static string FieldAccess_InitOnly { get; }
    internal static string FileNotFound_ResolveAssembly { get; }
    internal static string Format_AttributeUsage { get; }
    internal static string Format_Bad7BitInt32 { get; }
    internal static string Format_BadBase64Char { get; }
    internal static string Format_BadBoolean { get; }
    internal static string Format_BadFormatSpecifier { get; }
    internal static string Format_BadQuote { get; }
    internal static string Format_EmptyInputString { get; }
    internal static string Format_ExtraJunkAtEnd { get; }
    internal static string Format_GuidUnrecognized { get; }
    internal static string Format_IndexOutOfRange { get; }
    internal static string Format_InvalidEnumFormatSpecification { get; }
    internal static string Format_InvalidGuidFormatSpecification { get; }
    internal static string Format_InvalidString { get; }
    internal static string Format_NeedSingleChar { get; }
    internal static string Format_NoParsibleDigits { get; }
    internal static string Format_StringZeroLength { get; }
    internal static string IndexOutOfRange_UMSPosition { get; }
    internal static string Interop_Marshal_Unmappable_Char { get; }
    internal static string InvalidCast_CannotCastNullToValueType { get; }
    internal static string InvalidCast_DBNull { get; }
    internal static string InvalidCast_Empty { get; }
    internal static string InvalidCast_FromDBNull { get; }
    internal static string InvalidCast_FromTo { get; }
    internal static string InvalidCast_IConvertible { get; }
    internal static string InvalidOperation_AsyncFlowCtrlCtxMismatch { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string InvalidOperation_BadEmptyMethodBody { get; }
    internal static string InvalidOperation_BadILGeneratorUsage { get; }
    internal static string InvalidOperation_BadInstructionOrIndexOutOfBound { get; }
    internal static string InvalidOperation_BadInterfaceNotAbstract { get; }
    internal static string InvalidOperation_BadMethodBody { get; }
    internal static string InvalidOperation_BadTypeAttributesNotAbstract { get; }
    internal static string InvalidOperation_CalledTwice { get; }
    internal static string InvalidOperation_CannotImportGlobalFromDifferentModule { get; }
    internal static string InvalidOperation_CannotRestoreUnsupressedFlow { get; }
    internal static string InvalidOperation_CannotSupressFlowMultipleTimes { get; }
    internal static string InvalidOperation_CannotUseAFCMultiple { get; }
    internal static string InvalidOperation_CannotUseAFCOtherThread { get; }
    internal static string InvalidOperation_CollectionCorrupted { get; }
    internal static string InvalidOperation_ConstructorNotAllowedOnInterface { get; }
    internal static string InvalidOperation_DateTimeParsing { get; }
    internal static string InvalidOperation_DefaultConstructorILGen { get; }
    internal static string InvalidOperation_EndReadCalledMultiple { get; }
    internal static string InvalidOperation_EndWriteCalledMultiple { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_EventInfoNotAvailable { get; }
    internal static string InvalidOperation_GenericParametersAlreadySet { get; }
    internal static string InvalidOperation_GlobalsHaveBeenCreated { get; }
    internal static string InvalidOperation_HandleIsNotPinned { get; }
    internal static string InvalidOperation_HashInsertFailed { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string InvalidOperation_MethodBaked { get; }
    internal static string InvalidOperation_MethodBuilderBaked { get; }
    internal static string InvalidOperation_MethodHasBody { get; }
    internal static string InvalidOperation_MustCallInitialize { get; }
    internal static string InvalidOperation_NativeOverlappedReused { get; }
    internal static string InvalidOperation_NoMultiModuleAssembly { get; }
    internal static string InvalidOperation_NoPublicAddMethod { get; }
    internal static string InvalidOperation_NoPublicRemoveMethod { get; }
    internal static string InvalidOperation_NotADebugModule { get; }
    internal static string InvalidOperation_NotAllowedInDynamicMethod { get; }
    internal static string InvalidOperation_NotAllowedInReflectionOnly { get; }
    internal static string InvalidOperation_NotAVarArgCallingConvention { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string InvalidOperation_NotWithConcurrentGC { get; }
    internal static string InvalidOperation_NoUnderlyingTypeOnEnum { get; }
    internal static string InvalidOperation_NullContext { get; }
    internal static string InvalidOperation_NullModuleHandle { get; }
    internal static string InvalidOperation_OpenLocalVariableScope { get; }
    internal static string InvalidOperation_Overlapped_Pack { get; }
    internal static string InvalidOperation_PropertyInfoNotAvailable { get; }
    internal static string InvalidOperation_ReadOnly { get; }
    internal static string InvalidOperation_ResMgrBadResSet_Type { get; }
    internal static string InvalidOperation_ResourceNotStream_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Type { get; }
    internal static string InvalidOperation_ShouldNotHaveMethodBody { get; }
    internal static string InvalidOperation_ThreadWrongThreadStart { get; }
    internal static string InvalidOperation_TimeoutsNotSupported { get; }
    internal static string InvalidOperation_TypeHasBeenCreated { get; }
    internal static string InvalidOperation_TypeNotCreated { get; }
    internal static string InvalidOperation_UnknownEnumType { get; }
    internal static string InvalidOperation_WriteOnce { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple { get; }
    internal static string InvalidProgram_Default { get; }
    internal static string InvalidTimeZone_InvalidFileData { get; }
    internal static string InvalidTimeZone_InvalidJulianDay { get; }
    internal static string InvalidTimeZone_NJulianDayNotSupported { get; }
    internal static string InvalidTimeZone_NoTTInfoStructures { get; }
    internal static string InvalidTimeZone_UnparseablePosixMDateString { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileLoad { get; }
    internal static string IO_FileName_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileStreamHandlePosition { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_FixedCapacity { get; }
    internal static string IO_InvalidStringLen_Len { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_StreamTooLong { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_PathTooLong_Path { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string Lazy_CreateValue_NoParameterlessCtorForT { get; }
    internal static string Lazy_ctor_ModeInvalid { get; }
    internal static string Lazy_StaticInit_InvalidOperation { get; }
    internal static string Lazy_ToString_ValueNotCreated { get; }
    internal static string Lazy_Value_RecursiveCallsToValue { get; }
    internal static string ManualResetEventSlim_ctor_SpinCountOutOfRange { get; }
    internal static string ManualResetEventSlim_ctor_TooManyWaiters { get; }
    internal static string ManualResetEventSlim_Disposed { get; }
    internal static string Marshaler_StringTooLong { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MissingField { get; }
    internal static string MissingField_Name { get; }
    internal static string MissingManifestResource_MultipleBlobs { get; }
    internal static string MissingManifestResource_NoNeutralAsm { get; }
    internal static string MissingManifestResource_NoNeutralDisk { get; }
    internal static string MissingMember { get; }
    internal static string MissingMember_Name { get; }
    internal static string MissingMemberNestErr { get; }
    internal static string MissingMemberTypeRef { get; }
    internal static string MissingMethod_Name { get; }
    internal static string MissingSatelliteAssembly_Culture_Name { get; }
    internal static string MissingSatelliteAssembly_Default { get; }
    internal static string Multicast_Combine { get; }
    internal static string MustUseCCRewrite { get; }
    internal static string NotImplemented_ResourcesLongerThanInt64Max { get; }
    internal static string NotSupported_AbstractNonCLS { get; }
    internal static string NotSupported_ActivAttr { get; }
    internal static string NotSupported_AssemblyLoadFromHash { get; }
    internal static string NotSupported_ByRefReturn { get; }
    internal static string NotSupported_CallToVarArg { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string NotSupported_ChangeType { get; }
    internal static string NotSupported_CreateInstanceWithTypeBuilder { get; }
    internal static string NotSupported_DBNullSerial { get; }
    internal static string NotSupported_DynamicAssembly { get; }
    internal static string NotSupported_DynamicMethodFlags { get; }
    internal static string NotSupported_DynamicModule { get; }
    internal static string NotSupported_IllegalOneByteBranch { get; }
    internal static string NotSupported_MaxWaitHandles { get; }
    internal static string NotSupported_MemStreamNotExpandable { get; }
    internal static string NotSupported_MustBeModuleBuilder { get; }
    internal static string NotSupported_NoCodepageData { get; }
    internal static string NotSupported_NonReflectedType { get; }
    internal static string NotSupported_NoParentDefaultConstructor { get; }
    internal static string NotSupported_NoTypeInfo { get; }
    internal static string NotSupported_NYI { get; }
    internal static string NotSupported_ObsoleteResourcesFile { get; }
    internal static string NotSupported_OutputStreamUsingTypeBuilder { get; }
    internal static string NotSupported_Reading { get; }
    internal static string NotSupported_ResourceObjectSerialization { get; }
    internal static string NotSupported_StringComparison { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string NotSupported_SymbolMethod { get; }
    internal static string NotSupported_Type { get; }
    internal static string NotSupported_TypeNotYetCreated { get; }
    internal static string NotSupported_UmsSafeBuffer { get; }
    internal static string NotSupported_UnitySerHolder { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string NotSupported_Writing { get; }
    internal static string NotSupported_WrongResourceReader_Type { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string ObjectDisposed_Generic { get; }
    internal static string ObjectDisposed_ObjectName_Name { get; }
    internal static string ObjectDisposed_WriterClosed { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ObjectDisposed_ResourceSet { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string ObjectDisposed_ViewAccessorClosed { get; }
    internal static string OperationCanceled { get; }
    internal static string Overflow_Byte { get; }
    internal static string Overflow_Char { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Double { get; }
    internal static string Overflow_Duration { get; }
    internal static string Overflow_Int16 { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_NegateTwosCompNum { get; }
    internal static string Overflow_NegativeUnsigned { get; }
    internal static string Overflow_SByte { get; }
    internal static string Overflow_Single { get; }
    internal static string Overflow_TimeSpanTooLong { get; }
    internal static string Overflow_UInt16 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string PlatformNotSupported_ArgIterator { get; }
    internal static string PlatformNotSupported_ComInterop { get; }
    internal static string PlatformNotSupported_NamedSynchronizationPrimitives { get; }
    internal static string PlatformNotSupported_OSXFileLocking { get; }
    internal static string PlatformNotSupported_ReflectionOnly { get; }
    internal static string PlatformNotSupported_Remoting { get; }
    internal static string PlatformNotSupported_SecureBinarySerialization { get; }
    internal static string PlatformNotSupported_StrongNameSigning { get; }
    internal static string PlatformNotSupported_OverlappedIO { get; }
    internal static string ResourceReaderIsClosed { get; }
    internal static string Resources_StreamNotValid { get; }
    internal static string RFLCT_AmbigCust { get; }
    internal static string RFLCT_Ambiguous { get; }
    internal static string InvalidFilterCriteriaException_CritInt { get; }
    internal static string InvalidFilterCriteriaException_CritString { get; }
    internal static string RFLCT_InvalidFieldFail { get; }
    internal static string RFLCT_InvalidPropFail { get; }
    internal static string RFLCT_Targ_ITargMismatch { get; }
    internal static string RFLCT_Targ_StatFldReqTarg { get; }
    internal static string RFLCT_Targ_StatMethReqTarg { get; }
    internal static string RuntimeWrappedException { get; }
    internal static string Security_CannotReadFileData { get; }
    internal static string SemaphoreSlim_ctor_InitialCountWrong { get; }
    internal static string SemaphoreSlim_ctor_MaxCountWrong { get; }
    internal static string SemaphoreSlim_Disposed { get; }
    internal static string SemaphoreSlim_Release_CountWrong { get; }
    internal static string SemaphoreSlim_Wait_TimeoutWrong { get; }
    internal static string Serialization_BadParameterInfo { get; }
    internal static string Serialization_CorruptField { get; }
    internal static string Serialization_DateTimeTicksOutOfRange { get; }
    internal static string Serialization_DelegatesNotSupported { get; }
    internal static string Serialization_InsufficientState { get; }
    internal static string Serialization_InvalidData { get; }
    internal static string Serialization_InvalidEscapeSequence { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_InvalidPtrValue { get; }
    internal static string Serialization_InvalidType { get; }
    internal static string Serialization_KeyValueDifferentSizes { get; }
    internal static string Serialization_MissingDateTimeData { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Serialization_NonSerType { get; }
    internal static string Serialization_NoParameterInfo { get; }
    internal static string Serialization_NotFound { get; }
    internal static string Serialization_NullKey { get; }
    internal static string Serialization_OptionalFieldVersionValue { get; }
    internal static string Serialization_SameNameTwice { get; }
    internal static string Serialization_StringBuilderCapacity { get; }
    internal static string Serialization_StringBuilderMaxCapacity { get; }
    internal static string SpinLock_Exit_SynchronizationLockException { get; }
    internal static string SpinLock_IsHeldByCurrentThread { get; }
    internal static string SpinLock_TryEnter_ArgumentOutOfRange { get; }
    internal static string SpinLock_TryEnter_LockRecursionException { get; }
    internal static string SpinLock_TryReliableEnter_ArgumentException { get; }
    internal static string SpinWait_SpinUntil_ArgumentNull { get; }
    internal static string SpinWait_SpinUntil_TimeoutWrong { get; }
    internal static string StackTrace_InFileLineNumber { get; }
    internal static string Task_ContinueWith_ESandLR { get; }
    internal static string Task_FromAsync_LongRunning { get; }
    internal static string Task_FromAsync_PreferFairness { get; }
    internal static string Task_MultiTaskContinuation_EmptyTaskList { get; }
    internal static string Task_MultiTaskContinuation_FireOptions { get; }
    internal static string Task_MultiTaskContinuation_NullTask { get; }
    internal static string TaskCanceledException_ctor_DefaultMessage { get; }
    internal static string TaskExceptionHolder_UnhandledException { get; }
    internal static string TaskExceptionHolder_UnknownExceptionType { get; }
    internal static string TaskScheduler_ExecuteTask_WrongTaskScheduler { get; }
    internal static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent { get; }
    internal static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline { get; }
    internal static string TaskSchedulerException_ctor_DefaultMessage { get; }
    internal static string TaskT_DebuggerNoResult { get; }
    internal static string Threading_AbandonedMutexException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle { get; }
    internal static string Threading_WaitHandleTooManyPosts { get; }
    internal static string Threading_SemaphoreFullException { get; }
    internal static string ThreadLocal_Disposed { get; }
    internal static string ThreadLocal_Value_RecursiveCallsToValue { get; }
    internal static string ThreadLocal_ValuesNotAvailable { get; }
    internal static string TimeZoneNotFound_MissingData { get; }
    internal static string TypeInitialization_Default { get; }
    internal static string TypeInitialization_Type { get; }
    internal static string TypeLoad_ResolveNestedType { get; }
    internal static string TypeLoad_ResolveType { get; }
    internal static string TypeLoad_ResolveTypeFromAssembly { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string Verification_Exception { get; }
    internal static string Word_At { get; }
    internal static string DebugAssertBanner { get; }
    internal static string DebugAssertLongMessage { get; }
    internal static string DebugAssertShortMessage { get; }
    internal static string LockRecursionException_ReadAfterWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveReadNotAllowed { get; }
    internal static string LockRecursionException_RecursiveWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveUpgradeNotAllowed { get; }
    internal static string LockRecursionException_WriteAfterReadNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedUpgrade { get; }
    internal static string SynchronizationLockException_MisMatchedRead { get; }
    internal static string SynchronizationLockException_IncorrectDispose { get; }
    internal static string LockRecursionException_UpgradeAfterReadNotAllowed { get; }
    internal static string LockRecursionException_UpgradeAfterWriteNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedWrite { get; }
    internal static string NotSupported_SignatureType { get; }
    internal static string HashCode_HashCodeNotSupported { get; }
    internal static string HashCode_EqualityNotSupported { get; }
    internal static string Arg_TypeNotSupported { get; }
    internal static string IO_InvalidReadLength { get; }
    internal static string Arg_BasePathNotFullyQualified { get; }
    internal static string Arg_ElementsInSourceIsGreaterThanDestination { get; }
    internal static string Arg_NullArgumentNullRef { get; }
    internal static string Argument_OverlapAlignmentMismatch { get; }
    internal static string Arg_InsufficientNumberOfElements { get; }
    internal static string Arg_MustBeNullTerminatedString { get; }
    private static SR();
    [CompilerGeneratedAttribute]
private static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
private static void set_ResourceManager(ResourceManager value);
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Acc_CreateAbstEx();
    internal static string get_Acc_CreateArgIterator();
    internal static string get_Acc_CreateGenericEx();
    internal static string get_Acc_CreateInterfaceEx();
    internal static string get_Acc_CreateVoid();
    internal static string get_Acc_NotClassInit();
    internal static string get_Acc_ReadOnly();
    internal static string get_Access_Void();
    internal static string get_AggregateException_ctor_DefaultMessage();
    internal static string get_AggregateException_ctor_InnerExceptionNull();
    internal static string get_AggregateException_DeserializationFailure();
    internal static string get_AggregateException_InnerException();
    internal static string get_Arg_AccessException();
    internal static string get_Arg_AccessViolationException();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_Arg_AppDomainUnloadedException();
    internal static string get_Arg_ApplicationException();
    internal static string get_Arg_ArgumentException();
    internal static string get_Arg_ArgumentOutOfRangeException();
    internal static string get_Arg_ArithmeticException();
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_ArrayTypeMismatchException();
    internal static string get_Arg_ArrayZeroError();
    internal static string get_Arg_BadDecimal();
    internal static string get_Arg_BadImageFormatException();
    internal static string get_Arg_BadLiteralFormat();
    internal static string get_Arg_BogusIComparer();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_Arg_CannotBeNaN();
    internal static string get_Arg_CannotHaveNegativeValue();
    internal static string get_Arg_CATypeResolutionFailed();
    internal static string get_Arg_COMException();
    internal static string get_Arg_CreatInstAccess();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_CustomAttributeFormatException();
    internal static string get_Arg_DataMisalignedException();
    internal static string get_Arg_DateTimeRange();
    internal static string get_Arg_DecBitCtor();
    internal static string get_Arg_DirectoryNotFoundException();
    internal static string get_Arg_DivideByZero();
    internal static string get_Arg_DlgtNullInst();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_DlgtTypeMis();
    internal static string get_Arg_DllNotFoundException();
    internal static string get_Arg_DuplicateWaitObjectException();
    internal static string get_Arg_EHClauseNotClause();
    internal static string get_Arg_EHClauseNotFilter();
    internal static string get_Arg_EmptyArray();
    internal static string get_Arg_EndOfStreamException();
    internal static string get_Arg_EntryPointNotFoundException();
    internal static string get_Arg_EnumAndObjectMustBeSameType();
    internal static string get_Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_EnumLitValueNotFound();
    internal static string get_Arg_EnumUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumValueNotFound();
    internal static string get_Arg_ExecutionEngineException();
    internal static string get_Arg_ExternalException();
    internal static string get_Arg_FieldAccessException();
    internal static string get_Arg_FieldDeclTarget();
    internal static string get_Arg_FldGetArgErr();
    internal static string get_Arg_FldGetPropSet();
    internal static string get_Arg_FldSetArgErr();
    internal static string get_Arg_FldSetGet();
    internal static string get_Arg_FldSetInvoke();
    internal static string get_Arg_FldSetPropGet();
    internal static string get_Arg_FormatException();
    internal static string get_Arg_GenericParameter();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_GuidArrayCtor();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_Arg_HexStyleNotSupported();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_IndexMustBeInt();
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_InsufficientExecutionStackException();
    internal static string get_Arg_InvalidBase();
    internal static string get_Arg_InvalidCastException();
    internal static string get_Arg_InvalidComObjectException();
    internal static string get_Arg_InvalidFilterCriteriaException();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidHexStyle();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_Asm_Culture();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_FallbackLoc();
    internal static string get_Arg_InvalidOleVariantTypeException();
    internal static string get_Arg_InvalidOperationException();
    internal static string get_Arg_InvalidTypeInRetType();
    internal static string get_Arg_InvalidTypeInSignature();
    internal static string get_Arg_IOException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanSrcString();
    internal static string get_Arg_MarshalAsAnyRestriction();
    internal static string get_Arg_MarshalDirectiveException();
    internal static string get_Arg_MethodAccessException();
    internal static string get_Arg_MissingFieldException();
    internal static string get_Arg_MissingManifestResourceException();
    internal static string get_Arg_MissingMemberException();
    internal static string get_Arg_MissingMethodException();
    internal static string get_Arg_MulticastNotSupportedException();
    internal static string get_Arg_MustBeBoolean();
    internal static string get_Arg_MustBeByte();
    internal static string get_Arg_MustBeChar();
    internal static string get_Arg_MustBeDateTime();
    internal static string get_Arg_MustBeDateTimeOffset();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeDelegate();
    internal static string get_Arg_MustBeDouble();
    internal static string get_Arg_MustBeEnum();
    internal static string get_Arg_MustBeEnumBaseTypeOrEnum();
    internal static string get_Arg_MustBeGuid();
    internal static string get_Arg_MustBeInt16();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeInt64();
    internal static string get_Arg_MustBePointer();
    internal static string get_Arg_MustBePrimArray();
    internal static string get_Arg_MustBeSByte();
    internal static string get_Arg_MustBeSingle();
    internal static string get_Arg_MustBeString();
    internal static string get_Arg_MustBeTimeSpan();
    internal static string get_Arg_MustBeType();
    internal static string get_Arg_MustBeUInt16();
    internal static string get_Arg_MustBeUInt32();
    internal static string get_Arg_MustBeUInt64();
    internal static string get_Arg_MustBeVersion();
    internal static string get_Arg_NamedParamNull();
    internal static string get_Arg_NamedParamTooBig();
    internal static string get_Arg_NDirectBadObject();
    internal static string get_Arg_NegativeArgCount();
    internal static string get_Arg_NoAccessSpec();
    internal static string get_Arg_NoDefCTor();
    internal static string get_Arg_NoStaticVirtual();
    internal static string get_Arg_NotFiniteNumberException();
    internal static string get_Arg_NotGenericMethodDefinition();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_NotGenericTypeDefinition();
    internal static string get_Arg_NotImplementedException();
    internal static string get_Arg_NotSupportedException();
    internal static string get_Arg_NullReferenceException();
    internal static string get_Arg_ObjObjEx();
    internal static string get_Arg_OleAutDateInvalid();
    internal static string get_Arg_OleAutDateScale();
    internal static string get_Arg_OverflowException();
    internal static string get_Arg_ParamName_Name();
    internal static string get_Arg_ParmArraySize();
    internal static string get_Arg_ParmCnt();
    internal static string get_Arg_PathEmpty();
    internal static string get_Arg_PlatformNotSupported();
    internal static string get_Arg_PropSetGet();
    internal static string get_Arg_PropSetInvoke();
    internal static string get_Arg_RankException();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_ReflectionOnlyCA();
    internal static string get_Arg_ReflectionOnlyField();
    internal static string get_Arg_ReflectionOnlyInvoke();
    internal static string get_Arg_ResMgrNotResSet();
    internal static string get_Arg_ResourceFileUnsupportedVersion();
    internal static string get_Arg_ResourceNameNotExist();
    internal static string get_Arg_SafeArrayRankMismatchException();
    internal static string get_Arg_SafeArrayTypeMismatchException();
    internal static string get_Arg_SecurityException();
    internal static string get_SerializationException();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_StackOverflowException();
    internal static string get_Arg_SurrogatesNotAllowedAsSingleChar();
    internal static string get_Arg_SynchronizationLockException();
    internal static string get_Arg_SystemException();
    internal static string get_Arg_TargetInvocationException();
    internal static string get_Arg_TargetParameterCountException();
    internal static string get_Arg_ThreadStartException();
    internal static string get_Arg_ThreadStateException();
    internal static string get_Arg_TimeoutException();
    internal static string get_Arg_TypeAccessException();
    internal static string get_Arg_TypedReference_Null();
    internal static string get_Arg_TypeLoadException();
    internal static string get_Arg_TypeLoadNullStr();
    internal static string get_Arg_TypeRefPrimitve();
    internal static string get_Arg_TypeUnloadedException();
    internal static string get_Arg_UnauthorizedAccessException();
    internal static string get_Arg_UnboundGenField();
    internal static string get_Arg_UnboundGenParam();
    internal static string get_Arg_UnknownTypeCode();
    internal static string get_Arg_VarMissNull();
    internal static string get_Arg_VersionString();
    internal static string get_Arg_WrongAsyncResult();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AbsolutePathRequired();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_AdjustmentRulesNoNulls();
    internal static string get_Argument_AdjustmentRulesOutOfOrder();
    internal static string get_Argument_ArrayGetInterfaceMap();
    internal static string get_Argument_ArraysInvalid();
    internal static string get_Argument_BadAttributeOnInterfaceMethod();
    internal static string get_Argument_BadConstructor();
    internal static string get_Argument_BadConstructorCallConv();
    internal static string get_Argument_BadExceptionCodeGen();
    internal static string get_Argument_BadFieldForConstructorBuilder();
    internal static string get_Argument_BadFieldSig();
    internal static string get_Argument_BadFieldType();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_BadImageFormatExceptionResolve();
    internal static string get_Argument_BadLabel();
    internal static string get_Argument_BadLabelContent();
    internal static string get_Argument_BadNestedTypeFlags();
    internal static string get_Argument_BadParameterCountsForConstructor();
    internal static string get_Argument_BadParameterTypeForCAB();
    internal static string get_Argument_BadPropertyForConstructorBuilder();
    internal static string get_Argument_BadSigFormat();
    internal static string get_Argument_BadSizeForData();
    internal static string get_Argument_BadTypeAttrInvalidLayout();
    internal static string get_Argument_BadTypeAttrNestedVisibilityOnNonNestedType();
    internal static string get_Argument_BadTypeAttrNonNestedVisibilityNestedType();
    internal static string get_Argument_BadTypeAttrReservedBitsSet();
    internal static string get_Argument_BadTypeInCustomAttribute();
    internal static string get_Argument_CannotGetTypeTokenForByRef();
    internal static string get_Argument_CannotSetParentToInterface();
    internal static string get_Argument_CodepageNotSupported();
    internal static string get_Argument_CompareOptionOrdinal();
    internal static string get_Argument_ConflictingDateTimeRoundtripStyles();
    internal static string get_Argument_ConflictingDateTimeStyles();
    internal static string get_Argument_ConstantDoesntMatch();
    internal static string get_Argument_ConstantNotSupported();
    internal static string get_Argument_ConstantNull();
    internal static string get_Argument_ConstructorNeedGenericDeclaringType();
    internal static string get_Argument_ConversionOverflow();
    internal static string get_Argument_ConvertMismatch();
    internal static string get_Argument_CultureIetfNotSupported();
    internal static string get_Argument_CultureInvalidIdentifier();
    internal static string get_Argument_CultureIsNeutral();
    internal static string get_Argument_CultureNotSupported();
    internal static string get_Argument_CustomAssemblyLoadContextRequestedNameMismatch();
    internal static string get_Argument_CustomCultureCannotBePassedByNumber();
    internal static string get_Argument_DateTimeBadBinaryData();
    internal static string get_Argument_DateTimeHasTicks();
    internal static string get_Argument_DateTimeHasTimeOfDay();
    internal static string get_Argument_DateTimeIsInvalid();
    internal static string get_Argument_DateTimeIsNotAmbiguous();
    internal static string get_Argument_DateTimeKindMustBeUnspecified();
    internal static string get_Argument_DateTimeKindMustBeUnspecifiedOrUtc();
    internal static string get_Argument_DateTimeOffsetInvalidDateTimeStyles();
    internal static string get_Argument_DateTimeOffsetIsNotAmbiguous();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_DuplicateTypeName();
    internal static string get_Argument_EmitWriteLineType();
    internal static string get_Argument_EmptyDecString();
    internal static string get_Argument_EmptyName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_EmptyWaithandleArray();
    internal static string get_Argument_EncoderFallbackNotEmpty();
    internal static string get_Argument_EncodingConversionOverflowBytes();
    internal static string get_Argument_EncodingConversionOverflowChars();
    internal static string get_Argument_EncodingNotSupported();
    internal static string get_Argument_EnumTypeDoesNotMatch();
    internal static string get_Argument_FallbackBufferNotEmpty();
    internal static string get_Argument_FieldDeclaringTypeGeneric();
    internal static string get_Argument_FieldNeedGenericDeclaringType();
    internal static string get_Argument_GenConstraintViolation();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_GenericsInvalid();
    internal static string get_Argument_GlobalFunctionHasToBeStatic();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_Argument_IdnBadBidi();
    internal static string get_Argument_IdnBadLabelSize();
    internal static string get_Argument_IdnBadNameSize();
    internal static string get_Argument_IdnBadPunycode();
    internal static string get_Argument_IdnBadStd3();
    internal static string get_Argument_IdnIllegalName();
    internal static string get_Argument_IllegalEnvVarName();
    internal static string get_Argument_IllegalName();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_Argument_InvalidArrayLength();
    internal static string get_Argument_InvalidCalendar();
    internal static string get_Argument_InvalidCharSequence();
    internal static string get_Argument_InvalidCharSequenceNoIndex();
    internal static string get_Argument_InvalidCodePageBytesIndex();
    internal static string get_Argument_InvalidCodePageConversionIndex();
    internal static string get_Argument_InvalidConstructorDeclaringType();
    internal static string get_Argument_InvalidConstructorInfo();
    internal static string get_Argument_InvalidCultureName();
    internal static string get_Argument_InvalidDateTimeKind();
    internal static string get_Argument_InvalidDateTimeStyles();
    internal static string get_Argument_InvalidDigitSubstitution();
    internal static string get_Argument_InvalidEnum();
    internal static string get_Argument_InvalidEnumValue();
    internal static string get_Argument_InvalidFieldDeclaringType();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidGenericInstArray();
    internal static string get_Argument_InvalidGroupSize();
    internal static string get_Argument_InvalidHandle();
    internal static string get_Argument_InvalidHighSurrogate();
    internal static string get_Argument_InvalidId();
    internal static string get_Argument_InvalidKindOfTypeForCA();
    internal static string get_Argument_InvalidLabel();
    internal static string get_Argument_InvalidLowSurrogate();
    internal static string get_Argument_InvalidMemberForNamedArgument();
    internal static string get_Argument_InvalidMethodDeclaringType();
    internal static string get_Argument_InvalidName();
    internal static string get_Argument_InvalidNativeDigitCount();
    internal static string get_Argument_InvalidNativeDigitValue();
    internal static string get_Argument_InvalidNeutralRegionName();
    internal static string get_Argument_InvalidNormalizationForm();
    internal static string get_Argument_InvalidNumberStyles();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOpCodeOnDynamicMethod();
    internal static string get_Argument_InvalidParameterInfo();
    internal static string get_Argument_InvalidParamInfo();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidResourceCultureName();
    internal static string get_Argument_InvalidSafeBufferOffLen();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSerializedString();
    internal static string get_Argument_InvalidStartupHookSyntax();
    internal static string get_Argument_InvalidStartupHookSignature();
    internal static string get_Argument_InvalidTimeSpanStyles();
    internal static string get_Argument_InvalidToken();
    internal static string get_Argument_InvalidTypeForCA();
    internal static string get_Argument_InvalidTypeForDynamicMethod();
    internal static string get_Argument_InvalidTypeName();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_InvalidUnity();
    internal static string get_Argument_LargeInteger();
    internal static string get_Argument_LongEnvVarValue();
    internal static string get_Argument_MethodDeclaringTypeGeneric();
    internal static string get_Argument_MethodDeclaringTypeGenericLcg();
    internal static string get_Argument_MethodNeedGenericDeclaringType();
    internal static string get_Argument_MinMaxValue();
    internal static string get_Argument_MismatchedArrays();
    internal static string get_Argument_MissingDefaultConstructor();
    internal static string get_Argument_MustBeFalse();
    internal static string get_Argument_MustBeRuntimeAssembly();
    internal static string get_Argument_MustBeRuntimeFieldInfo();
    internal static string get_Argument_MustBeRuntimeMethodInfo();
    internal static string get_Argument_MustBeRuntimeReflectionObject();
    internal static string get_Argument_MustBeRuntimeType();
    internal static string get_Argument_MustBeTypeBuilder();
    internal static string get_Argument_MustHaveAttributeBaseClass();
    internal static string get_Argument_NativeOverlappedAlreadyFree();
    internal static string get_Argument_NativeOverlappedWrongBoundHandle();
    internal static string get_Argument_NeedGenericMethodDefinition();
    internal static string get_Argument_NeedNonGenericType();
    internal static string get_Argument_NeedStructWithNoRefs();
    internal static string get_Argument_NeverValidGenericArgument();
    internal static string get_Argument_NoEra();
    internal static string get_Argument_NoModuleFileExtension();
    internal static string get_Argument_NoRegionInvariantCulture();
    internal static string get_Argument_NotAWritableProperty();
    internal static string get_Argument_NotEnoughBytesToRead();
    internal static string get_Argument_NotEnoughBytesToWrite();
    internal static string get_Argument_NotEnoughGenArguments();
    internal static string get_Argument_NotExceptionType();
    internal static string get_Argument_NotInExceptionBlock();
    internal static string get_Argument_NotMethodCallOpcode();
    internal static string get_Argument_NotSerializable();
    internal static string get_Argument_OffsetAndCapacityOutOfBounds();
    internal static string get_Argument_OffsetLocalMismatch();
    internal static string get_Argument_OffsetOfFieldNotFound();
    internal static string get_Argument_OffsetOutOfRange();
    internal static string get_Argument_OffsetPrecision();
    internal static string get_Argument_OffsetUtcMismatch();
    internal static string get_Argument_OneOfCulturesNotSupported();
    internal static string get_Argument_OnlyMscorlib();
    internal static string get_Argument_OutOfOrderDateTimes();
    internal static string get_Argument_PreAllocatedAlreadyAllocated();
    internal static string get_Argument_RecursiveFallback();
    internal static string get_Argument_RecursiveFallbackBytes();
    internal static string get_Argument_RedefinedLabel();
    internal static string get_Argument_ResolveField();
    internal static string get_Argument_ResolveFieldHandle();
    internal static string get_Argument_ResolveMember();
    internal static string get_Argument_ResolveMethod();
    internal static string get_Argument_ResolveMethodHandle();
    internal static string get_Argument_ResolveModuleType();
    internal static string get_Argument_ResolveString();
    internal static string get_Argument_ResolveType();
    internal static string get_Argument_ResultCalendarRange();
    internal static string get_Argument_SemaphoreInitialMaximum();
    internal static string get_Argument_ShouldNotSpecifyExceptionType();
    internal static string get_Argument_ShouldOnlySetVisibilityFlags();
    internal static string get_Argument_SigIsFinalized();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Argument_StringFirstCharIsZero();
    internal static string get_Argument_StringZeroLength();
    internal static string get_Argument_TimeSpanHasSeconds();
    internal static string get_Argument_TimeZoneInfoBadTZif();
    internal static string get_Argument_TimeZoneInfoInvalidTZif();
    internal static string get_Argument_ToExclusiveLessThanFromExclusive();
    internal static string get_Argument_TooManyFinallyClause();
    internal static string get_Argument_TransitionTimesAreIdentical();
    internal static string get_Argument_TypedReferenceInvalidField();
    internal static string get_Argument_TypeMustNotBeComImport();
    internal static string get_Argument_TypeNameTooLong();
    internal static string get_Argument_TypeNotValid();
    internal static string get_Argument_UnclosedExceptionBlock();
    internal static string get_Argument_UnknownUnmanagedCallConv();
    internal static string get_Argument_UnmanagedMemAccessorWrapAround();
    internal static string get_Argument_UnmatchedMethodForLocal();
    internal static string get_Argument_UnmatchingSymScope();
    internal static string get_Argument_UTCOutOfRange();
    internal static string get_Argument_WaitHandleNameTooLong();
    internal static string get_ArgumentException_BadMethodImplBody();
    internal static string get_ArgumentException_BufferNotFromPool();
    internal static string get_ArgumentException_TupleIncorrectType();
    internal static string get_ArgumentException_TupleLastArgumentNotATuple();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
    internal static string get_ArgumentNull_Array();
    internal static string get_ArgumentNull_ArrayElement();
    internal static string get_ArgumentNull_ArrayValue();
    internal static string get_ArgumentNull_Assembly();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentNull_Generic();
    internal static string get_ArgumentNull_Key();
    internal static string get_ArgumentNull_Obj();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentNull_Stream();
    internal static string get_ArgumentNull_String();
    internal static string get_ArgumentNull_Waithandles();
    internal static string get_ArgumentOutOfRange_ActualValue();
    internal static string get_ArgumentOutOfRange_AddressSpace();
    internal static string get_ArgumentOutOfRange_AddValue();
    internal static string get_ArgumentOutOfRange_BadHourMinuteSecond();
    internal static string get_ArgumentOutOfRange_BadYearMonthDay();
    internal static string get_ArgumentOutOfRange_BinaryReaderFillBuffer();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper();
    internal static string get_ArgumentOutOfRange_CalendarRange();
    internal static string get_ArgumentOutOfRange_Capacity();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_DateArithmetic();
    internal static string get_ArgumentOutOfRange_DateTimeBadMonths();
    internal static string get_ArgumentOutOfRange_DateTimeBadTicks();
    internal static string get_ArgumentOutOfRange_DateTimeBadYears();
    internal static string get_ArgumentOutOfRange_Day();
    internal static string get_ArgumentOutOfRange_DayOfWeek();
    internal static string get_ArgumentOutOfRange_DayParam();
    internal static string get_ArgumentOutOfRange_DecimalRound();
    internal static string get_ArgumentOutOfRange_DecimalScale();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_Era();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_ArgumentOutOfRange_FileTimeInvalid();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_GetByteCountOverflow();
    internal static string get_ArgumentOutOfRange_GetCharCountOverflow();
    internal static string get_ArgumentOutOfRange_HashtableLoadFactor();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_IndexCount();
    internal static string get_ArgumentOutOfRange_IndexCountBuffer();
    internal static string get_ArgumentOutOfRange_IndexLength();
    internal static string get_ArgumentOutOfRange_IndexString();
    internal static string get_ArgumentOutOfRange_InvalidEraValue();
    internal static string get_ArgumentOutOfRange_InvalidHighSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidLowSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidUTF32();
    internal static string get_ArgumentOutOfRange_Length();
    internal static string get_ArgumentOutOfRange_LengthGreaterThanCapacity();
    internal static string get_ArgumentOutOfRange_LengthTooLarge();
    internal static string get_ArgumentOutOfRange_LessEqualToIntegerMaxVal();
    internal static string get_ArgumentOutOfRange_Month();
    internal static string get_ArgumentOutOfRange_MonthParam();
    internal static string get_ArgumentOutOfRange_MustBeNonNegInt32();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_ArgumentOutOfRange_NegativeCapacity();
    internal static string get_ArgumentOutOfRange_NegativeCount();
    internal static string get_ArgumentOutOfRange_NegativeLength();
    internal static string get_ArgumentOutOfRange_OffsetLength();
    internal static string get_ArgumentOutOfRange_OffsetOut();
    internal static string get_ArgumentOutOfRange_ParamSequence();
    internal static string get_ArgumentOutOfRange_PartialWCHAR();
    internal static string get_ArgumentOutOfRange_PeriodTooLarge();
    internal static string get_ArgumentOutOfRange_PositionLessThanCapacityRequired();
    internal static string get_ArgumentOutOfRange_Range();
    internal static string get_ArgumentOutOfRange_RoundingDigits();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_ArgumentOutOfRange_SmallMaxCapacity();
    internal static string get_ArgumentOutOfRange_StartIndex();
    internal static string get_ArgumentOutOfRange_StartIndexLargerThanLength();
    internal static string get_ArgumentOutOfRange_StartIndexLessThanLength();
    internal static string get_ArgumentOutOfRange_StreamLength();
    internal static string get_ArgumentOutOfRange_TimeoutTooLarge();
    internal static string get_ArgumentOutOfRange_UIntPtrMax();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamLength();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamWrapAround();
    internal static string get_ArgumentOutOfRange_UtcOffset();
    internal static string get_ArgumentOutOfRange_UtcOffsetAndDaylightDelta();
    internal static string get_ArgumentOutOfRange_Version();
    internal static string get_ArgumentOutOfRange_Week();
    internal static string get_ArgumentOutOfRange_Year();
    internal static string get_Arithmetic_NaN();
    internal static string get_Arugment_EmitMixedContext1();
    internal static string get_Arugment_EmitMixedContext2();
    internal static string get_BadImageFormat_BadILFormat();
    internal static string get_BadImageFormat_InvalidType();
    internal static string get_BadImageFormat_NegativeStringLength();
    internal static string get_BadImageFormat_ParameterSignatureMismatch();
    internal static string get_BadImageFormat_ResourceDataLengthInvalid();
    internal static string get_BadImageFormat_ResourceNameCorrupted();
    internal static string get_BadImageFormat_ResourceNameCorrupted_NameIndex();
    internal static string get_BadImageFormat_ResourcesDataInvalidOffset();
    internal static string get_BadImageFormat_ResourcesHeaderCorrupted();
    internal static string get_BadImageFormat_ResourcesIndexTooLong();
    internal static string get_BadImageFormat_ResourcesNameInvalidOffset();
    internal static string get_BadImageFormat_ResourcesNameTooLong();
    internal static string get_BadImageFormat_TypeMismatch();
    internal static string get_CancellationToken_CreateLinkedToken_TokensIsEmpty();
    internal static string get_CancellationTokenSource_Disposed();
    internal static string get_EventSource_AbstractMustNotDeclareEventMethods();
    internal static string get_EventSource_AbstractMustNotDeclareKTOC();
    internal static string get_EventSource_AddScalarOutOfRange();
    internal static string get_EventSource_BadHexDigit();
    internal static string get_EventSource_ChannelTypeDoesNotMatchEventChannelValue();
    internal static string get_EventSource_DataDescriptorsOutOfRange();
    internal static string get_EventSource_DuplicateStringKey();
    internal static string get_EventSource_EnumKindMismatch();
    internal static string get_EventSource_EvenHexDigits();
    internal static string get_EventSource_EventChannelOutOfRange();
    internal static string get_EventSource_EventIdReused();
    internal static string get_EventSource_EventMustHaveTaskIfNonDefaultOpcode();
    internal static string get_EventSource_EventMustNotBeExplicitImplementation();
    internal static string get_EventSource_EventNameReused();
    internal static string get_EventSource_EventParametersMismatch();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_EventTooBig();
    internal static string get_EventSource_EventWithAdminChannelMustHaveMessage();
    internal static string get_EventSource_IllegalKeywordsValue();
    internal static string get_EventSource_IllegalOpcodeValue();
    internal static string get_EventSource_IllegalTaskValue();
    internal static string get_EventSource_IllegalValue();
    internal static string get_EventSource_IncorrentlyAuthoredTypeInfo();
    internal static string get_EventSource_InvalidCommand();
    internal static string get_EventSource_InvalidEventFormat();
    internal static string get_EventSource_KeywordCollision();
    internal static string get_EventSource_KeywordNeedPowerOfTwo();
    internal static string get_EventSource_ListenerCreatedInsideCallback();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_MaxChannelExceeded();
    internal static string get_EventSource_MismatchIdToWriteEvent();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedPositiveId();
    internal static string get_EventSource_NoFreeBuffers();
    internal static string get_EventSource_NonCompliantTypeError();
    internal static string get_EventSource_NoRelatedActivityId();
    internal static string get_EventSource_NotSupportedArrayOfBinary();
    internal static string get_EventSource_NotSupportedArrayOfNil();
    internal static string get_EventSource_NotSupportedArrayOfNullTerminatedString();
    internal static string get_EventSource_NotSupportedNestedArraysEnums();
    internal static string get_EventSource_NullInput();
    internal static string get_EventSource_OpcodeCollision();
    internal static string get_EventSource_PinArrayOutOfRange();
    internal static string get_EventSource_RecursiveTypeDefinition();
    internal static string get_EventSource_StopsFollowStarts();
    internal static string get_EventSource_TaskCollision();
    internal static string get_EventSource_TaskOpcodePairReused();
    internal static string get_EventSource_TooManyArgs();
    internal static string get_EventSource_TooManyFields();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_TraitEven();
    internal static string get_EventSource_TypeMustBeSealedOrAbstract();
    internal static string get_EventSource_TypeMustDeriveFromEventSource();
    internal static string get_EventSource_UndefinedChannel();
    internal static string get_EventSource_UndefinedKeyword();
    internal static string get_EventSource_UndefinedOpcode();
    internal static string get_EventSource_UnknownEtwTrait();
    internal static string get_EventSource_UnsupportedMessageProperty();
    internal static string get_EventSource_VarArgsParameterMismatch();
    internal static string get_Exception_EndOfInnerExceptionStack();
    internal static string get_Exception_EndStackTraceFromPreviousThrow();
    internal static string get_Exception_WasThrown();
    internal static string get_ExecutionContext_ExceptionInAsyncLocalNotification();
    internal static string get_FieldAccess_InitOnly();
    internal static string get_FileNotFound_ResolveAssembly();
    internal static string get_Format_AttributeUsage();
    internal static string get_Format_Bad7BitInt32();
    internal static string get_Format_BadBase64Char();
    internal static string get_Format_BadBoolean();
    internal static string get_Format_BadFormatSpecifier();
    internal static string get_Format_BadQuote();
    internal static string get_Format_EmptyInputString();
    internal static string get_Format_ExtraJunkAtEnd();
    internal static string get_Format_GuidUnrecognized();
    internal static string get_Format_IndexOutOfRange();
    internal static string get_Format_InvalidEnumFormatSpecification();
    internal static string get_Format_InvalidGuidFormatSpecification();
    internal static string get_Format_InvalidString();
    internal static string get_Format_NeedSingleChar();
    internal static string get_Format_NoParsibleDigits();
    internal static string get_Format_StringZeroLength();
    internal static string get_IndexOutOfRange_UMSPosition();
    internal static string get_Interop_Marshal_Unmappable_Char();
    internal static string get_InvalidCast_CannotCastNullToValueType();
    internal static string get_InvalidCast_DBNull();
    internal static string get_InvalidCast_Empty();
    internal static string get_InvalidCast_FromDBNull();
    internal static string get_InvalidCast_FromTo();
    internal static string get_InvalidCast_IConvertible();
    internal static string get_InvalidOperation_AsyncFlowCtrlCtxMismatch();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_InvalidOperation_BadEmptyMethodBody();
    internal static string get_InvalidOperation_BadILGeneratorUsage();
    internal static string get_InvalidOperation_BadInstructionOrIndexOutOfBound();
    internal static string get_InvalidOperation_BadInterfaceNotAbstract();
    internal static string get_InvalidOperation_BadMethodBody();
    internal static string get_InvalidOperation_BadTypeAttributesNotAbstract();
    internal static string get_InvalidOperation_CalledTwice();
    internal static string get_InvalidOperation_CannotImportGlobalFromDifferentModule();
    internal static string get_InvalidOperation_CannotRestoreUnsupressedFlow();
    internal static string get_InvalidOperation_CannotSupressFlowMultipleTimes();
    internal static string get_InvalidOperation_CannotUseAFCMultiple();
    internal static string get_InvalidOperation_CannotUseAFCOtherThread();
    internal static string get_InvalidOperation_CollectionCorrupted();
    internal static string get_InvalidOperation_ConstructorNotAllowedOnInterface();
    internal static string get_InvalidOperation_DateTimeParsing();
    internal static string get_InvalidOperation_DefaultConstructorILGen();
    internal static string get_InvalidOperation_EndReadCalledMultiple();
    internal static string get_InvalidOperation_EndWriteCalledMultiple();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_EventInfoNotAvailable();
    internal static string get_InvalidOperation_GenericParametersAlreadySet();
    internal static string get_InvalidOperation_GlobalsHaveBeenCreated();
    internal static string get_InvalidOperation_HandleIsNotPinned();
    internal static string get_InvalidOperation_HashInsertFailed();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_InvalidOperation_MethodBaked();
    internal static string get_InvalidOperation_MethodBuilderBaked();
    internal static string get_InvalidOperation_MethodHasBody();
    internal static string get_InvalidOperation_MustCallInitialize();
    internal static string get_InvalidOperation_NativeOverlappedReused();
    internal static string get_InvalidOperation_NoMultiModuleAssembly();
    internal static string get_InvalidOperation_NoPublicAddMethod();
    internal static string get_InvalidOperation_NoPublicRemoveMethod();
    internal static string get_InvalidOperation_NotADebugModule();
    internal static string get_InvalidOperation_NotAllowedInDynamicMethod();
    internal static string get_InvalidOperation_NotAllowedInReflectionOnly();
    internal static string get_InvalidOperation_NotAVarArgCallingConvention();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_InvalidOperation_NotWithConcurrentGC();
    internal static string get_InvalidOperation_NoUnderlyingTypeOnEnum();
    internal static string get_InvalidOperation_NullContext();
    internal static string get_InvalidOperation_NullModuleHandle();
    internal static string get_InvalidOperation_OpenLocalVariableScope();
    internal static string get_InvalidOperation_Overlapped_Pack();
    internal static string get_InvalidOperation_PropertyInfoNotAvailable();
    internal static string get_InvalidOperation_ReadOnly();
    internal static string get_InvalidOperation_ResMgrBadResSet_Type();
    internal static string get_InvalidOperation_ResourceNotStream_Name();
    internal static string get_InvalidOperation_ResourceNotString_Name();
    internal static string get_InvalidOperation_ResourceNotString_Type();
    internal static string get_InvalidOperation_ShouldNotHaveMethodBody();
    internal static string get_InvalidOperation_ThreadWrongThreadStart();
    internal static string get_InvalidOperation_TimeoutsNotSupported();
    internal static string get_InvalidOperation_TypeHasBeenCreated();
    internal static string get_InvalidOperation_TypeNotCreated();
    internal static string get_InvalidOperation_UnknownEnumType();
    internal static string get_InvalidOperation_WriteOnce();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple();
    internal static string get_InvalidProgram_Default();
    internal static string get_InvalidTimeZone_InvalidFileData();
    internal static string get_InvalidTimeZone_InvalidJulianDay();
    internal static string get_InvalidTimeZone_NJulianDayNotSupported();
    internal static string get_InvalidTimeZone_NoTTInfoStructures();
    internal static string get_InvalidTimeZone_UnparseablePosixMDateString();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileLoad();
    internal static string get_IO_FileName_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileStreamHandlePosition();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_FixedCapacity();
    internal static string get_IO_InvalidStringLen_Len();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_StreamTooLong();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_PathTooLong_Path();
    internal static string get_IO_UnknownFileName();
    internal static string get_Lazy_CreateValue_NoParameterlessCtorForT();
    internal static string get_Lazy_ctor_ModeInvalid();
    internal static string get_Lazy_StaticInit_InvalidOperation();
    internal static string get_Lazy_ToString_ValueNotCreated();
    internal static string get_Lazy_Value_RecursiveCallsToValue();
    internal static string get_ManualResetEventSlim_ctor_SpinCountOutOfRange();
    internal static string get_ManualResetEventSlim_ctor_TooManyWaiters();
    internal static string get_ManualResetEventSlim_Disposed();
    internal static string get_Marshaler_StringTooLong();
    internal static string get_MissingConstructor_Name();
    internal static string get_MissingField();
    internal static string get_MissingField_Name();
    internal static string get_MissingManifestResource_MultipleBlobs();
    internal static string get_MissingManifestResource_NoNeutralAsm();
    internal static string get_MissingManifestResource_NoNeutralDisk();
    internal static string get_MissingMember();
    internal static string get_MissingMember_Name();
    internal static string get_MissingMemberNestErr();
    internal static string get_MissingMemberTypeRef();
    internal static string get_MissingMethod_Name();
    internal static string get_MissingSatelliteAssembly_Culture_Name();
    internal static string get_MissingSatelliteAssembly_Default();
    internal static string get_Multicast_Combine();
    internal static string get_MustUseCCRewrite();
    internal static string get_NotImplemented_ResourcesLongerThanInt64Max();
    internal static string get_NotSupported_AbstractNonCLS();
    internal static string get_NotSupported_ActivAttr();
    internal static string get_NotSupported_AssemblyLoadFromHash();
    internal static string get_NotSupported_ByRefReturn();
    internal static string get_NotSupported_CallToVarArg();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_NotSupported_ChangeType();
    internal static string get_NotSupported_CreateInstanceWithTypeBuilder();
    internal static string get_NotSupported_DBNullSerial();
    internal static string get_NotSupported_DynamicAssembly();
    internal static string get_NotSupported_DynamicMethodFlags();
    internal static string get_NotSupported_DynamicModule();
    internal static string get_NotSupported_IllegalOneByteBranch();
    internal static string get_NotSupported_MaxWaitHandles();
    internal static string get_NotSupported_MemStreamNotExpandable();
    internal static string get_NotSupported_MustBeModuleBuilder();
    internal static string get_NotSupported_NoCodepageData();
    internal static string get_NotSupported_NonReflectedType();
    internal static string get_NotSupported_NoParentDefaultConstructor();
    internal static string get_NotSupported_NoTypeInfo();
    internal static string get_NotSupported_NYI();
    internal static string get_NotSupported_ObsoleteResourcesFile();
    internal static string get_NotSupported_OutputStreamUsingTypeBuilder();
    internal static string get_NotSupported_Reading();
    internal static string get_NotSupported_ResourceObjectSerialization();
    internal static string get_NotSupported_StringComparison();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_NotSupported_SymbolMethod();
    internal static string get_NotSupported_Type();
    internal static string get_NotSupported_TypeNotYetCreated();
    internal static string get_NotSupported_UmsSafeBuffer();
    internal static string get_NotSupported_UnitySerHolder();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_NotSupported_Writing();
    internal static string get_NotSupported_WrongResourceReader_Type();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_ObjectDisposed_Generic();
    internal static string get_ObjectDisposed_ObjectName_Name();
    internal static string get_ObjectDisposed_WriterClosed();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ObjectDisposed_ResourceSet();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_ObjectDisposed_ViewAccessorClosed();
    internal static string get_OperationCanceled();
    internal static string get_Overflow_Byte();
    internal static string get_Overflow_Char();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Double();
    internal static string get_Overflow_Duration();
    internal static string get_Overflow_Int16();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_NegateTwosCompNum();
    internal static string get_Overflow_NegativeUnsigned();
    internal static string get_Overflow_SByte();
    internal static string get_Overflow_Single();
    internal static string get_Overflow_TimeSpanTooLong();
    internal static string get_Overflow_UInt16();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_PlatformNotSupported_ArgIterator();
    internal static string get_PlatformNotSupported_ComInterop();
    internal static string get_PlatformNotSupported_NamedSynchronizationPrimitives();
    internal static string get_PlatformNotSupported_OSXFileLocking();
    internal static string get_PlatformNotSupported_ReflectionOnly();
    internal static string get_PlatformNotSupported_Remoting();
    internal static string get_PlatformNotSupported_SecureBinarySerialization();
    internal static string get_PlatformNotSupported_StrongNameSigning();
    internal static string get_PlatformNotSupported_OverlappedIO();
    internal static string get_ResourceReaderIsClosed();
    internal static string get_Resources_StreamNotValid();
    internal static string get_RFLCT_AmbigCust();
    internal static string get_RFLCT_Ambiguous();
    internal static string get_InvalidFilterCriteriaException_CritInt();
    internal static string get_InvalidFilterCriteriaException_CritString();
    internal static string get_RFLCT_InvalidFieldFail();
    internal static string get_RFLCT_InvalidPropFail();
    internal static string get_RFLCT_Targ_ITargMismatch();
    internal static string get_RFLCT_Targ_StatFldReqTarg();
    internal static string get_RFLCT_Targ_StatMethReqTarg();
    internal static string get_RuntimeWrappedException();
    internal static string get_Security_CannotReadFileData();
    internal static string get_SemaphoreSlim_ctor_InitialCountWrong();
    internal static string get_SemaphoreSlim_ctor_MaxCountWrong();
    internal static string get_SemaphoreSlim_Disposed();
    internal static string get_SemaphoreSlim_Release_CountWrong();
    internal static string get_SemaphoreSlim_Wait_TimeoutWrong();
    internal static string get_Serialization_BadParameterInfo();
    internal static string get_Serialization_CorruptField();
    internal static string get_Serialization_DateTimeTicksOutOfRange();
    internal static string get_Serialization_DelegatesNotSupported();
    internal static string get_Serialization_InsufficientState();
    internal static string get_Serialization_InvalidData();
    internal static string get_Serialization_InvalidEscapeSequence();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_InvalidPtrValue();
    internal static string get_Serialization_InvalidType();
    internal static string get_Serialization_KeyValueDifferentSizes();
    internal static string get_Serialization_MissingDateTimeData();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_MissingValues();
    internal static string get_Serialization_NonSerType();
    internal static string get_Serialization_NoParameterInfo();
    internal static string get_Serialization_NotFound();
    internal static string get_Serialization_NullKey();
    internal static string get_Serialization_OptionalFieldVersionValue();
    internal static string get_Serialization_SameNameTwice();
    internal static string get_Serialization_StringBuilderCapacity();
    internal static string get_Serialization_StringBuilderMaxCapacity();
    internal static string get_SpinLock_Exit_SynchronizationLockException();
    internal static string get_SpinLock_IsHeldByCurrentThread();
    internal static string get_SpinLock_TryEnter_ArgumentOutOfRange();
    internal static string get_SpinLock_TryEnter_LockRecursionException();
    internal static string get_SpinLock_TryReliableEnter_ArgumentException();
    internal static string get_SpinWait_SpinUntil_ArgumentNull();
    internal static string get_SpinWait_SpinUntil_TimeoutWrong();
    internal static string get_StackTrace_InFileLineNumber();
    internal static string get_Task_ContinueWith_ESandLR();
    internal static string get_Task_FromAsync_LongRunning();
    internal static string get_Task_FromAsync_PreferFairness();
    internal static string get_Task_MultiTaskContinuation_EmptyTaskList();
    internal static string get_Task_MultiTaskContinuation_FireOptions();
    internal static string get_Task_MultiTaskContinuation_NullTask();
    internal static string get_TaskCanceledException_ctor_DefaultMessage();
    internal static string get_TaskExceptionHolder_UnhandledException();
    internal static string get_TaskExceptionHolder_UnknownExceptionType();
    internal static string get_TaskScheduler_ExecuteTask_WrongTaskScheduler();
    internal static string get_TaskScheduler_FromCurrentSynchronizationContext_NoCurrent();
    internal static string get_TaskScheduler_InconsistentStateAfterTryExecuteTaskInline();
    internal static string get_TaskSchedulerException_ctor_DefaultMessage();
    internal static string get_TaskT_DebuggerNoResult();
    internal static string get_Threading_AbandonedMutexException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException_InvalidHandle();
    internal static string get_Threading_WaitHandleTooManyPosts();
    internal static string get_Threading_SemaphoreFullException();
    internal static string get_ThreadLocal_Disposed();
    internal static string get_ThreadLocal_Value_RecursiveCallsToValue();
    internal static string get_ThreadLocal_ValuesNotAvailable();
    internal static string get_TimeZoneNotFound_MissingData();
    internal static string get_TypeInitialization_Default();
    internal static string get_TypeInitialization_Type();
    internal static string get_TypeLoad_ResolveNestedType();
    internal static string get_TypeLoad_ResolveType();
    internal static string get_TypeLoad_ResolveTypeFromAssembly();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_Verification_Exception();
    internal static string get_Word_At();
    internal static string get_DebugAssertBanner();
    internal static string get_DebugAssertLongMessage();
    internal static string get_DebugAssertShortMessage();
    internal static string get_LockRecursionException_ReadAfterWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveReadNotAllowed();
    internal static string get_LockRecursionException_RecursiveWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveUpgradeNotAllowed();
    internal static string get_LockRecursionException_WriteAfterReadNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedUpgrade();
    internal static string get_SynchronizationLockException_MisMatchedRead();
    internal static string get_SynchronizationLockException_IncorrectDispose();
    internal static string get_LockRecursionException_UpgradeAfterReadNotAllowed();
    internal static string get_LockRecursionException_UpgradeAfterWriteNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedWrite();
    internal static string get_NotSupported_SignatureType();
    internal static string get_HashCode_HashCodeNotSupported();
    internal static string get_HashCode_EqualityNotSupported();
    internal static string get_Arg_TypeNotSupported();
    internal static string get_IO_InvalidReadLength();
    internal static string get_Arg_BasePathNotFullyQualified();
    internal static string get_Arg_ElementsInSourceIsGreaterThanDestination();
    internal static string get_Arg_NullArgumentNullRef();
    internal static string get_Argument_OverlapAlignmentMismatch();
    internal static string get_Arg_InsufficientNumberOfElements();
    internal static string get_Arg_MustBeNullTerminatedString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    internal StackOverflowException(SerializationInfo info, StreamingContext context);
}
internal static class System.StartupHookProvider : object {
    private static void ProcessStartupHooks();
    private static void CallStartupHook(string assemblyPath);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.String : object {
    private int _stringLength;
    private char _firstChar;
    public static string Empty;
    public char Chars { get; }
    public int Length { get; }
    public String(Char[] value);
    public String(Char[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(Char* value);
    [CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public String(char c, int count);
    public String(ReadOnlySpan`1<char> value);
    public char get_Chars(int index);
    public int get_Length();
    internal static string FastAllocateString(int length);
    internal bool IsFastSort();
    internal bool IsAscii();
    internal void SetTrailByte(byte data);
    internal bool TryGetTrailByte(Byte& data);
    public static string Intern(string str);
    public static string IsInterned(string str);
    internal static void InternalCopy(string src, IntPtr dest, int len);
    internal int GetBytesFromEncoding(Byte* pbNativeBuffer, int cbNativeBuffer, Encoding encoding);
    internal int ConvertToAnsi(Byte* pbNativeBuffer, int cbNativeBuffer, bool fBestFit, bool fThrowOnUnmappableChar);
    private string Ctor(Char[] value);
    private string Ctor(Char[] value, int startIndex, int length);
    private string Ctor(Char* ptr);
    private string Ctor(Char* ptr, int startIndex, int length);
    private string Ctor(SByte* value);
    private string Ctor(SByte* value, int startIndex, int length);
    private static string CreateStringForSByteConstructor(Byte* pb, int numBytes);
    private string Ctor(SByte* value, int startIndex, int length, Encoding enc);
    private string Ctor(char c, int count);
    private string Ctor(ReadOnlySpan`1<char> value);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    public static ReadOnlySpan`1<char> op_Implicit(string value);
    public sealed virtual object Clone();
    public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    [NonVersionableAttribute]
public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    internal Char& GetRawStringData();
    internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    internal static string CreateFromChar(char c);
    internal static void wstrcpy(Char* dmem, Char* smem, int charCount);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static int wcslen(Char* ptr);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    private static int CompareOrdinalIgnoreCaseHelper(string strA, string strB);
    private static bool EqualsHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
    private static bool EqualsIgnoreCaseAsciiHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, string strB);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, string strB);
    internal static int CompareOrdinal(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(string strB);
    public bool EndsWith(string value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public bool Equals(string value, StringComparison comparisonType);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public static bool op_Equality(string a, string b);
    public static bool op_Inequality(string a, string b);
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    internal int GetLegacyNonRandomizedHashCode();
    public bool StartsWith(string value);
    public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    internal static void CheckStringComparison(StringComparison comparisonType);
    private static void FillStringChecked(string dest, int destPos, string src);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(IEnumerable`1<T> values);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    private static string FormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public string Insert(int startIndex, string value);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, String[] value, int startIndex, int count);
    private static string JoinCore(Char* separator, int separatorLength, Object[] values);
    private static string JoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private static string JoinCore(Char* separator, int separatorLength, String[] value, int startIndex, int count);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    private string ReplaceCore(string oldValue, string newValue, CultureInfo culture, CompareOptions options);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    private string ReplaceHelper(int oldValueLength, string newValue, ReadOnlySpan`1<int> indices);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(ReadOnlySpan`1<char> separators, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, String[] separators, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, int count, StringSplitOptions options);
    private String[] SplitKeepEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private String[] SplitOmitEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private void MakeSeparatorList(ReadOnlySpan`1<char> separators, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(string separator, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(String[] separators, ValueListBuilder`1& sepListBuilder, ValueListBuilder`1& lengthListBuilder);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private string InternalSubString(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    private string TrimWhiteSpaceHelper(TrimType trimType);
    private string TrimHelper(Char* trimChars, int trimCharsLength, TrimType trimType);
    private string CreateTrimmedString(int start, int end);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    private int IndexOfAny(char value1, char value2, int startIndex, int count);
    private int IndexOfAny(char value1, char value2, char value3, int startIndex, int count);
    private int IndexOfCharArray(Char[] anyOf, int startIndex, int count);
    private static void InitializeProbabilisticMap(UInt32* charMap, ReadOnlySpan`1<char> anyOf);
    private static bool ArrayContains(char searchChar, Char[] anyOf);
    private static bool IsCharBitSet(UInt32* charMap, byte value);
    private static void SetCharBit(UInt32* charMap, byte value);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    private int LastIndexOfCharArray(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.StringComparer : object {
    private static CultureAwareComparer s_invariantCulture;
    private static CultureAwareComparer s_invariantCultureIgnoreCase;
    private static OrdinalCaseSensitiveComparer s_ordinal;
    private static OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    private static StringComparer();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    public abstract virtual int Compare(string x, string y);
    public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
internal static class System.StubHelpers.AnsiCharMarshaler : object {
    internal static Byte[] DoAnsiConversion(string str, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cbLength);
    internal static byte ConvertToNative(char managedChar, bool fBestFit, bool fThrowOnUnmappableChar);
    internal static char ConvertToManaged(byte nativeChar);
}
internal class System.StubHelpers.AsAnyMarshaler : ValueType {
    private IntPtr pvArrayMarshaler;
    private BackPropAction backPropAction;
    private Type layoutType;
    private CleanupWorkList cleanupWorkList;
    internal AsAnyMarshaler(IntPtr pvArrayMarshaler);
    private static bool IsIn(int dwFlags);
    private static bool IsOut(int dwFlags);
    private static bool IsAnsi(int dwFlags);
    private static bool IsThrowOn(int dwFlags);
    private static bool IsBestFit(int dwFlags);
    private IntPtr ConvertArrayToNative(object pManagedHome, int dwFlags);
    private static IntPtr ConvertStringToNative(string pManagedHome, int dwFlags);
    private IntPtr ConvertStringBuilderToNative(StringBuilder pManagedHome, int dwFlags);
    private IntPtr ConvertLayoutToNative(object pManagedHome, int dwFlags);
    internal IntPtr ConvertToNative(object pManagedHome, int dwFlags);
    internal void ConvertToManaged(object pManagedHome, IntPtr pNativeHome);
    internal void ClearNative(IntPtr pNativeHome);
}
internal static class System.StubHelpers.BSTRMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal class System.StubHelpers.CleanupWorkList : object {
    private List`1<CleanupWorkListElement> m_list;
    public void Add(CleanupWorkListElement elem);
    public void Destroy();
}
internal class System.StubHelpers.CleanupWorkListElement : object {
    public SafeHandle m_handle;
    public bool m_owned;
    public CleanupWorkListElement(SafeHandle handle);
}
internal static class System.StubHelpers.CSTRMarshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr cstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.DateMarshaler : object {
    internal static double ConvertToNative(DateTime managedDate);
    internal static long ConvertToManaged(double nativeDate);
}
internal static class System.StubHelpers.MngdNativeArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int dwFlags);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int cElements);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
}
internal static class System.StubHelpers.MngdRefCustomMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pCMHelper);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
internal class System.StubHelpers.NativeVariant : ValueType {
    private ushort vt;
    private ushort wReserved1;
    private ushort wReserved2;
    private ushort wReserved3;
    private IntPtr data1;
    private IntPtr data2;
}
internal static class System.StubHelpers.StubHelpers : object {
    internal static bool IsQCall(IntPtr pMD);
    internal static void InitDeclaringType(IntPtr pMD);
    internal static IntPtr GetNDirectTarget(IntPtr pMD);
    internal static IntPtr GetDelegateTarget(Delegate pThis, IntPtr& pStubArg);
    internal static void ClearLastError();
    internal static void SetLastError();
    internal static void ThrowInteropParamException(int resID, int paramIdx);
    internal static IntPtr AddToCleanupList(CleanupWorkList& pCleanupWorkList, SafeHandle handle);
    internal static void DestroyCleanupList(CleanupWorkList& pCleanupWorkList);
    internal static Exception GetHRExceptionObject(int hr);
    internal static Exception InternalGetHRExceptionObject(int hr);
    internal static IntPtr CreateCustomMarshalerHelper(IntPtr pMD, int paramToken, IntPtr hndManagedType);
    internal static IntPtr SafeHandleAddRef(SafeHandle pHandle, Boolean& success);
    internal static void SafeHandleRelease(SafeHandle pHandle);
    internal static IntPtr ProfilerBeginTransitionCallback(IntPtr pSecretParam, IntPtr pThread, object pThis);
    internal static void ProfilerEndTransitionCallback(IntPtr pMD, IntPtr pThread);
    internal static void CheckStringLength(int length);
    internal static void CheckStringLength(UInt32 length);
    internal static int strlen(SByte* ptr);
    internal static void DecimalCanonicalizeInternal(Decimal& dec);
    internal static void FmtClassUpdateNativeInternal(object obj, Byte* pNative, CleanupWorkList& pCleanupWorkList);
    internal static void FmtClassUpdateCLRInternal(object obj, Byte* pNative);
    internal static void LayoutDestroyNativeInternal(Byte* pNative, IntPtr pMT);
    internal static object AllocateInternal(IntPtr typeHandle);
    internal static void MarshalToUnmanagedVaListInternal(IntPtr va_list, UInt32 vaListSize, IntPtr pArgIterator);
    internal static void MarshalToManagedVaListInternal(IntPtr va_list, IntPtr pArgIterator);
    internal static UInt32 CalcVaListSize(IntPtr va_list);
    internal static void ValidateObject(object obj, IntPtr pMD, object pThis);
    internal static void LogPinnedArgument(IntPtr localDesc, IntPtr nativeArg);
    internal static void ValidateByref(IntPtr byref, IntPtr pMD, object pThis);
    internal static IntPtr GetStubContext();
    internal static IntPtr GetStubContextAddr();
    internal static void ArrayTypeCheck(object o, Object[] arr);
    internal static void MulticastDebuggerTraceHelper(object o, int count);
}
internal static class System.StubHelpers.UTF8BufferMarshaler : object {
    internal static IntPtr ConvertToNative(StringBuilder sb, IntPtr pNativeBuffer, int flags);
    internal static void ConvertToManaged(StringBuilder sb, IntPtr pNative);
}
internal static class System.StubHelpers.UTF8Marshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr cstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.ValueClassMarshaler : object {
    internal static void ConvertToNative(IntPtr dst, IntPtr src, IntPtr pMT, CleanupWorkList& pCleanupWorkList);
    internal static void ConvertToManaged(IntPtr dst, IntPtr src, IntPtr pMT);
    internal static void ClearNative(IntPtr dst, IntPtr pMT);
}
internal static class System.StubHelpers.VBByValStrMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cch);
    internal static string ConvertToManaged(IntPtr pNative, int cch);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.WSTRBufferMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    protected SystemException(SerializationInfo info, StreamingContext context);
}
internal class System.SZArrayHelper : object {
    internal IEnumerator`1<T> GetEnumerator();
    private void CopyTo(T[] array, int index);
    internal int get_Count();
    internal T get_Item(int index);
    internal void set_Item(int index, T value);
    private void Add(T value);
    private bool Contains(T value);
    private bool get_IsReadOnly();
    private void Clear();
    private int IndexOf(T value);
    private void Insert(int index, T value);
    private bool Remove(T value);
    private void RemoveAt(int index);
}
public class System.Text.ASCIIEncoding : Encoding {
    internal static ASCIIEncodingSealed s_default;
    public bool IsSingleByte { get; }
    private static ASCIIEncoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
internal class System.Text.CodePageDataItem : object {
    private int _codePage;
    private int _uiFamilyCodePage;
    private string _webName;
    private UInt32 _flags;
    private string _displayNameResourceKey;
    public int CodePage { get; }
    public int UIFamilyCodePage { get; }
    public string WebName { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public UInt32 Flags { get; }
    public string DisplayNameResourceKey { get; }
    internal CodePageDataItem(int codePage, int uiFamilyCodePage, string webName, UInt32 flags);
    public int get_CodePage();
    public int get_UIFamilyCodePage();
    public string get_WebName();
    public string get_HeaderName();
    public string get_BodyName();
    public UInt32 get_Flags();
    public string get_DisplayNameResourceKey();
}
public abstract class System.Text.Decoder : object {
    internal DecoderFallback _fallback;
    internal DecoderFallbackBuffer _fallbackBuffer;
    public DecoderFallback Fallback { get; public set; }
    public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    private void Throw(Byte[] bytesUnknown, int index);
}
public abstract class System.Text.DecoderFallback : object {
    private static DecoderFallback s_replacementFallback;
    private static DecoderFallback s_exceptionFallback;
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    internal Byte* byteStart;
    internal Char* charEnd;
    public int Remaining { get; }
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.DecoderFallbackException : ArgumentException {
    private Byte[] _bytesUnknown;
    private int _index;
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    private DecoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _bytesUsed;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal DecoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
public abstract class System.Text.Encoder : object {
    internal EncoderFallback _fallback;
    internal EncoderFallbackBuffer _fallbackBuffer;
    public EncoderFallback Fallback { get; public set; }
    public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
public abstract class System.Text.EncoderFallback : object {
    private static EncoderFallback s_replacementFallback;
    private static EncoderFallback s_exceptionFallback;
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    internal Char* charStart;
    internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal char InternalGetNextChar();
    internal virtual bool InternalFallback(char ch, Char*& chars);
    internal void ThrowLastCharRecursive(int charRecursive);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.EncoderFallbackException : ArgumentException {
    private char _charUnknown;
    private char _charUnknownHigh;
    private char _charUnknownLow;
    private int _index;
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    private EncoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char _charLeftOver;
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal EncoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
}
public abstract class System.Text.Encoding : object {
    private static UTF8EncodingSealed s_defaultEncoding;
    internal int _codePage;
    internal CodePageDataItem _dataItem;
    [OptionalFieldAttribute]
private bool _isReadOnly;
    internal EncoderFallback encoderFallback;
    internal DecoderFallback decoderFallback;
    public static Encoding Default { get; }
    public ReadOnlySpan`1<byte> Preamble { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsSingleByte { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public DecoderFallback DecoderFallback { get; public set; }
    public bool IsReadOnly { get; }
    public static Encoding ASCII { get; }
    private static Encoding Latin1 { get; }
    public int CodePage { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    private static Encoding BigEndianUTF32 { get; }
    protected Encoding(int codePage);
    protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    private static Encoding();
    public static Encoding get_Default();
    internal virtual void SetDefaultFallbacks();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public static void RegisterProvider(EncodingProvider provider);
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    private void GetDataItem();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public virtual object Clone();
    public bool get_IsReadOnly();
    public static Encoding get_ASCII();
    private static Encoding get_Latin1();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public int GetByteCount(string s, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    [CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    public string GetString(ReadOnlySpan`1<byte> bytes);
    public virtual int get_CodePage();
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    private static Encoding get_BigEndianUTF32();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal virtual Char[] GetBestFitUnicodeToBytesData();
    internal virtual Char[] GetBestFitBytesToUnicodeData();
    internal void ThrowBytesOverflow();
    internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    internal void ThrowCharsOverflow();
    internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
}
public class System.Text.EncodingInfo : object {
    private int iCodePage;
    private string strEncodingName;
    private string strDisplayName;
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    internal EncodingInfo(int codePage, string name, string displayName);
    public int get_CodePage();
    public string get_Name();
    public string get_DisplayName();
    public Encoding GetEncoding();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal abstract class System.Text.EncodingNLS : Encoding {
    protected EncodingNLS(int codePage);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
public abstract class System.Text.EncodingProvider : object {
    private static object s_InternalSyncObject;
    private static EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    private static EncodingProvider();
    public abstract virtual Encoding GetEncoding(string name);
    public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    internal static void AddProvider(EncodingProvider provider);
    internal static Encoding GetEncodingFromProvider(int codepage);
    internal static Encoding GetEncodingFromProvider(string encodingName);
    internal static Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec);
    internal static Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec);
}
internal static class System.Text.EncodingTable : object {
    private static Dictionary`2<string, ushort> s_encodingDataTable;
    private static CodePageDataItem[] s_encodingDataTableItems;
    private static EncodingTable();
    internal static EncodingInfo[] GetEncodings();
    internal static int GetCodePageFromName(string name);
    internal static CodePageDataItem GetCodePageDataItem(int codepage);
}
internal class System.Text.InternalDecoderBestFitFallback : DecoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    internal char _cReplacement;
    public int MaxCharCount { get; }
    internal InternalDecoderBestFitFallback(Encoding encoding);
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
    private char _cBestFit;
    private int _iCount;
    private int _iSize;
    private InternalDecoderBestFitFallback _oFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalDecoderBestFitFallbackBuffer(InternalDecoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    private char TryBestFit(Byte[] bytesCheck);
}
internal class System.Text.InternalEncoderBestFitFallback : EncoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    public int MaxCharCount { get; }
    internal InternalEncoderBestFitFallback(Encoding encoding);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
    private char _cBestFit;
    private InternalEncoderBestFitFallback _oFallback;
    private int _iCount;
    private int _iSize;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalEncoderBestFitFallbackBuffer(InternalEncoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    private char TryBestFit(char cUnknown);
}
internal class System.Text.Latin1Encoding : EncodingNLS {
    internal static Latin1Encoding s_default;
    private static Char[] arrayCharBestFit;
    public bool IsSingleByte { get; }
    private static Latin1Encoding();
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    internal virtual Char[] GetBestFitUnicodeToBytesData();
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
[DefaultMemberAttribute("Chars")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.StringBuilder : object {
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    internal static int DefaultCapacity;
    private static string CapacityField;
    private static string MaxCapacityField;
    private static string StringValueField;
    private static string ThreadIDField;
    internal static int MaxChunkSize;
    private static int IndexLimit;
    private static int WidthLimit;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    private Span`1<char> RemainingCurrentChunk { get; }
    public StringBuilder(int capacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    private StringBuilder(SerializationInfo info, StreamingContext context);
    private StringBuilder(StringBuilder from);
    private StringBuilder(int size, int maxCapacity, StringBuilder previousBlock);
    internal void ReplaceBufferInternal(Char* newBuffer, int newLength);
    internal void ReplaceBufferAnsiInternal(SByte* newBuffer, int newLength);
    internal void InternalCopy(IntPtr dest, int len);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(string value);
    private void AppendHelper(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    private StringBuilder AppendCore(StringBuilder value, int startIndex, int count);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    public StringBuilder Append(char value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    private StringBuilder AppendSpanFormattable(T value);
    public StringBuilder Append(object value);
    public StringBuilder Append(Char[] value);
    public StringBuilder Append(ReadOnlySpan`1<char> value);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, T[] values);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    private static void FormatError();
    internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public StringBuilder Replace(string oldValue, string newValue);
    public bool Equals(StringBuilder sb);
    public bool Equals(ReadOnlySpan`1<char> span);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    private void Insert(int index, Char* value, int valueCount);
    private void ReplaceAllInChunk(Int32[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value);
    private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
    private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char* value, int count);
    private static void ThreadSafeCopy(Char* sourcePtr, Char[] destination, int destinationIndex, int count);
    private static void ThreadSafeCopy(Char[] source, int sourceIndex, Span`1<char> destination, int destinationIndex, int count);
    private StringBuilder FindChunkForIndex(int index);
    private StringBuilder FindChunkForByte(int byteIndex);
    private Span`1<char> get_RemainingCurrentChunk();
    private StringBuilder Next(StringBuilder chunk);
    private void ExpandByABlock(int minBlockCharCount);
    private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doNotMoveFollowingChars);
    private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk);
}
internal static class System.Text.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder CachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.Text.UnicodeEncoding : Encoding {
    internal static UnicodeEncoding s_bigEndianDefault;
    internal static UnicodeEncoding s_littleEndianDefault;
    private static Byte[] s_bigEndianPreamble;
    private static Byte[] s_littleEndianPreamble;
    internal bool isThrowException;
    internal bool bigEndian;
    internal bool byteOrderMark;
    public static int CharSize;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    private static UnicodeEncoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF32Encoding : Encoding {
    internal static UTF32Encoding s_default;
    internal static UTF32Encoding s_bigEndianDefault;
    private static Byte[] s_bigEndianPreamble;
    private static Byte[] s_littleEndianPreamble;
    private bool _emitUTF32ByteOrderMark;
    private bool _isThrowException;
    private bool _bigEndian;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    private static UTF32Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private UInt32 GetSurrogate(char cHigh, char cLow);
    private char GetHighSurrogate(UInt32 iChar);
    private char GetLowSurrogate(UInt32 iChar);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF7Encoding : Encoding {
    internal static UTF7Encoding s_default;
    private Byte[] _base64Bytes;
    private SByte[] _base64Values;
    private Boolean[] _directEncode;
    private bool _allowOptionals;
    public UTF7Encoding(bool allowOptionals);
    private static UTF7Encoding();
    private void MakeTables();
    internal virtual void SetDefaultFallbacks();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
public class System.Text.UTF8Encoding : Encoding {
    internal static UTF8EncodingSealed s_default;
    internal static Byte[] s_preamble;
    internal bool _emitUTF8Identifier;
    private bool _isThrowException;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    private static UTF8Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
    private static bool InRange(int ch, int start, int end);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private bool FallbackInvalidByteSequence(Byte*& pSrc, int ch, DecoderFallbackBuffer fallback, Char*& pTarget);
    private int FallbackInvalidByteSequence(Byte* pSrc, int ch, DecoderFallbackBuffer fallback);
    private Byte[] GetBytesUnknown(Byte*& pSrc, int ch);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public Char& Item { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public int get_Length();
    public void set_Length(int value);
    public Char& get_Item(int index);
    public virtual string ToString();
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int requiredAdditionalCapacity);
    public void Dispose();
}
internal class System.Threading._IOCompletionCallback : object {
    private IOCompletionCallback _ioCompletionCallback;
    private ExecutionContext _executionContext;
    private UInt32 _errorCode;
    private UInt32 _numBytes;
    private NativeOverlapped* _pOVERLAP;
    internal static ContextCallback _ccb;
    internal _IOCompletionCallback(IOCompletionCallback ioCompletionCallback, ExecutionContext executionContext);
    private static _IOCompletionCallback();
    internal static void IOCompletionCallback_Context(object state);
    internal static void PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
}
internal static class System.Threading._ThreadPoolWaitCallback : object {
    internal static bool PerformWaitCallback();
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    private WaitOrTimerCallback _waitOrTimerCallback;
    private ExecutionContext _executionContext;
    private object _state;
    private static ContextCallback _ccbt;
    private static ContextCallback _ccbf;
    internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool compressStack);
    private static _ThreadPoolWaitOrTimerCallback();
    private static void WaitOrTimerCallback_Context_t(object state);
    private static void WaitOrTimerCallback_Context_f(object state);
    private static void WaitOrTimerCallback_Context(object state, bool timedOut);
    internal static void PerformWaitOrTimerCallback(object state, bool timedOut);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.AbandonedMutexException : SystemException {
    private int _mutexIndex;
    private Mutex _mutex;
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    private void SetupException(int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private Thread _thread;
    internal void Initialize(Thread currentThread);
    public void Undo();
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
public class System.Threading.AsyncLocal`1 : object {
    private Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler;
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
    private sealed virtual override void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
}
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadContextChanged>k__BackingField;
    public T PreviousValue { get; private set; }
    public T CurrentValue { get; private set; }
    public bool ThreadContextChanged { get; private set; }
    internal AsyncLocalValueChangedArgs`1(T previousValue, T currentValue, bool contextChanged);
    [CompilerGeneratedAttribute]
public T get_PreviousValue();
    [CompilerGeneratedAttribute]
private void set_PreviousValue(T value);
    [CompilerGeneratedAttribute]
public T get_CurrentValue();
    [CompilerGeneratedAttribute]
private void set_CurrentValue(T value);
    [CompilerGeneratedAttribute]
public bool get_ThreadContextChanged();
    [CompilerGeneratedAttribute]
private void set_ThreadContextChanged(bool value);
}
internal static class System.Threading.AsyncLocalValueMap : object {
    [CompilerGeneratedAttribute]
private static IAsyncLocalValueMap <Empty>k__BackingField;
    public static IAsyncLocalValueMap Empty { get; }
    private static AsyncLocalValueMap();
    [CompilerGeneratedAttribute]
public static IAsyncLocalValueMap get_Empty();
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
public class System.Threading.CancellationToken : ValueType {
    private static Action`1<object> s_actionToActionObjShunt;
    private CancellationTokenSource _source;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
    private CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSyncContext, bool useExecutionContext);
    public bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    private void ThrowOperationCanceledException();
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private long _id;
    private CallbackNode _node;
    public CancellationToken Token { get; }
    internal CancellationTokenRegistration(long id, CallbackNode node);
    public sealed virtual void Dispose();
    public CancellationToken get_Token();
    private void WaitForCallbackIfNecessary();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
}
public class System.Threading.CancellationTokenSource : object {
    internal static CancellationTokenSource s_canceledSource;
    internal static CancellationTokenSource s_neverCanceledSource;
    private static TimerCallback s_timerCallback;
    private static int s_numPartitions;
    private static int s_numPartitionsMask;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadIDExecutingCallbacks;
    private long _executingCallbackId;
    private CallbackPartition[] modreq(System.Runtime.CompilerServices.IsVolatile) _callbackPartitions;
    private Timer modreq(System.Runtime.CompilerServices.IsVolatile) _timer;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _kernelEvent;
    private bool _disposed;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal WaitHandle WaitHandle { get; }
    internal long ExecutingCallback { get; }
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal int get_ThreadIDExecutingCallbacks();
    internal void set_ThreadIDExecutingCallbacks(int value);
    public CancellationToken get_Token();
    internal WaitHandle get_WaitHandle();
    internal long get_ExecutingCallback();
    private void InitializeWithTimer(int millisecondsDelay);
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void ThrowObjectDisposedException();
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext syncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    private static int GetPartitionCount();
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    internal static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(long id);
}
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.DeferredDisposableLifetime`1 : ValueType {
    private int _count;
    public bool AddRef(T obj);
    public void Release(T obj);
    public void Dispose(T obj);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
[ComVisibleAttribute("True")]
public class System.Threading.EventWaitHandle : WaitHandle {
    public EventWaitHandle(bool initialState, EventResetMode mode);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    internal EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity);
    public static EventWaitHandle OpenExisting(string name);
    internal static EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights);
    public static bool TryOpenExisting(string name, EventWaitHandle& result);
    private static OpenExistingResult OpenExistingWorker(string name, EventWaitHandleRights rights, EventWaitHandle& result);
    public bool Reset();
    public bool Set();
}
public class System.Threading.ExecutionContext : object {
    internal static ExecutionContext Default;
    internal static ExecutionContext DefaultFlowSuppressed;
    private IAsyncLocalValueMap m_localValues;
    private IAsyncLocal[] m_localChangeNotifications;
    private bool m_isFlowSuppressed;
    private bool m_isDefault;
    internal bool HasChangeNotifications { get; }
    internal bool IsDefault { get; }
    private ExecutionContext(bool isDefault);
    private ExecutionContext(IAsyncLocalValueMap localValues, IAsyncLocal[] localChangeNotifications, bool isFlowSuppressed);
    private static ExecutionContext();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static ExecutionContext Capture();
    private ExecutionContext ShallowClone(bool isFlowSuppressed);
    public static AsyncFlowControl SuppressFlow();
    public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    internal bool get_HasChangeNotifications();
    internal bool get_IsDefault();
    public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void OnValuesChanged(ExecutionContext previousExecutionCtx, ExecutionContext nextExecutionCtx);
    [StackTraceHiddenAttribute]
private static void ThrowNullContext();
    internal static object GetLocalValue(IAsyncLocal local);
    internal static void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications);
    public ExecutionContext CreateCopy();
    public sealed virtual void Dispose();
}
internal class System.Threading.FastRandom : ValueType {
    private UInt32 _w;
    private UInt32 _x;
    private UInt32 _y;
    private UInt32 _z;
    public FastRandom(int seed);
    public int Next(int maxValue);
}
internal interface System.Threading.IAsyncLocal {
    public abstract virtual void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
}
internal interface System.Threading.IAsyncLocalValueMap {
    public abstract virtual bool TryGetValue(IAsyncLocal key, Object& value);
    public abstract virtual IAsyncLocalValueMap Set(IAsyncLocal key, object value);
}
internal interface System.Threading.IDeferredDisposable {
    public abstract virtual void OnFinalRelease(bool disposed);
}
public static class System.Threading.Interlocked : object {
    public static int Increment(Int32& location);
    public static long Increment(Int64& location);
    public static int Decrement(Int32& location);
    public static long Decrement(Int64& location);
    public static int Exchange(Int32& location1, int value);
    public static long Exchange(Int64& location1, long value);
    public static float Exchange(Single& location1, float value);
    public static double Exchange(Double& location1, double value);
    public static object Exchange(Object& location1, object value);
    public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    public static T Exchange(T& location1, T value);
    public static int CompareExchange(Int32& location1, int value, int comparand);
    public static long CompareExchange(Int64& location1, long value, long comparand);
    public static float CompareExchange(Single& location1, float value, float comparand);
    public static double CompareExchange(Double& location1, double value, double comparand);
    public static object CompareExchange(Object& location1, object value, object comparand);
    public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    public static T CompareExchange(T& location1, T value, T comparand);
    internal static int CompareExchange(Int32& location1, int value, int comparand, Boolean& succeeded);
    internal static int ExchangeAdd(Int32& location1, int value);
    internal static long ExchangeAdd(Int64& location1, long value);
    public static int Add(Int32& location1, int value);
    public static long Add(Int64& location1, long value);
    public static long Read(Int64& location);
    public static void MemoryBarrier();
    private static void _MemoryBarrierProcessWide();
    public static void MemoryBarrierProcessWide();
}
internal class System.Threading.InternalCrossContextDelegate : MulticastDelegate {
    public InternalCrossContextDelegate(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface System.Threading.IThreadPoolWorkItem {
    public abstract virtual void ExecuteWorkItem();
    public abstract virtual void MarkAborted(ThreadAbortException tae);
}
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    private static T EnsureInitializedCore(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static object EnsureLockInitialized(Object& syncLock);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
    protected LockRecursionException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static Action`1<object> s_cancellationTokenCallback;
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private bool LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
}
public static class System.Threading.Monitor : object {
    public static void Enter(object obj);
    public static void Enter(object obj, Boolean& lockTaken);
    private static void ThrowLockTakenException();
    private static void ReliableEnter(object obj, Boolean& lockTaken);
    public static void Exit(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    private static int MillisecondsTimeoutFromTimeSpan(TimeSpan timeout);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    private static void ReliableEnterTimeout(object obj, int timeout, Boolean& lockTaken);
    public static bool IsEntered(object obj);
    private static bool IsEnteredNative(object obj);
    private static bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
    public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj);
    private static void ObjPulse(object obj);
    public static void Pulse(object obj);
    private static void ObjPulseAll(object obj);
    public static void PulseAll(object obj);
}
public class System.Threading.Mutex : WaitHandle {
    public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    public Mutex(bool initiallyOwned, string name);
    public Mutex(bool initiallyOwned);
    private Mutex(SafeWaitHandle handle);
    public static Mutex OpenExisting(string name);
    public static bool TryOpenExisting(string name, Mutex& result);
    public void ReleaseMutex();
    private void CreateMutexCore(bool initiallyOwned, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Mutex& result);
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
public class System.Threading.Overlapped : object {
    private OverlappedData m_overlappedData;
    private static PinnableBufferCache s_overlappedDataCache;
    public IAsyncResult AsyncResult { get; public set; }
    public int OffsetLow { get; public set; }
    public int OffsetHigh { get; public set; }
    [ObsoleteAttribute("This property is not 64-bit compatible.  Use EventHandleIntPtr instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public int EventHandle { get; public set; }
    public IntPtr EventHandleIntPtr { get; public set; }
    internal _IOCompletionCallback iocbHelper { get; }
    internal IOCompletionCallback UserCallback { get; }
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [ObsoleteAttribute("This constructor is not 64-bit compatible.  Use the constructor that takes an IntPtr for the event handle.  http://go.microsoft.com/fwlink/?linkid=14202")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    private static Overlapped();
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    internal _IOCompletionCallback get_iocbHelper();
    internal IOCompletionCallback get_UserCallback();
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This method is not safe.  Use Pack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This method is not safe.  Use UnsafePack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
}
internal class System.Threading.OverlappedData : object {
    internal IAsyncResult m_asyncResult;
    internal IOCompletionCallback m_iocb;
    internal _IOCompletionCallback m_iocbHelper;
    internal Overlapped m_overlapped;
    private object m_userObject;
    private IntPtr m_pinSelf;
    private IntPtr m_userObjectInternal;
    private int m_AppDomainId;
    private byte m_isArray;
    private byte m_toBeCleaned;
    internal NativeOverlapped m_nativeOverlapped;
    internal IntPtr UserHandle { get; internal set; }
    internal void ReInitialize();
    internal NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    internal NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    internal IntPtr get_UserHandle();
    internal void set_UserHandle(IntPtr value);
    private NativeOverlapped* AllocateNativeOverlapped();
    internal static void FreeNativeOverlapped(NativeOverlapped* nativeOverlappedPtr);
    internal static OverlappedData GetOverlappedFromNative(NativeOverlapped* nativeOverlappedPtr);
    internal static void CheckVMForIOPacket(NativeOverlapped*& pOVERLAP, UInt32& errorCode, UInt32& numBytes);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.PlatformHelper : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_lastProcessorCountRefreshTicks;
    internal static bool IsSingleProcessor;
    internal static int ProcessorCount { get; }
    private static PlatformHelper();
    internal static int get_ProcessorCount();
}
public class System.Threading.PreAllocatedOverlapped : object {
    internal ThreadPoolBoundHandleOverlapped _overlapped;
    private DeferredDisposableLifetime`1<PreAllocatedOverlapped> _lifetime;
    [CLSCompliantAttribute("False")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    internal bool AddRef();
    internal void Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.QueueUserWorkItemCallback : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    private ExecutionContext _context;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallback(WaitCallback callback, object state, ExecutionContext context);
    private static QueueUserWorkItemCallback();
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.QueueUserWorkItemCallback`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    private ExecutionContext _context;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallback`1(Action`1<TState> callback, TState state, ExecutionContext context);
    private static QueueUserWorkItemCallback`1();
    public virtual void ExecuteWorkItem();
}
internal abstract class System.Threading.QueueUserWorkItemCallbackBase : object {
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallbackDefaultContext(WaitCallback callback, object state);
    private static QueueUserWorkItemCallbackDefaultContext();
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallbackDefaultContext`1(Action`1<TState> callback, TState state);
    private static QueueUserWorkItemCallbackDefaultContext`1();
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.ReaderWriterCount : object {
    public long lockID;
    public int readercount;
    public int writercount;
    public int upgradecount;
    public ReaderWriterCount next;
}
public class System.Threading.ReaderWriterLockSlim : object {
    private static int ProcessorCount;
    private bool _fIsReentrant;
    private SpinLock _spinLock;
    private UInt32 _numWriteWaiters;
    private UInt32 _numReadWaiters;
    private UInt32 _numWriteUpgradeWaiters;
    private UInt32 _numUpgradeWaiters;
    private WaiterStates _waiterStates;
    private int _upgradeLockOwnerId;
    private int _writeLockOwnerId;
    private EventWaitHandle _writeEvent;
    private EventWaitHandle _readEvent;
    private EventWaitHandle _upgradeEvent;
    private EventWaitHandle _waitUpgradeEvent;
    private static long s_nextLockID;
    private long _lockID;
    [ThreadStaticAttribute]
private static ReaderWriterCount t_rwc;
    private bool _fUpgradeThreadHoldingRead;
    private UInt32 _owners;
    private bool _fDisposed;
    private bool HasNoWaiters { get; private set; }
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    private static ReaderWriterLockSlim();
    private void InitializeThreadCounts();
    private bool get_HasNoWaiters();
    private void set_HasNoWaiters(bool value);
    private static bool IsRWEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRWCount(bool dontAllocate);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(EventWaitHandle& waitEvent, EnterLockType enterLockType);
    private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, EnterLockType enterLockType);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private void ExitAndWakeUpAppropriateReadWaiters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private bool ShouldSpinForEnterAnyRead();
    private bool ShouldSpinForEnterAnyWrite(bool isUpgradeToWrite);
    private static void SpinWait(int spinCount);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    private RegisteredWaitHandleSafe internalRegisteredWait;
    internal void SetHandle(IntPtr handle);
    internal void SetWaitObject(WaitHandle waitObject);
    public bool Unregister(WaitHandle waitObject);
}
internal class System.Threading.RegisteredWaitHandleSafe : CriticalFinalizerObject {
    private IntPtr registeredWaitHandle;
    private WaitHandle m_internalWaitObject;
    private bool bReleaseNeeded;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private static IntPtr InvalidHandle { get; }
    private static IntPtr get_InvalidHandle();
    internal IntPtr GetHandle();
    internal void SetHandle(IntPtr handle);
    internal void SetWaitObject(WaitHandle waitObject);
    internal bool Unregister(WaitHandle waitObject);
    private bool ValidHandle();
    protected virtual override void Finalize();
    private static void WaitHandleCleanupNative(IntPtr handle);
    private static bool UnregisterWaitNative(IntPtr handle, SafeHandle waitObject);
}
public class System.Threading.Semaphore : WaitHandle {
    public Semaphore(int initialCount, int maximumCount);
    public Semaphore(int initialCount, int maximumCount, string name);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private static SafeWaitHandle CreateSemaphore(int initialCount, int maximumCount, string name);
    public static Semaphore OpenExisting(string name);
    public static bool TryOpenExisting(string name, Semaphore& result);
    private static OpenExistingResult OpenExistingWorker(string name, Semaphore& result);
    public int Release();
    public int Release(int releaseCount);
}
[TypeForwardedFromAttribute("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
public class System.Threading.SemaphoreSlim : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private int m_waitCount;
    private int m_countOfWaitersPulsedToWake;
    private object m_lockObj;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle;
    private TaskNode m_asyncHead;
    private TaskNode m_asyncTail;
    private static Task`1<bool> s_trueTask;
    private static Task`1<bool> s_falseTask;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    private TaskNode CreateAndAddAsyncWaiter();
    private bool RemoveAsyncWaiter(TaskNode task);
    [AsyncStateMachineAttribute("System.Threading.SemaphoreSlim/<WaitUntilCountOrTimeoutAsync>d__33")]
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    private static void QueueWaiterTask(TaskNode waiterTask);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
public class System.Threading.SpinLock : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_owner;
    private static int MAXIMUM_WAITERS;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static SpinLock();
    private int CompareExchange(Int32& location, int value, int comparand, Boolean& success);
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken);
    public void Exit();
    public void Exit(bool useMemoryBarrier);
    private void ExitSlowPath(bool useMemoryBarrier);
    public bool get_IsHeld();
    public bool get_IsHeldByCurrentThread();
    public bool get_IsThreadOwnerTrackingEnabled();
}
public class System.Threading.SpinWait : ValueType {
    internal static int SpinCountforSpinBeforeWait;
    private int _count;
    public int Count { get; internal set; }
    public bool NextSpinWillYield { get; }
    private static SpinWait();
    public int get_Count();
    internal void set_Count(int value);
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    internal void SpinOnce(int sleep1Threshold);
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal enum System.Threading.StackCrawlMark : Enum {
    public int value__;
    public static StackCrawlMark LookForMe;
    public static StackCrawlMark LookForMyCaller;
    public static StackCrawlMark LookForMyCallersCaller;
    public static StackCrawlMark LookForThread;
}
public class System.Threading.SynchronizationContext : object {
    private SynchronizationContextProperties _props;
    private static Type s_cachedPreparedType1;
    private static Type s_cachedPreparedType2;
    private static Type s_cachedPreparedType3;
    private static Type s_cachedPreparedType4;
    private static Type s_cachedPreparedType5;
    public static SynchronizationContext Current { get; }
    protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [CLSCompliantAttribute("False")]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
private static int WaitHelperNative(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public static void SetSynchronizationContext(SynchronizationContext syncContext);
    public static SynchronizationContext get_Current();
    public virtual SynchronizationContext CreateCopy();
    private static int InvokeWaitMethodHelper(SynchronizationContext syncContext, IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
[FlagsAttribute]
internal enum System.Threading.SynchronizationContextProperties : Enum {
    public int value__;
    public static SynchronizationContextProperties None;
    public static SynchronizationContextProperties RequireWaitNotification;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> m_tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
internal enum System.Threading.Tasks.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Started;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Error;
}
internal static class System.Threading.Tasks.AsyncCausalityTracer : object {
    internal static bool LoggingOn { get; }
    internal static void EnableToETW(bool enabled);
    internal static bool get_LoggingOn();
    internal static void TraceOperationCreation(CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext);
    internal static void TraceOperationCompletion(CausalityTraceLevel traceLevel, int taskId, AsyncCausalityStatus status);
    internal static void TraceOperationRelation(CausalityTraceLevel traceLevel, int taskId, CausalityRelation relation);
    internal static void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, int taskId, CausalitySynchronousWork work);
    internal static void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work);
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    private ExecutionContext m_capturedContext;
    protected Action m_action;
    protected int m_continuationId;
    private static ContextCallback s_invokeActionCallback;
    internal static bool IsValidLocationForInlining { get; }
    internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    internal virtual void Run(Task task, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    private void ExecuteWorkItemHelper();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    private static void InvokeAction(object state);
    protected static ContextCallback GetInvokeActionCallback();
    protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    internal static void RunOrScheduleAction(Action action, bool allowInlining);
    internal static void RunOrScheduleAction(IAsyncStateMachineBox box, bool allowInlining);
    internal static void UnsafeScheduleAction(Action action, Task task);
    protected static void ThrowAsyncIfNecessary(Exception exc);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal enum System.Threading.Tasks.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum System.Threading.Tasks.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
internal enum System.Threading.Tasks.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
internal class System.Threading.Tasks.CompletionActionInvoker : object {
    private ITaskCompletionAction m_action;
    private Task m_completingTask;
    internal CompletionActionInvoker(ITaskCompletionAction action, Task completingTask);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
[DebuggerDisplayAttribute("Concurrent={ConcurrentTaskCountForDebugger}, Exclusive={ExclusiveTaskCountForDebugger}, Mode={ModeForDebugger}")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    private ConcurrentDictionary`2<int, ProcessingMode> m_threadProcessingMapping;
    private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
    private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
    private TaskScheduler m_underlyingTaskScheduler;
    private int m_maxConcurrencyLevel;
    private int m_maxItemsPerTask;
    private int m_processingCount;
    private CompletionState m_completionState;
    private static int DefaultMaxConcurrencyLevel { get; }
    private object ValueLock { get; }
    public Task Completion { get; }
    private bool CompletionRequested { get; }
    private bool ReadyToComplete { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    private int ConcurrentTaskCountForDebugger { get; }
    private int ExclusiveTaskCountForDebugger { get; }
    private ProcessingMode ModeForDebugger { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    private static int get_DefaultMaxConcurrencyLevel();
    private object get_ValueLock();
    public void Complete();
    public Task get_Completion();
    private CompletionState EnsureCompletionStateInitialized();
    private bool get_CompletionRequested();
    private void RequestCompletion();
    private void CleanupStateIfCompletingAndQuiesced();
    private bool get_ReadyToComplete();
    private void CompleteTaskAsync();
    private void FaultWithTask(Task faultedTask);
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    private int get_ConcurrentTaskCountForDebugger();
    private int get_ExclusiveTaskCountForDebugger();
    private void ProcessAsyncIfNecessary(bool fairly);
    private void ProcessExclusiveTasks();
    private void ProcessConcurrentTasks();
    private ProcessingMode get_ModeForDebugger();
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    private Task m_antecedent;
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    private Task m_antecedent;
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal static class System.Threading.Tasks.GenericDelegateCache`2 : object {
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate;
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate;
    private static GenericDelegateCache`2();
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public bool InvokeMayRunArbitraryCode { get; }
    public abstract virtual void Invoke(Task completingTask);
    public abstract virtual bool get_InvokeMayRunArbitraryCode();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
}
internal class System.Threading.Tasks.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual TResult GetResult(short token);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
internal class System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    private TaskScheduler m_taskScheduler;
    internal StandardTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    private static SendOrPostCallback s_postCallback;
    private static ContextCallback s_postActionCallback;
    private SynchronizationContext m_syncContext;
    internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext);
    private static SynchronizationContextAwaitTaskContinuation();
    internal sealed virtual void Run(Task task, bool canInlineContinuationTask);
    private static void PostAction(object state);
    private static Action GetActionLogDelegate(int continuationId, Action action);
    private static ContextCallback GetPostActionCallback();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
public class System.Threading.Tasks.Task : object {
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    internal static int s_taskIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskId;
    internal Delegate m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject;
    private static object s_taskCompletionSentinel;
    internal static bool s_asyncDebuggingEnabled;
    private static Dictionary`2<int, Task> s_currentActiveTasks;
    private static object s_activeTasksLock;
    internal ContingentProperties m_contingentProperties;
    private static Action`1<object> s_taskCancelCallback;
    [CompilerGeneratedAttribute]
private static TaskFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    private static Predicate`1<Task> s_IsExceptionObservedByParentPredicate;
    private static ContextCallback s_ecCallback;
    private static Predicate`1<object> s_IsTaskContinuationNullPredicate;
    private Task ParentForDebugger { get; }
    private int StateFlagsForDebugger { get; }
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    internal bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    internal static Task InternalCurrent { get; }
    public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    public static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    private Task get_ParentForDebugger();
    private int get_StateFlagsForDebugger();
    internal static bool AddToActiveTasks(Task task);
    internal static void RemoveFromActiveTasks(int taskId);
    internal void TaskConstructorCore(Delegate action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
    private static void TaskCancelCallback(object o);
    private string get_DebuggerDisplayMethodDescription();
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    private bool AtomicStateUpdateSlow(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    private void NotifyDebuggerOfWaitCompletion();
    internal bool MarkStarted();
    internal bool FireTaskScheduledIfNeeded(TaskScheduler ts);
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions);
    internal static int NewId();
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized();
    internal ContingentProperties EnsureContingentPropertiesInitializedUnsafe();
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    private static bool IsCompletedMethod(int flags);
    public bool get_IsCompletedSuccessfully();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    [CompilerGeneratedAttribute]
public static TaskFactory get_Factory();
    [CompilerGeneratedAttribute]
public static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool userDelegateExecute);
    private void FinishSlow(bool userDelegateExecute);
    private void FinishStageTwo();
    internal void FinishStageThree();
    internal void NotifyParentIfPotentiallyAttachedTask();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren(ContingentProperties props);
    internal void FinishThreadAbortedTask(bool delegateRan);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    internal bool ExecuteEntry();
    internal void ExecuteEntryUnsafe();
    internal void ExecuteEntryCancellationRequestedOrCanceled();
    private void ExecuteWithThreadLocal(Task& currentTaskSlot);
    internal virtual void InnerInvoke();
    private void HandleException(Exception unhandledException);
    public TaskAwaiter GetAwaiter();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
    internal void UnsafeSetContinuationForAwait(IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool InternalWaitCore(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinWait(int millisecondsTimeout);
    internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    internal void FinishContinuations();
    private void RunContinuations(object continuationObject);
    private void RunOrQueueCompletionAction(ITaskCompletionAction completionAction, bool allowInlining);
    private void LogFinishCompletionNotification();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action);
    private void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
    private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
    private bool AddTaskContinuation(object tc, bool addBeforeOthers);
    internal void RemoveContinuation(object continuationObject);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static bool WaitAllCore(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static void AddToList(T item, List`1& list, int initSize);
    private static bool WaitAllBlockingCore(List`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void AddExceptionsForCompletedTask(List`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static int WaitAnyCore(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(OperationCanceledException exception);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    private static Task InternalWhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    private static Task`1<TResult[]> InternalWhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    internal static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    internal static Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
    private static Task GetActiveTaskFromId(int taskId);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
public class System.Threading.Tasks.Task`1 : Task {
    internal TResult m_result;
    private static TaskFactory`1<TResult> s_Factory;
    internal static Func`2<Task`1<Task>, Task`1<TResult>> TaskWhenAnyCast;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task`1();
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    public TResult get_Result();
    internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    internal bool TrySetException(object exceptionObject);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task _canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> _task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    private void SpinUntilCompleted();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public void SetCanceled();
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
    internal abstract virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private static bool s_failFastOnUnobservedException;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_domainUnloadStarted;
    private static EventHandler modreq(System.Runtime.CompilerServices.IsVolatile) s_adUnloadEventHandler;
    private Task m_task;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions;
    private ExceptionDispatchInfo m_cancellationException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled;
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    private static TaskExceptionHolder();
    private static bool ShouldFailFastOnUnobservedException();
    private static void EnsureADUnloadCallbackRegistered();
    private static void AppDomainUnloadCallback(object sender, EventArgs e);
    protected virtual override void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject, bool representsCancellation);
    private void SetCancellationException(object exceptionObject);
    private void AddFaultException(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks);
    internal static void CommonCWAnyLogicCleanup(Task`1<Task> continuation);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[DebuggerDisplayAttribute("Id={Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers;
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId;
    private static EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException;
    private static object _unobservedTaskExceptionLockObject;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    protected internal abstract virtual void QueueTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    internal void InternalQueueTask(Task task);
    private void AddToActiveTaskSchedulers();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    protected bool TryExecuteTask(Task task);
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    internal Task[] GetScheduledTasksForDebugger();
    internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    private TaskScheduler m_scheduler;
    internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [IteratorStateMachineAttribute("System.Threading.Tasks.ThreadPoolTaskScheduler/<FilterTasksFromWorkItems>d__6")]
private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<IThreadPoolWorkItem> tpwItems);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
[EventSourceAttribute]
internal class System.Threading.Tasks.TplEtwProvider : EventSource {
    internal bool TasksSetActivityIds;
    internal bool Debug;
    private bool DebugActivityId;
    public static TplEtwProvider Log;
    private static TplEtwProvider();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [EventAttribute("7")]
public void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions, int appDomain);
    [EventAttribute("8")]
public void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("9")]
public void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
    [EventAttribute("10")]
public void TaskWaitBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, TaskWaitBehavior Behavior, int ContinueWithTaskID);
    [EventAttribute("11")]
public void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("13")]
public void TaskWaitContinuationComplete(int TaskID);
    [EventAttribute("19")]
public void TaskWaitContinuationStarted(int TaskID);
    [EventAttribute("12")]
public void AwaitTaskContinuationScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ContinuwWithTaskId);
    [NonEventAttribute]
public void RunningContinuation(int TaskID, object Object);
    [EventAttribute("20")]
private void RunningContinuation(int TaskID, long Object);
    [NonEventAttribute]
public void RunningContinuationList(int TaskID, int Index, object Object);
    [EventAttribute("21")]
public void RunningContinuationList(int TaskID, int Index, long Object);
    [EventAttribute("23")]
public void DebugFacilityMessage(string Facility, string Message);
    [EventAttribute("24")]
public void DebugFacilityMessage1(string Facility, string Message, string Value1);
    [EventAttribute("25")]
public void SetActivityId(Guid NewId);
    [EventAttribute("26")]
public void NewID(int TaskID);
    [NonEventAttribute]
public void IncompleteAsyncMethod(IAsyncStateMachineBox stateMachineBox);
    [EventAttribute("27")]
private void IncompleteAsyncMethod(string stateMachineDescription);
    internal static Guid CreateGuidForTaskID(int taskID);
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    private byte _state;
    private bool _lookForOce;
    public bool InvokeMayRunArbitraryCode { get; }
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
    private void InvokeCore(Task completingTask);
    private void InvokeCoreAsync(Task completingTask);
    private void ProcessCompletedOuterTask(Task task);
    private bool TrySetFromTask(Task task, bool lookForOce);
    private void ProcessInnerTask(Task task);
    public sealed virtual bool get_InvokeMayRunArbitraryCode();
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private static Task s_canceledTask;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    internal static Task CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    private static ValueTask();
    internal static Task get_CompletedTask();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    [StackTraceHiddenAttribute]
internal void ThrowIfCompletedUnsuccessfully();
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
[IsReadOnlyAttribute]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1<TResult> s_canceledTask;
    internal object _obj;
    internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public virtual string ToString();
}
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
internal class System.Threading.Thread : RuntimeThread {
    private ExecutionContext m_ExecutionContext;
    private SynchronizationContext m_SynchronizationContext;
    private string m_Name;
    private Delegate m_Delegate;
    private object m_ThreadStartArg;
    private IntPtr DONT_USE_InternalThread;
    private int m_Priority;
    private int _managedThreadId;
    [ThreadStaticAttribute]
internal static CultureInfo m_CurrentCulture;
    [ThreadStaticAttribute]
internal static CultureInfo m_CurrentUICulture;
    public int ManagedThreadId { get; }
    internal ExecutionContext ExecutionContext { get; internal set; }
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    public static Thread CurrentThread { get; }
    public CultureInfo CurrentUICulture { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    public string Name { get; public set; }
    public Thread(ThreadStart start);
    internal Thread(ThreadStart start, int maxStackSize);
    public Thread(ParameterizedThreadStart start);
    internal Thread(ParameterizedThreadStart start, int maxStackSize);
    public virtual int GetHashCode();
    public int get_ManagedThreadId();
    internal ThreadHandle GetNativeHandle();
    public void Start(object parameter);
    public void Start();
    internal ExecutionContext get_ExecutionContext();
    internal void set_ExecutionContext(ExecutionContext value);
    internal SynchronizationContext get_SynchronizationContext();
    internal void set_SynchronizationContext(SynchronizationContext value);
    private void StartInternal();
    internal static IntPtr InternalGetCurrentThread();
    private static void SleepInternal(int millisecondsTimeout);
    public static void Sleep(int millisecondsTimeout);
    private static void SpinWaitInternal(int iterations);
    public static void SpinWait(int iterations);
    private static bool YieldInternal();
    internal static bool Yield();
    public static Thread get_CurrentThread();
    [ReliabilityContractAttribute("3", "1")]
private static Thread GetCurrentThreadNative();
    private void SetStartHelper(Delegate start, int maxStackSize);
    private void SetStart(Delegate start, int maxStackSize);
    protected virtual override void Finalize();
    private void InternalFinalize();
    public CultureInfo get_CurrentUICulture();
    public void set_CurrentUICulture(CultureInfo value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    private static void nativeInitCultureAccessors();
    private static AppDomain GetDomainInternal();
    private static AppDomain GetFastDomainInternal();
    internal static AppDomain GetDomain();
    internal static int GetDomainID();
    public string get_Name();
    public void set_Name(string value);
    private static void InformThreadNameChange(ThreadHandle t, string name, int len);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    internal ThreadAbortException(SerializationInfo info, StreamingContext context);
    public object get_ExceptionState();
}
internal class System.Threading.ThreadHandle : ValueType {
    private IntPtr m_ptr;
    internal ThreadHandle(IntPtr pThread);
}
internal class System.Threading.ThreadHelper : object {
    private Delegate _start;
    private object _startArg;
    private ExecutionContext _executionContext;
    internal static ContextCallback _ccb;
    internal ThreadHelper(Delegate start);
    private static ThreadHelper();
    internal void SetExecutionContextHelper(ExecutionContext ec);
    private static void ThreadStart_Context(object state);
    internal void ThreadStart(object obj);
    internal void ThreadStart();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}, Count={ValuesCountForDebugDisplay}")]
public class System.Threading.ThreadLocal`1 : object {
    private Func`1<T> m_valueFactory;
    [ThreadStaticAttribute]
private static LinkedSlotVolatile[] ts_slotArray;
    [ThreadStaticAttribute]
private static FinalizationHelper<T> ts_finalizationHelper;
    private int m_idComplement;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_initialized;
    private static IdManager<T> s_idManager;
    private LinkedSlot<T> m_linkedSlot;
    private bool m_trackAllValues;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    private int ValuesCountForDebugDisplay { get; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    private void Initialize(Func`1<T> valueFactory, bool trackAllValues);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private T GetValueSlow();
    private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray);
    private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value);
    public IList`1<T> get_Values();
    private List`1<T> GetValuesAsList();
    private int get_ValuesCountForDebugDisplay();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
    private void GrowTable(LinkedSlotVolatile[]& table, int minLength);
    private static int GetNewTableSize(int minSize);
}
public static class System.Threading.ThreadPool : object {
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    private static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, bool compressStack);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static bool QueueUserWorkItem(WaitCallback callBack);
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    public static bool QueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    internal static void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal);
    internal static bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem);
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetQueuedWorkItems>d__20")]
internal static IEnumerable`1<IThreadPoolWorkItem> GetQueuedWorkItems();
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetLocallyQueuedWorkItems>d__21")]
internal static IEnumerable`1<IThreadPoolWorkItem> GetLocallyQueuedWorkItems();
    internal static IEnumerable`1<IThreadPoolWorkItem> GetGloballyQueuedWorkItems();
    private static Object[] ToObjectArray(IEnumerable`1<IThreadPoolWorkItem> workitems);
    internal static Object[] GetQueuedWorkItemsForDebugger();
    internal static Object[] GetGloballyQueuedWorkItemsForDebugger();
    internal static Object[] GetLocallyQueuedWorkItemsForDebugger();
    internal static bool RequestWorkerThread();
    private static bool PostQueuedCompletionStatus(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    private static void EnsureVMInitialized();
    private static void EnsureVMInitializedCore();
    private static bool SetMinThreadsNative(int workerThreads, int completionPortThreads);
    private static bool SetMaxThreadsNative(int workerThreads, int completionPortThreads);
    private static void GetMinThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    private static void GetMaxThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    private static void GetAvailableThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    internal static bool NotifyWorkItemComplete();
    internal static void ReportThreadStatus(bool isWorking);
    internal static void NotifyWorkItemProgress();
    internal static void NotifyWorkItemProgressNative();
    private static void InitializeVMTp(Boolean& enableWorkerTracking);
    private static IntPtr RegisterWaitForSingleObjectNative(WaitHandle waitHandle, object state, UInt32 timeOutInterval, bool executeOnlyOnce, RegisteredWaitHandle registeredWaitHandle);
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
public static bool BindHandle(IntPtr osHandle);
    public static bool BindHandle(SafeHandle osHandle);
    private static bool BindIOCompletionCallbackNative(IntPtr fileHandle);
}
public class System.Threading.ThreadPoolBoundHandle : object {
    private SafeHandle _handle;
    private bool _isDisposed;
    public SafeHandle Handle { get; }
    private ThreadPoolBoundHandle(SafeHandle handle);
    public SafeHandle get_Handle();
    public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
    private static ThreadPoolBoundHandleOverlapped GetOverlappedWrapper(NativeOverlapped* overlapped, ThreadPoolBoundHandle expectedBoundHandle);
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
    private static ThreadPoolBoundHandle BindHandleCore(SafeHandle handle);
}
internal class System.Threading.ThreadPoolBoundHandleOverlapped : Overlapped {
    private static IOCompletionCallback s_completionCallback;
    private IOCompletionCallback _userCallback;
    internal object _userState;
    internal PreAllocatedOverlapped _preAllocated;
    internal NativeOverlapped* _nativeOverlapped;
    internal ThreadPoolBoundHandle _boundHandle;
    internal bool _completed;
    public ThreadPoolBoundHandleOverlapped(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    private static ThreadPoolBoundHandleOverlapped();
    private static void CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
}
internal static class System.Threading.ThreadPoolGlobals : object {
    public static int processorCount;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) vmTpInitialized;
    public static bool enableWorkerTracking;
    public static ThreadPoolWorkQueue workQueue;
    private static ThreadPoolGlobals();
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    internal bool loggingEnabled;
    internal ConcurrentQueue`1<IThreadPoolWorkItem> workItems;
    private PaddingFor32 pad1;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numOutstandingThreadRequests;
    private PaddingFor32 pad2;
    public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
    internal void EnsureThreadRequested();
    internal void MarkThreadRequestSatisfied();
    public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal);
    internal bool LocalFindAndPop(IThreadPoolWorkItem callback);
    public IThreadPoolWorkItem Dequeue(ThreadPoolWorkQueueThreadLocals tl, Boolean& missedSteal);
    internal static bool Dispatch();
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public FastRandom random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    private void CleanUp();
    protected virtual override void Finalize();
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(Exception reason);
    private ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
public static class System.Threading.Timeout : object {
    public static TimeSpan InfiniteTimeSpan;
    public static int Infinite;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
public class System.Threading.Timer : MarshalByRefObject {
    private TimerHolder m_timer;
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback);
    private void TimerSetup(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public bool Change(int dueTime, int period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public bool Change(long dueTime, long period);
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual void Dispose();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.TimerHolder : object {
    internal TimerQueueTimer m_timer;
    public TimerHolder(TimerQueueTimer timer);
    protected virtual override void Finalize();
    public void Close();
    public bool Close(WaitHandle notifyObject);
}
internal class System.Threading.TimerQueue : object {
    [CompilerGeneratedAttribute]
private static TimerQueue[] <Instances>k__BackingField;
    private int m_id;
    private AppDomainTimerSafeHandle m_appDomainTimer;
    private bool m_isAppDomainTimerScheduled;
    private int m_currentAppDomainTimerStartTicks;
    private UInt32 m_currentAppDomainTimerDuration;
    private TimerQueueTimer m_timers;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_pauseTicks;
    public static TimerQueue[] Instances { get; }
    private static int TickCount { get; }
    private TimerQueue(int id);
    private static TimerQueue();
    [CompilerGeneratedAttribute]
public static TimerQueue[] get_Instances();
    private static TimerQueue[] CreateTimerQueues();
    private static int get_TickCount();
    private bool EnsureAppDomainTimerFiresBy(UInt32 requestedDuration);
    internal static void AppDomainTimerCallback(int id);
    private static AppDomainTimerSafeHandle CreateAppDomainTimer(UInt32 dueTime, int id);
    private static bool ChangeAppDomainTimer(AppDomainTimerSafeHandle handle, UInt32 dueTime);
    private static bool DeleteAppDomainTimer(IntPtr handle);
    private void FireNextTimers();
    private static void QueueTimerCompletion(TimerQueueTimer timer);
    public bool UpdateTimer(TimerQueueTimer timer, UInt32 dueTime, UInt32 period);
    public void DeleteTimer(TimerQueueTimer timer);
}
internal class System.Threading.TimerQueueTimer : object {
    private TimerQueue m_associatedTimerQueue;
    internal TimerQueueTimer m_next;
    internal TimerQueueTimer m_prev;
    internal int m_startTicks;
    internal UInt32 m_dueTime;
    internal UInt32 m_period;
    private TimerCallback m_timerCallback;
    private object m_state;
    private ExecutionContext m_executionContext;
    private int m_callbacksRunning;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_canceled;
    private WaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) m_notifyWhenNoCallbacksRunning;
    private static ContextCallback s_callCallbackInContext;
    internal TimerQueueTimer(TimerCallback timerCallback, object state, UInt32 dueTime, UInt32 period);
    private static TimerQueueTimer();
    internal bool Change(UInt32 dueTime, UInt32 period);
    public void Close();
    public bool Close(WaitHandle toSignal);
    internal void Fire();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    internal void SignalNoCallbacksRunning();
    internal void CallCallback();
}
public static class System.Threading.Volatile : object {
    [NonVersionableAttribute]
public static bool Read(Boolean& location);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte Read(SByte& location);
    [NonVersionableAttribute]
public static byte Read(Byte& location);
    [NonVersionableAttribute]
public static short Read(Int16& location);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Read(UInt16& location);
    [NonVersionableAttribute]
public static int Read(Int32& location);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Read(UInt32& location);
    [NonVersionableAttribute]
public static long Read(Int64& location);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong Read(UInt64& location);
    [NonVersionableAttribute]
public static IntPtr Read(IntPtr& location);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UIntPtr Read(UIntPtr& location);
    [NonVersionableAttribute]
public static float Read(Single& location);
    [NonVersionableAttribute]
public static double Read(Double& location);
    [NonVersionableAttribute]
public static T Read(T& location);
    [NonVersionableAttribute]
public static void Write(Boolean& location, bool value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(SByte& location, sbyte value);
    [NonVersionableAttribute]
public static void Write(Byte& location, byte value);
    [NonVersionableAttribute]
public static void Write(Int16& location, short value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Write(UInt16& location, ushort value);
    [NonVersionableAttribute]
public static void Write(Int32& location, int value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Write(UInt32& location, UInt32 value);
    [NonVersionableAttribute]
public static void Write(Int64& location, long value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Write(UInt64& location, ulong value);
    [NonVersionableAttribute]
public static void Write(IntPtr& location, IntPtr value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(UIntPtr& location, UIntPtr value);
    [NonVersionableAttribute]
public static void Write(Single& location, float value);
    [NonVersionableAttribute]
public static void Write(Double& location, double value);
    [NonVersionableAttribute]
public static void Write(T& location, T value);
}
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    public static int WaitTimeout;
    private static int MAX_WAITHANDLES;
    private IntPtr waitHandle;
    internal SafeWaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) safeWaitHandle;
    internal bool hasThreadAffinity;
    protected static IntPtr InvalidHandle;
    private static int WAIT_OBJECT_0;
    private static int WAIT_ABANDONED;
    private static int WAIT_FAILED;
    private static int ERROR_TOO_MANY_POSTS;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    private static IntPtr GetInvalidHandle();
    private void Init();
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    internal void SetHandleInternal(SafeWaitHandle handle);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(TimeSpan timeout);
    private bool WaitOne(long timeout, bool exitContext);
    internal static bool InternalWaitOne(SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    private static int WaitOneNative(SafeHandle waitableSafeHandle, UInt32 millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    private static int WaitMultiple(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    private static int SignalAndWaitOne(SafeWaitHandle waitHandleToSignal, SafeWaitHandle waitHandleToWaitOn, int millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    private static void ThrowAbandonedMutexException();
    private static void ThrowAbandonedMutexException(int location, WaitHandle handle);
    public virtual void Close();
    protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
[StackTraceHiddenAttribute]
internal static class System.ThrowHelper : object {
    internal static void ThrowArrayTypeMismatchException();
    internal static void ThrowInvalidTypeWithPointersNotSupported(Type targetType);
    internal static void ThrowIndexOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException();
    internal static void ThrowArgumentException_DestinationTooShort();
    internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    internal static void ThrowArgumentOutOfRange_IndexException();
    internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    internal static void ThrowKeyNotFoundException(T key);
    internal static void ThrowArgumentException(ExceptionResource resource);
    internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentNullException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    internal static void ThrowSerializationException(ExceptionResource resource);
    internal static void ThrowRankException(ExceptionResource resource);
    internal static void ThrowNotSupportedException(ExceptionResource resource);
    internal static void ThrowObjectDisposedException(ExceptionResource resource);
    internal static void ThrowNotSupportedException();
    internal static void ThrowAggregateException(List`1<Exception> exceptions);
    internal static void ThrowOutOfMemoryException();
    internal static void ThrowArgumentException_Argument_InvalidArrayType();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    internal static void ThrowInvalidOperationException_EnumCurrent(int index);
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    internal static void ThrowInvalidOperationException_InvalidOperation_NoValue();
    internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    internal static void ThrowArraySegmentCtorValidationFailedExceptions(Array array, int offset, int count);
    private static Exception GetArraySegmentCtorValidationFailedException(Array array, int offset, int count);
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    internal static InvalidOperationException GetInvalidOperationException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    internal static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    private static ArgumentException GetArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException_EnumCurrent(int index);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    protected TimeoutException(SerializationInfo info, StreamingContext context);
}
public class System.TimeSpan : ValueType {
    public static long TicksPerMillisecond;
    public static long TicksPerSecond;
    public static long TicksPerMinute;
    public static long TicksPerHour;
    public static long TicksPerDay;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(long ticks);
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    private static TimeSpan Interval(double value, int scale);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    public TimeSpan Multiply(double factor);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    private static void ValidateStyles(TimeSpanStyles style, string parameterName);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
}
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    private static TimeZone modreq(System.Runtime.CompilerServices.IsVolatile) currentTimeZone;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static TimeZone();
    private static object get_InternalSyncObject();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneInfo : object {
    private string _id;
    private string _displayName;
    private string _standardDisplayName;
    private string _daylightDisplayName;
    private TimeSpan _baseUtcOffset;
    private bool _supportsDaylightSavingTime;
    private AdjustmentRule[] _adjustmentRules;
    private static TimeZoneInfo s_utcTimeZone;
    private static CachedData s_cachedData;
    private static DateTime s_maxDateOnly;
    private static DateTime s_minDateOnly;
    private static TimeSpan MaxOffset;
    private static TimeSpan MinOffset;
    public string Id { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private TimeZoneInfo(SerializationInfo info, StreamingContext context);
    private TimeZoneInfo(Byte[] data, string id, bool dstDisabled);
    private static TimeZoneInfo();
    public string get_Id();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    private AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(DateTime adjustedTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetPreviousAdjustmentRule(AdjustmentRule rule, Nullable`1<int> ruleIndex);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    private TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    private bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    private static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags, CachedData cachedData);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, bool dateTimeisUtc, Nullable`1& ruleIndex);
    private int CompareAdjustmentRuleToDateTime(AdjustmentRule rule, AdjustmentRule previousRule, DateTime dateTime, DateTime dateOnly, bool dateTimeisUtc);
    private DateTime ConvertToUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertToFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta, bool convertToUtc);
    private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone, Boolean& isAmbiguousLocalDst);
    private DaylightTimeStruct GetDaylightTime(int year, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime, TimeZoneInfoOptions flags);
    private TimeSpan GetDaylightSavingsStartOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private TimeSpan GetDaylightSavingsEndOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule);
    private static bool GetIsDaylightSavingsFromUtc(DateTime time, int year, TimeSpan utc, AdjustmentRule rule, Nullable`1<int> ruleIndex, Boolean& isAmbiguousLocalDst, TimeZoneInfo zone);
    private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment, AdjustmentRule rule);
    private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone, TimeZoneInfoOptions flags);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime);
    private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData);
    private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
    private static TimeSpan GetUtcOffset(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static bool IsValidAdjustmentRuleOffest(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static void NormalizeAdjustmentRuleOffset(TimeSpan baseUtcOffset, AdjustmentRule& adjustmentRule);
    private void GetDisplayName(TimeZoneDisplayNameType nameType, String& displayName);
    public AdjustmentRule[] GetAdjustmentRules();
    private static void PopulateAllSystemTimeZones(CachedData cachedData);
    private static TimeZoneInfo GetLocalTimeZone(CachedData cachedData);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, TimeZoneInfo& value, Exception& e);
    private static List`1<string> GetTimeZoneIds(string timeZoneDirectory);
    private static bool TryGetLocalTzFile(Byte[]& rawData, String& id);
    private static string GetTzEnvironmentVariable();
    private static bool TryLoadTzFile(string tzFilePath, Byte[]& rawData, String& id);
    private static string FindTimeZoneIdUsingReadLink(string tzFilePath);
    [IteratorStateMachineAttribute("System.TimeZoneInfo/<EnumerateFilesRecursively>d__123")]
private static IEnumerable`1<string> EnumerateFilesRecursively(string path);
    private static string FindTimeZoneId(Byte[] rawData);
    private static bool CompareTimeZoneFile(string filePath, Byte[] buffer, Byte[] rawData);
    private static TimeZoneInfo GetLocalTimeZoneFromTzFile();
    private static TimeZoneInfo GetTimeZoneFromTzData(Byte[] rawData, string id);
    private static string GetTimeZoneDirectory();
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    private static void TZif_GenerateAdjustmentRules(AdjustmentRule[]& rules, TimeSpan baseUtcOffset, DateTime[] dts, Byte[] typeOfLocalTime, TZifType[] transitionType, Boolean[] StandardTime, Boolean[] GmtTime, string futureTransitionsPosixFormat);
    private static void TZif_GenerateAdjustmentRule(Int32& index, TimeSpan timeZoneBaseUtcOffset, List`1<AdjustmentRule> rulesList, DateTime[] dts, Byte[] typeOfLocalTime, TZifType[] transitionTypes, Boolean[] StandardTime, Boolean[] GmtTime, string futureTransitionsPosixFormat);
    private static TimeSpan TZif_CalculateTransitionOffsetFromBase(TimeSpan transitionOffset, TimeSpan timeZoneBaseUtcOffset);
    private static TZifType TZif_GetEarlyDateTransitionType(TZifType[] transitionTypes);
    private static AdjustmentRule TZif_CreateAdjustmentRuleForPosixFormat(string posixFormat, DateTime startTransitionDate, TimeSpan timeZoneBaseUtcOffset);
    private static Nullable`1<TimeSpan> TZif_ParseOffsetString(string offset);
    private static DateTime ParseTimeOfDay(string time);
    private static TransitionTime TZif_CreateTransitionTimeFromPosixRule(string date, string time);
    private static void TZif_ParseJulianDay(string date, Int32& month, Int32& day);
    private static bool TZif_ParseMDateRule(string dateRule, Int32& month, Int32& week, DayOfWeek& dayOfWeek);
    private static bool TZif_ParsePosixFormat(string posixFormat, String& standardName, String& standardOffset, String& daylightSavingsName, String& daylightSavingsOffset, String& start, String& startTime, String& end, String& endTime);
    private static string TZif_ParsePosixName(string posixFormat, Int32& index);
    private static string TZif_ParsePosixOffset(string posixFormat, Int32& index);
    private static void TZif_ParsePosixDateTime(string posixFormat, Int32& index, String& date, String& time);
    private static string TZif_ParsePosixDate(string posixFormat, Int32& index);
    private static string TZif_ParsePosixTime(string posixFormat, Int32& index);
    private static string TZif_ParsePosixString(string posixFormat, Int32& index, Func`2<char, bool> breakCondition);
    private static string TZif_GetZoneAbbreviation(string zoneAbbreviations, int index);
    private static int TZif_ToInt32(Byte[] value, int startIndex);
    private static long TZif_ToInt64(Byte[] value, int startIndex);
    private static long TZif_ToUnixTime(Byte[] value, int startIndex, TZVersion version);
    private static DateTime TZif_UnixTimeToDateTime(long unixTime);
    private static void TZif_ParseRaw(Byte[] data, TZifHead& t, DateTime[]& dts, Byte[]& typeOfLocalTime, TZifType[]& transitionType, String& zoneAbbreviations, Boolean[]& StandardTime, Boolean[]& GmtTime, String& futureTransitionsPosixFormat);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`1 : object {
    private T1 m_Item1;
    public T1 Item1 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
public abstract class System.Type : MemberInfo {
    private static Binder modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultBinder;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static object Missing;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public bool IsInterface { get; }
    public MemberTypes MemberType { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public bool IsNested { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type ReflectedType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool HasElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public TypeAttributes Attributes { get; }
    public bool IsAbstract { get; }
    public bool IsImport { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsClass { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsAutoLayout { get; }
    public bool IsExplicitLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsAnsiClass { get; }
    public bool IsAutoClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsCOMObject { get; }
    public bool IsContextful { get; }
    public bool IsCollectible { get; }
    public bool IsEnum { get; }
    public bool IsMarshalByRef { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsSignatureType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public ConstructorInfo TypeInitializer { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Guid GUID { get; }
    public Type BaseType { get; }
    public static Binder DefaultBinder { get; }
    public bool IsSerializable { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsVisible { get; }
    private static Type();
    public bool get_IsInterface();
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    internal virtual RuntimeTypeHandle GetTypeHandleInternal();
    internal static RuntimeType GetTypeFromHandleUnsafe(IntPtr handle);
    public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    internal string FormatTypeName();
    internal virtual string FormatTypeName(bool serialization);
    public static bool op_Equality(Type left, Type right);
    public static bool op_Inequality(Type left, Type right);
    internal bool IsRuntimeImplemented();
    public virtual MemberTypes get_MemberType();
    public Type GetType();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Module get_Module();
    public bool get_IsNested();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_ReflectedType();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool get_IsTypeDefinition();
    public bool get_IsArray();
    protected abstract virtual bool IsArrayImpl();
    public bool get_IsByRef();
    protected abstract virtual bool IsByRefImpl();
    public bool get_IsPointer();
    protected abstract virtual bool IsPointerImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public virtual bool get_IsByRefLike();
    public bool get_HasElementType();
    protected abstract virtual bool HasElementTypeImpl();
    public abstract virtual Type GetElementType();
    public virtual int GetArrayRank();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type[] GetGenericArguments();
    public virtual int get_GenericParameterPosition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Type[] GetGenericParameterConstraints();
    public TypeAttributes get_Attributes();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public bool get_IsAbstract();
    public bool get_IsImport();
    public bool get_IsSealed();
    public bool get_IsSpecialName();
    public bool get_IsClass();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPublic();
    public bool get_IsAutoLayout();
    public bool get_IsExplicitLayout();
    public bool get_IsLayoutSequential();
    public bool get_IsAnsiClass();
    public bool get_IsAutoClass();
    public bool get_IsUnicodeClass();
    public bool get_IsCOMObject();
    protected abstract virtual bool IsCOMObjectImpl();
    public bool get_IsContextful();
    protected virtual bool IsContextfulImpl();
    public virtual bool get_IsCollectible();
    public virtual bool get_IsEnum();
    public bool get_IsMarshalByRef();
    protected virtual bool IsMarshalByRefImpl();
    public bool get_IsPrimitive();
    protected abstract virtual bool IsPrimitiveImpl();
    public bool get_IsValueType();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSignatureType();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public ConstructorInfo get_TypeInitializer();
    public ConstructorInfo GetConstructor(Type[] types);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name, Type returnType);
    public PropertyInfo GetProperty(string name, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    public static Type[] GetTypeArray(Object[] args);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    public static Type GetTypeFromCLSID(Guid clsid);
    public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server);
    public static Type GetTypeFromProgID(string progID);
    public static Type GetTypeFromProgID(string progID, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server);
    public abstract virtual Type get_BaseType();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsEquivalentTo(Type other);
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public static Type MakeGenericMethodParameter(int position);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool Equals(Type o);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public static Binder get_DefaultBinder();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    private Array GetEnumRawConstantValues();
    private void GetEnumData(String[]& enumNames, Array& enumValues);
    private static int BinarySearch(Array array, object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSerializable();
    public virtual bool get_ContainsGenericParameters();
    internal Type GetRootElementType();
    public bool get_IsVisible();
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual bool IsSubclassOf(Type c);
    public virtual bool IsAssignableFrom(Type c);
    internal bool ImplementInterface(Type ifaceType);
    private static bool FilterAttributeImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameIgnoreCaseImpl(MemberInfo m, object filterCriteria);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[IsByRefLikeAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    private IntPtr Value;
    private IntPtr Type;
    internal bool IsNull { get; }
    [CLSCompliantAttribute("False")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    private static void InternalMakeTypedReference(Void* result, object target, IntPtr[] flds, RuntimeType lastFieldType);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static object ToObject(TypedReference value);
    internal static object InternalToObject(Void* value);
    internal bool get_IsNull();
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    [CLSCompliantAttribute("False")]
public static void SetTypedReference(TypedReference target, object value);
    internal static void InternalSetTypedReference(Void* target, object value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeInitializationException : SystemException {
    private string _typeName;
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(string message);
    internal TypeInitializationException(string fullTypeName, string message, Exception innerException);
    internal TypeInitializationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeLoadException : SystemException {
    private string ClassName;
    private string AssemblyName;
    private string MessageArg;
    internal int ResourceId;
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    private TypeLoadException(string className, string assemblyName, string messageArg, int resourceId);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    public string get_TypeName();
    private static void GetTypeLoadExceptionMessage(int resourceId, StringHandleOnStack retString);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum System.TypeNameFormatFlags : Enum {
    public int value__;
    public static TypeNameFormatFlags FormatBasic;
    public static TypeNameFormatFlags FormatNamespace;
    public static TypeNameFormatFlags FormatFullInst;
    public static TypeNameFormatFlags FormatAssembly;
    public static TypeNameFormatFlags FormatSignature;
    public static TypeNameFormatFlags FormatNoVersion;
    public static TypeNameFormatFlags FormatAngleBrackets;
    public static TypeNameFormatFlags FormatStubInfo;
    public static TypeNameFormatFlags FormatGenericParam;
    public static TypeNameFormatFlags FormatSerialization;
}
internal enum System.TypeNameKind : Enum {
    public int value__;
    public static TypeNameKind Name;
    public static TypeNameKind ToString;
    public static TypeNameKind SerializationName;
    public static TypeNameKind FullName;
}
internal class System.TypeNameParser : object {
    private SafeTypeNameParserHandle m_NativeParser;
    private static Char[] SPECIAL_CHARS;
    private TypeNameParser(SafeTypeNameParserHandle handle);
    private static TypeNameParser();
    private static void _CreateTypeNameParser(string typeName, ObjectHandleOnStack retHandle, bool throwOnError);
    private static void _GetNames(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    private static void _GetTypeArguments(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    private static void _GetModifiers(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    private static void _GetAssemblyName(SafeTypeNameParserHandle pTypeNameParser, StringHandleOnStack retString);
    internal static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    public sealed virtual void Dispose();
    private Type ConstructType(Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static Assembly ResolveAssembly(string asmName, Func`2<AssemblyName, Assembly> assemblyResolver, bool throwOnError, StackCrawlMark& stackMark);
    private static Type ResolveType(Assembly assembly, String[] names, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static string EscapeTypeName(string name);
    private static SafeTypeNameParserHandle CreateTypeNameParser(string typeName, bool throwOnError);
    private String[] GetNames();
    private SafeTypeNameParserHandle[] GetTypeArguments();
    private Int32[] GetModifiers();
    private string GetAssemblyName();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    private ushort m_value;
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt32 : ValueType {
    private UInt32 m_value;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt64 : ValueType {
    private ulong m_value;
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    private Void* _value;
    [IntrinsicAttribute]
public static UIntPtr Zero;
    public static int Size { get; }
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UIntPtr(UInt32 value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UIntPtr(ulong value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UIntPtr(Void* value);
    private UIntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public UInt32 ToUInt32();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public ulong ToUInt64();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static UIntPtr op_Explicit(UInt32 value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static UIntPtr op_Explicit(ulong value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Explicit(Void* value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static ulong op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static UIntPtr Add(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static int get_Size();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public Void* ToPointer();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
public class System.UnhandledExceptionEventArgs : EventArgs {
    private object _exception;
    private bool _isTerminating;
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.UnitySerializationHolder : object {
    private int _unityType;
    private string _data;
    public UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual object GetRealObject(StreamingContext context);
}
internal class System.Utf8String : ValueType {
    private Void* m_pStringHeap;
    private int m_StringHeapByteLength;
    internal Utf8String(Void* pStringHeap);
    internal Utf8String(Void* pUtf8String, int cUtf8String);
    private static bool EqualsCaseSensitive(Void* szLhs, Void* szRhs, int cSz);
    private static bool EqualsCaseInsensitive(Void* szLhs, Void* szRhs, int cSz);
    private static UInt32 HashCaseInsensitive(Void* sz, int cSz);
    private static int GetUtf8StringByteLength(Void* pUtf8String);
    internal bool Equals(Utf8String s);
    internal bool EqualsCaseInsensitive(Utf8String s);
    internal UInt32 HashCaseInsensitive();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`1 : ValueType {
    public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`1(T1 item1);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.ValueType : object {
    public virtual bool Equals(object obj);
    private static bool CanCompareBits(object obj);
    private static bool FastEqualsCheck(object a, object b);
    public virtual int GetHashCode();
    internal static int GetHashCodeOfPtr(IntPtr ptr);
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Version : object {
    private int _Major;
    private int _Minor;
    private int _Build;
    private int _Revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    private int DefaultFormatFieldCount { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    public Version(string version);
    private Version(Version version);
    public sealed virtual object Clone();
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int fieldCount);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private int get_DefaultFormatFieldCount();
    private StringBuilder ToCachedStringBuilder(int fieldCount);
    public static Version Parse(string input);
    public static Version Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Version& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    private static Version ParseVersion(ReadOnlySpan`1<char> input, bool throwOnFailure);
    private static bool TryParseComponent(ReadOnlySpan`1<char> component, string componentName, bool throwOnFailure, Int32& parsedComponent);
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
}
public class System.Void : ValueType {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference : object {
    internal IntPtr m_handle;
    public bool IsAlive { get; }
    public bool TrackResurrection { get; }
    public object Target { get; public set; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual bool get_TrackResurrection();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    protected virtual override void Finalize();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private void Create(object target, bool trackResurrection);
    private bool IsTrackResurrection();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference`1 : object {
    internal IntPtr m_handle;
    private T Target { get; private set; }
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    internal WeakReference`1(SerializationInfo info, StreamingContext context);
    public bool TryGetTarget(T& target);
    public void SetTarget(T target);
    private T get_Target();
    private void set_Target(T value);
    protected virtual override void Finalize();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private void Create(T target, bool trackResurrection);
    private bool IsTrackResurrection();
}
