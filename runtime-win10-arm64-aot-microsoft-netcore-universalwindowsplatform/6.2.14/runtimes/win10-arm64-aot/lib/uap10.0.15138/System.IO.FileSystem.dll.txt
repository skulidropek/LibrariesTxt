internal static class FxResources.System.IO.FileSystem.SR : object {
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[ExtensionAttribute]
internal static class System.FixedBufferExtensions : object {
    [ExtensionAttribute]
internal static string GetStringFromFixedBuffer(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static int GetFixedBufferStringLength(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static bool FixedBufferEqualsString(ReadOnlySpan`1<char> span, string value);
}
internal static class System.HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_HANDLE;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_INVALIDARG;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_OWNER;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TIMEOUT;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
public static class System.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    public static DirectoryInfo CreateDirectory(string path);
    public static bool Exists(string path);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<string> InternalEnumeratePaths(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static string GetDirectoryRoot(string path);
    internal static string InternalGetDirectoryRoot(string path);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static String[] GetLogicalDrives();
}
public class System.IO.DirectoryInfo : FileSystemInfo {
    public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public DirectoryInfo(string path);
    internal DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    private void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
    public DirectoryInfo get_Parent();
    public DirectoryInfo CreateSubdirectory(string path);
    public void Create();
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public DirectoryInfo get_Root();
    public void MoveTo(string destDirName);
    public virtual void Delete();
    public void Delete(bool recursive);
}
internal class System.IO.DisableMediaInsertionPrompt : ValueType {
    private bool _disableSuccess;
    private UInt32 _oldMode;
    public static DisableMediaInsertionPrompt Create();
    public sealed virtual void Dispose();
}
internal static class System.IO.DriveInfoInternal : object {
    public static String[] GetLogicalDrives();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class System.IO.Enumeration.FileSystemEntry : ValueType {
    internal FILE_FULL_DIR_INFORMATION* _info;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <RootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <OriginalRootDirectory>k__BackingField;
    public ReadOnlySpan`1<char> Directory { get; private set; }
    public ReadOnlySpan`1<char> RootDirectory { get; private set; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; private set; }
    public ReadOnlySpan`1<char> FileName { get; }
    public FileAttributes Attributes { get; }
    public long Length { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public bool IsDirectory { get; }
    public bool IsHidden { get; }
    public string ToSpecifiedFullPath();
    internal static void Initialize(FileSystemEntry& entry, FILE_FULL_DIR_INFORMATION* info, ReadOnlySpan`1<char> directory, ReadOnlySpan`1<char> rootDirectory, ReadOnlySpan`1<char> originalRootDirectory);
    [CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(ReadOnlySpan`1<char> value);
    [CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_RootDirectory();
    [CompilerGeneratedAttribute]
private void set_RootDirectory(ReadOnlySpan`1<char> value);
    [CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    [CompilerGeneratedAttribute]
private void set_OriginalRootDirectory(ReadOnlySpan`1<char> value);
    public ReadOnlySpan`1<char> get_FileName();
    public FileAttributes get_Attributes();
    public long get_Length();
    public DateTimeOffset get_CreationTimeUtc();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public bool get_IsDirectory();
    public bool get_IsHidden();
    public FileSystemInfo ToFileSystemInfo();
    public string ToFullPath();
}
public class System.IO.Enumeration.FileSystemEnumerable`1 : object {
    private DelegateEnumerator<TResult> _enumerator;
    private FindTransform<TResult> _transform;
    private EnumerationOptions _options;
    private string _directory;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;
    public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldIncludePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldRecursePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.IO.Enumeration.FileSystemEnumerableFactory : object {
    private static Char[] s_unixEscapeChars;
    private static FileSystemEnumerableFactory();
    internal static void NormalizeInputs(String& directory, String& expression, EnumerationOptions options);
    private static bool MatchesPattern(string expression, ReadOnlySpan`1<char> name, EnumerationOptions options);
    internal static IEnumerable`1<string> UserFiles(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserDirectories(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserEntries(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileInfo> FileInfos(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<DirectoryInfo> DirectoryInfos(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileSystemInfo> FileSystemInfos(string directory, string expression, EnumerationOptions options);
}
public abstract class System.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    private static int StandardBufferSize;
    private static int MinimumBufferSize;
    private string _originalRootDirectory;
    private string _rootDirectory;
    private EnumerationOptions _options;
    private object _lock;
    private FILE_FULL_DIR_INFORMATION* _entry;
    private TResult _current;
    private IntPtr _buffer;
    private int _bufferLength;
    private IntPtr _directoryHandle;
    private string _currentPath;
    private bool _lastEntryFound;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<ValueTuple`2<IntPtr, string>> _pending;
    public TResult Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    protected virtual bool ContinueOnError(int error);
    public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void DirectoryFinished();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void CloseDirectoryHandle();
    private IntPtr CreateDirectoryHandle(string path, bool ignoreNotFound);
    private bool ContinueOnDirectoryError(int error, bool ignoreNotFound);
    public sealed virtual bool MoveNext();
    private void FindNextEntry();
    private bool DequeueNextDirectory();
    private void InternalDispose(bool disposing);
    private bool GetData();
    private IntPtr CreateRelativeDirectoryHandle(ReadOnlySpan`1<char> relativePath, string fullPath);
}
public static class System.IO.Enumeration.FileSystemName : object {
    private static Char[] s_wildcardChars;
    private static Char[] s_simpleWildcardChars;
    private static FileSystemName();
    public static string TranslateWin32Expression(string expression);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    private static bool MatchPattern(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase, bool useExtendedWildcards);
}
public class System.IO.EnumerationOptions : object {
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Compatible>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <CompatibleRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseSubdirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInaccessible>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <AttributesToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchCasing <MatchCasing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnSpecialDirectories>k__BackingField;
    internal static EnumerationOptions Compatible { get; }
    private static EnumerationOptions CompatibleRecursive { get; }
    internal static EnumerationOptions Default { get; }
    public bool RecurseSubdirectories { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public int BufferSize { get; public set; }
    public FileAttributes AttributesToSkip { get; public set; }
    public MatchType MatchType { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    private static EnumerationOptions();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Compatible();
    [CompilerGeneratedAttribute]
private static EnumerationOptions get_CompatibleRecursive();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Default();
    internal static EnumerationOptions FromSearchOption(SearchOption searchOption);
    [CompilerGeneratedAttribute]
public bool get_RecurseSubdirectories();
    [CompilerGeneratedAttribute]
public void set_RecurseSubdirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInaccessible();
    [CompilerGeneratedAttribute]
public void set_IgnoreInaccessible(bool value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public FileAttributes get_AttributesToSkip();
    [CompilerGeneratedAttribute]
public void set_AttributesToSkip(FileAttributes value);
    [CompilerGeneratedAttribute]
public MatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(MatchType value);
    [CompilerGeneratedAttribute]
public MatchCasing get_MatchCasing();
    [CompilerGeneratedAttribute]
public void set_MatchCasing(MatchCasing value);
    [CompilerGeneratedAttribute]
public bool get_ReturnSpecialDirectories();
    [CompilerGeneratedAttribute]
public void set_ReturnSpecialDirectories(bool value);
}
internal static class System.IO.Error : object {
    internal static Exception GetEndOfFile();
}
public static class System.IO.File : object {
    private static int MaxByteArrayLength;
    private static Encoding s_UTF8NoBOM;
    internal static int DefaultBufferSize;
    private static Encoding UTF8NoBOM { get; }
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static void Delete(string path);
    public static bool Exists(string path);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static DateTimeOffset GetUtcDateTimeOffset(DateTime dateTime);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static FileAttributes GetAttributes(string path);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    private static string InternalReadAllText(string path, Encoding encoding);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Byte[] ReadAllBytes(string path);
    private static Byte[] ReadAllBytesUnknownLength(FileStream fs);
    public static void WriteAllBytes(string path, Byte[] bytes);
    private static void InternalWriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    private static String[] InternalReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    private static void InternalWriteAllLines(TextWriter writer, IEnumerable`1<string> contents);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static void Move(string sourceFileName, string destFileName);
    public static void Encrypt(string path);
    public static void Decrypt(string path);
    private static Encoding get_UTF8NoBOM();
    private static StreamReader AsyncStreamReader(string path, Encoding encoding);
    private static StreamWriter AsyncStreamWriter(string path, Encoding encoding, bool append);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllTextAsync>d__67")]
private static Task`1<string> InternalReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesAsync>d__71")]
private static Task`1<Byte[]> InternalReadAllBytesAsync(FileStream fs, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesUnknownLengthAsync>d__72")]
private static Task`1<Byte[]> InternalReadAllBytesUnknownLengthAsync(FileStream fs, CancellationToken cancellationToken);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllBytesAsync>d__74")]
private static Task InternalWriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllLinesAsync>d__77")]
private static Task`1<String[]> InternalReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllLinesAsync>d__80")]
private static Task InternalWriteAllLinesAsync(TextWriter writer, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllTextAsync>d__81")]
private static Task InternalWriteAllTextAsync(StreamWriter sw, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
}
public class System.IO.FileInfo : FileSystemInfo {
    public long Length { get; }
    public string DirectoryName { get; }
    public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public FileInfo(string fileName);
    internal FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    public long get_Length();
    public string get_DirectoryName();
    public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public virtual void Delete();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public FileStream OpenWrite();
    public void MoveTo(string destFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public void Decrypt();
    public void Encrypt();
}
internal static class System.IO.FileSystem : object {
    internal static int GENERIC_READ;
    public static void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    public static void ReplaceFile(string sourceFullPath, string destFullPath, string destBackupFullPath, bool ignoreMetadataErrors);
    public static void CreateDirectory(string fullPath);
    public static void DeleteFile(string fullPath);
    public static bool DirectoryExists(string fullPath);
    private static bool DirectoryExists(string path, Int32& lastError);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
    public static bool FileExists(string fullPath);
    public static FileAttributes GetAttributes(string fullPath);
    public static DateTimeOffset GetCreationTime(string fullPath);
    public static FileSystemInfo GetFileSystemInfo(string fullPath, bool asDirectory);
    public static DateTimeOffset GetLastAccessTime(string fullPath);
    public static DateTimeOffset GetLastWriteTime(string fullPath);
    public static void MoveDirectory(string sourceFullPath, string destFullPath);
    public static void MoveFile(string sourceFullPath, string destFullPath);
    private static SafeFileHandle OpenHandle(string fullPath, bool asDirectory);
    public static void RemoveDirectory(string fullPath, bool recursive);
    private static void GetFindData(string fullPath, WIN32_FIND_DATA& findData);
    private static bool IsNameSurrogateReparsePoint(WIN32_FIND_DATA& data);
    private static void RemoveDirectoryRecursive(string fullPath, WIN32_FIND_DATA& findData, bool topLevel);
    private static void RemoveDirectoryInternal(string fullPath, bool topLevel, bool allowDirectoryNotEmpty);
    public static void SetAttributes(string fullPath, FileAttributes attributes);
    public static void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static String[] GetLogicalDrives();
}
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    protected string FullPath;
    protected string OriginalPath;
    internal string _name;
    private WIN32_FILE_ATTRIBUTE_DATA _data;
    private int _dataInitialized;
    public string FullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public FileAttributes Attributes { get; public set; }
    internal bool ExistsCore { get; }
    internal DateTimeOffset CreationTimeCore { get; internal set; }
    internal DateTimeOffset LastAccessTimeCore { get; internal set; }
    internal DateTimeOffset LastWriteTimeCore { get; internal set; }
    internal long LengthCore { get; }
    internal string NormalizedPath { get; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_FullName();
    public string get_Extension();
    public virtual string get_Name();
    public virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    public virtual string ToString();
    internal static FileSystemInfo Create(string fullPath, FileSystemEntry& findData);
    internal void Invalidate();
    internal void Init(FILE_FULL_DIR_INFORMATION* info);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal bool get_ExistsCore();
    internal DateTimeOffset get_CreationTimeCore();
    internal void set_CreationTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastAccessTimeCore();
    internal void set_LastAccessTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastWriteTimeCore();
    internal void set_LastWriteTimeCore(DateTimeOffset value);
    internal long get_LengthCore();
    private void EnsureDataInitialized();
    public void Refresh();
    internal string get_NormalizedPath();
}
internal abstract class System.IO.Iterator`1 : object {
    private int _threadId;
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public enum System.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing PlatformDefault;
    public static MatchCasing CaseSensitive;
    public static MatchCasing CaseInsensitive;
}
public enum System.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
internal static class System.IO.PathInternal : object {
    private static bool s_isCaseSensitive;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static char PathSeparator;
    internal static string DirectorySeparatorCharAsString;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static string ParentDirectoryPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static PathInternal();
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    private static bool GetIsCaseSensitive();
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefixOverMaxPath(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static bool HasWildCardCharacters(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    private string _path;
    private Encoding _encoding;
    private StreamReader _reader;
    private ReadLinesIterator(string path, Encoding encoding, StreamReader reader);
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
    private static ReadLinesIterator CreateIterator(string path, Encoding encoding, StreamReader reader);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal enum System.IO.SearchTarget : Enum {
    public int value__;
    public static SearchTarget Files;
    public static SearchTarget Directories;
    public static SearchTarget Both;
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static int TryMakeWin32ErrorCodeFromHR(int hr);
    internal static string GetMessage(int errorCode);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Arg_FileIsDirectory_Name { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string Arg_HandleNotSync { get; }
    internal static string Arg_InvalidFileAttrs { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidSearchPattern { get; }
    internal static string Arg_Path2IsRooted { get; }
    internal static string Arg_PathIsVolume { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentNull_FileName { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Argument_EmptyFileName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_FileNotResized { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSubPath { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_BindHandleFailed { get; }
    internal static string IO_CannotCreateDirectory { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_FileStreamHandlePosition { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_FileTooLongOrHandleNotSync { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_SourceDestMustBeDifferent { get; }
    internal static string IO_SourceDestMustHaveSameRoot { get; }
    internal static string IO_SyncOpOnUIThread { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string IndexOutOfRange_IORaceCondition { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string PlatformNotSupported_FileEncryption { get; }
    internal static string IO_PathTooLong_Path { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Arg_FileIsDirectory_Name();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_Arg_HandleNotSync();
    internal static string get_Arg_InvalidFileAttrs();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidSearchPattern();
    internal static string get_Arg_Path2IsRooted();
    internal static string get_Arg_PathIsVolume();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentNull_FileName();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Argument_EmptyFileName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_FileNotResized();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSubPath();
    internal static string get_Argument_PathEmpty();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_BindHandleFailed();
    internal static string get_IO_CannotCreateDirectory();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_FileStreamHandlePosition();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_FileTooLongOrHandleNotSync();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_SourceDestMustBeDifferent();
    internal static string get_IO_SourceDestMustHaveSameRoot();
    internal static string get_IO_SyncOpOnUIThread();
    internal static string get_IO_UnknownFileName();
    internal static string get_IndexOutOfRange_IORaceCondition();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_PlatformNotSupported_FileEncryption();
    internal static string get_IO_PathTooLong_Path();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int requiredAdditionalCapacity);
    public void Dispose();
}
