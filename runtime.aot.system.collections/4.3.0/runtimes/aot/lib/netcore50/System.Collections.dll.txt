internal class __DynamicallyInvokableAttribute : Attribute {
}
internal static class FxResources.System.Collections.SR : object {
}
internal class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string p0);
}
internal static class System.ArrayT`1 : object {
    public static void Copy(T[] sourceArray, int sourceIndex, T[] destinationArray, int destinationIndex, int length);
    public static T[] Resize(T[] src, int newLength, int copyCount);
    public static void Clear(T[] array, int index, int length);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("True")]
[__DynamicallyInvokableAttribute]
public class System.Collections.BitArray : object {
    private static int BitsPerInt32;
    private static int BytesPerInt32;
    private static int BitsPerByte;
    private Int32[] m_array;
    private int m_length;
    private int _version;
    private object _syncRoot;
    private static int _ShrinkThreshold;
    [__DynamicallyInvokableAttribute]
public bool Item { get; public set; }
    [__DynamicallyInvokableAttribute]
public int Length { get; public set; }
    [__DynamicallyInvokableAttribute]
private int System.Collections.ICollection.Count { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
public BitArray(int length);
    [__DynamicallyInvokableAttribute]
public BitArray(int length, bool defaultValue);
    [__DynamicallyInvokableAttribute]
public BitArray(Byte[] bytes);
    [__DynamicallyInvokableAttribute]
public BitArray(Boolean[] values);
    [__DynamicallyInvokableAttribute]
public BitArray(Int32[] values);
    [__DynamicallyInvokableAttribute]
public BitArray(BitArray bits);
    [__DynamicallyInvokableAttribute]
public bool get_Item(int index);
    [__DynamicallyInvokableAttribute]
public void set_Item(int index, bool value);
    [__DynamicallyInvokableAttribute]
public bool Get(int index);
    [__DynamicallyInvokableAttribute]
public void Set(int index, bool value);
    [__DynamicallyInvokableAttribute]
public void SetAll(bool value);
    [__DynamicallyInvokableAttribute]
public BitArray And(BitArray value);
    [__DynamicallyInvokableAttribute]
public BitArray Or(BitArray value);
    [__DynamicallyInvokableAttribute]
public BitArray Xor(BitArray value);
    [__DynamicallyInvokableAttribute]
public BitArray Not();
    [__DynamicallyInvokableAttribute]
public int get_Length();
    [__DynamicallyInvokableAttribute]
public void set_Length(int value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [__DynamicallyInvokableAttribute]
private sealed virtual override int System.Collections.ICollection.get_Count();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
public sealed virtual IEnumerator GetEnumerator();
    private static int GetArrayLength(int n, int div);
}
internal class System.Collections.Generic.BitHelper : object {
    private static byte MarkedBitFlag;
    private static byte IntSize;
    private int m_length;
    [SecurityCriticalAttribute]
private Int32* m_arrayPtr;
    private Int32[] m_array;
    private bool useStackAlloc;
    [SecurityCriticalAttribute]
internal BitHelper(Int32* bitArrayPtr, int length);
    internal BitHelper(Int32[] bitArray, int length);
    [SecuritySafeCriticalAttribute]
internal void MarkBit(int bitPosition);
    [SecuritySafeCriticalAttribute]
internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[__DynamicallyInvokableAttribute]
public abstract class System.Collections.Generic.Comparer`1 : object {
    private static Comparer`1<T> _default;
    [__DynamicallyInvokableAttribute]
public static Comparer`1<T> Default { get; }
    [__DynamicallyInvokableAttribute]
public static Comparer`1<T> get_Default();
    [__DynamicallyInvokableAttribute]
public abstract virtual int Compare(T x, T y);
    [__DynamicallyInvokableAttribute]
public static Comparer`1<T> Create(Comparison`1<T> comparison);
    [__DynamicallyInvokableAttribute]
private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private static Comparer`1<T> CreateComparer();
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
internal class System.Collections.Generic.DefaultComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] buckets;
    private Entry[] entries;
    private int count;
    private int version;
    private int freeList;
    private int freeCount;
    private IEqualityComparer`1<TKey> comparer;
    private KeyCollection<TKey, TValue> keys;
    private ValueCollection<TKey, TValue> values;
    private object _syncRoot;
    private static string VersionName;
    private static string HashSizeName;
    private static string KeyValuePairsName;
    private static string ComparerName;
    [__DynamicallyInvokableAttribute]
public IEqualityComparer`1<TKey> Comparer { get; }
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
public KeyCollection<TKey, TValue> Keys { get; }
    [__DynamicallyInvokableAttribute]
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    [__DynamicallyInvokableAttribute]
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [__DynamicallyInvokableAttribute]
public ValueCollection<TKey, TValue> Values { get; }
    [__DynamicallyInvokableAttribute]
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    [__DynamicallyInvokableAttribute]
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    [__DynamicallyInvokableAttribute]
public TValue Item { get; public set; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IDictionary.IsFixedSize { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IDictionary.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private ICollection System.Collections.IDictionary.Keys { get; }
    [__DynamicallyInvokableAttribute]
private ICollection System.Collections.IDictionary.Values { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.IDictionary.Item { get; private set; }
    [__DynamicallyInvokableAttribute]
public Dictionary`2(int capacity);
    [__DynamicallyInvokableAttribute]
public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    [__DynamicallyInvokableAttribute]
public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
public IEqualityComparer`1<TKey> get_Comparer();
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
public KeyCollection<TKey, TValue> get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    [__DynamicallyInvokableAttribute]
public ValueCollection<TKey, TValue> get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    [__DynamicallyInvokableAttribute]
public sealed virtual TValue get_Item(TKey key);
    [__DynamicallyInvokableAttribute]
public sealed virtual void set_Item(TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Add(TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Clear();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool ContainsKey(TKey key);
    [__DynamicallyInvokableAttribute]
public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [__DynamicallyInvokableAttribute]
public Enumerator<TKey, TValue> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private int FindEntry(TKey key);
    private void Initialize(int capacity);
    private void Insert(TKey key, TValue value, bool add);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(TKey key);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool TryGetValue(TKey key, TValue& value);
    internal TValue GetValueOrDefault(TKey key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
[__DynamicallyInvokableAttribute]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    private static EqualityComparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) _default;
    [__DynamicallyInvokableAttribute]
public static EqualityComparer`1<T> Default { get; }
    [__DynamicallyInvokableAttribute]
public static EqualityComparer`1<T> get_Default();
    [__DynamicallyInvokableAttribute]
public abstract virtual bool Equals(T x, T y);
    [__DynamicallyInvokableAttribute]
public abstract virtual int GetHashCode(T obj);
    [__DynamicallyInvokableAttribute]
private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.EqualityComparerForByte : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte x);
}
internal class System.Collections.Generic.EqualityComparerForDecimal : EqualityComparer`1<decimal> {
    public virtual bool Equals(decimal x, decimal y);
    public virtual int GetHashCode(decimal x);
}
internal class System.Collections.Generic.EqualityComparerForDouble : EqualityComparer`1<double> {
    public virtual bool Equals(double x, double y);
    public virtual int GetHashCode(double x);
}
internal class System.Collections.Generic.EqualityComparerForInt16 : EqualityComparer`1<short> {
    public virtual bool Equals(short x, short y);
    public virtual int GetHashCode(short x);
}
internal class System.Collections.Generic.EqualityComparerForInt32 : EqualityComparer`1<int> {
    public virtual bool Equals(int x, int y);
    public virtual int GetHashCode(int x);
}
internal class System.Collections.Generic.EqualityComparerForInt64 : EqualityComparer`1<long> {
    public virtual bool Equals(long x, long y);
    public virtual int GetHashCode(long x);
}
internal class System.Collections.Generic.EqualityComparerForIntPtr : EqualityComparer`1<IntPtr> {
    public virtual bool Equals(IntPtr x, IntPtr y);
    public virtual int GetHashCode(IntPtr x);
}
internal class System.Collections.Generic.EqualityComparerForSByte : EqualityComparer`1<sbyte> {
    public virtual bool Equals(sbyte x, sbyte y);
    public virtual int GetHashCode(sbyte x);
}
internal class System.Collections.Generic.EqualityComparerForSingle : EqualityComparer`1<float> {
    public virtual bool Equals(float x, float y);
    public virtual int GetHashCode(float x);
}
internal class System.Collections.Generic.EqualityComparerForString : EqualityComparer`1<string> {
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string x);
}
internal class System.Collections.Generic.EqualityComparerForUInt16 : EqualityComparer`1<ushort> {
    public virtual bool Equals(ushort x, ushort y);
    public virtual int GetHashCode(ushort x);
}
internal class System.Collections.Generic.EqualityComparerForUInt32 : EqualityComparer`1<UInt32> {
    public virtual bool Equals(UInt32 x, UInt32 y);
    public virtual int GetHashCode(UInt32 x);
}
internal class System.Collections.Generic.EqualityComparerForUInt64 : EqualityComparer`1<ulong> {
    public virtual bool Equals(ulong x, ulong y);
    public virtual int GetHashCode(ulong x);
}
internal class System.Collections.Generic.EqualityComparerForUIntPtr : EqualityComparer`1<UIntPtr> {
    public virtual bool Equals(UIntPtr x, UIntPtr y);
    public virtual int GetHashCode(UIntPtr x);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.HashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.HashSet`1 : object {
    private static int Lower31BitMask;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    private Int32[] m_buckets;
    private Slot[] m_slots;
    private int m_count;
    private int m_lastIndex;
    private int m_freeList;
    private IEqualityComparer`1<T> m_comparer;
    private int m_version;
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
public IEqualityComparer`1<T> Comparer { get; }
    [__DynamicallyInvokableAttribute]
public HashSet`1(IEqualityComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
public HashSet`1(IEnumerable`1<T> collection);
    [__DynamicallyInvokableAttribute]
public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Clear();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Contains(T item);
    [__DynamicallyInvokableAttribute]
public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(T item);
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
public Enumerator<T> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Add(T item);
    [__DynamicallyInvokableAttribute]
public sealed virtual void UnionWith(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array);
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array, int arrayIndex, int count);
    [__DynamicallyInvokableAttribute]
public int RemoveWhere(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public IEqualityComparer`1<T> get_Comparer();
    [__DynamicallyInvokableAttribute]
public void TrimExcess();
    private void Initialize(int capacity);
    private void IncreaseCapacity();
    private void SetCapacity(int newSize, bool forceNewHashCodes);
    private bool AddIfNotPresent(T value);
    private bool ContainsAllElements(IEnumerable`1<T> other);
    private bool IsSubsetOfHashSetWithSameEC(HashSet`1<T> other);
    private void IntersectWithHashSetWithSameEC(HashSet`1<T> other);
    [SecuritySafeCriticalAttribute]
private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private int InternalIndexOf(T item);
    private void SymmetricExceptWithUniqueHashSet(HashSet`1<T> other);
    [SecuritySafeCriticalAttribute]
private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    private bool AddOrGetLocation(T value, Int32& location);
    [SecuritySafeCriticalAttribute]
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal T[] ToArray();
    internal static bool HashSetEquals(HashSet`1<T> set1, HashSet`1<T> set2, IEqualityComparer`1<T> comparer);
    private static bool AreEqualityComparersEqual(HashSet`1<T> set1, HashSet`1<T> set2);
    private int InternalGetHashCode(T item);
}
internal class System.Collections.Generic.HashSetDebugView`1 : object {
    private HashSet`1<T> _set;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public HashSetDebugView`1(HashSet`1<T> set);
    public T[] get_Items();
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class System.Collections.Generic.Int32Comparer : Comparer`1<int> {
    public virtual int Compare(int x, int y);
}
internal class System.Collections.Generic.LastResortEqualityComparer`1 : EqualityComparer`1<T> {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.LinkedList`1 : object {
    internal LinkedListNode`1<T> head;
    internal int count;
    internal int version;
    private object _syncRoot;
    private static string VersionName;
    private static string CountName;
    private static string ValuesName;
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> First { get; }
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> Last { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public LinkedList`1(IEnumerable`1<T> collection);
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> get_First();
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> get_Last();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> AddAfter(LinkedListNode`1<T> node, T value);
    [__DynamicallyInvokableAttribute]
public void AddAfter(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> AddBefore(LinkedListNode`1<T> node, T value);
    [__DynamicallyInvokableAttribute]
public void AddBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> AddFirst(T value);
    [__DynamicallyInvokableAttribute]
public void AddFirst(LinkedListNode`1<T> node);
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> AddLast(T value);
    [__DynamicallyInvokableAttribute]
public void AddLast(LinkedListNode`1<T> node);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Clear();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Contains(T value);
    [__DynamicallyInvokableAttribute]
public sealed virtual void CopyTo(T[] array, int index);
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> Find(T value);
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> FindLast(T value);
    [__DynamicallyInvokableAttribute]
public Enumerator<T> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(T value);
    [__DynamicallyInvokableAttribute]
public void Remove(LinkedListNode`1<T> node);
    [__DynamicallyInvokableAttribute]
public void RemoveFirst();
    [__DynamicallyInvokableAttribute]
public void RemoveLast();
    private void InternalInsertNodeBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
    private void InternalInsertNodeToEmptyList(LinkedListNode`1<T> newNode);
    internal void InternalRemoveNode(LinkedListNode`1<T> node);
    internal void ValidateNewNode(LinkedListNode`1<T> node);
    internal void ValidateNode(LinkedListNode`1<T> node);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ComVisibleAttribute("False")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.LinkedListNode`1 : object {
    internal LinkedList`1<T> list;
    internal LinkedListNode`1<T> next;
    internal LinkedListNode`1<T> prev;
    internal T item;
    [__DynamicallyInvokableAttribute]
public LinkedList`1<T> List { get; }
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> Next { get; }
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> Previous { get; }
    [__DynamicallyInvokableAttribute]
public T Value { get; public set; }
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1(T value);
    internal LinkedListNode`1(LinkedList`1<T> list, T value);
    [__DynamicallyInvokableAttribute]
public LinkedList`1<T> get_List();
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> get_Next();
    [__DynamicallyInvokableAttribute]
public LinkedListNode`1<T> get_Previous();
    [__DynamicallyInvokableAttribute]
public T get_Value();
    [__DynamicallyInvokableAttribute]
public void set_Value(T value);
    internal void Invalidate();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.List`1 : object {
    private static int _defaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static T[] _emptyArray;
    [__DynamicallyInvokableAttribute]
public int Capacity { get; public set; }
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IList.IsFixedSize { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IList.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public T Item { get; public set; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.IList.Item { get; private set; }
    [__DynamicallyInvokableAttribute]
public List`1(int capacity);
    [__DynamicallyInvokableAttribute]
public List`1(IEnumerable`1<T> collection);
    private static List`1();
    [__DynamicallyInvokableAttribute]
public int get_Capacity();
    [__DynamicallyInvokableAttribute]
public void set_Capacity(int value);
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
public sealed virtual T get_Item(int index);
    [__DynamicallyInvokableAttribute]
public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Add(T item);
    [__DynamicallyInvokableAttribute]
private sealed virtual override int System.Collections.IList.Add(object item);
    [__DynamicallyInvokableAttribute]
public void AddRange(IEnumerable`1<T> collection);
    [__DynamicallyInvokableAttribute]
public ReadOnlyCollection`1<T> AsReadOnly();
    [__DynamicallyInvokableAttribute]
public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
public int BinarySearch(T item);
    [__DynamicallyInvokableAttribute]
public int BinarySearch(T item, IComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Clear();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Contains(T item);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    [__DynamicallyInvokableAttribute]
public void CopyTo(int index, T[] array, int arrayIndex, int count);
    [__DynamicallyInvokableAttribute]
public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    [__DynamicallyInvokableAttribute]
public bool Exists(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public T Find(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public List`1<T> FindAll(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public int FindIndex(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public int FindIndex(int startIndex, Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public T FindLast(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public int FindLastIndex(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public int FindLastIndex(int startIndex, Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public void ForEach(Action`1<T> action);
    [__DynamicallyInvokableAttribute]
public Enumerator<T> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [__DynamicallyInvokableAttribute]
public List`1<T> GetRange(int index, int count);
    [__DynamicallyInvokableAttribute]
public sealed virtual int IndexOf(T item);
    [__DynamicallyInvokableAttribute]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    [__DynamicallyInvokableAttribute]
public int IndexOf(T item, int index);
    [__DynamicallyInvokableAttribute]
public int IndexOf(T item, int index, int count);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Insert(int index, T item);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    [__DynamicallyInvokableAttribute]
public void InsertRange(int index, IEnumerable`1<T> collection);
    [__DynamicallyInvokableAttribute]
public int LastIndexOf(T item);
    [__DynamicallyInvokableAttribute]
public int LastIndexOf(T item, int index);
    [__DynamicallyInvokableAttribute]
public int LastIndexOf(T item, int index, int count);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(T item);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IList.Remove(object item);
    [__DynamicallyInvokableAttribute]
public int RemoveAll(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public sealed virtual void RemoveAt(int index);
    [__DynamicallyInvokableAttribute]
public void RemoveRange(int index, int count);
    [__DynamicallyInvokableAttribute]
public void Reverse();
    [__DynamicallyInvokableAttribute]
public void Reverse(int index, int count);
    [__DynamicallyInvokableAttribute]
public void Sort();
    [__DynamicallyInvokableAttribute]
public void Sort(IComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
public void Sort(int index, int count, IComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
public void Sort(Comparison`1<T> comparison);
    [__DynamicallyInvokableAttribute]
public T[] ToArray();
    [__DynamicallyInvokableAttribute]
public void TrimExcess();
    [__DynamicallyInvokableAttribute]
public bool TrueForAll(Predicate`1<T> match);
    internal static IList`1<T> Synchronized(List`1<T> list);
}
internal class System.Collections.Generic.LowLevelComparer`1 : object {
    private static IComparer`1<T> _default;
    internal static IComparer`1<T> Default { get; }
    internal static IComparer`1<T> get_Default();
    public sealed virtual int Compare(T x, T y);
    internal static int DefaultCompareImpl(T x, T y);
    private static IComparer`1<T> CreateComparer();
}
internal class System.Collections.Generic.LowLevelInt32Comparer : object {
    public sealed virtual int Compare(int x, int y);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.QueueDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.Queue`1 : object {
    private T[] _array;
    private int _head;
    private int _tail;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int _MinimumGrow;
    private static int _ShrinkThreshold;
    private static int _GrowFactor;
    private static int _DefaultCapacity;
    private static T[] _emptyArray;
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public Queue`1(int capacity);
    [__DynamicallyInvokableAttribute]
public Queue`1(IEnumerable`1<T> collection);
    private static Queue`1();
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
public void Clear();
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array, int arrayIndex);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [__DynamicallyInvokableAttribute]
public void Enqueue(T item);
    [__DynamicallyInvokableAttribute]
public Enumerator<T> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [__DynamicallyInvokableAttribute]
public T Dequeue();
    [__DynamicallyInvokableAttribute]
public T Peek();
    [__DynamicallyInvokableAttribute]
public bool Contains(T item);
    internal T GetElement(int i);
    [__DynamicallyInvokableAttribute]
public T[] ToArray();
    private void SetCapacity(int capacity);
    [__DynamicallyInvokableAttribute]
public void TrimExcess();
}
internal class System.Collections.Generic.QueueDebugView`1 : object {
    private Queue`1<T> _queue;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public QueueDebugView`1(Queue`1<T> queue);
    public T[] get_Items();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.SortedDictionary`2 : object {
    private KeyCollection<TKey, TValue> keys;
    private ValueCollection<TKey, TValue> values;
    private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set;
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
public TValue Item { get; public set; }
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
public IComparer`1<TKey> Comparer { get; }
    [__DynamicallyInvokableAttribute]
public KeyCollection<TKey, TValue> Keys { get; }
    [__DynamicallyInvokableAttribute]
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    [__DynamicallyInvokableAttribute]
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [__DynamicallyInvokableAttribute]
public ValueCollection<TKey, TValue> Values { get; }
    [__DynamicallyInvokableAttribute]
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    [__DynamicallyInvokableAttribute]
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IDictionary.IsFixedSize { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IDictionary.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private ICollection System.Collections.IDictionary.Keys { get; }
    [__DynamicallyInvokableAttribute]
private ICollection System.Collections.IDictionary.Values { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.IDictionary.Item { get; private set; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    [__DynamicallyInvokableAttribute]
public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
public SortedDictionary`2(IComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
public sealed virtual TValue get_Item(TKey key);
    [__DynamicallyInvokableAttribute]
public sealed virtual void set_Item(TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
public IComparer`1<TKey> get_Comparer();
    [__DynamicallyInvokableAttribute]
public KeyCollection<TKey, TValue> get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    [__DynamicallyInvokableAttribute]
public ValueCollection<TKey, TValue> get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    [__DynamicallyInvokableAttribute]
public sealed virtual void Add(TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
public sealed virtual void Clear();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool ContainsKey(TKey key);
    [__DynamicallyInvokableAttribute]
public bool ContainsValue(TValue value);
    [__DynamicallyInvokableAttribute]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [__DynamicallyInvokableAttribute]
public Enumerator<TKey, TValue> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(TKey key);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool TryGetValue(TKey key, TValue& value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private static bool IsCompatibleKey(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.SortedList`2 : object {
    private TKey[] keys;
    private TValue[] values;
    private int _size;
    private int version;
    private IComparer`1<TKey> comparer;
    private KeyList<TKey, TValue> keyList;
    private ValueList<TKey, TValue> valueList;
    private object _syncRoot;
    private static TKey[] emptyKeys;
    private static TValue[] emptyValues;
    private static int _defaultCapacity;
    private static int MaxArrayLength;
    [__DynamicallyInvokableAttribute]
public int Capacity { get; public set; }
    [__DynamicallyInvokableAttribute]
public IComparer`1<TKey> Comparer { get; }
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
public IList`1<TKey> Keys { get; }
    [__DynamicallyInvokableAttribute]
private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    [__DynamicallyInvokableAttribute]
private ICollection System.Collections.IDictionary.Keys { get; }
    [__DynamicallyInvokableAttribute]
private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [__DynamicallyInvokableAttribute]
public IList`1<TValue> Values { get; }
    [__DynamicallyInvokableAttribute]
private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    [__DynamicallyInvokableAttribute]
private ICollection System.Collections.IDictionary.Values { get; }
    [__DynamicallyInvokableAttribute]
private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IDictionary.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.IDictionary.IsFixedSize { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public TValue Item { get; public set; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.IDictionary.Item { get; private set; }
    [__DynamicallyInvokableAttribute]
public SortedList`2(int capacity);
    [__DynamicallyInvokableAttribute]
public SortedList`2(IComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
public SortedList`2(int capacity, IComparer`1<TKey> comparer);
    [__DynamicallyInvokableAttribute]
public SortedList`2(IDictionary`2<TKey, TValue> dictionary);
    [__DynamicallyInvokableAttribute]
public SortedList`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    private static SortedList`2();
    [__DynamicallyInvokableAttribute]
public sealed virtual void Add(TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    [__DynamicallyInvokableAttribute]
public int get_Capacity();
    [__DynamicallyInvokableAttribute]
public void set_Capacity(int value);
    [__DynamicallyInvokableAttribute]
public IComparer`1<TKey> get_Comparer();
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
public IList`1<TKey> get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    [__DynamicallyInvokableAttribute]
public IList`1<TValue> get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private KeyList<TKey, TValue> GetKeyListHelper();
    private ValueList<TKey, TValue> GetValueListHelper();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
public sealed virtual void Clear();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool ContainsKey(TKey key);
    [__DynamicallyInvokableAttribute]
public bool ContainsValue(TValue value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private void EnsureCapacity(int min);
    private TValue GetByIndex(int index);
    [__DynamicallyInvokableAttribute]
public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private TKey GetKey(int index);
    [__DynamicallyInvokableAttribute]
public sealed virtual TValue get_Item(TKey key);
    [__DynamicallyInvokableAttribute]
public sealed virtual void set_Item(TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    [__DynamicallyInvokableAttribute]
public int IndexOfKey(TKey key);
    [__DynamicallyInvokableAttribute]
public int IndexOfValue(TValue value);
    private void Insert(int index, TKey key, TValue value);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool TryGetValue(TKey key, TValue& value);
    [__DynamicallyInvokableAttribute]
public void RemoveAt(int index);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(TKey key);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    [__DynamicallyInvokableAttribute]
public void TrimExcess();
    private static bool IsCompatibleKey(object key);
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.SortedSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.SortedSet`1 : object {
    private Node<T> root;
    private IComparer`1<T> comparer;
    private int count;
    private int version;
    private object _syncRoot;
    private static string ComparerName;
    private static string CountName;
    private static string ItemsName;
    private static string VersionName;
    private static string TreeName;
    private static string NodeValueName;
    private static string EnumStartName;
    private static string ReverseName;
    private static string EnumVersionName;
    internal static int StackAllocThreshold;
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
public IComparer`1<T> Comparer { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public T Min { get; }
    [__DynamicallyInvokableAttribute]
public T Max { get; }
    [__DynamicallyInvokableAttribute]
public SortedSet`1(IComparer`1<T> comparer);
    [__DynamicallyInvokableAttribute]
public SortedSet`1(IEnumerable`1<T> collection);
    [__DynamicallyInvokableAttribute]
public SortedSet`1(IEnumerable`1<T> collection, IComparer`1<T> comparer);
    private void AddAllElements(IEnumerable`1<T> collection);
    private void RemoveAllElements(IEnumerable`1<T> collection);
    private bool ContainsAllElements(IEnumerable`1<T> collection);
    internal bool InOrderTreeWalk(TreeWalkPredicate`1<T> action);
    internal virtual bool InOrderTreeWalk(TreeWalkPredicate`1<T> action, bool reverse);
    internal virtual bool BreadthFirstTreeWalk(TreeWalkPredicate`1<T> action);
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
public IComparer`1<T> get_Comparer();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal virtual void VersionCheck();
    internal virtual bool IsWithinRange(T item);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Add(T item);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    internal virtual bool AddIfNotPresent(T item);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Remove(T item);
    internal virtual bool DoRemove(T item);
    [__DynamicallyInvokableAttribute]
public virtual void Clear();
    [__DynamicallyInvokableAttribute]
public virtual bool Contains(T item);
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array);
    [__DynamicallyInvokableAttribute]
public sealed virtual void CopyTo(T[] array, int index);
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array, int index, int count);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [__DynamicallyInvokableAttribute]
public Enumerator<T> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static Node<T> GetSibling(Node<T> node, Node<T> parent);
    private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent);
    private static bool Is2Node(Node<T> node);
    private static bool Is4Node(Node<T> node);
    private static bool IsBlack(Node<T> node);
    private static bool IsNullOrBlack(Node<T> node);
    private static bool IsRed(Node<T> node);
    private static void Merge2Nodes(Node<T> parent, Node<T> child1, Node<T> child2);
    private void ReplaceChildOfNodeOrRoot(Node<T> parent, Node<T> child, Node<T> newChild);
    private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> succesor, Node<T> parentOfSuccesor);
    internal virtual Node<T> FindNode(T item);
    internal virtual int InternalIndexOf(T item);
    internal Node<T> FindRange(T from, T to);
    internal Node<T> FindRange(T from, T to, bool lowerBoundActive, bool upperBoundActive);
    internal void UpdateVersion();
    private static Node<T> RotateLeft(Node<T> node);
    private static Node<T> RotateLeftRight(Node<T> node);
    private static Node<T> RotateRight(Node<T> node);
    private static Node<T> RotateRightLeft(Node<T> node);
    private static TreeRotation RotationNeeded(Node<T> parent, Node<T> current, Node<T> sibling);
    internal static bool SortedSetEquals(SortedSet`1<T> set1, SortedSet`1<T> set2, IComparer`1<T> comparer);
    private static bool AreComparersEqual(SortedSet`1<T> set1, SortedSet`1<T> set2);
    private static void Split4Node(Node<T> node);
    internal T[] ToArray();
    [__DynamicallyInvokableAttribute]
public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private static Node<T> ConstructRootFromSortedArray(T[] arr, int startIndex, int endIndex, Node<T> redNode);
    [__DynamicallyInvokableAttribute]
public virtual void IntersectWith(IEnumerable`1<T> other);
    internal virtual void IntersectWithEnumerable(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    internal void SymmetricExceptWithSameEC(ISet`1<T> other);
    internal void SymmetricExceptWithSameEC(T[] other);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    private bool IsSubsetOfSortedSetWithSameEC(SortedSet`1<T> asSorted);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    [SecuritySafeCriticalAttribute]
[__DynamicallyInvokableAttribute]
public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    [__DynamicallyInvokableAttribute]
public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    [SecurityCriticalAttribute]
private ElementCount<T> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    [__DynamicallyInvokableAttribute]
public int RemoveWhere(Predicate`1<T> match);
    [__DynamicallyInvokableAttribute]
public T get_Min();
    [__DynamicallyInvokableAttribute]
public T get_Max();
    [IteratorStateMachineAttribute("System.Collections.Generic.SortedSet`1/<Reverse>d__1")]
[__DynamicallyInvokableAttribute]
public IEnumerable`1<T> Reverse();
    [__DynamicallyInvokableAttribute]
public virtual SortedSet`1<T> GetViewBetween(T lowerValue, T upperValue);
    private static int log2(int value);
}
internal class System.Collections.Generic.SortedSetDebugView`1 : object {
    private SortedSet`1<T> _sortedSet;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SortedSetDebugView`1(SortedSet`1<T> sortedSet);
    public T[] get_Items();
}
internal class System.Collections.Generic.SortedSetEqualityComparer`1 : object {
    private IComparer`1<T> comparer;
    private IEqualityComparer`1<T> e_comparer;
    public SortedSetEqualityComparer`1(IComparer`1<T> comparer);
    public SortedSetEqualityComparer`1(IEqualityComparer`1<T> memberEqualityComparer);
    public SortedSetEqualityComparer`1(IComparer`1<T> comparer, IEqualityComparer`1<T> memberEqualityComparer);
    public sealed virtual bool Equals(SortedSet`1<T> x, SortedSet`1<T> y);
    public sealed virtual int GetHashCode(SortedSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerTypeProxyAttribute("System.Collections.Generic.StackDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[__DynamicallyInvokableAttribute]
public class System.Collections.Generic.Stack`1 : object {
    private T[] _array;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int _defaultCapacity;
    private static T[] _emptyArray;
    [__DynamicallyInvokableAttribute]
public int Count { get; }
    [__DynamicallyInvokableAttribute]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [__DynamicallyInvokableAttribute]
private object System.Collections.ICollection.SyncRoot { get; }
    [__DynamicallyInvokableAttribute]
public Stack`1(int capacity);
    [__DynamicallyInvokableAttribute]
public Stack`1(IEnumerable`1<T> collection);
    private static Stack`1();
    [__DynamicallyInvokableAttribute]
public sealed virtual int get_Count();
    [__DynamicallyInvokableAttribute]
private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    [__DynamicallyInvokableAttribute]
private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [__DynamicallyInvokableAttribute]
public void Clear();
    [__DynamicallyInvokableAttribute]
public bool Contains(T item);
    [__DynamicallyInvokableAttribute]
public void CopyTo(T[] array, int arrayIndex);
    [__DynamicallyInvokableAttribute]
private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    [__DynamicallyInvokableAttribute]
public Enumerator<T> GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [__DynamicallyInvokableAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [__DynamicallyInvokableAttribute]
public void TrimExcess();
    [__DynamicallyInvokableAttribute]
public T Peek();
    [__DynamicallyInvokableAttribute]
public T Pop();
    [__DynamicallyInvokableAttribute]
public void Push(T item);
    [__DynamicallyInvokableAttribute]
public T[] ToArray();
}
internal class System.Collections.Generic.StackDebugView`1 : object {
    private Stack`1<T> _stack;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public StackDebugView`1(Stack`1<T> stack);
    public T[] get_Items();
}
internal enum System.Collections.Generic.TreeRotation : Enum {
    public int value__;
    public static TreeRotation LeftRotation;
    public static TreeRotation RightRotation;
    public static TreeRotation RightLeftRotation;
    public static TreeRotation LeftRightRotation;
}
internal class System.Collections.Generic.TreeSet`1 : SortedSet`1<T> {
    public TreeSet`1(IComparer`1<T> comparer);
    public TreeSet`1(ICollection`1<T> collection);
    public TreeSet`1(ICollection`1<T> collection, IComparer`1<T> comparer);
    internal virtual bool AddIfNotPresent(T item);
}
internal class System.Collections.Generic.TreeWalkPredicate`1 : MulticastDelegate {
    public TreeWalkPredicate`1(object object, IntPtr method);
    public virtual bool Invoke(Node<T> node);
    public virtual IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class System.Collections.HashHelpers : object {
    private static int HashPrime;
    public static Int32[] primes;
    public static int MaxPrimeArrayLength;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int GetMinPrime();
    public static int ExpandPrime(int oldSize);
}
internal class System.Collections.LowLevelComparer : object {
    internal static LowLevelComparer Default;
    private static LowLevelComparer();
    public sealed virtual int Compare(object a, object b);
}
internal class System.Collections.StructuralComparer : object {
    public sealed virtual int Compare(object x, object y);
}
[__DynamicallyInvokableAttribute]
public static class System.Collections.StructuralComparisons : object {
    private static IComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralComparer;
    private static IEqualityComparer modreq(System.Runtime.CompilerServices.IsVolatile) s_StructuralEqualityComparer;
    [__DynamicallyInvokableAttribute]
public static IComparer StructuralComparer { get; }
    [__DynamicallyInvokableAttribute]
public static IEqualityComparer StructuralEqualityComparer { get; }
    [__DynamicallyInvokableAttribute]
public static IComparer get_StructuralComparer();
    [__DynamicallyInvokableAttribute]
public static IEqualityComparer get_StructuralEqualityComparer();
}
internal class System.Collections.StructuralEqualityComparer : object {
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
internal static class System.CommonRuntimeTypes : object {
    private static Type _object;
    private static Type _valuetype;
    private static Type _attribute;
    private static Type _string;
    private static Type _array;
    private static Type _enum;
    private static Type _boolean;
    private static Type _char;
    private static Type _byte;
    private static Type _sByte;
    private static Type _uInt16;
    private static Type _int16;
    private static Type _uInt32;
    private static Type _int32;
    private static Type _uInt64;
    private static Type _int64;
    private static Type _uIntPtr;
    private static Type _intPtr;
    private static Type _single;
    private static Type _double;
    private static Type _decimal;
    private static Type _datetime;
    private static Type _nullable;
    private static Type _void;
    internal static Type Object { get; }
    internal static Type ValueType { get; }
    internal static Type Attribute { get; }
    internal static Type String { get; }
    internal static Type Array { get; }
    internal static Type Enum { get; }
    internal static Type Boolean { get; }
    internal static Type Char { get; }
    internal static Type Byte { get; }
    internal static Type SByte { get; }
    internal static Type UInt16 { get; }
    internal static Type Int16 { get; }
    internal static Type UInt32 { get; }
    internal static Type Int32 { get; }
    internal static Type UInt64 { get; }
    internal static Type Int64 { get; }
    internal static Type UIntPtr { get; }
    internal static Type IntPtr { get; }
    internal static Type Single { get; }
    internal static Type Double { get; }
    internal static Type Decimal { get; }
    internal static Type DateTime { get; }
    internal static Type Nullable { get; }
    internal static Type Void { get; }
    private static CommonRuntimeTypes();
    internal static Type get_Object();
    internal static Type get_ValueType();
    internal static Type get_Attribute();
    internal static Type get_String();
    internal static Type get_Array();
    internal static Type get_Enum();
    internal static Type get_Boolean();
    internal static Type get_Char();
    internal static Type get_Byte();
    internal static Type get_SByte();
    internal static Type get_UInt16();
    internal static Type get_Int16();
    internal static Type get_UInt32();
    internal static Type get_Int32();
    internal static Type get_UInt64();
    internal static Type get_Int64();
    internal static Type get_UIntPtr();
    internal static Type get_IntPtr();
    internal static Type get_Single();
    internal static Type get_Double();
    internal static Type get_Decimal();
    internal static Type get_DateTime();
    internal static Type get_Nullable();
    internal static Type get_Void();
}
internal class System.Runtime.CompilerServices.__BlockReflectionActivateAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionInvokeAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNumRequired { get; }
    internal static string Arg_MultiRank { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_WrongType { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Invalid_Array_Type { get; }
    internal static string InvalidOperation_EmptyQueue { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EmptyStack { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_BitArrayTypeUnsupported { get; }
    internal static string Arg_HSCapacityOverflow { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_InsufficientSpace { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_ArrayTooLarge { get; }
    internal static string Argument_InvalidArgumentForComparison { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ExternalLinkedListNode { get; }
    internal static string IndexOutOfRange { get; }
    internal static string LinkedListEmpty { get; }
    internal static string LinkedListNodeIsAttached { get; }
    internal static string NotSupported_SortedListNestedWrite { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_ArgumentOutOfRange_NeedNonNegNumRequired();
    internal static string get_Arg_MultiRank();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_WrongType();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Invalid_Array_Type();
    internal static string get_InvalidOperation_EmptyQueue();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EmptyStack();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_BitArrayTypeUnsupported();
    internal static string get_Arg_HSCapacityOverflow();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_InsufficientSpace();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_ArrayTooLarge();
    internal static string get_Argument_InvalidArgumentForComparison();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ExternalLinkedListNode();
    internal static string get_IndexOutOfRange();
    internal static string get_LinkedListEmpty();
    internal static string get_LinkedListNodeIsAttached();
    internal static string get_NotSupported_SortedListNestedWrite();
    internal static Type get_ResourceType();
}
