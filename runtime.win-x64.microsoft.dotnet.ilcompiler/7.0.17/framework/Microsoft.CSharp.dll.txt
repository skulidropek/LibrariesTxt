internal static class FxResources.Microsoft.CSharp.SR : object {
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.ArgumentObject : ValueType {
    internal object Value;
    internal CSharpArgumentInfo Info;
    internal Type Type;
    public ArgumentObject(object value, CSharpArgumentInfo info, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.CSharp.RuntimeBinder.Binder : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder BinaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder Convert(CSharpBinderFlags flags, Type type, Type context);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder GetIndex(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder GetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder Invoke(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder InvokeMember(CSharpBinderFlags flags, string name, IEnumerable`1<Type> typeArguments, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder InvokeConstructor(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder IsEvent(CSharpBinderFlags flags, string name, Type context);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder SetIndex(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder SetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static CallSiteBinder UnaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.BinderEquivalence : object {
    private static int cachedBinderCount;
    private static ConcurrentDictionary`2<ICSharpBinder, ICSharpBinder> binderEquivalenceCache;
    private static BinderEquivalence();
    [ExtensionAttribute]
internal static T TryGetExisting(T binder);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.BinderHelper : object {
    private static MethodInfo s_DoubleIsNaN;
    private static MethodInfo s_SingleIsNaN;
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static DynamicMetaObject Bind(ICSharpBinder action, RuntimeBinder binder, DynamicMetaObject[] args, IEnumerable`1<CSharpArgumentInfo> arginfos, DynamicMetaObject onBindingError);
    public static void ValidateBindArgument(DynamicMetaObject argument, string paramName);
    public static void ValidateBindArgument(DynamicMetaObject[] arguments, string paramName);
    private static bool IsTypeOfStaticCall(int parameterIndex, ICSharpInvokeOrInvokeMemberBinder callPayload);
    private static bool IsComObject(object obj);
    private static bool IsDynamicallyTypedRuntimeProxy(DynamicMetaObject argument, CSharpArgumentInfo info);
    private static BindingRestrictions DeduceArgumentRestriction(int parameterIndex, ICSharpInvokeOrInvokeMemberBinder callPayload, DynamicMetaObject argument, CSharpArgumentInfo info);
    private static Expression ConvertResult(Expression binding, ICSharpBinder action);
    private static Type GetTypeForErrorMetaObject(ICSharpBinder action, DynamicMetaObject[] args);
    private static bool IsIncrementOrDecrementActionOnLocal(ICSharpBinder action);
    internal static T[] Cons(T sourceHead, T[] sourceTail);
    internal static T[] Cons(T sourceHead, T[] sourceMiddle, T sourceLast);
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static CallInfo CreateCallInfo(IEnumerable`1& argInfos, int discard);
    [ExtensionAttribute]
internal static string GetCLROperatorName(ExpressionType p);
    internal static int AddArgHashes(int hash, Type[] typeArguments, CSharpArgumentInfo[] argInfos);
    internal static int AddArgHashes(int hash, CSharpArgumentInfo[] argInfos);
    internal static bool CompareArgInfos(Type[] typeArgs, Type[] otherTypeArgs, CSharpArgumentInfo[] argInfos, CSharpArgumentInfo[] otherArgInfos);
    internal static bool CompareArgInfos(CSharpArgumentInfo[] argInfos, CSharpArgumentInfo[] otherArgInfos);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.ComInterop.ArgBuilder : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal abstract virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.BoolArgBuilder : SimpleArgBuilder {
    internal BoolArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.BoundDispEvent : DynamicObject {
    private object _rcw;
    private Guid _sourceIid;
    private int _dispid;
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal BoundDispEvent(object rcw, Guid sourceIid, int dispid);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object handler, Object& result);
    private static void VerifyHandler(object handler);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private object InPlaceAdd(object handler);
    private object InPlaceSubtract(object handler);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.CollectionExtensions : object {
    [ExtensionAttribute]
internal static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
internal static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
internal static T[] ToArray(IList`1<T> list);
    [ExtensionAttribute]
internal static T[] AddLast(IList`1<T> list, T item);
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.ComBinder : object {
    public static bool IsComObject(object value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool TryBindGetMember(GetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject& result, bool delayInvocation);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool TryBindSetMember(SetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject value, DynamicMetaObject& result);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool TryBindInvoke(InvokeBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool TryBindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool TryBindGetIndex(GetIndexBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool TryBindSetIndex(SetIndexBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject value, DynamicMetaObject& result);
    public static bool TryConvert(ConvertBinder binder, DynamicMetaObject instance, DynamicMetaObject& result);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static IList`1<string> GetDynamicDataMemberNames(object value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static IList`1<KeyValuePair`2<string, object>> GetDynamicDataMembers(object value, IEnumerable`1<string> names);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool TryGetMetaObject(DynamicMetaObject& instance);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool TryGetMetaObjectInvoke(DynamicMetaObject& instance);
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.ComBinderHelpers : object {
    internal static bool PreferPut(Type type, bool holdsNull);
    internal static bool IsByRef(DynamicMetaObject mo);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static bool IsStrongBoxArg(DynamicMetaObject o);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static Boolean[] ProcessArgumentsForCom(DynamicMetaObject[]& args);
    internal static BindingRestrictions GetTypeRestrictionForDynamicMetaObject(DynamicMetaObject obj);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComClassMetaObject : DynamicMetaObject {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ComClassMetaObject(Expression expression, ComTypeClassDesc cls);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComEventDesc : object {
    public Guid SourceIID;
    public int Dispid;
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComEventSinksContainer : List`1<ComEventsSink> {
    private static object s_comObjectEventSinksKey;
    private static ComEventSinksContainer();
    public static ComEventSinksContainer FromRuntimeCallableWrapper(object rcw, bool createIfNotFound);
    public sealed virtual void Dispose();
    private void DisposeAll();
    protected virtual override void Finalize();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComFallbackMetaObject : DynamicMetaObject {
    internal ComFallbackMetaObject(Expression expression, BindingRestrictions restrictions, object arg);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    protected virtual ComUnwrappedMetaObject UnwrapSelf();
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.ComHresults : object {
    internal static bool IsSuccess(int hresult);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComInvokeAction : InvokeBinder {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ComInvokeAction(CallInfo callInfo);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComInvokeBinder : object {
    private ComMethodDesc _methodDesc;
    private Expression _method;
    private Expression _dispatch;
    private CallInfo _callInfo;
    private DynamicMetaObject[] _args;
    private Boolean[] _isByRef;
    private Expression _instance;
    private BindingRestrictions _restrictions;
    private VarEnumSelector _varEnumSelector;
    private String[] _keywordArgNames;
    private int _totalExplicitArgs;
    private ParameterExpression _dispatchObject;
    private ParameterExpression _dispatchPointer;
    private ParameterExpression _dispId;
    private ParameterExpression _dispParams;
    private ParameterExpression _paramVariants;
    private ParameterExpression _invokeResult;
    private ParameterExpression _returnValue;
    private ParameterExpression _dispIdsOfKeywordArgsPinned;
    private ParameterExpression _propertyPutDispId;
    private ParameterExpression DispatchObjectVariable { get; }
    private ParameterExpression DispatchPointerVariable { get; }
    private ParameterExpression DispIdVariable { get; }
    private ParameterExpression DispParamsVariable { get; }
    private ParameterExpression InvokeResultVariable { get; }
    private ParameterExpression ReturnValueVariable { get; }
    private ParameterExpression DispIdsOfKeywordArgsPinnedVariable { get; }
    private ParameterExpression PropertyPutDispIdVariable { get; }
    private ParameterExpression ParamVariantsVariable { get; }
    internal ComInvokeBinder(CallInfo callInfo, DynamicMetaObject[] args, Boolean[] isByRef, BindingRestrictions restrictions, Expression method, Expression dispatch, ComMethodDesc methodDesc);
    private ParameterExpression get_DispatchObjectVariable();
    private ParameterExpression get_DispatchPointerVariable();
    private ParameterExpression get_DispIdVariable();
    private ParameterExpression get_DispParamsVariable();
    private ParameterExpression get_InvokeResultVariable();
    private ParameterExpression get_ReturnValueVariable();
    private ParameterExpression get_DispIdsOfKeywordArgsPinnedVariable();
    private ParameterExpression get_PropertyPutDispIdVariable();
    private ParameterExpression get_ParamVariantsVariable();
    private static ParameterExpression EnsureVariable(ParameterExpression& var, Type type, string name);
    private static Type MarshalType(DynamicMetaObject mo, bool isByRef);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal DynamicMetaObject Invoke();
    private static void AddNotNull(List`1<ParameterExpression> list, ParameterExpression var);
    private Expression CreateScope(Expression expression);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateTryBlock();
    private Expression GenerateFinallyBlock();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression MakeIDispatchInvokeTarget();
    private Expression[] MakeArgumentExpressions();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComMetaObject : DynamicMetaObject {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ComMetaObject(Expression expression, BindingRestrictions restrictions, object arg);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private DynamicMetaObject WrapSelf();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComMethodDesc : object {
    private INVOKEKIND _invokeKind;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DispId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParamCount>k__BackingField;
    public string Name { get; }
    public int DispId { get; }
    public bool IsPropertyGet { get; }
    public bool IsDataMember { get; }
    public bool IsPropertyPut { get; }
    public bool IsPropertyPutRef { get; }
    internal int ParamCount { get; }
    private ComMethodDesc(int dispId);
    internal ComMethodDesc(string name, int dispId);
    internal ComMethodDesc(string name, int dispId, INVOKEKIND invkind);
    internal ComMethodDesc(ITypeInfo typeInfo, FUNCDESC funcDesc);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_DispId();
    public bool get_IsPropertyGet();
    public bool get_IsDataMember();
    public bool get_IsPropertyPut();
    public bool get_IsPropertyPutRef();
    [CompilerGeneratedAttribute]
internal int get_ParamCount();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComObject : object {
    [CompilerGeneratedAttribute]
private object <RuntimeCallableWrapper>k__BackingField;
    private static object s_comObjectInfoKey;
    internal object RuntimeCallableWrapper { get; }
    internal ComObject(object rcw);
    private static ComObject();
    [CompilerGeneratedAttribute]
internal object get_RuntimeCallableWrapper();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ComObject ObjectToComObject(object rcw);
    internal static MemberExpression RcwFromComObject(Expression comObject);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static MethodCallExpression RcwToComObject(Expression rcw);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ComObject CreateComObject(object rcw);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual IList`1<string> GetMemberNames(bool dataOnly);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual IList`1<KeyValuePair`2<string, object>> GetMembers(IEnumerable`1<string> names);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.ComRuntimeHelpers : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static void CheckThrowException(int hresult, ExcepInfo& excepInfo, UInt32 argErr, string message);
    internal static void GetInfoFromType(ITypeInfo typeInfo, String& name, String& documentation);
    internal static string GetNameOfMethod(ITypeInfo typeInfo, int memid);
    internal static string GetNameOfLib(ITypeLib typeLib);
    internal static string GetNameOfType(ITypeInfo typeInfo);
    internal static ITypeInfo GetITypeInfoFromIDispatch(IDispatch dispatch);
    internal static TYPEATTR GetTypeAttrForTypeInfo(ITypeInfo typeInfo);
    internal static TYPELIBATTR GetTypeAttrForTypeLib(ITypeLib typeLib);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static BoundDispEvent CreateComEvent(object rcw, Guid sourceIid, int dispid);
    public static DispCallable CreateDispCallable(IDispatchComObject dispatch, ComMethodDesc method);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComTypeClassDesc : ComTypeDesc {
    private LinkedList`1<string> _itfs;
    private LinkedList`1<string> _sourceItfs;
    private Type _typeObj;
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ComTypeClassDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public object CreateInstance();
    private void AddInterface(ITypeInfo itfTypeInfo, bool isSourceItf);
    internal bool Implements(string itfName, bool isSourceItf);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComTypeDesc : object {
    private string _typeName;
    private string _documentation;
    private ComMethodDesc _getItem;
    private ComMethodDesc _setItem;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, ComEventDesc> <EmptyEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Funcs>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Puts>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <PutRefs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ComEventDesc> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private ComTypeLibDesc <TypeLib>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    internal static Dictionary`2<string, ComEventDesc> EmptyEvents { get; }
    internal Hashtable Funcs { get; internal set; }
    internal Hashtable Puts { get; internal set; }
    internal Hashtable PutRefs { get; internal set; }
    internal Dictionary`2<string, ComEventDesc> Events { get; internal set; }
    public string TypeName { get; }
    public ComTypeLibDesc TypeLib { get; }
    internal Guid Guid { get; internal set; }
    internal ComMethodDesc GetItem { get; }
    internal ComMethodDesc SetItem { get; }
    internal ComTypeDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    private static ComTypeDesc();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static ComTypeDesc FromITypeInfo(ITypeInfo typeInfo, TYPEATTR typeAttr);
    internal static ComTypeDesc CreateEmptyTypeDesc();
    [CompilerGeneratedAttribute]
internal static Dictionary`2<string, ComEventDesc> get_EmptyEvents();
    [CompilerGeneratedAttribute]
internal Hashtable get_Funcs();
    [CompilerGeneratedAttribute]
internal void set_Funcs(Hashtable value);
    [CompilerGeneratedAttribute]
internal Hashtable get_Puts();
    [CompilerGeneratedAttribute]
internal void set_Puts(Hashtable value);
    [CompilerGeneratedAttribute]
internal Hashtable get_PutRefs();
    [CompilerGeneratedAttribute]
internal void set_PutRefs(Hashtable value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ComEventDesc> get_Events();
    [CompilerGeneratedAttribute]
internal void set_Events(Dictionary`2<string, ComEventDesc> value);
    internal bool TryGetFunc(string name, ComMethodDesc& method);
    internal void AddFunc(string name, ComMethodDesc method);
    internal bool TryGetPut(string name, ComMethodDesc& method);
    internal void AddPut(string name, ComMethodDesc method);
    internal bool TryGetPutRef(string name, ComMethodDesc& method);
    internal void AddPutRef(string name, ComMethodDesc method);
    internal bool TryGetEvent(string name, ComEventDesc& event);
    internal String[] GetMemberNames(bool dataOnly);
    public string get_TypeName();
    [CompilerGeneratedAttribute]
public ComTypeLibDesc get_TypeLib();
    [CompilerGeneratedAttribute]
internal Guid get_Guid();
    [CompilerGeneratedAttribute]
internal void set_Guid(Guid value);
    internal ComMethodDesc get_GetItem();
    internal void EnsureGetItem(ComMethodDesc candidate);
    internal ComMethodDesc get_SetItem();
    internal void EnsureSetItem(ComMethodDesc candidate);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComTypeEnumDesc : ComTypeDesc {
    private String[] _memberNames;
    private Object[] _memberValues;
    internal ComTypeEnumDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    public virtual string ToString();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    public object GetValue(string enumValueName);
    internal bool HasMember(string name);
    public String[] GetMemberNames();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComTypeLibDesc : object {
    private LinkedList`1<ComTypeClassDesc> _classes;
    private Dictionary`2<string, ComTypeEnumDesc> _enums;
    private TYPELIBATTR _typeLibAttributes;
    private static Dictionary`2<Guid, ComTypeLibDesc> s_cachedTypeLibDesc;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Guid Guid { get; }
    public string Name { get; private set; }
    private static ComTypeLibDesc();
    public virtual string ToString();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static ComTypeLibDesc GetFromTypeLib(ITypeLib typeLib);
    public object GetTypeLibObjectDesc(string member);
    public String[] GetMemberNames();
    internal bool HasMember(string member);
    public Guid get_Guid();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    internal ComTypeClassDesc GetCoClassForInterface(string itfName);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ComUnwrappedMetaObject : DynamicMetaObject {
    internal ComUnwrappedMetaObject(Expression expression, BindingRestrictions restrictions, object value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ConversionArgBuilder : ArgBuilder {
    private SimpleArgBuilder _innerBuilder;
    private Type _parameterType;
    internal ConversionArgBuilder(Type parameterType, SimpleArgBuilder innerBuilder);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ConvertArgBuilder : SimpleArgBuilder {
    private Type _marshalType;
    internal ConvertArgBuilder(Type parameterType, Type marshalType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ConvertibleArgBuilder : ArgBuilder {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.CurrencyArgBuilder : SimpleArgBuilder {
    internal CurrencyArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.DateTimeArgBuilder : SimpleArgBuilder {
    internal DateTimeArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.DispatchArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal DispatchArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.DispCallable : object {
    [CompilerGeneratedAttribute]
private IDispatchComObject <DispatchComObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DispId>k__BackingField;
    public IDispatchComObject DispatchComObject { get; }
    public IDispatch DispatchObject { get; }
    public string MemberName { get; }
    public int DispId { get; }
    internal DispCallable(IDispatchComObject dispatch, string memberName, int dispId);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public IDispatchComObject get_DispatchComObject();
    public IDispatch get_DispatchObject();
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public int get_DispId();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.DispCallableMetaObject : DynamicMetaObject {
    private DispCallable _callable;
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal DispCallableMetaObject(Expression expression, DispCallable callable);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private DynamicMetaObject BindGetOrInvoke(DynamicMetaObject[] args, CallInfo callInfo);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private DynamicMetaObject BindComInvoke(ComMethodDesc method, DynamicMetaObject[] indexes, CallInfo callInfo, Boolean[] isByRef);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private BindingRestrictions DispCallableRestrictions();
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.Error : object {
    internal static Exception SetComObjectDataFailed();
    internal static Exception UnexpectedVarEnum(object p0);
    internal static Exception DispBadParamCount(object p0);
    internal static Exception DispMemberNotFound(object p0);
    internal static Exception DispNoNamedArgs(object p0);
    internal static Exception DispOverflow(object p0);
    internal static Exception DispTypeMismatch(object p0, object p1);
    internal static Exception DispParamNotOptional(object p0);
    internal static Exception CannotRetrieveTypeInformation();
    internal static Exception GetIDsOfNamesInvalid(object p0);
    internal static Exception UnsupportedHandlerType();
    internal static Exception CouldNotGetDispId(object p0, object p1);
    internal static Exception AmbiguousConversion(object p0, object p1);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ErrorArgBuilder : SimpleArgBuilder {
    internal ErrorArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.ExcepInfo : ValueType {
    private short wCode;
    private short wReserved;
    private IntPtr bstrSource;
    private IntPtr bstrDescription;
    private IntPtr bstrHelpFile;
    private int dwHelpContext;
    private IntPtr pvReserved;
    private IntPtr pfnDeferredFillIn;
    private int scode;
    private static string ConvertAndFreeBstr(IntPtr& bstr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Exception GetException();
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.Helpers : object {
    internal static Expression Convert(Expression expression, Type type);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
internal interface Microsoft.CSharp.RuntimeBinder.ComInterop.IDispatch {
    public abstract virtual int TryGetTypeInfoCount(UInt32& pctinfo);
    public abstract virtual int TryGetTypeInfo(UInt32 iTInfo, int lcid, IntPtr& info);
    public abstract virtual int TryGetIDsOfNames(Guid& iid, String[] names, UInt32 cNames, int lcid, Int32[] rgDispId);
    public abstract virtual int TryInvoke(int dispIdMember, Guid& riid, int lcid, INVOKEKIND wFlags, DISPPARAMS& pDispParams, IntPtr VarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.IDispatchComObject : ComObject {
    private ComTypeDesc _comTypeDesc;
    private static Dictionary`2<Guid, ComTypeDesc> s_cacheComTypeDesc;
    [CompilerGeneratedAttribute]
private IDispatch <DispatchObject>k__BackingField;
    public ComTypeDesc ComTypeDesc { get; }
    public IDispatch DispatchObject { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal IDispatchComObject(IDispatch rcw);
    private static IDispatchComObject();
    public virtual string ToString();
    public ComTypeDesc get_ComTypeDesc();
    [CompilerGeneratedAttribute]
public IDispatch get_DispatchObject();
    private static int GetIDsOfNames(IDispatch dispatch, string name, Int32& dispId);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal bool TryGetGetItem(ComMethodDesc& value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool SlowTryGetGetItem(ComMethodDesc& value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal bool TryGetSetItem(ComMethodDesc& value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool SlowTryGetSetItem(ComMethodDesc& value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal bool TryGetMemberMethod(string name, ComMethodDesc& method);
    internal bool TryGetMemberEvent(string name, ComEventDesc& event);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal bool TryGetMemberMethodExplicit(string name, ComMethodDesc& method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal bool TryGetPropertySetterExplicit(string name, ComMethodDesc& method, Type limitType, bool holdsNull);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual IList`1<string> GetMemberNames(bool dataOnly);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual IList`1<KeyValuePair`2<string, object>> GetMembers(IEnumerable`1<string> names);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex, FUNCDESC& funcDesc, IntPtr& funcDescHandle);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private void EnsureScanDefinedEvents();
    private static void ScanSourceInterface(ITypeInfo sourceTypeInfo, Dictionary`2& events);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ITypeInfo GetCoClassTypeInfo(object rcw, ITypeInfo typeInfo);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private void EnsureScanDefinedMethods();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal bool TryGetPropertySetter(string name, ComMethodDesc& method, Type limitType, bool holdsNull);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.IDispatchMetaObject : ComFallbackMetaObject {
    private IDispatchComObject _self;
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal IDispatchMetaObject(Expression expression, IDispatchComObject self);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private DynamicMetaObject BindComInvoke(DynamicMetaObject[] args, ComMethodDesc method, CallInfo callInfo, Boolean[] isByRef);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private DynamicMetaObject BindGetMember(ComMethodDesc method, bool canReturnCallables);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private DynamicMetaObject BindEvent(ComEventDesc eventDesc);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private DynamicMetaObject TryPropertyPut(SetMemberBinder binder, DynamicMetaObject value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private DynamicMetaObject TryEventHandlerNoop(SetMemberBinder binder, DynamicMetaObject value);
    private BindingRestrictions IDispatchRestriction();
    internal static BindingRestrictions IDispatchRestriction(Expression expr, ComTypeDesc typeDesc);
    protected virtual ComUnwrappedMetaObject UnwrapSelf();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B283-BAB4-101A-B69C-00AA00341D07")]
internal interface Microsoft.CSharp.RuntimeBinder.ComInterop.IProvideClassInfo {
    public abstract virtual void GetClassInfo(IntPtr& info);
}
internal interface Microsoft.CSharp.RuntimeBinder.ComInterop.IPseudoComObject {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public abstract virtual DynamicMetaObject GetMetaObject(Expression expression);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.NullArgBuilder : ArgBuilder {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.SimpleArgBuilder : ArgBuilder {
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    protected Type ParameterType { get; }
    internal SimpleArgBuilder(Type parameterType);
    [CompilerGeneratedAttribute]
protected Type get_ParameterType();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.SplatCallSite : object {
    internal object _callable;
    private CallSite`1<Func`4<CallSite, object, Object[], object>> _site;
    internal SplatCallSite(object callable);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal object Invoke(Object[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.SplatInvokeBinder : CallSiteBinder {
    private static SplatInvokeBinder s_instance;
    internal static SplatInvokeBinder Instance { get; }
    private static SplatInvokeBinder();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static SplatInvokeBinder get_Instance();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.StringArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal StringArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.TypeEnumMetaObject : DynamicMetaObject {
    private ComTypeEnumDesc _desc;
    internal TypeEnumMetaObject(ComTypeEnumDesc desc, Expression expression);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    private BindingRestrictions EnumRestrictions();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.TypeLibMetaObject : DynamicMetaObject {
    private ComTypeLibDesc _lib;
    internal TypeLibMetaObject(Expression expression, ComTypeLibDesc lib);
    private DynamicMetaObject TryBindGetMember(string name);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.TypeUtils : object {
    internal static Type GetNonNullableType(Type type);
    [ExtensionAttribute]
internal static bool IsNullableType(Type type);
    internal static bool AreReferenceAssignable(Type dest, Type src);
    internal static bool AreAssignable(Type dest, Type src);
    internal static bool IsImplicitlyConvertible(Type source, Type destination);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static bool IsImplicitlyConvertible(Type source, Type destination, bool considerUserDefined);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType, bool implicitOnly);
    internal static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo, bool implicitOnly);
    private static bool IsIdentityConversion(Type source, Type destination);
    private static bool IsImplicitNumericConversion(Type source, Type destination);
    private static bool IsImplicitReferenceConversion(Type source, Type destination);
    private static bool IsImplicitBoxingConversion(Type source, Type destination);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.UnknownArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal UnknownArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.UnsafeMethods : object {
    private static object s_lock;
    private static ModuleBuilder s_dynamicModule;
    internal static ModuleBuilder DynamicModule { get; }
    private static UnsafeMethods();
    public static IntPtr ConvertInt32ByrefToPtr(Int32& value);
    public static IntPtr ConvertVariantByrefToPtr(Variant& value);
    internal static Variant GetVariantForObject(object obj);
    internal static void InitVariantForObject(object obj, Variant& variant);
    public static object GetObjectForVariant(Variant variant);
    public static int IUnknownRelease(IntPtr interfacePointer);
    public static void IUnknownReleaseNotZero(IntPtr interfacePointer);
    public static int IDispatchInvoke(IntPtr dispatchPointer, int memberDispId, INVOKEKIND flags, DISPPARAMS& dispParams, Variant& result, ExcepInfo& excepInfo, UInt32& argErr);
    public static IntPtr GetIdsOfNamedParameters(IDispatch dispatch, String[] names, int methodDispId, GCHandle& pinningHandle);
    internal static ModuleBuilder get_DynamicModule();
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VarEnumSelector : object {
    private static Dictionary`2<VarEnum, Type> s_comToManagedPrimitiveTypes;
    private static IList`1<IList`1<VarEnum>> s_comPrimitiveTypeFamilies;
    [CompilerGeneratedAttribute]
private VariantBuilder[] <VariantBuilders>k__BackingField;
    internal VariantBuilder[] VariantBuilders { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal VarEnumSelector(Type[] explicitArgTypes);
    private static VarEnumSelector();
    [CompilerGeneratedAttribute]
internal VariantBuilder[] get_VariantBuilders();
    internal static Type GetManagedMarshalType(VarEnum varEnum);
    private static Dictionary`2<VarEnum, Type> CreateComToManagedPrimitiveTypes();
    private static IList`1<IList`1<VarEnum>> CreateComPrimitiveTypeFamilies();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static List`1<VarEnum> GetConversionsToComPrimitiveTypeFamilies(Type argumentType);
    private static void CheckForAmbiguousMatch(Type argumentType, List`1<VarEnum> compatibleComTypes);
    private static bool TryGetPrimitiveComType(Type argumentType, VarEnum& primitiveVarEnum);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool TryGetPrimitiveComTypeViaConversion(Type argumentType, VarEnum& primitiveVarEnum);
    private VarEnum GetComType(Type& argumentType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private VariantBuilder GetVariantBuilder(Type argumentType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ArgBuilder GetByValArgBuilder(Type elementType, VarEnum& elementVarEnum);
    private static SimpleArgBuilder GetSimpleArgBuilder(Type elementType, VarEnum elementVarEnum);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal VariantArgBuilder(Type parameterType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression Marshal(Expression parameter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal static class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray : object {
    private static List`1<Type> s_generatedTypes;
    private static VariantArray();
    [DynamicDependencyAttribute("32", "Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray1")]
[DynamicDependencyAttribute("32", "Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray2")]
[DynamicDependencyAttribute("32", "Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray4")]
[DynamicDependencyAttribute("32", "Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray8")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal static MemberExpression GetStructField(ParameterExpression variantArray, int field);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:UnrecognizedReflectionPattern")]
internal static Type GetStructType(int args);
    private static Type CreateCustomType(int size);
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray1 : ValueType {
    public Variant Element0;
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray2 : ValueType {
    public Variant Element0;
    public Variant Element1;
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray4 : ValueType {
    public Variant Element0;
    public Variant Element1;
    public Variant Element2;
    public Variant Element3;
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantArray8 : ValueType {
    public Variant Element0;
    public Variant Element1;
    public Variant Element2;
    public Variant Element3;
    public Variant Element4;
    public Variant Element5;
    public Variant Element6;
    public Variant Element7;
}
internal class Microsoft.CSharp.RuntimeBinder.ComInterop.VariantBuilder : object {
    private MemberExpression _variant;
    private ArgBuilder _argBuilder;
    private VarEnum _targetComType;
    [CompilerGeneratedAttribute]
private ParameterExpression <TempVariable>k__BackingField;
    internal ParameterExpression TempVariable { get; private set; }
    internal bool IsByRef { get; }
    internal VariantBuilder(VarEnum targetComType, ArgBuilder builder);
    [CompilerGeneratedAttribute]
internal ParameterExpression get_TempVariable();
    [CompilerGeneratedAttribute]
private void set_TempVariable(ParameterExpression value);
    internal bool get_IsByRef();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expression InitializeArgumentVariant(MemberExpression variant, Expression parameter);
    private static Expression Release(Expression pUnk);
    internal Expression Clear();
    internal Expression UpdateFromReturn(Expression parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo : object {
    internal static CSharpArgumentInfo None;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfoFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal CSharpArgumentInfoFlags Flags { get; }
    internal string Name { get; }
    internal bool UseCompileTimeType { get; }
    internal bool LiteralConstant { get; }
    internal bool NamedArgument { get; }
    internal bool IsByRefOrOut { get; }
    internal bool IsOut { get; }
    internal bool IsStaticType { get; }
    private CSharpArgumentInfo(CSharpArgumentInfoFlags flags, string name);
    private static CSharpArgumentInfo();
    [CompilerGeneratedAttribute]
internal CSharpArgumentInfoFlags get_Flags();
    [CompilerGeneratedAttribute]
internal string get_Name();
    public static CSharpArgumentInfo Create(CSharpArgumentInfoFlags flags, string name);
    internal bool get_UseCompileTimeType();
    internal bool get_LiteralConstant();
    internal bool get_NamedArgument();
    internal bool get_IsByRefOrOut();
    internal bool get_IsOut();
    internal bool get_IsStaticType();
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
public enum Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags : Enum {
    public int value__;
    public static CSharpArgumentInfoFlags None;
    public static CSharpArgumentInfoFlags UseCompileTimeType;
    public static CSharpArgumentInfoFlags Constant;
    public static CSharpArgumentInfoFlags NamedArgument;
    public static CSharpArgumentInfoFlags IsRef;
    public static CSharpArgumentInfoFlags IsOut;
    public static CSharpArgumentInfoFlags IsStaticType;
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpBinaryOperationBinder : BinaryOperationBinder {
    private CSharpBinaryOperationFlags _binopFlags;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    [ExcludeFromCodeCoverageAttribute]
public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    internal bool IsLogicalOperation { get; }
    private bool IsChecked { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpBinaryOperationBinder(ExpressionType operation, bool isChecked, CSharpBinaryOperationFlags binaryOperationFlags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    internal bool get_IsLogicalOperation();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private bool get_IsChecked();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.CSharpBinaryOperationFlags : Enum {
    public int value__;
    public static CSharpBinaryOperationFlags None;
    public static CSharpBinaryOperationFlags MemberAccess;
    public static CSharpBinaryOperationFlags LogicalOperation;
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
public enum Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags : Enum {
    public int value__;
    public static CSharpBinderFlags None;
    public static CSharpBinderFlags CheckedContext;
    public static CSharpBinderFlags InvokeSimpleName;
    public static CSharpBinderFlags InvokeSpecialName;
    public static CSharpBinderFlags BinaryOperationLogical;
    public static CSharpBinderFlags ConvertExplicit;
    public static CSharpBinderFlags ConvertArrayIndex;
    public static CSharpBinderFlags ResultIndexed;
    public static CSharpBinderFlags ValueFromCompoundAssignment;
    public static CSharpBinderFlags ResultDiscarded;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.CSharpCallFlags : Enum {
    public int value__;
    public static CSharpCallFlags None;
    public static CSharpCallFlags SimpleNameCall;
    public static CSharpCallFlags EventHookup;
    public static CSharpCallFlags ResultDiscarded;
}
internal enum Microsoft.CSharp.RuntimeBinder.CSharpConversionKind : Enum {
    public int value__;
    public static CSharpConversionKind ImplicitConversion;
    public static CSharpConversionKind ExplicitConversion;
    public static CSharpConversionKind ArrayCreationConversion;
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder : ConvertBinder {
    [CompilerGeneratedAttribute]
private CSharpConversionKind <ConversionKind>k__BackingField;
    private RuntimeBinder _binder;
    private Type _callingContext;
    [ExcludeFromCodeCoverageAttribute]
public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private CSharpConversionKind ConversionKind { get; }
    private bool IsChecked { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpConvertBinder(Type type, CSharpConversionKind conversionKind, bool isChecked, Type callingContext);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    [CompilerGeneratedAttribute]
private CSharpConversionKind get_ConversionKind();
    private bool get_IsChecked();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpGetIndexBinder : GetIndexBinder {
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpGetIndexBinder(Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpGetMemberBinder : GetMemberBinder {
    private CSharpArgumentInfo[] _argumentInfo;
    [CompilerGeneratedAttribute]
private bool <ResultIndexed>k__BackingField;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool System.Dynamic.IInvokeOnGetBinder.InvokeOnGet { get; }
    private bool ResultIndexed { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpGetMemberBinder(string name, bool resultIndexed, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private sealed virtual override bool System.Dynamic.IInvokeOnGetBinder.get_InvokeOnGet();
    [CompilerGeneratedAttribute]
private bool get_ResultIndexed();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeBinder : InvokeBinder {
    private CSharpCallFlags _flags;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.StaticCall { get; }
    private string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.Name { get; }
    private Type[] Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.TypeArguments { get; }
    private CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.Flags { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpInvokeBinder(CSharpCallFlags flags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_StaticCall();
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
    private sealed virtual override Type[] Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_TypeArguments();
    private sealed virtual override CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_Flags();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeConstructorBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CSharpCallFlags <Flags>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public CSharpCallFlags Flags { get; }
    public bool StaticCall { get; }
    public Type[] TypeArguments { get; }
    public string Name { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpInvokeConstructorBinder(CSharpCallFlags flags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpCallFlags get_Flags();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public sealed virtual bool get_StaticCall();
    public sealed virtual Type[] get_TypeArguments();
    public sealed virtual string get_Name();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeMemberBinder : InvokeMemberBinder {
    [CompilerGeneratedAttribute]
private CSharpCallFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CallingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <TypeArguments>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.StaticCall { get; }
    public CSharpCallFlags Flags { get; }
    public Type CallingContext { get; }
    public Type[] TypeArguments { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpInvokeMemberBinder(CSharpCallFlags flags, string name, Type callingContext, IEnumerable`1<Type> typeArguments, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_StaticCall();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpCallFlags get_Flags();
    [CompilerGeneratedAttribute]
public Type get_CallingContext();
    [CompilerGeneratedAttribute]
public sealed virtual Type[] get_TypeArguments();
    public sealed virtual CSharpArgumentInfo GetArgumentInfo(int index);
    public CSharpArgumentInfo[] ArgumentInfoArray();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpIsEventBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpIsEventBinder(string name, Type callingContext);
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    public virtual Type get_ReturnType();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpSetIndexBinder : SetIndexBinder {
    [CompilerGeneratedAttribute]
private bool <IsCompoundAssignment>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    internal bool IsCompoundAssignment { get; }
    private bool IsChecked { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpSetIndexBinder(bool isCompoundAssignment, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    [CompilerGeneratedAttribute]
internal bool get_IsCompoundAssignment();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private bool get_IsChecked();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpSetMemberBinder : SetMemberBinder {
    [CompilerGeneratedAttribute]
private bool <IsCompoundAssignment>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    internal bool IsCompoundAssignment { get; }
    private bool IsChecked { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpSetMemberBinder(string name, bool isCompoundAssignment, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    [CompilerGeneratedAttribute]
internal bool get_IsCompoundAssignment();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private bool get_IsChecked();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpUnaryOperationBinder : UnaryOperationBinder {
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    private Type _callingContext;
    [ExcludeFromCodeCoverageAttribute]
public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool IsChecked { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public CSharpUnaryOperationBinder(ExpressionType operation, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private bool get_IsChecked();
    public sealed virtual int GetGetBinderEquivalenceHash();
    public sealed virtual bool IsEquivalentTo(ICSharpBinder other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[EditorBrowsableAttribute("1")]
internal class Microsoft.CSharp.RuntimeBinder.DynamicBindingFailedException : Exception {
    private DynamicBindingFailedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.CSharp.RuntimeBinder.DynamicMetaObjectProviderDebugView : object {
    [DebuggerBrowsableAttribute("0")]
private IList`1<KeyValuePair`2<string, object>> results;
    [DebuggerBrowsableAttribute("0")]
private object obj;
    [DebuggerBrowsableAttribute("0")]
private static ParameterExpression parameter;
    [DebuggerBrowsableAttribute("0")]
private static Type ComObjectType;
    [DebuggerBrowsableAttribute("3")]
internal DynamicProperty[] Items { get; }
    public DynamicMetaObjectProviderDebugView(object arg);
    private static DynamicMetaObjectProviderDebugView();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal DynamicProperty[] get_Items();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TryEvalBinaryOperators(T1 arg1, T2 arg2, CSharpArgumentInfoFlags arg1Flags, CSharpArgumentInfoFlags arg2Flags, ExpressionType opKind, Type accessibilityContext);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TryEvalUnaryOperators(T obj, ExpressionType oper, Type accessibilityContext);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static K TryEvalCast(T obj, Type type, CSharpBinderFlags kind, Type accessibilityContext);
    private static void CreateDelegateSignatureAndArgumentInfos(Object[] args, Type[] argTypes, CSharpArgumentInfoFlags[] argFlags, Type[]& delegateSignatureTypes, CSharpArgumentInfo[]& argInfos);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static object CreateDelegateAndInvoke(Type[] delegateSignatureTypes, CallSiteBinder binder, Object[] args);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TryEvalMethodVarArgs(Object[] methodArgs, Type[] argTypes, CSharpArgumentInfoFlags[] argFlags, string methodName, Type accessibilityContext, Type[] typeArguments);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TryGetMemberValue(T obj, string propName, Type accessibilityContext, bool isResultIndexed);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TryGetMemberValueVarArgs(Object[] propArgs, Type[] argTypes, CSharpArgumentInfoFlags[] argFlags, Type accessibilityContext);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TrySetMemberValue(TObject obj, string propName, TValue value, CSharpArgumentInfoFlags valueFlags, Type accessibilityContext);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static object TrySetMemberValueVarArgs(Object[] propArgs, Type[] argTypes, CSharpArgumentInfoFlags[] argFlags, Type accessibilityContext);
    internal static object TryGetMemberValue(object obj, string name, bool ignoreException);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static IList`1<KeyValuePair`2<string, object>> QueryDynamicObject(object obj);
}
internal static class Microsoft.CSharp.RuntimeBinder.Error : object {
    internal static Exception InternalCompilerError();
    internal static Exception BindPropertyFailedMethodGroup(object p0);
    internal static Exception BindPropertyFailedEvent(object p0);
    internal static Exception BindInvokeFailedNonDelegate();
    internal static Exception BindStaticRequiresType(string paramName);
    internal static Exception NullReferenceOnMemberException();
    internal static Exception BindCallToConditionalMethod(object p0);
    internal static Exception BindToVoidMethodButExpectResult();
    internal static Exception DynamicArgumentNeedsValue(string paramName);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArg : object {
    public ErrArgKind eak;
    public ErrArgFlags eaf;
    internal int n;
    internal SYMKIND sk;
    internal Name name;
    internal Symbol sym;
    internal string psz;
    internal CType pType;
    internal MethPropWithInstMemo mpwiMemo;
    internal SymWithTypeMemo swtMemo;
    public ErrArg(int n);
    public ErrArg(Name name);
    public ErrArg(string psz);
    public ErrArg(CType pType);
    public ErrArg(CType pType, ErrArgFlags eaf);
    public ErrArg(Symbol pSym);
    private ErrArg(Symbol pSym, ErrArgFlags eaf);
    public ErrArg(SymWithType swt);
    public ErrArg(MethPropWithInst mpwi);
    public static ErrArg op_Implicit(int n);
    public static ErrArg op_Implicit(CType type);
    public static ErrArg op_Implicit(string psz);
    public static ErrArg op_Implicit(Name name);
    public static ErrArg op_Implicit(Symbol pSym);
    public static ErrArg op_Implicit(SymWithType swt);
    public static ErrArg op_Implicit(MethPropWithInst mpwi);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrArgFlags : Enum {
    public int value__;
    public static ErrArgFlags None;
    public static ErrArgFlags NoStr;
    public static ErrArgFlags Unique;
    public static ErrArgFlags UseGetErrorInfo;
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrArgKind : Enum {
    public int value__;
    public static ErrArgKind Int;
    public static ErrArgKind SymKind;
    public static ErrArgKind Sym;
    public static ErrArgKind Type;
    public static ErrArgKind Name;
    public static ErrArgKind Str;
    public static ErrArgKind SymWithType;
    public static ErrArgKind MethWithInst;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgNoRef : ErrArg {
    public ErrArgNoRef(CType pType);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgRefOnly : ErrArg {
    public ErrArgRefOnly(Symbol sym);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgSymKind : ErrArg {
    public ErrArgSymKind(Symbol sym);
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrorCode : Enum {
    public int value__;
    public static ErrorCode ERR_BadBinaryOps;
    public static ErrorCode ERR_BadIndexLHS;
    public static ErrorCode ERR_BadIndexCount;
    public static ErrorCode ERR_BadUnaryOp;
    public static ErrorCode ERR_NoImplicitConv;
    public static ErrorCode ERR_NoExplicitConv;
    public static ErrorCode ERR_ConstOutOfRange;
    public static ErrorCode ERR_AmbigBinaryOps;
    public static ErrorCode ERR_AmbigUnaryOp;
    public static ErrorCode ERR_ValueCantBeNull;
    public static ErrorCode ERR_NoSuchMember;
    public static ErrorCode ERR_ObjectRequired;
    public static ErrorCode ERR_AmbigCall;
    public static ErrorCode ERR_BadAccess;
    public static ErrorCode ERR_AssgLvalueExpected;
    public static ErrorCode ERR_NoConstructors;
    public static ErrorCode ERR_PropertyLacksGet;
    public static ErrorCode ERR_ObjectProhibited;
    public static ErrorCode ERR_AssgReadonly;
    public static ErrorCode ERR_AssgReadonlyStatic;
    public static ErrorCode ERR_AssgReadonlyProp;
    public static ErrorCode ERR_UnsafeNeeded;
    public static ErrorCode ERR_BadBoolOp;
    public static ErrorCode ERR_MustHaveOpTF;
    public static ErrorCode ERR_ConstOutOfRangeChecked;
    public static ErrorCode ERR_AmbigMember;
    public static ErrorCode ERR_NoImplicitConvCast;
    public static ErrorCode ERR_InaccessibleGetter;
    public static ErrorCode ERR_InaccessibleSetter;
    public static ErrorCode ERR_BadArity;
    public static ErrorCode ERR_TypeArgsNotAllowed;
    public static ErrorCode ERR_HasNoTypeVars;
    public static ErrorCode ERR_NewConstraintNotSatisfied;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedRefType;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableEnum;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableInterface;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedValType;
    public static ErrorCode ERR_CantInferMethTypeArgs;
    public static ErrorCode ERR_RefConstraintNotSatisfied;
    public static ErrorCode ERR_ValConstraintNotSatisfied;
    public static ErrorCode ERR_AmbigUDConv;
    public static ErrorCode ERR_BindToBogus;
    public static ErrorCode ERR_CantCallSpecialMethod;
    public static ErrorCode ERR_ConvertToStaticClass;
    public static ErrorCode ERR_IncrementLvalueExpected;
    public static ErrorCode ERR_BadArgCount;
    public static ErrorCode ERR_BadArgTypes;
    public static ErrorCode ERR_BadProtectedAccess;
    public static ErrorCode ERR_BindToBogusProp2;
    public static ErrorCode ERR_BindToBogusProp1;
    public static ErrorCode ERR_BadDelArgCount;
    public static ErrorCode ERR_BadDelArgTypes;
    public static ErrorCode ERR_BadCtorArgCount;
    public static ErrorCode ERR_BadNamedArgument;
    public static ErrorCode ERR_DuplicateNamedArgument;
    public static ErrorCode ERR_NamedArgumentUsedInPositional;
    public static ErrorCode ERR_BadNamedArgumentForDelegateInvoke;
    public static ErrorCode ERR_NonInvocableMemberCalled;
    public static ErrorCode ERR_BadNonTrailingNamedArgument;
    public static ErrorCode ERR_DynamicBindingComUnsupported;
}
internal static class Microsoft.CSharp.RuntimeBinder.Errors.ErrorFacts : object {
    public static string GetMessage(ErrorCode code);
    public static string GetMessage(MessageID id);
}
internal static class Microsoft.CSharp.RuntimeBinder.Errors.ErrorHandling : object {
    public static RuntimeBinderException Error(ErrorCode id, ErrArg[] args);
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.MessageID : Enum {
    public int value__;
    public static MessageID SK_METHOD;
    public static MessageID SK_CLASS;
    public static MessageID SK_NAMESPACE;
    public static MessageID SK_FIELD;
    public static MessageID SK_PROPERTY;
    public static MessageID SK_UNKNOWN;
    public static MessageID SK_VARIABLE;
    public static MessageID SK_EVENT;
    public static MessageID SK_TYVAR;
    public static MessageID SK_ALIAS;
    public static MessageID ERRORSYM;
    public static MessageID NULL;
    public static MessageID GlobalNamespace;
    public static MessageID MethodGroup;
    public static MessageID AnonMethod;
    public static MessageID Lambda;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.MethPropWithInstMemo : object {
    public Symbol sym;
    public AggregateType ats;
    public TypeArray typeArgs;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.SymWithTypeMemo : object {
    public Symbol sym;
    public AggregateType ats;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.UserStringBuilder : ValueType {
    private StringBuilder _strBuilder;
    private void BeginString();
    private string EndString();
    private static string ErrSK(SYMKIND sk);
    private void ErrAppendParamList(TypeArray params, bool isParamArray);
    private void ErrAppendString(string str);
    private void ErrAppendChar(char ch);
    private void ErrAppendPrintf(string format, Object[] args);
    private void ErrAppendName(Name name);
    private void ErrAppendParentSym(Symbol sym, SubstContext pctx);
    private void ErrAppendParentCore(Symbol parent, SubstContext pctx);
    private void ErrAppendTypeParameters(TypeArray params, SubstContext pctx);
    private void ErrAppendMethod(MethodSymbol meth, SubstContext pctx, bool fArgs);
    private void ErrAppendIndexer(IndexerSymbol indexer, SubstContext pctx);
    private void ErrAppendProperty(PropertySymbol prop, SubstContext pctx);
    private void ErrAppendId(MessageID id);
    private void ErrAppendSym(Symbol sym, SubstContext pctx);
    private void ErrAppendSym(Symbol sym, SubstContext pctx, bool fArgs);
    private void ErrAppendType(CType pType, SubstContext pctx);
    public bool ErrArgToString(String& psz, ErrArg parg, Boolean& fUserStrings);
    private static string ErrId(MessageID id);
}
internal class Microsoft.CSharp.RuntimeBinder.ExpressionTreeCallRewriter : ExprVisitorBase {
    private Dictionary`2<ExprCall, Expression> _DictionaryOfParameters;
    private Expression[] _ListOfParameters;
    private int _currentParameterIndex;
    private ExpressionTreeCallRewriter(Expression[] listOfParameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static Expression Rewrite(ExprBinOp binOp, Expression[] listOfParameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSAVE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCALL(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitWRAP(ExprWrap pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateLambda(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateCall(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateArrayIndex(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateConvert(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateProperty(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateField(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateInvoke(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateNew(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expression GenerateConstantType(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateAssignment(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateBinaryOperator(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateUserDefinedBinaryOperator(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateUnaryOperator(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GenerateUserDefinedUnaryOperator(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression GetExpression(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression[] GetArgumentsFromArrayInit(ExprArrayInit arrinit);
}
internal class Microsoft.CSharp.RuntimeBinder.GetMemberValueBinder : GetMemberBinder {
    public GetMemberValueBinder(string name, bool ignoreCase);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject self, DynamicMetaObject onBindingError);
}
internal interface Microsoft.CSharp.RuntimeBinder.ICSharpBinder {
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public BindingFlag BindingFlags { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    public abstract virtual CSharpArgumentInfo GetArgumentInfo(int index);
    public abstract virtual bool get_IsBinderThatCanHaveRefReceiver();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public abstract virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public abstract virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public abstract virtual BindingFlag get_BindingFlags();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReturnType();
    public abstract virtual int GetGetBinderEquivalenceHash();
    public abstract virtual bool IsEquivalentTo(ICSharpBinder other);
}
internal interface Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder {
    public bool StaticCall { get; }
    public bool ResultDiscarded { get; }
    public CSharpCallFlags Flags { get; }
    public Type[] TypeArguments { get; }
    public abstract virtual bool get_StaticCall();
    public abstract virtual bool get_ResultDiscarded();
    public abstract virtual CSharpCallFlags get_Flags();
    public abstract virtual Type[] get_TypeArguments();
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.RuntimeBinder : ValueType {
    private static object s_bindLock;
    private ExpressionBinder _binder;
    internal bool IsChecked { get; }
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public RuntimeBinder(Type contextType, bool isChecked);
    private static RuntimeBinder();
    internal bool get_IsChecked();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expression Bind(ICSharpBinder payload, Expression[] parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expression BindCore(ICSharpBinder payload, Expression[] parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool DeferBinding(ICSharpBinder payload, ArgumentObject[] arguments, DynamicMetaObject[] args, LocalVariableSymbol[] locals, DynamicMetaObject& deferredBinding);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expression CreateExpressionTreeFromResult(Expression[] parameters, Scope pScope, Expr pResult);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Type GetArgumentType(ICSharpBinder p, CSharpArgumentInfo argInfo, Expression param, DynamicMetaObject arg, int index);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ArgumentObject[] CreateArgumentArray(ICSharpBinder payload, Expression[] parameters, DynamicMetaObject[] args);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static void PopulateSymbolTableWithPayloadInformation(ICSharpInvokeOrInvokeMemberBinder callOrInvoke, Type callingType, ArgumentObject[] arguments);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddConversionsForArguments(ArgumentObject[] arguments);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ExprWithArgs DispatchPayload(ICSharpInvokeOrInvokeMemberBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static LocalVariableSymbol[] PopulateLocalScope(ICSharpBinder payload, Scope pScope, ArgumentObject[] arguments, Expression[] parameterExpressions);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprBoundLambda GenerateBoundLambda(Scope pScope, Expr call);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr CreateLocal(Type type, bool isOut, LocalVariableSymbol local);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr CreateArgumentListEXPR(ArgumentObject[] arguments, LocalVariableSymbol[] locals, int startIndex, int endIndex);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr CreateArgumentEXPR(ArgumentObject argument, LocalVariableSymbol local);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprMemberGroup CreateMemberGroupExpr(string Name, Type[] typeArguments, Expr callingObject, SYMKIND kind);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr CreateProperty(SymWithType swt, Expr callingObject, BindingFlag flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprWithArgs CreateIndexer(SymWithType swt, Expr callingObject, Expr arguments, BindingFlag bindFlags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr CreateArray(Expr callingObject, Expr optionalIndexerArguments);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr CreateField(SymWithType swt, Expr callingObject);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr CreateCallingObjectForCall(ICSharpInvokeOrInvokeMemberBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprWithArgs BindCall(ICSharpInvokeOrInvokeMemberBinder payload, Expr callingObject, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    private static void CheckForConditionalMethodError(ExprCall call);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void ReorderArgumentsForNamedAndOptional(Expr callingObject, ExprWithArgs result);
    private Expr StripNamedArgument(Expr pArg);
    private Expr StripNamedArguments(Expr pArg);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindUnaryOperation(CSharpUnaryOperationBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindBinaryOperation(CSharpBinaryOperationBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    private static OperatorKind GetOperatorKind(ExpressionType p);
    private static OperatorKind GetOperatorKind(ExpressionType p, bool bIsLogical);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindProperty(ICSharpBinder payload, ArgumentObject argument, LocalVariableSymbol local, Expr optionalIndexerArguments);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindImplicitConversion(ArgumentObject[] arguments, Type returnType, LocalVariableSymbol[] locals, bool bIsArrayCreationConversion);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindExplicitConversion(ArgumentObject[] arguments, Type returnType, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindAssignment(ICSharpBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindIsEvent(CSharpIsEventBinder binder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.CSharp.RuntimeBinder.RuntimeBinderException : Exception {
    public RuntimeBinderException(string message);
    public RuntimeBinderException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected RuntimeBinderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.RuntimeBinderExtensions : object {
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static bool IsEquivalentTo(MemberInfo mi1, MemberInfo mi2);
    [ExtensionAttribute]
private static bool AreParametersEquivalent(MethodBase method1, MethodBase method2);
    [ExtensionAttribute]
private static bool IsEquivalentTo(ParameterInfo pi1, ParameterInfo pi2, MethodBase method1, MethodBase method2);
    [ExtensionAttribute]
private static bool IsGenericallyEqual(Type t1, Type t2);
    [ExtensionAttribute]
private static bool IsGenericallyEquivalentTo(Type t1, Type t2, MemberInfo member1, MemberInfo member2);
    [ExtensionAttribute]
private static bool IsTypeParameterEquivalentToTypeInst(Type typeParam, Type typeInst, MemberInfo member);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static string GetIndexerName(Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static string GetTypeIndexerName(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.CSharp.RuntimeBinder.RuntimeBinderInternalCompilerException : Exception {
    public RuntimeBinderInternalCompilerException(string message);
    public RuntimeBinderInternalCompilerException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected RuntimeBinderInternalCompilerException(SerializationInfo info, StreamingContext context);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ACCESS : Enum {
    public int value__;
    public static ACCESS ACC_UNKNOWN;
    public static ACCESS ACC_PRIVATE;
    public static ACCESS ACC_INTERNAL_AND_PROTECTED;
    public static ACCESS ACC_INTERNAL;
    public static ACCESS ACC_PROTECTED;
    public static ACCESS ACC_INTERNALPROTECTED;
    public static ACCESS ACC_PUBLIC;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ACCESSERROR : Enum {
    public int value__;
    public static ACCESSERROR ACCESSERROR_NOACCESS;
    public static ACCESSERROR ACCESSERROR_NOACCESSTHRU;
    public static ACCESSERROR ACCESSERROR_NOERROR;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.AggCastResult : Enum {
    public int value__;
    public static AggCastResult Success;
    public static AggCastResult Failure;
    public static AggCastResult Abort;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.AggKindEnum : Enum {
    public int value__;
    public static AggKindEnum Unknown;
    public static AggKindEnum Class;
    public static AggKindEnum Delegate;
    public static AggKindEnum Interface;
    public static AggKindEnum Struct;
    public static AggKindEnum Enum;
    public static AggKindEnum Lim;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateSymbol : NamespaceOrAggregateSymbol {
    public Type AssociatedSystemType;
    public Assembly AssociatedAssembly;
    private AggregateType _atsInst;
    private AggregateType _pBaseClass;
    private AggregateType _pUnderlyingType;
    private TypeArray _ifaces;
    private TypeArray _ifacesAll;
    private TypeArray _typeVarsThis;
    private TypeArray _typeVarsAll;
    private MethodSymbol _pConvFirst;
    private AggKindEnum _aggKind;
    private bool _isPredefined;
    private PredefinedType _iPredef;
    private bool _isAbstract;
    private bool _isSealed;
    private bool _hasPubNoArgCtor;
    private bool _isSkipUDOps;
    private Nullable`1<bool> _hasConversion;
    public AggregateSymbol GetBaseAgg();
    public AggregateType getThisType();
    public bool FindBaseAgg(AggregateSymbol agg);
    public bool isNested();
    public AggregateSymbol GetOuterAgg();
    public bool isPredefAgg(PredefinedType pt);
    public AggKindEnum AggKind();
    public void SetAggKind(AggKindEnum aggKind);
    public bool IsClass();
    public bool IsDelegate();
    public bool IsInterface();
    public bool IsStruct();
    public bool IsEnum();
    public bool IsValueType();
    public bool IsRefType();
    public bool IsStatic();
    public bool IsAbstract();
    public void SetAbstract(bool abstract);
    public bool IsPredefined();
    public void SetPredefined(bool predefined);
    public PredefinedType GetPredefType();
    public void SetPredefType(PredefinedType predef);
    public bool IsSealed();
    public void SetSealed(bool sealed);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public bool HasConversion();
    public void SetHasConversion();
    public bool HasPubNoArgCtor();
    public void SetHasPubNoArgCtor(bool hasPubNoArgCtor);
    public bool IsSkipUDOps();
    public void SetSkipUDOps(bool skipUDOps);
    public TypeArray GetTypeVars();
    public void SetTypeVars(TypeArray typeVars);
    public TypeArray GetTypeVarsAll();
    public AggregateType GetBaseClass();
    public void SetBaseClass(AggregateType baseClass);
    public AggregateType GetUnderlyingType();
    public void SetUnderlyingType(AggregateType underlyingType);
    public TypeArray GetIfaces();
    public void SetIfaces(TypeArray ifaces);
    public TypeArray GetIfacesAll();
    public void SetIfacesAll(TypeArray ifacesAll);
    public MethodSymbol GetFirstUDConversion();
    public void SetFirstUDConversion(MethodSymbol conv);
    public bool InternalsVisibleTo(Assembly assembly);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateType : CType {
    private AggregateType _baseType;
    private TypeArray _ifacesAll;
    private Type _associatedSystemType;
    public Nullable`1<bool> ConstraintError;
    public bool AllHidden;
    public bool DiffHidden;
    [CompilerGeneratedAttribute]
private AggregateType <OuterType>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateSymbol <OwningAggregate>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgsThis>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgsAll>k__BackingField;
    public AggregateType OuterType { get; }
    public AggregateSymbol OwningAggregate { get; }
    public AggregateType BaseClass { get; }
    public IEnumerable`1<AggregateType> TypeHierarchy { get; }
    private AggregateType BaseClassWithSuppressedMessage { get; }
    public TypeArray TypeArgsThis { get; }
    public TypeArray TypeArgsAll { get; }
    public TypeArray IfacesAll { get; }
    public bool IsReferenceType { get; }
    public bool IsNonNullableValueType { get; }
    public bool IsValueType { get; }
    public bool IsStaticClass { get; }
    public bool IsPredefined { get; }
    public PredefinedType PredefinedType { get; }
    public bool IsDelegateType { get; }
    public bool IsSimpleType { get; }
    public bool IsSimpleOrEnum { get; }
    public bool IsSimpleOrEnumOrString { get; }
    public bool IsNumericType { get; }
    public bool IsStructType { get; }
    public bool IsEnumType { get; }
    public bool IsInterfaceType { get; }
    public bool IsClassType { get; }
    public AggregateType UnderlyingEnumType { get; }
    public Type AssociatedSystemType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    public AggregateType(AggregateSymbol parent, TypeArray typeArgsThis, AggregateType outerType);
    [CompilerGeneratedAttribute]
public AggregateType get_OuterType();
    [CompilerGeneratedAttribute]
public AggregateSymbol get_OwningAggregate();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public AggregateType get_BaseClass();
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.AggregateType/<get_TypeHierarchy>d__17")]
[RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public IEnumerable`1<AggregateType> get_TypeHierarchy();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private AggregateType get_BaseClassWithSuppressedMessage();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static AggregateType GetPredefinedAggregateGetThisTypeWithSuppressedMessage();
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgsThis();
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgsAll();
    public TypeArray get_IfacesAll();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsNonNullableValueType();
    public virtual bool get_IsValueType();
    public virtual bool get_IsStaticClass();
    public virtual bool get_IsPredefined();
    public virtual PredefinedType get_PredefinedType();
    public virtual bool IsPredefType(PredefinedType pt);
    public virtual bool get_IsDelegateType();
    public virtual bool get_IsSimpleType();
    public virtual bool get_IsSimpleOrEnum();
    public virtual bool get_IsSimpleOrEnumOrString();
    public virtual bool get_IsNumericType();
    public virtual bool get_IsStructType();
    public virtual bool get_IsEnumType();
    public virtual bool get_IsInterfaceType();
    public virtual bool get_IsClassType();
    public virtual AggregateType get_UnderlyingEnumType();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Type CalculateAssociatedSystemType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual AggregateType GetAts();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArgInfos : object {
    public int carg;
    public TypeArray types;
    public List`1<Expr> prgexpr;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArgumentListType : CType {
    public static ArgumentListType Instance;
    private static ArgumentListType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArrayType : CType {
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSZArray>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <ElementType>k__BackingField;
    public int Rank { get; }
    public bool IsSZArray { get; }
    public CType ElementType { get; }
    public CType BaseElementType { get; }
    public bool IsReferenceType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    public ArrayType(CType elementType, int rank, bool isSZArray);
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
public bool get_IsSZArray();
    [CompilerGeneratedAttribute]
public CType get_ElementType();
    public CType get_BaseElementType();
    public virtual bool get_IsReferenceType();
    public virtual bool IsUnsafe();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual AggregateType GetAts();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BetterType : Enum {
    public int value__;
    public static BetterType Same;
    public static BetterType Left;
    public static BetterType Right;
    public static BetterType Neither;
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.BindingContext : ValueType {
    [CompilerGeneratedAttribute]
private AggregateSymbol <ContextForMemberLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Checked>k__BackingField;
    public AggregateSymbol ContextForMemberLookup { get; }
    public bool Checked { get; }
    public BindingContext(AggregateSymbol context, bool isChecked);
    public BindingContext(BindingContext parent);
    [CompilerGeneratedAttribute]
public AggregateSymbol get_ContextForMemberLookup();
    [CompilerGeneratedAttribute]
public bool get_Checked();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BindingFlag : Enum {
    public int value__;
    public static BindingFlag BIND_RVALUEREQUIRED;
    public static BindingFlag BIND_MEMBERSET;
    public static BindingFlag BIND_FIXEDVALUE;
    public static BindingFlag BIND_ARGUMENTS;
    public static BindingFlag BIND_BASECALL;
    public static BindingFlag BIND_USINGVALUE;
    public static BindingFlag BIND_STMTEXPRONLY;
    public static BindingFlag BIND_TYPEOK;
    public static BindingFlag BIND_MAYBECONFUSEDNEGATIVECAST;
    public static BindingFlag BIND_METHODNOTOK;
    public static BindingFlag BIND_DECLNOTOK;
    public static BindingFlag BIND_NOPARAMS;
    public static BindingFlag BIND_SPECULATIVELY;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpFuncKind : Enum {
    public int value__;
    public static BinOpFuncKind BoolBinOp;
    public static BinOpFuncKind BoolBitwiseOp;
    public static BinOpFuncKind DecBinOp;
    public static BinOpFuncKind DelBinOp;
    public static BinOpFuncKind EnumBinOp;
    public static BinOpFuncKind IntBinOp;
    public static BinOpFuncKind RealBinOp;
    public static BinOpFuncKind RefCmpOp;
    public static BinOpFuncKind ShiftOp;
    public static BinOpFuncKind StrBinOp;
    public static BinOpFuncKind StrCmpOp;
    public static BinOpFuncKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpKind : Enum {
    public int value__;
    public static BinOpKind Add;
    public static BinOpKind Sub;
    public static BinOpKind Mul;
    public static BinOpKind Shift;
    public static BinOpKind Equal;
    public static BinOpKind Compare;
    public static BinOpKind Bitwise;
    public static BinOpKind BitXor;
    public static BinOpKind Logical;
    public static BinOpKind Lim;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpMask : Enum {
    public int value__;
    public static BinOpMask None;
    public static BinOpMask Add;
    public static BinOpMask Sub;
    public static BinOpMask Mul;
    public static BinOpMask Shift;
    public static BinOpMask Equal;
    public static BinOpMask Compare;
    public static BinOpMask Bitwise;
    public static BinOpMask BitXor;
    public static BinOpMask Logical;
    public static BinOpMask Integer;
    public static BinOpMask Real;
    public static BinOpMask BoolNorm;
    public static BinOpMask Delegate;
    public static BinOpMask Enum;
    public static BinOpMask EnumUnder;
    public static BinOpMask UnderEnum;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CandidateFunctionMember : object {
    public MethPropWithInst mpwi;
    public TypeArray params;
    public byte ctypeLift;
    public bool fExpanded;
    public CandidateFunctionMember(MethPropWithInst mpwi, TypeArray params, byte ctypeLift, bool fExpanded);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.CConversions : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool FImpRefConv(CType typeSrc, CType typeDst);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool FExpRefConv(CType typeSrc, CType typeDst);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool HasGenericDelegateExplicitReferenceConversion(CType source, CType target);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool HasGenericDelegateExplicitReferenceConversion(CType pSource, AggregateType pTarget);
    public static bool FWrappingConv(CType typeSrc, CType typeDst);
    public static bool FUnwrappingConv(CType typeSrc, CType typeDst);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CheckConstraintsFlags : Enum {
    public int value__;
    public static CheckConstraintsFlags None;
    public static CheckConstraintsFlags Outer;
    public static CheckConstraintsFlags NoErrors;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CheckLvalueKind : Enum {
    public int value__;
    public static CheckLvalueKind Assignment;
    public static CheckLvalueKind Increment;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CMemberLookupResults : object {
    [CompilerGeneratedAttribute]
private TypeArray <ContainingTypes>k__BackingField;
    private Name _pName;
    private TypeArray ContainingTypes { get; }
    public CMemberLookupResults(TypeArray containingTypes, Name name);
    [CompilerGeneratedAttribute]
private TypeArray get_ContainingTypes();
    public CMethodIterator GetMethodIterator(CType qualifyingType, AggregateSymbol context, int arity, EXPRFLAG flags, symbmask_t mask, ArgInfos nonTrailingNamedArguments);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstCastResult : Enum {
    public int value__;
    public static ConstCastResult Success;
    public static ConstCastResult Failure;
    public static ConstCastResult CheckFailure;
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ConstVal : ValueType {
    private static object s_false;
    private static object s_true;
    private static object s_zeroInt32;
    [CompilerGeneratedAttribute]
private object <ObjectVal>k__BackingField;
    public object ObjectVal { get; }
    public bool BooleanVal { get; }
    public sbyte SByteVal { get; }
    public byte ByteVal { get; }
    public short Int16Val { get; }
    public ushort UInt16Val { get; }
    public int Int32Val { get; }
    public UInt32 UInt32Val { get; }
    public long Int64Val { get; }
    public ulong UInt64Val { get; }
    public float SingleVal { get; }
    public double DoubleVal { get; }
    public decimal DecimalVal { get; }
    public char CharVal { get; }
    public string StringVal { get; }
    public bool IsNullRef { get; }
    private ConstVal(object value);
    private static ConstVal();
    [CompilerGeneratedAttribute]
public object get_ObjectVal();
    public bool get_BooleanVal();
    public sbyte get_SByteVal();
    public byte get_ByteVal();
    public short get_Int16Val();
    public ushort get_UInt16Val();
    public int get_Int32Val();
    public UInt32 get_UInt32Val();
    public long get_Int64Val();
    public ulong get_UInt64Val();
    public float get_SingleVal();
    public double get_DoubleVal();
    public decimal get_DecimalVal();
    public char get_CharVal();
    public string get_StringVal();
    public bool get_IsNullRef();
    public bool IsZero(ConstValKind kind);
    private static T SpecialUnbox(object o);
    private static bool IsDefault(object o);
    public static ConstVal GetDefaultValue(ConstValKind kind);
    public static ConstVal Get(bool value);
    public static ConstVal Get(int value);
    public static ConstVal Get(UInt32 value);
    public static ConstVal Get(decimal value);
    public static ConstVal Get(string value);
    public static ConstVal Get(float value);
    public static ConstVal Get(double value);
    public static ConstVal Get(long value);
    public static ConstVal Get(ulong value);
    public static ConstVal Get(object p);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstValKind : Enum {
    public int value__;
    public static ConstValKind Int;
    public static ConstValKind Double;
    public static ConstValKind Long;
    public static ConstValKind String;
    public static ConstValKind Decimal;
    public static ConstValKind IntPtr;
    public static ConstValKind Float;
    public static ConstValKind Boolean;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CONVERTTYPE : Enum {
    public int value__;
    public static CONVERTTYPE NOUDC;
    public static CONVERTTYPE STANDARD;
    public static CONVERTTYPE ISEXPLICIT;
    public static CONVERTTYPE CHECKOVERFLOW;
    public static CONVERTTYPE FORCECAST;
    public static CONVERTTYPE STANDARDANDNOUDC;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConvKind : Enum {
    public int value__;
    public static ConvKind Identity;
    public static ConvKind Implicit;
    public static ConvKind Explicit;
    public static ConvKind Unknown;
    public static ConvKind None;
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.CSemanticChecker : object {
    public static void CheckForStaticClass(CType type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ACCESSERROR CheckAccess2(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool CheckTypeAccess(CType type, Symbol symWhere);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ACCESSERROR CheckAccessCore(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
    public static bool CheckBogus(Symbol sym);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static RuntimeBinderException ReportAccessError(SymWithType swtBad, Symbol symWhere, CType typeQual);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool CheckAccess(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.CType : object {
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    [ExcludeFromCodeCoverageAttribute]
public Type AssociatedSystemType { get; }
    public TypeKind TypeKind { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    public bool IsDelegateType { get; }
    public bool IsSimpleType { get; }
    public bool IsSimpleOrEnum { get; }
    public bool IsSimpleOrEnumOrString { get; }
    public bool IsNumericType { get; }
    public bool IsStructType { get; }
    public bool IsEnumType { get; }
    public bool IsInterfaceType { get; }
    public bool IsClassType { get; }
    [ExcludeFromCodeCoverageAttribute]
public AggregateType UnderlyingEnumType { get; }
    public bool IsPredefined { get; }
    [ExcludeFromCodeCoverageAttribute]
public PredefinedType PredefinedType { get; }
    public bool IsStaticClass { get; }
    public bool IsValueType { get; }
    public bool IsNonNullableValueType { get; }
    public bool IsReferenceType { get; }
    private protected CType(TypeKind kind);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    [CompilerGeneratedAttribute]
public TypeKind get_TypeKind();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
    public CType GetNakedType(bool fStripNub);
    public virtual CType StripNubs();
    public virtual CType StripNubs(Boolean& wasNullable);
    public virtual bool get_IsDelegateType();
    public virtual bool get_IsSimpleType();
    public virtual bool get_IsSimpleOrEnum();
    public virtual bool get_IsSimpleOrEnumOrString();
    public virtual bool get_IsNumericType();
    public virtual bool get_IsStructType();
    public virtual bool get_IsEnumType();
    public virtual bool get_IsInterfaceType();
    public virtual bool get_IsClassType();
    public virtual AggregateType get_UnderlyingEnumType();
    public virtual bool IsUnsafe();
    public virtual bool IsPredefType(PredefinedType pt);
    public virtual bool get_IsPredefined();
    public virtual PredefinedType get_PredefinedType();
    public virtual bool get_IsStaticClass();
    public virtual bool get_IsValueType();
    public virtual bool get_IsNonNullableValueType();
    public virtual bool get_IsReferenceType();
    [ExcludeFromCodeCoverageAttribute]
[RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual AggregateType GetAts();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EventSymbol : Symbol {
    public EventInfo AssociatedEventInfo;
    public bool isStatic;
    public bool isOverride;
    public CType type;
    public MethodSymbol methAdd;
    public MethodSymbol methRemove;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.Expr : object {
    private CType _type;
    [CompilerGeneratedAttribute]
private object <RuntimeObject>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <RuntimeObjectActualType>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private EXPRFLAG <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptionalArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorString>k__BackingField;
    internal object RuntimeObject { get; internal set; }
    internal CType RuntimeObjectActualType { get; internal set; }
    public ExpressionKind Kind { get; }
    public EXPRFLAG Flags { get; public set; }
    public bool IsOptionalArgument { get; public set; }
    public string ErrorString { get; public set; }
    public CType Type { get; protected set; }
    [ExcludeFromCodeCoverageAttribute]
public object Object { get; }
    protected Expr(ExpressionKind kind);
    [CompilerGeneratedAttribute]
internal object get_RuntimeObject();
    [CompilerGeneratedAttribute]
internal void set_RuntimeObject(object value);
    [CompilerGeneratedAttribute]
internal CType get_RuntimeObjectActualType();
    [CompilerGeneratedAttribute]
internal void set_RuntimeObjectActualType(CType value);
    [CompilerGeneratedAttribute]
public ExpressionKind get_Kind();
    [CompilerGeneratedAttribute]
public EXPRFLAG get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(EXPRFLAG value);
    [CompilerGeneratedAttribute]
public bool get_IsOptionalArgument();
    [CompilerGeneratedAttribute]
public void set_IsOptionalArgument(bool value);
    [CompilerGeneratedAttribute]
public string get_ErrorString();
    [CompilerGeneratedAttribute]
public void set_ErrorString(string value);
    public CType get_Type();
    protected void set_Type(CType value);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprArrayIndex : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <Index>k__BackingField;
    public Expr Array { get; public set; }
    public Expr Index { get; public set; }
    public ExprArrayIndex(CType type, Expr array, Expr index);
    [CompilerGeneratedAttribute]
public Expr get_Array();
    [CompilerGeneratedAttribute]
public void set_Array(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprArrayInit : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalArgumentDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <DimensionSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneratedForParamArray>k__BackingField;
    public Expr OptionalArguments { get; public set; }
    public Expr OptionalArgumentDimensions { get; public set; }
    public Int32[] DimensionSizes { get; }
    public bool GeneratedForParamArray { get; public set; }
    public ExprArrayInit(CType type, Expr arguments, Expr argumentDimensions, Int32[] dimensionSizes);
    [CompilerGeneratedAttribute]
public Expr get_OptionalArguments();
    [CompilerGeneratedAttribute]
public void set_OptionalArguments(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalArgumentDimensions();
    [CompilerGeneratedAttribute]
public void set_OptionalArgumentDimensions(Expr value);
    [CompilerGeneratedAttribute]
public Int32[] get_DimensionSizes();
    [CompilerGeneratedAttribute]
public bool get_GeneratedForParamArray();
    [CompilerGeneratedAttribute]
public void set_GeneratedForParamArray(bool value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprAssignment : Expr {
    private Expr _lhs;
    [CompilerGeneratedAttribute]
private Expr <RHS>k__BackingField;
    public Expr LHS { get; public set; }
    public Expr RHS { get; public set; }
    public ExprAssignment(Expr lhs, Expr rhs);
    public Expr get_LHS();
    public void set_LHS(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_RHS();
    [CompilerGeneratedAttribute]
public void set_RHS(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprBinOp : ExprOperator {
    [CompilerGeneratedAttribute]
private Expr <OptionalLeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalRightChild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    public Expr OptionalLeftChild { get; public set; }
    public Expr OptionalRightChild { get; public set; }
    unknown bool IsLifted {public set; }
    public ExprBinOp(ExpressionKind kind, CType type, Expr left, Expr right);
    public ExprBinOp(ExpressionKind kind, CType type, Expr left, Expr right, Expr call, MethPropWithInst userMethod);
    [CompilerGeneratedAttribute]
public Expr get_OptionalLeftChild();
    [CompilerGeneratedAttribute]
public void set_OptionalLeftChild(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalRightChild();
    [CompilerGeneratedAttribute]
public void set_OptionalRightChild(Expr value);
    [CompilerGeneratedAttribute]
public void set_IsLifted(bool value);
    public void SetAssignment();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprBoundLambda : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <ArgumentScope>k__BackingField;
    public Expr Expression { get; }
    public AggregateType DelegateType { get; }
    public Scope ArgumentScope { get; }
    public ExprBoundLambda(AggregateType type, Scope argumentScope, Expr expression);
    [CompilerGeneratedAttribute]
public Expr get_Expression();
    public AggregateType get_DelegateType();
    [CompilerGeneratedAttribute]
public Scope get_ArgumentScope();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprCall : ExprWithArgs {
    [CompilerGeneratedAttribute]
private MethWithInst <MethWithInst>k__BackingField;
    [CompilerGeneratedAttribute]
private PREDEFMETH <PredefinedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableCallLiftKind <NullableCallLiftKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <PConversions>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <CastOfNonLiftedResultToLiftedType>k__BackingField;
    public MethWithInst MethWithInst { get; public set; }
    public PREDEFMETH PredefinedMethod { get; public set; }
    public NullableCallLiftKind NullableCallLiftKind { get; public set; }
    public Expr PConversions { get; public set; }
    public Expr CastOfNonLiftedResultToLiftedType { get; public set; }
    public ExprCall(CType type, EXPRFLAG flags, Expr arguments, ExprMemberGroup member, MethWithInst method);
    [CompilerGeneratedAttribute]
public MethWithInst get_MethWithInst();
    [CompilerGeneratedAttribute]
public void set_MethWithInst(MethWithInst value);
    [CompilerGeneratedAttribute]
public PREDEFMETH get_PredefinedMethod();
    [CompilerGeneratedAttribute]
public void set_PredefinedMethod(PREDEFMETH value);
    [CompilerGeneratedAttribute]
public NullableCallLiftKind get_NullableCallLiftKind();
    [CompilerGeneratedAttribute]
public void set_NullableCallLiftKind(NullableCallLiftKind value);
    [CompilerGeneratedAttribute]
public Expr get_PConversions();
    [CompilerGeneratedAttribute]
public void set_PConversions(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_CastOfNonLiftedResultToLiftedType();
    [CompilerGeneratedAttribute]
public void set_CastOfNonLiftedResultToLiftedType(Expr value);
    public virtual SymWithType GetSymWithType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprCast : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Argument>k__BackingField;
    public Expr Argument { get; public set; }
    public bool IsBoxingCast { get; }
    public object Object { get; }
    public ExprCast(EXPRFLAG flags, CType type, Expr argument);
    [CompilerGeneratedAttribute]
public Expr get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(Expr value);
    public bool get_IsBoxingCast();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprClass : ExprWithType {
    public ExprClass(CType type);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprConcat : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <FirstArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <SecondArgument>k__BackingField;
    public Expr FirstArgument { get; public set; }
    public Expr SecondArgument { get; public set; }
    public ExprConcat(Expr first, Expr second);
    private static CType TypeFromOperands(Expr first, Expr second);
    [CompilerGeneratedAttribute]
public Expr get_FirstArgument();
    [CompilerGeneratedAttribute]
public void set_FirstArgument(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_SecondArgument();
    [CompilerGeneratedAttribute]
public void set_SecondArgument(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprConstant : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalConstructorCall>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstVal <Val>k__BackingField;
    public Expr OptionalConstructorCall { get; public set; }
    public bool IsZero { get; }
    public ConstVal Val { get; }
    public ulong UInt64Value { get; }
    public long Int64Value { get; }
    public object Object { get; }
    public ExprConstant(CType type, ConstVal value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalConstructorCall();
    [CompilerGeneratedAttribute]
public void set_OptionalConstructorCall(Expr value);
    public bool get_IsZero();
    [CompilerGeneratedAttribute]
public ConstVal get_Val();
    public ulong get_UInt64Value();
    public long get_Int64Value();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual object get_Object();
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionBinder : ValueType {
    private static Byte[][] s_betterConversionTable;
    private static Byte[][] s_simpleTypeConversions;
    private static Byte[][] s_simpleTypeBetter;
    [CompilerGeneratedAttribute]
private BindingContext <Context>k__BackingField;
    private static PredefinedType[] s_rgptIntOp;
    private static PredefinedName[] s_EK2NAME;
    private static BinOpSig[] s_binopSignatures;
    private static UnaOpSig[] s_rguos;
    public BindingContext Context { get; }
    private AggregateSymbol ContextForMemberLookup { get; }
    public ExpressionBinder(BindingContext context);
    private static ExpressionBinder();
    private static BetterType WhichMethodIsBetterTieBreaker(CandidateFunctionMember node1, CandidateFunctionMember node2, CType pTypeThrough, ArgInfos args);
    private static BetterType CompareTypes(TypeArray ta1, TypeArray ta2);
    private static int FindName(List`1<Name> names, Name name);
    private static TypeArray RearrangeNamedArguments(TypeArray pta, MethPropWithInst mpwi, CType pTypeThrough, ArgInfos args);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private BetterType WhichMethodIsBetter(CandidateFunctionMember node1, CandidateFunctionMember node2, CType pTypeThrough, ArgInfos args);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private BetterType WhichConversionIsBetter(CType argType, CType p1, CType p2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private CandidateFunctionMember FindBestMethod(List`1<CandidateFunctionMember> list, CType pTypeThrough, ArgInfos args, CandidateFunctionMember& methAmbig1, CandidateFunctionMember& methAmbig2);
    private static void RoundToFloat(double d, Single& f);
    private static long I64(long x);
    private static ConvKind GetConvKind(PredefinedType ptSrc, PredefinedType ptDst);
    private static bool isUserDefinedConversion(PredefinedType ptSrc, PredefinedType ptDst);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private BetterType WhichSimpleConversionIsBetter(PredefinedType pt1, PredefinedType pt2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private BetterType WhichTypeIsBetter(PredefinedType pt1, PredefinedType pt2, CType typeGiven);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private BetterType WhichTypeIsBetter(CType type1, CType type2, CType typeGiven);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool canConvert(CType src, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public bool canConvert(CType src, CType dest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool canConvert(Expr expr, CType dest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool canConvert(Expr expr, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr mustConvertCore(Expr expr, CType destExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr mustConvertCore(Expr expr, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr tryConvert(Expr expr, CType dest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr tryConvert(Expr expr, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr mustConvert(Expr expr, CType dest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr mustConvert(Expr expr, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr mustCastCore(Expr expr, CType dest, CONVERTTYPE flags);
    private static RuntimeBinderException CantConvert(Expr expr, CType dest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr mustCast(Expr expr, CType dest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr mustCast(Expr expr, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr MustCastInUncheckedContext(Expr expr, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool canCast(CType src, CType dest, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool BindImplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool BindImplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, Expr& ppDestinationExpr, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool BindImplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, bool needsExprDest, Expr& ppDestinationExpr, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool BindExplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, bool needsExprDest, Expr& ppDestinationExpr, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool BindExplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, Expr& ppDestinationExpr, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool BindExplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, CONVERTTYPE flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool bindUserDefinedConversion(Expr exprSrc, CType typeSrc, CType typeDst, bool needExprDest, Expr& pexprDst, bool fImplicitOnly);
    private static RuntimeBinderException HandleAmbiguity(CType typeSrc, CType typeDst, List`1<UdConvInfo> prguci, int iuciBestSrc, int iuciBestDst);
    private static void MarkAsIntermediateConversion(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindUDConversionCore(Expr pFrom, CType pTypeFrom, CType pTypeTo, CType pTypeDestination, MethWithInst mwiBest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindUDConversionCore(Expr pFrom, CType pTypeFrom, CType pTypeTo, CType pTypeDestination, MethWithInst mwiBest, Expr& ppTransformedArgument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ConstCastResult bindConstantCast(Expr exprSrc, CType typeDest, bool needExprDest, Expr& pexprDest, bool explicitConversion);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private int CompareSrcTypesBased(CType type1, bool fImplicit1, CType type2, bool fImplicit2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private int CompareDstTypesBased(CType type1, bool fImplicit1, CType type2, bool fImplicit2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr BindDecimalConstCast(CType destType, CType srcType, ExprConstant src);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool CanExplicitConversionBeBoundInUncheckedContext(Expr exprSrc, CType typeSrc, CType typeDest, CONVERTTYPE flags);
    [CompilerGeneratedAttribute]
public BindingContext get_Context();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static AggregateType GetPredefindType(PredefinedType pt);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateAssignmentConversion(Expr op1, Expr op2, bool allowExplicit);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr BindAssignment(Expr op1, Expr op2, bool allowExplicit);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindArrayIndexCore(Expr pOp1, Expr pOp2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private Expr MustConvertWithSuppressedMessage(Expr x, CType pDestType);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprCast ExprFactoryCreateCastWithSuppressedMessage(EXPRFLAG flags, CType type, Expr argument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void bindSimpleCast(Expr exprSrc, CType typeDest, Expr& pexprDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void bindSimpleCast(Expr exprSrc, CType typeDest, Expr& pexprDest, EXPRFLAG exprFlags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprCall BindToMethod(MethWithInst mwi, Expr pArguments, ExprMemberGroup pMemGroup, MemLookFlags flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr BindToField(Expr pOptionalObject, FieldWithType fwt, BindingFlag bindFlags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ExprProperty BindToProperty(Expr pObject, PropWithType pwt, BindingFlag bindFlags, Expr args, ExprMemberGroup pMemGroup);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal Expr bindUDUnop(ExpressionKind ek, Expr arg);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprCall BindLiftedUDUnop(Expr arg, CType typeArg, MethPropWithInst mpwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprCall BindUDUnopCall(Expr arg, CType typeArg, MethPropWithInst mpwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private GroupToArgsBinderResult BindMethodGroupToArgumentsCore(BindingFlag bindFlags, ExprMemberGroup grp, Expr args, int carg, NamedArgumentsKind namedArgumentsKind);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal ExprWithArgs BindMethodGroupToArguments(BindingFlag bindFlags, ExprMemberGroup grp, Expr args);
    private static NamedArgumentsKind FindNamedArgumentsType(Expr args);
    private static RuntimeBinderException BadOperatorTypesError(Expr pOperand1, Expr pOperand2);
    private static ErrorCode GetStandardLvalueError(CheckLvalueKind kind);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void CheckLvalueProp(ExprProperty prop);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void CheckPropertyAccess(MethWithType mwt, PropWithType pwtSlot, CType type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void CheckLvalue(Expr expr, CheckLvalueKind kind);
    private static void PostBindMethod(MethWithInst pMWI);
    private static void PostBindProperty(PropWithType pwt, MethWithType& pmwtGet, MethWithType& pmwtSet);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr AdjustMemberObject(SymWithType swt, Expr pObject);
    private static bool IsMatchingStatic(SymWithType swt, Expr pObject);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void verifyMethodArgs(ExprWithArgs call, CType callingObjectType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void AdjustCallArgumentsForParams(CType callingObjectType, CType type, MethodOrPropertySymbol mp, TypeArray pTypeArgs, Expr argsPtr, Expr& newArgs);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal CType ChooseArrayIndexType(Expr args);
    internal static void FillInArgInfoFromArgList(ArgInfos argInfo, Expr args);
    private static bool TryGetExpandedParams(TypeArray params, int count, TypeArray& ppExpandedParams);
    public static bool IsMethPropCallable(MethodOrPropertySymbol sym, bool requireUC);
    private static bool IsConvInTable(List`1<UdConvInfo> convTable, MethodSymbol meth, AggregateType ats, bool fSrc, bool fDst);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool isConstantInRange(ExprConstant exprSrc, CType typeDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool isConstantInRange(ExprConstant exprSrc, CType typeDest, bool realsOk);
    private static Name ExpressionKindName(ExpressionKind ek);
    private static void CheckUnsafe(CType type);
    private AggregateSymbol get_ContextForMemberLookup();
    private static ExprWrap WrapShortLivedExpression(Expr expr);
    private static ExprAssignment GenerateOptimizedAssignment(Expr op1, Expr op2);
    internal static int CountArguments(Expr args);
    private static bool IsNullableConstructor(Expr expr, ExprCall& call);
    private static Expr StripNullableConstructor(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr BindNubValue(Expr exprSrc);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprCall BindNubNew(Expr exprSrc);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprBinOp BindUserDefinedBinOp(ExpressionKind ek, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool GetSpecialBinopSignatures(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool GetStandardAndLiftedBinopSignatures(List`1<BinOpFullSig> rgbofs, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private int FindBestSignatureInList(List`1<BinOpFullSig> binopSignatures, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprBinOp BindNullEqualityComparison(ExpressionKind ek, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr BindStandardBinop(ExpressionKind ek, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindStandardBinopCore(BinOpArgInfo info, BinOpFullSig bofs, ExpressionKind ek, EXPRFLAG flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprBinOp BindLiftedStandardBinOp(BinOpArgInfo info, BinOpFullSig bofs, ExpressionKind ek, EXPRFLAG flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void LiftArgument(Expr pArgument, CType pParameterType, bool bConvertBeforeLift, Expr& ppLiftedArgument, Expr& ppNonLiftedArgument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool GetDelBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool CanConvertArg1(BinOpArgInfo info, CType typeDst, LiftFlags& pgrflt, CType& ptypeSig1, CType& ptypeSig2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool CanConvertArg2(BinOpArgInfo info, CType typeDst, LiftFlags& pgrflt, CType& ptypeSig1, CType& ptypeSig2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void RecordBinOpSigFromArgs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool GetEnumBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private static bool IsEnumArithmeticBinOp(ExpressionKind ek, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool GetRefEqualSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private int WhichBofsIsBetter(BinOpFullSig bofs1, BinOpFullSig bofs2, CType type1, CType type2);
    private static ValueTuple`3<ExpressionKind, UnaOpKind, EXPRFLAG> CalculateExprAndUnaryOpKinds(OperatorKind op, bool bChecked);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Expr BindStandardUnaryOperator(OperatorKind op, Expr pArgument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private UnaryOperatorSignatureFindResult PopulateSignatureList(Expr pArgument, UnaOpKind unaryOpKind, UnaOpMask unaryOpMask, ExpressionKind exprKind, EXPRFLAG flags, List`1<UnaOpFullSig> pSignatures, Expr& ppResult);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool FindApplicableSignatures(Expr pArgument, UnaOpMask unaryOpMask, List`1<UnaOpFullSig> pSignatures);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprOperator BindLiftedStandardUnop(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private int WhichUofsIsBetter(UnaOpFullSig uofs1, UnaOpFullSig uofs2, CType typeArg);
    private static ExprOperator BindIntBinOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static ExprOperator BindIntUnaOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private static ExprOperator BindRealBinOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG _, Expr arg1, Expr arg2);
    private static ExprOperator BindRealUnaOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG _, Expr arg);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindIncOp(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindIncOpCore(ExpressionKind ek, EXPRFLAG flags, Expr exprVal, CType type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr LScalar(ExpressionKind ek, EXPRFLAG flags, Expr exprVal, CType type, ConstVal cv, CType typeTmp);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprMulti BindNonliftedIncOp(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprMulti BindLiftedIncOp(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprBinOp BindDecBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprUnaryOp BindDecUnaOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private static Expr BindStrBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprBinOp BindShiftOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprBinOp BindBoolBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprOperator BindBoolBitwiseOp(ExpressionKind ek, EXPRFLAG flags, Expr expr1, Expr expr2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static Expr BindLiftedBoolBitwiseOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr expr1, Expr expr2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static Expr BindBoolUnaOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprBinOp BindStrCmpOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprBinOp BindRefCmpOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr BindDelBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr BindEnumBinOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindLiftedEnumArithmeticBinOp(ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr BindEnumUnaOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private ValueTuple`2<BinOpKind, EXPRFLAG> GetBinopKindAndFlags(ExpressionKind ek);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private ExprOperator BindIntOp(ExpressionKind kind, EXPRFLAG flags, Expr op1, Expr op2, PredefinedType ptOp);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private ExprOperator BindIntegerNeg(EXPRFLAG flags, Expr op, PredefinedType ptOp);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprOperator BindFloatOp(ExpressionKind kind, Expr op1, Expr op2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static ExprConcat BindStringConcat(Expr op1, Expr op2);
    private static RuntimeBinderException AmbiguousOperatorError(Expr op1, Expr op2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr BindUserBoolOp(ExpressionKind kind, ExprCall pCall);
    private static AggregateType GetUserDefinedBinopArgumentType(CType type);
    private static int GetUserDefinedBinopArgumentTypes(CType type1, CType type2, AggregateType[] rgats);
    private static bool UserDefinedBinaryOperatorCanBeLifted(ExpressionKind ek, MethodSymbol method, AggregateType ats, TypeArray Params);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool UserDefinedBinaryOperatorIsApplicable(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, MethodSymbol method, AggregateType ats, Expr arg1, Expr arg2, bool fDontLift);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool GetApplicableUserDefinedBinaryOperatorCandidates(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, AggregateType type, Expr arg1, Expr arg2, bool fDontLift);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private AggregateType GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, AggregateType type, Expr arg1, Expr arg2, bool fDontLift, AggregateType atsStop);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprCall BindUDBinop(ExpressionKind ek, Expr arg1, Expr arg2, bool fDontLift, MethPropWithInst& ppmpwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprCall BindUDBinopCall(Expr arg1, Expr arg2, TypeArray Params, CType typeRet, MethPropWithInst mpwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprCall BindLiftedUDBinop(ExpressionKind ek, Expr arg1, Expr arg2, TypeArray Params, MethPropWithInst mpwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static AggregateType GetEnumBinOpType(ExpressionKind ek, CType argType1, CType argType2, AggregateType& ppEnumType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprBinOp CreateBinopForPredefMethodCall(ExpressionKind ek, PREDEFMETH predefMeth, CType RetType, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprUnaryOp CreateUnaryOpForPredefMethodCall(ExpressionKind ek, PREDEFMETH predefMeth, CType pRetType, Expr pArg);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionIterator : object {
    private ExprList _pList;
    private Expr _pCurrent;
    public ExpressionIterator(Expr pExpr);
    public bool AtEnd();
    public Expr Current();
    public void MoveNext();
    public static int Count(Expr pExpr);
    private void Init(Expr pExpr);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionKind : Enum {
    public int value__;
    public static ExpressionKind NoOp;
    public static ExpressionKind BinaryOp;
    public static ExpressionKind UnaryOp;
    public static ExpressionKind Assignment;
    public static ExpressionKind List;
    public static ExpressionKind ArrayIndex;
    public static ExpressionKind Call;
    public static ExpressionKind Field;
    public static ExpressionKind Local;
    public static ExpressionKind Constant;
    public static ExpressionKind Class;
    public static ExpressionKind Property;
    public static ExpressionKind Multi;
    public static ExpressionKind MultiGet;
    public static ExpressionKind Wrap;
    public static ExpressionKind Concat;
    public static ExpressionKind ArrayInit;
    public static ExpressionKind Cast;
    public static ExpressionKind UserDefinedConversion;
    public static ExpressionKind TypeOf;
    public static ExpressionKind ZeroInit;
    public static ExpressionKind UserLogicalOp;
    public static ExpressionKind MemberGroup;
    public static ExpressionKind BoundLambda;
    public static ExpressionKind FieldInfo;
    public static ExpressionKind MethodInfo;
    public static ExpressionKind PropertyInfo;
    public static ExpressionKind NamedArgumentSpecification;
    public static ExpressionKind ExpressionKindCount;
    public static ExpressionKind EqualsParam;
    public static ExpressionKind FirstOp;
    public static ExpressionKind Compare;
    public static ExpressionKind True;
    public static ExpressionKind False;
    public static ExpressionKind Inc;
    public static ExpressionKind Dec;
    public static ExpressionKind LogicalNot;
    public static ExpressionKind Eq;
    public static ExpressionKind RelationalMin;
    public static ExpressionKind NotEq;
    public static ExpressionKind LessThan;
    public static ExpressionKind LessThanOrEqual;
    public static ExpressionKind GreaterThan;
    public static ExpressionKind GreaterThanOrEqual;
    public static ExpressionKind RelationalMax;
    public static ExpressionKind Add;
    public static ExpressionKind Subtract;
    public static ExpressionKind Multiply;
    public static ExpressionKind Divide;
    public static ExpressionKind Modulo;
    public static ExpressionKind Negate;
    public static ExpressionKind UnaryPlus;
    public static ExpressionKind BitwiseAnd;
    public static ExpressionKind BitwiseOr;
    public static ExpressionKind BitwiseExclusiveOr;
    public static ExpressionKind BitwiseNot;
    public static ExpressionKind LeftShirt;
    public static ExpressionKind RightShift;
    public static ExpressionKind LogicalAnd;
    public static ExpressionKind LogicalOr;
    public static ExpressionKind Sequence;
    public static ExpressionKind Save;
    public static ExpressionKind Swap;
    public static ExpressionKind Indir;
    public static ExpressionKind Addr;
    public static ExpressionKind StringEq;
    public static ExpressionKind StringNotEq;
    public static ExpressionKind DelegateEq;
    public static ExpressionKind DelegateNotEq;
    public static ExpressionKind DelegateAdd;
    public static ExpressionKind DelegateSubtract;
    public static ExpressionKind DecimalNegate;
    public static ExpressionKind DecimalInc;
    public static ExpressionKind DecimalDec;
    public static ExpressionKind MultiOffset;
    public static ExpressionKind TypeLimit;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionKindExtensions : object {
    [ExtensionAttribute]
public static bool IsRelational(ExpressionKind kind);
    [ExtensionAttribute]
public static bool IsUnaryOperator(ExpressionKind kind);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionTreeRewriter : ExprVisitorBase {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprBinOp Rewrite(ExprBoundLambda expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr Dispatch(Expr expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitASSIGNMENT(ExprAssignment assignment);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMULTIGET(ExprMultiGet pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMULTI(ExprMulti pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private ExprBinOp VisitBoundLambda(ExprBoundLambda anonmeth);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCONSTANT(ExprConstant expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLOCAL(ExprLocal local);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitFIELD(ExprField expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitUSERDEFINEDCONVERSION(ExprUserDefinedConversion expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCAST(ExprCast pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCONCAT(ExprConcat expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitBINOP(ExprBinOp expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitUNARYOP(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitARRAYINDEX(ExprArrayIndex pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCALL(ExprCall expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitPROP(ExprProperty expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitARRINIT(ExprArrayInit expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitZEROINIT(ExprZeroInit expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitTYPEOF(ExprTypeOf expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateDelegateInvoke(ExprCall expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateBuiltInBinaryOperator(ExprBinOp expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateBuiltInUnaryOperator(ExprUnaryOp expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateUserDefinedBinaryOperator(ExprBinOp expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateUserDefinedUnaryOperator(ExprUnaryOp expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateUserDefinedComparisonOperator(ExprBinOp expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateConversion(Expr arg, CType CType, bool bChecked);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr GenerateConversionWithSource(Expr pTarget, CType pType, bool bChecked);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateValueAccessConversion(Expr pArgument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateUserDefinedConversion(Expr arg, CType type, MethWithInst method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr GenerateUserDefinedConversion(Expr arg, CType CType, Expr target, MethWithInst method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateUserDefinedConversion(ExprUserDefinedConversion pExpr, Expr pArgument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr GenerateParameter(string name, CType CType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static MethodSymbol GetPreDefMethod(PREDEFMETH pdm);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprTypeOf CreateTypeOf(CType type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr CreateWraps(ExprBoundLambda anonmeth);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateConstructor(ExprCall expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateArgsList(Expr oldArgs);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private Expr GenerateIndexList(Expr oldIndices);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static Expr GenerateConstant(Expr expr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1, Expr arg2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1, Expr arg2, Expr arg3);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1, Expr arg2, Expr arg3, Expr arg4);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static ExprArrayInit GenerateParamsArray(Expr args, PredefinedType pt);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void FixLiftedUserDefinedBinaryOperators(ExprBinOp expr, Expr& pp1, Expr& pp2);
    private static bool IsNullableValueType(CType pType);
    private static bool IsNullableValueAccess(Expr pExpr, Expr pObject);
    private static bool isEnumToDecimalConversion(CType argtype, CType desttype);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRExtensions : object {
    [ExtensionAttribute]
public static Expr Map(Expr expr, Func`2<Expr, Expr> f);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.EXPRExtensions/<ToEnumerable>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<Expr> ToEnumerable(Expr expr);
    [ExtensionAttribute]
public static bool isLvalue(Expr expr);
    [ExtensionAttribute]
public static bool isChecked(Expr expr);
    [ExtensionAttribute]
public static bool isNull(Expr expr);
    [ExtensionAttribute]
public static bool IsZero(Expr expr);
    [ExtensionAttribute]
private static Expr GetSeqVal(Expr expr);
    [ExtensionAttribute]
public static Expr GetConst(Expr expr);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ExprFactory : object {
    public static ExprCall CreateCall(EXPRFLAG flags, CType type, Expr arguments, ExprMemberGroup memberGroup, MethWithInst method);
    public static ExprField CreateField(CType type, Expr optionalObject, FieldWithType field);
    public static ExprArrayInit CreateArrayInit(CType type, Expr arguments, Expr argumentDimensions, Int32[] dimSizes);
    public static ExprProperty CreateProperty(CType type, Expr optionalObjectThrough, Expr arguments, ExprMemberGroup memberGroup, PropWithType property, MethWithType setMethod);
    public static ExprMemberGroup CreateMemGroup(EXPRFLAG flags, Name name, TypeArray typeArgs, SYMKIND symKind, CType parentType, Expr obj, CMemberLookupResults memberLookupResults);
    public static ExprMemberGroup CreateMemGroup(Expr obj, MethPropWithInst method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprUserDefinedConversion CreateUserDefinedConversion(Expr arg, Expr call, MethWithInst method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprCast CreateCast(CType type, Expr argument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprCast CreateCast(EXPRFLAG flags, CType type, Expr argument);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprLocal CreateLocal(LocalVariableSymbol local);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprBoundLambda CreateAnonymousMethod(AggregateType delegateType, Scope argumentScope, Expr expression);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprMethodInfo CreateMethodInfo(MethPropWithInst mwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprMethodInfo CreateMethodInfo(MethodSymbol method, AggregateType methodType, TypeArray methodParameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprPropertyInfo CreatePropertyInfo(PropertySymbol prop, AggregateType propertyType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprFieldInfo CreateFieldInfo(FieldSymbol field, AggregateType fieldType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprTypeOf CreateTypeOf(CType sourceType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprUserLogicalOp CreateUserLogOp(CType type, Expr trueFalseCall, ExprCall operatorCall);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprConcat CreateConcat(Expr first, Expr second);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprConstant CreateStringConstant(string str);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprMultiGet CreateMultiGet(EXPRFLAG flags, CType type, ExprMulti multi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprMulti CreateMulti(EXPRFLAG flags, CType type, Expr left, Expr op);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static Expr CreateZeroInit(CType type);
    public static ExprConstant CreateConstant(CType type, ConstVal constVal);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprConstant CreateIntegerConstant(int x);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static ExprConstant CreateBoolConstant(bool b);
    public static ExprArrayIndex CreateArrayIndex(CType type, Expr array, Expr index);
    public static ExprBinOp CreateBinop(ExpressionKind exprKind, CType type, Expr left, Expr right);
    public static ExprUnaryOp CreateUnaryOp(ExpressionKind exprKind, CType type, Expr operand);
    public static ExprOperator CreateOperator(ExpressionKind exprKind, CType type, Expr arg1, Expr arg2);
    public static ExprBinOp CreateUserDefinedBinop(ExpressionKind exprKind, CType type, Expr left, Expr right, Expr call, MethPropWithInst userMethod);
    public static ExprUnaryOp CreateUserDefinedUnaryOperator(ExpressionKind exprKind, CType type, Expr operand, ExprCall call, MethPropWithInst userMethod);
    public static ExprUnaryOp CreateNeg(EXPRFLAG flags, Expr operand);
    public static ExprBinOp CreateSequence(Expr first, Expr second);
    public static ExprAssignment CreateAssignment(Expr left, Expr right);
    public static ExprNamedArgumentSpecification CreateNamedArgumentSpecification(Name name, Expr value);
    public static ExprWrap CreateWrap(Expr expression);
    public static ExprBinOp CreateSave(ExprWrap wrap);
    public static ExprConstant CreateNull();
    public static void AppendItemToList(Expr newItem, Expr& first, Expr& last);
    public static ExprList CreateList(Expr op1, Expr op2);
    public static ExprList CreateList(Expr op1, Expr op2, Expr op3);
    public static ExprList CreateList(Expr op1, Expr op2, Expr op3, Expr op4);
    public static ExprClass CreateClass(CType type);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprField : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldWithType <FieldWithType>k__BackingField;
    public Expr OptionalObject { get; public set; }
    public FieldWithType FieldWithType { get; }
    public ExprField(CType type, Expr optionalObject, FieldWithType field);
    [CompilerGeneratedAttribute]
public Expr get_OptionalObject();
    [CompilerGeneratedAttribute]
public void set_OptionalObject(Expr value);
    [CompilerGeneratedAttribute]
public FieldWithType get_FieldWithType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprFieldInfo : ExprWithType {
    [CompilerGeneratedAttribute]
private FieldSymbol <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateType <FieldType>k__BackingField;
    public FieldSymbol Field { get; }
    public AggregateType FieldType { get; }
    public ExprFieldInfo(FieldSymbol field, AggregateType fieldType, CType type);
    [CompilerGeneratedAttribute]
public FieldSymbol get_Field();
    [CompilerGeneratedAttribute]
public AggregateType get_FieldType();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.EXPRFLAG : Enum {
    public int value__;
    public static EXPRFLAG EXF_BINOP;
    public static EXPRFLAG EXF_CTOR;
    public static EXPRFLAG EXF_NEEDSRET;
    public static EXPRFLAG EXF_ASLEAVE;
    public static EXPRFLAG EXF_ISFAULT;
    public static EXPRFLAG EXF_HASHTABLESWITCH;
    public static EXPRFLAG EXF_BOX;
    public static EXPRFLAG EXF_ARRAYCONST;
    public static EXPRFLAG EXF_MEMBERSET;
    public static EXPRFLAG EXF_OPENTYPE;
    public static EXPRFLAG EXF_LABELREFERENCED;
    public static EXPRFLAG EXF_GENERATEDQMARK;
    public static EXPRFLAG EXF_INDEXER;
    public static EXPRFLAG EXF_GOTOCASE;
    public static EXPRFLAG EXF_REMOVEFINALLY;
    public static EXPRFLAG EXF_UNBOX;
    public static EXPRFLAG EXF_ARRAYALLCONST;
    public static EXPRFLAG EXF_CTORPREAMBLE;
    public static EXPRFLAG EXF_USERLABEL;
    public static EXPRFLAG EXF_OPERATOR;
    public static EXPRFLAG EXF_ISPOSTOP;
    public static EXPRFLAG EXF_FINALLYBLOCKED;
    public static EXPRFLAG EXF_REFCHECK;
    public static EXPRFLAG EXF_WRAPASTEMP;
    public static EXPRFLAG EXF_LITERALCONST;
    public static EXPRFLAG EXF_BADGOTO;
    public static EXPRFLAG EXF_RETURNISYIELD;
    public static EXPRFLAG EXF_ISFINALLY;
    public static EXPRFLAG EXF_NEWOBJCALL;
    public static EXPRFLAG EXF_INDEXEXPR;
    public static EXPRFLAG EXF_REPLACEWRAP;
    public static EXPRFLAG EXF_UNREALIZEDGOTO;
    public static EXPRFLAG EXF_CONSTRAINED;
    public static EXPRFLAG EXF_FORCE_BOX;
    public static EXPRFLAG EXF_SIMPLENAME;
    public static EXPRFLAG EXF_ASFINALLYLEAVE;
    public static EXPRFLAG EXF_BASECALL;
    public static EXPRFLAG EXF_FORCE_UNBOX;
    public static EXPRFLAG EXF_ADDRNOCONV;
    public static EXPRFLAG EXF_GOTONOTBLOCKED;
    public static EXPRFLAG EXF_DELEGATE;
    public static EXPRFLAG EXF_STATIC_CAST;
    public static EXPRFLAG EXF_USERCALLABLE;
    public static EXPRFLAG EXF_UNBOXRUNTIME;
    public static EXPRFLAG EXF_NEWSTRUCTASSG;
    public static EXPRFLAG EXF_GENERATEDSTMT;
    public static EXPRFLAG EXF_IMPLICITSTRUCTASSG;
    public static EXPRFLAG EXF_MARKING;
    public static EXPRFLAG EXF_UNREACHABLEBEGIN;
    public static EXPRFLAG EXF_UNREACHABLEEND;
    public static EXPRFLAG EXF_USEORIGDEBUGINFO;
    public static EXPRFLAG EXF_LASTBRACEDEBUGINFO;
    public static EXPRFLAG EXF_NODEBUGINFO;
    public static EXPRFLAG EXF_IMPLICITTHIS;
    public static EXPRFLAG EXF_CANTBENULL;
    public static EXPRFLAG EXF_CHECKOVERFLOW;
    public static EXPRFLAG EXF_PUSH_OP_FIRST;
    public static EXPRFLAG EXF_ASSGOP;
    public static EXPRFLAG EXF_LVALUE;
    public static EXPRFLAG EXF_SAMENAMETYPE;
    public static EXPRFLAG EXF_MASK_ANY;
    public static EXPRFLAG EXF_CAST_ALL;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprList : Expr {
    [CompilerGeneratedAttribute]
private Expr <OptionalElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalNextListNode>k__BackingField;
    public Expr OptionalElement { get; public set; }
    public Expr OptionalNextListNode { get; public set; }
    public ExprList(Expr optionalElement, Expr optionalNextListNode);
    [CompilerGeneratedAttribute]
public Expr get_OptionalElement();
    [CompilerGeneratedAttribute]
public void set_OptionalElement(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalNextListNode();
    [CompilerGeneratedAttribute]
public void set_OptionalNextListNode(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprLocal : Expr {
    [CompilerGeneratedAttribute]
private LocalVariableSymbol <Local>k__BackingField;
    public LocalVariableSymbol Local { get; }
    public ExprLocal(LocalVariableSymbol local);
    [CompilerGeneratedAttribute]
public LocalVariableSymbol get_Local();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMemberGroup : ExprWithType {
    [CompilerGeneratedAttribute]
private Name <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private SYMKIND <SymKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private CMemberLookupResults <MemberLookupResults>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <ParentType>k__BackingField;
    public Name Name { get; }
    public TypeArray TypeArgs { get; }
    public SYMKIND SymKind { get; }
    public Expr OptionalObject { get; public set; }
    public CMemberLookupResults MemberLookupResults { get; }
    public CType ParentType { get; }
    public bool IsDelegate { get; }
    public ExprMemberGroup(EXPRFLAG flags, Name name, TypeArray typeArgs, SYMKIND symKind, CType parentType, Expr optionalObject, CMemberLookupResults memberLookupResults);
    [CompilerGeneratedAttribute]
public Name get_Name();
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgs();
    [CompilerGeneratedAttribute]
public SYMKIND get_SymKind();
    [CompilerGeneratedAttribute]
public Expr get_OptionalObject();
    [CompilerGeneratedAttribute]
public void set_OptionalObject(Expr value);
    [CompilerGeneratedAttribute]
public CMemberLookupResults get_MemberLookupResults();
    [CompilerGeneratedAttribute]
public CType get_ParentType();
    public bool get_IsDelegate();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMethodInfo : ExprWithType {
    [CompilerGeneratedAttribute]
private MethWithInst <Method>k__BackingField;
    public MethWithInst Method { get; }
    public MethodInfo MethodInfo { get; }
    public ConstructorInfo ConstructorInfo { get; }
    public object Object { get; }
    public ExprMethodInfo(CType type, MethodSymbol method, AggregateType methodType, TypeArray methodParameters);
    [CompilerGeneratedAttribute]
public MethWithInst get_Method();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public MethodInfo get_MethodInfo();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public ConstructorInfo get_ConstructorInfo();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMulti : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <Operator>k__BackingField;
    public Expr Left { get; public set; }
    public Expr Operator { get; public set; }
    public ExprMulti(CType type, EXPRFLAG flags, Expr left, Expr op);
    [CompilerGeneratedAttribute]
public Expr get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMultiGet : ExprWithType {
    [CompilerGeneratedAttribute]
private ExprMulti <OptionalMulti>k__BackingField;
    public ExprMulti OptionalMulti { get; public set; }
    public ExprMultiGet(CType type, EXPRFLAG flags, ExprMulti multi);
    [CompilerGeneratedAttribute]
public ExprMulti get_OptionalMulti();
    [CompilerGeneratedAttribute]
public void set_OptionalMulti(ExprMulti value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprNamedArgumentSpecification : Expr {
    private Expr _value;
    [CompilerGeneratedAttribute]
private Name <Name>k__BackingField;
    public Name Name { get; }
    public Expr Value { get; public set; }
    public ExprNamedArgumentSpecification(Name name, Expr value);
    [CompilerGeneratedAttribute]
public Name get_Name();
    public Expr get_Value();
    public void set_Value(Expr value);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprOperator : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalUserDefinedCall>k__BackingField;
    [CompilerGeneratedAttribute]
private MethWithInst <PredefinedMethodToCall>k__BackingField;
    [CompilerGeneratedAttribute]
private MethPropWithInst <UserDefinedCallMethod>k__BackingField;
    public Expr OptionalUserDefinedCall { get; }
    public MethWithInst PredefinedMethodToCall { get; public set; }
    public MethPropWithInst UserDefinedCallMethod { get; public set; }
    protected ExprOperator(ExpressionKind kind, CType type);
    protected ExprOperator(ExpressionKind kind, CType type, Expr call, MethPropWithInst userDefinedMethod);
    [CompilerGeneratedAttribute]
public Expr get_OptionalUserDefinedCall();
    [CompilerGeneratedAttribute]
public MethWithInst get_PredefinedMethodToCall();
    [CompilerGeneratedAttribute]
public void set_PredefinedMethodToCall(MethWithInst value);
    [CompilerGeneratedAttribute]
public MethPropWithInst get_UserDefinedCallMethod();
    [CompilerGeneratedAttribute]
public void set_UserDefinedCallMethod(MethPropWithInst value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprProperty : ExprWithArgs {
    [CompilerGeneratedAttribute]
private Expr <OptionalObjectThrough>k__BackingField;
    [CompilerGeneratedAttribute]
private PropWithType <PropWithTypeSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private MethWithType <MethWithTypeSet>k__BackingField;
    public Expr OptionalObjectThrough { get; }
    public PropWithType PropWithTypeSlot { get; }
    public MethWithType MethWithTypeSet { get; }
    public ExprProperty(CType type, Expr pOptionalObjectThrough, Expr pOptionalArguments, ExprMemberGroup pMemberGroup, PropWithType pwtSlot, MethWithType mwtSet);
    [CompilerGeneratedAttribute]
public Expr get_OptionalObjectThrough();
    [CompilerGeneratedAttribute]
public PropWithType get_PropWithTypeSlot();
    [CompilerGeneratedAttribute]
public MethWithType get_MethWithTypeSet();
    public virtual SymWithType GetSymWithType();
    internal static bool HasIsExternalInitModifier(MethWithType mwtSet);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprPropertyInfo : ExprWithType {
    [CompilerGeneratedAttribute]
private PropWithType <Property>k__BackingField;
    public PropWithType Property { get; }
    public PropertyInfo PropertyInfo { get; }
    public ExprPropertyInfo(CType type, PropertySymbol propertySymbol, AggregateType propertyType);
    [CompilerGeneratedAttribute]
public PropWithType get_Property();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public PropertyInfo get_PropertyInfo();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprTypeOf : ExprWithType {
    [CompilerGeneratedAttribute]
private CType <SourceType>k__BackingField;
    public CType SourceType { get; }
    public object Object { get; }
    public ExprTypeOf(CType type, CType sourceType);
    [CompilerGeneratedAttribute]
public CType get_SourceType();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprUnaryOp : ExprOperator {
    [CompilerGeneratedAttribute]
private Expr <Child>k__BackingField;
    public Expr Child { get; public set; }
    public ExprUnaryOp(ExpressionKind kind, CType type, Expr operand);
    public ExprUnaryOp(ExpressionKind kind, CType type, Expr operand, Expr call, MethPropWithInst userMethod);
    [CompilerGeneratedAttribute]
public Expr get_Child();
    [CompilerGeneratedAttribute]
public void set_Child(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprUserDefinedConversion : Expr {
    private Expr _userDefinedCall;
    [CompilerGeneratedAttribute]
private Expr <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private MethWithInst <UserDefinedCallMethod>k__BackingField;
    public Expr Argument { get; public set; }
    public Expr UserDefinedCall { get; public set; }
    public MethWithInst UserDefinedCallMethod { get; }
    public ExprUserDefinedConversion(Expr argument, Expr call, MethWithInst method);
    [CompilerGeneratedAttribute]
public Expr get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(Expr value);
    public Expr get_UserDefinedCall();
    public void set_UserDefinedCall(Expr value);
    [CompilerGeneratedAttribute]
public MethWithInst get_UserDefinedCallMethod();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprUserLogicalOp : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <TrueFalseCall>k__BackingField;
    [CompilerGeneratedAttribute]
private ExprCall <OperatorCall>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <FirstOperandToExamine>k__BackingField;
    public Expr TrueFalseCall { get; public set; }
    public ExprCall OperatorCall { get; public set; }
    public Expr FirstOperandToExamine { get; public set; }
    public ExprUserLogicalOp(CType type, Expr trueFalseCall, ExprCall operatorCall);
    [CompilerGeneratedAttribute]
public Expr get_TrueFalseCall();
    [CompilerGeneratedAttribute]
public void set_TrueFalseCall(Expr value);
    [CompilerGeneratedAttribute]
public ExprCall get_OperatorCall();
    [CompilerGeneratedAttribute]
public void set_OperatorCall(ExprCall value);
    [CompilerGeneratedAttribute]
public Expr get_FirstOperandToExamine();
    [CompilerGeneratedAttribute]
public void set_FirstOperandToExamine(Expr value);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprVisitorBase : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected Expr Visit(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr Dispatch(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void VisitChildren(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitEXPR(Expr pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitBINOP(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLIST(ExprList pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitASSIGNMENT(ExprAssignment pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitARRAYINDEX(ExprArrayIndex pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitUNARYOP(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitUSERLOGOP(ExprUserLogicalOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitTYPEOF(ExprTypeOf pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCAST(ExprCast pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitUSERDEFINEDCONVERSION(ExprUserDefinedConversion pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitZEROINIT(ExprZeroInit pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMEMGRP(ExprMemberGroup pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCALL(ExprCall pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitPROP(ExprProperty pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitFIELD(ExprField pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLOCAL(ExprLocal pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCONSTANT(ExprConstant pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMULTIGET(ExprMultiGet pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMULTI(ExprMulti pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitWRAP(ExprWrap pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCONCAT(ExprConcat pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitARRINIT(ExprArrayInit pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitFIELDINFO(ExprFieldInfo pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMETHODINFO(ExprMethodInfo pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitEQUALS(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitCOMPARE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitEQ(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitNE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitGE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitADD(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSUB(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDIV(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitBITAND(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitBITOR(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLSHIFT(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLOGAND(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSEQUENCE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSAVE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitINDIR(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSTRINGEQ(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDELEGATEEQ(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDELEGATEADD(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLT(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMUL(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitBITXOR(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitRSHIFT(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLOGOR(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSTRINGNE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDELEGATENE(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitGT(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitMOD(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitSWAP(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDELEGATESUB(ExprBinOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitTRUE(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitINC(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitLOGNOT(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitNEG(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitBITNOT(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitADDR(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDECIMALNEG(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDECIMALDEC(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitFALSE(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDEC(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitUPLUS(ExprUnaryOp pExpr);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
protected virtual Expr VisitDECIMALINC(ExprUnaryOp pExpr);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprWithArgs : ExprWithType {
    [CompilerGeneratedAttribute]
private ExprMemberGroup <MemberGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalArguments>k__BackingField;
    public ExprMemberGroup MemberGroup { get; public set; }
    public Expr OptionalArguments { get; public set; }
    protected ExprWithArgs(ExpressionKind kind, CType type);
    [CompilerGeneratedAttribute]
public ExprMemberGroup get_MemberGroup();
    [CompilerGeneratedAttribute]
public void set_MemberGroup(ExprMemberGroup value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalArguments();
    [CompilerGeneratedAttribute]
public void set_OptionalArguments(Expr value);
    public abstract virtual SymWithType GetSymWithType();
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprWithType : Expr {
    protected ExprWithType(ExpressionKind kind, CType type);
    protected static bool TypesAreEqual(Type t1, Type t2);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprWrap : Expr {
    [CompilerGeneratedAttribute]
private Expr <OptionalExpression>k__BackingField;
    public Expr OptionalExpression { get; }
    public ExprWrap(Expr expression);
    [CompilerGeneratedAttribute]
public Expr get_OptionalExpression();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprZeroInit : ExprWithType {
    public object Object { get; }
    public ExprZeroInit(CType type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FieldSymbol : VariableSymbol {
    public bool isStatic;
    public bool isReadOnly;
    public bool isEvent;
    public FieldInfo AssociatedFieldInfo;
    public void SetType(CType pType);
    public CType GetType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FieldWithType : SymWithType {
    public FieldWithType(FieldSymbol field, AggregateType ats);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.FUNDTYPE : Enum {
    public int value__;
    public static FUNDTYPE FT_NONE;
    public static FUNDTYPE FT_I1;
    public static FUNDTYPE FT_I2;
    public static FUNDTYPE FT_I4;
    public static FUNDTYPE FT_U1;
    public static FUNDTYPE FT_U2;
    public static FUNDTYPE FT_U4;
    public static FUNDTYPE FT_LASTNONLONG;
    public static FUNDTYPE FT_I8;
    public static FUNDTYPE FT_U8;
    public static FUNDTYPE FT_LASTINTEGRAL;
    public static FUNDTYPE FT_R4;
    public static FUNDTYPE FT_R8;
    public static FUNDTYPE FT_LASTNUMERIC;
    public static FUNDTYPE FT_REF;
    public static FUNDTYPE FT_STRUCT;
    public static FUNDTYPE FT_PTR;
    public static FUNDTYPE FT_VAR;
    public static FUNDTYPE FT_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.IndexerSymbol : PropertySymbol {
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.LiftFlags : Enum {
    public int value__;
    public static LiftFlags None;
    public static LiftFlags Lift1;
    public static LiftFlags Lift2;
    public static LiftFlags Convert1;
    public static LiftFlags Convert2;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ListExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> list);
    [ExtensionAttribute]
public static T Head(List`1<T> list);
    [ExtensionAttribute]
public static List`1<T> Tail(List`1<T> list);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.LocalVariableSymbol : VariableSymbol {
    public ExprWrap wrap;
    public void SetType(CType pType);
    public CType GetType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MemberLookup : object {
    private CType _typeSrc;
    private CType _typeQual;
    private ParentSymbol _symWhere;
    private Name _name;
    private int _arity;
    private MemLookFlags _flags;
    private List`1<AggregateType> _rgtypeStart;
    private List`1<AggregateType> _prgtype;
    private int _csym;
    private SymWithType _swtFirst;
    private List`1<MethPropWithType> _methPropWithTypeList;
    private SymWithType _swtAmbig;
    private SymWithType _swtInaccess;
    private SymWithType _swtBad;
    private SymWithType _swtBogus;
    private SymWithType _swtBadArity;
    private bool _fMulti;
    private void RecordType(AggregateType type, Symbol sym);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool SearchSingleType(AggregateType typeCur, Boolean& pfHideByName);
    private static bool IsDynamicMember(Symbol sym);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool LookupInClass(AggregateType typeStart, AggregateType& ptypeEnd);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool LookupInInterfaces(AggregateType typeStart, TypeArray types);
    private static RuntimeBinderException ReportBogus(SymWithType swt);
    private static bool IsDelegateType(CType pSrcType, AggregateType pAggType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public bool Lookup(CType typeSrc, Expr obj, ParentSymbol symWhere, Name name, int arity, MemLookFlags flags);
    private bool FError();
    public SymWithType SwtFirst();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public Exception ReportErrors();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MemLookFlags : Enum {
    public UInt32 value__;
    public static MemLookFlags None;
    public static MemLookFlags Ctor;
    public static MemLookFlags NewObj;
    public static MemLookFlags Operator;
    public static MemLookFlags Indexer;
    public static MemLookFlags UserCallable;
    public static MemLookFlags BaseCall;
    public static MemLookFlags MustBeInvocable;
    public static MemLookFlags All;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodCallingConventionEnum : Enum {
    public int value__;
    public static MethodCallingConventionEnum Static;
    public static MethodCallingConventionEnum Virtual;
    public static MethodCallingConventionEnum Instance;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodGroupType : CType {
    public static MethodGroupType Instance;
    private static MethodGroupType();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodKindEnum : Enum {
    public int value__;
    public static MethodKindEnum None;
    public static MethodKindEnum Constructor;
    public static MethodKindEnum Destructor;
    public static MethodKindEnum PropAccessor;
    public static MethodKindEnum EventAccessor;
    public static MethodKindEnum ExplicitConv;
    public static MethodKindEnum ImplicitConv;
    public static MethodKindEnum Anonymous;
    public static MethodKindEnum Invoke;
    public static MethodKindEnum BeginInvoke;
    public static MethodKindEnum EndInvoke;
    public static MethodKindEnum AnonymousTypeToString;
    public static MethodKindEnum AnonymousTypeEquals;
    public static MethodKindEnum AnonymousTypeGetHashCode;
    public static MethodKindEnum IteratorDispose;
    public static MethodKindEnum IteratorReset;
    public static MethodKindEnum IteratorGetEnumerator;
    public static MethodKindEnum IteratorGetEnumeratorDelegating;
    public static MethodKindEnum IteratorMoveNext;
    public static MethodKindEnum Latent;
    public static MethodKindEnum Actual;
    public static MethodKindEnum IteratorFinally;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.MethodOrPropertySymbol : ParentSymbol {
    public UInt32 modOptCount;
    public bool isStatic;
    public bool isOverride;
    public bool isOperator;
    public bool isParamArray;
    public bool isHideByName;
    [CompilerGeneratedAttribute]
private List`1<Name> <ParameterNames>k__BackingField;
    private Boolean[] _optionalParameterIndex;
    private Boolean[] _defaultParameterIndex;
    private ConstVal[] _defaultParameters;
    private CType[] _defaultParameterConstValTypes;
    private Boolean[] _marshalAsIndex;
    private UnmanagedType[] _marshalAsBuffer;
    public SymWithType swtSlot;
    public CType RetType;
    private TypeArray _Params;
    public List`1<Name> ParameterNames { get; private set; }
    public TypeArray Params { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Name> get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(List`1<Name> value);
    public TypeArray get_Params();
    public void set_Params(TypeArray value);
    public bool IsParameterOptional(int index);
    public void SetOptionalParameter(int index);
    public bool HasOptionalParameters();
    public bool HasDefaultParameterValue(int index);
    public void SetDefaultParameterValue(int index, CType type, ConstVal cv);
    public ConstVal GetDefaultParameterValue(int index);
    public CType GetDefaultParameterValueConstValType(int index);
    private bool IsMarshalAsParameter(int index);
    public void SetMarshalAsParameter(int index, UnmanagedType umt);
    private UnmanagedType GetMarshalAsParameterValue(int index);
    public bool MarshalAsObject(int index);
    public AggregateSymbol getClass();
    public bool IsExpImpl();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodSignatureEnum : Enum {
    public int value__;
    public static MethodSignatureEnum SIG_CLASS_TYVAR;
    public static MethodSignatureEnum SIG_METH_TYVAR;
    public static MethodSignatureEnum SIG_SZ_ARRAY;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodSymbol : MethodOrPropertySymbol {
    private MethodKindEnum _methKind;
    private bool _inferenceMustFail;
    private bool _checkedInfMustFail;
    private MethodSymbol _convNext;
    private PropertySymbol _prop;
    private EventSymbol _evt;
    public bool isVirtual;
    public MemberInfo AssociatedMemberInfo;
    public TypeArray typeVars;
    public MethodKindEnum MethKind { get; }
    public bool InferenceMustFail();
    public MethodKindEnum get_MethKind();
    public bool IsConstructor();
    public bool IsNullableConstructor();
    public bool isPropertyAccessor();
    public bool isEventAccessor();
    public bool isImplicit();
    public void SetMethKind(MethodKindEnum mk);
    public MethodSymbol ConvNext();
    public void SetConvNext(MethodSymbol conv);
    public PropertySymbol getProperty();
    public void SetProperty(PropertySymbol prop);
    public EventSymbol getEvent();
    public void SetEvent(EventSymbol evt);
    public bool isUserCallable();
    private bool isAnyAccessor();
    public bool isSetAccessor();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodTypeInferrer : object {
    private ExpressionBinder _binder;
    private TypeArray _pMethodTypeParameters;
    private TypeArray _pMethodFormalParameterTypes;
    private ArgInfos _pMethodArguments;
    private List`1[] _pExactBounds;
    private List`1[] _pUpperBounds;
    private List`1[] _pLowerBounds;
    private CType[] _pFixedResults;
    private Dependency[][] _ppDependencies;
    private bool _dependenciesDirty;
    private MethodTypeInferrer(ExpressionBinder exprBinder, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments, TypeArray pMethodTypeParameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool Infer(ExpressionBinder binder, MethodSymbol pMethod, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments, TypeArray& ppInferredTypeArguments);
    private TypeArray GetResults();
    private bool IsUnfixed(int iParam);
    private bool IsUnfixed(TypeParameterType pParam);
    private bool AllFixed();
    private void AddLowerBound(TypeParameterType pParam, CType pBound);
    private void AddUpperBound(TypeParameterType pParam, CType pBound);
    private void AddExactBound(TypeParameterType pParam, CType pBound);
    private bool HasBound(int iParam);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool InferTypeArgs();
    private static bool IsReallyAType(CType pType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void InferTypeArgsFirstPhase();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool InferTypeArgsSecondPhase();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private NewInferenceResult DoSecondPhase();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private NewInferenceResult FixNondependentParameters();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private NewInferenceResult FixDependentParameters();
    private void InitializeDependencies();
    private bool DependsOn(int iParam, int jParam);
    private bool DependsTransitivelyOn(int iParam, int jParam);
    private void DeduceAllDependencies();
    private bool DeduceDependencies();
    private void SetUnknownsToNotDependent();
    private void SetIndirectsToUnknown();
    private void UpdateDependenciesAfterFix(int iParam);
    private bool DependsOnAny(int iParam);
    private bool AnyDependsOn(int iParam);
    private void ExactInference(CType pSource, CType pDest);
    private bool ExactTypeParameterInference(CType pSource, CType pDest);
    private bool ExactArrayInference(CType pSource, CType pDest);
    private bool ExactNullableInference(CType pSource, CType pDest);
    private bool ExactConstructedInference(CType pSource, CType pDest);
    private void ExactTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void LowerBoundInference(CType pSource, CType pDest);
    private bool LowerBoundTypeParameterInference(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool LowerBoundArrayInference(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool LowerBoundConstructedInference(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool LowerBoundClassInference(CType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool LowerBoundInterfaceInference(CType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void LowerBoundTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void UpperBoundInference(CType pSource, CType pDest);
    private bool UpperBoundTypeParameterInference(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool UpperBoundArrayInference(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool UpperBoundConstructedInference(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool UpperBoundClassInference(AggregateType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool UpperBoundInterfaceInference(AggregateType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private void UpperBoundTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private bool Fix(int iParam);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethPropWithInst : MethPropWithType {
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgs>k__BackingField;
    public TypeArray TypeArgs { get; private set; }
    public MethPropWithInst(MethodOrPropertySymbol mps, AggregateType ats);
    public MethPropWithInst(MethodOrPropertySymbol mps, AggregateType ats, TypeArray typeArgs);
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgs();
    [CompilerGeneratedAttribute]
private void set_TypeArgs(TypeArray value);
    public virtual void Clear();
    public void Set(MethodOrPropertySymbol mps, AggregateType ats, TypeArray typeArgs);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethPropWithType : SymWithType {
    public MethPropWithType(MethodOrPropertySymbol mps, AggregateType ats);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethWithInst : MethPropWithInst {
    public MethWithInst(MethodSymbol meth, AggregateType ats);
    public MethWithInst(MethodSymbol meth, AggregateType ats, TypeArray typeArgs);
    public MethWithInst(MethPropWithInst mpwi);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethWithType : MethPropWithType {
    public MethWithType(MethodSymbol meth, AggregateType ats);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceOrAggregateSymbol : ParentSymbol {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceSymbol : NamespaceOrAggregateSymbol {
    public static NamespaceSymbol Root;
    private static NamespaceSymbol();
    private static NamespaceSymbol GetRootNamespaceSymbol();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.NullableCallLiftKind : Enum {
    public int value__;
    public static NullableCallLiftKind NotLifted;
    public static NullableCallLiftKind Operator;
    public static NullableCallLiftKind EqualityOperator;
    public static NullableCallLiftKind InequalityOperator;
    public static NullableCallLiftKind UserDefinedConversion;
    public static NullableCallLiftKind NullableConversion;
    public static NullableCallLiftKind NullableConversionConstructor;
    public static NullableCallLiftKind NullableIntermediateConversion;
    public static NullableCallLiftKind NotLiftedIntermediateConversion;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NullableType : CType {
    private AggregateType _ats;
    [CompilerGeneratedAttribute]
private CType <UnderlyingType>k__BackingField;
    public CType UnderlyingType { get; }
    public bool IsValueType { get; }
    public bool IsStructType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    [ExcludeFromCodeCoverageAttribute]
public ConstValKind ConstValKind { get; }
    public NullableType(CType underlyingType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual AggregateType GetAts();
    public virtual CType StripNubs();
    public virtual CType StripNubs(Boolean& wasNullable);
    [CompilerGeneratedAttribute]
public CType get_UnderlyingType();
    public virtual bool get_IsValueType();
    public virtual bool get_IsStructType();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NullType : CType {
    public static NullType Instance;
    public bool IsReferenceType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    private static NullType();
    public virtual bool get_IsReferenceType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.Operators : object {
    private static OperatorInfo[] s_operatorInfos;
    private static Dictionary`2<Name, string> s_operatorsByName;
    private static Operators();
    private static Dictionary`2<Name, string> GetOperatorByName();
    private static OperatorInfo GetInfo(OperatorKind op);
    public static string OperatorOfMethodName(Name name);
    public static string GetDisplayName(OperatorKind op);
    public static ExpressionKind GetExpressionKind(OperatorKind op);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.OpSigFlags : Enum {
    public int value__;
    public static OpSigFlags None;
    public static OpSigFlags Convert;
    public static OpSigFlags CanLift;
    public static OpSigFlags AutoLift;
    public static OpSigFlags Value;
    public static OpSigFlags Reference;
    public static OpSigFlags BoolBit;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ParameterModifierType : CType {
    [CompilerGeneratedAttribute]
private bool <IsOut>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <ParameterType>k__BackingField;
    public bool IsOut { get; }
    public CType ParameterType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public ParameterModifierType(CType parameterType, bool isOut);
    [CompilerGeneratedAttribute]
public bool get_IsOut();
    [CompilerGeneratedAttribute]
public CType get_ParameterType();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ParentSymbol : Symbol {
    public Symbol firstChild;
    private Symbol _lastChild;
    public void AddToChildList(Symbol sym);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PointerType : CType {
    [CompilerGeneratedAttribute]
private CType <ReferentType>k__BackingField;
    public CType ReferentType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    [ExcludeFromCodeCoverageAttribute]
public ConstValKind ConstValKind { get; }
    public PointerType(CType referentType);
    [CompilerGeneratedAttribute]
public CType get_ReferentType();
    public virtual bool IsUnsafe();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMembers : object {
    private static MethodSymbol[] _methods;
    private static PropertySymbol[] _properties;
    private static PredefinedPropertyInfo[] s_predefinedProperties;
    private static PredefinedMethodInfo[] s_predefinedMethods;
    private static PredefinedMembers();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static PropertySymbol LoadProperty(PREDEFPROP property);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static PropertySymbol LoadProperty(PREDEFPROP predefProp, Name propertyName, PREDEFMETH propertyGetter);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static AggregateSymbol GetPredefAgg(PredefinedType pt);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static CType LoadTypeFromSignature(Int32[] signature, Int32& indexIntoSignatures, TypeArray classTyVars);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeArray LoadTypeArrayFromSignature(Int32[] signature, Int32& indexIntoSignatures, TypeArray classTyVars);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static PropertySymbol GetProperty(PREDEFPROP property);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static MethodSymbol GetMethod(PREDEFMETH method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static MethodSymbol LoadMethod(AggregateSymbol type, Int32[] signature, int cMethodTyVars, Name methodName, ACCESS methodAccess, bool isStatic, bool isVirtual);
    private static MethodSymbol LookupMethodWhileLoading(AggregateSymbol type, int cMethodTyVars, Name methodName, ACCESS methodAccess, bool isStatic, bool isVirtual, CType returnType, TypeArray argumentTypes);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static MethodSymbol LoadMethod(PREDEFMETH method);
    private static PREDEFMETH GetPropGetter(PREDEFPROP property);
    private static PredefinedType GetPropPredefType(PREDEFPROP property);
    private static PredefinedPropertyInfo GetPropInfo(PREDEFPROP property);
    private static PredefinedMethodInfo GetMethInfo(PREDEFMETH method);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMethodInfo : object {
    public PREDEFMETH method;
    public PredefinedType type;
    public PredefinedName name;
    public MethodCallingConventionEnum callingConvention;
    public ACCESS access;
    public int cTypeVars;
    public Int32[] signature;
    public PredefinedMethodInfo(PREDEFMETH method, PredefinedType type, PredefinedName name, MethodCallingConventionEnum callingConvention, ACCESS access, int cTypeVars, Int32[] signature);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedPropertyInfo : object {
    public PREDEFPROP property;
    public PredefinedName name;
    public PREDEFMETH getter;
    public PredefinedPropertyInfo(PREDEFPROP property, PredefinedName name, PREDEFMETH getter);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedTypeFacts : object {
    private static PredefinedTypeInfo[] s_types;
    private static Dictionary`2<string, PredefinedType> s_typesByName;
    private static PredefinedTypeFacts();
    internal static FUNDTYPE GetFundType(PredefinedType type);
    internal static Type GetAssociatedSystemType(PredefinedType type);
    internal static bool IsSimpleType(PredefinedType type);
    internal static bool IsNumericType(PredefinedType type);
    internal static string GetNiceName(PredefinedType type);
    public static PredefinedType TryGetPredefTypeIndex(string name);
    private static Dictionary`2<string, PredefinedType> CreatePredefinedTypeFacts();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedTypes : object {
    private static AggregateSymbol[] s_predefSymbols;
    private static PredefinedTypes();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static AggregateSymbol DelayLoadPredefSym(PredefinedType pt);
    internal static AggregateSymbol InitializePredefinedType(AggregateSymbol sym, PredefinedType pt);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static AggregateSymbol GetPredefinedAggregate(PredefinedType pt);
    private static string GetNiceName(PredefinedType pt);
    public static string GetNiceName(AggregateSymbol type);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFMETH : Enum {
    public int value__;
    public static PREDEFMETH PM_DECIMAL_OPDECREMENT;
    public static PREDEFMETH PM_DECIMAL_OPINCREMENT;
    public static PREDEFMETH PM_DECIMAL_OPUNARYMINUS;
    public static PREDEFMETH PM_DELEGATE_COMBINE;
    public static PREDEFMETH PM_DELEGATE_OPEQUALITY;
    public static PREDEFMETH PM_DELEGATE_OPINEQUALITY;
    public static PREDEFMETH PM_DELEGATE_REMOVE;
    public static PREDEFMETH PM_EXPRESSION_ADD;
    public static PREDEFMETH PM_EXPRESSION_ADD_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ADDCHECKED;
    public static PREDEFMETH PM_EXPRESSION_ADDCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_AND;
    public static PREDEFMETH PM_EXPRESSION_AND_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ANDALSO;
    public static PREDEFMETH PM_EXPRESSION_ANDALSO_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ARRAYINDEX;
    public static PREDEFMETH PM_EXPRESSION_ARRAYINDEX2;
    public static PREDEFMETH PM_EXPRESSION_ASSIGN;
    public static PREDEFMETH PM_EXPRESSION_CONSTANT_OBJECT_TYPE;
    public static PREDEFMETH PM_EXPRESSION_CONVERT;
    public static PREDEFMETH PM_EXPRESSION_CONVERT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_CONVERTCHECKED;
    public static PREDEFMETH PM_EXPRESSION_CONVERTCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_DIVIDE;
    public static PREDEFMETH PM_EXPRESSION_DIVIDE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_EQUAL;
    public static PREDEFMETH PM_EXPRESSION_EQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_EXCLUSIVEOR;
    public static PREDEFMETH PM_EXPRESSION_EXCLUSIVEOR_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_FIELD;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHAN;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHAN_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHANOREQUAL;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHANOREQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LAMBDA;
    public static PREDEFMETH PM_EXPRESSION_LEFTSHIFT;
    public static PREDEFMETH PM_EXPRESSION_LEFTSHIFT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LESSTHAN;
    public static PREDEFMETH PM_EXPRESSION_LESSTHAN_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LESSTHANOREQUAL;
    public static PREDEFMETH PM_EXPRESSION_LESSTHANOREQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MODULO;
    public static PREDEFMETH PM_EXPRESSION_MODULO_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLY;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLY_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLYCHECKED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLYCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NOTEQUAL;
    public static PREDEFMETH PM_EXPRESSION_NOTEQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_OR;
    public static PREDEFMETH PM_EXPRESSION_OR_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ORELSE;
    public static PREDEFMETH PM_EXPRESSION_ORELSE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_PARAMETER;
    public static PREDEFMETH PM_EXPRESSION_RIGHTSHIFT;
    public static PREDEFMETH PM_EXPRESSION_RIGHTSHIFT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACT;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACTCHECKED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACTCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_UNARYPLUS_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEGATE;
    public static PREDEFMETH PM_EXPRESSION_NEGATE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEGATECHECKED;
    public static PREDEFMETH PM_EXPRESSION_NEGATECHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_CALL;
    public static PREDEFMETH PM_EXPRESSION_NEW;
    public static PREDEFMETH PM_EXPRESSION_NEW_TYPE;
    public static PREDEFMETH PM_EXPRESSION_QUOTE;
    public static PREDEFMETH PM_EXPRESSION_NOT;
    public static PREDEFMETH PM_EXPRESSION_NOT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEWARRAYINIT;
    public static PREDEFMETH PM_EXPRESSION_PROPERTY;
    public static PREDEFMETH PM_EXPRESSION_INVOKE;
    public static PREDEFMETH PM_G_OPTIONAL_CTOR;
    public static PREDEFMETH PM_G_OPTIONAL_GETVALUE;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_2;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_3;
    public static PREDEFMETH PM_STRING_CONCAT_STRING_2;
    public static PREDEFMETH PM_STRING_OPEQUALITY;
    public static PREDEFMETH PM_STRING_OPINEQUALITY;
    public static PREDEFMETH PM_COUNT;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFPROP : Enum {
    public int value__;
    public static PREDEFPROP PP_G_OPTIONAL_VALUE;
    public static PREDEFPROP PP_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PropertySymbol : MethodOrPropertySymbol {
    [CompilerGeneratedAttribute]
private MethodSymbol <GetterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <SetterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <AssociatedPropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Bogus>k__BackingField;
    public MethodSymbol GetterMethod { get; public set; }
    public MethodSymbol SetterMethod { get; public set; }
    public PropertyInfo AssociatedPropertyInfo { get; public set; }
    public bool Bogus { get; public set; }
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetterMethod();
    [CompilerGeneratedAttribute]
public void set_GetterMethod(MethodSymbol value);
    [CompilerGeneratedAttribute]
public MethodSymbol get_SetterMethod();
    [CompilerGeneratedAttribute]
public void set_SetterMethod(MethodSymbol value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_AssociatedPropertyInfo();
    [CompilerGeneratedAttribute]
public void set_AssociatedPropertyInfo(PropertyInfo value);
    [CompilerGeneratedAttribute]
public bool get_Bogus();
    [CompilerGeneratedAttribute]
public void set_Bogus(bool value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PropWithType : MethPropWithType {
    public PropWithType(PropertySymbol prop, AggregateType ats);
    public PropWithType(SymWithType swt);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.Scope : ParentSymbol {
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SpecCons : Enum {
    public int value__;
    public static SpecCons None;
    public static SpecCons New;
    public static SpecCons Ref;
    public static SpecCons Val;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SubstContext : object {
    public CType[] ClassTypes;
    public CType[] MethodTypes;
    public bool DenormMeth;
    public bool IsNop { get; }
    public SubstContext(TypeArray typeArgsCls, TypeArray typeArgsMeth, bool denormMeth);
    public SubstContext(AggregateType type);
    public SubstContext(AggregateType type, TypeArray typeArgsMeth);
    private SubstContext(AggregateType type, TypeArray typeArgsMeth, bool denormMeth);
    public bool get_IsNop();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.symbmask_t : Enum {
    public long value__;
    public static symbmask_t MASK_NamespaceSymbol;
    public static symbmask_t MASK_AggregateSymbol;
    public static symbmask_t MASK_TypeParameterSymbol;
    public static symbmask_t MASK_FieldSymbol;
    public static symbmask_t MASK_MethodSymbol;
    public static symbmask_t MASK_PropertySymbol;
    public static symbmask_t MASK_EventSymbol;
    public static symbmask_t MASK_ALL;
    public static symbmask_t MASK_Member;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.Symbol : object {
    private SYMKIND _kind;
    private ACCESS _access;
    public Name name;
    public ParentSymbol parent;
    public Symbol nextChild;
    public Symbol nextSameName;
    public bool isStatic { get; }
    public Symbol LookupNext(symbmask_t kindmask);
    public ACCESS GetAccess();
    public void SetAccess(ACCESS access);
    public SYMKIND getKind();
    public void setKind(SYMKIND kind);
    public symbmask_t mask();
    public CType getType();
    public bool get_isStatic();
    private Assembly GetAssembly();
    private bool InternalsVisibleTo(Assembly assembly);
    public bool SameAssemOrFriend(Symbol sym);
    public bool IsOverride();
    public bool IsHideByName();
    public bool isUserCallable();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymbolLoader : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static AggregateSymbol GetPredefAgg(PredefinedType pt);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static AggregateType GetPredefindType(PredefinedType pt);
    public static Symbol LookupAggMember(Name name, AggregateSymbol agg, symbmask_t mask);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool IsBaseInterface(AggregateType atsDer, AggregateType pBase);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool IsBaseClassOfClass(CType pDerived, CType pBase);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool IsBaseClass(CType pDerived, CType pBase);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasCovariantArrayConversion(ArrayType pSource, ArrayType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool HasIdentityOrImplicitReferenceConversion(CType pSource, CType pDest);
    private static bool AreTypesEqualForConversion(CType pType1, CType pType2);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasArrayConversionToInterface(ArrayType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasImplicitReferenceConversion(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasAnyBaseInterfaceConversion(CType pDerived, CType pBase);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasInterfaceConversion(AggregateType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasDelegateConversion(AggregateType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasVariantConversion(AggregateType pSource, AggregateType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool HasImplicitBoxingConversion(CType pSource, CType pDest);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool HasBaseConversion(CType pSource, CType pDest);
    public static bool IsBaseAggregate(AggregateSymbol derived, AggregateSymbol base);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymbolStore : object {
    private static Dictionary`2<Key, Symbol> s_dictionary;
    private static SymbolStore();
    public static Symbol LookupSym(Name name, ParentSymbol parent, symbmask_t kindmask);
    public static void InsertChild(ParentSymbol parent, Symbol child);
    private static void InsertChildNoGrow(Symbol child);
    private static Symbol FindCorrectKind(Symbol sym, symbmask_t kindmask);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymFactory : object {
    private static Symbol NewBasicSymbol(SYMKIND kind, Name name, ParentSymbol parent);
    public static NamespaceSymbol CreateNamespace(Name name, NamespaceSymbol parent);
    public static AggregateSymbol CreateAggregate(Name name, NamespaceOrAggregateSymbol parent);
    public static FieldSymbol CreateMemberVar(Name name, AggregateSymbol parent);
    public static LocalVariableSymbol CreateLocalVar(Name name, Scope parent, CType type);
    public static MethodSymbol CreateMethod(Name name, AggregateSymbol parent);
    public static PropertySymbol CreateProperty(Name name, AggregateSymbol parent);
    public static EventSymbol CreateEvent(Name name, AggregateSymbol parent);
    public static TypeParameterSymbol CreateMethodTypeParameter(Name pName, MethodSymbol pParent, int index, int indexTotal);
    public static TypeParameterSymbol CreateClassTypeParameter(Name pName, AggregateSymbol pParent, int index, int indexTotal);
    public static Scope CreateScope();
    public static IndexerSymbol CreateIndexer(Name name, ParentSymbol parent);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SYMKIND : Enum {
    public int value__;
    public static SYMKIND SK_NamespaceSymbol;
    public static SYMKIND SK_AggregateSymbol;
    public static SYMKIND SK_TypeParameterSymbol;
    public static SYMKIND SK_FieldSymbol;
    public static SYMKIND SK_LocalVariableSymbol;
    public static SYMKIND SK_MethodSymbol;
    public static SYMKIND SK_PropertySymbol;
    public static SYMKIND SK_EventSymbol;
    public static SYMKIND SK_Scope;
    public static SYMKIND SK_IndexerSymbol;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SymWithType : object {
    private AggregateType _ats;
    private Symbol _sym;
    public AggregateType Ats { get; }
    public Symbol Sym { get; }
    public SymWithType(Symbol sym, AggregateType ats);
    public virtual void Clear();
    public AggregateType get_Ats();
    public Symbol get_Sym();
    public AggregateType GetType();
    public static bool op_Equality(SymWithType swt1, SymWithType swt2);
    public static bool op_Inequality(SymWithType swt1, SymWithType swt2);
    [ExcludeFromCodeCoverageAttribute]
public virtual bool Equals(object obj);
    [ExcludeFromCodeCoverageAttribute]
public virtual int GetHashCode();
    public static bool op_Implicit(SymWithType swt);
    public MethodOrPropertySymbol MethProp();
    public MethodSymbol Meth();
    public PropertySymbol Prop();
    public FieldSymbol Field();
    public EventSymbol Event();
    public void Set(Symbol sym, AggregateType ats);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeArray : object {
    private static Dictionary`2<TypeArrayKey, TypeArray> s_tableTypeArrays;
    public static TypeArray Empty;
    [CompilerGeneratedAttribute]
private CType[] <Items>k__BackingField;
    public int Count { get; }
    public CType[] Items { get; }
    public CType Item { get; }
    private TypeArray(CType[] types);
    private static TypeArray();
    public int get_Count();
    [CompilerGeneratedAttribute]
public CType[] get_Items();
    public CType get_Item(int i);
    public void CopyItems(int i, int c, CType[] dest);
    public static TypeArray Allocate(int ctype, TypeArray array, int offset);
    public static TypeArray Allocate(CType[] types);
    public static TypeArray Concat(TypeArray pta1, TypeArray pta2);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeBind : object {
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static bool CheckConstraints(CType type, CheckConstraintsFlags flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static void CheckMethConstraints(MethWithInst mwi);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool CheckConstraintsCore(Symbol symErr, TypeArray typeVars, TypeArray typeArgs, TypeArray typeArgsCls, TypeArray typeArgsMeth, CheckConstraintsFlags flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool CheckSingleConstraint(Symbol symErr, TypeParameterType var, CType arg, TypeArray typeArgsCls, TypeArray typeArgsMeth, CheckConstraintsFlags flags);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool SatisfiesBound(CType arg, CType typeBnd);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.TypeKind : Enum {
    public int value__;
    public static TypeKind TK_AggregateType;
    public static TypeKind TK_VoidType;
    public static TypeKind TK_NullType;
    public static TypeKind TK_MethodGroupType;
    public static TypeKind TK_ArgumentListType;
    public static TypeKind TK_ArrayType;
    public static TypeKind TK_PointerType;
    public static TypeKind TK_ParameterModifierType;
    public static TypeKind TK_NullableType;
    public static TypeKind TK_TypeParameterType;
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeManager : object {
    private static Dictionary`2<ValueTuple`2<Assembly, Assembly>, bool> s_internalsVisibleToCache;
    private static StdTypeVarColl s_stvcMethod;
    private static TypeManager();
    public static ArrayType GetArray(CType elementType, int args, bool isSZArray);
    public static AggregateType GetAggregate(AggregateSymbol agg, AggregateType atsOuter, TypeArray typeArgs);
    public static AggregateType GetAggregate(AggregateSymbol agg, TypeArray typeArgsAll);
    public static PointerType GetPointer(CType baseType);
    public static NullableType GetNullable(CType pUnderlyingType);
    public static ParameterModifierType GetParameterModifier(CType paramType, bool isOut);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static AggregateSymbol GetNullable();
    private static CType SubstType(CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, bool denormMeth);
    public static AggregateType SubstType(AggregateType typeSrc, TypeArray typeArgsCls);
    private static CType SubstType(CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, SubstContext ctx);
    public static TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls);
    private static AggregateType SubstTypeCore(AggregateType type, SubstContext ctx);
    private static CType SubstTypeCore(CType type, SubstContext pctx);
    public static bool SubstEqualTypes(CType typeDst, CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, bool denormMeth);
    public static bool SubstEqualTypeArrays(TypeArray taDst, TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    private static bool SubstEqualTypesCore(CType typeDst, CType typeSrc, SubstContext pctx);
    public static bool TypeContainsType(CType type, CType typeFind);
    public static bool TypeContainsTyVars(CType type, TypeArray typeVars);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public static AggregateSymbol GetPredefAgg(PredefinedType pt);
    public static AggregateType SubstType(AggregateType typeSrc, SubstContext ctx);
    public static CType SubstType(CType typeSrc, SubstContext pctx);
    public static CType SubstType(CType typeSrc, AggregateType atsCls);
    public static CType SubstType(CType typeSrc, AggregateType atsCls, TypeArray typeArgsMeth);
    public static CType SubstType(CType typeSrc, CType typeCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, AggregateType atsCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, AggregateType atsCls);
    private static bool SubstEqualTypes(CType typeDst, CType typeSrc, CType typeCls, TypeArray typeArgsMeth);
    public static bool SubstEqualTypes(CType typeDst, CType typeSrc, CType typeCls);
    public static TypeParameterType GetStdMethTypeVar(int iv);
    public static TypeParameterType GetTypeParameter(TypeParameterSymbol pSymbol);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static CType GetBestAccessibleType(AggregateSymbol context, CType typeSrc);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool TryVarianceAdjustmentToGetAccessibleType(AggregateSymbol context, AggregateType typeSrc, CType& typeDst);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static bool TryArrayVarianceAdjustmentToGetAccessibleType(AggregateSymbol context, ArrayType typeSrc, CType& typeDst);
    internal static bool InternalsVisibleTo(Assembly assemblyThatDefinesAttribute, Assembly assemblyToCheck);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeParameterSymbol : Symbol {
    private bool _bIsMethodTypeParameter;
    private SpecCons _constraints;
    private TypeParameterType _pTypeParameterType;
    private int _nIndexInOwnParameters;
    private int _nIndexInTotalParameters;
    private TypeArray _pBounds;
    public bool Covariant;
    public bool Contravariant;
    public bool Invariant { get; }
    public bool get_Invariant();
    public void SetTypeParameterType(TypeParameterType pType);
    public TypeParameterType GetTypeParameterType();
    public bool IsMethodTypeParameter();
    public void SetIsMethodTypeParameter(bool b);
    public int GetIndexInOwnParameters();
    public void SetIndexInOwnParameters(int index);
    public int GetIndexInTotalParameters();
    public void SetIndexInTotalParameters(int index);
    public void SetBounds(TypeArray pBounds);
    public TypeArray GetBounds();
    public void SetConstraints(SpecCons constraints);
    public bool IsValueType();
    public bool IsReferenceType();
    public bool IsNonNullableValueType();
    public bool HasNewConstraint();
    public bool HasRefConstraint();
    public bool HasValConstraint();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeParameterType : CType {
    [CompilerGeneratedAttribute]
private TypeParameterSymbol <Symbol>k__BackingField;
    public TypeParameterSymbol Symbol { get; }
    public ParentSymbol OwningSymbol { get; }
    public Name Name { get; }
    public bool Covariant { get; }
    public bool Invariant { get; }
    public bool Contravariant { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsNonNullableValueType { get; }
    public bool HasNewConstraint { get; }
    public bool HasRefConstraint { get; }
    public bool HasValConstraint { get; }
    public bool IsMethodTypeParameter { get; }
    public int IndexInOwnParameters { get; }
    public int IndexInTotalParameters { get; }
    public TypeArray Bounds { get; }
    public Type AssociatedSystemType { get; }
    public FUNDTYPE FundamentalType { get; }
    public TypeParameterType(TypeParameterSymbol symbol);
    [CompilerGeneratedAttribute]
public TypeParameterSymbol get_Symbol();
    public ParentSymbol get_OwningSymbol();
    public Name get_Name();
    public bool get_Covariant();
    public bool get_Invariant();
    public bool get_Contravariant();
    public virtual bool get_IsValueType();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsNonNullableValueType();
    public bool get_HasNewConstraint();
    public bool get_HasRefConstraint();
    public bool get_HasValConstraint();
    public bool get_IsMethodTypeParameter();
    public int get_IndexInOwnParameters();
    public int get_IndexInTotalParameters();
    public TypeArray get_Bounds();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public virtual Type get_AssociatedSystemType();
    public virtual FUNDTYPE get_FundamentalType();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeTable : object {
    private static Dictionary`2<KeyPair`2<AggregateSymbol, KeyPair`2<AggregateType, TypeArray>>, AggregateType> s_aggregateTable;
    private static Dictionary`2<KeyPair`2<CType, int>, ArrayType> s_arrayTable;
    private static Dictionary`2<KeyPair`2<CType, bool>, ParameterModifierType> s_parameterModifierTable;
    private static Dictionary`2<CType, PointerType> s_pointerTable;
    private static Dictionary`2<CType, NullableType> s_nullableTable;
    private static TypeTable();
    private static KeyPair`2<TKey1, TKey2> MakeKey(TKey1 key1, TKey2 key2);
    public static AggregateType LookupAggregate(AggregateSymbol aggregate, AggregateType outer, TypeArray args);
    public static void InsertAggregate(AggregateSymbol aggregate, AggregateType outer, TypeArray args, AggregateType ats);
    public static ArrayType LookupArray(CType elementType, int rankNum);
    public static void InsertArray(CType elementType, int rankNum, ArrayType pArray);
    public static ParameterModifierType LookupParameterModifier(CType elementType, bool isOut);
    public static void InsertParameterModifier(CType elementType, bool isOut, ParameterModifierType parameterModifier);
    public static PointerType LookupPointer(CType elementType);
    public static void InsertPointer(CType elementType, PointerType pointer);
    public static NullableType LookupNullable(CType underlyingType);
    public static void InsertNullable(CType underlyingType, NullableType nullable);
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.UdConvInfo : ValueType {
    public MethWithType Meth;
    public bool SrcImplicit;
    public bool DstImplicit;
    public UdConvInfo(MethWithType mwt, bool srcImplicit, bool dstImplicit);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpFuncKind : Enum {
    public int value__;
    public static UnaOpFuncKind BoolUnaOp;
    public static UnaOpFuncKind DecUnaOp;
    public static UnaOpFuncKind EnumUnaOp;
    public static UnaOpFuncKind IntUnaOp;
    public static UnaOpFuncKind RealUnaOp;
    public static UnaOpFuncKind LiftedIncOpCore;
    public static UnaOpFuncKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpKind : Enum {
    public int value__;
    public static UnaOpKind Plus;
    public static UnaOpKind Minus;
    public static UnaOpKind Tilde;
    public static UnaOpKind Bang;
    public static UnaOpKind IncDec;
    public static UnaOpKind Lim;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpMask : Enum {
    public int value__;
    public static UnaOpMask None;
    public static UnaOpMask Plus;
    public static UnaOpMask Minus;
    public static UnaOpMask Tilde;
    public static UnaOpMask Bang;
    public static UnaOpMask IncDec;
    public static UnaOpMask Signed;
    public static UnaOpMask Unsigned;
    public static UnaOpMask Real;
    public static UnaOpMask Bool;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaryOperatorSignatureFindResult : Enum {
    public int value__;
    public static UnaryOperatorSignatureFindResult Match;
    public static UnaryOperatorSignatureFindResult Continue;
    public static UnaryOperatorSignatureFindResult Return;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.VariableSymbol : Symbol {
    protected CType type;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.VoidType : CType {
    public static VoidType Instance;
    private static VoidType();
    public virtual bool IsPredefType(PredefinedType pt);
}
internal static class Microsoft.CSharp.RuntimeBinder.SymbolTable : object {
    private static HashSet`1<Type> s_typesWithConversionsLoaded;
    private static HashSet`1<NameHashKey> s_namesLoadedForEachType;
    private static SymbolTable();
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static void PopulateSymbolTableWithName(string name, IEnumerable`1<Type> typeArguments, Type callingType);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static SymWithType LookupMember(string name, Expr callingObject, ParentSymbol context, int arity, MemberLookup mem, bool allowSpecialNames, bool requireInvocable);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddParameterConversions(MethodBase method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddNamesOnType(NameHashKey key);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddNamesInInheritanceHierarchy(string name, List`1<Type> inheritance);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static List`1<Type> CreateInheritanceHierarchyList(Type type);
    private static Name GetName(string p);
    private static Name GetName(Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeArray GetMethodTypeParameters(MethodInfo method, MethodSymbol parent);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeArray GetAggregateTypeParameters(Type type, AggregateSymbol agg);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeParameterType LoadClassTypeParameter(AggregateSymbol parent, Type t);
    private static bool AreTypeParametersEquivalent(Type t1, Type t2);
    private static Type GetOriginalTypeParameterType(Type t);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeParameterType LoadMethodTypeParameter(MethodSymbol parent, Type t);
    private static TypeParameterType AddTypeParameterToSymbolTable(AggregateSymbol agg, MethodSymbol meth, Type t, bool bIsAggregate);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static CType LoadSymbolsFromType(Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeParameterType ProcessMethodTypeParameter(MethodInfo methinfo, Type t, AggregateSymbol parent);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static CType GetConstructedType(Type type, AggregateSymbol agg);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static CType ProcessSpecialTypeInChain(NamespaceOrAggregateSymbol parent, Type t);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static List`1<object> BuildDeclarationChain(Type callingType);
    private static AggregateSymbol FindSymForType(Symbol sym, Type t);
    private static NamespaceSymbol AddNamespaceToSymbolTable(NamespaceOrAggregateSymbol parent, string sz);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static CType[] GetCTypeArrayFromTypes(Type[] types);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static CType GetCTypeFromType(Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static AggregateSymbol AddAggregateToSymbolTable(NamespaceOrAggregateSymbol parent, Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void SetInterfacesOnAggregate(AggregateSymbol aggregate, Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static FieldSymbol AddFieldToSymbolTable(FieldInfo fieldInfo, AggregateSymbol aggregate);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddEventToSymbolTable(EventInfo eventInfo, AggregateSymbol aggregate, FieldSymbol addedField);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static void AddPredefinedPropertyToSymbolTable(AggregateSymbol type, Name property);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddPropertyToSymbolTable(PropertyInfo property, AggregateSymbol aggregate);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static void AddPredefinedMethodToSymbolTable(AggregateSymbol type, Name methodName);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static MethodSymbol AddMethodToSymbolTable(MethodBase member, AggregateSymbol callingAggregate, MethodKindEnum kind);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void SetParameterDataForMethProp(MethodOrPropertySymbol methProp, ParameterInfo[] parameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void SetParameterAttributes(MethodOrPropertySymbol methProp, ParameterInfo[] parameters, int i);
    private static MethodSymbol FindMatchingMethod(MemberInfo method, AggregateSymbol callingAggregate);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static TypeArray CreateParameterArray(MemberInfo associatedInfo, ParameterInfo[] parameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static CType GetTypeOfParameter(ParameterInfo p, MemberInfo m);
    private static bool DoesMethodHaveParameterArray(ParameterInfo[] parameters);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static SymWithType GetSlotForOverride(MethodInfo method);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static MethodSymbol FindMethodFromMemberInfo(MemberInfo baseMemberInfo);
    internal static bool AggregateContainsMethod(AggregateSymbol agg, string szName, symbmask_t mask);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
internal static void AddConversionsForType(Type type);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
private static void AddConversionsForOneType(Type type);
    private static bool IsOperator(MethodInfo method);
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.Name : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public Name(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    public virtual string ToString();
}
internal static class Microsoft.CSharp.RuntimeBinder.Syntax.NameManager : object {
    private static Name[] s_predefinedNames;
    private static NameTable s_names;
    private static NameManager();
    private static NameTable GetKnownNames();
    internal static Name Add(string key);
    internal static Name Add(string key, int length);
    internal static Name GetPredefinedName(PredefinedName id);
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.NameTable : object {
    private Entry[] _entries;
    private int _count;
    private int _mask;
    public Name Add(string key);
    public Name Add(string key, int length);
    internal void Add(Name name);
    private static int ComputeHashCode(string key);
    private static int ComputeHashCode(string key, int length);
    private static bool Equals(string candidate, string key, int length);
    private Name AddEntry(Name name, int hashCode);
    private void Grow();
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.OperatorKind : Enum {
    public UInt32 value__;
    public static OperatorKind OP_NONE;
    public static OperatorKind OP_ASSIGN;
    public static OperatorKind OP_ADDEQ;
    public static OperatorKind OP_SUBEQ;
    public static OperatorKind OP_MULEQ;
    public static OperatorKind OP_DIVEQ;
    public static OperatorKind OP_MODEQ;
    public static OperatorKind OP_ANDEQ;
    public static OperatorKind OP_XOREQ;
    public static OperatorKind OP_OREQ;
    public static OperatorKind OP_LSHIFTEQ;
    public static OperatorKind OP_RSHIFTEQ;
    public static OperatorKind OP_QUESTION;
    public static OperatorKind OP_VALORDEF;
    public static OperatorKind OP_LOGOR;
    public static OperatorKind OP_LOGAND;
    public static OperatorKind OP_BITOR;
    public static OperatorKind OP_BITXOR;
    public static OperatorKind OP_BITAND;
    public static OperatorKind OP_EQ;
    public static OperatorKind OP_NEQ;
    public static OperatorKind OP_LT;
    public static OperatorKind OP_LE;
    public static OperatorKind OP_GT;
    public static OperatorKind OP_GE;
    public static OperatorKind OP_IS;
    public static OperatorKind OP_AS;
    public static OperatorKind OP_LSHIFT;
    public static OperatorKind OP_RSHIFT;
    public static OperatorKind OP_ADD;
    public static OperatorKind OP_SUB;
    public static OperatorKind OP_MUL;
    public static OperatorKind OP_DIV;
    public static OperatorKind OP_MOD;
    public static OperatorKind OP_NOP;
    public static OperatorKind OP_UPLUS;
    public static OperatorKind OP_NEG;
    public static OperatorKind OP_BITNOT;
    public static OperatorKind OP_LOGNOT;
    public static OperatorKind OP_PREINC;
    public static OperatorKind OP_PREDEC;
    public static OperatorKind OP_TYPEOF;
    public static OperatorKind OP_CHECKED;
    public static OperatorKind OP_UNCHECKED;
    public static OperatorKind OP_MAKEREFANY;
    public static OperatorKind OP_REFVALUE;
    public static OperatorKind OP_REFTYPE;
    public static OperatorKind OP_ARGS;
    public static OperatorKind OP_CAST;
    public static OperatorKind OP_INDIR;
    public static OperatorKind OP_ADDR;
    public static OperatorKind OP_COLON;
    public static OperatorKind OP_THIS;
    public static OperatorKind OP_BASE;
    public static OperatorKind OP_NULL;
    public static OperatorKind OP_TRUE;
    public static OperatorKind OP_FALSE;
    public static OperatorKind OP_CALL;
    public static OperatorKind OP_DEREF;
    public static OperatorKind OP_PAREN;
    public static OperatorKind OP_POSTINC;
    public static OperatorKind OP_POSTDEC;
    public static OperatorKind OP_DOT;
    public static OperatorKind OP_IMPLICIT;
    public static OperatorKind OP_EXPLICIT;
    public static OperatorKind OP_EQUALS;
    public static OperatorKind OP_COMPARE;
    public static OperatorKind OP_DEFAULT;
    public static OperatorKind OP_LAST;
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.PredefinedName : Enum {
    public int value__;
    public static PredefinedName PN_CTOR;
    public static PredefinedName PN_DTOR;
    public static PredefinedName PN_STATCTOR;
    public static PredefinedName PN_PTR;
    public static PredefinedName PN_NUB;
    public static PredefinedName PN_OUTPARAM;
    public static PredefinedName PN_REFPARAM;
    public static PredefinedName PN_ARRAY0;
    public static PredefinedName PN_ARRAY1;
    public static PredefinedName PN_ARRAY2;
    public static PredefinedName PN_GARRAY0;
    public static PredefinedName PN_GARRAY1;
    public static PredefinedName PN_GARRAY2;
    public static PredefinedName PN_INVOKE;
    public static PredefinedName PN_LENGTH;
    public static PredefinedName PN_INDEXER;
    public static PredefinedName PN_INDEXERINTERNAL;
    public static PredefinedName PN_COMBINE;
    public static PredefinedName PN_REMOVE;
    public static PredefinedName PN_OPEXPLICITMN;
    public static PredefinedName PN_OPIMPLICITMN;
    public static PredefinedName PN_OPUNARYPLUS;
    public static PredefinedName PN_OPUNARYMINUS;
    public static PredefinedName PN_OPCOMPLEMENT;
    public static PredefinedName PN_OPINCREMENT;
    public static PredefinedName PN_OPDECREMENT;
    public static PredefinedName PN_OPPLUS;
    public static PredefinedName PN_OPMINUS;
    public static PredefinedName PN_OPMULTIPLY;
    public static PredefinedName PN_OPDIVISION;
    public static PredefinedName PN_OPMODULUS;
    public static PredefinedName PN_OPXOR;
    public static PredefinedName PN_OPBITWISEAND;
    public static PredefinedName PN_OPBITWISEOR;
    public static PredefinedName PN_OPLEFTSHIFT;
    public static PredefinedName PN_OPRIGHTSHIFT;
    public static PredefinedName PN_OPEQUALS;
    public static PredefinedName PN_OPCOMPARE;
    public static PredefinedName PN_OPEQUALITY;
    public static PredefinedName PN_OPINEQUALITY;
    public static PredefinedName PN_OPGREATERTHAN;
    public static PredefinedName PN_OPLESSTHAN;
    public static PredefinedName PN_OPGREATERTHANOREQUAL;
    public static PredefinedName PN_OPLESSTHANOREQUAL;
    public static PredefinedName PN_OPTRUE;
    public static PredefinedName PN_OPFALSE;
    public static PredefinedName PN_OPNEGATION;
    public static PredefinedName PN_CONCAT;
    public static PredefinedName PN_ADD;
    public static PredefinedName PN_GETLENGTH;
    public static PredefinedName PN_GETCHARS;
    public static PredefinedName PN_CREATEDELEGATE;
    public static PredefinedName PN_FIXEDELEMENT;
    public static PredefinedName PN_HASVALUE;
    public static PredefinedName PN_GETHASVALUE;
    public static PredefinedName PN_CAP_VALUE;
    public static PredefinedName PN_GETVALUE;
    public static PredefinedName PN_GET_VALUE_OR_DEF;
    public static PredefinedName PN_MISSING;
    public static PredefinedName PN_MISSINGSYM;
    public static PredefinedName PN_LAMBDA;
    public static PredefinedName PN_PARAMETER;
    public static PredefinedName PN_CONSTANT;
    public static PredefinedName PN_CONVERT;
    public static PredefinedName PN_CONVERTCHECKED;
    public static PredefinedName PN_ADDCHECKED;
    public static PredefinedName PN_DIVIDE;
    public static PredefinedName PN_MODULO;
    public static PredefinedName PN_MULTIPLY;
    public static PredefinedName PN_MULTIPLYCHECKED;
    public static PredefinedName PN_SUBTRACT;
    public static PredefinedName PN_SUBTRACTCHECKED;
    public static PredefinedName PN_AND;
    public static PredefinedName PN_OR;
    public static PredefinedName PN_EXCLUSIVEOR;
    public static PredefinedName PN_LEFTSHIFT;
    public static PredefinedName PN_RIGHTSHIFT;
    public static PredefinedName PN_ANDALSO;
    public static PredefinedName PN_ORELSE;
    public static PredefinedName PN_EQUAL;
    public static PredefinedName PN_NOTEQUAL;
    public static PredefinedName PN_GREATERTHANOREQUAL;
    public static PredefinedName PN_GREATERTHAN;
    public static PredefinedName PN_LESSTHAN;
    public static PredefinedName PN_LESSTHANOREQUAL;
    public static PredefinedName PN_ARRAYINDEX;
    public static PredefinedName PN_ASSIGN;
    public static PredefinedName PN_CONDITION;
    public static PredefinedName PN_CAP_FIELD;
    public static PredefinedName PN_CALL;
    public static PredefinedName PN_NEW;
    public static PredefinedName PN_QUOTE;
    public static PredefinedName PN_ARRAYLENGTH;
    public static PredefinedName PN_PLUS;
    public static PredefinedName PN_NEGATE;
    public static PredefinedName PN_NEGATECHECKED;
    public static PredefinedName PN_NOT;
    public static PredefinedName PN_NEWARRAYINIT;
    public static PredefinedName PN_EXPRESSION_PROPERTY;
    public static PredefinedName PN_ADDEVENTHANDLER;
    public static PredefinedName PN_REMOVEEVENTHANDLER;
    public static PredefinedName PN_INVOCATIONLIST;
    public static PredefinedName PN_GETORCREATEEVENTREGISTRATIONTOKENTABLE;
    public static PredefinedName PN_VOID;
    public static PredefinedName PN_EMPTY;
    public static PredefinedName PN_COUNT;
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.PredefinedType : Enum {
    public UInt32 value__;
    public static PredefinedType PT_BYTE;
    public static PredefinedType PT_SHORT;
    public static PredefinedType PT_INT;
    public static PredefinedType PT_LONG;
    public static PredefinedType PT_FLOAT;
    public static PredefinedType PT_DOUBLE;
    public static PredefinedType PT_DECIMAL;
    public static PredefinedType PT_CHAR;
    public static PredefinedType PT_BOOL;
    public static PredefinedType PT_SBYTE;
    public static PredefinedType PT_USHORT;
    public static PredefinedType PT_UINT;
    public static PredefinedType PT_ULONG;
    public static PredefinedType FirstNonSimpleType;
    public static PredefinedType PT_INTPTR;
    public static PredefinedType PT_UINTPTR;
    public static PredefinedType PT_OBJECT;
    public static PredefinedType PT_STRING;
    public static PredefinedType PT_DELEGATE;
    public static PredefinedType PT_MULTIDEL;
    public static PredefinedType PT_ARRAY;
    public static PredefinedType PT_TYPE;
    public static PredefinedType PT_VALUE;
    public static PredefinedType PT_ENUM;
    public static PredefinedType PT_DATETIME;
    public static PredefinedType PT_IENUMERABLE;
    public static PredefinedType PT_G_IENUMERABLE;
    public static PredefinedType PT_G_OPTIONAL;
    public static PredefinedType PT_G_IQUERYABLE;
    public static PredefinedType PT_G_ICOLLECTION;
    public static PredefinedType PT_G_ILIST;
    public static PredefinedType PT_G_EXPRESSION;
    public static PredefinedType PT_EXPRESSION;
    public static PredefinedType PT_BINARYEXPRESSION;
    public static PredefinedType PT_UNARYEXPRESSION;
    public static PredefinedType PT_CONSTANTEXPRESSION;
    public static PredefinedType PT_PARAMETEREXPRESSION;
    public static PredefinedType PT_MEMBEREXPRESSION;
    public static PredefinedType PT_METHODCALLEXPRESSION;
    public static PredefinedType PT_NEWEXPRESSION;
    public static PredefinedType PT_NEWARRAYEXPRESSION;
    public static PredefinedType PT_INVOCATIONEXPRESSION;
    public static PredefinedType PT_FIELDINFO;
    public static PredefinedType PT_METHODINFO;
    public static PredefinedType PT_CONSTRUCTORINFO;
    public static PredefinedType PT_PROPERTYINFO;
    public static PredefinedType PT_MISSING;
    public static PredefinedType PT_G_IREADONLYLIST;
    public static PredefinedType PT_G_IREADONLYCOLLECTION;
    public static PredefinedType PT_FUNC;
    public static PredefinedType PT_COUNT;
    public static PredefinedType PT_VOID;
    public static PredefinedType PT_UNDEFINEDINDEX;
}
internal static class Microsoft.CSharp.RuntimeBinder.Syntax.TokenFacts : object {
    internal static string GetText(TokenKind kind);
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.TokenKind : Enum {
    public byte value__;
    public static TokenKind ArgList;
    public static TokenKind MakeRef;
    public static TokenKind RefType;
    public static TokenKind RefValue;
    public static TokenKind As;
    public static TokenKind Base;
    public static TokenKind Checked;
    public static TokenKind Explicit;
    public static TokenKind False;
    public static TokenKind Implicit;
    public static TokenKind Is;
    public static TokenKind Null;
    public static TokenKind This;
    public static TokenKind True;
    public static TokenKind TypeOf;
    public static TokenKind Unchecked;
    public static TokenKind Void;
    public static TokenKind Equal;
    public static TokenKind PlusEqual;
    public static TokenKind MinusEqual;
    public static TokenKind SplatEqual;
    public static TokenKind SlashEqual;
    public static TokenKind PercentEqual;
    public static TokenKind AndEqual;
    public static TokenKind HatEqual;
    public static TokenKind BarEqual;
    public static TokenKind LeftShiftEqual;
    public static TokenKind RightShiftEqual;
    public static TokenKind Question;
    public static TokenKind Colon;
    public static TokenKind ColonColon;
    public static TokenKind LogicalOr;
    public static TokenKind LogicalAnd;
    public static TokenKind Bar;
    public static TokenKind Hat;
    public static TokenKind Ampersand;
    public static TokenKind EqualEqual;
    public static TokenKind NotEqual;
    public static TokenKind LessThan;
    public static TokenKind LessThanEqual;
    public static TokenKind GreaterThan;
    public static TokenKind GreaterThanEqual;
    public static TokenKind LeftShift;
    public static TokenKind RightShift;
    public static TokenKind Plus;
    public static TokenKind Minus;
    public static TokenKind Splat;
    public static TokenKind Slash;
    public static TokenKind Percent;
    public static TokenKind Tilde;
    public static TokenKind Bang;
    public static TokenKind PlusPlus;
    public static TokenKind MinusMinus;
    public static TokenKind Dot;
    public static TokenKind QuestionQuestion;
    public static TokenKind Unknown;
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int Combine(int h1, int h2);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal class System.Runtime.InteropServices.ComEventsMethod : object {
    private DelegateWrapper[] _delegateWrappers;
    private int _dispid;
    private ComEventsMethod _next;
    public bool Empty { get; }
    public ComEventsMethod(int dispid);
    public static ComEventsMethod Find(ComEventsMethod methods, int dispid);
    public static ComEventsMethod Add(ComEventsMethod methods, ComEventsMethod method);
    public static ComEventsMethod Remove(ComEventsMethod methods, ComEventsMethod method);
    public bool get_Empty();
    public void AddDelegate(Delegate d, bool wrapArgs);
    public void RemoveDelegate(Delegate d, bool wrapArgs);
    public void RemoveDelegates(Func`2<Delegate, bool> condition);
    public object Invoke(Object[] args);
    private bool PublishNewWrappers(DelegateWrapper[] newWrappers, DelegateWrapper[] currentMaybe);
}
[SupportedOSPlatformAttribute("windows")]
internal class System.Runtime.InteropServices.ComEventsSink : object {
    private Guid _iidSourceItf;
    private IConnectionPoint _connectionPoint;
    private int _cookie;
    private ComEventsMethod _methods;
    private ComEventsSink _next;
    private static VarEnum VT_BYREF_VARIANT;
    private static VarEnum VT_TYPEMASK;
    private static VarEnum VT_BYREF_TYPEMASK;
    public ComEventsSink(object rcw, Guid iid);
    public static ComEventsSink Find(ComEventsSink sinks, Guid& iid);
    public static ComEventsSink Add(ComEventsSink sinks, ComEventsSink sink);
    public static ComEventsSink RemoveAll(ComEventsSink sinks);
    public static ComEventsSink Remove(ComEventsSink sinks, ComEventsSink sink);
    public ComEventsMethod RemoveMethod(ComEventsMethod method);
    public ComEventsMethod FindMethod(int dispid);
    public ComEventsMethod AddMethod(int dispid);
    private sealed virtual override int System.Runtime.InteropServices.IDispatch.GetTypeInfoCount();
    private sealed virtual override ITypeInfo System.Runtime.InteropServices.IDispatch.GetTypeInfo(int iTInfo, int lcid);
    private sealed virtual override void System.Runtime.InteropServices.IDispatch.GetIDsOfNames(Guid& iid, String[] names, int cNames, int lcid, Int32[] rgDispId);
    private static Variant& GetVariant(Variant& pSrc);
    private sealed virtual override void System.Runtime.InteropServices.IDispatch.Invoke(int dispid, Guid& riid, int lcid, InvokeFlags wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    private void Advise(object rcw);
    private void Unadvise();
    private void Initialize(object rcw, Guid iid);
    [RequiresUnreferencedCodeAttribute("Using dynamic types might cause types or members to be removed by trimmer.")]
public void AddHandler(int dispid, object func);
    public void RemoveHandler(int dispid, object func);
    public static ComEventsSink FromRuntimeCallableWrapper(object rcw, Guid sourceIid, bool createIfNotFound);
}
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.IDispatch {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual ITypeInfo GetTypeInfo(int iTInfo, int lcid);
    public abstract virtual void GetIDsOfNames(Guid& riid, String[] rgszNames, int cNames, int lcid, Int32[] rgDispId);
    public abstract virtual void Invoke(int dispIdMember, Guid& riid, int lcid, InvokeFlags wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.InvokeFlags : Enum {
    public short value__;
    public static InvokeFlags DISPATCH_METHOD;
    public static InvokeFlags DISPATCH_PROPERTYGET;
    public static InvokeFlags DISPATCH_PROPERTYPUT;
    public static InvokeFlags DISPATCH_PROPERTYPUTREF;
}
[SupportedOSPlatformAttribute("windows")]
internal class System.Runtime.InteropServices.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; public set; }
    public bool IsEmpty { get; }
    public bool IsByRef { get; }
    public sbyte AsI1 { get; public set; }
    public short AsI2 { get; public set; }
    public int AsI4 { get; public set; }
    public long AsI8 { get; public set; }
    public byte AsUi1 { get; public set; }
    public ushort AsUi2 { get; public set; }
    public UInt32 AsUi4 { get; public set; }
    public ulong AsUi8 { get; public set; }
    public int AsInt { get; public set; }
    public UInt32 AsUint { get; public set; }
    public bool AsBool { get; public set; }
    public int AsError { get; public set; }
    public float AsR4 { get; public set; }
    public double AsR8 { get; public set; }
    public decimal AsDecimal { get; public set; }
    public decimal AsCy { get; public set; }
    public DateTime AsDate { get; public set; }
    public string AsBstr { get; public set; }
    public object AsUnknown { get; public set; }
    public object AsDispatch { get; public set; }
    public IntPtr AsByRefVariant { get; }
    public object AsVariant { get; public set; }
    public static bool IsPrimitiveType(VarEnum varEnum);
    public void CopyFromIndirect(object value);
    public object ToObject();
    public void Clear();
    public VarEnum get_VariantType();
    public void set_VariantType(VarEnum value);
    public bool get_IsEmpty();
    public bool get_IsByRef();
    public void SetAsNULL();
    public sbyte get_AsI1();
    public void set_AsI1(sbyte value);
    public short get_AsI2();
    public void set_AsI2(short value);
    public int get_AsI4();
    public void set_AsI4(int value);
    public long get_AsI8();
    public void set_AsI8(long value);
    public byte get_AsUi1();
    public void set_AsUi1(byte value);
    public ushort get_AsUi2();
    public void set_AsUi2(ushort value);
    public UInt32 get_AsUi4();
    public void set_AsUi4(UInt32 value);
    public ulong get_AsUi8();
    public void set_AsUi8(ulong value);
    public int get_AsInt();
    public void set_AsInt(int value);
    public UInt32 get_AsUint();
    public void set_AsUint(UInt32 value);
    public bool get_AsBool();
    public void set_AsBool(bool value);
    public int get_AsError();
    public void set_AsError(int value);
    public float get_AsR4();
    public void set_AsR4(float value);
    public double get_AsR8();
    public void set_AsR8(double value);
    public decimal get_AsDecimal();
    public void set_AsDecimal(decimal value);
    public decimal get_AsCy();
    public void set_AsCy(decimal value);
    public DateTime get_AsDate();
    public void set_AsDate(DateTime value);
    public string get_AsBstr();
    public void set_AsBstr(string value);
    public object get_AsUnknown();
    public void set_AsUnknown(object value);
    public object get_AsDispatch();
    public void set_AsDispatch(object value);
    public IntPtr get_AsByRefVariant();
    public void SetAsByrefI1(SByte& value);
    public void SetAsByrefI2(Int16& value);
    public void SetAsByrefI4(Int32& value);
    public void SetAsByrefI8(Int64& value);
    public void SetAsByrefUi1(Byte& value);
    public void SetAsByrefUi2(UInt16& value);
    public void SetAsByrefUi4(UInt32& value);
    public void SetAsByrefUi8(UInt64& value);
    public void SetAsByrefInt(Int32& value);
    public void SetAsByrefUint(UInt32& value);
    public void SetAsByrefBool(Int16& value);
    public void SetAsByrefError(Int32& value);
    public void SetAsByrefR4(Single& value);
    public void SetAsByrefR8(Double& value);
    public void SetAsByrefDecimal(Decimal& value);
    public void SetAsByrefCy(Int64& value);
    public void SetAsByrefDate(Double& value);
    public void SetAsByrefBstr(IntPtr& value);
    public void SetAsByrefUnknown(IntPtr& value);
    public void SetAsByrefDispatch(IntPtr& value);
    public object get_AsVariant();
    public void set_AsVariant(object value);
    public void SetAsByrefVariant(Variant& value);
    public void SetAsByrefVariantIndirect(Variant& value);
    private void SetAsByref(T& value, VarEnum type);
    internal static PropertyInfo GetAccessor(VarEnum varType);
    internal static MethodInfo GetByrefSetter(VarEnum varType);
    public virtual string ToString();
    public void SetAsIConvertible(IConvertible value);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string InternalCompilerError { get; }
    internal static string BindPropertyFailedMethodGroup { get; }
    internal static string BindPropertyFailedEvent { get; }
    internal static string BindInvokeFailedNonDelegate { get; }
    internal static string NullReferenceOnMemberException { get; }
    internal static string BindCallToConditionalMethod { get; }
    internal static string BindToVoidMethodButExpectResult { get; }
    internal static string EmptyDynamicView { get; }
    internal static string GetValueonWriteOnlyProperty { get; }
    internal static string BadBinaryOps { get; }
    internal static string BadIndexLHS { get; }
    internal static string BadIndexCount { get; }
    internal static string BadUnaryOp { get; }
    internal static string NoImplicitConv { get; }
    internal static string NoExplicitConv { get; }
    internal static string ConstOutOfRange { get; }
    internal static string AmbigBinaryOps { get; }
    internal static string AmbigUnaryOp { get; }
    internal static string ValueCantBeNull { get; }
    internal static string NoSuchMember { get; }
    internal static string ObjectRequired { get; }
    internal static string AmbigCall { get; }
    internal static string BadAccess { get; }
    internal static string AssgLvalueExpected { get; }
    internal static string NoConstructors { get; }
    internal static string PropertyLacksGet { get; }
    internal static string ObjectProhibited { get; }
    internal static string AssgReadonly { get; }
    internal static string AssgReadonlyStatic { get; }
    internal static string AssgReadonlyProp { get; }
    internal static string UnsafeNeeded { get; }
    internal static string BadBoolOp { get; }
    internal static string MustHaveOpTF { get; }
    internal static string ConstOutOfRangeChecked { get; }
    internal static string AmbigMember { get; }
    internal static string NoImplicitConvCast { get; }
    internal static string InaccessibleGetter { get; }
    internal static string InaccessibleSetter { get; }
    internal static string BadArity { get; }
    internal static string TypeArgsNotAllowed { get; }
    internal static string HasNoTypeVars { get; }
    internal static string NewConstraintNotSatisfied { get; }
    internal static string GenericConstraintNotSatisfiedRefType { get; }
    internal static string GenericConstraintNotSatisfiedNullableEnum { get; }
    internal static string GenericConstraintNotSatisfiedNullableInterface { get; }
    internal static string GenericConstraintNotSatisfiedValType { get; }
    internal static string CantInferMethTypeArgs { get; }
    internal static string RefConstraintNotSatisfied { get; }
    internal static string ValConstraintNotSatisfied { get; }
    internal static string AmbigUDConv { get; }
    internal static string BindToBogus { get; }
    internal static string CantCallSpecialMethod { get; }
    internal static string ConvertToStaticClass { get; }
    internal static string IncrementLvalueExpected { get; }
    internal static string BadArgCount { get; }
    internal static string BadArgTypes { get; }
    internal static string BadProtectedAccess { get; }
    internal static string BindToBogusProp2 { get; }
    internal static string BindToBogusProp1 { get; }
    internal static string BadDelArgCount { get; }
    internal static string BadDelArgTypes { get; }
    internal static string BadCtorArgCount { get; }
    internal static string NonInvocableMemberCalled { get; }
    internal static string BadNamedArgument { get; }
    internal static string BadNamedArgumentForDelegateInvoke { get; }
    internal static string DuplicateNamedArgument { get; }
    internal static string NamedArgumentUsedInPositional { get; }
    internal static string TypeArgumentRequiredForStaticCall { get; }
    internal static string DynamicArgumentNeedsValue { get; }
    internal static string BadNonTrailingNamedArgument { get; }
    internal static string DynamicBindingComUnsupported { get; }
    internal static string COMAmbiguousConversion { get; }
    internal static string COMCannotPerformCall { get; }
    internal static string COMCannotRetrieveTypeInfo { get; }
    internal static string COMDispatchInvokeError { get; }
    internal static string COMDispatchInvokeErrorNoNamedArgs { get; }
    internal static string COMDispatchInvokeErrorParamNotOptional { get; }
    internal static string COMDispatchInvokeErrorTypeMismatch { get; }
    internal static string COMGetDispatchIdFailed { get; }
    internal static string COMGetIDsOfNamesInvalid { get; }
    internal static string COMSetComObjectDataFailed { get; }
    internal static string COMUnexpectedVarEnum { get; }
    internal static string COMUnsupportedEventHandlerType { get; }
    internal static string UnsupportedEnum { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_InternalCompilerError();
    internal static string get_BindPropertyFailedMethodGroup();
    internal static string get_BindPropertyFailedEvent();
    internal static string get_BindInvokeFailedNonDelegate();
    internal static string get_NullReferenceOnMemberException();
    internal static string get_BindCallToConditionalMethod();
    internal static string get_BindToVoidMethodButExpectResult();
    internal static string get_EmptyDynamicView();
    internal static string get_GetValueonWriteOnlyProperty();
    internal static string get_BadBinaryOps();
    internal static string get_BadIndexLHS();
    internal static string get_BadIndexCount();
    internal static string get_BadUnaryOp();
    internal static string get_NoImplicitConv();
    internal static string get_NoExplicitConv();
    internal static string get_ConstOutOfRange();
    internal static string get_AmbigBinaryOps();
    internal static string get_AmbigUnaryOp();
    internal static string get_ValueCantBeNull();
    internal static string get_NoSuchMember();
    internal static string get_ObjectRequired();
    internal static string get_AmbigCall();
    internal static string get_BadAccess();
    internal static string get_AssgLvalueExpected();
    internal static string get_NoConstructors();
    internal static string get_PropertyLacksGet();
    internal static string get_ObjectProhibited();
    internal static string get_AssgReadonly();
    internal static string get_AssgReadonlyStatic();
    internal static string get_AssgReadonlyProp();
    internal static string get_UnsafeNeeded();
    internal static string get_BadBoolOp();
    internal static string get_MustHaveOpTF();
    internal static string get_ConstOutOfRangeChecked();
    internal static string get_AmbigMember();
    internal static string get_NoImplicitConvCast();
    internal static string get_InaccessibleGetter();
    internal static string get_InaccessibleSetter();
    internal static string get_BadArity();
    internal static string get_TypeArgsNotAllowed();
    internal static string get_HasNoTypeVars();
    internal static string get_NewConstraintNotSatisfied();
    internal static string get_GenericConstraintNotSatisfiedRefType();
    internal static string get_GenericConstraintNotSatisfiedNullableEnum();
    internal static string get_GenericConstraintNotSatisfiedNullableInterface();
    internal static string get_GenericConstraintNotSatisfiedValType();
    internal static string get_CantInferMethTypeArgs();
    internal static string get_RefConstraintNotSatisfied();
    internal static string get_ValConstraintNotSatisfied();
    internal static string get_AmbigUDConv();
    internal static string get_BindToBogus();
    internal static string get_CantCallSpecialMethod();
    internal static string get_ConvertToStaticClass();
    internal static string get_IncrementLvalueExpected();
    internal static string get_BadArgCount();
    internal static string get_BadArgTypes();
    internal static string get_BadProtectedAccess();
    internal static string get_BindToBogusProp2();
    internal static string get_BindToBogusProp1();
    internal static string get_BadDelArgCount();
    internal static string get_BadDelArgTypes();
    internal static string get_BadCtorArgCount();
    internal static string get_NonInvocableMemberCalled();
    internal static string get_BadNamedArgument();
    internal static string get_BadNamedArgumentForDelegateInvoke();
    internal static string get_DuplicateNamedArgument();
    internal static string get_NamedArgumentUsedInPositional();
    internal static string get_TypeArgumentRequiredForStaticCall();
    internal static string get_DynamicArgumentNeedsValue();
    internal static string get_BadNonTrailingNamedArgument();
    internal static string get_DynamicBindingComUnsupported();
    internal static string get_COMAmbiguousConversion();
    internal static string get_COMCannotPerformCall();
    internal static string get_COMCannotRetrieveTypeInfo();
    internal static string get_COMDispatchInvokeError();
    internal static string get_COMDispatchInvokeErrorNoNamedArgs();
    internal static string get_COMDispatchInvokeErrorParamNotOptional();
    internal static string get_COMDispatchInvokeErrorTypeMismatch();
    internal static string get_COMGetDispatchIdFailed();
    internal static string get_COMGetIDsOfNamesInvalid();
    internal static string get_COMSetComObjectDataFailed();
    internal static string get_COMUnexpectedVarEnum();
    internal static string get_COMUnsupportedEventHandlerType();
    internal static string get_UnsupportedEnum();
}
