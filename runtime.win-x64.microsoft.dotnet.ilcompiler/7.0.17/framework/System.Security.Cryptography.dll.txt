internal static class FxResources.System.Security.Cryptography.SR : object {
}
internal static class Internal.Cryptography.AesBCryptModes : object {
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCbc;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgEcb;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb128;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb8;
    private static AesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode, int feedback);
    internal static Lazy`1<SafeAlgorithmHandle> OpenAesAlgorithm(string cipherMode, int feedback);
}
internal static class Internal.Cryptography.BCryptAeadHandleCache : object {
    private static SafeAlgorithmHandle s_aesCcm;
    private static SafeAlgorithmHandle s_aesGcm;
    private static SafeAlgorithmHandle s_chaCha20Poly1305;
    [CompilerGeneratedAttribute]
private static bool <IsChaCha20Poly1305Supported>k__BackingField;
    internal static SafeAlgorithmHandle AesCcm { get; }
    internal static SafeAlgorithmHandle AesGcm { get; }
    internal static bool IsChaCha20Poly1305Supported { get; }
    internal static SafeAlgorithmHandle ChaCha20Poly1305 { get; }
    private static BCryptAeadHandleCache();
    internal static SafeAlgorithmHandle get_AesCcm();
    internal static SafeAlgorithmHandle get_AesGcm();
    [CompilerGeneratedAttribute]
internal static bool get_IsChaCha20Poly1305Supported();
    internal static SafeAlgorithmHandle get_ChaCha20Poly1305();
    private static SafeAlgorithmHandle GetCachedAlgorithmHandle(SafeAlgorithmHandle& handle, string algId, string chainingMode);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
internal static class Internal.Cryptography.DesBCryptModes : object {
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCbc;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgEcb;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb8;
    private static DesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode, int feedback);
    private static Lazy`1<SafeAlgorithmHandle> OpenDesAlgorithm(string cipherMode);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [CompilerGeneratedAttribute]
private static bool <HasSymmetricEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasMD5>k__BackingField;
    [UnsupportedOSPlatformGuardAttribute("browser")]
internal static bool HasSymmetricEncryption { get; }
    [UnsupportedOSPlatformGuardAttribute("ios")]
[UnsupportedOSPlatformGuardAttribute("tvos")]
public static bool IsDSASupported { get; }
    [UnsupportedOSPlatformGuardAttribute("android")]
[UnsupportedOSPlatformGuardAttribute("browser")]
public static bool IsRC2Supported { get; }
    [UnsupportedOSPlatformGuardAttribute("browser")]
internal static bool HasMD5 { get; }
    private static Helpers();
    [CompilerGeneratedAttribute]
internal static bool get_HasSymmetricEncryption();
    public static bool get_IsDSASupported();
    public static bool get_IsRC2Supported();
    [CompilerGeneratedAttribute]
internal static bool get_HasMD5();
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
internal static bool TryCopyToDestination(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    internal static int HashOidToByteLength(string hashOid);
    [ExtensionAttribute]
internal static void AddRange(ICollection`1<T> coll, IEnumerable`1<T> newData);
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    [ExtensionAttribute]
public static Byte[] FixupKeyParity(Byte[] key);
    [ExtensionAttribute]
internal static Char[] ToHexArrayUpper(Byte[] bytes);
    [ExtensionAttribute]
internal static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] LaxDecodeHexString(string hexString);
    [ExtensionAttribute]
internal static bool ContentsEqual(Byte[] a1, Byte[] a2);
    internal static ReadOnlyMemory`1<byte> DecodeOctetStringAsMemory(ReadOnlyMemory`1<byte> encodedOctetString);
    internal static bool AreSamePublicECParameters(ECParameters aParameters, ECParameters bParameters);
    [ExtensionAttribute]
internal static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year, int era);
    internal static void ValidateDer(ReadOnlySpan`1<byte> encodedValue);
    [ExtensionAttribute]
public static int GetPaddingSize(SymmetricAlgorithm algorithm, CipherMode mode, int feedbackSizeInBits);
    [ExtensionAttribute]
public static SafeHandle ToLpstrArray(OidCollection oids, Int32& numOids);
    [ExtensionAttribute]
public static Byte[] ValueAsAscii(Oid oid);
    [ExtensionAttribute]
public static TResult DecodeObject(Byte[] encoded, CryptDecodeObjectStructType lpszStructType, DecodedObjectReceiver`1<TResult> receiver);
    [ExtensionAttribute]
public static TResult DecodeObject(Byte[] encoded, string lpszStructType, DecodedObjectReceiver`1<TResult> receiver);
    [ExtensionAttribute]
public static bool DecodeObjectNoThrow(ReadOnlySpan`1<byte> encoded, CryptDecodeObjectStructType lpszStructType, TState state, DecodedObjectReceiver`2<TState, TResult> receiver, TResult& result);
}
internal static class Internal.Cryptography.RC2BCryptModes : object {
    internal static SafeAlgorithmHandle GetHandle(CipherMode cipherMode, int effectiveKeyLength);
    private static SafeAlgorithmHandle OpenRC2Algorithm(string cipherMode, int effectiveKeyLength);
}
internal static class Internal.Cryptography.TripleDesBCryptModes : object {
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCbc;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgEcb;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb8;
    private static Lazy`1<SafeAlgorithmHandle> s_hAlgCfb64;
    private static TripleDesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode, int feedback);
    private static Lazy`1<SafeAlgorithmHandle> Open3DesAlgorithm(string cipherMode, int feedback);
}
[ExtensionAttribute]
internal static class Internal.NativeCrypto.Cng : object {
    public static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, OpenAlgorithmProviderFlags dwFlags);
    [ExtensionAttribute]
public static void SetFeedbackSize(SafeAlgorithmHandle hAlg, int dwFeedbackSize);
    [ExtensionAttribute]
public static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode);
    [ExtensionAttribute]
public static void SetEffectiveKeyLength(SafeAlgorithmHandle hAlg, int effectiveKeyLength);
    private static Exception CreateCryptographicException(NTSTATUS ntStatus);
}
internal class Internal.NativeCrypto.SafeAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
    [LibraryImportAttribute("BCrypt.dll")]
private static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
}
internal class Internal.NativeCrypto.SafeKeyHandle : SafeBCryptHandle {
    private SafeAlgorithmHandle _parentHandle;
    public void SetParentHandle(SafeAlgorithmHandle parentHandle);
    protected sealed virtual bool ReleaseHandle();
    [LibraryImportAttribute("BCrypt.dll")]
private static UInt32 BCryptDestroyKey(IntPtr hKey);
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptHashHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeCertContextHandle : SafeCrypt32Handle`1<SafeCertContextHandle> {
    private SafeCertContextHandle _parent;
    public CERT_CONTEXT* CertContext { get; }
    public bool HasPersistedPrivateKey { get; }
    public bool HasEphemeralPrivateKey { get; }
    public bool ContainsPrivateKey { get; }
    public SafeCertContextHandle(SafeCertContextHandle parent);
    protected virtual bool ReleaseHandle();
    public CERT_CONTEXT* get_CertContext();
    public CERT_CONTEXT* Disconnect();
    public bool get_HasPersistedPrivateKey();
    public bool get_HasEphemeralPrivateKey();
    public bool get_ContainsPrivateKey();
    public SafeCertContextHandle Duplicate();
    private bool CertHasProperty(CertContextPropId propertyId);
}
internal class Microsoft.Win32.SafeHandles.SafeCertContextHandleWithKeyContainerDeletion : SafeCertContextHandle {
    protected sealed virtual bool ReleaseHandle();
    internal static void DeleteKeyContainer(SafeCertContextHandle pCertContext);
}
internal class Microsoft.Win32.SafeHandles.SafeCertStoreHandle : SafeCrypt32Handle`1<SafeCertStoreHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeChainEngineHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public static SafeChainEngineHandle MachineChainEngine;
    public static SafeChainEngineHandle UserChainEngine;
    private SafeChainEngineHandle(IntPtr handle);
    private static SafeChainEngineHandle();
    protected sealed virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Microsoft.Win32.SafeHandles.SafeCrypt32Handle`1 : SafeHandle {
    public bool IsInvalid { get; }
    public static T InvalidHandle { get; }
    public sealed virtual bool get_IsInvalid();
    public static T get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Win32.SafeHandles.SafeCryptMsgHandle : SafeCrypt32Handle`1<SafeCryptMsgHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private OwnershipState _ownershipState;
    private SafeNCryptHandle _holder;
    private SafeHandle _parentHandle;
    [NullableAttribute("2")]
private SafeNCryptHandle Holder { get; private set; }
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
    private SafeNCryptHandle get_Holder();
    private void set_Holder(SafeNCryptHandle value);
    internal T Duplicate();
    private T DuplicateDuplicatedHandle();
    private T DuplicateOwnerHandle();
    protected virtual bool ReleaseHandle();
    protected abstract virtual bool ReleaseNativeHandle();
    internal bool ReleaseNativeWithNCryptFreeObject();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
    internal SafeNCryptKeyHandle Duplicate();
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    internal SafeNCryptProviderHandle Duplicate();
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
internal class Microsoft.Win32.SafeHandles.SafePasswordHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PasswordProvided>k__BackingField;
    unknown int Length {private set; }
    internal bool PasswordProvided { get; }
    public static SafePasswordHandle InvalidHandle { get; }
    public SafePasswordHandle(string password, bool passwordProvided);
    public SafePasswordHandle(ReadOnlySpan`1<char> password, bool passwordProvided);
    public SafePasswordHandle(SecureString password, bool passwordProvided);
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
internal bool get_PasswordProvided();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    public static SafePasswordHandle get_InvalidHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeUnicodeStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    public SafeUnicodeStringHandle(string s);
    public SafeUnicodeStringHandle(ReadOnlySpan`1<char> s);
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [NullableAttribute("1")]
internal static SafeX509ChainHandle InvalidHandle { get; }
    internal static SafeX509ChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Formats.Asn1.AsnValueReader : ValueType {
    private static Byte[] s_singleByte;
    private ReadOnlySpan`1<byte> _span;
    private AsnEncodingRules _ruleSet;
    internal bool HasData { get; }
    internal AsnValueReader(ReadOnlySpan`1<byte> span, AsnEncodingRules ruleSet);
    private static AsnValueReader();
    internal bool get_HasData();
    internal void ThrowIfNotEmpty();
    internal Asn1Tag PeekTag();
    internal ReadOnlySpan`1<byte> PeekContentBytes();
    internal ReadOnlySpan`1<byte> PeekEncodedValue();
    internal ReadOnlySpan`1<byte> ReadEncodedValue();
    internal bool ReadBoolean(Nullable`1<Asn1Tag> expectedTag);
    internal BigInteger ReadInteger(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadInt32(Int32& value, Nullable`1<Asn1Tag> expectedTag);
    internal ReadOnlySpan`1<byte> ReadIntegerBytes(Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveBitString(Int32& unusedBitCount, ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadBitString(Int32& unusedBitCount, Nullable`1<Asn1Tag> expectedTag);
    internal bool TryReadPrimitiveOctetString(ReadOnlySpan`1& value, Nullable`1<Asn1Tag> expectedTag);
    internal Byte[] ReadOctetString(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadObjectIdentifier(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSequence(Nullable`1<Asn1Tag> expectedTag);
    internal AsnValueReader ReadSetOf(Nullable`1<Asn1Tag> expectedTag, bool skipSortOrderValidation);
    internal DateTimeOffset ReadUtcTime(Nullable`1<Asn1Tag> expectedTag);
    internal DateTimeOffset ReadGeneralizedTime(Nullable`1<Asn1Tag> expectedTag);
    internal string ReadCharacterString(UniversalTagNumber encodingType, Nullable`1<Asn1Tag> expectedTag);
}
[ExtensionAttribute]
internal static class System.Formats.Asn1.AsnWriterExtensions : object {
    [ExtensionAttribute]
internal static void WriteEncodedValueForCrypto(AsnWriter writer, ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
internal static void WriteObjectIdentifierForCrypto(AsnWriter writer, string value);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.LocalAppContextSwitches : object {
    [CompilerGeneratedAttribute]
private static long <Pkcs12UnspecifiedPasswordIterationLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <X509ChainBuildThrowOnInternalError>k__BackingField;
    internal static long Pkcs12UnspecifiedPasswordIterationLimit { get; }
    internal static bool X509ChainBuildThrowOnInternalError { get; }
    private static LocalAppContextSwitches();
    [CompilerGeneratedAttribute]
internal static long get_Pkcs12UnspecifiedPasswordIterationLimit();
    [CompilerGeneratedAttribute]
internal static bool get_X509ChainBuildThrowOnInternalError();
    private static long InitializePkcs12UnspecifiedPasswordIterationLimit();
    private static bool InitializeX509ChainBuildThrowOnInternalError();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.Security.Cryptography.AeadCommon : object {
    public static void Encrypt(SafeKeyHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag);
    public static void Decrypt(SafeKeyHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, bool clearPlaintextOnFailure);
    private static Byte& modreq(System.Runtime.InteropServices.InAttribute) GetNonNullPinnableReference(ReadOnlySpan`1<byte> buffer);
    private static Byte& GetNonNullPinnableReference(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Aes();
    [UnsupportedOSPlatformAttribute("browser")]
public static Aes Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static Aes Create(string algorithmName);
}
internal static class System.Security.Cryptography.AesAEAD : object {
    public static void CheckKeySize(int keySizeInBytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.AesCcm : object {
    [CompilerGeneratedAttribute]
private static KeySizes <NonceByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeySizes <TagByteSizes>k__BackingField;
    private SafeKeyHandle _keyHandle;
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public static bool IsSupported { get; }
    [NullableContextAttribute("0")]
public AesCcm(ReadOnlySpan`1<byte> key);
    public AesCcm(Byte[] key);
    private static AesCcm();
    [CompilerGeneratedAttribute]
public static KeySizes get_NonceByteSizes();
    [CompilerGeneratedAttribute]
public static KeySizes get_TagByteSizes();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private static void ThrowIfNotSupported();
    public static bool get_IsSupported();
    [MemberNotNullAttribute("_keyHandle")]
private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AesCng : Aes {
    private CngSymmetricAlgorithmCore _core;
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    private Byte[] System.Security.Cryptography.ICngSymmetricAlgorithm.BaseKey { get; private set; }
    private int System.Security.Cryptography.ICngSymmetricAlgorithm.BaseKeySize { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override Byte[] System.Security.Cryptography.ICngSymmetricAlgorithm.get_BaseKey();
    private sealed virtual override void System.Security.Cryptography.ICngSymmetricAlgorithm.set_BaseKey(Byte[] value);
    private sealed virtual override int System.Security.Cryptography.ICngSymmetricAlgorithm.get_BaseKeySize();
    private sealed virtual override void System.Security.Cryptography.ICngSymmetricAlgorithm.set_BaseKeySize(int value);
    private sealed virtual override bool System.Security.Cryptography.ICngSymmetricAlgorithm.IsWeakKey(Byte[] key);
    private sealed virtual override int System.Security.Cryptography.ICngSymmetricAlgorithm.GetPaddingSize(CipherMode mode, int feedbackSizeBits);
    private sealed virtual override SafeAlgorithmHandle System.Security.Cryptography.ICngSymmetricAlgorithm.GetEphemeralModeHandle(CipherMode mode, int feedbackSizeInBits);
    private sealed virtual override string System.Security.Cryptography.ICngSymmetricAlgorithm.GetNCryptAlgorithmIdentifier();
    private sealed virtual override Byte[] System.Security.Cryptography.ICngSymmetricAlgorithm.PreprocessKey(Byte[] key);
    private sealed virtual override bool System.Security.Cryptography.ICngSymmetricAlgorithm.IsValidEphemeralFeedbackSize(int feedbackSizeInBits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    private Aes _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.AesGcm : object {
    [CompilerGeneratedAttribute]
private static KeySizes <NonceByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeySizes <TagByteSizes>k__BackingField;
    private SafeKeyHandle _keyHandle;
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public static bool IsSupported { get; }
    [NullableContextAttribute("0")]
public AesGcm(ReadOnlySpan`1<byte> key);
    public AesGcm(Byte[] key);
    private static AesGcm();
    [CompilerGeneratedAttribute]
public static KeySizes get_NonceByteSizes();
    [CompilerGeneratedAttribute]
public static KeySizes get_TagByteSizes();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    [NullableContextAttribute("0")]
public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private static void ThrowIfNotSupported();
    public static bool get_IsSupported();
    [MemberNotNullAttribute("_keyHandle")]
private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
}
internal class System.Security.Cryptography.AesImplementation : Aes {
    public sealed virtual ICryptoTransform CreateDecryptor();
    public sealed virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual ICryptoTransform CreateEncryptor();
    public sealed virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    protected sealed virtual void Dispose(bool disposing);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private static void ValidateCFBFeedbackSize(int feedback);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int paddingSize, int feedbackSize, bool encrypting);
    private static ILiteSymmetricCipher CreateLiteCipher(CipherMode cipherMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int paddingSize, int feedbackSize, bool encrypting);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.AesManaged : Aes {
    private Aes _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal string Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AlgorithmIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AlgorithmIdentifierAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AlgorithmIdentifierAsn& decoded);
    [IsReadOnlyAttribute]
internal bool HasNullEquivalentParameters();
    internal static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal string AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    public AttributeAsn(AsnEncodedData attribute);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AttributeAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.CurveAsn : ValueType {
    internal ReadOnlyMemory`1<byte> A;
    internal ReadOnlyMemory`1<byte> B;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Seed;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CurveAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DigestInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn DigestAlgorithm;
    internal ReadOnlyMemory`1<byte> Digest;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DigestInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DirectoryStringAsn : ValueType {
    internal string TeletexString;
    internal string PrintableString;
    internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString;
    internal string Utf8String;
    internal string BmpString;
    internal void Encode(AsnWriter writer);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DirectoryStringAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, DirectoryStringAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DssParms : ValueType {
    internal BigInteger P;
    internal BigInteger Q;
    internal BigInteger G;
    internal static DssParms Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static DssParms Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, DssParms& decoded);
}
internal class System.Security.Cryptography.Asn1.ECDomainParameters : ValueType {
    internal Nullable`1<SpecifiedECDomain> Specified;
    internal string Named;
    internal void Encode(AsnWriter writer);
    internal static ECDomainParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECDomainParameters& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ECDomainParameters& decoded);
}
internal class System.Security.Cryptography.Asn1.ECPrivateKey : ValueType {
    internal int Version;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal Nullable`1<ECDomainParameters> Parameters;
    internal Nullable`1<ReadOnlyMemory`1<byte>> PublicKey;
    internal static ECPrivateKey Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static ECPrivateKey Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ECPrivateKey& decoded);
}
internal class System.Security.Cryptography.Asn1.EdiPartyNameAsn : ValueType {
    internal Nullable`1<DirectoryStringAsn> NameAssigner;
    internal DirectoryStringAsn PartyName;
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EdiPartyNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.FieldID : ValueType {
    internal string FieldType;
    internal ReadOnlyMemory`1<byte> Parameters;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, FieldID& decoded);
}
internal class System.Security.Cryptography.Asn1.GeneralNameAsn : ValueType {
    internal Nullable`1<OtherNameAsn> OtherName;
    internal string Rfc822Name;
    internal string DnsName;
    internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address;
    internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName;
    internal Nullable`1<EdiPartyNameAsn> EdiPartyName;
    internal string Uri;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress;
    internal string RegisteredId;
    internal void Encode(AsnWriter writer);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, GeneralNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, GeneralNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.OtherNameAsn : ValueType {
    internal string TypeId;
    internal ReadOnlyMemory`1<byte> Value;
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, OtherNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<int> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static ReadOnlySpan`1<byte> DefaultPrf { get; }
    private static ReadOnlySpan`1<byte> get_DefaultPrf();
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.MacData : ValueType {
    internal DigestInfoAsn Mac;
    internal ReadOnlyMemory`1<byte> MacSalt;
    internal int IterationCount;
    private static ReadOnlySpan`1<byte> DefaultIterationCount { get; }
    private static ReadOnlySpan`1<byte> get_DefaultIterationCount();
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, MacData& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.PfxAsn : ValueType {
    internal int Version;
    internal ContentInfoAsn AuthSafe;
    internal Nullable`1<MacData> MacData;
    private static ReadOnlySpan`1<char> EmptyPassword { get; }
    private static ReadOnlySpan`1<char> NullPassword { get; }
    private static ReadOnlySpan`1<char> get_EmptyPassword();
    private static ReadOnlySpan`1<char> get_NullPassword();
    internal ulong CountTotalIterations();
    private static ArraySegment`1<byte> DecryptContentInfo(ContentInfoAsn contentInfo, UInt32& iterations);
    private static UInt32 IterationsFromParameters(AlgorithmIdentifierAsn& algorithmIdentifier);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PfxAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs12.SafeBagAsn : ValueType {
    internal string BagId;
    internal ReadOnlyMemory`1<byte> BagValue;
    internal AttributeAsn[] BagAttributes;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SafeBagAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.ContentInfoAsn : ValueType {
    internal string ContentType;
    internal ReadOnlyMemory`1<byte> Content;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.EncryptedContentInfoAsn : ValueType {
    internal string ContentType;
    internal AlgorithmIdentifierAsn ContentEncryptionAlgorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> EncryptedContent;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Pkcs7.EncryptedDataAsn : ValueType {
    internal int Version;
    internal EncryptedContentInfoAsn EncryptedContentInfo;
    internal AttributeAsn[] UnprotectedAttributes;
    internal static EncryptedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, EncryptedDataAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PrivateKeyInfoAsn : ValueType {
    internal int Version;
    internal AlgorithmIdentifierAsn PrivateKeyAlgorithm;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal AttributeAsn[] Attributes;
    internal static PrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PssParamsAsn : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal AlgorithmIdentifierAsn MaskGenAlgorithm;
    internal int SaltLength;
    internal int TrailerField;
    private static ReadOnlySpan`1<byte> DefaultHashAlgorithm { get; }
    private static ReadOnlySpan`1<byte> DefaultMaskGenAlgorithm { get; }
    private static ReadOnlySpan`1<byte> DefaultSaltLength { get; }
    private static ReadOnlySpan`1<byte> DefaultTrailerField { get; }
    internal RSASignaturePadding GetSignaturePadding(Nullable`1<int> digestValueLength);
    private static ReadOnlySpan`1<byte> get_DefaultHashAlgorithm();
    private static ReadOnlySpan`1<byte> get_DefaultMaskGenAlgorithm();
    private static ReadOnlySpan`1<byte> get_DefaultSaltLength();
    private static ReadOnlySpan`1<byte> get_DefaultTrailerField();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PssParamsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PssParamsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, PssParamsAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static Byte[] s_rc2EkbEncoding;
    private static Rc2CbcParameters();
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, Rc2CbcParameters& decoded);
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Asn1.RSAPrivateKeyAsn : ValueType {
    internal int Version;
    internal BigInteger Modulus;
    internal BigInteger PublicExponent;
    internal BigInteger PrivateExponent;
    internal BigInteger Prime1;
    internal BigInteger Prime2;
    internal BigInteger Exponent1;
    internal BigInteger Exponent2;
    internal BigInteger Coefficient;
    internal static RSAPrivateKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RSAPrivateKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, RSAPrivateKeyAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.RSAPublicKeyAsn : ValueType {
    internal BigInteger Modulus;
    internal BigInteger PublicExponent;
    internal static RSAPublicKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RSAPublicKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, RSAPublicKeyAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.SpecifiedECDomain : ValueType {
    internal int Version;
    internal FieldID FieldID;
    internal CurveAsn Curve;
    internal ReadOnlyMemory`1<byte> Base;
    internal ReadOnlyMemory`1<byte> Order;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Cofactor;
    internal string Hash;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SpecifiedECDomain& decoded);
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, SubjectPublicKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.X509ExtensionAsn : ValueType {
    internal string ExtnId;
    internal bool Critical;
    internal ReadOnlyMemory`1<byte> ExtnValue;
    private static ReadOnlySpan`1<byte> DefaultCritical { get; }
    public X509ExtensionAsn(X509Extension extension);
    private static ReadOnlySpan`1<byte> get_DefaultCritical();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, X509ExtensionAsn& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AsnEncodedData : object {
    private Oid _oid;
    private Byte[] _rawData;
    [NullableAttribute("2")]
public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    public AsnEncodedData(Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(ReadOnlySpan`1<byte> rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    public AsnEncodedData(string oid, Byte[] rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(Oid oid, ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("0")]
public AsnEncodedData(string oid, ReadOnlySpan`1<byte> rawData);
    internal AsnEncodedData(Oid oid, Byte[] rawData, bool skipCopy);
    [NullableContextAttribute("2")]
public Oid get_Oid();
    [NullableContextAttribute("2")]
public void set_Oid(Oid value);
    public Byte[] get_RawData();
    [MemberNotNullAttribute("_rawData")]
public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
    [MemberNotNullAttribute("_rawData")]
private void Reset(Oid oid, Byte[] rawData);
    [MemberNotNullAttribute("_rawData")]
private void Reset(Oid oid, ReadOnlySpan`1<byte> rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    private List`1<AsnEncodedData> _list;
    public AsnEncodedData Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public int Add(AsnEncodedData asnEncodedData);
    public void Remove(AsnEncodedData asnEncodedData);
    public AsnEncodedData get_Item(int index);
    public sealed virtual int get_Count();
    public AsnEncodedDataEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(AsnEncodedData[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    private AsnEncodedDataCollection _asnEncodedDatas;
    private int _current;
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal AsnEncodedDataEnumerator(AsnEncodedDataCollection asnEncodedDatas);
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal abstract class System.Security.Cryptography.AsnFormatter : object {
    private static AsnFormatter s_instance;
    internal static AsnFormatter Instance { get; }
    private static AsnFormatter();
    internal static AsnFormatter get_Instance();
    public string Format(Oid oid, Byte[] rawData, bool multiLine);
    protected abstract virtual string FormatNative(Oid oid, Byte[] rawData, bool multiLine);
}
public abstract class System.Security.Cryptography.AsymmetricAlgorithm : object {
    protected int KeySizeValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalKeySizesValue;
    public int KeySize { get; public set; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    [NullableAttribute("2")]
public string SignatureAlgorithm { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static AsymmetricAlgorithm Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static AsymmetricAlgorithm Create(string algName);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    [NullableContextAttribute("2")]
public virtual string get_SignatureAlgorithm();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    [NullableContextAttribute("1")]
public virtual void FromXmlString(string xmlString);
    [NullableContextAttribute("1")]
public virtual string ToXmlString(bool includePrivateParameters);
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportPkcs8PrivateKey();
    [NullableContextAttribute("1")]
public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("1")]
public string ExportPkcs8PrivateKeyPem();
    [NullableContextAttribute("1")]
public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public string ExportSubjectPublicKeyInfoPem();
    public bool TryExportSubjectPublicKeyInfoPem(Span`1<char> destination, Int32& charsWritten);
    public bool TryExportPkcs8PrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<char> destination, Int32& charsWritten);
    private static Byte[] ExportArray(ReadOnlySpan`1<T> password, PbeParameters pbeParameters, TryExportPbe`1<T> exporter);
    private static Byte[] ExportArray(TryExport exporter);
    [CompilerGeneratedAttribute]
private ImportKeyAction <ImportFromPem>b__33_0(ReadOnlySpan`1<char> label);
    [CompilerGeneratedAttribute]
internal static bool <TryExportSubjectPublicKeyInfoPem>g__Export|37_0(AsymmetricAlgorithm alg, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportPkcs8PrivateKeyPem>g__Export|38_0(AsymmetricAlgorithm alg, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportEncryptedPkcs8PrivateKeyPem>g__Export|39_0(AsymmetricAlgorithm alg, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.AsymmetricAlgorithmHelpers : object {
    public static Byte[] ConvertIeee1363ToDer(ReadOnlySpan`1<byte> input);
    internal static bool TryConvertIeee1363ToDer(ReadOnlySpan`1<byte> input, Span`1<byte> destination, Int32& bytesWritten);
    private static AsnWriter WriteIeee1363ToDer(ReadOnlySpan`1<byte> input);
    public static Byte[] ConvertDerToIeee1363(ReadOnlySpan`1<byte> input, int fieldSizeBits);
    internal static int ConvertDerToIeee1363(ReadOnlySpan`1<byte> input, int fieldSizeBits, Span`1<byte> destination);
    internal static int GetMaxDerSignatureSize(int fieldSizeBits);
    internal static Byte[] ConvertFromIeeeP1363Signature(Byte[] signature, DSASignatureFormat targetFormat);
    internal static Byte[] ConvertSignatureToIeeeP1363(DSASignatureFormat currentFormat, ReadOnlySpan`1<byte> signature, int fieldSizeBits);
    public static int BitsToBytes(int bitLength);
    private static void CopySignatureField(ReadOnlySpan`1<byte> signatureField, Span`1<byte> response);
    [ExtensionAttribute]
internal static Byte[] ConvertSignatureToIeeeP1363(DSA dsa, DSASignatureFormat currentFormat, ReadOnlySpan`1<byte> signature, int fieldSizeBits);
    [ExtensionAttribute]
internal static Byte[] ConvertSignatureToIeeeP1363(ECDsa ecdsa, DSASignatureFormat currentFormat, ReadOnlySpan`1<byte> signature);
    [CompilerGeneratedAttribute]
internal static int <GetMaxDerSignatureSize>g__GetDerLengthLength|5_0(int payloadLength);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    [NullableContextAttribute("1")]
public abstract virtual void SetKey(AsymmetricAlgorithm key);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    [NullableAttribute("2")]
public string Parameters { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_Parameters();
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
}
internal abstract class System.Security.Cryptography.BasicSymmetricCipher : object {
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaddingSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    public int BlockSizeInBytes { get; private set; }
    public int PaddingSizeInBytes { get; private set; }
    protected Byte[] IV { get; private set; }
    protected BasicSymmetricCipher(Byte[] iv, int blockSizeInBytes, int paddingSizeInBytes);
    public abstract virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    [CompilerGeneratedAttribute]
public int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_BlockSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public int get_PaddingSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_PaddingSizeInBytes(int value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
}
internal class System.Security.Cryptography.BasicSymmetricCipherBCrypt : BasicSymmetricCipher {
    private BasicSymmetricCipherLiteBCrypt _cipherLite;
    public BasicSymmetricCipherBCrypt(SafeAlgorithmHandle algorithm, CipherMode cipherMode, int blockSizeInBytes, int paddingSizeInBytes, ReadOnlySpan`1<byte> key, bool ownsParentHandle, Byte[] iv, bool encrypting);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
}
internal class System.Security.Cryptography.BasicSymmetricCipherCsp : BasicSymmetricCipher {
    private bool _encrypting;
    private SafeProvHandle _hProvider;
    private SafeCapiKeyHandle _hKey;
    public BasicSymmetricCipherCsp(int algId, CipherMode cipherMode, int blockSizeInBytes, Byte[] key, bool addNoSaltFlag, Byte[] iv, bool encrypting, int feedbackSize, int paddingSizeInBytes);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    private void Reset();
    private int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output, bool isFinal);
    private static SafeCapiKeyHandle ImportCspBlob(SafeProvHandle safeProvHandle, int algId, Byte[] rawKey, bool addNoSaltFlag);
    private static SafeProvHandle AcquireSafeProviderHandle();
}
internal class System.Security.Cryptography.BasicSymmetricCipherLiteBCrypt : object {
    private bool _encrypting;
    private SafeKeyHandle _hKey;
    private Byte[] _currentIv;
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaddingSizeInBytes>k__BackingField;
    public int BlockSizeInBytes { get; }
    public int PaddingSizeInBytes { get; }
    public BasicSymmetricCipherLiteBCrypt(SafeAlgorithmHandle algorithm, CipherMode cipherMode, int blockSizeInBytes, int paddingSizeInBytes, ReadOnlySpan`1<byte> key, bool ownsParentHandle, ReadOnlySpan`1<byte> iv, bool encrypting);
    [CompilerGeneratedAttribute]
public sealed virtual int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PaddingSizeInBytes();
    public sealed virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Reset(ReadOnlySpan`1<byte> iv);
    public sealed virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private int <Transform>g__BCryptTransform|10_0(ReadOnlySpan`1<byte> input, Span`1<byte> output);
}
internal class System.Security.Cryptography.BasicSymmetricCipherLiteNCrypt : object {
    private static CngProperty s_ECBMode;
    private static CngProperty s_CBCMode;
    private static CngProperty s_CFBMode;
    private bool _encrypting;
    private CngKey _key;
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PaddingSizeInBytes>k__BackingField;
    public int BlockSizeInBytes { get; }
    public int PaddingSizeInBytes { get; }
    public BasicSymmetricCipherLiteNCrypt(Func`1<CngKey> cngKeyFactory, CipherMode cipherMode, int blockSizeInBytes, ReadOnlySpan`1<byte> iv, bool encrypting, int paddingSizeInBytes);
    private static BasicSymmetricCipherLiteNCrypt();
    [CompilerGeneratedAttribute]
public sealed virtual int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
public sealed virtual int get_PaddingSizeInBytes();
    public sealed virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Reset(ReadOnlySpan`1<byte> iv);
    public sealed virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private int <Transform>g__NCryptTransform|12_0(ReadOnlySpan`1<byte> input, Span`1<byte> output);
}
internal class System.Security.Cryptography.BasicSymmetricCipherNCrypt : BasicSymmetricCipher {
    private BasicSymmetricCipherLiteNCrypt _cipher;
    public BasicSymmetricCipherNCrypt(Func`1<CngKey> cngKeyFactory, CipherMode cipherMode, int blockSizeInBytes, Byte[] iv, bool encrypting, int paddingSizeInBytes);
    public sealed virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public sealed virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.CapiHelper : object {
    private static ReadOnlySpan`1<byte> RgbPubKey { get; }
    [ExtensionAttribute]
internal static Byte[] ToKeyBlob(DSAParameters dsaParameters);
    [ExtensionAttribute]
internal static DSAParameters ToDSAParameters(Byte[] cspBlob, bool includePrivateParameters, Byte[] cspPublicBlob);
    private static void ReadKeyBlobHeader(BinaryReader br, Byte& bVersion);
    private static void WriteKeyBlobHeader(DSAParameters dsaParameters, BinaryWriter bw, bool isPrivate, Boolean& isV3);
    private static void ReadDSSSeed(DSAParameters dsaParameters, BinaryReader br, bool isV3);
    private static void WriteDSSSeed(DSAParameters dsaParameters, BinaryWriter bw);
    public static string UpgradeDSS(int dwProvType, string wszProvider);
    private static void ReverseDsaSignature(Byte[] signature, int cbSignature);
    [ExtensionAttribute]
internal static Byte[] ToKeyBlob(RSAParameters rsaParameters);
    [ExtensionAttribute]
private static void WriteReversed(BinaryWriter bw, Byte[] bytes);
    [ExtensionAttribute]
internal static RSAParameters ToRSAParameters(Byte[] cspBlob, bool includePrivateParameters);
    internal static byte GetKeyBlobHeaderVersion(Byte[] cspBlob);
    private static Byte[] ExponentAsBytes(UInt32 exponent);
    [ExtensionAttribute]
private static Byte[] ReadReversed(BinaryReader br, int count);
    internal static Byte[] TrimLargeIV(Byte[] currentIV, int blockSizeInBits);
    internal static Byte[] ToPlainTextKeyBlob(int algId, Byte[] rawKey);
    private static void WriteKeyBlobHeader(int algId, BinaryWriter bw);
    private static ReadOnlySpan`1<byte> get_RgbPubKey();
    public static string UpgradeRSA(int dwProvType, string wszProvider);
    internal static string GetDefaultProvider(int dwType);
    private static void CreateCSP(CspParameters parameters, bool randomKeyContainer, SafeProvHandle& safeProvHandle);
    private static int AcquireCryptContext(SafeProvHandle& safeProvHandle, string keyContainer, string providerName, int providerType, UInt32 flags);
    internal static void AcquireCsp(CspParameters cspParameters, SafeProvHandle& safeProvHandle);
    public static int OpenCSP(CspParameters cspParameters, UInt32 flags, SafeProvHandle& safeProvHandle);
    internal static SafeProvHandle CreateProvHandle(CspParameters parameters, bool randomKeyContainer);
    internal static bool IsFlagBitSet(UInt32 dwImp, UInt32 flag);
    internal static int GetProviderParameterWorker(SafeProvHandle safeProvHandle, Byte[] impType, Int32& cb, CryptProvParam flags);
    public static object GetProviderParameter(SafeProvHandle safeProvHandle, int keyNumber, ClrPropertyId keyParam);
    internal static int GetUserKey(SafeProvHandle safeProvHandle, int keySpec, SafeCapiKeyHandle& safeKeyHandle);
    internal static int GenerateKey(SafeProvHandle safeProvHandle, int algID, int flags, UInt32 keySize, SafeCapiKeyHandle& safeKeyHandle);
    internal static int MapCspKeyFlags(int flags);
    internal static UInt32 MapCspProviderFlags(int flags);
    internal static void VerifyValidHandle(SafeHandleZeroOrMinusOneIsInvalid handle);
    internal static Byte[] GetKeyParameter(SafeCapiKeyHandle safeKeyHandle, ClrPropertyId keyParam);
    internal static void SetKeyParameter(SafeCapiKeyHandle safeKeyHandle, CryptGetKeyParamQueryType keyParam, Byte[] value);
    internal static void SetKeyParameter(SafeCapiKeyHandle safeKeyHandle, CryptGetKeyParamQueryType keyParam, int value);
    internal static CspParameters SaveCspParameters(CspAlgorithmType keyType, CspParameters userParameters, CspProviderFlags defaultFlags, Boolean& randomKeyContainer);
    private static void ValidateCspFlags(CspProviderFlags flags);
    internal static SafeCapiKeyHandle GetKeyPairHelper(CspAlgorithmType keyType, CspParameters parameters, int keySize, SafeProvHandle safeProvHandle);
    internal static int GetErrorCode();
    internal static bool GetPersistKeyInCsp(SafeProvHandle safeProvHandle);
    internal static void SetPersistKeyInCsp(SafeProvHandle safeProvHandle, bool fPersistKeyInCsp);
    internal static void DecryptKey(SafeCapiKeyHandle safeKeyHandle, Byte[] encryptedData, int encryptedDataLength, bool fOAEP, Byte[]& decryptedData);
    internal static void EncryptKey(SafeCapiKeyHandle safeKeyHandle, Byte[] pbKey, int cbKey, bool foep, Byte[]& pbEncryptedKey);
    internal static int EncryptData(SafeCapiKeyHandle hKey, ReadOnlySpan`1<byte> input, Span`1<byte> output, bool isFinal);
    internal static int DecryptData(SafeCapiKeyHandle hKey, ReadOnlySpan`1<byte> input, Span`1<byte> output);
    internal static void ImportKeyBlob(SafeProvHandle saveProvHandle, CspProviderFlags flags, bool addNoSaltFlag, Byte[] keyBlob, SafeCapiKeyHandle& safeKeyHandle);
    internal static Byte[] ExportKeyBlob(bool includePrivateParameters, SafeCapiKeyHandle safeKeyHandle);
    public static int NameOrOidToHashAlgId(string nameOrOid, OidGroup oidGroup);
    public static int ObjToHashAlgId(object hashAlg);
    internal static HashAlgorithmName AlgIdToHashAlgorithmName(int hashAlg);
    private static int GetAlgIdFromOid(string oid, OidGroup oidGroup);
    public static Byte[] SignValue(SafeProvHandle hProv, SafeCapiKeyHandle hKey, int keyNumber, int calgKey, int calgHash, Byte[] hash);
    public static bool VerifySign(SafeProvHandle hProv, SafeCapiKeyHandle hKey, int calgKey, int calgHash, Byte[] hash, Byte[] signature);
    public static void DeriveKey(SafeProvHandle hProv, int algid, int algidHash, Byte[] password, int cbPassword, int dwFlags, Byte[] IV_Out, int cbIV_In, Byte[]& pbKey);
    private static void UnloadKey(SafeProvHandle hProv, SafeCapiKeyHandle hKey, Byte[]& key_out, Int32& cb_out);
    [ExtensionAttribute]
private static SafeHashHandle CreateHashHandle(SafeProvHandle hProv, Byte[] hash, int calgHash);
    [ExtensionAttribute]
private static SafeHashHandle CreateHashHandle(SafeProvHandle hProv, Byte[] hash, int calgHash, bool throwOnSizeError);
    public static CryptographicException GetBadDataException();
    public static CryptographicException GetEFailException();
    public static bool CryptGetUserKey(SafeProvHandle safeProvHandle, int dwKeySpec, SafeCapiKeyHandle& safeKeyHandle);
    public static bool CryptGenKey(SafeProvHandle safeProvHandle, int algId, int dwFlags, SafeCapiKeyHandle& safeKeyHandle);
    public static bool CryptImportKey(SafeProvHandle hProv, ReadOnlySpan`1<byte> pbData, SafeCapiKeyHandle hPubKey, int dwFlags, SafeCapiKeyHandle& phKey);
    public static bool CryptCreateHash(SafeProvHandle hProv, int algId, SafeCapiKeyHandle hKey, CryptCreateHashFlags dwFlags, SafeHashHandle& phHash);
    public static bool CryptDeriveKey(SafeProvHandle hProv, int algId, SafeHashHandle phHash, int dwFlags, SafeCapiKeyHandle& phKey);
}
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Security.Cryptography.ChaCha20Poly1305 : object {
    private SafeKeyHandle _keyHandle;
    public static bool IsSupported { get; }
    public ChaCha20Poly1305(ReadOnlySpan`1<byte> key);
    [NullableContextAttribute("1")]
public ChaCha20Poly1305(Byte[] key);
    private static void CheckKeySize(int keySizeInBytes);
    [NullableContextAttribute("1")]
public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    [NullableContextAttribute("1")]
public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private static void ThrowIfNotSupported();
    public static bool get_IsSupported();
    [MemberNotNullAttribute("_keyHandle")]
private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptCore(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
}
public enum System.Security.Cryptography.CipherMode : Enum {
    public int value__;
    public static CipherMode CBC;
    public static CipherMode ECB;
    [EditorBrowsableAttribute("1")]
public static CipherMode OFB;
    public static CipherMode CFB;
    public static CipherMode CTS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithm : object {
    private static CngAlgorithm s_ecdh;
    private static CngAlgorithm s_ecdhp256;
    private static CngAlgorithm s_ecdhp384;
    private static CngAlgorithm s_ecdhp521;
    private static CngAlgorithm s_ecdsa;
    private static CngAlgorithm s_ecdsap256;
    private static CngAlgorithm s_ecdsap384;
    private static CngAlgorithm s_ecdsap521;
    private static CngAlgorithm s_md5;
    private static CngAlgorithm s_sha1;
    private static CngAlgorithm s_sha256;
    private static CngAlgorithm s_sha384;
    private static CngAlgorithm s_sha512;
    private static CngAlgorithm s_rsa;
    private string _algorithm;
    public string Algorithm { get; }
    public static CngAlgorithm Rsa { get; }
    public static CngAlgorithm ECDiffieHellman { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsa { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithm get_Rsa();
    public static CngAlgorithm get_ECDiffieHellman();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsa();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
}
internal class System.Security.Cryptography.CngAlgorithmCore : ValueType {
    private string _disposedName;
    public CngAlgorithm DefaultKeyType;
    private CngKey _lazyKey;
    private bool _disposed;
    public CngAlgorithmCore(string disposedName);
    public static CngKey Duplicate(CngKey key);
    public bool IsKeyGeneratedNamedCurve();
    public void DisposeKey();
    public CngKey GetOrGenerateKey(int keySize, CngAlgorithm algorithm);
    public CngKey GetOrGenerateKey(Nullable`1<ECCurve> curve);
    public void SetKey(CngKey key);
    public void Dispose();
    internal void ThrowIfDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    private static CngAlgorithmGroup s_dh;
    private static CngAlgorithmGroup s_dsa;
    private static CngAlgorithmGroup s_ecdh;
    private static CngAlgorithmGroup s_ecdsa;
    private static CngAlgorithmGroup s_rsa;
    private string _algorithmGroup;
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
}
internal class System.Security.Cryptography.CngAsnFormatter : AsnFormatter {
    protected virtual string FormatNative(Oid oid, Byte[] rawData, bool multiLine);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.CngCommon : object {
    [ExtensionAttribute]
public static Byte[] SignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, int estimatedSize);
    [ExtensionAttribute]
public static bool TrySignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, Span`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, Int32& bytesWritten);
    [ExtensionAttribute]
public static bool VerifyHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.CngHelpers : object {
    private static CngKeyBlobFormat s_cipherKeyBlobFormat;
    private static CngHelpers();
    [ExtensionAttribute]
internal static CryptographicException ToCryptographicException(ErrorCode errorCode);
    [ExtensionAttribute]
internal static SafeNCryptProviderHandle OpenStorageProvider(CngProvider provider);
    [ExtensionAttribute]
public static void SetExportPolicy(SafeNCryptKeyHandle keyHandle, CngExportPolicies exportPolicy);
    [ExtensionAttribute]
internal static Byte[] GetProperty(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
internal static string GetPropertyAsString(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static int GetPropertyAsDword(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
internal static IntPtr GetPropertyAsIntPtr(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
internal static Byte[] GetSymmetricKeyDataIfExportable(CngKey cngKey, string algorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKey : object {
    private SafeNCryptKeyHandle _keyHandle;
    private SafeNCryptProviderHandle _providerHandle;
    public CngAlgorithm Algorithm { get; }
    [NullableAttribute("2")]
public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngExportPolicies ExportPolicy { get; internal set; }
    public SafeNCryptKeyHandle Handle { get; }
    internal SafeNCryptKeyHandle HandleNoDuplicate { get; }
    public bool IsEphemeral { get; private set; }
    public bool IsMachineKey { get; }
    [NullableAttribute("2")]
public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    [NullableAttribute("2")]
public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public CngUIPolicy UIPolicy { get; }
    [NullableAttribute("2")]
public string UniqueName { get; }
    private CngKey(SafeNCryptProviderHandle providerHandle, SafeNCryptKeyHandle keyHandle);
    public sealed virtual void Dispose();
    private static Byte[] MapZeroLengthArrayToNonNullPointer(Byte[] src);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm, string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    private static void InitializeKeyProperties(SafeNCryptKeyHandle keyHandle, CngKeyCreationParameters creationParameters);
    private static void InitializeKeyUiPolicyProperties(SafeNCryptKeyHandle keyHandle, CngUIPolicy uiPolicy);
    public void Delete();
    internal bool IsECNamedCurve();
    internal static bool IsECNamedCurve(string algorithm);
    internal string GetCurveName(String& oidValue);
    private string GetECSpecificCurveName(String& oidValue);
    internal static CngProperty GetPropertyFromNamedCurve(ECCurve curve);
    internal static CngAlgorithm EcdsaCurveNameToAlgorithm(string name);
    internal static CngAlgorithm EcdhCurveNameToAlgorithm(string name);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    public Byte[] Export(CngKeyBlobFormat format);
    internal bool TryExportKeyBlob(string blobType, Span`1<byte> destination, Int32& bytesWritten);
    internal Byte[] ExportPkcs8KeyBlob(ReadOnlySpan`1<char> password, int kdfCount);
    internal bool TryExportPkcs8KeyBlob(ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    internal static bool ExportPkcs8KeyBlob(bool allocate, SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten, Byte[]& allocated);
    internal static CngKey Import(ReadOnlySpan`1<byte> keyBlob, CngKeyBlobFormat format);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    internal static CngKey Import(Byte[] keyBlob, string curveName, CngKeyBlobFormat format);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    internal static CngKey ImportEncryptedPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
    internal static CngKey ImportEncryptedPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password, CngProvider provider);
    internal static CngKey Import(Byte[] keyBlob, string curveName, CngKeyBlobFormat format, CngProvider provider);
    internal static CngKey Import(ReadOnlySpan`1<byte> keyBlob, string curveName, CngKeyBlobFormat format, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    [SupportedOSPlatformAttribute("windows")]
public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
    [SupportedOSPlatformAttribute("windows")]
internal static CngKey OpenNoDuplicate(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
    public CngProperty GetProperty(string name, CngPropertyOptions options);
    public bool HasProperty(string name, CngPropertyOptions options);
    public void SetProperty(CngProperty property);
    public CngAlgorithm get_Algorithm();
    [NullableContextAttribute("2")]
public CngAlgorithmGroup get_AlgorithmGroup();
    public CngExportPolicies get_ExportPolicy();
    internal void set_ExportPolicy(CngExportPolicies value);
    public SafeNCryptKeyHandle get_Handle();
    internal SafeNCryptKeyHandle get_HandleNoDuplicate();
    public bool get_IsEphemeral();
    private void set_IsEphemeral(bool value);
    public bool get_IsMachineKey();
    [NullableContextAttribute("2")]
public string get_KeyName();
    public int get_KeySize();
    public CngKeyUsages get_KeyUsage();
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
    [NullableContextAttribute("2")]
public CngProvider get_Provider();
    public SafeNCryptProviderHandle get_ProviderHandle();
    public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
public string get_UniqueName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    private static CngKeyBlobFormat s_eccPrivate;
    private static CngKeyBlobFormat s_eccPublic;
    private static CngKeyBlobFormat s_eccFullPrivate;
    private static CngKeyBlobFormat s_eccFullPublic;
    private static CngKeyBlobFormat s_genericPrivate;
    private static CngKeyBlobFormat s_genericPublic;
    private static CngKeyBlobFormat s_opaqueTransport;
    private static CngKeyBlobFormat s_pkcs8Private;
    private string _format;
    public string Format { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public static CngKeyBlobFormat EccFullPrivateBlob { get; }
    public static CngKeyBlobFormat EccFullPublicBlob { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public string get_Format();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public static CngKeyBlobFormat get_EccFullPrivateBlob();
    public static CngKeyBlobFormat get_EccFullPublicBlob();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<CngExportPolicies> <ExportPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKeyCreationOptions <KeyCreationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CngKeyUsages> <KeyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyCollection <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <ParentWindowHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private CngUIPolicy <UIPolicy>k__BackingField;
    private CngProvider _provider;
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public CngPropertyCollection Parameters { get; private set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; public set; }
    [NullableAttribute("2")]
public CngUIPolicy UIPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<CngExportPolicies> get_ExportPolicy();
    [CompilerGeneratedAttribute]
public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    [CompilerGeneratedAttribute]
public CngKeyCreationOptions get_KeyCreationOptions();
    [CompilerGeneratedAttribute]
public void set_KeyCreationOptions(CngKeyCreationOptions value);
    [CompilerGeneratedAttribute]
public Nullable`1<CngKeyUsages> get_KeyUsage();
    [CompilerGeneratedAttribute]
public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    [CompilerGeneratedAttribute]
public CngPropertyCollection get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(CngPropertyCollection value);
    [CompilerGeneratedAttribute]
public IntPtr get_ParentWindowHandle();
    [CompilerGeneratedAttribute]
public void set_ParentWindowHandle(IntPtr value);
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CngUIPolicy get_UIPolicy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
internal static class System.Security.Cryptography.CngPkcs8 : object {
    private static PbeParameters s_platformParameters;
    private static CngPkcs8();
    internal static bool IsPlatformScheme(PbeParameters pbeParameters);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Pkcs8Response ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static Pkcs8Response ImportPkcs8(AsnWriter pkcs8Writer);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    private static AsnWriter RewritePkcs8ECPrivateKeyWithZeroPublicKey(ReadOnlySpan`1<byte> source);
    private static void FillRandomAsciiString(Span`1<char> destination);
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob);
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProperty : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyOptions <Options>k__BackingField;
    private Byte[] _value;
    private Nullable`1<int> _lazyHashCode;
    public string Name { get; private set; }
    public CngPropertyOptions Options { get; private set; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    internal CngProperty(string name, ReadOnlySpan`1<byte> value, CngPropertyOptions options);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [NullableContextAttribute("2")]
public Byte[] GetValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CngPropertyOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(CngPropertyOptions value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
    internal Byte[] GetValueWithoutCopying();
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
    public static CngPropertyOptions Persist;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngProvider : object {
    private static CngProvider s_msPlatformKsp;
    private static CngProvider s_msSmartCardKsp;
    private static CngProvider s_msSoftwareKsp;
    private string _provider;
    public string Provider { get; }
    public static CngProvider MicrosoftPlatformCryptoProvider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public CngProvider(string provider);
    public string get_Provider();
    [NullableContextAttribute("2")]
public static bool op_Equality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(CngProvider left, CngProvider right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngProvider get_MicrosoftPlatformCryptoProvider();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
}
internal class System.Security.Cryptography.CngSymmetricAlgorithmCore : ValueType {
    private ICngSymmetricAlgorithm _outer;
    private string _keyName;
    private CngProvider _provider;
    private CngKeyOpenOptions _optionOptions;
    private bool KeyInPlainText { get; }
    public CngSymmetricAlgorithmCore(ICngSymmetricAlgorithm outer);
    public CngSymmetricAlgorithmCore(ICngSymmetricAlgorithm outer, string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public Byte[] GetKeyIfExportable();
    public void SetKey(Byte[] key);
    public void SetKeySize(int keySize, ICngSymmetricAlgorithm outer);
    public void GenerateKey();
    public void GenerateIV();
    public ICryptoTransform CreateEncryptor();
    public ICryptoTransform CreateDecryptor();
    public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    private ICryptoTransform CreateCryptoTransform(bool encrypting);
    public ILiteSymmetricCipher CreateLiteSymmetricCipher(ReadOnlySpan`1<byte> iv, bool encrypting, PaddingMode padding, CipherMode mode, int feedbackSizeInBits);
    private ILiteSymmetricCipher CreateLiteSymmetricCipher(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, bool encrypting, PaddingMode padding, CipherMode mode, int feedbackSizeInBits);
    private UniversalCryptoTransform CreateCryptoTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting, PaddingMode padding, CipherMode mode, int feedbackSizeInBits);
    private UniversalCryptoTransform CreateEphemeralCryptoTransformCore(Byte[] key, Byte[] iv, bool encrypting, PaddingMode padding, CipherMode mode, int feedbackSizeInBits);
    private ILiteSymmetricCipher CreatePersistedLiteSymmetricCipher(Func`1<CngKey> cngKeyFactory, ReadOnlySpan`1<byte> iv, bool encrypting, PaddingMode padding, CipherMode mode, int feedbackSizeInBits);
    private UniversalCryptoTransform CreatePersistedCryptoTransformCore(Func`1<CngKey> cngKeyFactory, Byte[] iv, bool encrypting, PaddingMode padding, CipherMode mode, int feedbackSizeInBits);
    private CngKey ProduceCngKey();
    private bool get_KeyInPlainText();
    private void ValidateFeedbackSize(CipherMode mode, int feedbackSizeInBits);
    private Byte[] CopyAndValidateKey(ReadOnlySpan`1<byte> rgbKey);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CngUIPolicy : object {
    [CompilerGeneratedAttribute]
private CngUIProtectionLevels <ProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreationTitle>k__BackingField;
    public CngUIProtectionLevels ProtectionLevel { get; private set; }
    public string FriendlyName { get; private set; }
    public string Description { get; private set; }
    public string UseContext { get; private set; }
    public string CreationTitle { get; private set; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    [CompilerGeneratedAttribute]
public CngUIProtectionLevels get_ProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_ProtectionLevel(CngUIProtectionLevels value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_UseContext();
    [CompilerGeneratedAttribute]
private void set_UseContext(string value);
    [CompilerGeneratedAttribute]
public string get_CreationTitle();
    [CompilerGeneratedAttribute]
private void set_CreationTitle(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptoConfig : object {
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultOidHT;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultNameHT;
    private static ConcurrentDictionary`2<string, Type> appNameHT;
    private static ConcurrentDictionary`2<string, string> appOidHT;
    private static Dictionary`2<string, string> DefaultOidHT { get; }
    private static Dictionary`2<string, object> DefaultNameHT { get; }
    public static bool AllowOnlyFipsAlgorithms { get; }
    private static CryptoConfig();
    private static Dictionary`2<string, string> get_DefaultOidHT();
    private static Dictionary`2<string, object> get_DefaultNameHT();
    [UnsupportedOSPlatformAttribute("browser")]
public static void AddAlgorithm(Type algorithm, String[] names);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static object CreateFromName(string name, Object[] args);
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static object CreateFromName(string name);
    [UnsupportedOSPlatformAttribute("browser")]
public static void AddOID(string oid, String[] names);
    [UnsupportedOSPlatformAttribute("browser")]
public static string MapNameToOID(string name);
    [UnsupportedOSPlatformAttribute("browser")]
[ObsoleteAttribute("EncodeOID is obsolete. Use the ASN.1 functionality provided in System.Formats.Asn1.")]
public static Byte[] EncodeOID(string str);
    private static void EncodeSingleOidNum(UInt32 value, Byte[] destination, Int32& index);
    public static bool get_AllowOnlyFipsAlgorithms();
}
internal static class System.Security.Cryptography.CryptoConfigForwarder : object {
    private static Func`2<string, object> s_createFromName;
    private static CryptoConfigForwarder();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
private static Func`2<string, object> BindCreateFromName();
    [RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
internal static T CreateFromName(string name);
    internal static HashAlgorithm CreateDefaultHashAlgorithm();
}
public static class System.Security.Cryptography.CryptographicOperations : object {
    public static bool FixedTimeEquals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static void ZeroMemory(Span`1<byte> buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Cryptography.CryptographicUnexpectedOperationException : CryptographicException {
    [NullableContextAttribute("2")]
public CryptographicUnexpectedOperationException(string message);
    [NullableContextAttribute("2")]
public CryptographicUnexpectedOperationException(string message, Exception inner);
    public CryptographicUnexpectedOperationException(string format, string insert);
    protected CryptographicUnexpectedOperationException(SerializationInfo info, StreamingContext context);
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(ArraySegment`1<byte> arraySegment);
    internal static void Return(Byte[] array, int clearSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptoStream : Stream {
    private Stream _stream;
    private ICryptoTransform _transform;
    private Byte[] _inputBuffer;
    private int _inputBufferIndex;
    private int _inputBlockSize;
    private Byte[] _outputBuffer;
    private int _outputBufferIndex;
    private int _outputBlockSize;
    private bool _canRead;
    private bool _canWrite;
    private bool _finalBlockTransformed;
    private SemaphoreSlim _lazyAsyncActiveSemaphore;
    private bool _leaveOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool HasFlushedFinalBlock { get; }
    [MemberNotNullAttribute("_lazyAsyncActiveSemaphore")]
private SemaphoreSlim AsyncActiveSemaphore { get; }
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
    public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public bool get_HasFlushedFinalBlock();
    public void FlushFinalBlock();
    public ValueTask FlushFinalBlockAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<FlushFinalBlockAsync>d__30")]
private ValueTask FlushFinalBlockAsync(bool useAsync, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<ReadAsyncInternal>d__37")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void CheckReadArguments(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<ReadAsyncCore>d__44")]
private ValueTask`1<int> ReadAsyncCore(Memory`1<byte> buffer, CancellationToken cancellationToken, bool useAsync);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<WriteAsyncInternal>d__47")]
private ValueTask WriteAsyncInternal(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void CheckWriteArguments(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<WriteAsyncCore>d__52")]
private ValueTask WriteAsyncCore(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken, bool useAsync);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<CopyToAsyncInternal>d__55")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void CheckCopyToArguments(Stream destination, int bufferSize);
    private static void EnsureNotDisposed(Stream stream, string objectName);
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.Security.Cryptography.CryptoStream/<DisposeAsyncCore>d__61")]
private ValueTask DisposeAsyncCore();
    [MemberNotNullAttribute("_lazyAsyncActiveSemaphore")]
private SemaphoreSlim get_AsyncActiveSemaphore();
    [CompilerGeneratedAttribute]
internal static int <WriteAsyncCore>g__TransformBlock|52_0(ICryptoTransform transform, ReadOnlyMemory`1<byte> inputBuffer, Byte[] outputBuffer, int outputOffset);
}
public enum System.Security.Cryptography.CryptoStreamMode : Enum {
    public int value__;
    public static CryptoStreamMode Read;
    public static CryptoStreamMode Write;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    private CspParameters _parameters;
    private bool _randomKeyContainer;
    public bool Accessible { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public string KeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool MachineKeyStore { get; }
    public bool Protected { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public bool RandomlyGenerated { get; }
    public bool Removable { get; }
    [NullableAttribute("1")]
public string UniqueKeyContainerName { get; }
    [NullableContextAttribute("1")]
public CspKeyContainerInfo(CspParameters parameters);
    internal CspKeyContainerInfo(CspParameters parameters, bool randomKeyContainer);
    public bool get_Accessible();
    public bool get_Exportable();
    public bool get_HardwareDevice();
    public string get_KeyContainerName();
    public KeyNumber get_KeyNumber();
    public bool get_MachineKeyStore();
    public bool get_Protected();
    public string get_ProviderName();
    public int get_ProviderType();
    public bool get_RandomlyGenerated();
    public bool get_Removable();
    [NullableContextAttribute("1")]
public string get_UniqueKeyContainerName();
    private object ReadKeyParameterSilent(ClrPropertyId keyParam, bool throwOnNotFound);
    private object ReadDeviceParameterVerifyContext(ClrPropertyId keyParam);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
public class System.Security.Cryptography.CspParameters : object {
    public int ProviderType;
    public string ProviderName;
    public string KeyContainerName;
    public int KeyNumber;
    private int _flags;
    private IntPtr _parentWindowHandle;
    [CompilerGeneratedAttribute]
private SecureString <KeyPassword>k__BackingField;
    public CspProviderFlags Flags { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    internal CspParameters(int providerType, string providerName, string keyContainerName, CspProviderFlags flags);
    internal CspParameters(CspParameters parameters);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    [CompilerGeneratedAttribute]
public SecureString get_KeyPassword();
    [CompilerGeneratedAttribute]
public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseUserProtectedKey;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags CreateEphemeralKey;
}
public abstract class System.Security.Cryptography.DeriveBytes : object {
    [NullableContextAttribute("1")]
public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static DES();
    [UnsupportedOSPlatformAttribute("browser")]
public static DES Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static DES Create(string algName);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static bool IsWeakKey(Byte[] rgbKey);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
    private static bool IsLegalKeySize(Byte[] rgbKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
}
internal class System.Security.Cryptography.DesImplementation : DES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void ValidateCFBFeedbackSize(int feedback);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int feedbackSize, int paddingSize, bool encrypting);
    private static ILiteSymmetricCipher CreateLiteCipher(CipherMode cipherMode, PaddingMode paddingMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int feedbackSize, int paddingSize, bool encrypting);
}
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static DSA Create(string algName);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create();
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create(int keySizeInBits);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static DSA Create(DSAParameters parameters);
    [NullableContextAttribute("1")]
public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    [NullableContextAttribute("1")]
public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual Byte[] SignDataCore(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
protected virtual Byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public Byte[] CreateSignature(Byte[] rgbHash, DSASignatureFormat signatureFormat);
    protected virtual Byte[] CreateSignatureCore(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TryCreateSignatureCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    protected virtual bool TrySignDataCore(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual bool VerifyDataCore(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("1")]
public bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature, DSASignatureFormat signatureFormat);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    protected virtual bool VerifySignatureCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    private ReadOnlySpan`1<byte> HashSpanToTmp(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Span`1<byte> tmp);
    private Byte[] HashSpanToArray(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs8();
    private AsnWriter WriteSubjectPublicKeyInfo();
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    private static Byte[] ReadRequiredElement(ParseState& state, string name, int sizeHint);
    [NullableContextAttribute("1")]
public virtual void FromXmlString(string xmlString);
    [NullableContextAttribute("1")]
public virtual string ToXmlString(bool includePrivateParameters);
    private static DSA CreateCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACng : DSA {
    private static KeySizes[] s_legalKeySizes;
    private static int s_defaultKeySize;
    private CngAlgorithmCore _core;
    private CngAlgorithm _dsnCng;
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public CngKey Key { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public DSACng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public DSACng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
internal DSACng(CngKey key, bool transferOwnership);
    private static DSACng();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    private void ForceSetKeySize(int newKeySize);
    private static bool Supports2048KeySize();
    public virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    private static void GenerateV1DsaBlob(Byte[]& blob, DSAParameters parameters, int cbKey, bool includePrivate);
    private static void GenerateV2DsaBlob(Byte[]& blob, DSAParameters parameters, int cbKey, bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    [NullableContextAttribute("0")]
protected virtual bool TryCreateSignatureCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    [NullableContextAttribute("0")]
protected virtual bool VerifySignatureCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    private ReadOnlySpan`1<byte> AdjustHashSizeIfNecessary(ReadOnlySpan`1<byte> hash, Span`1<byte> stackBuf);
    private int ComputeQLength();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] dsaBlob, bool includePrivate);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    private int _keySize;
    private CspParameters _parameters;
    private bool _randomKeyContainer;
    private SafeCapiKeyHandle _safeKeyHandle;
    private SafeProvHandle _safeProvHandle;
    private static CspProviderFlags modreq(System.Runtime.CompilerServices.IsVolatile) s_useMachineKeyStore;
    private bool _disposed;
    private SafeProvHandle SafeProvHandle { get; private set; }
    private SafeCapiKeyHandle SafeKeyHandle { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public DSACryptoServiceProvider(int dwKeySize);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public DSACryptoServiceProvider(CspParameters parameters);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    private SafeProvHandle get_SafeProvHandle();
    private void set_SafeProvHandle(SafeProvHandle value);
    private SafeCapiKeyHandle get_SafeKeyHandle();
    private void set_SafeKeyHandle(SafeCapiKeyHandle value);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    private static SafeProvHandle AcquireSafeProviderHandle();
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(DSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public Byte[] SignData(Stream inputStream);
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    private static bool IsPublic(Byte[] keyBlob);
}
internal static class System.Security.Cryptography.DSAKeyFormatHelper : object {
    private static String[] s_validOids;
    private static DSAKeyFormatHelper();
    internal static void ReadDsaPrivateKey(ReadOnlyMemory`1<byte> xBytes, AlgorithmIdentifierAsn& algId, DSAParameters& ret);
    internal static void ReadDsaPublicKey(ReadOnlyMemory`1<byte> yBytes, AlgorithmIdentifierAsn& algId, DSAParameters& ret);
    internal static void ReadSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead, DSAParameters& key);
    internal static void ReadPkcs8(ReadOnlySpan`1<byte> source, Int32& bytesRead, DSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, DSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, DSAParameters& key);
    internal static AsnWriter WriteSubjectPublicKeyInfo(DSAParameters& dsaParameters);
    internal static AsnWriter WritePkcs8(DSAParameters& dsaParameters);
    private static void WriteAlgorithmId(AsnWriter writer, DSAParameters& dsaParameters);
    private static void WriteKeyComponent(AsnWriter writer, Byte[] component, bool bitString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSAOpenSsl : DSA {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(DSAParameters parameters);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public DSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSAParameters : ValueType {
    public Byte[] P;
    public Byte[] Q;
    public Byte[] G;
    public Byte[] Y;
    public Byte[] J;
    public Byte[] X;
    public Byte[] Seed;
    public int Counter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    private DSA _dsaKey;
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public enum System.Security.Cryptography.DSASignatureFormat : Enum {
    public int value__;
    public static DSASignatureFormat IeeeP1363FixedFieldConcatenation;
    public static DSASignatureFormat Rfc3279DerSequence;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.DSASignatureFormatHelpers : object {
    [ExtensionAttribute]
internal static bool IsKnownValue(DSASignatureFormat signatureFormat);
    internal static Exception CreateUnknownValueException(DSASignatureFormat signatureFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    private DSA _dsaKey;
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
internal class System.Security.Cryptography.DSAWrapper : DSA {
    private DSA _wrapped;
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    public string KeyExchangeAlgorithm { get; }
    internal DSAWrapper(DSA wrapped);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    public virtual string get_KeyExchangeAlgorithm();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual Byte[] ExportPkcs8PrivateKey();
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
}
public abstract class System.Security.Cryptography.ECAlgorithm : AsymmetricAlgorithm {
    private static String[] s_validOids;
    private static ECAlgorithm();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    [NullableContextAttribute("1")]
public string ExportECPrivateKeyPem();
    public bool TryExportECPrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
private ImportKeyAction <ImportFromPem>b__16_0(ReadOnlySpan`1<char> label);
    [CompilerGeneratedAttribute]
internal static bool <TryExportECPrivateKeyPem>g__Export|20_0(ECAlgorithm alg, Span`1<byte> destination, Int32& bytesWritten);
}
internal static class System.Security.Cryptography.EccKeyFormatHelper : object {
    internal static ECParameters FromECPrivateKey(ReadOnlySpan`1<byte> key, Int32& bytesRead);
    internal static void FromECPrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPrivateKey(ECPrivateKey key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPublicKey(ReadOnlyMemory`1<byte> key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    private static void ValidateParameters(Nullable`1<ECDomainParameters> keyParameters, AlgorithmIdentifierAsn& algId);
    private static ECCurve GetCurve(ECDomainParameters domainParameters);
    private static ECCurve GetSpecifiedECCurve(SpecifiedECDomain specifiedParameters);
    private static ECCurve GetSpecifiedECCurveCore(SpecifiedECDomain specifiedParameters);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ECParameters ecParameters);
    private static AsnWriter WriteAlgorithmIdentifier(ECParameters& ecParameters);
    private static void WriteAlgorithmIdentifier(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WritePkcs8PrivateKey(ECParameters ecParameters, AttributeAsn[] attributes);
    private static AsnWriter WritePrivateKeyInfoAttributes(AttributeAsn[] attributes);
    private static void WriteEcParameters(ECParameters ecParameters, AsnWriter writer);
    private static void WriteSpecifiedECDomain(ECParameters ecParameters, AsnWriter writer);
    private static void DetermineChar2Parameters(ECParameters& ecParameters, Int32& m, Int32& k1, Int32& k2, Int32& k3);
    private static void WriteCurve(ECCurve& curve, AsnWriter writer);
    private static void WriteFieldElement(Byte[] fieldElement, AsnWriter writer);
    private static void WriteUncompressedBasePoint(ECParameters& ecParameters, AsnWriter writer);
    private static void WriteUncompressedPublicKey(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WriteECPrivateKey(ECParameters& ecParameters);
    private static AsnWriter WriteEcPrivateKey(ECParameters& ecParameters, bool includeDomainParameters);
}
internal static class System.Security.Cryptography.ECCng : object {
    internal static ECC_CURVE_ALG_ID_ENUM GetHashAlgorithmId(Nullable`1<HashAlgorithmName> name);
    internal static Nullable`1<HashAlgorithmName> GetHashAlgorithmName(ECC_CURVE_ALG_ID_ENUM hashId);
    internal static Byte[] GetNamedCurveBlob(ECParameters& parameters, bool ecdh);
    internal static Byte[] GetPrimeCurveBlob(ECParameters& parameters, bool ecdh);
    internal static void ExportNamedCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static void ExportPrimeCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] GetPrimeCurveParameterBlob(ECCurve& curve);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static bool IsMagicValueOfKeyPrivate(KeyBlobMagicNumber magic);
    private static bool IsMagicValueOfKeyPublic(KeyBlobMagicNumber magic);
    private static KeyBlobMagicNumber EcdsaCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static KeyBlobMagicNumber EcdhCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static ECC_CURVE_TYPE_ENUM ConvertToCurveTypeEnum(ECCurveType value);
    private static ECCurveType ConvertToCurveTypeEnum(ECC_CURVE_TYPE_ENUM value);
    internal static SafeNCryptKeyHandle ImportKeyBlob(string blobType, ReadOnlySpan`1<byte> keyBlob, string curveName, SafeNCryptProviderHandle provider);
    internal static string EcdsaCurveNameToAlgorithm(string algorithm);
    internal static string EcdhCurveNameToAlgorithm(string algorithm);
    internal static CngKey ImportKeyBlob(Byte[] ecBlob, string curveName, bool includePrivateParameters);
    internal static CngKey ImportFullKeyBlob(Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] ExportKeyBlob(CngKey key, bool includePrivateParameters);
    internal static Byte[] ExportFullKeyBlob(CngKey key, bool includePrivateParameters);
    internal static Byte[] ExportKeyBlob(CngKey key, bool includePrivateParameters, CngKeyBlobFormat& format, String& curveName);
    private static void FixupGenericBlob(Byte[] blob);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("ECCurve: {Oid}")]
public class System.Security.Cryptography.ECCurve : ValueType {
    public Byte[] A;
    public Byte[] B;
    public ECPoint G;
    public Byte[] Order;
    public Byte[] Cofactor;
    public Byte[] Seed;
    public ECCurveType CurveType;
    public Nullable`1<HashAlgorithmName> Hash;
    public Byte[] Polynomial;
    public Byte[] Prime;
    private Oid _oid;
    [NullableAttribute("1")]
public Oid Oid { get; private set; }
    public bool IsPrime { get; }
    public bool IsCharacteristic2 { get; }
    public bool IsExplicit { get; }
    public bool IsNamed { get; }
    [NullableContextAttribute("1")]
public Oid get_Oid();
    private void set_Oid(Oid value);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromOid(Oid curveOid);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
    [NullableContextAttribute("1")]
public static ECCurve CreateFromValue(string oidValue);
    private static ECCurve CreateFromValueAndName(string oidValue, string oidFriendlyName);
    public bool get_IsPrime();
    public bool get_IsCharacteristic2();
    public bool get_IsExplicit();
    public bool get_IsNamed();
    public void Validate();
    private bool HasAnyExplicitParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDiffieHellman : ECAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    [NullableAttribute("2")]
public string SignatureAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public virtual string get_KeyExchangeAlgorithm();
    [NullableContextAttribute("2")]
public virtual string get_SignatureAlgorithm();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create(ECCurve curve);
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDiffieHellman Create(ECParameters parameters);
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static ECDiffieHellman Create(string algorithm);
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey);
    [NullableContextAttribute("2")]
public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    private static Exception DerivedClassMustOverride();
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    private CngAlgorithmCore _core;
    private CngAlgorithm _hashAlgorithm;
    private ECDiffieHellmanKeyDerivationFunction _kdf;
    private Byte[] _hmacKey;
    private Byte[] _label;
    private Byte[] _secretAppend;
    private Byte[] _secretPrepend;
    private Byte[] _seed;
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public CngAlgorithm HashAlgorithm { get; public set; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    [NullableAttribute("2")]
public Byte[] HmacKey { get; public set; }
    [NullableAttribute("2")]
public Byte[] Label { get; public set; }
    [NullableAttribute("2")]
public Byte[] SecretAppend { get; public set; }
    [NullableAttribute("2")]
public Byte[] SecretPrepend { get; public set; }
    [NullableAttribute("2")]
public Byte[] Seed { get; public set; }
    public bool UseSecretAgreementAsHmacKey { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public CngKey Key { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(ECCurve curve);
    [SupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanCng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
internal ECDiffieHellmanCng(CngKey key, bool transferOwnership);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    private void ForceSetKeySize(int newKeySize);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    [NullableContextAttribute("2")]
public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    [NullableContextAttribute("2")]
public Byte[] get_HmacKey();
    [NullableContextAttribute("2")]
public void set_HmacKey(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_Label();
    [NullableContextAttribute("2")]
public void set_Label(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_SecretAppend();
    [NullableContextAttribute("2")]
public void set_SecretAppend(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_SecretPrepend();
    [NullableContextAttribute("2")]
public void set_SecretPrepend(Byte[] value);
    [NullableContextAttribute("2")]
public Byte[] get_Seed();
    [NullableContextAttribute("2")]
public void set_Seed(Byte[] value);
    public bool get_UseSecretAgreementAsHmacKey();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void DisposeKey();
    internal string GetCurveName(String& oidValue);
    private void ImportFullKeyBlob(Byte[] ecfullKeyBlob, bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] ecfullKeyBlob, string curveName, bool includePrivateParameters);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private Byte[] ExportFullKeyBlob(bool includePrivateParameters);
    private void AcceptImport(Pkcs8Response response);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual void GenerateKey(ECCurve curve);
    private CngKey GetKey();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public void FromXmlString(string xml, ECKeyXmlFormat format);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public string ToXmlString(ECKeyXmlFormat format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    private CngKeyBlobFormat _format;
    private string _curveName;
    private bool _disposed;
    public CngKeyBlobFormat BlobFormat { get; }
    internal ECDiffieHellmanCngPublicKey(Byte[] keyBlob, string curveName, CngKeyBlobFormat format);
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public virtual string ToXmlString();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    public CngKeyBlobFormat get_BlobFormat();
    [SupportedOSPlatformAttribute("windows")]
public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    internal static ECDiffieHellmanCngPublicKey FromKey(CngKey key);
    public CngKey Import();
    public virtual ECParameters ExportExplicitParameters();
    public virtual ECParameters ExportParameters();
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDiffieHellmanOpenSsl : ECDiffieHellman {
    public ECDiffieHellmanPublicKey PublicKey { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(ECCurve curve);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDiffieHellmanOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    private Byte[] _keyBlob;
    [ObsoleteAttribute("ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.")]
protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("ECDiffieHellmanPublicKey.ToByteArray() and the associated constructor do not have a consistent and interoperable implementation on all platforms. Use ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo() instead.")]
public virtual Byte[] ToByteArray();
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public virtual string ToXmlString();
    public virtual ECParameters ExportParameters();
    public virtual ECParameters ExportExplicitParameters();
    [NullableContextAttribute("0")]
public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportSubjectPublicKeyInfo();
}
internal class System.Security.Cryptography.ECDiffieHellmanWrapper : ECDiffieHellman {
    private ECDiffieHellman _wrapped;
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    internal ECDiffieHellmanWrapper(ECDiffieHellman wrapped);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static ECDiffieHellmanPublicKey Unwrap(ECDiffieHellmanPublicKey otherPartyPublicKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.ECDsa : ECAlgorithm {
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create();
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create(ECCurve curve);
    [UnsupportedOSPlatformAttribute("browser")]
public static ECDsa Create(ECParameters parameters);
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static ECDsa Create(string algorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual Byte[] SignDataCore(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    protected virtual Byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public Byte[] SignHash(Byte[] hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public Byte[] SignHash(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public Byte[] SignHash(ReadOnlySpan`1<byte> hash);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination);
    [NullableContextAttribute("0")]
protected virtual Byte[] SignHashCore(ReadOnlySpan`1<byte> hash, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignDataCore(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyDataCore(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignHashCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public bool VerifyHash(Byte[] hash, Byte[] signature, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
public bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    [NullableContextAttribute("0")]
protected virtual bool VerifyHashCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    private ReadOnlySpan`1<byte> HashSpanToTmp(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Span`1<byte> tmp);
    private Byte[] HashSpanToArray(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm);
    public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    private CngAlgorithmCore _core;
    private CngAlgorithm _hashAlgorithm;
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(ECCurve curve);
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(int keySize);
    [SupportedOSPlatformAttribute("windows")]
public ECDsaCng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
internal ECDsaCng(CngKey key, bool transferOwnership);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    private void ForceSetKeySize(int newKeySize);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual void ImportParameters(ECParameters parameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] SignHash(Byte[] hash);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TrySignHashCore(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, DSASignatureFormat signatureFormat, Int32& bytesWritten);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    [NullableContextAttribute("0")]
protected virtual bool VerifyHashCore(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, DSASignatureFormat signatureFormat);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void DisposeKey();
    private static bool IsEccAlgorithmGroup(CngAlgorithmGroup algorithmGroup);
    internal string GetCurveName(String& oidValue);
    private void ImportFullKeyBlob(Byte[] ecfullKeyBlob, bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] ecfullKeyBlob, string curveName, bool includePrivateParameters);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private Byte[] ExportFullKeyBlob(bool includePrivateParameters);
    private void AcceptImport(Pkcs8Response response);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public void FromXmlString(string xml, ECKeyXmlFormat format);
    public Byte[] SignData(Byte[] data);
    public Byte[] SignData(Byte[] data, int offset, int count);
    public Byte[] SignData(Stream data);
    [ObsoleteAttribute("ToXmlString and FromXmlString have no implementation for ECC types, and are obsolete. Use a standard import and export format such as ExportSubjectPublicKeyInfo or ImportSubjectPublicKeyInfo for public keys and ExportPkcs8PrivateKey or ImportPkcs8PrivateKey for private keys.")]
public string ToXmlString(ECKeyXmlFormat format);
    public bool VerifyData(Byte[] data, Byte[] signature);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
    public bool VerifyData(Stream data, Byte[] signature);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual void GenerateKey(ECCurve curve);
    private CngKey GetKey();
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECDsaOpenSsl : ECDsa {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(ECCurve curve);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
}
internal class System.Security.Cryptography.ECDsaWrapper : ECDsa {
    private ECDsa _wrapped;
    public string KeyExchangeAlgorithm { get; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    internal ECDsaWrapper(ECDsa wrapped);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    protected virtual void Dispose(bool disposing);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
public class System.Security.Cryptography.ECParameters : ValueType {
    public ECPoint Q;
    [NullableAttribute("2")]
public Byte[] D;
    public ECCurve Curve;
    public void Validate();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.ECPoint : ValueType {
    public Byte[] X;
    public Byte[] Y;
}
public class System.Security.Cryptography.FromBase64Transform : object {
    private Byte[] _inputBuffer;
    private int _inputIndex;
    private FromBase64TransformMode _whitespaces;
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    [NullableContextAttribute("1")]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Span`1<byte> GetTempBuffer(Span`1<byte> inputBuffer, Span`1<byte> tmpBuffer);
    private static Span`1<byte> DiscardWhiteSpaces(Span`1<byte> inputBuffer, Span`1<byte> tmpBuffer);
    private static bool IsWhitespace(byte value);
    private static int GetOutputSize(int bytesToTransform, Span`1<byte> tmpBuffer);
    private void ConvertFromBase64(Span`1<byte> tmpBuffer, Span`1<byte> outputBuffer, Int32& consumed, Int32& written);
    private static void ReturnToCryptoPool(Byte[] array, int clearSize);
    public void Clear();
    private void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.HashAlgorithm : object {
    private bool _disposed;
    protected int HashSizeValue;
    [NullableAttribute("2")]
protected internal Byte[] HashValue;
    protected int State;
    public int HashSize { get; }
    [NullableAttribute("2")]
public Byte[] Hash { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static HashAlgorithm Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static HashAlgorithm Create(string hashName);
    public virtual int get_HashSize();
    [NullableContextAttribute("2")]
public virtual Byte[] get_Hash();
    public Byte[] ComputeHash(Byte[] buffer);
    [NullableContextAttribute("0")]
public bool TryComputeHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] ComputeHash(Byte[] buffer, int offset, int count);
    public Byte[] ComputeHash(Stream inputStream);
    public Task`1<Byte[]> ComputeHashAsync(Stream inputStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.HashAlgorithm/<ComputeHashAsyncCore>d__16")]
private Task`1<Byte[]> ComputeHashAsyncCore(Stream inputStream, CancellationToken cancellationToken);
    private Byte[] CaptureHashCodeAndReinitialize();
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public virtual int get_InputBlockSize();
    public virtual int get_OutputBlockSize();
    public virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected abstract virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected abstract virtual Byte[] HashFinal();
    public abstract virtual void Initialize();
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Security.Cryptography.HashAlgorithmName : ValueType {
    private string _name;
    public static HashAlgorithmName MD5 { get; }
    public static HashAlgorithmName SHA1 { get; }
    public static HashAlgorithmName SHA256 { get; }
    public static HashAlgorithmName SHA384 { get; }
    public static HashAlgorithmName SHA512 { get; }
    public string Name { get; }
    public HashAlgorithmName(string name);
    public static HashAlgorithmName get_MD5();
    public static HashAlgorithmName get_SHA1();
    public static HashAlgorithmName get_SHA256();
    public static HashAlgorithmName get_SHA384();
    public static HashAlgorithmName get_SHA512();
    public string get_Name();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HashAlgorithmName other);
    public virtual int GetHashCode();
    public static bool op_Equality(HashAlgorithmName left, HashAlgorithmName right);
    public static bool op_Inequality(HashAlgorithmName left, HashAlgorithmName right);
    [NullableContextAttribute("1")]
public static bool TryFromOid(string oidValue, HashAlgorithmName& value);
    [NullableContextAttribute("1")]
public static HashAlgorithmName FromOid(string oidValue);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.HashAlgorithmNames : object {
    [ExtensionAttribute]
public static string ToAlgorithmName(HashAlgorithm hashAlgorithm);
    public static string ToUpper(string hashAlgorithmName);
}
internal static class System.Security.Cryptography.HashOneShotHelpers : object {
    internal static Byte[] HashData(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> source);
    internal static bool TryHashData(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    internal static Byte[] HashData(HashAlgorithmName hashAlgorithm, Stream source);
    internal static int MacData(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
}
internal abstract class System.Security.Cryptography.HashProvider : object {
    public int HashSizeInBytes { get; }
    public void AppendHashData(Byte[] data, int offset, int count);
    public abstract virtual void AppendHashData(ReadOnlySpan`1<byte> data);
    public abstract virtual int FinalizeHashAndReset(Span`1<byte> destination);
    public abstract virtual int GetCurrentHash(Span`1<byte> destination);
    public Byte[] FinalizeHashAndReset();
    public bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public abstract virtual int get_HashSizeInBytes();
    public sealed virtual void Dispose();
    public abstract virtual void Dispose(bool disposing);
    public abstract virtual void Reset();
}
internal class System.Security.Cryptography.HashProviderCng : HashProvider {
    private SafeBCryptAlgorithmHandle _hAlgorithm;
    private SafeBCryptHashHandle _hHash;
    private Byte[] _key;
    private bool _reusable;
    private int _hashSize;
    private bool _running;
    public int HashSizeInBytes { get; }
    public HashProviderCng(string hashAlgId, Byte[] key);
    internal HashProviderCng(string hashAlgId, ReadOnlySpan`1<byte> key, bool isHmac);
    public sealed virtual void AppendHashData(ReadOnlySpan`1<byte> source);
    public virtual int FinalizeHashAndReset(Span`1<byte> destination);
    public virtual int GetCurrentHash(Span`1<byte> destination);
    public sealed virtual void Dispose(bool disposing);
    public sealed virtual int get_HashSizeInBytes();
    public virtual void Reset();
    private void DestroyHash();
}
internal static class System.Security.Cryptography.HashProviderDispenser : object {
    public static HashProvider CreateHashProvider(string hashAlgorithmId);
    public static HashProvider CreateMacProvider(string hashAlgorithmId, ReadOnlySpan`1<byte> key);
}
public static class System.Security.Cryptography.HKDF : object {
    [NullableContextAttribute("1")]
public static Byte[] Extract(HashAlgorithmName hashAlgorithmName, Byte[] ikm, Byte[] salt);
    public static int Extract(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> ikm, ReadOnlySpan`1<byte> salt, Span`1<byte> prk);
    private static void Extract(HashAlgorithmName hashAlgorithmName, int hashLength, ReadOnlySpan`1<byte> ikm, ReadOnlySpan`1<byte> salt, Span`1<byte> prk);
    [NullableContextAttribute("1")]
public static Byte[] Expand(HashAlgorithmName hashAlgorithmName, Byte[] prk, int outputLength, Byte[] info);
    public static void Expand(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> prk, Span`1<byte> output, ReadOnlySpan`1<byte> info);
    private static void Expand(HashAlgorithmName hashAlgorithmName, int hashLength, ReadOnlySpan`1<byte> prk, Span`1<byte> output, ReadOnlySpan`1<byte> info);
    [NullableContextAttribute("1")]
public static Byte[] DeriveKey(HashAlgorithmName hashAlgorithmName, Byte[] ikm, int outputLength, Byte[] salt, Byte[] info);
    public static void DeriveKey(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> ikm, Span`1<byte> output, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info);
    private static void GetHashAndReset(IncrementalHash hmac, Span`1<byte> output);
    private static int HashLength(HashAlgorithmName hashAlgorithmName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.HMAC : KeyedHashAlgorithm {
    private string _hashName;
    private int _blockSizeValue;
    protected int BlockSizeValue { get; protected set; }
    public string HashName { get; public set; }
    public Byte[] Key { get; public set; }
    protected int get_BlockSizeValue();
    protected void set_BlockSizeValue(int value);
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static HMAC Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static HMAC Create(string algorithmName);
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
}
internal class System.Security.Cryptography.HMACCommon : object {
    [CompilerGeneratedAttribute]
private Byte[] <ActualKey>k__BackingField;
    private string _hashAlgorithmId;
    private HashProvider _hMacProvider;
    private int _blockSize;
    public int HashSizeInBits { get; }
    public int HashSizeInBytes { get; }
    public Byte[] ActualKey { get; private set; }
    public HMACCommon(string hashAlgorithmId, Byte[] key, int blockSize);
    internal HMACCommon(string hashAlgorithmId, ReadOnlySpan`1<byte> key, int blockSize);
    public int get_HashSizeInBits();
    public int get_HashSizeInBytes();
    public void ChangeKey(Byte[] key);
    [MemberNotNullAttribute("_hMacProvider")]
private Byte[] ChangeKeyImpl(ReadOnlySpan`1<byte> key);
    [CompilerGeneratedAttribute]
public Byte[] get_ActualKey();
    [CompilerGeneratedAttribute]
private void set_ActualKey(Byte[] value);
    public void AppendHashData(Byte[] data, int offset, int count);
    public void AppendHashData(ReadOnlySpan`1<byte> source);
    public Byte[] FinalizeHashAndReset();
    public int FinalizeHashAndReset(Span`1<byte> destination);
    public bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public int GetCurrentHash(Span`1<byte> destination);
    public void Reset();
    public void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACMD5 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public HMACMD5(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACSHA1(Byte[] key);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HMACSHA1 always uses the algorithm implementation provided by the platform. Use a constructor without the useManagedSha1 parameter.")]
public HMACSHA1(Byte[] key, bool useManagedSha1);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACSHA256(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    [ObsoleteAttribute("ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.")]
public bool ProduceLegacyHmacValues { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACSHA384(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    private HMACCommon _hMacCommon;
    [ObsoleteAttribute("ProduceLegacyHmacValues is obsolete. Producing legacy HMAC values is not supported.")]
public bool ProduceLegacyHmacValues { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACSHA512(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    [NullableContextAttribute("0")]
protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    [NullableContextAttribute("0")]
protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    public static Byte[] HashData(Byte[] key, Byte[] source);
    [NullableContextAttribute("0")]
public static Byte[] HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [NullableContextAttribute("0")]
public static bool TryHashData(ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static int HashData(ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    public static Byte[] HashData(ReadOnlySpan`1<byte> key, Stream source);
    public static Byte[] HashData(Byte[] key, Stream source);
    [NullableContextAttribute("0")]
public static ValueTask`1<Byte[]> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<Byte[]> HashDataAsync(Byte[] key, Stream source, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public static ValueTask`1<int> HashDataAsync(ReadOnlyMemory`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal interface System.Security.Cryptography.ICngSymmetricAlgorithm {
    public int BlockSize { get; }
    public int FeedbackSize { get; }
    public CipherMode Mode { get; }
    public PaddingMode Padding { get; }
    public Byte[] IV { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public Byte[] BaseKey { get; public set; }
    public int BaseKeySize { get; public set; }
    public abstract virtual int get_BlockSize();
    public abstract virtual int get_FeedbackSize();
    public abstract virtual CipherMode get_Mode();
    public abstract virtual PaddingMode get_Padding();
    public abstract virtual Byte[] get_IV();
    public abstract virtual void set_IV(Byte[] value);
    public abstract virtual KeySizes[] get_LegalKeySizes();
    public abstract virtual Byte[] get_BaseKey();
    public abstract virtual void set_BaseKey(Byte[] value);
    public abstract virtual int get_BaseKeySize();
    public abstract virtual void set_BaseKeySize(int value);
    public abstract virtual bool IsWeakKey(Byte[] key);
    public abstract virtual SafeAlgorithmHandle GetEphemeralModeHandle(CipherMode mode, int feedbackSizeInBits);
    public abstract virtual string GetNCryptAlgorithmIdentifier();
    public abstract virtual Byte[] PreprocessKey(Byte[] key);
    public abstract virtual int GetPaddingSize(CipherMode mode, int feedbackSizeBits);
    public abstract virtual bool IsValidEphemeralFeedbackSize(int feedbackSizeInBits);
}
[NullableContextAttribute("1")]
public interface System.Security.Cryptography.ICryptoTransform {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public abstract virtual int get_InputBlockSize();
    public abstract virtual int get_OutputBlockSize();
    public abstract virtual bool get_CanTransformMultipleBlocks();
    public abstract virtual bool get_CanReuseTransform();
    public abstract virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public abstract virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
[NullableContextAttribute("1")]
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
internal interface System.Security.Cryptography.ILiteHash {
    public int HashSizeInBytes { get; }
    public abstract virtual int get_HashSizeInBytes();
    public abstract virtual void Append(ReadOnlySpan`1<byte> data);
    public abstract virtual int Finalize(Span`1<byte> destination);
}
internal interface System.Security.Cryptography.ILiteSymmetricCipher {
    public int BlockSizeInBytes { get; }
    public int PaddingSizeInBytes { get; }
    public abstract virtual int TransformFinal(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual int Transform(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    public abstract virtual void Reset(ReadOnlySpan`1<byte> iv);
    public abstract virtual int get_BlockSizeInBytes();
    public abstract virtual int get_PaddingSizeInBytes();
}
public class System.Security.Cryptography.IncrementalHash : object {
    private HashAlgorithmName _algorithmName;
    private HashProvider _hash;
    private HMACCommon _hmac;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private int <HashLengthInBytes>k__BackingField;
    public int HashLengthInBytes { get; }
    public HashAlgorithmName AlgorithmName { get; }
    private IncrementalHash(HashAlgorithmName name, HashProvider hash);
    private IncrementalHash(HashAlgorithmName name, HMACCommon hmac);
    [CompilerGeneratedAttribute]
public int get_HashLengthInBytes();
    public HashAlgorithmName get_AlgorithmName();
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data);
    [NullableContextAttribute("1")]
public void AppendData(Byte[] data, int offset, int count);
    public void AppendData(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public Byte[] GetHashAndReset();
    public int GetHashAndReset(Span`1<byte> destination);
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    private int GetHashAndResetCore(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public Byte[] GetCurrentHash();
    public int GetCurrentHash(Span`1<byte> destination);
    public bool TryGetCurrentHash(Span`1<byte> destination, Int32& bytesWritten);
    private int GetCurrentHashCore(Span`1<byte> destination);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
    public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan`1<byte> key);
}
internal interface System.Security.Cryptography.IRuntimeAlgorithm {
}
internal static class System.Security.Cryptography.KdfWorkLimiter : object {
    [ThreadStaticAttribute]
private static State t_state;
    internal static void SetIterationLimit(ulong workLimit);
    internal static bool WasWorkLimitExceeded();
    internal static void ResetIterationLimit();
    internal static void RecordIterations(int workCount);
    internal static void RecordIterations(long workCount);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeyBlobHelpers : object {
    [ExtensionAttribute]
internal static Byte[] ToUnsignedIntegerBytes(ReadOnlyMemory`1<byte> memory, int length);
    [ExtensionAttribute]
internal static Byte[] ToUnsignedIntegerBytes(ReadOnlyMemory`1<byte> memory);
    [ExtensionAttribute]
internal static Byte[] ExportKeyParameter(BigInteger value, int length);
    [ExtensionAttribute]
internal static void WriteKeyParameterInteger(AsnWriter writer, ReadOnlySpan`1<byte> integer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.KeyedHashAlgorithm : HashAlgorithm {
    protected Byte[] KeyValue;
    public Byte[] Key { get; public set; }
    [ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static KeyedHashAlgorithm Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static KeyedHashAlgorithm Create(string algName);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void Dispose(bool disposing);
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WritePkcs8(AsnWriter algorithmIdentifierWriter, AsnWriter privateKeyWriter, AsnWriter attributesWriter);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<char> newPassword, PbeParameters pbeParameters);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<byte> newPasswordBytes, PbeParameters pbeParameters);
}
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
}
public class System.Security.Cryptography.KeySizes : object {
    [CompilerGeneratedAttribute]
private int <MinSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipSize>k__BackingField;
    public int MinSize { get; private set; }
    public int MaxSize { get; private set; }
    public int SkipSize { get; private set; }
    public KeySizes(int minSize, int maxSize, int skipSize);
    [CompilerGeneratedAttribute]
public int get_MinSize();
    [CompilerGeneratedAttribute]
private void set_MinSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxSize();
    [CompilerGeneratedAttribute]
private void set_MaxSize(int value);
    [CompilerGeneratedAttribute]
public int get_SkipSize();
    [CompilerGeneratedAttribute]
private void set_SkipSize(int value);
}
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.LiteHash : ValueType {
    private SafeBCryptHashHandle _hashHandle;
    private int _hashSizeInBytes;
    public int HashSizeInBytes { get; }
    internal LiteHash(string algorithm);
    public sealed virtual int get_HashSizeInBytes();
    public sealed virtual void Append(ReadOnlySpan`1<byte> data);
    public sealed virtual int Finalize(Span`1<byte> destination);
    public sealed virtual void Dispose();
}
internal static class System.Security.Cryptography.LiteHashProvider : object {
    internal static int HashStream(string hashAlgorithmId, int hashSizeInBytes, Stream source, Span`1<byte> destination);
    internal static Byte[] HashStream(string hashAlgorithmId, int hashSizeInBytes, Stream source);
    internal static ValueTask`1<int> HashStreamAsync(string hashAlgorithmId, int hashSizeInBytes, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    internal static ValueTask`1<Byte[]> HashStreamAsync(string hashAlgorithmId, int hashSizeInBytes, Stream source, CancellationToken cancellationToken);
    internal static int HmacStream(string hashAlgorithmId, int hashSizeInBytes, ReadOnlySpan`1<byte> key, Stream source, Span`1<byte> destination);
    internal static Byte[] HmacStream(string hashAlgorithmId, int hashSizeInBytes, ReadOnlySpan`1<byte> key, Stream source);
    internal static ValueTask`1<int> HmacStreamAsync(string hashAlgorithmId, int hashSizeInBytes, ReadOnlySpan`1<byte> key, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    internal static ValueTask`1<Byte[]> HmacStreamAsync(string hashAlgorithmId, int hashSizeInBytes, ReadOnlySpan`1<byte> key, Stream source, CancellationToken cancellationToken);
    private static int ProcessStream(T hash, Stream source, Span`1<byte> destination);
    [AsyncStateMachineAttribute("System.Security.Cryptography.LiteHashProvider/<ProcessStreamAsync>d__9`1")]
private static ValueTask`1<int> ProcessStreamAsync(T hash, Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Security.Cryptography.LiteHashProvider/<ProcessStreamAsync>d__10`1")]
private static ValueTask`1<Byte[]> ProcessStreamAsync(T hash, Stream source, CancellationToken cancellationToken);
    private static LiteHash CreateHash(string hashAlgorithmId);
    private static LiteHmac CreateHmac(string hashAlgorithmId, ReadOnlySpan`1<byte> key);
}
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.LiteHmac : ValueType {
    private SafeBCryptHashHandle _hashHandle;
    private int _hashSizeInBytes;
    public int HashSizeInBytes { get; }
    internal LiteHmac(string algorithm, ReadOnlySpan`1<byte> key);
    public sealed virtual int get_HashSizeInBytes();
    public sealed virtual void Append(ReadOnlySpan`1<byte> data);
    public sealed virtual int Finalize(Span`1<byte> destination);
    public sealed virtual void Dispose();
}
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    [NullableContextAttribute("1")]
public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static MD5 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static MD5 Create(string algName);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Byte[] source);
    [UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    [UnsupportedOSPlatformAttribute("browser")]
public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    [UnsupportedOSPlatformAttribute("browser")]
public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Oid : object {
    private string _value;
    private string _friendlyName;
    private bool _hasInitializedFriendlyName;
    private OidGroup _group;
    public string Value { get; public set; }
    public string FriendlyName { get; public set; }
    [NullableContextAttribute("1")]
public Oid(string oid);
    public Oid(string value, string friendlyName);
    [NullableContextAttribute("1")]
public Oid(Oid oid);
    private Oid(string value, string friendlyName, OidGroup group);
    [NullableContextAttribute("1")]
public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    [NullableContextAttribute("1")]
public static Oid FromOidValue(string oidValue, OidGroup group);
    public string get_Value();
    public void set_Value(string value);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    private Oid[] _oids;
    private int _count;
    public Oid Item { get; }
    [NullableAttribute("2")]
public Oid Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Add(Oid oid);
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual int get_Count();
    public OidEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Oid[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.OidEnumerator : object {
    private OidCollection _oids;
    private int _current;
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OidEnumerator(OidCollection oids);
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
}
internal static class System.Security.Cryptography.OidLookup : object {
    private static ConcurrentDictionary`2<string, string> s_lateBoundOidToFriendlyName;
    private static ConcurrentDictionary`2<string, string> s_lateBoundFriendlyNameToOid;
    private static Dictionary`2<string, string> s_friendlyNameToOid;
    private static Dictionary`2<string, string> s_oidToFriendlyName;
    private static Dictionary`2<string, string> s_compatOids;
    private static OidLookup();
    public static string ToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    public static string ToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
    private static void InitializeLookupDictionaries();
    private static bool ShouldUseCache(OidGroup oidGroup);
    private static string NativeOidToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    private static string NativeFriendlyNameToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
    [CompilerGeneratedAttribute]
internal static void <InitializeLookupDictionaries>g__AddEntry|10_0(string oid, string primaryFriendlyName, String[] additionalFriendlyNames);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.Oids : object {
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_ecPublicKeyOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_secp256R1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_secp384R1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_secp521R1Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_pkcs9ExtensionRequestOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_basicConstraints2Oid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_enhancedKeyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_keyUsageOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_subjectAltNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_subjectKeyIdentifierOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_authorityKeyIdentifierOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_authorityInformationAccessOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_crlNumberOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_crlDistributionPointOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_commonNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_countryOrRegionOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_localityNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_stateOrProvinceNameOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_organizationOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_organizationalUnitOid;
    private static Oid modreq(System.Runtime.CompilerServices.IsVolatile) s_emailAddressOid;
    internal static Oid StateOrProvinceNameOid;
    internal static Oid OrganizationOid;
    internal static Oid OrganizationalUnitOid;
    internal static Oid EmailAddressOid;
    internal static Oid RsaOid { get; }
    internal static Oid EcPublicKeyOid { get; }
    internal static Oid secp256r1Oid { get; }
    internal static Oid secp384r1Oid { get; }
    internal static Oid secp521r1Oid { get; }
    internal static Oid Pkcs9ExtensionRequestOid { get; }
    internal static Oid BasicConstraints2Oid { get; }
    internal static Oid EnhancedKeyUsageOid { get; }
    internal static Oid KeyUsageOid { get; }
    internal static Oid AuthorityKeyIdentifierOid { get; }
    internal static Oid SubjectKeyIdentifierOid { get; }
    internal static Oid SubjectAltNameOid { get; }
    internal static Oid AuthorityInformationAccessOid { get; }
    internal static Oid CrlNumberOid { get; }
    internal static Oid CrlDistributionPointsOid { get; }
    internal static Oid CommonNameOid { get; }
    internal static Oid CountryOrRegionNameOid { get; }
    internal static Oid LocalityNameOid { get; }
    private static Oids();
    internal static Oid get_RsaOid();
    internal static Oid get_EcPublicKeyOid();
    internal static Oid get_secp256r1Oid();
    internal static Oid get_secp384r1Oid();
    internal static Oid get_secp521r1Oid();
    internal static Oid get_Pkcs9ExtensionRequestOid();
    internal static Oid get_BasicConstraints2Oid();
    internal static Oid get_EnhancedKeyUsageOid();
    internal static Oid get_KeyUsageOid();
    internal static Oid get_AuthorityKeyIdentifierOid();
    internal static Oid get_SubjectKeyIdentifierOid();
    internal static Oid get_SubjectAltNameOid();
    internal static Oid get_AuthorityInformationAccessOid();
    internal static Oid get_CrlNumberOid();
    internal static Oid get_CrlDistributionPointsOid();
    internal static Oid get_CommonNameOid();
    internal static Oid get_CountryOrRegionNameOid();
    internal static Oid get_LocalityNameOid();
    private static Oid InitializeOid(string oidValue);
    internal static Oid GetSharedOrNewOid(AsnValueReader& asnValueReader);
    internal static Oid GetSharedOrNullOid(AsnValueReader& asnValueReader, Nullable`1<Asn1Tag> expectedTag);
    [ExtensionAttribute]
internal static bool ValueEquals(Oid oid, Oid other);
}
public enum System.Security.Cryptography.PaddingMode : Enum {
    public int value__;
    public static PaddingMode None;
    public static PaddingMode PKCS7;
    public static PaddingMode Zeros;
    public static PaddingMode ANSIX923;
    public static PaddingMode ISO10126;
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, AsnWriter source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<int> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(int iterationCount, Nullable`1<int> iterationLimit);
    private static RC2 CreateRC2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    private int _extraCount;
    private int _prefix;
    private int _iterations;
    private Byte[] _baseValue;
    private Byte[] _extra;
    private Byte[] _salt;
    private Byte[] _password;
    private string _hashName;
    private HashAlgorithm _hash;
    private CspParameters _cspParams;
    private SafeProvHandle _safeProvHandle;
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    [NullableAttribute("2")]
public Byte[] Salt { get; public set; }
    private SafeProvHandle ProvHandle { get; }
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("1", "System.Security.Cryptography.SHA1CryptoServiceProvider")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("1", "System.Security.Cryptography.SHA1CryptoServiceProvider")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    [RequiresUnreferencedCodeAttribute("The hash implementation might be removed. Ensure the referenced hash algorithm is not trimmed.")]
public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    [NullableContextAttribute("2")]
public Byte[] get_Salt();
    [NullableContextAttribute("2")]
public void set_Salt(Byte[] value);
    [ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    private Byte[] ComputeBaseValue();
    private Byte[] ComputeBytes(int cb);
    private void HashPrefix(CryptoStream cs);
    [SupportedOSPlatformAttribute("windows")]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    private SafeProvHandle get_ProvHandle();
    private static SafeProvHandle AcquireSafeProviderHandle(CspParameters cspParams);
}
public enum System.Security.Cryptography.PbeEncryptionAlgorithm : Enum {
    public int value__;
    public static PbeEncryptionAlgorithm Unknown;
    public static PbeEncryptionAlgorithm Aes128Cbc;
    public static PbeEncryptionAlgorithm Aes192Cbc;
    public static PbeEncryptionAlgorithm Aes256Cbc;
    public static PbeEncryptionAlgorithm TripleDes3KeyPkcs12;
}
public class System.Security.Cryptography.PbeParameters : object {
    [CompilerGeneratedAttribute]
private PbeEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IterationCount>k__BackingField;
    public PbeEncryptionAlgorithm EncryptionAlgorithm { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; }
    public PbeParameters(PbeEncryptionAlgorithm encryptionAlgorithm, HashAlgorithmName hashAlgorithm, int iterationCount);
    [CompilerGeneratedAttribute]
public PbeEncryptionAlgorithm get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public int get_IterationCount();
}
internal static class System.Security.Cryptography.Pbkdf2Implementation : object {
    private static bool s_useKeyDerivation;
    private static SafeBCryptAlgorithmHandle s_pbkdf2AlgorithmHandle;
    private static Pbkdf2Implementation();
    public static void Fill(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithmName, Span`1<byte> destination);
    private static void FillKeyDerivation(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, string hashAlgorithmName, Span`1<byte> destination);
    private static void FillDeriveKeyPBKDF2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, string hashAlgorithmName, Span`1<byte> destination);
    private static int GetHashBlockSize(string hashAlgorithmName);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.PemEncoding : object {
    public static PemFields Find(ReadOnlySpan`1<char> pemData);
    public static bool TryFind(ReadOnlySpan`1<char> pemData, PemFields& fields);
    [ExtensionAttribute]
private static int IndexOfByOffset(ReadOnlySpan`1<char> str, ReadOnlySpan`1<char> value, int startPosition);
    private static bool IsValidLabel(ReadOnlySpan`1<char> data);
    private static bool TryCountBase64(ReadOnlySpan`1<char> str, Int32& base64Start, Int32& base64End, Int32& base64DecodedSize);
    private static bool IsBase64Character(char ch);
    private static bool IsWhiteSpaceCharacter(char ch);
    public static int GetEncodedSize(int labelLength, int dataLength);
    public static bool TryWrite(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data, Span`1<char> destination, Int32& charsWritten);
    private static int WriteCore(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data, Span`1<char> destination);
    public static Char[] Write(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data);
    public static string WriteString(ReadOnlySpan`1<char> label, ReadOnlySpan`1<byte> data);
    [CompilerGeneratedAttribute]
internal static ReadOnlySpan`1<char> <TryFind>g__WritePostEB|5_0(ReadOnlySpan`1<char> label, Span`1<char> destination);
    [CompilerGeneratedAttribute]
internal static bool <IsValidLabel>g__IsLabelChar|7_0(char c);
    [CompilerGeneratedAttribute]
internal static int <WriteCore>g__Write|13_0(ReadOnlySpan`1<char> str, Span`1<char> dest, int offset);
    [CompilerGeneratedAttribute]
internal static int <WriteCore>g__WriteBase64|13_1(ReadOnlySpan`1<byte> bytes, Span`1<char> dest, int offset);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
internal class System.Security.Cryptography.PemEnumerator : ValueType {
    private ReadOnlySpan`1<char> _contents;
    public PemEnumerator(ReadOnlySpan`1<char> contents);
    public Enumerator GetEnumerator();
}
[IsReadOnlyAttribute]
public class System.Security.Cryptography.PemFields : ValueType {
    [CompilerGeneratedAttribute]
private Range <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Range <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Range <Base64Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DecodedDataLength>k__BackingField;
    public Range Location { get; }
    public Range Label { get; }
    public Range Base64Data { get; }
    public int DecodedDataLength { get; }
    internal PemFields(Range label, Range base64data, Range location, int decodedDataLength);
    [CompilerGeneratedAttribute]
public Range get_Location();
    [CompilerGeneratedAttribute]
public Range get_Label();
    [CompilerGeneratedAttribute]
public Range get_Base64Data();
    [CompilerGeneratedAttribute]
public int get_DecodedDataLength();
}
internal static class System.Security.Cryptography.PemKeyHelpers : object {
    public static bool TryExportToEncryptedPem(T arg, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, TryExportEncryptedKeyAction`1<T> exporter, Span`1<char> destination, Int32& charsWritten);
    public static bool TryExportToPem(T arg, string label, TryExportKeyAction`1<T> exporter, Span`1<char> destination, Int32& charsWritten);
    public static void ImportEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<TPass> password, ImportEncryptedKeyAction`1<TPass> importAction);
    public static void ImportPem(ReadOnlySpan`1<char> input, FindImportActionFunc callback);
}
internal class System.Security.Cryptography.PinAndClear : ValueType {
    private Byte[] _data;
    private GCHandle _gcHandle;
    internal static PinAndClear Track(Byte[] data);
    public sealed virtual void Dispose();
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static ValueTuple`3[] s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    private string _hashNameValue;
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    [NullableContextAttribute("0")]
public virtual void GetNonZeroBytes(Span`1<byte> data);
    [NullableContextAttribute("0")]
public static void Fill(Span`1<byte> data);
    public static int GetInt32(int fromInclusive, int toExclusive);
    public static int GetInt32(int toExclusive);
    public static Byte[] GetBytes(int count);
    internal static void VerifyGetBytes(Byte[] data, int offset, int count);
}
internal class System.Security.Cryptography.RandomNumberGeneratorImplementation : RandomNumberGenerator {
    internal static RandomNumberGeneratorImplementation s_singleton;
    private static RandomNumberGeneratorImplementation();
    internal static void FillSpan(Span`1<byte> data);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
    private static void GetBytes(Byte* pbBuffer, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public int KeySize { get; public set; }
    public int EffectiveKeySize { get; public set; }
    private static RC2();
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
public static RC2 Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static RC2 Create(string AlgName);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    private bool _use40bitSalt;
    private static KeySizes[] s_legalKeySizes;
    public int EffectiveKeySize { get; public set; }
    public bool UseSalt { get; public set; }
    private static RC2CryptoServiceProvider();
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public bool get_UseSalt();
    [SupportedOSPlatformAttribute("windows")]
public void set_UseSalt(bool value);
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
}
internal class System.Security.Cryptography.RC2Implementation : RC2 {
    public int EffectiveKeySize { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void ValidateCFBFeedbackSize(int feedback);
    private int GetPaddingSize();
    private bool ValidKeySize(int keySizeBytes);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int feedbackSize, int paddingSize, bool encrypting);
    private static ILiteSymmetricCipher CreateLiteCipher(CipherMode cipherMode, PaddingMode paddingMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int feedbackSizeInBytes, int paddingSize, bool encrypting);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    private Byte[] _salt;
    private UInt32 _iterations;
    private IncrementalHash _hmac;
    private int _blockSize;
    private Byte[] _buffer;
    private UInt32 _block;
    private int _startIndex;
    private int _endIndex;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    private static Encoding s_throwingUtf8Encoding;
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, Byte[] salt);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, int saltSize);
    [ObsoleteAttribute("The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.")]
public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    internal Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, bool clearPassword);
    internal Rfc2898DeriveBytes(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm);
    private static Rfc2898DeriveBytes();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    internal void GetBytes(Span`1<byte> destination);
    [ObsoleteAttribute("Rfc2898DeriveBytes.CryptDeriveKey is obsolete and is not supported. Use PasswordDeriveBytes.CryptDeriveKey instead.")]
public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    public virtual void Reset();
    private IncrementalHash OpenHmac(ReadOnlySpan`1<byte> password);
    [MemberNotNullAttribute("_buffer")]
private void Initialize();
    private void Func();
    public static Byte[] Pbkdf2(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static Byte[] Pbkdf2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static void Pbkdf2(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    public static Byte[] Pbkdf2(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static Byte[] Pbkdf2(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, int iterations, HashAlgorithmName hashAlgorithm, int outputLength);
    [NullableContextAttribute("0")]
public static void Pbkdf2(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    private static void Pbkdf2Core(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    private static void Pbkdf2Core(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> destination, int iterations, HashAlgorithmName hashAlgorithm);
    private static void ValidateHashAlgorithm(HashAlgorithmName hashAlgorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Rijndael();
    [UnsupportedOSPlatformAttribute("browser")]
public static Rijndael Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static Rijndael Create(string algName);
}
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
internal class System.Security.Cryptography.RijndaelImplementation : Rijndael {
    private Aes _impl;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("The Rijndael and RijndaelManaged types are obsolete. Use Aes instead.")]
[EditorBrowsableAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    private Aes _impl;
    public int BlockSize { get; public set; }
    public int FeedbackSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("RNGCryptoServiceProvider is obsolete. To generate a random number, use one of the RandomNumberGenerator static methods instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    private RandomNumberGenerator _impl;
    public RNGCryptoServiceProvider(string str);
    public RNGCryptoServiceProvider(Byte[] rgb);
    [NullableContextAttribute("2")]
public RNGCryptoServiceProvider(CspParameters cspParams);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    [NullableContextAttribute("0")]
public virtual void GetNonZeroBytes(Span`1<byte> data);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static RSA Create(string algName);
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create(int keySizeInBits);
    [UnsupportedOSPlatformAttribute("browser")]
public static RSA Create(RSAParameters parameters);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("0")]
public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public Byte[] Encrypt(ReadOnlySpan`1<byte> data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public int Encrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding);
    public Byte[] Decrypt(ReadOnlySpan`1<byte> data, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
public int Decrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding);
    [NullableContextAttribute("0")]
protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    private static Exception DerivedClassMustOverride();
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public Byte[] SignData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public int SignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public Byte[] SignHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public int SignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("0")]
public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] ExportRSAPrivateKey();
    [NullableContextAttribute("0")]
public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportRSAPublicKey();
    [NullableContextAttribute("0")]
public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs8PrivateKey();
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs1PublicKey();
    private AsnWriter WritePkcs1PrivateKey();
    [NullableContextAttribute("0")]
public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("0")]
public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    [NullableContextAttribute("0")]
public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public string ExportRSAPrivateKeyPem();
    public string ExportRSAPublicKeyPem();
    [NullableContextAttribute("0")]
public bool TryExportRSAPrivateKeyPem(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public bool TryExportRSAPublicKeyPem(Span`1<char> destination, Int32& charsWritten);
    private static void ClearPrivateParameters(RSAParameters& rsaParameters);
    private Byte[] TryWithKeyBuffer(ReadOnlySpan`1<byte> input, TState state, TryFunc`1<TState> callback, bool tryKeySizeFirst);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    private static Byte[] ReadRequiredElement(ParseState& state, string name, int sizeHint);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    [CompilerGeneratedAttribute]
internal static bool <Encrypt>g__TryWithEncrypt|14_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <Decrypt>g__TryWithDecrypt|16_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <SignData>g__TryWithSignData|28_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, ValueTuple`2<HashAlgorithmName, RSASignaturePadding> state, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <SignHash>g__TryWithSignHash|30_0(RSA rsa, ReadOnlySpan`1<byte> input, Byte[] destination, ValueTuple`2<HashAlgorithmName, RSASignaturePadding> state, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
private ImportKeyAction <ImportFromPem>b__53_0(ReadOnlySpan`1<char> label);
    [CompilerGeneratedAttribute]
internal static bool <TryExportRSAPrivateKeyPem>g__Export|58_0(RSA alg, Span`1<byte> destination, Int32& bytesWritten);
    [CompilerGeneratedAttribute]
internal static bool <TryExportRSAPublicKeyPem>g__Export|59_0(RSA alg, Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.RSACng : RSA {
    private static ConcurrentDictionary`2<HashAlgorithmName, int> s_hashSizes;
    private CngAlgorithmCore _core;
    private static CngKeyBlobFormat s_rsaFullPrivateBlob;
    private static CngKeyBlobFormat s_rsaPrivateBlob;
    private static CngKeyBlobFormat s_rsaPublicBlob;
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    [NullableAttribute("1")]
public CngKey Key { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public RSACng(int keySize);
    [NullableContextAttribute("1")]
[SupportedOSPlatformAttribute("windows")]
public RSACng(CngKey key);
    [SupportedOSPlatformAttribute("windows")]
internal RSACng(CngKey key, bool transferOwnership);
    private static RSACng();
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    private void ForceSetKeySize(int newKeySize);
    [NullableContextAttribute("1")]
public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    [NullableContextAttribute("1")]
public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    private Byte[] EncryptOrDecrypt(Byte[] data, RSAEncryptionPadding padding, bool encrypt);
    private bool TryEncryptOrDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, bool encrypt, Int32& bytesWritten);
    private Byte[] EncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt);
    private static bool TryEncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, Span`1<byte> output, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt, Int32& bytesWritten);
    private static ErrorCode EncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, Span`1<byte> output, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt, Int32& bytesNeeded);
    public virtual void ImportParameters(RSAParameters parameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    [NullableContextAttribute("1")]
public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    private static void ExportParameters(RSAParameters& rsaParams, Byte[] rsaBlob, bool includePrivateParameters);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static int GetHashSizeInBytes(HashAlgorithmName hashAlgorithm);
    [NullableContextAttribute("1")]
public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void ImportKeyBlob(Byte[] rsaBlob, bool includePrivate);
    private void AcceptImport(Pkcs8Response response);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public CngKey get_Key();
    private void set_Key(CngKey value);
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    private int _keySize;
    private CspParameters _parameters;
    private bool _randomKeyContainer;
    private SafeCapiKeyHandle _safeKeyHandle;
    private SafeProvHandle _safeProvHandle;
    private static CspProviderFlags modreq(System.Runtime.CompilerServices.IsVolatile) s_useMachineKeyStore;
    private bool _disposed;
    private SafeProvHandle SafeProvHandle { get; private set; }
    private SafeCapiKeyHandle SafeKeyHandle { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public static bool UseMachineKeyStore { get; public set; }
    [NullableAttribute("2")]
public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public RSACryptoServiceProvider(int dwKeySize);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public RSACryptoServiceProvider(CspParameters parameters);
    private RSACryptoServiceProvider(int keySize, CspParameters parameters, bool useDefaultKeySize);
    private SafeProvHandle get_SafeProvHandle();
    private void set_SafeProvHandle(SafeProvHandle value);
    private SafeCapiKeyHandle get_SafeKeyHandle();
    private void set_SafeKeyHandle(SafeCapiKeyHandle value);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    private static SafeProvHandle AcquireSafeProviderHandle();
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(RSAParameters parameters);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("0")]
public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Stream inputStream, object halg);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    private Byte[] SignHash(Byte[] rgbHash, int calgHash);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    private bool VerifyHash(Byte[] rgbHash, int calgHash, Byte[] rgbSignature);
    private static bool IsPublic(Byte[] keyBlob);
    private static int GetAlgorithmId(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    [NullableContextAttribute("2")]
public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    private static Exception PaddingModeNotSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAEncryptionPadding : object {
    private static RSAEncryptionPadding s_pkcs1;
    private static RSAEncryptionPadding s_oaepSHA1;
    private static RSAEncryptionPadding s_oaepSHA256;
    private static RSAEncryptionPadding s_oaepSHA384;
    private static RSAEncryptionPadding s_oaepSHA512;
    private RSAEncryptionPaddingMode _mode;
    private HashAlgorithmName _oaepHashAlgorithm;
    public static RSAEncryptionPadding Pkcs1 { get; }
    public static RSAEncryptionPadding OaepSHA1 { get; }
    public static RSAEncryptionPadding OaepSHA256 { get; }
    public static RSAEncryptionPadding OaepSHA384 { get; }
    public static RSAEncryptionPadding OaepSHA512 { get; }
    public RSAEncryptionPaddingMode Mode { get; }
    public HashAlgorithmName OaepHashAlgorithm { get; }
    private RSAEncryptionPadding(RSAEncryptionPaddingMode mode, HashAlgorithmName oaepHashAlgorithm);
    private static RSAEncryptionPadding();
    public static RSAEncryptionPadding get_Pkcs1();
    public static RSAEncryptionPadding get_OaepSHA1();
    public static RSAEncryptionPadding get_OaepSHA256();
    public static RSAEncryptionPadding get_OaepSHA384();
    public static RSAEncryptionPadding get_OaepSHA512();
    public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
    public RSAEncryptionPaddingMode get_Mode();
    public HashAlgorithmName get_OaepHashAlgorithm();
    public virtual int GetHashCode();
    private static int CombineHashCodes(int h1, int h2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RSAEncryptionPadding other);
    [NullableContextAttribute("2")]
public static bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
    public int value__;
    public static RSAEncryptionPaddingMode Pkcs1;
    public static RSAEncryptionPaddingMode Oaep;
}
internal static class System.Security.Cryptography.RSAKeyFormatHelper : object {
    private static String[] s_validOids;
    private static RSAKeyFormatHelper();
    internal static void FromPkcs1PrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, RSAParameters& ret);
    internal static void ReadRsaPublicKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, RSAParameters& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ReadOnlySpan`1<byte> pkcs1PublicKey);
    internal static AsnWriter WritePkcs8PrivateKey(ReadOnlySpan`1<byte> pkcs1PrivateKey, AsnWriter copyFrom);
    private static void WriteAlgorithmIdentifier(AsnWriter writer);
    internal static AsnWriter WritePkcs1PublicKey(RSAParameters& rsaParameters);
    internal static AsnWriter WritePkcs1PrivateKey(RSAParameters& rsaParameters);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, RSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, RSAParameters& key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    [NullableAttribute("2")]
public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    [NullableContextAttribute("2")]
public virtual string get_Parameters();
    [NullableContextAttribute("2")]
public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private Byte[] ParameterValue;
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    [NullableContextAttribute("1")]
public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    [NullableContextAttribute("1")]
public virtual void SetKey(AsymmetricAlgorithm key);
    [NullableContextAttribute("1")]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    [NullableContextAttribute("1")]
public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAOpenSsl : RSA {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(int keySize);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(IntPtr handle);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(RSAParameters parameters);
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
    public SafeEvpPKeyHandle DuplicateKeyHandle();
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
}
internal static class System.Security.Cryptography.RsaPaddingProcessor : object {
    private static ReadOnlySpan`1<byte> DigestInfoMD5 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha1 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha256 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha384 { get; }
    private static ReadOnlySpan`1<byte> DigestInfoSha512 { get; }
    private static ReadOnlySpan`1<byte> get_DigestInfoMD5();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha1();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha256();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha384();
    private static ReadOnlySpan`1<byte> get_DigestInfoSha512();
    private static ReadOnlySpan`1<byte> GetDigestInfoForAlgorithm(HashAlgorithmName hashAlgorithmName, Int32& digestLengthInBytes);
    internal static int BytesRequiredForBitCount(int keySizeInBits);
    internal static int HashLength(HashAlgorithmName hashAlgorithmName);
    internal static void PadPkcs1Encryption(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal static void PadOaep(HashAlgorithmName hashAlgorithmName, ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    private static void Mgf1(IncrementalHash hasher, ReadOnlySpan`1<byte> mgfSeed, Span`1<byte> mask);
    private static void FillNonZeroBytes(Span`1<byte> data);
    private static void Xor(Span`1<byte> a, ReadOnlySpan`1<byte> b);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] D;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] Exponent;
    public Byte[] InverseQ;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public RandomNumberGenerator RNG { get; public set; }
    public string Parameters { get; public set; }
    [NullableContextAttribute("1")]
public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    [NullableContextAttribute("1")]
public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    [NullableContextAttribute("1")]
public virtual void SetKey(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public string Parameters { get; }
    [NullableAttribute("2")]
public RandomNumberGenerator Rng { get; public set; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    [NullableContextAttribute("2")]
public RandomNumberGenerator get_Rng();
    [NullableContextAttribute("2")]
public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    private RSA _rsaKey;
    private string _algName;
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    private RSA _rsaKey;
    private string _algName;
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.RSASignaturePadding : object {
    private static RSASignaturePadding s_pkcs1;
    private static RSASignaturePadding s_pss;
    private RSASignaturePaddingMode _mode;
    public static RSASignaturePadding Pkcs1 { get; }
    public static RSASignaturePadding Pss { get; }
    public RSASignaturePaddingMode Mode { get; }
    private RSASignaturePadding(RSASignaturePaddingMode mode);
    private static RSASignaturePadding();
    public static RSASignaturePadding get_Pkcs1();
    public static RSASignaturePadding get_Pss();
    public RSASignaturePaddingMode get_Mode();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RSASignaturePadding other);
    [NullableContextAttribute("2")]
public static bool op_Equality(RSASignaturePadding left, RSASignaturePadding right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSASignaturePaddingMode : Enum {
    public int value__;
    public static RSASignaturePaddingMode Pkcs1;
    public static RSASignaturePaddingMode Pss;
}
internal class System.Security.Cryptography.RSAWrapper : RSA {
    private RSA _wrapped;
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    internal RSAWrapper(RSA wrapped);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual Byte[] ExportPkcs8PrivateKey();
    public virtual Byte[] ExportSubjectPublicKeyInfo();
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] ExportRSAPrivateKey();
    public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportRSAPublicKey();
    public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportFromPem(ReadOnlySpan`1<char> input);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> password);
    public virtual void ImportFromEncryptedPem(ReadOnlySpan`1<char> input, ReadOnlySpan`1<byte> passwordBytes);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.Security.Cryptography.SafeCapiKeyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private int _keySpec;
    private bool _fPublicOnly;
    private SafeProvHandle _parent;
    unknown int KeySpec {internal set; }
    internal bool PublicOnly { get; internal set; }
    internal static SafeCapiKeyHandle InvalidHandle { get; }
    internal void set_KeySpec(int value);
    internal bool get_PublicOnly();
    internal void set_PublicOnly(bool value);
    internal void SetParent(SafeProvHandle parent);
    internal static SafeCapiKeyHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
public class System.Security.Cryptography.SafeEvpPKeyHandle : SafeHandle {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public static long OpenSslVersion { get; }
    public bool IsInvalid { get; }
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("windows")]
public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle);
    public static long get_OpenSslVersion();
    [NullableContextAttribute("1")]
public SafeEvpPKeyHandle DuplicateHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeHashHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private SafeProvHandle _parent;
    internal static SafeHashHandle InvalidHandle { get; }
    internal void SetParent(SafeProvHandle parent);
    internal static SafeHashHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private string _containerName;
    private string _providerName;
    private int _type;
    private UInt32 _flags;
    private bool _fPersistKeyInCsp;
    unknown string ContainerName {internal set; }
    unknown string ProviderName {internal set; }
    unknown int Types {internal set; }
    unknown UInt32 Flags {internal set; }
    internal bool PersistKeyInCsp { get; internal set; }
    internal static SafeProvHandle InvalidHandle { get; }
    internal void set_ContainerName(string value);
    internal void set_ProviderName(string value);
    internal void set_Types(int value);
    internal void set_Flags(UInt32 value);
    internal bool get_PersistKeyInCsp();
    internal void set_PersistKeyInCsp(bool value);
    internal static SafeProvHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA1 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA1 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA256 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA256 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA384 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA384 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static int HashSizeInBits;
    public static int HashSizeInBytes;
    [NullableContextAttribute("1")]
public static SHA512 Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SHA512 Create(string hashName);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Byte[] source);
    public static Byte[] HashData(ReadOnlySpan`1<byte> source);
    public static int HashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static int HashData(Stream source, Span`1<byte> destination);
    [NullableContextAttribute("1")]
public static Byte[] HashData(Stream source);
    [NullableContextAttribute("1")]
public static ValueTask`1<Byte[]> HashDataAsync(Stream source, CancellationToken cancellationToken);
    public static ValueTask`1<int> HashDataAsync(Stream source, Memory`1<byte> destination, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    private IncrementalHash _incrementalHash;
    private bool _running;
    public virtual void Initialize();
    [NullableContextAttribute("1")]
protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    private HashProvider _hashProvider;
    [NullableContextAttribute("1")]
protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Cryptography.SignatureDescription : object {
    [CompilerGeneratedAttribute]
private string <KeyAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatterAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeformatterAlgorithm>k__BackingField;
    public string KeyAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string DeformatterAlgorithm { get; public set; }
    [NullableContextAttribute("1")]
public SignatureDescription(SecurityElement el);
    [CompilerGeneratedAttribute]
public string get_KeyAlgorithm();
    [CompilerGeneratedAttribute]
public void set_KeyAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_FormatterAlgorithm();
    [CompilerGeneratedAttribute]
public void set_FormatterAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_DeformatterAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DeformatterAlgorithm(string value);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("CreateDeformatter is not trim compatible because the algorithm implementation referenced by DeformatterAlgorithm might be removed.")]
public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("CreateFormatter is not trim compatible because the algorithm implementation referenced by FormatterAlgorithm might be removed.")]
public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
    [RequiresUnreferencedCodeAttribute("CreateDigest is not trim compatible because the algorithm implementation referenced by DigestAlgorithm might be removed.")]
public virtual HashAlgorithm CreateDigest();
}
public abstract class System.Security.Cryptography.SymmetricAlgorithm : object {
    protected CipherMode ModeValue;
    protected PaddingMode PaddingValue;
    [NullableAttribute("2")]
protected Byte[] KeyValue;
    [NullableAttribute("2")]
protected Byte[] IVValue;
    protected int BlockSizeValue;
    protected int FeedbackSizeValue;
    protected int KeySizeValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalBlockSizesValue;
    [NullableAttribute("1")]
[MaybeNullAttribute]
protected KeySizes[] LegalKeySizesValue;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    [NullableAttribute("1")]
public Byte[] IV { get; public set; }
    [NullableAttribute("1")]
public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    [NullableAttribute("1")]
public KeySizes[] LegalBlockSizes { get; }
    [NullableAttribute("1")]
public KeySizes[] LegalKeySizes { get; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("The default implementation of this cryptography algorithm is not supported.")]
public static SymmetricAlgorithm Create();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static SymmetricAlgorithm Create(string algName);
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    [NullableContextAttribute("1")]
public virtual Byte[] get_IV();
    [NullableContextAttribute("1")]
public virtual void set_IV(Byte[] value);
    [NullableContextAttribute("1")]
public virtual Byte[] get_Key();
    [NullableContextAttribute("1")]
public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalBlockSizes();
    [NullableContextAttribute("1")]
public virtual KeySizes[] get_LegalKeySizes();
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    [NullableContextAttribute("1")]
public virtual ICryptoTransform CreateDecryptor();
    [NullableContextAttribute("1")]
public abstract virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    [NullableContextAttribute("1")]
public virtual ICryptoTransform CreateEncryptor();
    [NullableContextAttribute("1")]
public abstract virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GenerateIV();
    public abstract virtual void GenerateKey();
    public bool ValidKeySize(int bitLength);
    public int GetCiphertextLengthEcb(int plaintextLength, PaddingMode paddingMode);
    public int GetCiphertextLengthCbc(int plaintextLength, PaddingMode paddingMode);
    private int GetCiphertextLengthBlockAligned(int plaintextLength, PaddingMode paddingMode);
    public int GetCiphertextLengthCfb(int plaintextLength, PaddingMode paddingMode, int feedbackSizeInBits);
    [NullableContextAttribute("1")]
public Byte[] DecryptEcb(Byte[] ciphertext, PaddingMode paddingMode);
    public Byte[] DecryptEcb(ReadOnlySpan`1<byte> ciphertext, PaddingMode paddingMode);
    public int DecryptEcb(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryDecryptEcb(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public Byte[] EncryptEcb(Byte[] plaintext, PaddingMode paddingMode);
    public Byte[] EncryptEcb(ReadOnlySpan`1<byte> plaintext, PaddingMode paddingMode);
    public int EncryptEcb(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryEncryptEcb(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public Byte[] DecryptCbc(Byte[] ciphertext, Byte[] iv, PaddingMode paddingMode);
    public Byte[] DecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode);
    public int DecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryDecryptCbc(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode);
    [NullableContextAttribute("1")]
public Byte[] EncryptCbc(Byte[] plaintext, Byte[] iv, PaddingMode paddingMode);
    public Byte[] EncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode);
    public int EncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode);
    public bool TryEncryptCbc(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode);
    [NullableContextAttribute("1")]
public Byte[] DecryptCfb(Byte[] ciphertext, Byte[] iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public Byte[] DecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public int DecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits);
    public bool TryDecryptCfb(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode, int feedbackSizeInBits);
    [NullableContextAttribute("1")]
public Byte[] EncryptCfb(Byte[] plaintext, Byte[] iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public Byte[] EncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, PaddingMode paddingMode, int feedbackSizeInBits);
    public int EncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits);
    public bool TryEncryptCfb(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, Int32& bytesWritten, PaddingMode paddingMode, int feedbackSizeInBits);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void CheckPaddingMode(PaddingMode paddingMode);
    private void CheckInitializationVectorSize(ReadOnlySpan`1<byte> iv);
    private void CheckFeedbackSize(int feedbackSizeInBits);
}
internal static class System.Security.Cryptography.SymmetricPadding : object {
    public static int GetCiphertextLength(int plaintextLength, int paddingSizeInBytes, PaddingMode paddingMode);
    public static int PadBlock(ReadOnlySpan`1<byte> block, Span`1<byte> destination, int paddingSizeInBytes, PaddingMode paddingMode);
    public static bool DepaddingRequired(PaddingMode padding);
    public static int GetPaddingLength(ReadOnlySpan`1<byte> block, PaddingMode paddingMode, int blockSize);
}
internal static class System.Security.Cryptography.ThrowHelper : object {
    public static void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [DoesNotReturnAttribute]
public static void ThrowArgumentNull(ExceptionArgument argument);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRange(ExceptionArgument argument);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOffLen();
    [DoesNotReturnAttribute]
public static void ThrowBase64FormatException();
}
public class System.Security.Cryptography.ToBase64Transform : object {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    [NullableContextAttribute("1")]
public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static TripleDES();
    [UnsupportedOSPlatformAttribute("browser")]
public static TripleDES Create();
    [ObsoleteAttribute("Cryptographic factory methods accepting an algorithm name are obsolete. Use the parameterless Create factory method on the algorithm type instead.")]
[RequiresUnreferencedCodeAttribute("The default algorithm implementations might be removed, use strong type references like 'RSA.Create()' instead.")]
public static TripleDES Create(string str);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static bool IsWeakKey(Byte[] rgbKey);
    private static bool EqualBytes(Byte[] rgbKey, int start1, int start2, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.TripleDESCng : TripleDES {
    private CngSymmetricAlgorithmCore _core;
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    private Byte[] System.Security.Cryptography.ICngSymmetricAlgorithm.BaseKey { get; private set; }
    private int System.Security.Cryptography.ICngSymmetricAlgorithm.BaseKeySize { get; private set; }
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName);
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName, CngProvider provider);
    [SupportedOSPlatformAttribute("windows")]
public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    [NullableContextAttribute("0")]
protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override Byte[] System.Security.Cryptography.ICngSymmetricAlgorithm.get_BaseKey();
    private sealed virtual override void System.Security.Cryptography.ICngSymmetricAlgorithm.set_BaseKey(Byte[] value);
    private sealed virtual override int System.Security.Cryptography.ICngSymmetricAlgorithm.get_BaseKeySize();
    private sealed virtual override void System.Security.Cryptography.ICngSymmetricAlgorithm.set_BaseKeySize(int value);
    private sealed virtual override bool System.Security.Cryptography.ICngSymmetricAlgorithm.IsWeakKey(Byte[] key);
    private sealed virtual override int System.Security.Cryptography.ICngSymmetricAlgorithm.GetPaddingSize(CipherMode mode, int feedbackSizeBits);
    private sealed virtual override SafeAlgorithmHandle System.Security.Cryptography.ICngSymmetricAlgorithm.GetEphemeralModeHandle(CipherMode mode, int feedbackSizeInBits);
    private sealed virtual override string System.Security.Cryptography.ICngSymmetricAlgorithm.GetNCryptAlgorithmIdentifier();
    private sealed virtual override Byte[] System.Security.Cryptography.ICngSymmetricAlgorithm.PreprocessKey(Byte[] key);
    private sealed virtual override bool System.Security.Cryptography.ICngSymmetricAlgorithm.IsValidEphemeralFeedbackSize(int feedbackSizeInBits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Derived cryptographic types are obsolete. Use the Create method on the base type instead.")]
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    private TripleDES _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateDecryptor();
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.TripleDesImplementation : TripleDES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    protected virtual bool TryDecryptEcbCore(ReadOnlySpan`1<byte> ciphertext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptEcbCore(ReadOnlySpan`1<byte> plaintext, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryEncryptCbcCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCbcCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, Int32& bytesWritten);
    protected virtual bool TryDecryptCfbCore(ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    protected virtual bool TryEncryptCfbCore(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> iv, Span`1<byte> destination, PaddingMode paddingMode, int feedbackSizeInBits, Int32& bytesWritten);
    private static void ValidateCFBFeedbackSize(int feedback);
    private static UniversalCryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, int paddingSize, int feedbackSize, bool encrypting);
    private static ILiteSymmetricCipher CreateLiteCipher(CipherMode cipherMode, PaddingMode paddingMode, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, int blockSize, int paddingSize, int feedbackSize, bool encrypting);
}
internal class System.Security.Cryptography.UniversalCryptoDecryptor : UniversalCryptoTransform {
    private Byte[] _heldoverCipher;
    public UniversalCryptoDecryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
}
internal class System.Security.Cryptography.UniversalCryptoEncryptor : UniversalCryptoTransform {
    public UniversalCryptoEncryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
}
internal static class System.Security.Cryptography.UniversalCryptoOneShot : object {
    public static bool OneShotDecrypt(ILiteSymmetricCipher cipher, PaddingMode paddingMode, ReadOnlySpan`1<byte> input, Span`1<byte> output, Int32& bytesWritten);
    public static bool OneShotEncrypt(ILiteSymmetricCipher cipher, PaddingMode paddingMode, ReadOnlySpan`1<byte> input, Span`1<byte> output, Int32& bytesWritten);
}
internal abstract class System.Security.Cryptography.UniversalCryptoTransform : object {
    [CompilerGeneratedAttribute]
private PaddingMode <PaddingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicSymmetricCipher <BasicSymmetricCipher>k__BackingField;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    protected int PaddingSizeBytes { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected PaddingMode PaddingMode { get; private set; }
    protected BasicSymmetricCipher BasicSymmetricCipher { get; private set; }
    protected UniversalCryptoTransform(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    public static UniversalCryptoTransform Create(PaddingMode paddingMode, BasicSymmetricCipher cipher, bool encrypting);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    protected int get_PaddingSizeBytes();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void Dispose(bool disposing);
    protected int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual int UncheckedTransformBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    protected abstract virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected abstract virtual int UncheckedTransformFinalBlock(ReadOnlySpan`1<byte> inputBuffer, Span`1<byte> outputBuffer);
    [CompilerGeneratedAttribute]
protected PaddingMode get_PaddingMode();
    [CompilerGeneratedAttribute]
private void set_PaddingMode(PaddingMode value);
    [CompilerGeneratedAttribute]
protected BasicSymmetricCipher get_BasicSymmetricCipher();
    [CompilerGeneratedAttribute]
private void set_BasicSymmetricCipher(BasicSymmetricCipher value);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.AccessDescriptionAsn : ValueType {
    internal string AccessMethod;
    internal GeneralNameAsn AccessLocation;
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, AccessDescriptionAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AccessDescriptionAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, AccessDescriptionAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificateAsn : ValueType {
    internal TbsCertificateAsn TbsCertificate;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CertificateAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CertificateAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificateAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificationRequestAsn : ValueType {
    internal CertificationRequestInfoAsn CertificationRequestInfo;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificationRequestInfoAsn : ValueType {
    internal BigInteger Version;
    internal ReadOnlyMemory`1<byte> Subject;
    internal SubjectPublicKeyInfoAsn SubjectPublicKeyInfo;
    internal AttributeAsn[] Attributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, CertificationRequestInfoAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificationRequestInfoAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, CertificationRequestInfoAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.TbsCertificateAsn : ValueType {
    internal int Version;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> Issuer;
    internal ValidityAsn Validity;
    internal ReadOnlyMemory`1<byte> Subject;
    internal SubjectPublicKeyInfoAsn SubjectPublicKeyInfo;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IssuerUniqueId;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectUniqueId;
    internal X509ExtensionAsn[] Extensions;
    private static ReadOnlySpan`1<byte> DefaultVersion { get; }
    private static ReadOnlySpan`1<byte> get_DefaultVersion();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, TbsCertificateAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, TbsCertificateAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, TbsCertificateAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.TimeAsn : ValueType {
    internal Nullable`1<DateTimeOffset> UtcTime;
    internal Nullable`1<DateTimeOffset> GeneralTime;
    public TimeAsn(DateTimeOffset dateTimeOffset);
    internal void Encode(AsnWriter writer);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, TimeAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, TimeAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.ValidityAsn : ValueType {
    internal TimeAsn NotBefore;
    internal TimeAsn NotAfter;
    public ValidityAsn(DateTimeOffset notBefore, DateTimeOffset notAfter);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnValueReader& reader, ReadOnlyMemory`1<byte> rebind, ValidityAsn& decoded);
    internal static void Decode(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ValidityAsn& decoded);
    private static void DecodeCore(AsnValueReader& reader, Asn1Tag expectedTag, ReadOnlyMemory`1<byte> rebind, ValidityAsn& decoded);
}
internal class System.Security.Cryptography.X509Certificates.CERT_BASIC_CONSTRAINTS_INFO : ValueType {
    public CRYPT_BIT_BLOB SubjectType;
    public int fPathLenConstraint;
    public int dwPathLenConstraint;
    public int cSubtreesConstraint;
    public DATA_BLOB* rgSubtreesConstraint;
}
internal class System.Security.Cryptography.X509Certificates.CERT_BASIC_CONSTRAINTS2_INFO : ValueType {
    public int fCA;
    public int fPathLenConstraint;
    public int dwPathLenConstraint;
}
internal class System.Security.Cryptography.X509Certificates.CERT_CHAIN_CONTEXT : ValueType {
    public int cbSize;
    public CERT_TRUST_STATUS TrustStatus;
    public int cChain;
    public CERT_SIMPLE_CHAIN** rgpChain;
    public int cLowerQualityChainContext;
    public CERT_CHAIN_CONTEXT** rgpLowerQualityChainContext;
    public int fHasRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
    public int dwCreateFlags;
    public Guid ChainId;
}
internal class System.Security.Cryptography.X509Certificates.CERT_CHAIN_ELEMENT : ValueType {
    public int cbSize;
    public CERT_CONTEXT* pCertContext;
    public CERT_TRUST_STATUS TrustStatus;
    public IntPtr pRevocationInfo;
    public IntPtr pIssuanceUsage;
    public IntPtr pApplicationUsage;
    public IntPtr pwszExtendedErrorInfo;
}
internal class System.Security.Cryptography.X509Certificates.CERT_DSS_PARAMETERS : ValueType {
    public DATA_BLOB p;
    public DATA_BLOB q;
    public DATA_BLOB g;
}
internal class System.Security.Cryptography.X509Certificates.CERT_ENHKEY_USAGE : ValueType {
    public int cUsageIdentifier;
    public IntPtr* rgpszUsageIdentifier;
}
internal class System.Security.Cryptography.X509Certificates.CERT_NAME_VALUE : ValueType {
    public int dwValueType;
    public DATA_BLOB Value;
}
internal class System.Security.Cryptography.X509Certificates.CERT_POLICIES_INFO : ValueType {
    public int cPolicyInfo;
    public CERT_POLICY_INFO* rgPolicyInfo;
}
internal class System.Security.Cryptography.X509Certificates.CERT_POLICY_INFO : ValueType {
    public IntPtr pszPolicyIdentifier;
    public int cPolicyQualifier;
    public IntPtr rgPolicyQualifier;
}
internal class System.Security.Cryptography.X509Certificates.CERT_SIMPLE_CHAIN : ValueType {
    public int cbSize;
    public CERT_TRUST_STATUS TrustStatus;
    public int cElement;
    public CERT_CHAIN_ELEMENT** rgpElement;
    public IntPtr pTrustListInfo;
    public int fHasRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
}
internal class System.Security.Cryptography.X509Certificates.CERT_TEMPLATE_EXT : ValueType {
    public IntPtr pszObjId;
    public int dwMajorVersion;
    public int fMinorVersion;
    public int dwMinorVersion;
}
internal class System.Security.Cryptography.X509Certificates.CERT_TRUST_STATUS : ValueType {
    public CertTrustErrorStatus dwErrorStatus;
    public CertTrustInfoStatus dwInfoStatus;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.X509Certificates.CertificateExtensionsCommon : object {
    [ExtensionAttribute]
public static T GetPublicKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    [ExtensionAttribute]
public static T GetPrivateKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    private static string GetExpectedOidValue();
}
internal class System.Security.Cryptography.X509Certificates.CertificatePal : object {
    private SafeCertContextHandle _certContext;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public bool HasPrivateKey { get; }
    private CertificatePal(CertificatePal copyFrom);
    private CertificatePal(SafeCertContextHandle certContext, bool deleteKeyContainer);
    internal static ICertificatePal FromHandle(IntPtr handle);
    internal static ICertificatePal FromOtherCert(X509Certificate copyFrom);
    internal static ICertificatePal FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static ICertificatePal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public sealed virtual IntPtr get_Handle();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_Subject();
    public sealed virtual string get_LegacyIssuer();
    public sealed virtual string get_LegacySubject();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    private Byte[] PropagateKeyAlgorithmParametersFromChain();
    public sealed virtual Byte[] get_PublicKeyValue();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual int get_Version();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual PolicyData GetPolicyData();
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public sealed virtual void Dispose();
    internal SafeCertContextHandle GetCertContext();
    private static CertNameType MapNameType(X509NameType nameType);
    private string GetIssuerOrSubject(bool issuer, bool reverse);
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    private static ICertificatePal FromBlobOrFile(ReadOnlySpan`1<byte> rawData, string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    private static SafeCertContextHandle GetSignerInPKCS7Store(SafeCertStoreHandle hCertStore, SafeCryptMsgHandle hCryptMsg);
    private static SafeCertContextHandle FilterPFXStore(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, PfxCertStoreFlags pfxCertStoreFlags);
    private static PfxCertStoreFlags MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    public sealed virtual bool get_HasPrivateKey();
    public sealed virtual RSA GetRSAPrivateKey();
    public sealed virtual DSA GetDSAPrivateKey();
    public sealed virtual ECDsa GetECDsaPrivateKey();
    public sealed virtual ECDiffieHellman GetECDiffieHellmanPrivateKey();
    public sealed virtual ICertificatePal CopyWithPrivateKey(DSA dsa);
    public sealed virtual ICertificatePal CopyWithPrivateKey(ECDsa ecdsa);
    public sealed virtual ICertificatePal CopyWithPrivateKey(ECDiffieHellman ecdh);
    public sealed virtual ICertificatePal CopyWithPrivateKey(RSA rsa);
    private T GetPrivateKey(Func`2<CspParameters, T> createCsp, Func`2<CngKey, T> createCng);
    private static SafeNCryptKeyHandle TryAcquireCngPrivateKey(SafeCertContextHandle certificateContext, CngKeyHandleOpenOptions& handleOptions);
    private CspParameters GetPrivateKeyCsp();
    private ICertificatePal CopyWithPersistedCngKey(CngKey cngKey);
    private static int GuessKeySpec(CngProvider provider, string keyName, bool machineKey, CngAlgorithmGroup algorithmGroup);
    private static bool TryGuessKeySpec(CspParameters cspParameters, CngAlgorithmGroup algorithmGroup, Int32& keySpec);
    private static bool TryGuessRsaKeySpec(CspParameters cspParameters, Int32& keySpec);
    private static bool TryGuessDsaKeySpec(CspParameters cspParameters, Int32& keySpec);
    private ICertificatePal CopyWithPersistedCapiKey(CspKeyContainerInfo keyContainerInfo);
    private ICertificatePal CopyWithEphemeralKey(CngKey cngKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    private AsymmetricAlgorithm _key;
    private X509SignatureGenerator _generator;
    private RSASignaturePadding _rsaPadding;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <SubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X509Extension> <CertificateExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AsnEncodedData> <OtherRequestAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public X500DistinguishedName SubjectName { get; }
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public Collection`1<AsnEncodedData> OtherRequestAttributes { get; }
    public PublicKey PublicKey { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_SubjectName();
    [CompilerGeneratedAttribute]
public Collection`1<X509Extension> get_CertificateExtensions();
    [CompilerGeneratedAttribute]
public Collection`1<AsnEncodedData> get_OtherRequestAttributes();
    [CompilerGeneratedAttribute]
public PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
    public string CreateSigningRequestPem();
    public string CreateSigningRequestPem(X509SignatureGenerator signatureGenerator);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, ReadOnlySpan`1<byte> serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, ReadOnlySpan`1<byte> serialNumber);
    private static ArraySegment`1<byte> NormalizeSerialNumber(ReadOnlySpan`1<byte> serialNumber);
    public static CertificateRequest LoadSigningRequestPem(string pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    [NullableContextAttribute("0")]
public static CertificateRequest LoadSigningRequestPem(ReadOnlySpan`1<char> pkcs10Pem, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    public static CertificateRequest LoadSigningRequest(Byte[] pkcs10, HashAlgorithmName signerHashAlgorithm, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    [NullableContextAttribute("0")]
public static CertificateRequest LoadSigningRequest(ReadOnlySpan`1<byte> pkcs10, HashAlgorithmName signerHashAlgorithm, Int32& bytesConsumed, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    private static CertificateRequest LoadSigningRequest(ReadOnlySpan`1<byte> pkcs10, bool permitTrailingData, HashAlgorithmName signerHashAlgorithm, Int32& bytesConsumed, CertificateRequestLoadOptions options, RSASignaturePadding signerSignaturePadding);
    private static bool VerifyX509Signature(ReadOnlySpan`1<byte> toBeSigned, ReadOnlySpan`1<byte> signature, PublicKey publicKey, AlgorithmIdentifierAsn algorithmIdentifier);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.CertificateRequestLoadOptions : Enum {
    public int value__;
    public static CertificateRequestLoadOptions Default;
    public static CertificateRequestLoadOptions SkipSignatureValidation;
    public static CertificateRequestLoadOptions UnsafeLoadCertificateExtensions;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.CertificateRevocationListBuilder : object {
    private List`1<RevokedCertificate> _revoked;
    private AsnWriter _writer;
    private CertificateRevocationListBuilder(List`1<RevokedCertificate> revoked);
    public void AddEntry(X509Certificate2 certificate, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    public void AddEntry(Byte[] serialNumber, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    [NullableContextAttribute("0")]
public void AddEntry(ReadOnlySpan`1<byte> serialNumber, Nullable`1<DateTimeOffset> revocationTime, Nullable`1<X509RevocationReason> reason);
    public bool RemoveEntry(Byte[] serialNumber);
    [NullableContextAttribute("0")]
public bool RemoveEntry(ReadOnlySpan`1<byte> serialNumber);
    private static DateTimeOffset ReadX509Time(AsnValueReader& reader);
    private static Nullable`1<DateTimeOffset> ReadX509TimeOpt(AsnValueReader& reader);
    private static void WriteX509Time(AsnWriter writer, DateTimeOffset time);
    public Byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding, Nullable`1<DateTimeOffset> thisUpdate);
    private Byte[] Build(X509Certificate2 issuerCertificate, BigInteger crlNumber, DateTimeOffset nextUpdate, DateTimeOffset thisUpdate, HashAlgorithmName hashAlgorithm, RSASignaturePadding rsaSignaturePadding);
    public Byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier, Nullable`1<DateTimeOffset> thisUpdate);
    private Byte[] Build(X500DistinguishedName issuerName, X509SignatureGenerator generator, BigInteger crlNumber, DateTimeOffset nextUpdate, DateTimeOffset thisUpdate, HashAlgorithmName hashAlgorithm, X509AuthorityKeyIdentifierExtension authorityKeyIdentifier);
    public static X509Extension BuildCrlDistributionPointExtension(IEnumerable`1<string> uris, bool critical);
    public static CertificateRevocationListBuilder Load(Byte[] currentCrl, BigInteger& currentCrlNumber);
    [NullableContextAttribute("0")]
public static CertificateRevocationListBuilder Load(ReadOnlySpan`1<byte> currentCrl, BigInteger& currentCrlNumber, Int32& bytesConsumed);
    public static CertificateRevocationListBuilder LoadPem(string currentCrl, BigInteger& currentCrlNumber);
    [NullableContextAttribute("0")]
public static CertificateRevocationListBuilder LoadPem(ReadOnlySpan`1<char> currentCrl, BigInteger& currentCrlNumber);
}
internal enum System.Security.Cryptography.X509Certificates.CertStoreProvider : Enum {
    public int value__;
    public static CertStoreProvider CERT_STORE_PROV_MEMORY;
    public static CertStoreProvider CERT_STORE_PROV_SYSTEM_W;
}
[FlagsAttribute]
internal enum System.Security.Cryptography.X509Certificates.CertTrustErrorStatus : Enum {
    public int value__;
    public static CertTrustErrorStatus CERT_TRUST_NO_ERROR;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_TIME_VALID;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_TIME_NESTED;
    public static CertTrustErrorStatus CERT_TRUST_IS_REVOKED;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_SIGNATURE_VALID;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    public static CertTrustErrorStatus CERT_TRUST_IS_UNTRUSTED_ROOT;
    public static CertTrustErrorStatus CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
    public static CertTrustErrorStatus CERT_TRUST_IS_CYCLIC;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_EXTENSION;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_NAME_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_IS_OFFLINE_REVOCATION;
    public static CertTrustErrorStatus CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY;
    public static CertTrustErrorStatus CERT_TRUST_IS_EXPLICIT_DISTRUST;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_WEAK_SIGNATURE;
    public static CertTrustErrorStatus CERT_TRUST_IS_PARTIAL_CHAIN;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
}
[FlagsAttribute]
internal enum System.Security.Cryptography.X509Certificates.CertTrustInfoStatus : Enum {
    public int value__;
    public static CertTrustInfoStatus CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_NAME_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_IS_SELF_SIGNED;
    public static CertTrustInfoStatus CERT_TRUST_HAS_PREFERRED_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY;
    public static CertTrustInfoStatus CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
    public static CertTrustInfoStatus CERT_TRUST_IS_COMPLEX_CHAIN;
}
internal class System.Security.Cryptography.X509Certificates.ChainPal : object {
    private SafeX509ChainHandle _chain;
    private static X509ChainErrorMapping[] s_x509ChainErrorMappings;
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    private ChainPal(SafeX509ChainHandle chain);
    private static ChainPal();
    internal static IChainPal FromHandle(IntPtr chainContext);
    internal static bool ReleaseSafeX509ChainHandle(IntPtr handle);
    internal static IChainPal BuildChain(bool useMachineContext, ICertificatePal cert, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, X509Certificate2Collection customTrustStore, X509ChainTrustMode trustMode, DateTime verificationTime, TimeSpan timeout, bool disableAia);
    public sealed virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public sealed virtual X509ChainElement[] get_ChainElements();
    public sealed virtual X509ChainStatus[] get_ChainStatus();
    public sealed virtual SafeX509ChainHandle get_SafeHandle();
    public sealed virtual void Dispose();
    private static SafeChainEngineHandle GetChainEngine(X509ChainTrustMode trustMode, X509Certificate2Collection customTrustStore, bool useMachineContext);
    private static SafeCertStoreHandle ConvertStoreToSafeHandle(X509Certificate2Collection extraStore, bool returnEmptyHandle);
    private static CertChainFlags MapRevocationFlags(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, bool disableAia);
    private static X509ChainStatus[] GetChainStatusInformation(CertTrustErrorStatus dwStatus);
}
internal enum System.Security.Cryptography.X509Certificates.ChainPolicy : Enum {
    public int value__;
    public static ChainPolicy CERT_CHAIN_POLICY_BASE;
}
internal class System.Security.Cryptography.X509Certificates.CMSG_SIGNER_INFO_Partial : ValueType {
    public int dwVersion;
    public DATA_BLOB Issuer;
    public DATA_BLOB SerialNumber;
}
internal enum System.Security.Cryptography.X509Certificates.CryptDecodeObjectStructType : Enum {
    public int value__;
    public static CryptDecodeObjectStructType CNG_RSA_PUBLIC_KEY_BLOB;
    public static CryptDecodeObjectStructType X509_DSS_PUBLICKEY;
    public static CryptDecodeObjectStructType X509_DSS_PARAMETERS;
    public static CryptDecodeObjectStructType X509_KEY_USAGE;
    public static CryptDecodeObjectStructType X509_BASIC_CONSTRAINTS;
    public static CryptDecodeObjectStructType X509_BASIC_CONSTRAINTS2;
    public static CryptDecodeObjectStructType X509_ENHANCED_KEY_USAGE;
    public static CryptDecodeObjectStructType X509_CERT_POLICIES;
    public static CryptDecodeObjectStructType X509_UNICODE_ANY_STRING;
    public static CryptDecodeObjectStructType X509_CERTIFICATE_TEMPLATE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
    private static bool HasECDsaKeyUsage(X509Certificate2 certificate);
}
internal class System.Security.Cryptography.X509Certificates.ECDsaX509SignatureGenerator : X509SignatureGenerator {
    private ECDsa _key;
    internal ECDsaX509SignatureGenerator(ECDsa key);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
internal class System.Security.Cryptography.X509Certificates.FindPal : object {
    private static Dictionary`2<string, X509KeyUsageFlags> s_keyUsages;
    private StorePal _storePal;
    private X509Certificate2Collection _copyTo;
    private bool _validOnly;
    private FindPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    private static FindPal();
    private static IFindPal OpenPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public static X509Certificate2Collection FindFromCollection(X509Certificate2Collection coll, X509FindType findType, object findValue, bool validOnly);
    private static T ConfirmedCast(object findValue);
    private static string ConfirmedOidValue(IFindPal findPal, object findValue, OidGroup oidGroup);
    private static X509KeyUsageFlags ConfirmedX509KeyUsage(object findValue);
    internal static void ValidateOidValue(string keyValue);
    private static BigInteger LaxParseDecimalBigInteger(string decimalString);
    public sealed virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public sealed virtual void FindByThumbprint(Byte[] thumbPrint);
    public sealed virtual void FindBySubjectName(string subjectName);
    public sealed virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public sealed virtual void FindByIssuerName(string issuerName);
    public sealed virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public sealed virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public sealed virtual void FindByTimeValid(DateTime dateTime);
    public sealed virtual void FindByTimeNotYetValid(DateTime dateTime);
    public sealed virtual void FindByTimeExpired(DateTime dateTime);
    private void FindByTime(DateTime dateTime, int compareResult);
    public sealed virtual void FindByTemplateName(string templateName);
    public sealed virtual void FindByApplicationPolicy(string oidValue);
    public sealed virtual void FindByCertificatePolicy(string oidValue);
    public sealed virtual void FindByExtension(string oidValue);
    public sealed virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public sealed virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
    public sealed virtual void Dispose();
    private void FindCore(TState state, Func`3<TState, SafeCertContextHandle, bool> filter);
    private void FindCore(CertFindType dwFindType, Void* pvFindPara, TState state, Func`3<TState, SafeCertContextHandle, bool> filter);
    private static bool VerifyCertificateIgnoringErrors(SafeCertContextHandle pCertContext);
    private static string GetCertNameInfo(SafeCertContextHandle pCertContext, CertNameType dwNameType, CertNameFlags dwNameFlags);
    [CompilerGeneratedAttribute]
internal static bool <FindByTemplateName>g__DecodeV1TemplateCallback|24_0(Void* pvDecoded, int cbDecoded, string templateName);
    [CompilerGeneratedAttribute]
internal static bool <FindByTemplateName>g__DecodeV2TemplateCallback|24_1(Void* pvDecoded, int cbDecoded, string templateName);
    [CompilerGeneratedAttribute]
internal static bool <FindByCertificatePolicy>g__DecodeObjectCallback|26_0(Void* pvDecoded, int cbDecoded, string oidValue);
}
internal interface System.Security.Cryptography.X509Certificates.ICertificatePal {
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public abstract virtual int get_Version();
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual DSA GetDSAPrivateKey();
    public abstract virtual ECDsa GetECDsaPrivateKey();
    public abstract virtual ECDiffieHellman GetECDiffieHellmanPrivateKey();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public abstract virtual ICertificatePal CopyWithPrivateKey(DSA privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(ECDsa privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(RSA privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(ECDiffieHellman privateKey);
    public abstract virtual PolicyData GetPolicyData();
}
internal interface System.Security.Cryptography.X509Certificates.ICertificatePalCore {
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual string get_LegacyIssuer();
    public abstract virtual string get_LegacySubject();
    public abstract virtual Byte[] get_Thumbprint();
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
internal interface System.Security.Cryptography.X509Certificates.IChainPal {
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public abstract virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public abstract virtual X509ChainElement[] get_ChainElements();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual SafeX509ChainHandle get_SafeHandle();
}
internal interface System.Security.Cryptography.X509Certificates.IExportPal {
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
internal interface System.Security.Cryptography.X509Certificates.IFindPal {
    public abstract virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public abstract virtual void FindByThumbprint(Byte[] thumbprint);
    public abstract virtual void FindBySubjectName(string subjectName);
    public abstract virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public abstract virtual void FindByIssuerName(string issuerName);
    public abstract virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public abstract virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public abstract virtual void FindByTimeValid(DateTime dateTime);
    public abstract virtual void FindByTimeNotYetValid(DateTime dateTime);
    public abstract virtual void FindByTimeExpired(DateTime dateTime);
    public abstract virtual void FindByTemplateName(string templateName);
    public abstract virtual void FindByApplicationPolicy(string oidValue);
    public abstract virtual void FindByCertificatePolicy(string oidValue);
    public abstract virtual void FindByExtension(string oidValue);
    public abstract virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public abstract virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
}
internal interface System.Security.Cryptography.X509Certificates.ILoaderPal {
    public abstract virtual void MoveTo(X509Certificate2Collection collection);
}
internal interface System.Security.Cryptography.X509Certificates.IStorePal {
    public SafeHandle SafeHandle { get; }
    public abstract virtual void CloneTo(X509Certificate2Collection collection);
    public abstract virtual void Add(ICertificatePal cert);
    public abstract virtual void Remove(ICertificatePal cert);
    public abstract virtual SafeHandle get_SafeHandle();
}
internal interface System.Security.Cryptography.X509Certificates.IX509Pal {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public abstract virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public abstract virtual ECDsa DecodeECDsaPublicKey(ICertificatePal certificatePal);
    public abstract virtual ECDiffieHellman DecodeECDiffieHellmanPublicKey(ICertificatePal certificatePal);
    public abstract virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public abstract virtual X509ContentType GetCertContentType(ReadOnlySpan`1<byte> rawData);
    public abstract virtual X509ContentType GetCertContentType(string fileName);
    public abstract virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public abstract virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public abstract virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public abstract virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public abstract virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public abstract virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    public abstract virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public abstract virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
internal class System.Security.Cryptography.X509Certificates.Pkcs10CertificationRequestInfo : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X501Attribute> <Attributes>k__BackingField;
    internal X500DistinguishedName Subject { get; internal set; }
    internal PublicKey PublicKey { get; internal set; }
    internal Collection`1<X501Attribute> Attributes { get; }
    internal Pkcs10CertificationRequestInfo(X500DistinguishedName subject, PublicKey publicKey, IEnumerable`1<X501Attribute> attributes);
    [CompilerGeneratedAttribute]
internal X500DistinguishedName get_Subject();
    [CompilerGeneratedAttribute]
internal void set_Subject(X500DistinguishedName value);
    [CompilerGeneratedAttribute]
internal PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
internal void set_PublicKey(PublicKey value);
    [CompilerGeneratedAttribute]
internal Collection`1<X501Attribute> get_Attributes();
    internal Byte[] ToPkcs10Request(X509SignatureGenerator signatureGenerator, HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.Pkcs9ExtensionRequest : X501Attribute {
    internal Pkcs9ExtensionRequest(IEnumerable`1<X509Extension> extensions);
    private static Byte[] EncodeAttribute(IEnumerable`1<X509Extension> extensions);
}
internal class System.Security.Cryptography.X509Certificates.PolicyData : ValueType {
    internal Byte[] ApplicationCertPolicies;
    internal Byte[] CertPolicies;
    internal Byte[] CertPolicyMappings;
    internal Byte[] CertPolicyConstraints;
    internal Byte[] EnhancedKeyUsage;
    internal Byte[] InhibitAnyPolicyExtension;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    private Oid _oid;
    private AsymmetricAlgorithm _key;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedKeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedParameters>k__BackingField;
    public AsnEncodedData EncodedKeyValue { get; private set; }
    public AsnEncodedData EncodedParameters { get; private set; }
    [ObsoleteAttribute("PublicKey.Key is obsolete. Use the appropriate method to get the public key, such as GetRSAPublicKey.")]
public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    public PublicKey(AsymmetricAlgorithm key);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedKeyValue();
    [CompilerGeneratedAttribute]
private void set_EncodedKeyValue(AsnEncodedData value);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedParameters();
    [CompilerGeneratedAttribute]
private void set_EncodedParameters(AsnEncodedData value);
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
    [NullableContextAttribute("0")]
public bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] ExportSubjectPublicKeyInfo();
    [NullableContextAttribute("0")]
public static PublicKey CreateFromSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public RSA GetRSAPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public DSA GetDSAPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public ECDsa GetECDsaPublicKey();
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public ECDiffieHellman GetECDiffieHellmanPublicKey();
    private AsnWriter EncodeSubjectPublicKeyInfo();
    private static int DecodeSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Oid& oid, AsnEncodedData& parameters, AsnEncodedData& keyValue);
    internal static PublicKey DecodeSubjectPublicKeyInfo(SubjectPublicKeyInfoAsn& spki);
    private static void DecodeSubjectPublicKeyInfo(SubjectPublicKeyInfoAsn& spki, Oid& oid, AsnEncodedData& parameters, AsnEncodedData& keyValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
}
internal class System.Security.Cryptography.X509Certificates.RSAPkcs1X509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    internal RSAPkcs1X509SignatureGenerator(RSA key);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
    internal static PublicKey BuildPublicKey(RSA rsa);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.RSAPssX509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    private RSASignaturePadding _padding;
    internal RSAPssX509SignatureGenerator(RSA key, RSASignaturePadding padding);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
internal class System.Security.Cryptography.X509Certificates.SafeLocalAllocHandle : SafeCrypt32Handle`1<SafeLocalAllocHandle> {
    public static SafeLocalAllocHandle Create(int cb);
    protected sealed virtual bool ReleaseHandle();
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
internal class System.Security.Cryptography.X509Certificates.StorePal : object {
    private SafeCertStoreHandle _certStore;
    internal SafeCertStoreHandle SafeCertStoreHandle { get; }
    private SafeHandle System.Security.Cryptography.X509Certificates.IStorePal.SafeHandle { get; }
    internal StorePal(SafeCertStoreHandle certStore);
    internal static IStorePal FromHandle(IntPtr storeHandle);
    internal static ILoaderPal FromBlob(ReadOnlySpan`1<byte> rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static ILoaderPal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    internal static IExportPal FromCertificate(ICertificatePalCore cert);
    internal static IExportPal LinkFromCertificateCollection(X509Certificate2Collection certificates);
    internal static IStorePal FromSystemStore(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    public sealed virtual void CloneTo(X509Certificate2Collection collection);
    public void CopyTo(X509Certificate2Collection collection);
    public sealed virtual void Add(ICertificatePal certificate);
    public sealed virtual void Remove(ICertificatePal certificate);
    public sealed virtual void Dispose();
    internal SafeCertStoreHandle get_SafeCertStoreHandle();
    private sealed virtual override SafeHandle System.Security.Cryptography.X509Certificates.IStorePal.get_SafeHandle();
    public sealed virtual void MoveTo(X509Certificate2Collection collection);
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    private Byte[] SaveToMemoryStore(CertStoreSaveAs dwSaveAs);
    private static StorePal FromBlobOrFile(ReadOnlySpan`1<byte> rawData, string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    private static PfxCertStoreFlags MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private static CertStoreFlags MapX509StoreFlags(StoreLocation storeLocation, OpenFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    private static IdnMapping s_idnMapping;
    private List`1<Byte[]> _encodedNames;
    private static SubjectAlternativeNameBuilder();
    public void AddEmailAddress(string emailAddress);
    public void AddDnsName(string dnsName);
    public void AddUri(Uri uri);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
    private void AddGeneralName(GeneralNameAsn generalName);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.X509Certificates.X500DictionaryStringHelper : object {
    [ExtensionAttribute]
internal static string ReadAnyAsnString(AsnValueReader& tavReader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDistinguishedName;
    private List`1<X500RelativeDistinguishedName> _parsedAttributes;
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    [NullableContextAttribute("0")]
public X500DistinguishedName(ReadOnlySpan`1<byte> encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    public IEnumerable`1<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(bool reversed);
    private static Byte[] Encode(string distinguishedName, X500DistinguishedNameFlags flags);
    private static void ThrowIfInvalid(X500DistinguishedNameFlags flags);
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X500DistinguishedName/<EnumerateRelativeDistinguishedNames>d__15")]
private static IEnumerable`1<X500RelativeDistinguishedName> EnumerateRelativeDistinguishedNames(List`1<X500RelativeDistinguishedName> parsedAttributes, bool reversed);
    private static List`1<X500RelativeDistinguishedName> ParseAttributes(Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X500DistinguishedNameBuilder : object {
    private List`1<Byte[]> _encodedComponents;
    private AsnWriter _writer;
    public void Add(string oidValue, string value, Nullable`1<UniversalTagNumber> stringEncodingType);
    public void Add(Oid oid, string value, Nullable`1<UniversalTagNumber> stringEncodingType);
    public void AddEmailAddress(string emailAddress);
    public void AddCommonName(string commonName);
    public void AddLocalityName(string localityName);
    public void AddCountryOrRegion(string twoLetterCode);
    public void AddOrganizationName(string organizationName);
    public void AddOrganizationalUnitName(string organizationalUnitName);
    public void AddStateOrProvinceName(string stateOrProvinceName);
    public void AddDomainComponent(string domainComponent);
    public X500DistinguishedName Build();
    private void EncodeComponent(string oid, ReadOnlySpan`1<char> value, UniversalTagNumber stringEncodingType, string paramName);
    private static UniversalTagNumber GetAndValidateTagNumber(Nullable`1<UniversalTagNumber> stringEncodingType);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
public class System.Security.Cryptography.X509Certificates.X500RelativeDistinguishedName : object {
    private Oid _singleElementType;
    private ReadOnlyMemory`1<byte> _singleElementValue;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <RawData>k__BackingField;
    public ReadOnlyMemory`1<byte> RawData { get; }
    public bool HasMultipleElements { get; }
    internal X500RelativeDistinguishedName(ReadOnlyMemory`1<byte> rawData);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_RawData();
    public bool get_HasMultipleElements();
    [NullableContextAttribute("1")]
public Oid GetSingleElementType();
    [NullableContextAttribute("2")]
public string GetSingleElementValue();
}
internal class System.Security.Cryptography.X509Certificates.X501Attribute : AsnEncodedData {
    internal X501Attribute(string oid, Byte[] rawData);
    internal X501Attribute(Oid oid, Byte[] rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509AuthorityInformationAccessExtension : X509Extension {
    private AccessDescriptionAsn[] _decoded;
    public X509AuthorityInformationAccessExtension(Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509AuthorityInformationAccessExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public X509AuthorityInformationAccessExtension(IEnumerable`1<string> ocspUris, IEnumerable`1<string> caIssuersUris, bool critical);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public IEnumerable`1<string> EnumerateUris(string accessMethodOid);
    public IEnumerable`1<string> EnumerateUris(Oid accessMethodOid);
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X509AuthorityInformationAccessExtension/<EnumerateUrisCore>d__8")]
private IEnumerable`1<string> EnumerateUrisCore(string accessMethodOid);
    public IEnumerable`1<string> EnumerateCAIssuersUris();
    public IEnumerable`1<string> EnumerateOcspUris();
    private static AccessDescriptionAsn[] Decode(Byte[] authorityInfoAccessSyntax);
    private static Byte[] Encode(IEnumerable`1<string> ocspUris, IEnumerable`1<string> caIssuersUris);
    [CompilerGeneratedAttribute]
internal static string <EnumerateUrisCore>g__GetUri|8_0(string accessMethodOid, AccessDescriptionAsn& desc);
    [CompilerGeneratedAttribute]
internal static void <Encode>g__WriteAccessMethod|12_0(AsnWriter writer, string oid, string value);
}
public class System.Security.Cryptography.X509Certificates.X509AuthorityKeyIdentifierExtension : X509Extension {
    private bool _decoded;
    private X500DistinguishedName _simpleIssuer;
    private Nullable`1<ReadOnlyMemory`1<byte>> _keyIdentifier;
    private Nullable`1<ReadOnlyMemory`1<byte>> _rawIssuer;
    private Nullable`1<ReadOnlyMemory`1<byte>> _serialNumber;
    public Nullable`1<ReadOnlyMemory`1<byte>> KeyIdentifier { get; }
    [NullableAttribute("2")]
public X500DistinguishedName NamedIssuer { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> RawIssuer { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> SerialNumber { get; }
    [NullableContextAttribute("1")]
public X509AuthorityKeyIdentifierExtension(Byte[] rawData, bool critical);
    public X509AuthorityKeyIdentifierExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    [NullableContextAttribute("1")]
public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public Nullable`1<ReadOnlyMemory`1<byte>> get_KeyIdentifier();
    [NullableContextAttribute("2")]
public X500DistinguishedName get_NamedIssuer();
    public Nullable`1<ReadOnlyMemory`1<byte>> get_RawIssuer();
    public Nullable`1<ReadOnlyMemory`1<byte>> get_SerialNumber();
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(X509SubjectKeyIdentifierExtension subjectKeyIdentifier);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(Byte[] subjectKeyIdentifier);
    public static X509AuthorityKeyIdentifierExtension CreateFromSubjectKeyIdentifier(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, Byte[] serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromIssuerNameAndSerialNumber(X500DistinguishedName issuerName, ReadOnlySpan`1<byte> serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension Create(Byte[] keyIdentifier, X500DistinguishedName issuerName, Byte[] serialNumber);
    public static X509AuthorityKeyIdentifierExtension Create(ReadOnlySpan`1<byte> keyIdentifier, X500DistinguishedName issuerName, ReadOnlySpan`1<byte> serialNumber);
    [NullableContextAttribute("1")]
public static X509AuthorityKeyIdentifierExtension CreateFromCertificate(X509Certificate2 certificate, bool includeKeyIdentifier, bool includeIssuerAndSerial);
    private void Decode(ReadOnlySpan`1<byte> rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    private bool _certificateAuthority;
    private bool _hasPathLenConstraint;
    private int _pathLenConstraint;
    private bool _decoded;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public static X509BasicConstraintsExtension CreateForCertificateAuthority(Nullable`1<int> pathLengthConstraint);
    public static X509BasicConstraintsExtension CreateForEndEntity(bool critical);
    private static Byte[] EncodeExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    private void DecodeExtension();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCertHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubject;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private DateTime _lazyNotBefore;
    private DateTime _lazyNotAfter;
    [CompilerGeneratedAttribute]
private ICertificatePalCore <Pal>k__BackingField;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> SerialNumberBytes { get; }
    [NullableAttribute("2")]
internal ICertificatePalCore Pal { get; private set; }
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] data);
    private protected X509Certificate(ReadOnlySpan`1<byte> data);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    private protected X509Certificate(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(IntPtr handle);
    internal X509Certificate(ICertificatePalCore pal);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    private protected X509Certificate(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate(X509Certificate cert);
    public X509Certificate(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate CreateFromCertFile(string filename);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate CreateFromSignedFile(string filename);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    private static Byte[] GetCertHash(HashAlgorithmName hashAlgorithm, ICertificatePalCore certPal);
    [NullableContextAttribute("0")]
public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    internal static string GetCertHashString(HashAlgorithmName hashAlgorithm, ICertificatePalCore certPal);
    private Byte[] GetRawCertHash();
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_SerialNumberBytes();
    public virtual string GetSerialNumberString();
    private Byte[] GetRawSerialNumber();
    [ObsoleteAttribute("X509Certificate.GetName has been deprecated. Use the Subject property instead.")]
public virtual string GetName();
    [ObsoleteAttribute("X509Certificate.GetIssuerName has been deprecated. Use the Issuer property instead.")]
public virtual string GetIssuerName();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [CompilerGeneratedAttribute]
internal ICertificatePalCore get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(ICertificatePalCore value);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    [MemberNotNullAttribute("Pal")]
internal void ThrowIfInvalid();
    protected static string FormatDate(DateTime date);
    internal static void ValidateKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private static void VerifyContentType(X509ContentType contentType);
    internal static void EnforceIterationCountLimit(ReadOnlySpan`1<byte> pkcs12, bool readingFromFile, bool passwordProvided);
    internal static ulong GetIterationCount(ReadOnlySpan`1<byte> pkcs12);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuerName;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private AsymmetricAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPrivateKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) _lazyExtensions;
    private static String[] s_EcPublicKeyPrivateKeyLabels;
    private static String[] s_RsaPublicKeyPrivateKeyLabels;
    private static String[] s_DsaPublicKeyPrivateKeyLabels;
    internal ICertificatePal Pal { get; }
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("X509Certificate2.PrivateKey is obsolete. Use the appropriate method to get the private key, such as GetRSAPrivateKey, or use the CopyWithPrivateKey method to create a new instance with a private key.")]
public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> RawDataMemory { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(ReadOnlySpan`1<byte> rawData);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(IntPtr handle);
    internal X509Certificate2(ICertificatePal pal);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, string password);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    [UnsupportedOSPlatformAttribute("browser")]
public X509Certificate2(X509Certificate certificate);
    protected X509Certificate2(SerializationInfo info, StreamingContext context);
    private static X509Certificate2();
    public virtual void Reset();
    internal ICertificatePal get_Pal();
    public bool get_Archived();
    [SupportedOSPlatformAttribute("windows")]
public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    [SupportedOSPlatformAttribute("windows")]
public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    [NullableContextAttribute("2")]
public AsymmetricAlgorithm get_PrivateKey();
    [NullableContextAttribute("2")]
public void set_PrivateKey(AsymmetricAlgorithm value);
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_RawDataMemory();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    [UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(Byte[] rawData);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(ReadOnlySpan`1<byte> rawData);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName);
    [ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("X509Certificate and X509Certificate2 are immutable. Use the appropriate constructor to create a new certificate.")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public bool Verify();
    [NullableContextAttribute("2")]
public ECDiffieHellman GetECDiffieHellmanPublicKey();
    [NullableContextAttribute("2")]
public ECDiffieHellman GetECDiffieHellmanPrivateKey();
    public X509Certificate2 CopyWithPrivateKey(ECDiffieHellman privateKey);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string keyPemFilePath);
    [UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan`1<char> password, string keyPemFilePath);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPem(ReadOnlySpan`1<char> certPem, ReadOnlySpan`1<char> keyPem);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan`1<char> certPem, ReadOnlySpan`1<char> keyPem, ReadOnlySpan`1<char> password);
    private static bool IsECDsa(X509Certificate2 certificate);
    private static bool IsECDiffieHellman(X509Certificate2 certificate);
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public static X509Certificate2 CreateFromPem(ReadOnlySpan`1<char> certPem);
    public string ExportCertificatePem();
    [NullableContextAttribute("0")]
public bool TryExportCertificatePem(Span`1<char> destination, Int32& charsWritten);
    public bool MatchesHostname(string hostname, bool allowWildcards, bool allowCommonName);
    private static X509Certificate2 ExtractKeyFromPem(ReadOnlySpan`1<char> keyPem, String[] labels, Func`1<TAlg> factory, Func`2<TAlg, X509Certificate2> import);
    private static X509Certificate2 ExtractKeyFromEncryptedPem(ReadOnlySpan`1<char> keyPem, ReadOnlySpan`1<char> password, Func`1<TAlg> factory, Func`2<TAlg, X509Certificate2> import);
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
    internal static X509Extension CreateCustomExtensionIfAny(string oidValue);
    private static bool HasECDiffieHellmanKeyUsage(X509Certificate2 certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    [NullableContextAttribute("2")]
public Byte[] Export(X509ContentType contentType);
    [NullableContextAttribute("2")]
public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<X509Certificate2> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate2>.GetEnumerator();
    public void Import(Byte[] rawData);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(ReadOnlySpan`1<byte> rawData, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [NullableContextAttribute("0")]
public void Import(string fileName, ReadOnlySpan`1<char> password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
    public void ImportFromPemFile(string certPemFilePath);
    [NullableContextAttribute("0")]
public void ImportFromPem(ReadOnlySpan`1<char> certPem);
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public string ExportPkcs7Pem();
    [NullableContextAttribute("0")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public bool TryExportPkcs7Pem(Span`1<char> destination, Int32& charsWritten);
    public string ExportCertificatePems();
    [NullableContextAttribute("0")]
public bool TryExportCertificatePems(Span`1<char> destination, Int32& charsWritten);
    private int GetCertificatePemsSize();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private IEnumerator _enumerator;
    [NullableAttribute("1")]
public X509Certificate2 Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    [NullableContextAttribute("1")]
public sealed virtual X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    protected virtual void OnValidate(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainPolicy _chainPolicy;
    private X509ChainStatus[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyChainStatus;
    private X509ChainElementCollection _chainElements;
    private IChainPal _pal;
    private bool _useMachineContext;
    private object _syncRoot;
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public IntPtr ChainContext { get; }
    [NullableAttribute("2")]
public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    [SupportedOSPlatformAttribute("windows")]
public X509Chain(IntPtr chainContext);
    public static X509Chain Create();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public IntPtr get_ChainContext();
    [NullableContextAttribute("2")]
public SafeX509ChainHandle get_SafeHandle();
    [UnsupportedOSPlatformAttribute("browser")]
public bool Build(X509Certificate2 certificate);
    internal bool Build(X509Certificate2 certificate, bool throwOnException);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainElementStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509ChainStatus[] ChainElementStatus { get; private set; }
    public string Information { get; private set; }
    internal X509ChainElement(X509Certificate2 certificate, X509ChainStatus[] chainElementStatus, string information);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509ChainStatus[] get_ChainElementStatus();
    [CompilerGeneratedAttribute]
private void set_ChainElementStatus(X509ChainStatus[] value);
    [CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private X509ChainElement[] _elements;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509ChainElement Item { get; }
    internal X509ChainElementCollection(X509ChainElement[] chainElements);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509ChainElement get_Item(int index);
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<X509ChainElement> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509ChainElement>.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private X509ChainElementCollection _chainElements;
    private int _current;
    [NullableAttribute("1")]
public X509ChainElement Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    [NullableContextAttribute("1")]
public sealed virtual X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    private X509RevocationMode _revocationMode;
    private X509RevocationFlag _revocationFlag;
    private X509VerificationFlags _verificationFlags;
    private X509ChainTrustMode _trustMode;
    private DateTime _verificationTime;
    internal OidCollection _applicationPolicy;
    internal OidCollection _certificatePolicy;
    internal X509Certificate2Collection _extraStore;
    internal X509Certificate2Collection _customTrustStore;
    [CompilerGeneratedAttribute]
private bool <DisableCertificateDownloads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerificationTimeIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UrlRetrievalTimeout>k__BackingField;
    public bool DisableCertificateDownloads { get; public set; }
    public bool VerificationTimeIgnored { get; public set; }
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509Certificate2Collection ExtraStore { get; }
    public X509Certificate2Collection CustomTrustStore { get; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public X509ChainTrustMode TrustMode { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisableCertificateDownloads();
    [CompilerGeneratedAttribute]
public void set_DisableCertificateDownloads(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerificationTimeIgnored();
    [CompilerGeneratedAttribute]
public void set_VerificationTimeIgnored(bool value);
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509Certificate2Collection get_ExtraStore();
    public X509Certificate2Collection get_CustomTrustStore();
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    public X509ChainTrustMode get_TrustMode();
    public void set_TrustMode(X509ChainTrustMode value);
    public DateTime get_VerificationTime();
    public void set_VerificationTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UrlRetrievalTimeout();
    [CompilerGeneratedAttribute]
public void set_UrlRetrievalTimeout(TimeSpan value);
    public void Reset();
    public X509ChainPolicy Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <Status>k__BackingField;
    private string _statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public X509ChainStatusFlags get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public enum System.Security.Cryptography.X509Certificates.X509ChainTrustMode : Enum {
    public int value__;
    public static X509ChainTrustMode System;
    public static X509ChainTrustMode CustomRootTrust;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    private OidCollection _enhancedKeyUsages;
    private bool _decoded;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(OidCollection enhancedKeyUsages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509Extension(Oid oid, ReadOnlySpan`1<byte> rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509Extension(string oid, ReadOnlySpan`1<byte> rawData, bool critical);
    internal X509Extension(Oid oid, Byte[] rawData, bool critical, bool skipCopy);
    internal X509Extension(Oid oid);
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private List`1<X509Extension> _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509Extension Item { get; }
    [NullableAttribute("2")]
public X509Extension Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<X509Extension> System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Extension>.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private X509ExtensionCollection _extensions;
    private int _current;
    [NullableAttribute("1")]
public X509Extension Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    [NullableContextAttribute("1")]
public sealed virtual X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    private bool _decoded;
    private X509KeyUsageFlags _keyUsages;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
internal class System.Security.Cryptography.X509Certificates.X509Pal : object {
    [CompilerGeneratedAttribute]
private static IX509Pal <Instance>k__BackingField;
    internal static IX509Pal Instance { get; }
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    private static X509Pal();
    [CompilerGeneratedAttribute]
internal static IX509Pal get_Instance();
    private static IX509Pal BuildSingleton();
    public sealed virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public sealed virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public sealed virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public sealed virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public sealed virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public sealed virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    public sealed virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public sealed virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
    public sealed virtual X509ContentType GetCertContentType(ReadOnlySpan`1<byte> rawData);
    public sealed virtual X509ContentType GetCertContentType(string fileName);
    private static X509ContentType MapContentType(ContentType contentType);
    public sealed virtual ECDsa DecodeECDsaPublicKey(ICertificatePal certificatePal);
    public sealed virtual ECDiffieHellman DecodeECDiffieHellmanPublicKey(ICertificatePal certificatePal);
    public sealed virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    private static TAlgorithm DecodeECPublicKey(CertificatePal certificatePal, Func`2<CngKey, TAlgorithm> factory, CryptImportPublicKeyInfoFlags importFlags);
    private static SafeBCryptKeyHandle ImportPublicKeyInfo(SafeCertContextHandle certContext, CryptImportPublicKeyInfoFlags importFlags);
    private static Byte[] ExportKeyBlob(SafeBCryptKeyHandle bCryptKeyHandle, CngKeyBlobFormat blobFormat);
    private static void ExportNamedCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    private static Byte[] DecodeKeyBlob(CryptDecodeObjectStructType lpszStructType, Byte[] encodedKeyValue);
    private static Byte[] ConstructDSSPublicKeyCspBlob(Byte[] encodedKeyValue, Byte[] encodedParameters);
    private static Byte[] DecodeDssKeyValue(Byte[] encodedKeyValue);
    private static void DecodeDssParameters(Byte[] encodedParameters, Byte[]& p, Byte[]& q, Byte[]& g);
    private static bool HasExplicitParameters(SafeBCryptKeyHandle bcryptHandle);
    private static string GetCurveName(SafeBCryptKeyHandle bcryptHandle);
    private static string GetPropertyAsString(SafeBCryptKeyHandle cryptHandle, string propertyName);
    private static Byte[] GetProperty(SafeBCryptKeyHandle cryptHandle, string propertyName);
    public sealed virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    private static CertNameStrTypeAndFlags MapNameToStrFlag(X500DistinguishedNameFlags flag);
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationReason : Enum {
    public int value__;
    public static X509RevocationReason Unspecified;
    public static X509RevocationReason KeyCompromise;
    public static X509RevocationReason CACompromise;
    public static X509RevocationReason AffiliationChanged;
    public static X509RevocationReason Superseded;
    public static X509RevocationReason CessationOfOperation;
    public static X509RevocationReason CertificateHold;
    public static X509RevocationReason RemoveFromCrl;
    public static X509RevocationReason PrivilegeWithdrawn;
    public static X509RevocationReason AACompromise;
    public static X509RevocationReason WeakAlgorithmOrKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    private PublicKey _publicKey;
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    private IStorePal _storePal;
    [CompilerGeneratedAttribute]
private StoreLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IntPtr StoreHandle { get; }
    public StoreLocation Location { get; private set; }
    [NullableAttribute("2")]
public string Name { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public bool IsOpen { get; }
    public X509Store(string storeName);
    public X509Store(StoreName storeName);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(IntPtr storeHandle);
    public IntPtr get_StoreHandle();
    [CompilerGeneratedAttribute]
public StoreLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(StoreLocation value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public void Open(OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public bool get_IsOpen();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public sealed virtual void Dispose();
    public void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension : X509Extension {
    private List`1<GeneralNameAsn> _decoded;
    public X509SubjectAlternativeNameExtension(Byte[] rawData, bool critical);
    [NullableContextAttribute("0")]
public X509SubjectAlternativeNameExtension(ReadOnlySpan`1<byte> rawData, bool critical);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public IEnumerable`1<string> EnumerateDnsNames();
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension/<EnumerateDnsNames>d__6")]
private static IEnumerable`1<string> EnumerateDnsNames(List`1<GeneralNameAsn> decoded);
    public IEnumerable`1<IPAddress> EnumerateIPAddresses();
    [IteratorStateMachineAttribute("System.Security.Cryptography.X509Certificates.X509SubjectAlternativeNameExtension/<EnumerateIPAddresses>d__8")]
private static IEnumerable`1<IPAddress> EnumerateIPAddresses(List`1<GeneralNameAsn> decoded);
    private static List`1<GeneralNameAsn> Decode(ReadOnlySpan`1<byte> rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    private Byte[] _subjectKeyIdentifierBytes;
    private string _subjectKeyIdentifierString;
    private bool _decoded;
    [NullableAttribute("2")]
public string SubjectKeyIdentifier { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> SubjectKeyIdentifierBytes { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    [NullableContextAttribute("0")]
public X509SubjectKeyIdentifierExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    [NullableContextAttribute("2")]
public string get_SubjectKeyIdentifier();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_SubjectKeyIdentifierBytes();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private void Decode(Byte[] rawData);
    private static Byte[] EncodeExtension(ReadOnlySpan`1<byte> subjectKeyIdentifier);
    private static Byte[] EncodeExtension(string subjectKeyIdentifier);
    private static Byte[] EncodeExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] GenerateSubjectKeyIdentifierFromPublicKey(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal static class System.Security.Cryptography.XmlKeyHelper : object {
    internal static ParseState ParseDocument(string xmlString);
    internal static bool HasElement(ParseState& state, string name);
    internal static Byte[] ReadCryptoBinary(ParseState& state, string name, int sizeHint);
    internal static int ReadCryptoBinaryInt32(Byte[] buf);
    internal static void WriteCryptoBinary(string name, int value, StringBuilder builder);
    internal static void WriteCryptoBinary(string name, ReadOnlySpan`1<byte> value, StringBuilder builder);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_EmptyOrNullArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EmptyOrNullString_Named { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidType { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_Asn1_InvalidCharacterString { get; }
    internal static string Argument_Asn1_InvalidStringContents { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_Invalid_SafeHandleInvalidOrClosed { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidHostnameOrIPAddress { get; }
    internal static string Argument_InvalidNameType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidRandomRange { get; }
    internal static string Argument_InvalidSerialNumberBytes { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Argument_BitsMustBeWholeBytes { get; }
    internal static string Argument_PemEncoding_NoPemFound { get; }
    internal static string Argument_PemEncoding_InvalidLabel { get; }
    internal static string Argument_PemEncoding_EncodedSizeTooLarge { get; }
    internal static string Argument_PemImport_NoPemFound { get; }
    internal static string Argument_PemImport_AmbiguousPem { get; }
    internal static string Argument_PemImport_EncryptedPem { get; }
    internal static string Argument_X500_EmailTooLong { get; }
    internal static string Argument_X500_InvalidCountryOrRegion { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLess { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string CryptoConfigNotSupported { get; }
    internal static string Cryptography_AddNullOrEmptyName { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_AlgorithmNotSupported { get; }
    internal static string Cryptography_AlgorithmTypesMustBeVisible { get; }
    internal static string Cryptography_ArgDSARequiresDSAKey { get; }
    internal static string Cryptography_ArgECDHKeySizeMismatch { get; }
    internal static string Cryptography_ArgECDHRequiresECDHKey { get; }
    internal static string Cryptography_ArgECDsaRequiresECDsaKey { get; }
    internal static string Cryptography_ArgRSARequiresRSAKey { get; }
    internal static string Cryptography_AuthTagMismatch { get; }
    internal static string Cryptography_Cert_AlreadyHasPrivateKey { get; }
    internal static string Cryptography_CertReq_AlgorithmMustMatch { get; }
    internal static string Cryptography_CertReq_BasicConstraintsRequired { get; }
    internal static string Cryptography_CertReq_DatesReversed { get; }
    internal static string Cryptography_CertReq_DuplicateExtension { get; }
    internal static string Cryptography_CertReq_ExtensionRequestInOtherAttributes { get; }
    internal static string Cryptography_CertReq_IssuerBasicConstraintsInvalid { get; }
    internal static string Cryptography_CertReq_IssuerKeyUsageInvalid { get; }
    internal static string Cryptography_CertReq_IssuerRequiresPrivateKey { get; }
    internal static string Cryptography_CertReq_Load_DuplicateExtensionRequests { get; }
    internal static string Cryptography_CertReq_Load_VersionTooNew { get; }
    internal static string Cryptography_CertReq_MissingOidInCollection { get; }
    internal static string Cryptography_CertReq_NullValueInCollection { get; }
    internal static string Cryptography_CertReq_NoKeyProvided { get; }
    internal static string Cryptography_CertReq_NotAfterNotNested { get; }
    internal static string Cryptography_CertReq_NotBeforeNotNested { get; }
    internal static string Cryptography_CertReq_RSAPaddingRequired { get; }
    internal static string Cryptography_CertReq_SignatureVerificationFailed { get; }
    internal static string Cryptography_CipherModeFeedbackNotSupported { get; }
    internal static string Cryptography_CipherModeNotSupported { get; }
    internal static string Cryptography_CngKeyWrongAlgorithm { get; }
    internal static string Cryptography_Config_EncodedOIDError { get; }
    internal static string Cryptography_CRLBuilder_DatesReversed { get; }
    internal static string Cryptography_CRLBuilder_IssuerKeyUsageInvalid { get; }
    internal static string Cryptography_CRLBuilder_ReasonNotSupported { get; }
    internal static string Cryptography_CryptoStream_FlushFinalBlockTwice { get; }
    internal static string Cryptography_CSP_NoPrivateKey { get; }
    internal static string Cryptography_CSP_NotFound { get; }
    internal static string Cryptography_CSP_WrongKeySpec { get; }
    internal static string Cryptography_CurveNotSupported { get; }
    internal static string Cryptography_CustomTrustCertsInSystemMode { get; }
    internal static string Cryptography_DefaultAlgorithm_NotSupported { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_ECC_NamedCurvesOnly { get; }
    internal static string Cryptography_ECXmlSerializationFormatRequired { get; }
    internal static string Cryptography_EncryptedIncorrectLength { get; }
    internal static string Cryptography_ExceedKdfExtractLimit { get; }
    internal static string Cryptography_FeedbackSizeNotSupported { get; }
    internal static string Cryptography_FormatterMissingAlgorithm { get; }
    internal static string Cryptography_FormatterMissingKey { get; }
    internal static string Cryptography_FromXmlParseError { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_HashNotYetFinalized { get; }
    internal static string Cryptography_InvalidBlockSize { get; }
    internal static string Cryptography_InvalidCipherMode { get; }
    internal static string Cryptography_InvalidContextHandle { get; }
    internal static string Cryptography_InvalidCurveKeyParameters { get; }
    internal static string Cryptography_InvalidCurveOid { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPGY { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPJ { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedQX { get; }
    internal static string Cryptography_InvalidDsaParameters_MissingFields { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDSASignatureSize { get; }
    internal static string Cryptography_InvalidECCharacteristic2Curve { get; }
    internal static string Cryptography_InvalidECPrimeCurve { get; }
    internal static string Cryptography_InvalidECNamedCurve { get; }
    internal static string Cryptography_InvalidFeedbackSize { get; }
    internal static string Cryptography_InvalidFromXmlString { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Cryptography_InvalidHashAlgorithmOid { get; }
    internal static string Cryptography_InvalidHashSize { get; }
    internal static string Cryptography_InvalidIVSize { get; }
    internal static string Cryptography_InvalidKey_SemiWeak { get; }
    internal static string Cryptography_InvalidKey_Weak { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_InvalidNonceLength { get; }
    internal static string Cryptography_InvalidOID { get; }
    internal static string Cryptography_InvalidOperation { get; }
    internal static string Cryptography_InvalidPadding { get; }
    internal static string Cryptography_InvalidPaddingMode { get; }
    internal static string Cryptography_InvalidStoreHandle { get; }
    internal static string Cryptography_InvalidTagLength { get; }
    internal static string Cryptography_InvalidTrustCertificate { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_KeyBlobParsingError { get; }
    internal static string Cryptography_KeyTooSmall { get; }
    internal static string Cryptography_MatchBlockSize { get; }
    internal static string Cryptography_MatchFeedbackSize { get; }
    internal static string Cryptography_Encryption_MessageTooLong { get; }
    internal static string Cryptography_InvalidRsaParameters { get; }
    internal static string Cryptography_MissingIV { get; }
    internal static string Cryptography_MustTransformWholeBlock { get; }
    internal static string Cryptography_NoPemOfLabel { get; }
    internal static string Cryptography_NotValidPrivateKey { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_Oid_InvalidName { get; }
    internal static string Cryptography_Oid_InvalidValue { get; }
    internal static string Cryptography_Oid_SetOnceFriendlyName { get; }
    internal static string Cryptography_Oid_SetOnceValue { get; }
    internal static string Cryptography_Okm_TooLarge { get; }
    internal static string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag { get; }
    internal static string Cryptography_OpenInvalidHandle { get; }
    internal static string Cryptography_PartialBlock { get; }
    internal static string Cryptography_PasswordDerivedBytes_InvalidAlgorithm { get; }
    internal static string Cryptography_PasswordDerivedBytes_InvalidIV { get; }
    internal static string Cryptography_PasswordDerivedBytes_TooManyBytes { get; }
    internal static string Cryptography_PasswordDerivedBytes_ValuesFixed { get; }
    internal static string Cryptography_Pfx_NoCertificates { get; }
    internal static string Cryptography_Pkcs_InvalidSignatureParameters { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfNotSupported { get; }
    internal static string Cryptography_Pkcs_PssParametersSaltMismatch { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_PlaintextCiphertextLengthMismatch { get; }
    internal static string Cryptography_PlaintextTooLarge { get; }
    internal static string Cryptography_PrivateKey_DoesNotMatch { get; }
    internal static string Cryptography_PrivateKey_WrongAlgorithm { get; }
    internal static string Cryptography_Prk_TooSmall { get; }
    internal static string Cryptography_RC2_EKS40 { get; }
    internal static string Cryptography_RC2_EKSKS { get; }
    internal static string Cryptography_RC2_EKSKS2 { get; }
    internal static string Cryptography_Rijndael_BlockSize { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_RSAPrivateKey_VersionTooNew { get; }
    internal static string Cryptography_SignHash_WrongSize { get; }
    internal static string Cryptography_TlsRequiresLabelAndSeed { get; }
    internal static string Cryptography_UnexpectedTransformTruncation { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownKeyAlgorithm { get; }
    internal static string Cryptography_UnknownPaddingMode { get; }
    internal static string Cryptography_UnknownSignatureFormat { get; }
    internal static string Cryptography_UnsupportedPaddingMode { get; }
    internal static string Cryptography_X500_MultiValued { get; }
    internal static string Cryptography_X509_AIA_MustNotBuildEmpty { get; }
    internal static string Cryptography_X509_AIA_NullValue { get; }
    internal static string Cryptography_X509_AKID_NoSKID { get; }
    internal static string Cryptography_X509_CDP_MustNotBuildEmpty { get; }
    internal static string Cryptography_X509_CDP_NullValue { get; }
    internal static string Cryptography_X509_ExportFailed { get; }
    internal static string Cryptography_X509_ExtensionMismatch { get; }
    internal static string Cryptography_X509_InvalidContentType { get; }
    internal static string Cryptography_X509_InvalidFindType { get; }
    internal static string Cryptography_X509_InvalidFindValue { get; }
    internal static string Cryptography_X509_InvalidFlagCombination { get; }
    internal static string Cryptography_X509_NoOrMismatchedPemKey { get; }
    internal static string Cryptography_X509_NoPemCertificate { get; }
    internal static string Cryptography_X509_SAN_UnknownIPAddressSize { get; }
    internal static string Cryptography_X509_StoreNotOpen { get; }
    internal static string Cryptography_X509_TooManySANs { get; }
    internal static string CryptSetKeyParam_Failed { get; }
    internal static string CspParameter_invalid { get; }
    internal static string HashNameMultipleSetNotSupported { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_IncorrectImplementation { get; }
    internal static string InvalidOperation_UnsupportedBlockSize { get; }
    internal static string NotSupported_ECDsa_Csp { get; }
    internal static string NotSupported_ECDiffieHellman_Csp { get; }
    internal static string NotSupported_ImmutableX509Certificate { get; }
    internal static string NotSupported_KeyAlgorithm { get; }
    internal static string NotSupported_Method { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string PlatformNotSupported_CryptographyOpenSSL { get; }
    internal static string Unknown_Error { get; }
    internal static string Cryptography_X509_PfxWithoutPassword { get; }
    internal static string Cryptography_X509_ChainBuildingFailed { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_EmptyOrNullArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EmptyOrNullString_Named();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidType();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_Asn1_InvalidCharacterString();
    internal static string get_Argument_Asn1_InvalidStringContents();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_Invalid_SafeHandleInvalidOrClosed();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidHostnameOrIPAddress();
    internal static string get_Argument_InvalidNameType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidRandomRange();
    internal static string get_Argument_InvalidSerialNumberBytes();
    internal static string get_Argument_InvalidValue();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Argument_BitsMustBeWholeBytes();
    internal static string get_Argument_PemEncoding_NoPemFound();
    internal static string get_Argument_PemEncoding_InvalidLabel();
    internal static string get_Argument_PemEncoding_EncodedSizeTooLarge();
    internal static string get_Argument_PemImport_NoPemFound();
    internal static string get_Argument_PemImport_AmbiguousPem();
    internal static string get_Argument_PemImport_EncryptedPem();
    internal static string get_Argument_X500_EmailTooLong();
    internal static string get_Argument_X500_InvalidCountryOrRegion();
    internal static string get_ArgumentOutOfRange_IndexMustBeLess();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_CryptoConfigNotSupported();
    internal static string get_Cryptography_AddNullOrEmptyName();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_AlgorithmNotSupported();
    internal static string get_Cryptography_AlgorithmTypesMustBeVisible();
    internal static string get_Cryptography_ArgDSARequiresDSAKey();
    internal static string get_Cryptography_ArgECDHKeySizeMismatch();
    internal static string get_Cryptography_ArgECDHRequiresECDHKey();
    internal static string get_Cryptography_ArgECDsaRequiresECDsaKey();
    internal static string get_Cryptography_ArgRSARequiresRSAKey();
    internal static string get_Cryptography_AuthTagMismatch();
    internal static string get_Cryptography_Cert_AlreadyHasPrivateKey();
    internal static string get_Cryptography_CertReq_AlgorithmMustMatch();
    internal static string get_Cryptography_CertReq_BasicConstraintsRequired();
    internal static string get_Cryptography_CertReq_DatesReversed();
    internal static string get_Cryptography_CertReq_DuplicateExtension();
    internal static string get_Cryptography_CertReq_ExtensionRequestInOtherAttributes();
    internal static string get_Cryptography_CertReq_IssuerBasicConstraintsInvalid();
    internal static string get_Cryptography_CertReq_IssuerKeyUsageInvalid();
    internal static string get_Cryptography_CertReq_IssuerRequiresPrivateKey();
    internal static string get_Cryptography_CertReq_Load_DuplicateExtensionRequests();
    internal static string get_Cryptography_CertReq_Load_VersionTooNew();
    internal static string get_Cryptography_CertReq_MissingOidInCollection();
    internal static string get_Cryptography_CertReq_NullValueInCollection();
    internal static string get_Cryptography_CertReq_NoKeyProvided();
    internal static string get_Cryptography_CertReq_NotAfterNotNested();
    internal static string get_Cryptography_CertReq_NotBeforeNotNested();
    internal static string get_Cryptography_CertReq_RSAPaddingRequired();
    internal static string get_Cryptography_CertReq_SignatureVerificationFailed();
    internal static string get_Cryptography_CipherModeFeedbackNotSupported();
    internal static string get_Cryptography_CipherModeNotSupported();
    internal static string get_Cryptography_CngKeyWrongAlgorithm();
    internal static string get_Cryptography_Config_EncodedOIDError();
    internal static string get_Cryptography_CRLBuilder_DatesReversed();
    internal static string get_Cryptography_CRLBuilder_IssuerKeyUsageInvalid();
    internal static string get_Cryptography_CRLBuilder_ReasonNotSupported();
    internal static string get_Cryptography_CryptoStream_FlushFinalBlockTwice();
    internal static string get_Cryptography_CSP_NoPrivateKey();
    internal static string get_Cryptography_CSP_NotFound();
    internal static string get_Cryptography_CSP_WrongKeySpec();
    internal static string get_Cryptography_CurveNotSupported();
    internal static string get_Cryptography_CustomTrustCertsInSystemMode();
    internal static string get_Cryptography_DefaultAlgorithm_NotSupported();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_ECC_NamedCurvesOnly();
    internal static string get_Cryptography_ECXmlSerializationFormatRequired();
    internal static string get_Cryptography_EncryptedIncorrectLength();
    internal static string get_Cryptography_ExceedKdfExtractLimit();
    internal static string get_Cryptography_FeedbackSizeNotSupported();
    internal static string get_Cryptography_FormatterMissingAlgorithm();
    internal static string get_Cryptography_FormatterMissingKey();
    internal static string get_Cryptography_FromXmlParseError();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_HashNotYetFinalized();
    internal static string get_Cryptography_InvalidBlockSize();
    internal static string get_Cryptography_InvalidCipherMode();
    internal static string get_Cryptography_InvalidContextHandle();
    internal static string get_Cryptography_InvalidCurveKeyParameters();
    internal static string get_Cryptography_InvalidCurveOid();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPGY();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPJ();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedQX();
    internal static string get_Cryptography_InvalidDsaParameters_MissingFields();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_LargeKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDSASignatureSize();
    internal static string get_Cryptography_InvalidECCharacteristic2Curve();
    internal static string get_Cryptography_InvalidECPrimeCurve();
    internal static string get_Cryptography_InvalidECNamedCurve();
    internal static string get_Cryptography_InvalidFeedbackSize();
    internal static string get_Cryptography_InvalidFromXmlString();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Cryptography_InvalidHashAlgorithmOid();
    internal static string get_Cryptography_InvalidHashSize();
    internal static string get_Cryptography_InvalidIVSize();
    internal static string get_Cryptography_InvalidKey_SemiWeak();
    internal static string get_Cryptography_InvalidKey_Weak();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_InvalidNonceLength();
    internal static string get_Cryptography_InvalidOID();
    internal static string get_Cryptography_InvalidOperation();
    internal static string get_Cryptography_InvalidPadding();
    internal static string get_Cryptography_InvalidPaddingMode();
    internal static string get_Cryptography_InvalidStoreHandle();
    internal static string get_Cryptography_InvalidTagLength();
    internal static string get_Cryptography_InvalidTrustCertificate();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_KeyBlobParsingError();
    internal static string get_Cryptography_KeyTooSmall();
    internal static string get_Cryptography_MatchBlockSize();
    internal static string get_Cryptography_MatchFeedbackSize();
    internal static string get_Cryptography_Encryption_MessageTooLong();
    internal static string get_Cryptography_InvalidRsaParameters();
    internal static string get_Cryptography_MissingIV();
    internal static string get_Cryptography_MustTransformWholeBlock();
    internal static string get_Cryptography_NoPemOfLabel();
    internal static string get_Cryptography_NotValidPrivateKey();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_Oid_InvalidName();
    internal static string get_Cryptography_Oid_InvalidValue();
    internal static string get_Cryptography_Oid_SetOnceFriendlyName();
    internal static string get_Cryptography_Oid_SetOnceValue();
    internal static string get_Cryptography_Okm_TooLarge();
    internal static string get_Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag();
    internal static string get_Cryptography_OpenInvalidHandle();
    internal static string get_Cryptography_PartialBlock();
    internal static string get_Cryptography_PasswordDerivedBytes_InvalidAlgorithm();
    internal static string get_Cryptography_PasswordDerivedBytes_InvalidIV();
    internal static string get_Cryptography_PasswordDerivedBytes_TooManyBytes();
    internal static string get_Cryptography_PasswordDerivedBytes_ValuesFixed();
    internal static string get_Cryptography_Pfx_NoCertificates();
    internal static string get_Cryptography_Pkcs_InvalidSignatureParameters();
    internal static string get_Cryptography_Pkcs_PssParametersMgfHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfNotSupported();
    internal static string get_Cryptography_Pkcs_PssParametersSaltMismatch();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_PlaintextCiphertextLengthMismatch();
    internal static string get_Cryptography_PlaintextTooLarge();
    internal static string get_Cryptography_PrivateKey_DoesNotMatch();
    internal static string get_Cryptography_PrivateKey_WrongAlgorithm();
    internal static string get_Cryptography_Prk_TooSmall();
    internal static string get_Cryptography_RC2_EKS40();
    internal static string get_Cryptography_RC2_EKSKS();
    internal static string get_Cryptography_RC2_EKSKS2();
    internal static string get_Cryptography_Rijndael_BlockSize();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_RSAPrivateKey_VersionTooNew();
    internal static string get_Cryptography_SignHash_WrongSize();
    internal static string get_Cryptography_TlsRequiresLabelAndSeed();
    internal static string get_Cryptography_UnexpectedTransformTruncation();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownKeyAlgorithm();
    internal static string get_Cryptography_UnknownPaddingMode();
    internal static string get_Cryptography_UnknownSignatureFormat();
    internal static string get_Cryptography_UnsupportedPaddingMode();
    internal static string get_Cryptography_X500_MultiValued();
    internal static string get_Cryptography_X509_AIA_MustNotBuildEmpty();
    internal static string get_Cryptography_X509_AIA_NullValue();
    internal static string get_Cryptography_X509_AKID_NoSKID();
    internal static string get_Cryptography_X509_CDP_MustNotBuildEmpty();
    internal static string get_Cryptography_X509_CDP_NullValue();
    internal static string get_Cryptography_X509_ExportFailed();
    internal static string get_Cryptography_X509_ExtensionMismatch();
    internal static string get_Cryptography_X509_InvalidContentType();
    internal static string get_Cryptography_X509_InvalidFindType();
    internal static string get_Cryptography_X509_InvalidFindValue();
    internal static string get_Cryptography_X509_InvalidFlagCombination();
    internal static string get_Cryptography_X509_NoOrMismatchedPemKey();
    internal static string get_Cryptography_X509_NoPemCertificate();
    internal static string get_Cryptography_X509_SAN_UnknownIPAddressSize();
    internal static string get_Cryptography_X509_StoreNotOpen();
    internal static string get_Cryptography_X509_TooManySANs();
    internal static string get_CryptSetKeyParam_Failed();
    internal static string get_CspParameter_invalid();
    internal static string get_HashNameMultipleSetNotSupported();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_IncorrectImplementation();
    internal static string get_InvalidOperation_UnsupportedBlockSize();
    internal static string get_NotSupported_ECDsa_Csp();
    internal static string get_NotSupported_ECDiffieHellman_Csp();
    internal static string get_NotSupported_ImmutableX509Certificate();
    internal static string get_NotSupported_KeyAlgorithm();
    internal static string get_NotSupported_Method();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_PlatformNotSupported_CryptographyOpenSSL();
    internal static string get_Unknown_Error();
    internal static string get_Cryptography_X509_PfxWithoutPassword();
    internal static string get_Cryptography_X509_ChainBuildingFailed();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    public static Task GetTask(IAsyncResult asyncResult);
    [DoesNotReturnAttribute]
private static void ThrowArgumentException(IAsyncResult asyncResult);
}
