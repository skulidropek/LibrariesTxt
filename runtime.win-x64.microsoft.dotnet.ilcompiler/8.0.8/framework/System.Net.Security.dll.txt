internal static class FxResources.System.Net.Security.SR : object {
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeCertContextHandle : SafeCrypt32Handle`1<SafeCertContextHandle> {
    private SafeCertContextHandle _parent;
    public bool HasEphemeralPrivateKey { get; }
    protected virtual bool ReleaseHandle();
    public bool get_HasEphemeralPrivateKey();
    private bool CertHasProperty(CertContextPropId propertyId);
}
internal abstract class Microsoft.Win32.SafeHandles.SafeCrypt32Handle`1 : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected virtual void Dispose(bool disposing);
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal class System.Collections.Generic.BidirectionalDictionary`2 : object {
    private Dictionary`2<T1, T2> _forward;
    private Dictionary`2<T2, T1> _backward;
    public BidirectionalDictionary`2(int capacity);
    public void Add(T1 item1, T2 item2);
    public bool TryGetForward(T1 item1, T2& item2);
    public bool TryGetBackward(T2 item2, T1& item1);
    public Enumerator<T1, T2> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T1, T2>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T1,T2>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.HexConverter : object {
    public static char ToCharLower(int value);
}
internal class System.Net.ArrayBuffer : ValueType {
    private bool _usePool;
    private Byte[] _bytes;
    private int _activeStart;
    private int _availableStart;
    public int ActiveLength { get; }
    public Span`1<byte> ActiveSpan { get; }
    public int AvailableLength { get; }
    public Memory`1<byte> AvailableMemory { get; }
    public ArrayBuffer(int initialSize, bool usePool);
    public sealed virtual void Dispose();
    public void ClearAndReturnBuffer();
    public int get_ActiveLength();
    public Span`1<byte> get_ActiveSpan();
    public int get_AvailableLength();
    public Memory`1<byte> get_AvailableMemory();
    public void Discard(int byteCount);
    public void Commit(int byteCount);
    public void EnsureAvailableSpace(int byteCount);
    private void EnsureAvailableSpaceCore(int byteCount);
    private void ReturnBufferIfPooled(Byte[] buffer);
}
internal static class System.Net.CertificateValidation : object {
    internal static SslPolicyErrors BuildChainAndVerifyProperties(X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool isServer, string hostName);
    private static UInt32 Verify(SafeX509ChainHandle chainContext, CERT_CHAIN_POLICY_PARA& cpp);
}
internal static class System.Net.CertificateValidationPal : object {
    private static object s_syncObject;
    private static X509Store modreq(System.Runtime.CompilerServices.IsVolatile) s_myCertStoreEx;
    private static X509Store modreq(System.Runtime.CompilerServices.IsVolatile) s_myMachineCertStoreEx;
    private static X509Chain s_chain;
    private static CertificateValidationPal();
    internal static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext);
    internal static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext, X509Chain& chain, X509ChainPolicy chainPolicy);
    internal static X509Store EnsureStoreOpened(bool isMachineStore);
    internal static SslPolicyErrors VerifyCertificateProperties(SafeDeleteContext _, X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool isServer, string hostName);
    private static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext, bool retrieveChainCertificates, X509Chain& chain, X509ChainPolicy chainPolicy);
    internal static bool IsLocalCertificateUsed(SafeFreeCredentials _credentialsHandle, SafeDeleteContext securityContext);
    internal static String[] GetRequestCertificateAuthorities(SafeDeleteContext securityContext);
    internal static X509Store OpenStore(StoreLocation storeLocation);
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal class System.Net.FrameHeader : object {
    private int _payloadSize;
    [CompilerGeneratedAttribute]
private int <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MajorV>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinorV>k__BackingField;
    public int MessageId { get; public set; }
    public int MajorV { get; private set; }
    public int MinorV { get; private set; }
    public int PayloadSize { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(int value);
    [CompilerGeneratedAttribute]
public int get_MajorV();
    [CompilerGeneratedAttribute]
private void set_MajorV(int value);
    [CompilerGeneratedAttribute]
public int get_MinorV();
    [CompilerGeneratedAttribute]
private void set_MinorV(int value);
    public int get_PayloadSize();
    public void set_PayloadSize(int value);
    public void CopyTo(Byte[] dest, int start);
    public void CopyFrom(Byte[] bytes, int start);
}
internal static class System.Net.GlobalSSPI : object {
    internal static SSPIAuthType SSPIAuth;
    internal static SSPISecureChannelType SSPISecureChannel;
    private static GlobalSSPI();
}
internal class System.Net.InternalException : Exception {
    private object _unexpectedValue;
    public string Message { get; }
    internal InternalException(object unexpectedValue);
    public virtual string get_Message();
}
internal interface System.Net.ISSPIInterface {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public abstract virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public abstract virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public abstract virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED* authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCH_CREDENTIALS* authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteSslContext& context, InputSecurityBuffers inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteSslContext& context, string targetName, ContextFlags inFlags, Endianness endianness, InputSecurityBuffers inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 qop);
    public abstract virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32& qop);
    public abstract virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public abstract virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public abstract virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public abstract virtual int CompleteAuthToken(SafeDeleteSslContext& refContext, InputSecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
    public abstract virtual int ApplyControlToken(SafeDeleteSslContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal abstract class System.Net.NegotiateAuthenticationPal : object {
    public bool IsAuthenticated { get; }
    public bool IsSigned { get; }
    public bool IsEncrypted { get; }
    public bool IsMutuallyAuthenticated { get; }
    public string Package { get; }
    public string TargetName { get; }
    public IIdentity RemoteIdentity { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual string get_Package();
    public abstract virtual string get_TargetName();
    public abstract virtual IIdentity get_RemoteIdentity();
    public abstract virtual TokenImpersonationLevel get_ImpersonationLevel();
    public abstract virtual void Dispose();
    public abstract virtual Byte[] GetOutgoingBlob(ReadOnlySpan`1<byte> incomingBlob, NegotiateAuthenticationStatusCode& statusCode);
    public abstract virtual NegotiateAuthenticationStatusCode Wrap(ReadOnlySpan`1<byte> input, IBufferWriter`1<byte> outputWriter, bool requestEncryption, Boolean& isEncrypted);
    public abstract virtual NegotiateAuthenticationStatusCode Unwrap(ReadOnlySpan`1<byte> input, IBufferWriter`1<byte> outputWriter, Boolean& wasEncrypted);
    public abstract virtual NegotiateAuthenticationStatusCode UnwrapInPlace(Span`1<byte> input, Int32& unwrappedOffset, Int32& unwrappedLength, Boolean& wasEncrypted);
    public abstract virtual void GetMIC(ReadOnlySpan`1<byte> message, IBufferWriter`1<byte> signature);
    public abstract virtual bool VerifyMIC(ReadOnlySpan`1<byte> message, ReadOnlySpan`1<byte> signature);
    public static NegotiateAuthenticationPal Create(NegotiateAuthenticationClientOptions clientOptions);
    public static NegotiateAuthenticationPal Create(NegotiateAuthenticationServerOptions serverOptions);
}
internal static class System.Net.NegotiationInfoClass : object {
    internal static string GetAuthenticationPackageName(SafeHandle safeHandle, int negotiationState);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public void SslStreamCtor(SslStream sslStream, Stream innerStream);
    [EventAttribute("34")]
private void SslStreamCtor(string thisOrContextObject, string localId, string remoteId);
    [NonEventAttribute]
public void LocatingPrivateKey(X509Certificate x509Certificate, object instance);
    [EventAttribute("14")]
private void LocatingPrivateKey(string x509Certificate, int sslStreamHash);
    [NonEventAttribute]
public void CertIsType2(object instance);
    [EventAttribute("15")]
private void CertIsType2(int sslStreamHash);
    [NonEventAttribute]
public void FoundCertInStore(bool serverMode, object instance);
    [EventAttribute("16")]
private void FoundCertInStore(string store, int sslStreamHash);
    [NonEventAttribute]
public void NotFoundCertInStore(object instance);
    [EventAttribute("17")]
private void NotFoundCertInStore(int sslStreamHash);
    [NonEventAttribute]
public void RemoteCertificate(X509Certificate remoteCertificate);
    [EventAttribute("18")]
private void RemoteCertificate(string remoteCertificate);
    [NonEventAttribute]
public void CertificateFromDelegate(SslStream SslStream);
    [EventAttribute("19")]
private void CertificateFromDelegate(int sslStreamHash);
    [NonEventAttribute]
public void NoDelegateNoClientCert(SslStream SslStream);
    [EventAttribute("20")]
private void NoDelegateNoClientCert(int sslStreamHash);
    [NonEventAttribute]
public void NoDelegateButClientCert(SslStream SslStream);
    [EventAttribute("21")]
private void NoDelegateButClientCert(int sslStreamHash);
    [NonEventAttribute]
public void AttemptingRestartUsingCert(X509Certificate clientCertificate, SslStream SslStream);
    [EventAttribute("22")]
private void AttemptingRestartUsingCert(string clientCertificate, int sslStreamHash);
    [NonEventAttribute]
public void NoIssuersTryAllCerts(SslStream SslStream);
    [EventAttribute("23")]
private void NoIssuersTryAllCerts(int sslStreamHash);
    [NonEventAttribute]
public void LookForMatchingCerts(int issuersCount, SslStream SslStream);
    [EventAttribute("24")]
private void LookForMatchingCerts(int issuersCount, int sslStreamHash);
    [NonEventAttribute]
public void SelectedCert(X509Certificate clientCertificate, SslStream SslStream);
    [EventAttribute("25")]
private void SelectedCert(string clientCertificate, int sslStreamHash);
    [NonEventAttribute]
public void CertsAfterFiltering(int filteredCertsCount, SslStream SslStream);
    [EventAttribute("26")]
private void CertsAfterFiltering(int filteredCertsCount, int sslStreamHash);
    [NonEventAttribute]
public void FindingMatchingCerts(SslStream SslStream);
    [EventAttribute("27")]
private void FindingMatchingCerts(int sslStreamHash);
    [NonEventAttribute]
public void UsingCachedCredential(SslStream SslStream);
    [EventAttribute("28")]
private void UsingCachedCredential(int sslStreamHash);
    [EventAttribute("29")]
public void SspiSelectedCipherSuite(string process, SslProtocols sslProtocol, CipherAlgorithmType cipherAlgorithm, int cipherStrength, HashAlgorithmType hashAlgorithm, int hashStrength, ExchangeAlgorithmType keyExchangeAlgorithm, int keyExchangeStrength);
    [NonEventAttribute]
public void RemoteCertificateError(SslStream SslStream, string message);
    [EventAttribute("30")]
private void RemoteCertificateError(int sslStreamHash, string message);
    [NonEventAttribute]
public void RemoteCertDeclaredValid(SslStream SslStream);
    [EventAttribute("31")]
private void RemoteCertDeclaredValid(int sslStreamHash);
    [NonEventAttribute]
public void RemoteCertHasNoErrors(SslStream SslStream);
    [EventAttribute("32")]
private void RemoteCertHasNoErrors(int sslStreamHash);
    [NonEventAttribute]
public void RemoteCertUserDeclaredInvalid(SslStream SslStream);
    [EventAttribute("33")]
private void RemoteCertUserDeclaredInvalid(int sslStreamHash);
    [NonEventAttribute]
public void SentFrame(SslStream sslStream, ReadOnlySpan`1<byte> frame);
    [EventAttribute("35")]
private void SentFrame(string sslStream, string tlsFrame, int isComplete);
    [NonEventAttribute]
public void ReceivedFrame(SslStream sslStream, TlsFrameInfo frameInfo);
    [EventAttribute("36")]
private void ReceivedFrame(string sslStream, string tlsFrame, int isComplete);
    [NonEventAttribute]
public void CertificateFromCertContext(SslStream sslStream);
    [EventAttribute("37")]
public void CertificateFromCertContext(int sslStreamHash);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    private static void AdditionalCustomizedToString(object value, String& result);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, ReadOnlySpan`1<byte> buffer, string memberName);
    [EventAttribute("4")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [EventAttribute("5")]
public void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("6")]
public void SspiPackageNotFound(string packageName);
    [EventAttribute("7")]
public void AcquireDefaultCredential(string packageName, CredentialUse intent);
    [NonEventAttribute]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, object authdata);
    [EventAttribute("8")]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, string authdata);
    [NonEventAttribute]
public void InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, string targetName, ContextFlags inFlags);
    [EventAttribute("9")]
private void InitializeSecurityContext(string credential, string context, string targetName, ContextFlags inFlags);
    [NonEventAttribute]
public void AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, ContextFlags inFlags);
    [EventAttribute("12")]
private void AcceptSecurityContext(string credential, string context, ContextFlags inFlags);
    [EventAttribute("13")]
public void OperationReturnedSomething(string operation, SECURITY_STATUS errorCode);
    [EventAttribute("11")]
public void SecurityContextInputBuffers(string context, int inputBuffersSize, int outputBufferSize, SECURITY_STATUS errorCode);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
}
internal class System.Net.SecPkgContext_Bindings : ValueType {
    internal int BindingsLength;
    internal IntPtr Bindings;
}
internal class System.Net.SecPkgContext_CipherInfo : ValueType {
    private int dwVersion;
    private int dwProtocol;
    public int dwCipherSuite;
    private int dwBaseCipherSuite;
    [FixedBufferAttribute("System.Char", "64")]
private <szCipherSuite>e__FixedBuffer szCipherSuite;
    [FixedBufferAttribute("System.Char", "64")]
private <szCipher>e__FixedBuffer szCipher;
    private int dwCipherLen;
    private int dwCipherBlockLen;
    [FixedBufferAttribute("System.Char", "64")]
private <szHash>e__FixedBuffer szHash;
    private int dwHashLen;
    [FixedBufferAttribute("System.Char", "64")]
private <szExchange>e__FixedBuffer szExchange;
    private int dwMinExchangeLen;
    private int dwMaxExchangeLen;
    [FixedBufferAttribute("System.Char", "64")]
private <szCertificate>e__FixedBuffer szCertificate;
    private int dwKeyType;
}
internal class System.Net.SecPkgContext_ConnectionInfo : ValueType {
    public int Protocol;
    public int DataCipherAlg;
    public int DataKeySize;
    public int DataHashAlg;
    public int DataHashKeySize;
    public int KeyExchangeAlg;
    public int KeyExchKeySize;
}
internal class System.Net.SecPkgContext_NegotiationInfoW : ValueType {
    internal IntPtr PackageInfo;
    internal UInt32 NegotiationState;
}
internal class System.Net.SecPkgContext_Sizes : ValueType {
    public int cbMaxToken;
    public int cbMaxSignature;
    public int cbBlockSize;
    public int cbSecurityTrailer;
}
internal class System.Net.SecPkgContext_StreamSizes : ValueType {
    public int cbHeader;
    public int cbTrailer;
    public int cbMaximumMessage;
    public int cBuffers;
    public int cbBlockSize;
}
[IsReadOnlyAttribute]
internal class System.Net.Security.AsyncReadWriteAdapter : ValueType {
    public static override ValueTask`1<int> ReadAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    public static override ValueTask`1<int> ReadAtLeastAsync(Stream stream, Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    public static override ValueTask WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public static override Task FlushAsync(Stream stream, CancellationToken cancellationToken);
    public static override Task WaitAsync(TaskCompletionSource`1<bool> waiter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    public bool LeaveInnerStreamOpen { get; }
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    public bool get_LeaveInnerStreamOpen();
    protected Stream get_InnerStream();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("windows")]
[UnsupportedOSPlatformAttribute("android")]
public class System.Net.Security.CipherSuitesPolicy : object {
    [CompilerGeneratedAttribute]
private CipherSuitesPolicyPal <Pal>k__BackingField;
    internal CipherSuitesPolicyPal Pal { get; private set; }
    [CLSCompliantAttribute("False")]
public IEnumerable`1<TlsCipherSuite> AllowedCipherSuites { get; }
    [CLSCompliantAttribute("False")]
public CipherSuitesPolicy(IEnumerable`1<TlsCipherSuite> allowedCipherSuites);
    [CompilerGeneratedAttribute]
internal CipherSuitesPolicyPal get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(CipherSuitesPolicyPal value);
    [IteratorStateMachineAttribute("System.Net.Security.CipherSuitesPolicy/<get_AllowedCipherSuites>d__6")]
public IEnumerable`1<TlsCipherSuite> get_AllowedCipherSuites();
}
internal class System.Net.Security.CipherSuitesPolicyPal : object {
    internal CipherSuitesPolicyPal(IEnumerable`1<TlsCipherSuite> _);
    internal IEnumerable`1<TlsCipherSuite> GetCipherSuites();
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy RequireEncryption;
    [ObsoleteAttribute("EncryptionPolicy.NoEncryption and AllowEncryption significantly reduce security and should not be used in production code.")]
public static EncryptionPolicy AllowNoEncryption;
    [ObsoleteAttribute("EncryptionPolicy.NoEncryption and AllowEncryption significantly reduce security and should not be used in production code.")]
public static EncryptionPolicy NoEncryption;
}
internal enum System.Net.Security.ExtensionType : Enum {
    public ushort value__;
    public static ExtensionType ServerName;
    public static ExtensionType MaximumFagmentLength;
    public static ExtensionType ClientCertificateUrl;
    public static ExtensionType TrustedCaKeys;
    public static ExtensionType TruncatedHmac;
    public static ExtensionType CertificateStatusRequest;
    public static ExtensionType ApplicationProtocols;
    public static ExtensionType SupportedVersions;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
internal class System.Net.Security.InputSecurityBuffer : ValueType {
    public SecurityBufferType Type;
    public ReadOnlySpan`1<byte> Token;
    public SafeHandle UnmanagedToken;
    public InputSecurityBuffer(ReadOnlySpan`1<byte> data, SecurityBufferType tokentype);
    public InputSecurityBuffer(ChannelBinding binding);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Net.Security.InputSecurityBuffers : ValueType {
    internal int Count;
    internal InputSecurityBuffer _item0;
    internal InputSecurityBuffer _item1;
    internal InputSecurityBuffer _item2;
    internal void SetNextBuffer(InputSecurityBuffer buffer);
}
internal interface System.Net.Security.IReadWriteAdapter {
    public static abstract virtual ValueTask`1<int> ReadAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    public static abstract virtual ValueTask`1<int> ReadAtLeastAsync(Stream stream, Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    public static abstract virtual ValueTask WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public static abstract virtual Task FlushAsync(Stream stream, CancellationToken cancellationToken);
    public static abstract virtual Task WaitAsync(TaskCompletionSource`1<bool> waiter);
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
public class System.Net.Security.NegotiateAuthentication : object {
    private NegotiateAuthenticationPal _pal;
    private string _requestedPackage;
    private bool _isServer;
    private TokenImpersonationLevel _requiredImpersonationLevel;
    private ProtectionLevel _requiredProtectionLevel;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private bool _isSecureConnection;
    private bool _isDisposed;
    private IIdentity _remoteIdentity;
    public bool IsAuthenticated { get; }
    public ProtectionLevel ProtectionLevel { get; }
    public bool IsSigned { get; }
    public bool IsEncrypted { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsServer { get; }
    [NullableAttribute("1")]
public string Package { get; }
    [NullableAttribute("2")]
public string TargetName { get; }
    [NullableAttribute("1")]
public IIdentity RemoteIdentity { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    [NullableContextAttribute("1")]
public NegotiateAuthentication(NegotiateAuthenticationClientOptions clientOptions);
    [NullableContextAttribute("1")]
public NegotiateAuthentication(NegotiateAuthenticationServerOptions serverOptions);
    public sealed virtual void Dispose();
    public bool get_IsAuthenticated();
    public ProtectionLevel get_ProtectionLevel();
    public bool get_IsSigned();
    public bool get_IsEncrypted();
    public bool get_IsMutuallyAuthenticated();
    public bool get_IsServer();
    [NullableContextAttribute("1")]
public string get_Package();
    [NullableContextAttribute("2")]
public string get_TargetName();
    [NullableContextAttribute("1")]
public IIdentity get_RemoteIdentity();
    public TokenImpersonationLevel get_ImpersonationLevel();
    public Byte[] GetOutgoingBlob(ReadOnlySpan`1<byte> incomingBlob, NegotiateAuthenticationStatusCode& statusCode);
    [NullableContextAttribute("2")]
public string GetOutgoingBlob(string incomingBlob, NegotiateAuthenticationStatusCode& statusCode);
    public NegotiateAuthenticationStatusCode Wrap(ReadOnlySpan`1<byte> input, IBufferWriter`1<byte> outputWriter, bool requestEncryption, Boolean& isEncrypted);
    public NegotiateAuthenticationStatusCode Unwrap(ReadOnlySpan`1<byte> input, IBufferWriter`1<byte> outputWriter, Boolean& wasEncrypted);
    public NegotiateAuthenticationStatusCode UnwrapInPlace(Span`1<byte> input, Int32& unwrappedOffset, Int32& unwrappedLength, Boolean& wasEncrypted);
    internal void GetMIC(ReadOnlySpan`1<byte> message, IBufferWriter`1<byte> signature);
    internal bool VerifyMIC(ReadOnlySpan`1<byte> message, ReadOnlySpan`1<byte> signature);
    private bool CheckSpn();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Security.NegotiateAuthenticationClientOptions : object {
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <Credential>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtectionLevel <RequiredProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireMutualAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenImpersonationLevel <AllowedImpersonationLevel>k__BackingField;
    public string Package { get; public set; }
    public NetworkCredential Credential { get; public set; }
    [NullableAttribute("2")]
public string TargetName { get; public set; }
    [NullableAttribute("2")]
public ChannelBinding Binding { get; public set; }
    public ProtectionLevel RequiredProtectionLevel { get; public set; }
    public bool RequireMutualAuthentication { get; public set; }
    public TokenImpersonationLevel AllowedImpersonationLevel { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
public void set_Package(string value);
    [CompilerGeneratedAttribute]
public NetworkCredential get_Credential();
    [CompilerGeneratedAttribute]
public void set_Credential(NetworkCredential value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TargetName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TargetName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ChannelBinding get_Binding();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Binding(ChannelBinding value);
    [CompilerGeneratedAttribute]
public ProtectionLevel get_RequiredProtectionLevel();
    [CompilerGeneratedAttribute]
public void set_RequiredProtectionLevel(ProtectionLevel value);
    [CompilerGeneratedAttribute]
public bool get_RequireMutualAuthentication();
    [CompilerGeneratedAttribute]
public void set_RequireMutualAuthentication(bool value);
    [CompilerGeneratedAttribute]
public TokenImpersonationLevel get_AllowedImpersonationLevel();
    [CompilerGeneratedAttribute]
public void set_AllowedImpersonationLevel(TokenImpersonationLevel value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Security.NegotiateAuthenticationServerOptions : object {
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <Credential>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtectionLevel <RequiredProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedProtectionPolicy <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenImpersonationLevel <RequiredImpersonationLevel>k__BackingField;
    public string Package { get; public set; }
    public NetworkCredential Credential { get; public set; }
    [NullableAttribute("2")]
public ChannelBinding Binding { get; public set; }
    public ProtectionLevel RequiredProtectionLevel { get; public set; }
    [NullableAttribute("2")]
public ExtendedProtectionPolicy Policy { get; public set; }
    public TokenImpersonationLevel RequiredImpersonationLevel { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
public void set_Package(string value);
    [CompilerGeneratedAttribute]
public NetworkCredential get_Credential();
    [CompilerGeneratedAttribute]
public void set_Credential(NetworkCredential value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ChannelBinding get_Binding();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Binding(ChannelBinding value);
    [CompilerGeneratedAttribute]
public ProtectionLevel get_RequiredProtectionLevel();
    [CompilerGeneratedAttribute]
public void set_RequiredProtectionLevel(ProtectionLevel value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExtendedProtectionPolicy get_Policy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Policy(ExtendedProtectionPolicy value);
    [CompilerGeneratedAttribute]
public TokenImpersonationLevel get_RequiredImpersonationLevel();
    [CompilerGeneratedAttribute]
public void set_RequiredImpersonationLevel(TokenImpersonationLevel value);
}
public enum System.Net.Security.NegotiateAuthenticationStatusCode : Enum {
    public int value__;
    public static NegotiateAuthenticationStatusCode Completed;
    public static NegotiateAuthenticationStatusCode ContinueNeeded;
    public static NegotiateAuthenticationStatusCode GenericFailure;
    public static NegotiateAuthenticationStatusCode BadBinding;
    public static NegotiateAuthenticationStatusCode Unsupported;
    public static NegotiateAuthenticationStatusCode MessageAltered;
    public static NegotiateAuthenticationStatusCode ContextExpired;
    public static NegotiateAuthenticationStatusCode CredentialsExpired;
    public static NegotiateAuthenticationStatusCode InvalidCredentials;
    public static NegotiateAuthenticationStatusCode InvalidToken;
    public static NegotiateAuthenticationStatusCode UnknownCredentials;
    public static NegotiateAuthenticationStatusCode QopNotSupported;
    public static NegotiateAuthenticationStatusCode OutOfSequence;
    public static NegotiateAuthenticationStatusCode SecurityQosFailed;
    public static NegotiateAuthenticationStatusCode TargetUnknown;
    public static NegotiateAuthenticationStatusCode ImpersonationValidationFailed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    private static ExceptionDispatchInfo s_disposedSentinel;
    private static Byte[] s_emptyMessage;
    private Byte[] _writeHeader;
    private Byte[] _readHeader;
    private Byte[] _readBuffer;
    private int _readBufferOffset;
    private int _readBufferCount;
    private ArrayBufferWriter`1<byte> _writeBuffer;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _writeInProgress;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _readInProgress;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _authInProgress;
    private ExceptionDispatchInfo _exception;
    private StreamFramer _framer;
    private NegotiateAuthentication _context;
    private bool _canRetryAuthentication;
    private ProtectionLevel _expectedProtectionLevel;
    private TokenImpersonationLevel _expectedImpersonationLevel;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private bool isNtlm;
    private bool _remoteOk;
    public bool IsAuthenticated { get; }
    [MemberNotNullWhenAttribute("True", "_context")]
private bool IsAuthenticatedCore { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    private TokenImpersonationLevel PrivateImpersonationLevel { get; }
    private bool HandshakeComplete { get; }
    private bool CanGetSecureStream { get; }
    public IIdentity RemoteIdentity { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public NegotiateStream(Stream innerStream);
    public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    private static NegotiateStream();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<DisposeAsync>d__27")]
public virtual ValueTask DisposeAsync();
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void AuthenticateAsServer();
    [NullableContextAttribute("2")]
public virtual void AuthenticateAsServer(ExtendedProtectionPolicy policy);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual void AuthenticateAsClient();
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual bool get_IsAuthenticated();
    [MemberNotNullWhenAttribute("True", "_context")]
private bool get_IsAuthenticatedCore();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    private TokenImpersonationLevel get_PrivateImpersonationLevel();
    private bool get_HandshakeComplete();
    private bool get_CanGetSecureStream();
    public virtual IIdentity get_RemoteIdentity();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<ReadAsync>d__105`1")]
private ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<WriteAsync>d__109`1")]
private Task WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void ThrowIfExceptional();
    private void ValidateCreateContext(string package, NetworkCredential credential, string servicePrincipalName, ExtendedProtectionPolicy policy, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    private void ValidateCreateContext(string package, bool isServer, NetworkCredential credential, string servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    private void SetFailed(Exception e);
    private void ThrowIfFailed(bool authSuccessCheck);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<AuthenticateAsync>d__119`1")]
private Task AuthenticateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<SendBlobAsync>d__120`1")]
private Task SendBlobAsync(Byte[] message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<ReceiveBlobAsync>d__121`1")]
private Task ReceiveBlobAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<SendAuthResetSignalAndThrowAsync>d__122`1")]
private Task SendAuthResetSignalAndThrowAsync(Byte[] message, Exception exception, CancellationToken cancellationToken);
    private static void ThrowCredentialException(long error);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<<ReadAsync>g__ReadAllAsync|105_0>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__ReadAllAsync|105_0(Stream stream, Memory`1<byte> buffer, bool allowZeroRead, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <ThrowIfExceptional>g__ThrowExceptional|114_0(ExceptionDispatchInfo e);
}
[EventSourceAttribute]
internal class System.Net.Security.NetSecurityTelemetry : EventSource {
    public static NetSecurityTelemetry Log;
    private IncrementingPollingCounter _tlsHandshakeRateCounter;
    private PollingCounter _totalTlsHandshakesCounter;
    private PollingCounter _currentTlsHandshakesCounter;
    private PollingCounter _failedTlsHandshakesCounter;
    private PollingCounter _sessionsOpenCounter;
    private PollingCounter _sessionsOpenTls10Counter;
    private PollingCounter _sessionsOpenTls11Counter;
    private PollingCounter _sessionsOpenTls12Counter;
    private PollingCounter _sessionsOpenTls13Counter;
    private EventCounter _handshakeDurationCounter;
    private EventCounter _handshakeDurationTls10Counter;
    private EventCounter _handshakeDurationTls11Counter;
    private EventCounter _handshakeDurationTls12Counter;
    private EventCounter _handshakeDurationTls13Counter;
    private long _finishedTlsHandshakes;
    private long _startedTlsHandshakes;
    private long _failedTlsHandshakes;
    private long _sessionsOpen;
    private long _sessionsOpenTls10;
    private long _sessionsOpenTls11;
    private long _sessionsOpenTls12;
    private long _sessionsOpenTls13;
    private static NetSecurityTelemetry();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [EventAttribute("1")]
public void HandshakeStart(bool isServer, string targetHost);
    [EventAttribute("2")]
private void HandshakeStop(SslProtocols protocol);
    [EventAttribute("3")]
private void HandshakeFailed(bool isServer, double elapsedMilliseconds, string exceptionMessage);
    [NonEventAttribute]
public void HandshakeFailed(bool isServer, long startingTimestamp, string exceptionMessage);
    [NonEventAttribute]
public void HandshakeCompleted(SslProtocols protocol, long startingTimestamp, bool connectionOpen);
    [NonEventAttribute]
public void ConnectionClosed(SslProtocols protocol);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, bool arg1, string arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, bool arg1, double arg2, string arg3);
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_0();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_1();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_2();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_3();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_4();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_5();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_6();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_7();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__24_8();
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
    public static ProtectionLevel EncryptAndSign;
}
internal class System.Net.Security.ProtocolToken : ValueType {
    internal SecurityStatusPal Status;
    internal Byte[] Payload;
    internal int Size;
    internal bool Failed { get; }
    internal bool Done { get; }
    internal bool get_Failed();
    internal bool get_Done();
    internal Exception GetException();
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SafeCredentialReference : CriticalFinalizerObject {
    [CompilerGeneratedAttribute]
private SafeFreeCredentials <Target>k__BackingField;
    internal SafeFreeCredentials Target { get; private set; }
    private SafeCredentialReference(SafeFreeCredentials target);
    [CompilerGeneratedAttribute]
internal SafeFreeCredentials get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(SafeFreeCredentials value);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    public sealed virtual void Dispose();
    private void DisposeInternal();
    protected virtual override void Finalize();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    internal CredHandle _handle;
    protected SafeFreeCredentials _EffectiveCredential;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public virtual string ToString();
    internal static int InitializeSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteSslContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, InputSecurityBuffers inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunInitializeSecurityContext(SafeFreeCredentials& inCredentials, bool isContextAbsent, Byte* targetName, ContextFlags inFlags, Endianness endianness, SecBufferDesc* inputBuffer, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& attributes, SafeFreeContextBuffer handleTemplate);
    internal static int AcceptSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteSslContext& refContext, ContextFlags inFlags, Endianness endianness, InputSecurityBuffers inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunAcceptSecurityContext_SECURITY(SafeFreeCredentials& inCredentials, bool isContextAbsent, SecBufferDesc* inputBuffer, ContextFlags inFlags, Endianness endianness, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& outFlags, SafeFreeContextBuffer handleTemplate);
    internal static int CompleteAuthToken(SafeDeleteSslContext& refContext, InputSecurityBuffer& inSecBuffer);
    internal static int ApplyControlToken(SafeDeleteSslContext& refContext, SecurityBuffer& inSecBuffer);
}
internal class System.Net.Security.SafeDeleteSslContext : SafeDeleteContext {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    internal static int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle();
    public static int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
}
internal class System.Net.Security.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBufferChannelBinding : ChannelBinding {
    private int _size;
    public int Size { get; }
    public bool IsInvalid { get; }
    public virtual int get_Size();
    public virtual bool get_IsInvalid();
    internal void Set(IntPtr value);
    internal static SafeFreeContextBufferChannelBinding CreateEmptyHandle();
    public static int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute contextAttribute, SecPkgContext_Bindings* buffer, SafeFreeContextBufferChannelBinding refHandle);
    public virtual string ToString();
}
internal class System.Net.Security.SafeFreeContextBufferChannelBinding_SECURITY : SafeFreeContextBufferChannelBinding {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCredential_SECURITY : SafeFreeCredentials {
    public bool HasLocalCertificate;
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    internal DateTime _expiry;
    internal CredHandle _handle;
    public bool IsInvalid { get; }
    public DateTime Expiry { get; }
    public virtual bool get_IsInvalid();
    public DateTime get_Expiry();
    public static int AcquireDefaultCredential(string package, CredentialUse intent, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SCHANNEL_CRED* authdata, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SCH_CREDENTIALS* authdata, SafeFreeCredentials& outCredential);
}
internal class System.Net.Security.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecurityBuffer : ValueType {
    public int offset;
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType SECBUFFER_EMPTY;
    public static SecurityBufferType SECBUFFER_DATA;
    public static SecurityBufferType SECBUFFER_TOKEN;
    public static SecurityBufferType SECBUFFER_PKG_PARAMS;
    public static SecurityBufferType SECBUFFER_MISSING;
    public static SecurityBufferType SECBUFFER_EXTRA;
    public static SecurityBufferType SECBUFFER_STREAM_TRAILER;
    public static SecurityBufferType SECBUFFER_STREAM_HEADER;
    public static SecurityBufferType SECBUFFER_PADDING;
    public static SecurityBufferType SECBUFFER_STREAM;
    public static SecurityBufferType SECBUFFER_CHANNEL_BINDINGS;
    public static SecurityBufferType SECBUFFER_TARGET_HOST;
    public static SecurityBufferType SECBUFFER_ALERT;
    public static SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS;
    public static SecurityBufferType SECBUFFER_READONLY;
    public static SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM;
}
internal class System.Net.Security.SecurityContextTokenHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private int _disposed;
    protected virtual bool ReleaseHandle();
}
public class System.Net.Security.ServerCertificateSelectionCallback : MulticastDelegate {
    public ServerCertificateSelectionCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual X509Certificate Invoke(object sender, string hostName);
    public virtual IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
public class System.Net.Security.ServerOptionsSelectionCallback : MulticastDelegate {
    public ServerOptionsSelectionCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ValueTask`1<SslServerAuthenticationOptions> Invoke(SslStream stream, SslClientHelloInfo clientHelloInfo, object state, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(SslStream stream, SslClientHelloInfo clientHelloInfo, object state, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual ValueTask`1<SslServerAuthenticationOptions> EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.Net.Security.SslApplicationProtocol : ValueType {
    private static Encoding s_utf8;
    private static Byte[] s_http3Utf8;
    private static Byte[] s_http2Utf8;
    private static Byte[] s_http11Utf8;
    public static SslApplicationProtocol Http3;
    public static SslApplicationProtocol Http2;
    public static SslApplicationProtocol Http11;
    private Byte[] _readOnlyProtocol;
    public ReadOnlyMemory`1<byte> Protocol { get; }
    internal SslApplicationProtocol(Byte[] protocol, bool copy);
    [NullableContextAttribute("1")]
public SslApplicationProtocol(Byte[] protocol);
    [NullableContextAttribute("1")]
public SslApplicationProtocol(string protocol);
    private static SslApplicationProtocol();
    public ReadOnlyMemory`1<byte> get_Protocol();
    public sealed virtual bool Equals(SslApplicationProtocol other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(SslApplicationProtocol left, SslApplicationProtocol right);
    public static bool op_Inequality(SslApplicationProtocol left, SslApplicationProtocol right);
}
internal class System.Net.Security.SslAuthenticationOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowRenegotiation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServer>k__BackingField;
    [CompilerGeneratedAttribute]
private SslStreamCertificateContext <CertificateContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <EnabledSslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private X509RevocationMode <CertificateRevocationCheckMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionPolicy <EncryptionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoteCertRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertName>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <CertValidationDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <CertSelectionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertificateSelectionCallback <ServerCertSelectionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuitesPolicy <CipherSuitesPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private object <UserState>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerOptionsSelectionCallback <ServerOptionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainPolicy <CertificateChainPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowTlsResume>k__BackingField;
    internal bool AllowRenegotiation { get; internal set; }
    internal string TargetHost { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; internal set; }
    internal List`1<SslApplicationProtocol> ApplicationProtocols { get; internal set; }
    internal bool IsServer { get; internal set; }
    internal SslStreamCertificateContext CertificateContext { get; internal set; }
    internal SslProtocols EnabledSslProtocols { get; internal set; }
    internal X509RevocationMode CertificateRevocationCheckMode { get; internal set; }
    internal EncryptionPolicy EncryptionPolicy { get; internal set; }
    internal bool RemoteCertRequired { get; internal set; }
    internal bool CheckCertName { get; internal set; }
    internal RemoteCertificateValidationCallback CertValidationDelegate { get; internal set; }
    internal LocalCertificateSelectionCallback CertSelectionDelegate { get; internal set; }
    internal ServerCertificateSelectionCallback ServerCertSelectionDelegate { get; internal set; }
    unknown CipherSuitesPolicy CipherSuitesPolicy {internal set; }
    internal object UserState { get; internal set; }
    internal ServerOptionsSelectionCallback ServerOptionDelegate { get; internal set; }
    internal X509ChainPolicy CertificateChainPolicy { get; internal set; }
    internal bool AllowTlsResume { get; internal set; }
    internal void UpdateOptions(SslClientAuthenticationOptions sslClientAuthenticationOptions);
    internal void UpdateOptions(ServerOptionsSelectionCallback optionCallback, object state);
    internal void UpdateOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    private static SslProtocols FilterOutIncompatibleSslProtocols(SslProtocols protocols);
    [CompilerGeneratedAttribute]
internal bool get_AllowRenegotiation();
    [CompilerGeneratedAttribute]
internal void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
internal string get_TargetHost();
    [CompilerGeneratedAttribute]
internal void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
internal X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
internal List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
internal void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
internal bool get_IsServer();
    [CompilerGeneratedAttribute]
internal void set_IsServer(bool value);
    [CompilerGeneratedAttribute]
internal SslStreamCertificateContext get_CertificateContext();
    [CompilerGeneratedAttribute]
internal void set_CertificateContext(SslStreamCertificateContext value);
    [CompilerGeneratedAttribute]
internal SslProtocols get_EnabledSslProtocols();
    [CompilerGeneratedAttribute]
internal void set_EnabledSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal X509RevocationMode get_CertificateRevocationCheckMode();
    [CompilerGeneratedAttribute]
internal void set_CertificateRevocationCheckMode(X509RevocationMode value);
    [CompilerGeneratedAttribute]
internal EncryptionPolicy get_EncryptionPolicy();
    [CompilerGeneratedAttribute]
internal void set_EncryptionPolicy(EncryptionPolicy value);
    [CompilerGeneratedAttribute]
internal bool get_RemoteCertRequired();
    [CompilerGeneratedAttribute]
internal void set_RemoteCertRequired(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertName();
    [CompilerGeneratedAttribute]
internal void set_CheckCertName(bool value);
    [CompilerGeneratedAttribute]
internal RemoteCertificateValidationCallback get_CertValidationDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertValidationDelegate(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
internal LocalCertificateSelectionCallback get_CertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertSelectionDelegate(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
internal ServerCertificateSelectionCallback get_ServerCertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertSelectionDelegate(ServerCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
internal void set_CipherSuitesPolicy(CipherSuitesPolicy value);
    [CompilerGeneratedAttribute]
internal object get_UserState();
    [CompilerGeneratedAttribute]
internal void set_UserState(object value);
    [CompilerGeneratedAttribute]
internal ServerOptionsSelectionCallback get_ServerOptionDelegate();
    [CompilerGeneratedAttribute]
internal void set_ServerOptionDelegate(ServerOptionsSelectionCallback value);
    [CompilerGeneratedAttribute]
internal X509ChainPolicy get_CertificateChainPolicy();
    [CompilerGeneratedAttribute]
internal void set_CertificateChainPolicy(X509ChainPolicy value);
    [CompilerGeneratedAttribute]
internal bool get_AllowTlsResume();
    [CompilerGeneratedAttribute]
internal void set_AllowTlsResume(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Security.SslCertificateTrust : object {
    internal X509Store _store;
    internal X509Certificate2Collection _trustList;
    internal bool _sendTrustInHandshake;
    public static SslCertificateTrust CreateForX509Store(X509Store store, bool sendTrustInHandshake);
    public static SslCertificateTrust CreateForX509Collection(X509Certificate2Collection trustList, bool sendTrustInHandshake);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Security.SslClientAuthenticationOptions : object {
    private EncryptionPolicy _encryptionPolicy;
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private bool _allowRenegotiation;
    private bool _allowTlsResume;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private SslStreamCertificateContext <ClientCertificateContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuitesPolicy <CipherSuitesPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainPolicy <CertificateChainPolicy>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public bool AllowTlsResume { get; public set; }
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public string TargetHost { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public SslStreamCertificateContext ClientCertificateContext { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public CipherSuitesPolicy CipherSuitesPolicy { get; public set; }
    public X509ChainPolicy CertificateChainPolicy { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    public bool get_AllowTlsResume();
    public void set_AllowTlsResume(bool value);
    [CompilerGeneratedAttribute]
public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public string get_TargetHost();
    [CompilerGeneratedAttribute]
public void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
public SslStreamCertificateContext get_ClientCertificateContext();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateContext(SslStreamCertificateContext value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public CipherSuitesPolicy get_CipherSuitesPolicy();
    [CompilerGeneratedAttribute]
public void set_CipherSuitesPolicy(CipherSuitesPolicy value);
    [CompilerGeneratedAttribute]
public X509ChainPolicy get_CertificateChainPolicy();
    [CompilerGeneratedAttribute]
public void set_CertificateChainPolicy(X509ChainPolicy value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Net.Security.SslClientHelloInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <SslProtocols>k__BackingField;
    public string ServerName { get; }
    public SslProtocols SslProtocols { get; }
    public SslClientHelloInfo(string serverName, SslProtocols sslProtocols);
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public SslProtocols get_SslProtocols();
}
internal class System.Net.Security.SslConnectionInfo : ValueType {
    private static Byte[] s_http1;
    private static Byte[] s_http2;
    private static Byte[] s_http3;
    [CompilerGeneratedAttribute]
private int <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private TlsCipherSuite <TlsCipherSuite>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataCipherAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataHashAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataHashKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchangeAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ApplicationProtocol>k__BackingField;
    public int Protocol { get; private set; }
    public TlsCipherSuite TlsCipherSuite { get; private set; }
    public int DataCipherAlg { get; private set; }
    public int DataKeySize { get; private set; }
    public int DataHashAlg { get; private set; }
    public int DataHashKeySize { get; private set; }
    public int KeyExchangeAlg { get; private set; }
    public int KeyExchKeySize { get; private set; }
    public Byte[] ApplicationProtocol { get; internal set; }
    private static SslConnectionInfo();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Protocol();
    [CompilerGeneratedAttribute]
private void set_Protocol(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TlsCipherSuite get_TlsCipherSuite();
    [CompilerGeneratedAttribute]
private void set_TlsCipherSuite(TlsCipherSuite value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_DataCipherAlg();
    [CompilerGeneratedAttribute]
private void set_DataCipherAlg(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_DataKeySize();
    [CompilerGeneratedAttribute]
private void set_DataKeySize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_DataHashAlg();
    [CompilerGeneratedAttribute]
private void set_DataHashAlg(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_DataHashKeySize();
    [CompilerGeneratedAttribute]
private void set_DataHashKeySize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_KeyExchangeAlg();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeAlg(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_KeyExchKeySize();
    [CompilerGeneratedAttribute]
private void set_KeyExchKeySize(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_ApplicationProtocol();
    [CompilerGeneratedAttribute]
internal void set_ApplicationProtocol(Byte[] value);
    private static Byte[] GetNegotiatedApplicationProtocol(SafeDeleteContext context);
    public void UpdateSslConnectionInfo(SafeDeleteContext securityContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Security.SslServerAuthenticationOptions : object {
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private EncryptionPolicy _encryptionPolicy;
    private bool _allowRenegotiation;
    private bool _allowTlsResume;
    [CompilerGeneratedAttribute]
private bool <ClientCertificateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertificateSelectionCallback <ServerCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SslStreamCertificateContext <ServerCertificateContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuitesPolicy <CipherSuitesPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainPolicy <CertificateChainPolicy>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public bool AllowTlsResume { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public ServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public SslStreamCertificateContext ServerCertificateContext { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public CipherSuitesPolicy CipherSuitesPolicy { get; public set; }
    public X509ChainPolicy CertificateChainPolicy { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    public bool get_AllowTlsResume();
    public void set_AllowTlsResume(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClientCertificateRequired();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateRequired(bool value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
public void set_ServerCertificate(X509Certificate value);
    [CompilerGeneratedAttribute]
public SslStreamCertificateContext get_ServerCertificateContext();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateContext(SslStreamCertificateContext value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    [CompilerGeneratedAttribute]
public CipherSuitesPolicy get_CipherSuitesPolicy();
    [CompilerGeneratedAttribute]
public void set_CipherSuitesPolicy(CipherSuitesPolicy value);
    [CompilerGeneratedAttribute]
public X509ChainPolicy get_CertificateChainPolicy();
    [CompilerGeneratedAttribute]
public void set_CertificateChainPolicy(X509ChainPolicy value);
}
internal static class System.Net.Security.SslSessionsCache : object {
    private static ConcurrentDictionary`2<SslCredKey, SafeCredentialReference> s_cachedCreds;
    private static SslSessionsCache();
    internal static SafeFreeCredentials TryCachedCredential(Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy, bool checkRevocation, bool allowTlsResume, bool sendTrustList);
    private static SafeFreeCredentials GetCachedCredential(SslCredKey key);
    internal static void CacheCredential(SafeFreeCredentials creds, Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy, bool checkRevocation, bool allowTlsResume, bool sendTrustList);
    [CompilerGeneratedAttribute]
internal static void <CacheCredential>g__ShrinkCredentialCache|5_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Security.SslStream : AuthenticatedStream {
    private static ExceptionDispatchInfo s_disposedSentinel;
    private ExceptionDispatchInfo _exception;
    private bool _shutdown;
    private bool _handshakeCompleted;
    private SslBuffer _buffer;
    private int _nestedWrite;
    private int _nestedRead;
    private SslAuthenticationOptions _sslAuthenticationOptions;
    private int _nestedAuth;
    private bool _isRenego;
    private TlsFrameInfo _lastFrame;
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) _handshakeWaiter;
    private bool _receivedEOF;
    private int _connectionOpenedStatus;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteSslContext _securityContext;
    private SslConnectionInfo _connectionInfo;
    private X509Certificate _selectedClientCertificate;
    private X509Certificate2 _remoteCertificate;
    private bool _remoteCertificateExposed;
    private int _headerSize;
    private int _trailerSize;
    private int _maxDataSize;
    private static Oid s_serverAuthOid;
    private static Oid s_clientAuthOid;
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertRevocationStatus { get; }
    [NullableAttribute("2")]
public X509Certificate LocalCertificate { get; }
    [NullableAttribute("2")]
public X509Certificate RemoteCertificate { get; }
    public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    [CLSCompliantAttribute("False")]
public TlsCipherSuite NegotiatedCipherSuite { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public string TargetHostName { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    private object _handshakeLock { get; }
    [NullableAttribute("2")]
internal X509Certificate LocalServerCertificate { get; }
    [NullableAttribute("2")]
internal X509Certificate LocalClientCertificate { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal int MaxDataSize { get; }
    internal bool IsValidContext { get; }
    internal bool RemoteCertRequired { get; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    [NullableContextAttribute("2")]
public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    [NullableContextAttribute("2")]
public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    private static SslStream();
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    internal IAsyncResult BeginAuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    public virtual void AuthenticateAsClient(string targetHost);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public void AuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public void AuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
    public Task AuthenticateAsServerAsync(ServerOptionsSelectionCallback optionsCallback, object state, CancellationToken cancellationToken);
    public virtual Task ShutdownAsync();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual SslProtocols get_SslProtocol();
    private SslProtocols GetSslProtocolInternal();
    public virtual bool get_CheckCertRevocationStatus();
    [NullableContextAttribute("2")]
public virtual X509Certificate get_LocalCertificate();
    [NullableContextAttribute("2")]
public virtual X509Certificate get_RemoteCertificate();
    public SslApplicationProtocol get_NegotiatedApplicationProtocol();
    public virtual TlsCipherSuite get_NegotiatedCipherSuite();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public string get_TargetHostName();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("freebsd")]
public virtual Task NegotiateClientCertificateAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<DisposeAsync>d__113")]
public virtual ValueTask DisposeAsync();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void ThrowIfExceptional();
    private void ThrowIfExceptionalOrNotAuthenticated();
    private void ThrowIfExceptionalOrNotHandshake();
    private void ThrowIfExceptionalOrNotAuthenticatedOrShutdown();
    private static void ThrowNotAuthenticated();
    private object get__handshakeLock();
    private void SetException(Exception e);
    private void CloseInternal();
    private SecurityStatusPal EncryptData(ReadOnlyMemory`1<byte> buffer, Byte[]& outBuffer, Int32& outSize);
    private Task ProcessAuthenticationAsync(bool isAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<ProcessAuthenticationWithTelemetryAsync>d__147")]
private Task ProcessAuthenticationWithTelemetryAsync(bool isAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<ReplyOnReAuthenticationAsync>d__148`1")]
private Task ReplyOnReAuthenticationAsync(Byte[] buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<RenegotiateAsync>d__149`1")]
private Task RenegotiateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<ForceAuthenticationAsync>d__150`1")]
private Task ForceAuthenticationAsync(bool receiveFirst, Byte[] reAuthenticationData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<ReceiveHandshakeFrameAsync>d__151`1")]
private ValueTask`1<int> ReceiveHandshakeFrameAsync(CancellationToken cancellationToken);
    private void ProcessTlsFrame(int frameSize, ProtocolToken& message);
    private void SendAuthResetSignal(ReadOnlySpan`1<byte> alert, ExceptionDispatchInfo exception);
    private bool CompleteHandshake(ProtocolToken& alertToken, SslPolicyErrors& sslPolicyErrors, X509ChainStatusFlags& chainStatus);
    private void CompleteHandshake(SslAuthenticationOptions sslAuthenticationOptions);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<WriteAsyncChunked>d__156`1")]
private ValueTask WriteAsyncChunked(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    private ValueTask WriteSingleChunk(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    protected virtual override void Finalize();
    private void ReturnReadBufferIfEmpty();
    private bool HaveFullTlsFrame(Int32& frameSize);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<EnsureFullTlsFrameAsync>d__161`1")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> EnsureFullTlsFrameAsync(CancellationToken cancellationToken, int estimatedSize);
    private SecurityStatusPal DecryptData(int frameSize);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<ReadAsyncInternal>d__163`1")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> ReadAsyncInternal(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<WriteAsyncInternal>d__164`1")]
private ValueTask WriteAsyncInternal(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    private int CopyDecryptedData(Memory`1<byte> buffer);
    private int GetFrameSize(ReadOnlySpan`1<byte> buffer);
    internal X509Certificate get_LocalServerCertificate();
    internal X509Certificate get_LocalClientCertificate();
    internal bool get_IsRemoteCertificateAvailable();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal int get_MaxDataSize();
    internal bool get_IsValidContext();
    internal bool get_RemoteCertRequired();
    internal void CloseContext();
    internal static X509Certificate2 FindCertificateWithPrivateKey(object instance, bool isServer, X509Certificate certificate);
    private static X509Certificate2 MakeEx(X509Certificate certificate);
    private String[] GetRequestCertificateAuthorities();
    internal X509Certificate2 SelectClientCertificate();
    private bool AcquireClientCredentials(Byte[]& thumbPrint, bool newCredentialsRequested);
    private static List`1<T> EnsureInitialized(List`1& list);
    private bool AcquireServerCredentials(Byte[]& thumbPrint);
    private static SafeFreeCredentials AcquireCredentialsHandle(SslAuthenticationOptions sslAuthenticationOptions, bool newCredentialsRequested);
    internal void NextMessage(ReadOnlySpan`1<byte> incomingBuffer, ProtocolToken& token);
    private SecurityStatusPal GenerateToken(ReadOnlySpan`1<byte> inputBuffer, Byte[]& output);
    internal SecurityStatusPal Renegotiate(Byte[]& output);
    internal void ProcessHandshakeSuccess();
    internal SecurityStatusPal Encrypt(ReadOnlyMemory`1<byte> buffer, Byte[]& output, Int32& resultSize);
    internal SecurityStatusPal Decrypt(Span`1<byte> buffer, Int32& outputOffset, Int32& outputCount);
    internal bool VerifyRemoteCertificate(RemoteCertificateValidationCallback remoteCertValidationCallback, SslCertificateTrust trust, ProtocolToken& alertToken, SslPolicyErrors& sslPolicyErrors, X509ChainStatusFlags& chainStatus);
    private void CreateFatalHandshakeAlertToken(SslPolicyErrors sslPolicyErrors, X509Chain chain, ProtocolToken& alertToken);
    private Byte[] CreateShutdownToken();
    private void GenerateAlertToken(ProtocolToken& alertToken);
    private static TlsAlertMessage GetAlertMessageFromChain(X509Chain chain);
    private void LogCertificateValidation(RemoteCertificateValidationCallback remoteCertValidationCallback, SslPolicyErrors sslPolicyErrors, bool success, X509Chain chain);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
    [CompilerGeneratedAttribute]
private void <ThrowIfExceptional>g__ThrowExceptional|126_0(ExceptionDispatchInfo e);
    [CompilerGeneratedAttribute]
internal static void <ThrowIfExceptionalOrNotAuthenticatedOrShutdown>g__ThrowAlreadyShutdown|129_0();
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<<WriteSingleChunk>g__WaitAndWriteAsync|157_0>d`1")]
[CompilerGeneratedAttribute]
private ValueTask <WriteSingleChunk>g__WaitAndWriteAsync|157_0(ReadOnlyMemory`1<byte> buffer, Task waitTask, Byte[] rentedBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<<WriteSingleChunk>g__CompleteWriteAsync|157_1>d`1")]
[CompilerGeneratedAttribute]
internal static ValueTask <WriteSingleChunk>g__CompleteWriteAsync|157_1(ValueTask writeTask, Byte[] bufferToReturn);
    [CompilerGeneratedAttribute]
internal static X509Certificate2 <FindCertificateWithPrivateKey>g__FindCertWithPrivateKey|192_0(bool isServer, <>c__DisplayClass192_0& , <>c__DisplayClass192_1& );
    [CompilerGeneratedAttribute]
internal static DateTime <AcquireCredentialsHandle>g__GetExpiryTimestamp|199_0(SslStreamCertificateContext certificateContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Security.SslStreamCertificateContext : object {
    internal SslCertificateTrust Trust;
    [CompilerGeneratedAttribute]
private X509Certificate2 <TargetCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<X509Certificate2> <IntermediateCertificates>k__BackingField;
    public X509Certificate2 TargetCertificate { get; }
    public ReadOnlyCollection`1<X509Certificate2> IntermediateCertificates { get; }
    private SslStreamCertificateContext(X509Certificate2 target, ReadOnlyCollection`1<X509Certificate2> intermediates, SslCertificateTrust trust);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_TargetCertificate();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<X509Certificate2> get_IntermediateCertificates();
    [EditorBrowsableAttribute("1")]
public static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection additionalCertificates, bool offline);
    public static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection additionalCertificates, bool offline, SslCertificateTrust trust);
    internal static SslStreamCertificateContext Create(X509Certificate2 target, X509Certificate2Collection additionalCertificates, bool offline, SslCertificateTrust trust, bool noOcspFetch);
    internal SslStreamCertificateContext Duplicate();
    internal static SslStreamCertificateContext Create(X509Certificate2 target);
}
internal static class System.Net.Security.SslStreamPal : object {
    private static Byte[] s_http1;
    private static Byte[] s_http2;
    private static Byte[] s_http12;
    private static Byte[] s_http21;
    private static bool UseNewCryptoApi;
    private static Byte[] s_sessionTokenBuffer;
    private static Byte[] s_schannelShutdownBytes;
    private static SslStreamPal();
    public static Exception GetException(SecurityStatusPal status);
    private static Byte[] InitSessionTokenBuffer();
    private static void SetAlpn(InputSecurityBuffers& inputBuffers, List`1<SslApplicationProtocol> alpn, Span`1<byte> localBuffer);
    public static SecurityStatusPal SelectApplicationProtocol(SafeFreeCredentials credentialsHandle, SafeDeleteSslContext context, SslAuthenticationOptions sslAuthenticationOptions, ReadOnlySpan`1<byte> clientProtocols);
    public static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteSslContext& context, ReadOnlySpan`1<byte> inputBuffer, Byte[]& outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    public static bool TryUpdateClintCertificate(SafeFreeCredentials _1, SafeDeleteSslContext _2, SslAuthenticationOptions _3);
    public static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteSslContext& context, string targetName, ReadOnlySpan`1<byte> inputBuffer, Byte[]& outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    public static SecurityStatusPal Renegotiate(SafeFreeCredentials& credentialsHandle, SafeDeleteSslContext& context, SslAuthenticationOptions sslAuthenticationOptions, Byte[]& outputBuffer);
    public static SafeFreeCredentials AcquireCredentialsHandle(SslAuthenticationOptions sslAuthenticationOptions, bool newCredentialsRequested);
    private static void AttachCertificateStore(SafeFreeCredentials cred, X509Store store);
    public static SafeFreeCredentials AcquireCredentialsHandleSchannelCred(SslAuthenticationOptions authOptions);
    public static SafeFreeCredentials AcquireCredentialsHandleSchCredentials(SslAuthenticationOptions authOptions);
    public static SecurityStatusPal EncryptMessage(SafeDeleteSslContext securityContext, ReadOnlyMemory`1<byte> input, int headerSize, int trailerSize, Byte[]& output, Int32& resultSize);
    public static SecurityStatusPal DecryptMessage(SafeDeleteSslContext securityContext, Span`1<byte> buffer, Int32& offset, Int32& count);
    public static SecurityStatusPal ApplyAlertToken(SafeDeleteSslContext securityContext, TlsAlertType alertType, TlsAlertMessage alertMessage);
    public static SecurityStatusPal ApplyShutdownToken(SafeDeleteSslContext securityContext);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SafeDeleteContext securityContext, ChannelBindingKind attribute);
    public static void QueryContextStreamSizes(SafeDeleteContext securityContext, StreamSizes& streamSizes);
    public static void QueryContextConnectionInfo(SafeDeleteContext securityContext, SslConnectionInfo& connectionInfo);
    private static int GetProtocolFlagsFromSslProtocols(SslProtocols protocols, bool isServer);
    private static SCHANNEL_CRED CreateSecureCredential(Flags flags, int protocols, EncryptionPolicy policy);
    private static SafeFreeCredentials AcquireCredentialsHandle(CredentialUse credUsage, SCHANNEL_CRED* secureCredential);
    private static SafeFreeCredentials AcquireCredentialsHandle(CredentialUse credUsage, SCH_CREDENTIALS* secureCredential);
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
[IsReadOnlyAttribute]
internal class System.Net.Security.SyncReadWriteAdapter : ValueType {
    public static override ValueTask`1<int> ReadAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    public static override ValueTask`1<int> ReadAtLeastAsync(Stream stream, Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    public static override ValueTask WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public static override Task FlushAsync(Stream stream, CancellationToken cancellationToken);
    public static override Task WaitAsync(TaskCompletionSource`1<bool> waiter);
}
internal static class System.Net.Security.TargetHostNameHelper : object {
    private static IdnMapping s_idnMapping;
    private static SearchValues`1<char> s_safeDnsChars;
    private static TargetHostNameHelper();
    private static bool IsSafeDnsString(ReadOnlySpan`1<char> name);
    internal static string NormalizeHostName(string targetHost);
}
internal enum System.Net.Security.TlsAlertDescription : Enum {
    public byte value__;
    public static TlsAlertDescription CloseNotify;
    public static TlsAlertDescription UnexpectedMessage;
    public static TlsAlertDescription BadRecordMac;
    public static TlsAlertDescription DecryptionFailed;
    public static TlsAlertDescription RecordOverflow;
    public static TlsAlertDescription DecompressionFail;
    public static TlsAlertDescription HandshakeFailure;
    public static TlsAlertDescription BadCertificate;
    public static TlsAlertDescription UnsupportedCert;
    public static TlsAlertDescription CertificateRevoked;
    public static TlsAlertDescription CertificateExpired;
    public static TlsAlertDescription CertificateUnknown;
    public static TlsAlertDescription IllegalParameter;
    public static TlsAlertDescription UnknownCA;
    public static TlsAlertDescription AccessDenied;
    public static TlsAlertDescription DecodeError;
    public static TlsAlertDescription DecryptError;
    public static TlsAlertDescription ExportRestriction;
    public static TlsAlertDescription ProtocolVersion;
    public static TlsAlertDescription InsuffientSecurity;
    public static TlsAlertDescription InternalError;
    public static TlsAlertDescription UserCanceled;
    public static TlsAlertDescription NoRenegotiation;
    public static TlsAlertDescription UnsupportedExt;
}
internal enum System.Net.Security.TlsAlertLevel : Enum {
    public byte value__;
    public static TlsAlertLevel Warning;
    public static TlsAlertLevel Fatal;
}
internal enum System.Net.Security.TlsAlertMessage : Enum {
    public int value__;
    public static TlsAlertMessage CloseNotify;
    public static TlsAlertMessage UnexpectedMessage;
    public static TlsAlertMessage BadRecordMac;
    public static TlsAlertMessage DecryptionFailed;
    public static TlsAlertMessage RecordOverflow;
    public static TlsAlertMessage DecompressionFail;
    public static TlsAlertMessage HandshakeFailure;
    public static TlsAlertMessage BadCertificate;
    public static TlsAlertMessage UnsupportedCert;
    public static TlsAlertMessage CertificateRevoked;
    public static TlsAlertMessage CertificateExpired;
    public static TlsAlertMessage CertificateUnknown;
    public static TlsAlertMessage IllegalParameter;
    public static TlsAlertMessage UnknownCA;
    public static TlsAlertMessage AccessDenied;
    public static TlsAlertMessage DecodeError;
    public static TlsAlertMessage DecryptError;
    public static TlsAlertMessage ExportRestriction;
    public static TlsAlertMessage ProtocolVersion;
    public static TlsAlertMessage InsuffientSecurity;
    public static TlsAlertMessage InternalError;
    public static TlsAlertMessage UserCanceled;
    public static TlsAlertMessage NoRenegotiation;
    public static TlsAlertMessage UnsupportedExt;
}
internal enum System.Net.Security.TlsAlertType : Enum {
    public int value__;
    public static TlsAlertType Warning;
    public static TlsAlertType Fatal;
}
[CLSCompliantAttribute("False")]
public enum System.Net.Security.TlsCipherSuite : Enum {
    public ushort value__;
    public static TlsCipherSuite TLS_NULL_WITH_NULL_NULL;
    public static TlsCipherSuite TLS_RSA_WITH_NULL_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_RC4_128_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static TlsCipherSuite TLS_DH_anon_WITH_RC4_128_MD5;
    public static TlsCipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_DES_CBC_MD5;
    public static TlsCipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5;
    public static TlsCipherSuite TLS_KRB5_WITH_RC4_128_MD5;
    public static TlsCipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5;
    public static TlsCipherSuite TLS_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_AES_128_CCM_SHA256;
    public static TlsCipherSuite TLS_AES_128_CCM_8_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256;
}
internal enum System.Net.Security.TlsContentType : Enum {
    public byte value__;
    public static TlsContentType ChangeCipherSpec;
    public static TlsContentType Alert;
    public static TlsContentType Handshake;
    public static TlsContentType AppData;
}
internal class System.Net.Security.TlsFrameHeader : ValueType {
    public TlsContentType Type;
    public SslProtocols Version;
    public int Length;
    public virtual string ToString();
}
internal static class System.Net.Security.TlsFrameHelper : object {
    private static Byte[] s_protocolMismatch13;
    private static Byte[] s_protocolMismatch12;
    private static Byte[] s_protocolMismatch11;
    private static Byte[] s_protocolMismatch10;
    private static Byte[] s_protocolMismatch30;
    private static IdnMapping s_idnMapping;
    private static Encoding s_encoding;
    private static TlsFrameHelper();
    public static bool TryGetFrameHeader(ReadOnlySpan`1<byte> frame, TlsFrameHeader& header);
    public static bool TryGetFrameInfo(ReadOnlySpan`1<byte> frame, TlsFrameInfo& info, ProcessingOptions options, HelloExtensionCallback callback);
    public static bool TryGetAlertInfo(ReadOnlySpan`1<byte> frame, TlsAlertLevel& level, TlsAlertDescription& description);
    private static Byte[] CreateProtocolVersionAlert(SslProtocols version);
    public static Byte[] CreateAlertFrame(SslProtocols version, TlsAlertDescription reason);
    private static bool TryParseHelloFrame(ReadOnlySpan`1<byte> sslHandshake, TlsFrameInfo& info, ProcessingOptions options, HelloExtensionCallback callback);
    private static bool TryParseClientHello(ReadOnlySpan`1<byte> clientHello, TlsFrameInfo& info, ProcessingOptions options, HelloExtensionCallback callback);
    private static bool TryParseServerHello(ReadOnlySpan`1<byte> serverHello, TlsFrameInfo& info, ProcessingOptions options, HelloExtensionCallback callback);
    private static bool TryParseHelloExtensions(ReadOnlySpan`1<byte> extensions, TlsFrameInfo& info, ProcessingOptions options, HelloExtensionCallback callback);
    private static bool TryGetSniFromServerNameList(ReadOnlySpan`1<byte> serverNameListExtension, String& sni);
    private static string GetSniFromServerName(ReadOnlySpan`1<byte> serverName, Boolean& invalid);
    private static string GetSniFromHostNameStruct(ReadOnlySpan`1<byte> hostNameStruct, Boolean& invalid);
    private static bool TryGetSupportedVersionsFromExtension(ReadOnlySpan`1<byte> extensionData, SslProtocols& protocols);
    private static bool TryGetApplicationProtocolsFromExtension(ReadOnlySpan`1<byte> extensionData, ApplicationProtocolInfo& alpn);
    private static SslProtocols TlsMinorVersionToProtocol(byte value);
    private static string DecodeString(ReadOnlySpan`1<byte> bytes);
    private static int ReadUInt24BigEndian(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> SkipBytes(ReadOnlySpan`1<byte> bytes, int numberOfBytesToSkip);
    private static ReadOnlySpan`1<byte> SkipOpaqueType1(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> SkipOpaqueType2(ReadOnlySpan`1<byte> bytes);
}
internal enum System.Net.Security.TlsHandshakeType : Enum {
    public byte value__;
    public static TlsHandshakeType HelloRequest;
    public static TlsHandshakeType ClientHello;
    public static TlsHandshakeType ServerHello;
    public static TlsHandshakeType NewSessionTicket;
    public static TlsHandshakeType EndOfEarlyData;
    public static TlsHandshakeType EncryptedExtensions;
    public static TlsHandshakeType Certificate;
    public static TlsHandshakeType ServerKeyExchange;
    public static TlsHandshakeType CertificateRequest;
    public static TlsHandshakeType ServerHelloDone;
    public static TlsHandshakeType CertificateVerify;
    public static TlsHandshakeType ClientKeyExchange;
    public static TlsHandshakeType Finished;
    public static TlsHandshakeType KeyUpdate;
    public static TlsHandshakeType MessageHash;
}
internal class System.Net.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
}
internal class System.Net.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
    public virtual string ToString();
}
internal static class System.Net.SecurityStatusAdapterPal : object {
    private static BidirectionalDictionary`2<SECURITY_STATUS, SecurityStatusPalErrorCode> s_statusDictionary;
    private static SecurityStatusAdapterPal();
    internal static SecurityStatusPal GetSecurityStatusPalFromNativeInt(int win32SecurityStatus);
    internal static SecurityStatusPal GetSecurityStatusPalFromInterop(SECURITY_STATUS win32SecurityStatus, bool attachException);
    internal static SECURITY_STATUS GetInteropFromSecurityStatusPal(SecurityStatusPal status);
}
[IsReadOnlyAttribute]
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode TryAgain;
    public static SecurityStatusPalErrorCode HandshakeStarted;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode DecryptFailure;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
    public static SecurityStatusPalErrorCode DowngradeDetected;
    public static SecurityStatusPalErrorCode ApplicationProtocolMismatch;
    public static SecurityStatusPalErrorCode NoRenegotiation;
    public static SecurityStatusPalErrorCode KeySetDoesNotExist;
    public static SecurityStatusPalErrorCode ContextExpiredError;
}
internal class System.Net.SslStreamContext : TransportContext {
    private SslStream _sslStream;
    internal SslStreamContext(SslStream sslStream);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.SSPIAuthType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED* authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCH_CREDENTIALS* authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteSslContext& context, InputSecurityBuffers inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteSslContext& context, string targetName, ContextFlags inFlags, Endianness endianness, InputSecurityBuffers inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 qop);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32& qop);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext context, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& binding);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public int CompleteAuthToken(SafeDeleteSslContext& refContext, InputSecurityBuffer& inputBuffer);
    private static int GetSecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& safeHandle);
    public int ApplyControlToken(SafeDeleteSslContext& refContext, SecurityBuffer& inputBuffers);
    private sealed virtual override int System.Net.ISSPIInterface.CompleteAuthToken(SafeDeleteSslContext& refContext, InputSecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
    private sealed virtual override int System.Net.ISSPIInterface.ApplyControlToken(SafeDeleteSslContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal class System.Net.SSPISecureChannelType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED* authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCH_CREDENTIALS* authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteSslContext& context, InputSecurityBuffers inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteSslContext& context, string targetName, ContextFlags inFlags, Endianness endianness, InputSecurityBuffers inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 qop);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32& qop);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public int CompleteAuthToken(SafeDeleteSslContext& refContext, InputSecurityBuffer& inputBuffer);
    public int ApplyControlToken(SafeDeleteSslContext& refContext, SecurityBuffer& inputBuffer);
    private sealed virtual override int System.Net.ISSPIInterface.CompleteAuthToken(SafeDeleteSslContext& refContext, InputSecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
    private sealed virtual override int System.Net.ISSPIInterface.ApplyControlToken(SafeDeleteSslContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal static class System.Net.SSPIWrapper : object {
    internal static SecurityPackageInfoClass[] EnumerateSecurityPackages(ISSPIInterface secModule);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(ISSPIInterface secModule, string packageName, bool throwIfMissing);
    public static SafeFreeCredentials AcquireDefaultCredential(ISSPIInterface secModule, string package, CredentialUse intent);
    public static SafeFreeCredentials AcquireCredentialsHandle(ISSPIInterface secModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(ISSPIInterface secModule, string package, CredentialUse intent, SCHANNEL_CRED* scc);
    public static SafeFreeCredentials AcquireCredentialsHandle(ISSPIInterface secModule, string package, CredentialUse intent, SCH_CREDENTIALS* scc);
    internal static int InitializeSecurityContext(ISSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteSslContext& context, string targetName, ContextFlags inFlags, Endianness datarep, InputSecurityBuffers inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(ISSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteSslContext& context, ContextFlags inFlags, Endianness datarep, InputSecurityBuffers inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(ISSPIInterface secModule, SafeDeleteSslContext& context, InputSecurityBuffer& inputBuffer);
    internal static int ApplyControlToken(ISSPIInterface secModule, SafeDeleteSslContext& context, SecurityBuffer& inputBuffer);
    public static int QuerySecurityContextToken(ISSPIInterface secModule, SafeDeleteContext context, SecurityContextTokenHandle& token);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(ISSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static bool QueryBlittableContextAttributes(ISSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, T& attribute);
    public static bool QueryBlittableContextAttributes(ISSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, Type safeHandleType, SafeHandle& sspiHandle, T& attribute);
    public static string QueryStringContextAttributes(ISSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    private static bool QueryCertContextAttribute(ISSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute attribute, SafeFreeCertContext& certContext);
    public static bool QueryContextAttributes_SECPKG_ATTR_REMOTE_CERT_CONTEXT(ISSPIInterface secModule, SafeDeleteContext securityContext, SafeFreeCertContext& certContext);
    public static bool QueryContextAttributes_SECPKG_ATTR_LOCAL_CERT_CONTEXT(ISSPIInterface secModule, SafeDeleteContext securityContext, SafeFreeCertContext& certContext);
    public static bool QueryContextAttributes_SECPKG_ATTR_REMOTE_CERT_CHAIN(ISSPIInterface secModule, SafeDeleteContext securityContext, SafeFreeCertContext& certContext);
    public static bool QueryContextAttributes_SECPKG_ATTR_ISSUER_LIST_EX(ISSPIInterface secModule, SafeDeleteContext securityContext, SecPkgContext_IssuerListInfoEx& ctx, SafeHandle& sspiHandle);
    public static string ErrorDescription(int errorCode);
}
internal class System.Net.StreamFramer : object {
    private FrameHeader _writeHeader;
    private FrameHeader _curReadHeader;
    private Byte[] _readHeaderBuffer;
    private Byte[] _writeHeaderBuffer;
    private bool _eof;
    public FrameHeader ReadHeader { get; }
    public FrameHeader WriteHeader { get; }
    public FrameHeader get_ReadHeader();
    public FrameHeader get_WriteHeader();
    [AsyncStateMachineAttribute("System.Net.StreamFramer/<ReadMessageAsync>d__9`1")]
public ValueTask`1<Byte[]> ReadMessageAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.StreamFramer/<WriteMessageAsync>d__10`1")]
public Task WriteMessageAsync(Stream stream, Byte[] message, CancellationToken cancellationToken);
}
internal class System.Net.StreamSizes : ValueType {
    [CompilerGeneratedAttribute]
private int <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Trailer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumMessage>k__BackingField;
    public int Header { get; private set; }
    public int Trailer { get; private set; }
    public int MaximumMessage { get; private set; }
    public StreamSizes(SecPkgContext_StreamSizes interopStreamSizes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Trailer();
    [CompilerGeneratedAttribute]
private void set_Trailer(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaximumMessage();
    [CompilerGeneratedAttribute]
private void set_MaximumMessage(int value);
}
internal static class System.Net.UnmanagedCertificateContext : object {
    internal static void GetRemoteCertificatesFromStoreContext(SafeFreeCertContext certContext, X509Certificate2Collection collection);
    internal static void GetRemoteCertificatesFromStoreContext(IntPtr certContext, X509Certificate2Collection result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Authentication.AuthenticationException : SystemException {
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    private ServiceNameCollection _customServiceNames;
    private PolicyEnforcement _policyEnforcement;
    private ProtectionScenario _protectionScenario;
    private ChannelBinding _customChannelBinding;
    public ServiceNameCollection CustomServiceNames { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    public ChannelBinding CustomChannelBinding { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    [NullableContextAttribute("1")]
public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ExtendedProtectionPolicy(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public ServiceNameCollection get_CustomServiceNames();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    public ChannelBinding get_CustomChannelBinding();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool get_OSSupportsExtendedProtection();
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
    public static PolicyEnforcement Always;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
    public ServiceNameCollection(ICollection items);
    private ServiceNameCollection(IList list, string serviceName);
    private ServiceNameCollection(IList list, IEnumerable serviceNames);
    private ServiceNameCollection(IList list, int additionalCapacity);
    [NullableContextAttribute("2")]
public bool Contains(string searchServiceName);
    public ServiceNameCollection Merge(string serviceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    private void AddIfNew(IEnumerable serviceNames, bool expectStrings);
    private void AddIfNew(List`1<string> serviceNames);
    private void AddIfNew(IList serviceNames);
    private void AddIfNew(string serviceName);
    private static int GetCountOrOne(IEnumerable collection);
    private static string NormalizeServiceName(string inputServiceName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_noseek { get; }
    internal static string net_securitypackagesupport { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string net_io_invalidnestedcall { get; }
    internal static string net_io_must_be_rw_stream { get; }
    internal static string net_io_header_id { get; }
    internal static string net_io_encrypt { get; }
    internal static string net_io_decrypt { get; }
    internal static string net_io_read { get; }
    internal static string net_io_write { get; }
    internal static string net_io_eof { get; }
    internal static string net_log_listener_no_spns { get; }
    internal static string net_log_listener_no_spn_kerberos { get; }
    internal static string net_log_listener_no_spn_disabled { get; }
    internal static string net_log_listener_no_spn_cbt { get; }
    internal static string net_log_listener_no_spn_whensupported { get; }
    internal static string net_log_listener_spn { get; }
    internal static string net_log_listener_spn_passed { get; }
    internal static string net_log_listener_spn_failed { get; }
    internal static string net_log_listener_spn_failed_always { get; }
    internal static string net_log_listener_spn_failed_empty { get; }
    internal static string net_log_listener_spn_failed_dump { get; }
    internal static string net_ssl_io_frame { get; }
    internal static string net_ssl_io_renego { get; }
    internal static string net_ssl_io_cert_validation { get; }
    internal static string net_ssl_io_cert_chain_validation { get; }
    internal static string net_ssl_io_cert_custom_validation { get; }
    internal static string net_ssl_io_no_server_cert { get; }
    internal static string net_ssl_io_already_shutdown { get; }
    internal static string net_auth_bad_client_creds { get; }
    internal static string net_auth_bad_client_creds_or_target_mismatch { get; }
    internal static string net_auth_context_expectation { get; }
    internal static string net_auth_context_expectation_remote { get; }
    internal static string net_auth_supported_impl_levels { get; }
    internal static string net_auth_reauth { get; }
    internal static string net_auth_noauth { get; }
    internal static string net_auth_client_server { get; }
    internal static string net_auth_SSPI { get; }
    internal static string net_auth_eof { get; }
    internal static string net_auth_tls_alert { get; }
    internal static string net_auth_alert { get; }
    internal static string net_auth_ephemeral { get; }
    internal static string net_auth_message_not_encrypted { get; }
    internal static string net_auth_must_specify_extended_protection_scheme { get; }
    internal static string net_frame_size { get; }
    internal static string net_frame_read_size { get; }
    internal static string net_frame_max_size { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_log_open_store_failed { get; }
    internal static string net_log_remote_cert_has_errors { get; }
    internal static string net_log_remote_cert_not_available { get; }
    internal static string net_log_remote_cert_name_mismatch { get; }
    internal static string net_log_operation_failed_with_error { get; }
    internal static string SSPIInvalidHandleType { get; }
    internal static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever { get; }
    internal static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection { get; }
    internal static string net_ssl_app_protocols_invalid { get; }
    internal static string net_ssl_app_protocol_invalid { get; }
    internal static string net_conflicting_options { get; }
    internal static string net_ssl_ciphersuites_policy_not_supported { get; }
    internal static string net_ssl_certificate_exist { get; }
    internal static string net_ssl_renegotiate_data { get; }
    internal static string net_ssl_renegotiate_buffer { get; }
    internal static string net_ssl_trust_store { get; }
    internal static string net_ssl_trust_collection { get; }
    internal static string net_ssl_trust_handshake { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_noseek();
    internal static string get_net_securitypackagesupport();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_net_io_invalidnestedcall();
    internal static string get_net_io_must_be_rw_stream();
    internal static string get_net_io_header_id();
    internal static string get_net_io_encrypt();
    internal static string get_net_io_decrypt();
    internal static string get_net_io_read();
    internal static string get_net_io_write();
    internal static string get_net_io_eof();
    internal static string get_net_log_listener_no_spns();
    internal static string get_net_log_listener_no_spn_kerberos();
    internal static string get_net_log_listener_no_spn_disabled();
    internal static string get_net_log_listener_no_spn_cbt();
    internal static string get_net_log_listener_no_spn_whensupported();
    internal static string get_net_log_listener_spn();
    internal static string get_net_log_listener_spn_passed();
    internal static string get_net_log_listener_spn_failed();
    internal static string get_net_log_listener_spn_failed_always();
    internal static string get_net_log_listener_spn_failed_empty();
    internal static string get_net_log_listener_spn_failed_dump();
    internal static string get_net_ssl_io_frame();
    internal static string get_net_ssl_io_renego();
    internal static string get_net_ssl_io_cert_validation();
    internal static string get_net_ssl_io_cert_chain_validation();
    internal static string get_net_ssl_io_cert_custom_validation();
    internal static string get_net_ssl_io_no_server_cert();
    internal static string get_net_ssl_io_already_shutdown();
    internal static string get_net_auth_bad_client_creds();
    internal static string get_net_auth_bad_client_creds_or_target_mismatch();
    internal static string get_net_auth_context_expectation();
    internal static string get_net_auth_context_expectation_remote();
    internal static string get_net_auth_supported_impl_levels();
    internal static string get_net_auth_reauth();
    internal static string get_net_auth_noauth();
    internal static string get_net_auth_client_server();
    internal static string get_net_auth_SSPI();
    internal static string get_net_auth_eof();
    internal static string get_net_auth_tls_alert();
    internal static string get_net_auth_alert();
    internal static string get_net_auth_ephemeral();
    internal static string get_net_auth_message_not_encrypted();
    internal static string get_net_auth_must_specify_extended_protection_scheme();
    internal static string get_net_frame_size();
    internal static string get_net_frame_read_size();
    internal static string get_net_frame_max_size();
    internal static string get_net_invalid_enum();
    internal static string get_net_log_open_store_failed();
    internal static string get_net_log_remote_cert_has_errors();
    internal static string get_net_log_remote_cert_not_available();
    internal static string get_net_log_remote_cert_name_mismatch();
    internal static string get_net_log_operation_failed_with_error();
    internal static string get_SSPIInvalidHandleType();
    internal static string get_security_ExtendedProtectionPolicy_UseDifferentConstructorForNever();
    internal static string get_security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection();
    internal static string get_net_ssl_app_protocols_invalid();
    internal static string get_net_ssl_app_protocol_invalid();
    internal static string get_net_conflicting_options();
    internal static string get_net_ssl_ciphersuites_policy_not_supported();
    internal static string get_net_ssl_certificate_exist();
    internal static string get_net_ssl_renegotiate_data();
    internal static string get_net_ssl_renegotiate_buffer();
    internal static string get_net_ssl_trust_store();
    internal static string get_net_ssl_trust_collection();
    internal static string get_net_ssl_trust_handshake();
}
