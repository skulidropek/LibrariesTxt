internal static class FxResources.System.Security.AccessControl.SR : object {
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeTokenHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeTokenHandle(IntPtr handle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
}
[FlagsAttribute]
public enum System.Security.AccessControl.AccessControlActions : Enum {
    public int value__;
    public static AccessControlActions None;
    public static AccessControlActions View;
    public static AccessControlActions Change;
}
public enum System.Security.AccessControl.AccessControlModification : Enum {
    public int value__;
    public static AccessControlModification Add;
    public static AccessControlModification Set;
    public static AccessControlModification Reset;
    public static AccessControlModification Remove;
    public static AccessControlModification RemoveAll;
    public static AccessControlModification RemoveSpecific;
}
[FlagsAttribute]
public enum System.Security.AccessControl.AccessControlSections : Enum {
    public int value__;
    public static AccessControlSections None;
    public static AccessControlSections Audit;
    public static AccessControlSections Access;
    public static AccessControlSections Owner;
    public static AccessControlSections Group;
    public static AccessControlSections All;
}
public enum System.Security.AccessControl.AccessControlType : Enum {
    public int value__;
    public static AccessControlType Allow;
    public static AccessControlType Deny;
}
public abstract class System.Security.AccessControl.AccessRule : AuthorizationRule {
    private AccessControlType _type;
    public AccessControlType AccessControlType { get; }
    [NullableContextAttribute("1")]
protected AccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public AccessControlType get_AccessControlType();
}
public class System.Security.AccessControl.AccessRule`1 : AccessRule {
    public T Rights { get; }
    public AccessRule`1(IdentityReference identity, T rights, AccessControlType type);
    public AccessRule`1(string identity, T rights, AccessControlType type);
    public AccessRule`1(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public AccessRule`1(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    internal AccessRule`1(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public T get_Rights();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.AccessControl.AceEnumerator : object {
    private int _current;
    private GenericAcl _acl;
    private object System.Collections.IEnumerator.Current { get; }
    public GenericAce Current { get; }
    internal AceEnumerator(GenericAcl collection);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public GenericAce get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[FlagsAttribute]
public enum System.Security.AccessControl.AceFlags : Enum {
    public byte value__;
    public static AceFlags None;
    public static AceFlags ObjectInherit;
    public static AceFlags ContainerInherit;
    public static AceFlags NoPropagateInherit;
    public static AceFlags InheritOnly;
    public static AceFlags Inherited;
    public static AceFlags SuccessfulAccess;
    public static AceFlags FailedAccess;
    public static AceFlags InheritanceFlags;
    public static AceFlags AuditFlags;
}
public enum System.Security.AccessControl.AceQualifier : Enum {
    public int value__;
    public static AceQualifier AccessAllowed;
    public static AceQualifier AccessDenied;
    public static AceQualifier SystemAudit;
    public static AceQualifier SystemAlarm;
}
public enum System.Security.AccessControl.AceType : Enum {
    public byte value__;
    public static AceType AccessAllowed;
    public static AceType AccessDenied;
    public static AceType SystemAudit;
    public static AceType SystemAlarm;
    public static AceType AccessAllowedCompound;
    public static AceType AccessAllowedObject;
    public static AceType AccessDeniedObject;
    public static AceType SystemAuditObject;
    public static AceType SystemAlarmObject;
    public static AceType AccessAllowedCallback;
    public static AceType AccessDeniedCallback;
    public static AceType AccessAllowedCallbackObject;
    public static AceType AccessDeniedCallbackObject;
    public static AceType SystemAuditCallback;
    public static AceType SystemAlarmCallback;
    public static AceType SystemAuditCallbackObject;
    public static AceType SystemAlarmCallbackObject;
    public static AceType MaxDefinedAceType;
}
[FlagsAttribute]
public enum System.Security.AccessControl.AuditFlags : Enum {
    public int value__;
    public static AuditFlags None;
    public static AuditFlags Success;
    public static AuditFlags Failure;
}
public abstract class System.Security.AccessControl.AuditRule : AuthorizationRule {
    private AuditFlags _flags;
    public AuditFlags AuditFlags { get; }
    [NullableContextAttribute("1")]
protected AuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
    public AuditFlags get_AuditFlags();
}
public class System.Security.AccessControl.AuditRule`1 : AuditRule {
    public T Rights { get; }
    public AuditRule`1(IdentityReference identity, T rights, AuditFlags flags);
    public AuditRule`1(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public AuditRule`1(string identity, T rights, AuditFlags flags);
    public AuditRule`1(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    internal AuditRule`1(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    public T get_Rights();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.AuthorizationRule : object {
    private IdentityReference _identity;
    private int _accessMask;
    private bool _isInherited;
    private InheritanceFlags _inheritanceFlags;
    private PropagationFlags _propagationFlags;
    public IdentityReference IdentityReference { get; }
    protected internal int AccessMask { get; }
    public bool IsInherited { get; }
    public InheritanceFlags InheritanceFlags { get; }
    public PropagationFlags PropagationFlags { get; }
    protected internal AuthorizationRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public IdentityReference get_IdentityReference();
    protected internal int get_AccessMask();
    public bool get_IsInherited();
    public InheritanceFlags get_InheritanceFlags();
    public PropagationFlags get_PropagationFlags();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.AccessControl.AuthorizationRuleCollection : ReadOnlyCollectionBase {
    public AuthorizationRule Item { get; }
    public void AddRule(AuthorizationRule rule);
    [NullableContextAttribute("1")]
public void CopyTo(AuthorizationRule[] rules, int index);
    public AuthorizationRule get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.AccessControl.CommonAce : QualifiedAce {
    public int BinaryLength { get; }
    internal int MaxOpaqueLengthInternal { get; }
    public CommonAce(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, Byte[] opaque);
    private static AceType TypeFromQualifier(bool isCallback, AceQualifier qualifier);
    internal static bool ParseBinaryForm(Byte[] binaryForm, int offset, AceQualifier& qualifier, Int32& accessMask, SecurityIdentifier& sid, Boolean& isCallback, Byte[]& opaque);
    public virtual int get_BinaryLength();
    public static int MaxOpaqueLength(bool isCallback);
    internal virtual int get_MaxOpaqueLengthInternal();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Security.AccessControl.CommonAcl : GenericAcl {
    private static PM[] s_AFtoPM;
    private static AF[] s_PMtoAF;
    private RawAcl _acl;
    private bool _isDirty;
    private bool _isCanonical;
    private bool _isContainer;
    private bool _isDS;
    internal RawAcl RawAcl { get; }
    public byte Revision { get; }
    public int Count { get; }
    public int BinaryLength { get; }
    public bool IsCanonical { get; }
    public bool IsContainer { get; }
    public bool IsDS { get; }
    public GenericAce Item { get; public set; }
    internal CommonAcl(bool isContainer, bool isDS, byte revision, int capacity);
    internal CommonAcl(bool isContainer, bool isDS, RawAcl rawAcl, bool trusted, bool isDacl);
    private static CommonAcl();
    private static PM[] CreateAFtoPMConversionMatrix();
    private static AF[] CreatePMtoAFConversionMatrix();
    private static AF AFFromAceFlags(AceFlags aceFlags, bool isDS);
    private static AceFlags AceFlagsFromAF(AF af, bool isDS);
    private static bool MergeInheritanceBits(AceFlags left, AceFlags right, bool isDS, AceFlags& result);
    private static bool RemoveInheritanceBits(AceFlags existing, AceFlags remove, bool isDS, AceFlags& result, Boolean& total);
    private void CanonicalizeIfNecessary();
    private static int DaclAcePriority(GenericAce ace);
    private static int SaclAcePriority(GenericAce ace);
    private static ComparisonResult CompareAces(GenericAce ace1, GenericAce ace2, bool isDacl);
    private void QuickSort(int left, int right, bool isDacl);
    private bool InspectAce(GenericAce& ace, bool isDacl);
    private void RemoveMeaninglessAcesAndFlags(bool isDacl);
    private void Canonicalize(bool compact, bool isDacl);
    private static void GetObjectTypesForSplit(ObjectAce originalAce, int accessMask, AceFlags aceFlags, ObjectAceFlags& objectFlags, Guid& objectType, Guid& inheritedObjectType);
    private static bool ObjectTypesMatch(QualifiedAce ace, QualifiedAce newAce);
    private static bool InheritedObjectTypesMatch(QualifiedAce ace, QualifiedAce newAce);
    private static bool AccessMasksAreMergeable(QualifiedAce ace, QualifiedAce newAce);
    private static bool AceFlagsAreMergeable(QualifiedAce ace, QualifiedAce newAce);
    private static bool GetAccessMaskForRemoval(QualifiedAce ace, ObjectAceFlags objectFlags, Guid objectType, Int32& accessMask);
    private static bool GetInheritanceFlagsForRemoval(QualifiedAce ace, ObjectAceFlags objectFlags, Guid inheritedObjectType, AceFlags& aceFlags);
    private static bool AceOpaquesMatch(QualifiedAce ace, QualifiedAce newAce);
    private static bool AcesAreMergeable(QualifiedAce ace, QualifiedAce newAce);
    private bool MergeAces(QualifiedAce& ace, QualifiedAce newAce);
    private bool CanonicalCheck(bool isDacl);
    private void ThrowIfNotCanonical();
    internal RawAcl get_RawAcl();
    internal static void CheckAccessType(AccessControlType accessType);
    internal void CheckFlags(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    internal void AddQualifiedAce(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal void SetQualifiedAce(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal bool RemoveQualifiedAces(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, bool saclSemantics, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal void RemoveQualifiedAcesSpecific(SecurityIdentifier sid, AceQualifier qualifier, int accessMask, AceFlags flags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal virtual void OnAclModificationTried();
    public sealed virtual byte get_Revision();
    public sealed virtual int get_Count();
    public sealed virtual int get_BinaryLength();
    public bool get_IsCanonical();
    public bool get_IsContainer();
    public bool get_IsDS();
    public sealed virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public sealed virtual GenericAce get_Item(int index);
    public sealed virtual void set_Item(int index, GenericAce value);
    public void RemoveInheritedAces();
    public void Purge(SecurityIdentifier sid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.CommonObjectSecurity : ObjectSecurity {
    protected CommonObjectSecurity(bool isContainer);
    internal CommonObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    private static bool IsValidTargetTypeStatic(Type targetType);
    private AuthorizationRuleCollection GetRules(bool access, bool includeExplicit, bool includeInherited, Type targetType);
    private static bool AceNeedsTranslation(CommonAce ace, bool isAccessAce, bool includeExplicit, bool includeInherited);
    protected virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
    protected void AddAccessRule(AccessRule rule);
    protected void SetAccessRule(AccessRule rule);
    protected void ResetAccessRule(AccessRule rule);
    protected bool RemoveAccessRule(AccessRule rule);
    protected void RemoveAccessRuleAll(AccessRule rule);
    protected void RemoveAccessRuleSpecific(AccessRule rule);
    protected void AddAuditRule(AuditRule rule);
    protected void SetAuditRule(AuditRule rule);
    protected bool RemoveAuditRule(AuditRule rule);
    protected void RemoveAuditRuleAll(AuditRule rule);
    protected void RemoveAuditRuleSpecific(AuditRule rule);
    public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
    public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.AccessControl.CommonSecurityDescriptor : GenericSecurityDescriptor {
    private bool _isContainer;
    private bool _isDS;
    private RawSecurityDescriptor _rawSd;
    private SystemAcl _sacl;
    private DiscretionaryAcl _dacl;
    internal GenericAcl GenericSacl { get; }
    internal GenericAcl GenericDacl { get; }
    public bool IsContainer { get; }
    public bool IsDS { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public SystemAcl SystemAcl { get; public set; }
    public DiscretionaryAcl DiscretionaryAcl { get; public set; }
    public bool IsSystemAclCanonical { get; }
    public bool IsDiscretionaryAclCanonical { get; }
    internal bool IsSystemAclPresent { get; }
    internal bool IsDiscretionaryAclPresent { get; }
    public CommonSecurityDescriptor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
    [NullableContextAttribute("1")]
public CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
    internal CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor, bool trusted);
    [NullableContextAttribute("1")]
public CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
    [NullableContextAttribute("1")]
public CommonSecurityDescriptor(bool isContainer, bool isDS, Byte[] binaryForm, int offset);
    [MemberNotNullAttribute("_rawSd")]
private void CreateFromParts(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
    internal sealed virtual GenericAcl get_GenericSacl();
    internal sealed virtual GenericAcl get_GenericDacl();
    public bool get_IsContainer();
    public bool get_IsDS();
    public virtual ControlFlags get_ControlFlags();
    public virtual SecurityIdentifier get_Owner();
    public virtual void set_Owner(SecurityIdentifier value);
    public virtual SecurityIdentifier get_Group();
    public virtual void set_Group(SecurityIdentifier value);
    public SystemAcl get_SystemAcl();
    public void set_SystemAcl(SystemAcl value);
    public DiscretionaryAcl get_DiscretionaryAcl();
    public void set_DiscretionaryAcl(DiscretionaryAcl value);
    public bool get_IsSystemAclCanonical();
    public bool get_IsDiscretionaryAclCanonical();
    public void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
    public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
    [NullableContextAttribute("1")]
public void PurgeAccessControl(SecurityIdentifier sid);
    [NullableContextAttribute("1")]
public void PurgeAudit(SecurityIdentifier sid);
    public void AddDiscretionaryAcl(byte revision, int trusted);
    public void AddSystemAcl(byte revision, int trusted);
    internal void UpdateControlFlags(ControlFlags flagsToUpdate, ControlFlags newFlags);
    internal void AddControlFlags(ControlFlags flags);
    internal void RemoveControlFlags(ControlFlags flags);
    internal bool get_IsSystemAclPresent();
    internal bool get_IsDiscretionaryAclPresent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.AccessControl.CompoundAce : KnownAce {
    private CompoundAceType _compoundAceType;
    public CompoundAceType CompoundAceType { get; public set; }
    public int BinaryLength { get; }
    public CompoundAce(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid);
    internal static bool ParseBinaryForm(Byte[] binaryForm, int offset, Int32& accessMask, CompoundAceType& compoundAceType, SecurityIdentifier& sid);
    public CompoundAceType get_CompoundAceType();
    public void set_CompoundAceType(CompoundAceType value);
    public virtual int get_BinaryLength();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
public enum System.Security.AccessControl.CompoundAceType : Enum {
    public int value__;
    public static CompoundAceType Impersonation;
}
[FlagsAttribute]
public enum System.Security.AccessControl.ControlFlags : Enum {
    public int value__;
    public static ControlFlags None;
    public static ControlFlags OwnerDefaulted;
    public static ControlFlags GroupDefaulted;
    public static ControlFlags DiscretionaryAclPresent;
    public static ControlFlags DiscretionaryAclDefaulted;
    public static ControlFlags SystemAclPresent;
    public static ControlFlags SystemAclDefaulted;
    public static ControlFlags DiscretionaryAclUntrusted;
    public static ControlFlags ServerSecurity;
    public static ControlFlags DiscretionaryAclAutoInheritRequired;
    public static ControlFlags SystemAclAutoInheritRequired;
    public static ControlFlags DiscretionaryAclAutoInherited;
    public static ControlFlags SystemAclAutoInherited;
    public static ControlFlags DiscretionaryAclProtected;
    public static ControlFlags SystemAclProtected;
    public static ControlFlags RMControlValid;
    public static ControlFlags SelfRelative;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.AccessControl.CustomAce : GenericAce {
    private Byte[] _opaque;
    public static int MaxOpaqueLength;
    public int OpaqueLength { get; }
    public int BinaryLength { get; }
    public CustomAce(AceType type, AceFlags flags, Byte[] opaque);
    private static CustomAce();
    public int get_OpaqueLength();
    public virtual int get_BinaryLength();
    public Byte[] GetOpaque();
    public void SetOpaque(Byte[] opaque);
    [NullableContextAttribute("1")]
public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.AccessControl.DiscretionaryAcl : CommonAcl {
    private static SecurityIdentifier _sidEveryone;
    private bool everyOneFullAccessForNullDacl;
    internal bool EveryOneFullAccessForNullDacl { get; internal set; }
    public DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
    public DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
    [NullableContextAttribute("2")]
public DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    internal DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl, bool trusted);
    private static DiscretionaryAcl();
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
    public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    internal bool get_EveryOneFullAccessForNullDacl();
    internal void set_EveryOneFullAccessForNullDacl(bool value);
    internal virtual void OnAclModificationTried();
    internal static DiscretionaryAcl CreateAllowEveryoneFullAccess(bool isDS, bool isContainer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.GenericAce : object {
    private AceType _type;
    private AceFlags _flags;
    internal ushort _indexInAcl;
    public AceType AceType { get; }
    public AceFlags AceFlags { get; public set; }
    public bool IsInherited { get; }
    public InheritanceFlags InheritanceFlags { get; }
    public PropagationFlags PropagationFlags { get; }
    public AuditFlags AuditFlags { get; }
    public int BinaryLength { get; }
    internal GenericAce(AceType type, AceFlags flags);
    internal void MarshalHeader(Byte[] binaryForm, int offset);
    internal static AceFlags AceFlagsFromAuditFlags(AuditFlags auditFlags);
    internal static AceFlags AceFlagsFromInheritanceFlags(InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    internal static void VerifyHeader(Byte[] binaryForm, int offset);
    public static GenericAce CreateFromBinaryForm(Byte[] binaryForm, int offset);
    public AceType get_AceType();
    public AceFlags get_AceFlags();
    public void set_AceFlags(AceFlags value);
    public bool get_IsInherited();
    public InheritanceFlags get_InheritanceFlags();
    public PropagationFlags get_PropagationFlags();
    public AuditFlags get_AuditFlags();
    public abstract virtual int get_BinaryLength();
    public abstract virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public GenericAce Copy();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object o);
    public sealed virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(GenericAce left, GenericAce right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(GenericAce left, GenericAce right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Security.AccessControl.GenericAcl : object {
    public static byte AclRevision;
    public static byte AclRevisionDS;
    public static int MaxBinaryLength;
    public byte Revision { get; }
    public int BinaryLength { get; }
    public GenericAce Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private static GenericAcl();
    public abstract virtual byte get_Revision();
    public abstract virtual int get_BinaryLength();
    public abstract virtual GenericAce get_Item(int index);
    public abstract virtual void set_Item(int index, GenericAce value);
    public abstract virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(GenericAce[] array, int index);
    public abstract virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public AceEnumerator GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.GenericSecurityDescriptor : object {
    internal GenericAcl GenericSacl { get; }
    internal GenericAcl GenericDacl { get; }
    private bool IsCraftedAefaDacl { get; }
    public static byte Revision { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public int BinaryLength { get; }
    private static void MarshalInt(Byte[] binaryForm, int offset, int number);
    internal static int UnmarshalInt(Byte[] binaryForm, int offset);
    internal abstract virtual GenericAcl get_GenericSacl();
    internal abstract virtual GenericAcl get_GenericDacl();
    private bool get_IsCraftedAefaDacl();
    public static bool IsSddlConversionSupported();
    public static byte get_Revision();
    public abstract virtual ControlFlags get_ControlFlags();
    public abstract virtual SecurityIdentifier get_Owner();
    public abstract virtual void set_Owner(SecurityIdentifier value);
    public abstract virtual SecurityIdentifier get_Group();
    public abstract virtual void set_Group(SecurityIdentifier value);
    public int get_BinaryLength();
    [NullableContextAttribute("1")]
public string GetSddlForm(AccessControlSections includeSections);
    [NullableContextAttribute("1")]
public void GetBinaryForm(Byte[] binaryForm, int offset);
}
[FlagsAttribute]
public enum System.Security.AccessControl.InheritanceFlags : Enum {
    public int value__;
    public static InheritanceFlags None;
    public static InheritanceFlags ContainerInherit;
    public static InheritanceFlags ObjectInherit;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.KnownAce : GenericAce {
    private int _accessMask;
    private SecurityIdentifier _sid;
    public int AccessMask { get; public set; }
    public SecurityIdentifier SecurityIdentifier { get; public set; }
    internal KnownAce(AceType type, AceFlags flags, int accessMask, SecurityIdentifier securityIdentifier);
    public int get_AccessMask();
    public void set_AccessMask(int value);
    public SecurityIdentifier get_SecurityIdentifier();
    [MemberNotNullAttribute("_sid")]
public void set_SecurityIdentifier(SecurityIdentifier value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.NativeObjectSecurity : CommonObjectSecurity {
    private ResourceType _resourceType;
    private ExceptionFromErrorCode _exceptionFromErrorCode;
    private object _exceptionContext;
    private UInt32 ProtectedDiscretionaryAcl;
    private UInt32 ProtectedSystemAcl;
    private UInt32 UnprotectedDiscretionaryAcl;
    private UInt32 UnprotectedSystemAcl;
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    internal NativeObjectSecurity(ResourceType resourceType, CommonSecurityDescriptor securityDescriptor, ExceptionFromErrorCode exceptionFromErrorCode);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections);
    private static CommonSecurityDescriptor CreateInternal(ResourceType resourceType, bool isContainer, string name, SafeHandle handle, AccessControlSections includeSections, bool createByName, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    private void Persist(string name, SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
    [NullableContextAttribute("1")]
protected sealed virtual void Persist(string name, AccessControlSections includeSections);
    [NullableContextAttribute("1")]
protected void Persist(string name, AccessControlSections includeSections, object exceptionContext);
    [NullableContextAttribute("1")]
protected sealed virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
    [NullableContextAttribute("1")]
protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
}
public abstract class System.Security.AccessControl.ObjectAccessRule : AccessRule {
    private Guid _objectType;
    private Guid _inheritedObjectType;
    private ObjectAceFlags _objectFlags;
    public Guid ObjectType { get; }
    public Guid InheritedObjectType { get; }
    public ObjectAceFlags ObjectFlags { get; }
    [NullableContextAttribute("1")]
protected ObjectAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type);
    public Guid get_ObjectType();
    public Guid get_InheritedObjectType();
    public ObjectAceFlags get_ObjectFlags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.AccessControl.ObjectAce : QualifiedAce {
    private ObjectAceFlags _objectFlags;
    private Guid _objectAceType;
    private Guid _inheritedObjectAceType;
    public ObjectAceFlags ObjectAceFlags { get; public set; }
    public Guid ObjectAceType { get; public set; }
    public Guid InheritedObjectAceType { get; public set; }
    public int BinaryLength { get; }
    internal int MaxOpaqueLengthInternal { get; }
    public ObjectAce(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, Byte[] opaque);
    private static AceType TypeFromQualifier(bool isCallback, AceQualifier qualifier);
    internal bool ObjectTypesMatch(ObjectAceFlags objectFlags, Guid objectType);
    internal bool InheritedObjectTypesMatch(ObjectAceFlags objectFlags, Guid inheritedObjectType);
    internal static bool ParseBinaryForm(Byte[] binaryForm, int offset, AceQualifier& qualifier, Int32& accessMask, SecurityIdentifier& sid, ObjectAceFlags& objectFlags, Guid& objectAceType, Guid& inheritedObjectAceType, Boolean& isCallback, Byte[]& opaque);
    public ObjectAceFlags get_ObjectAceFlags();
    public void set_ObjectAceFlags(ObjectAceFlags value);
    public Guid get_ObjectAceType();
    public void set_ObjectAceType(Guid value);
    public Guid get_InheritedObjectAceType();
    public void set_InheritedObjectAceType(Guid value);
    public virtual int get_BinaryLength();
    public static int MaxOpaqueLength(bool isCallback);
    internal virtual int get_MaxOpaqueLengthInternal();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
}
[FlagsAttribute]
public enum System.Security.AccessControl.ObjectAceFlags : Enum {
    public int value__;
    public static ObjectAceFlags None;
    public static ObjectAceFlags ObjectAceTypePresent;
    public static ObjectAceFlags InheritedObjectAceTypePresent;
}
public abstract class System.Security.AccessControl.ObjectAuditRule : AuditRule {
    private Guid _objectType;
    private Guid _inheritedObjectType;
    private ObjectAceFlags _objectFlags;
    public Guid ObjectType { get; }
    public Guid InheritedObjectType { get; }
    public ObjectAceFlags ObjectFlags { get; }
    [NullableContextAttribute("1")]
protected ObjectAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags);
    public Guid get_ObjectType();
    public Guid get_InheritedObjectType();
    public ObjectAceFlags get_ObjectFlags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.ObjectSecurity : object {
    private ReaderWriterLockSlim _lock;
    internal CommonSecurityDescriptor _securityDescriptor;
    private bool _ownerModified;
    private bool _groupModified;
    private bool _saclModified;
    private bool _daclModified;
    protected CommonSecurityDescriptor SecurityDescriptor { get; }
    protected bool OwnerModified { get; protected set; }
    protected bool GroupModified { get; protected set; }
    protected bool AuditRulesModified { get; protected set; }
    protected bool AccessRulesModified { get; protected set; }
    protected bool IsContainer { get; }
    protected bool IsDS { get; }
    public bool AreAccessRulesProtected { get; }
    public bool AreAuditRulesProtected { get; }
    public bool AreAccessRulesCanonical { get; }
    public bool AreAuditRulesCanonical { get; }
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    protected ObjectSecurity(bool isContainer, bool isDS);
    protected ObjectSecurity(CommonSecurityDescriptor securityDescriptor);
    private void UpdateWithNewSecurityDescriptor(RawSecurityDescriptor newOne, AccessControlSections includeSections);
    protected CommonSecurityDescriptor get_SecurityDescriptor();
    protected void ReadLock();
    protected void ReadUnlock();
    protected void WriteLock();
    protected void WriteUnlock();
    protected bool get_OwnerModified();
    protected void set_OwnerModified(bool value);
    protected bool get_GroupModified();
    protected void set_GroupModified(bool value);
    protected bool get_AuditRulesModified();
    protected void set_AuditRulesModified(bool value);
    protected bool get_AccessRulesModified();
    protected void set_AccessRulesModified(bool value);
    protected bool get_IsContainer();
    protected bool get_IsDS();
    protected virtual void Persist(string name, AccessControlSections includeSections);
    protected virtual void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections);
    protected virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
    public IdentityReference GetOwner(Type targetType);
    public void SetOwner(IdentityReference identity);
    public IdentityReference GetGroup(Type targetType);
    public void SetGroup(IdentityReference identity);
    public virtual void PurgeAccessRules(IdentityReference identity);
    public virtual void PurgeAuditRules(IdentityReference identity);
    public bool get_AreAccessRulesProtected();
    public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
    public bool get_AreAuditRulesProtected();
    public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
    public bool get_AreAccessRulesCanonical();
    public bool get_AreAuditRulesCanonical();
    public static bool IsSddlConversionSupported();
    public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections);
    public void SetSecurityDescriptorSddlForm(string sddlForm);
    public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections);
    public Byte[] GetSecurityDescriptorBinaryForm();
    public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm);
    public void SetSecurityDescriptorBinaryForm(Byte[] binaryForm, AccessControlSections includeSections);
    public abstract virtual Type get_AccessRightType();
    public abstract virtual Type get_AccessRuleType();
    public abstract virtual Type get_AuditRuleType();
    protected abstract virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected abstract virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
    public virtual bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, Boolean& modified);
    public virtual bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, Boolean& modified);
    public abstract virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public abstract virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.ObjectSecurity`1 : NativeObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    protected ObjectSecurity`1(bool isContainer, ResourceType resourceType);
    [NullableContextAttribute("2")]
protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
    [NullableContextAttribute("2")]
protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    [NullableContextAttribute("2")]
protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections);
    [NullableContextAttribute("2")]
protected ObjectSecurity`1(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    private AccessControlSections GetAccessControlSectionsFromChanges();
    protected internal void Persist(SafeHandle handle);
    protected internal void Persist(string name);
    public virtual void AddAccessRule(AccessRule`1<T> rule);
    public virtual void SetAccessRule(AccessRule`1<T> rule);
    public virtual void ResetAccessRule(AccessRule`1<T> rule);
    public virtual bool RemoveAccessRule(AccessRule`1<T> rule);
    public virtual void RemoveAccessRuleAll(AccessRule`1<T> rule);
    public virtual void RemoveAccessRuleSpecific(AccessRule`1<T> rule);
    public virtual void AddAuditRule(AuditRule`1<T> rule);
    public virtual void SetAuditRule(AuditRule`1<T> rule);
    public virtual bool RemoveAuditRule(AuditRule`1<T> rule);
    public virtual void RemoveAuditRuleAll(AuditRule`1<T> rule);
    public virtual void RemoveAuditRuleSpecific(AuditRule`1<T> rule);
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
}
internal class System.Security.AccessControl.Privilege : object {
    [ThreadStaticAttribute]
private static TlsContents t_tlsSlotData;
    private static Dictionary`2<LUID, string> privileges;
    private static Dictionary`2<string, LUID> luids;
    private static ReaderWriterLockSlim privilegeLock;
    private bool needToRevert;
    private bool initialState;
    private bool stateWasChanged;
    private LUID luid;
    private Thread currentThread;
    private TlsContents tlsContents;
    public bool NeedToRevert { get; }
    public Privilege(string privilegeName);
    private static Privilege();
    private static LUID LuidFromPrivilege(string privilege);
    protected virtual override void Finalize();
    public void Enable();
    public bool get_NeedToRevert();
    private void ToggleState(bool enable);
    public void Revert();
    private void Reset();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.AccessControl.PrivilegeNotHeldException : UnauthorizedAccessException {
    private string _privilegeName;
    public string PrivilegeName { get; }
    public PrivilegeNotHeldException(string privilege);
    public PrivilegeNotHeldException(string privilege, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private PrivilegeNotHeldException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_PrivilegeName();
}
[FlagsAttribute]
public enum System.Security.AccessControl.PropagationFlags : Enum {
    public int value__;
    public static PropagationFlags None;
    public static PropagationFlags NoPropagateInherit;
    public static PropagationFlags InheritOnly;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Security.AccessControl.QualifiedAce : KnownAce {
    private bool _isCallback;
    private AceQualifier _qualifier;
    private Byte[] _opaque;
    public AceQualifier AceQualifier { get; }
    public bool IsCallback { get; }
    internal int MaxOpaqueLengthInternal { get; }
    public int OpaqueLength { get; }
    internal QualifiedAce(AceType type, AceFlags flags, int accessMask, SecurityIdentifier sid, Byte[] opaque);
    private static AceQualifier QualifierFromType(AceType type, Boolean& isCallback);
    public AceQualifier get_AceQualifier();
    public bool get_IsCallback();
    internal abstract virtual int get_MaxOpaqueLengthInternal();
    public int get_OpaqueLength();
    public Byte[] GetOpaque();
    public void SetOpaque(Byte[] opaque);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Security.AccessControl.RawAcl : GenericAcl {
    private byte _revision;
    private List`1<GenericAce> _aces;
    public byte Revision { get; }
    public int Count { get; }
    public int BinaryLength { get; }
    public GenericAce Item { get; public set; }
    public RawAcl(byte revision, int capacity);
    public RawAcl(Byte[] binaryForm, int offset);
    private static void VerifyHeader(Byte[] binaryForm, int offset, Byte& revision, Int32& count, Int32& length);
    private void MarshalHeader(Byte[] binaryForm, int offset);
    [MemberNotNullAttribute("_aces")]
internal void SetBinaryForm(Byte[] binaryForm, int offset);
    public virtual byte get_Revision();
    public virtual int get_Count();
    public virtual int get_BinaryLength();
    public virtual void GetBinaryForm(Byte[] binaryForm, int offset);
    public virtual GenericAce get_Item(int index);
    public virtual void set_Item(int index, GenericAce value);
    public void InsertAce(int index, GenericAce ace);
    public void RemoveAce(int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.AccessControl.RawSecurityDescriptor : GenericSecurityDescriptor {
    private SecurityIdentifier _owner;
    private SecurityIdentifier _group;
    private ControlFlags _flags;
    private RawAcl _sacl;
    private RawAcl _dacl;
    private byte _rmControl;
    internal GenericAcl GenericSacl { get; }
    internal GenericAcl GenericDacl { get; }
    public ControlFlags ControlFlags { get; }
    public SecurityIdentifier Owner { get; public set; }
    public SecurityIdentifier Group { get; public set; }
    public RawAcl SystemAcl { get; public set; }
    public RawAcl DiscretionaryAcl { get; public set; }
    public byte ResourceManagerControl { get; public set; }
    public RawSecurityDescriptor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
    [NullableContextAttribute("1")]
public RawSecurityDescriptor(string sddlForm);
    [NullableContextAttribute("1")]
public RawSecurityDescriptor(Byte[] binaryForm, int offset);
    internal virtual GenericAcl get_GenericSacl();
    internal virtual GenericAcl get_GenericDacl();
    private void CreateFromParts(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
    private static Byte[] BinaryFormFromSddlForm(string sddlForm);
    public virtual ControlFlags get_ControlFlags();
    public virtual SecurityIdentifier get_Owner();
    public virtual void set_Owner(SecurityIdentifier value);
    public virtual SecurityIdentifier get_Group();
    public virtual void set_Group(SecurityIdentifier value);
    public RawAcl get_SystemAcl();
    public void set_SystemAcl(RawAcl value);
    public RawAcl get_DiscretionaryAcl();
    public void set_DiscretionaryAcl(RawAcl value);
    public byte get_ResourceManagerControl();
    public void set_ResourceManagerControl(byte value);
    public void SetFlags(ControlFlags flags);
}
public enum System.Security.AccessControl.ResourceType : Enum {
    public int value__;
    public static ResourceType Unknown;
    public static ResourceType FileObject;
    public static ResourceType Service;
    public static ResourceType Printer;
    public static ResourceType RegistryKey;
    public static ResourceType LMShare;
    public static ResourceType KernelObject;
    public static ResourceType WindowObject;
    public static ResourceType DSObject;
    public static ResourceType DSObjectAll;
    public static ResourceType ProviderDefined;
    public static ResourceType WmiGuidObject;
    public static ResourceType RegistryWow6432Key;
}
[FlagsAttribute]
public enum System.Security.AccessControl.SecurityInfos : Enum {
    public int value__;
    public static SecurityInfos Owner;
    public static SecurityInfos Group;
    public static SecurityInfos DiscretionaryAcl;
    public static SecurityInfos SystemAcl;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.AccessControl.SystemAcl : CommonAcl {
    public SystemAcl(bool isContainer, bool isDS, int capacity);
    public SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
    public SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl);
    internal SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl, bool trusted);
    public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
    public void AddAudit(SecurityIdentifier sid, ObjectAuditRule rule);
    public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void SetAudit(SecurityIdentifier sid, ObjectAuditRule rule);
    public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public bool RemoveAudit(SecurityIdentifier sid, ObjectAuditRule rule);
    public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
    public void RemoveAuditSpecific(SecurityIdentifier sid, ObjectAuditRule rule);
    public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
}
internal static class System.Security.AccessControl.Win32 : object {
    internal static int ConvertSdToSddl(Byte[] binaryForm, int requestedRevision, SecurityInfos si, String& resultSddl);
    internal static int GetSecurityInfo(ResourceType resourceType, string name, SafeHandle handle, AccessControlSections accessControlSections, RawSecurityDescriptor& resultSd);
    internal static int SetSecurityInfo(ResourceType type, string name, SafeHandle handle, SecurityInfos securityInformation, SecurityIdentifier owner, SecurityIdentifier group, GenericAcl sacl, GenericAcl dacl);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Policy.Evidence : object {
    [CompilerGeneratedAttribute]
private bool <Locked>k__BackingField;
    [ObsoleteAttribute("Evidence should not be treated as an ICollection. Use GetHostEnumerator and GetAssemblyEnumerator to iterate over the evidence to collect a count.")]
public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public bool Locked { get; public set; }
    public object SyncRoot { get; }
    [ObsoleteAttribute("This constructor is obsolete. Use the constructor which accepts arrays of EvidenceBase instead.")]
public Evidence(Object[] hostEvidence, Object[] assemblyEvidence);
    public Evidence(Evidence evidence);
    public Evidence(EvidenceBase[] hostEvidence, EvidenceBase[] assemblyEvidence);
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    [CompilerGeneratedAttribute]
public bool get_Locked();
    [CompilerGeneratedAttribute]
public void set_Locked(bool value);
    public sealed virtual object get_SyncRoot();
    [ObsoleteAttribute("Evidence.AddAssembly has been deprecated. Use AddAssemblyEvidence instead.")]
public void AddAssembly(object id);
    public void AddAssemblyEvidence(T evidence);
    public void AddHostEvidence(T evidence);
    [NullableContextAttribute("0")]
public T GetAssemblyEvidence();
    [NullableContextAttribute("0")]
public T GetHostEvidence();
    [ObsoleteAttribute("Evidence.AddHost has been deprecated. Use AddHostEvidence instead.")]
public void AddHost(object id);
    public void Clear();
    [NullableContextAttribute("2")]
public Evidence Clone();
    [ObsoleteAttribute("Evidence should not be treated as an ICollection. Use the GetHostEnumerator and GetAssemblyEnumerator methods rather than using CopyTo.")]
public sealed virtual void CopyTo(Array array, int index);
    public IEnumerator GetAssemblyEnumerator();
    [ObsoleteAttribute("GetEnumerator is obsolete. Use GetAssemblyEnumerator and GetHostEnumerator instead.")]
public sealed virtual IEnumerator GetEnumerator();
    public IEnumerator GetHostEnumerator();
    public void Merge(Evidence evidence);
    public void RemoveType(Type t);
}
public abstract class System.Security.Policy.EvidenceBase : object {
    [NullableContextAttribute("2")]
public virtual EvidenceBase Clone();
}
internal enum System.Security.Principal.TokenType : Enum {
    public int value__;
    public static TokenType TokenPrimary;
    public static TokenType TokenImpersonation;
}
internal static class System.Security.Principal.Win32 : object {
    internal static int OpenThreadToken(TokenAccessLevels dwDesiredAccess, WinSecurityContext dwOpenAs, SafeTokenHandle& phThreadToken);
    internal static int SetThreadToken(SafeTokenHandle hToken);
}
internal enum System.Security.Principal.WinSecurityContext : Enum {
    public int value__;
    public static WinSecurityContext Thread;
    public static WinSecurityContext Process;
    public static WinSecurityContext Both;
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string AccessControl_AclTooLong { get; }
    internal static string AccessControl_InvalidAccessRuleType { get; }
    internal static string AccessControl_InvalidAuditRuleType { get; }
    internal static string AccessControl_InvalidOwner { get; }
    internal static string AccessControl_InvalidGroup { get; }
    internal static string AccessControl_InvalidHandle { get; }
    internal static string AccessControl_InvalidSecurityDescriptorRevision { get; }
    internal static string AccessControl_InvalidSecurityDescriptorSelfRelativeForm { get; }
    internal static string AccessControl_InvalidSidInSDDLString { get; }
    internal static string AccessControl_MustSpecifyContainerAcl { get; }
    internal static string AccessControl_MustSpecifyDirectoryObjectAcl { get; }
    internal static string AccessControl_MustSpecifyLeafObjectAcl { get; }
    internal static string AccessControl_MustSpecifyNonDirectoryObjectAcl { get; }
    internal static string AccessControl_NoAssociatedSecurity { get; }
    internal static string AccessControl_UnexpectedError { get; }
    internal static string Arg_EnumAtLeastOneFlag { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidOperationException { get; }
    internal static string Arg_MustBeIdentityReferenceType { get; }
    internal static string Argument_ArgumentZero { get; }
    internal static string Argument_InvalidAnyFlag { get; }
    internal static string Argument_InvalidEnumValue { get; }
    internal static string Argument_InvalidName { get; }
    internal static string Argument_InvalidPrivilegeName { get; }
    internal static string Argument_InvalidSafeHandle { get; }
    internal static string ArgumentException_InvalidAceBinaryForm { get; }
    internal static string ArgumentException_InvalidAclBinaryForm { get; }
    internal static string ArgumentException_InvalidSDSddlForm { get; }
    internal static string ArgumentOutOfRange_ArrayLength { get; }
    internal static string ArgumentOutOfRange_ArrayLengthMultiple { get; }
    internal static string ArgumentOutOfRange_ArrayTooSmall { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_InvalidUserDefinedAceType { get; }
    internal static string InvalidOperation_ModificationOfNonCanonicalAcl { get; }
    internal static string InvalidOperation_MustBeSameThread { get; }
    internal static string InvalidOperation_MustLockForReadOrWrite { get; }
    internal static string InvalidOperation_MustLockForWrite { get; }
    internal static string InvalidOperation_MustRevertPrivilege { get; }
    internal static string InvalidOperation_NoSecurityDescriptor { get; }
    internal static string InvalidOperation_OnlyValidForDS { get; }
    internal static string InvalidOperation_DisconnectedPipe { get; }
    internal static string NotSupported_SetMethod { get; }
    internal static string PrivilegeNotHeld_Default { get; }
    internal static string PrivilegeNotHeld_Named { get; }
    internal static string Rank_MultiDimNotSupported { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_AccessControl_AclTooLong();
    internal static string get_AccessControl_InvalidAccessRuleType();
    internal static string get_AccessControl_InvalidAuditRuleType();
    internal static string get_AccessControl_InvalidOwner();
    internal static string get_AccessControl_InvalidGroup();
    internal static string get_AccessControl_InvalidHandle();
    internal static string get_AccessControl_InvalidSecurityDescriptorRevision();
    internal static string get_AccessControl_InvalidSecurityDescriptorSelfRelativeForm();
    internal static string get_AccessControl_InvalidSidInSDDLString();
    internal static string get_AccessControl_MustSpecifyContainerAcl();
    internal static string get_AccessControl_MustSpecifyDirectoryObjectAcl();
    internal static string get_AccessControl_MustSpecifyLeafObjectAcl();
    internal static string get_AccessControl_MustSpecifyNonDirectoryObjectAcl();
    internal static string get_AccessControl_NoAssociatedSecurity();
    internal static string get_AccessControl_UnexpectedError();
    internal static string get_Arg_EnumAtLeastOneFlag();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidOperationException();
    internal static string get_Arg_MustBeIdentityReferenceType();
    internal static string get_Argument_ArgumentZero();
    internal static string get_Argument_InvalidAnyFlag();
    internal static string get_Argument_InvalidEnumValue();
    internal static string get_Argument_InvalidName();
    internal static string get_Argument_InvalidPrivilegeName();
    internal static string get_Argument_InvalidSafeHandle();
    internal static string get_ArgumentException_InvalidAceBinaryForm();
    internal static string get_ArgumentException_InvalidAclBinaryForm();
    internal static string get_ArgumentException_InvalidSDSddlForm();
    internal static string get_ArgumentOutOfRange_ArrayLength();
    internal static string get_ArgumentOutOfRange_ArrayLengthMultiple();
    internal static string get_ArgumentOutOfRange_ArrayTooSmall();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_InvalidUserDefinedAceType();
    internal static string get_InvalidOperation_ModificationOfNonCanonicalAcl();
    internal static string get_InvalidOperation_MustBeSameThread();
    internal static string get_InvalidOperation_MustLockForReadOrWrite();
    internal static string get_InvalidOperation_MustLockForWrite();
    internal static string get_InvalidOperation_MustRevertPrivilege();
    internal static string get_InvalidOperation_NoSecurityDescriptor();
    internal static string get_InvalidOperation_OnlyValidForDS();
    internal static string get_InvalidOperation_DisconnectedPipe();
    internal static string get_NotSupported_SetMethod();
    internal static string get_PrivilegeNotHeld_Default();
    internal static string get_PrivilegeNotHeld_Named();
    internal static string get_Rank_MultiDimNotSupported();
}
