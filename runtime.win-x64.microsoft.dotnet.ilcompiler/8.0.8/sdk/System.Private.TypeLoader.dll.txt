internal static class FxResources.System.Private.TypeLoader.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Metadata.NativeFormat.MetadataTypeHashingAlgorithms : object {
    private static TypeAttributes NestedMask;
    private static void AppendNamespaceHashCode(HashCodeBuilder& builder, NamespaceDefinitionHandle namespaceDefHandle, MetadataReader reader);
    private static void AppendNamespaceHashCode(HashCodeBuilder& builder, NamespaceReferenceHandle namespaceRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static int ComputeHashCode(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static int ComputeHashCode(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
private static bool IsNested(TypeAttributes flags);
}
internal enum Internal.NativeFormat.BagElementKind : Enum {
    public UInt32 value__;
    public static BagElementKind End;
    public static BagElementKind BaseType;
    public static BagElementKind ImplementedInterfaces;
    public static BagElementKind DictionaryLayout;
    public static BagElementKind NonGcStaticData;
    public static BagElementKind GcStaticData;
    public static BagElementKind NonGcStaticDataSize;
    public static BagElementKind GcStaticDataSize;
    public static BagElementKind GcStaticDesc;
    public static BagElementKind ThreadStaticDataSize;
    public static BagElementKind ThreadStaticDesc;
    public static BagElementKind ThreadStaticIndex;
    public static BagElementKind ThreadStaticOffset;
    public static BagElementKind FieldLayout;
    public static BagElementKind ClassConstructorPointer;
}
internal enum Internal.NativeFormat.CallingConventionConverterKind : Enum {
    public UInt32 value__;
    public static CallingConventionConverterKind NoInstantiatingParam;
    public static CallingConventionConverterKind HasInstantiatingParam;
    public static CallingConventionConverterKind MaybeInstantiatingParam;
}
internal enum Internal.NativeFormat.FieldStorage : Enum {
    public UInt32 value__;
    public static FieldStorage Instance;
    public static FieldStorage NonGCStatic;
    public static FieldStorage GCStatic;
    public static FieldStorage TLSStatic;
}
internal enum Internal.NativeFormat.FixupSignatureKind : Enum {
    public UInt32 value__;
    public static FixupSignatureKind Null;
    public static FixupSignatureKind TypeHandle;
    public static FixupSignatureKind InterfaceCall;
    public static FixupSignatureKind MethodDictionary;
    public static FixupSignatureKind StaticData;
    public static FixupSignatureKind UnwrapNullableType;
    public static FixupSignatureKind FieldLdToken;
    public static FixupSignatureKind MethodLdToken;
    public static FixupSignatureKind AllocateObject;
    public static FixupSignatureKind DefaultConstructor;
    public static FixupSignatureKind ThreadStaticIndex;
    public static FixupSignatureKind Method;
    public static FixupSignatureKind NonGenericStaticConstrainedMethod;
    public static FixupSignatureKind GenericStaticConstrainedMethod;
    public static FixupSignatureKind NotYetSupported;
}
internal enum Internal.NativeFormat.GenericContextKind : Enum {
    public UInt32 value__;
    public static GenericContextKind FromThis;
    public static GenericContextKind FromHiddenArg;
    public static GenericContextKind FromMethodHiddenArg;
    public static GenericContextKind HasDeclaringType;
    public static GenericContextKind NeedsUSGContext;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodCallingConvention : Enum {
    public UInt32 value__;
    public static MethodCallingConvention Generic;
    public static MethodCallingConvention Static;
    public static MethodCallingConvention Unmanaged;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodFlags : Enum {
    public UInt32 value__;
    public static MethodFlags HasInstantiation;
    public static MethodFlags IsUnboxingStub;
    public static MethodFlags HasFunctionPointer;
    public static MethodFlags FunctionPointerIsUSG;
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public static void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public BagElementKind GetBagElementKind();
    public FixupSignatureKind GetFixupSignatureKind();
    public TypeSignatureKind GetTypeSignatureKind(UInt32& data);
    public NativeParser GetLookbackParser(UInt32 lookback);
    public Nullable`1<UInt32> GetUnsignedForBagElementKind(BagElementKind kindToFind);
    public NativeParser GetParserForBagElementKind(BagElementKind kindToFind);
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativePrimitiveEncoder : ValueType {
    private Byte[] _buffer;
    private int _size;
    public int Size { get; }
    public void Init();
    public int get_Size();
    public void Clear();
    public void RollbackTo(int offset);
    public void WriteByte(byte b);
    public void WriteUInt8(byte value);
    public void WriteUInt16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteFloat(float value);
    public void WriteDouble(double value);
    public void WriteUnsigned(UInt32 d);
    public static int GetUnsignedEncodingSize(UInt32 d);
    public void WriteSigned(int i);
    public void WriteUnsignedLong(ulong i);
    public void WriteSignedLong(long i);
    public void PatchByteAt(int offset, byte value);
    public void Save(Stream stream);
    public bool Save(Byte* stream, int streamLength);
    public Byte[] GetBytes();
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public static void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
internal enum Internal.NativeFormat.StaticDataKind : Enum {
    public UInt32 value__;
    public static StaticDataKind Gc;
    public static StaticDataKind NonGc;
}
public static class Internal.NativeFormat.TypeHashingAlgorithms : object {
    private static int _rotl(int value, int shift);
    public static int ComputeNameHashCode(string src);
    public static int ComputeASCIINameHashCode(Byte* data, int length, Boolean& isAscii);
    private static string IntToString(int arg);
    public static int ComputeArrayTypeHashCode(int elementTypeHashCode, int rank);
    public static int ComputeArrayTypeHashCode(T elementType, int rank);
    public static int ComputePointerTypeHashCode(int pointeeTypeHashCode);
    public static int ComputePointerTypeHashCode(T pointeeType);
    public static int ComputeByrefTypeHashCode(int parameterTypeHashCode);
    public static int ComputeByrefTypeHashCode(T parameterType);
    public static int ComputeNestedTypeHashCode(int enclosingTypeHashCode, int nestedTypeNameHash);
    public static int ComputeGenericInstanceHashCode(int genericDefinitionHashCode, ARG[] genericTypeArguments);
    public static int ComputeMethodSignatureHashCode(int returnTypeHashCode, ARG[] parameters);
    public static int ComputeMethodHashCode(int typeHashCode, int nameOrNameAndGenericArgumentsHashCode);
    public static int ComputeSignatureVariableHashCode(int index, bool method);
}
internal enum Internal.NativeFormat.TypeModifierKind : Enum {
    public UInt32 value__;
    public static TypeModifierKind Array;
    public static TypeModifierKind ByRef;
    public static TypeModifierKind Pointer;
}
internal enum Internal.NativeFormat.TypeSignatureKind : Enum {
    public UInt32 value__;
    public static TypeSignatureKind Null;
    public static TypeSignatureKind Lookback;
    public static TypeSignatureKind Modifier;
    public static TypeSignatureKind Instantiation;
    public static TypeSignatureKind Variable;
    public static TypeSignatureKind BuiltIn;
    public static TypeSignatureKind External;
    public static TypeSignatureKind MultiDimArray;
    public static TypeSignatureKind FunctionPointer;
}
public class Internal.Reflection.Execution.AssemblyBinderImplementation : AssemblyBinder {
    [CompilerGeneratedAttribute]
private static AssemblyBinderImplementation <Instance>k__BackingField;
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopeGroups;
    public static AssemblyBinderImplementation Instance { get; }
    private KeyValuePair`2[] ScopeGroups { get; }
    private static AssemblyBinderImplementation();
    [CompilerGeneratedAttribute]
public static AssemblyBinderImplementation get_Instance();
    public sealed virtual bool Bind(string assemblyPath, AssemblyBindResult& bindResult, Exception& exception);
    public sealed virtual bool Bind(ReadOnlySpan`1<byte> rawAssembly, ReadOnlySpan`1<byte> rawSymbolStore, AssemblyBindResult& bindResult, Exception& exception);
    public sealed virtual bool Bind(RuntimeAssemblyName refName, bool cacheMissedLookups, AssemblyBindResult& result, Exception& exception);
    public sealed virtual IList`1<AssemblyBindResult> GetLoadedAssemblies();
    private static bool AssemblyNameMatches(RuntimeAssemblyName refName, RuntimeAssemblyName defName, Exception& preferredException);
    private static bool AssemblyVersionMatches(Version refVersion, Version defVersion);
    private void RegisterModule(NativeFormatModuleInfo nativeFormatModuleInfo);
    private KeyValuePair`2[] get_ScopeGroups();
    private static void AddScopesFromReaderToGroups(LowLevelDictionaryWithIEnumerable`2<RuntimeAssemblyName, ScopeDefinitionGroup> groups, MetadataReader reader);
}
internal class Internal.Runtime.ArchitectureConstants : ValueType {
    public static int MAX_ARG_SIZE;
    public static int NUM_ARGUMENT_REGISTERS;
    public static int ARGUMENTREGISTERS_SIZE;
    public static int ENREGISTERED_RETURNTYPE_MAXSIZE;
    public static int ENREGISTERED_RETURNTYPE_INTEGER_MAXSIZE;
    public static int ENREGISTERED_RETURNTYPE_INTEGER_MAXSIZE_PRIMITIVE;
    public static int ENREGISTERED_PARAMTYPE_MAXSIZE;
    public static int STACK_ELEM_SIZE;
    public static int StackElemSize(int size);
}
internal class Internal.Runtime.ArgumentRegisters : ValueType {
    private IntPtr rdx;
    private IntPtr rcx;
    private IntPtr r8;
    private IntPtr r9;
}
internal static class Internal.Runtime.ArrayTypesConstants : object {
    public static int MaxSizeForValueClassInArray;
}
public class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
internal class Internal.Runtime.DispatchMap : ValueType {
    private ushort _standardEntryCount;
    private ushort _defaultEntryCount;
    private ushort _standardStaticEntryCount;
    private ushort _defaultStaticEntryCount;
    private DispatchMapEntry _dispatchMap;
    public UInt32 NumStandardEntries { get; public set; }
    public UInt32 NumDefaultEntries { get; public set; }
    public UInt32 NumStandardStaticEntries { get; public set; }
    public UInt32 NumDefaultStaticEntries { get; public set; }
    public int Size { get; }
    public UInt32 get_NumStandardEntries();
    public void set_NumStandardEntries(UInt32 value);
    public UInt32 get_NumDefaultEntries();
    public void set_NumDefaultEntries(UInt32 value);
    public UInt32 get_NumStandardStaticEntries();
    public void set_NumStandardStaticEntries(UInt32 value);
    public UInt32 get_NumDefaultStaticEntries();
    public void set_NumDefaultStaticEntries(UInt32 value);
    public int get_Size();
    public DispatchMapEntry* GetEntry(int index);
    public DispatchMapEntry* GetStaticEntry(int index);
}
internal class Internal.Runtime.DynamicInvokeMapEntry : ValueType {
    public static UInt32 IsImportMethodFlag;
    public static UInt32 InstantiationDetailIndexMask;
}
internal enum Internal.Runtime.EETypeElementType : Enum {
    public int value__;
    public static EETypeElementType Unknown;
    public static EETypeElementType Void;
    public static EETypeElementType Boolean;
    public static EETypeElementType Char;
    public static EETypeElementType SByte;
    public static EETypeElementType Byte;
    public static EETypeElementType Int16;
    public static EETypeElementType UInt16;
    public static EETypeElementType Int32;
    public static EETypeElementType UInt32;
    public static EETypeElementType Int64;
    public static EETypeElementType UInt64;
    public static EETypeElementType IntPtr;
    public static EETypeElementType UIntPtr;
    public static EETypeElementType Single;
    public static EETypeElementType Double;
    public static EETypeElementType ValueType;
    public static EETypeElementType Nullable;
    public static EETypeElementType Class;
    public static EETypeElementType Interface;
    public static EETypeElementType SystemArray;
    public static EETypeElementType Array;
    public static EETypeElementType SzArray;
    public static EETypeElementType ByRef;
    public static EETypeElementType Pointer;
    public static EETypeElementType FunctionPointer;
}
internal enum Internal.Runtime.EETypeField : Enum {
    public int value__;
    public static EETypeField ETF_TypeManagerIndirection;
    public static EETypeField ETF_WritableData;
    public static EETypeField ETF_DispatchMap;
    public static EETypeField ETF_Finalizer;
    public static EETypeField ETF_OptionalFieldsPtr;
    public static EETypeField ETF_SealedVirtualSlots;
    public static EETypeField ETF_DynamicTemplateType;
    public static EETypeField ETF_GenericDefinition;
    public static EETypeField ETF_GenericComposition;
    public static EETypeField ETF_FunctionPointerParameters;
    public static EETypeField ETF_DynamicGcStatics;
    public static EETypeField ETF_DynamicNonGcStatics;
    public static EETypeField ETF_DynamicThreadStaticOffset;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeFlags : Enum {
    public UInt32 value__;
    public static EETypeFlags EETypeKindMask;
    public static EETypeFlags HasDispatchMap;
    public static EETypeFlags IsDynamicTypeFlag;
    public static EETypeFlags HasFinalizerFlag;
    public static EETypeFlags HasPointersFlag;
    public static EETypeFlags HasSealedVTableEntriesFlag;
    public static EETypeFlags GenericVarianceFlag;
    public static EETypeFlags OptionalFieldsFlag;
    public static EETypeFlags IsGenericFlag;
    public static EETypeFlags ElementTypeMask;
    public static EETypeFlags ElementTypeShift;
    public static EETypeFlags HasComponentSizeFlag;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeFlagsEx : Enum {
    public ushort value__;
    public static EETypeFlagsEx HasEagerFinalizerFlag;
    public static EETypeFlagsEx HasCriticalFinalizerFlag;
    public static EETypeFlagsEx IsTrackedReferenceWithFinalizerFlag;
    public static EETypeFlagsEx IDynamicInterfaceCastableFlag;
}
internal enum Internal.Runtime.EETypeKind : Enum {
    public UInt32 value__;
    public static EETypeKind CanonicalEEType;
    public static EETypeKind FunctionPointerEEType;
    public static EETypeKind ParameterizedEEType;
    public static EETypeKind GenericTypeDefEEType;
}
internal enum Internal.Runtime.EETypeOptionalFieldTag : Enum {
    public byte value__;
    public static EETypeOptionalFieldTag RareFlags;
    public static EETypeOptionalFieldTag ValueTypeFieldPadding;
    public static EETypeOptionalFieldTag NullableValueOffset;
    public static EETypeOptionalFieldTag Count;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeRareFlags : Enum {
    public int value__;
    public static EETypeRareFlags RequiresAlign8Flag;
    public static EETypeRareFlags HasCctorFlag;
    public static EETypeRareFlags IsHFAFlag;
    public static EETypeRareFlags IsDynamicTypeWithGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithNonGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithThreadStatics;
    public static EETypeRareFlags IsByRefLikeFlag;
}
[FlagsAttribute]
public enum Internal.Runtime.FieldTableFlags : Enum {
    public UInt32 value__;
    public static FieldTableFlags Instance;
    public static FieldTableFlags NonGCStatic;
    public static FieldTableFlags GCStatic;
    public static FieldTableFlags ThreadStatic;
    public static FieldTableFlags StorageClass;
    public static FieldTableFlags IsUniversalCanonicalEntry;
    public static FieldTableFlags HasMetadataHandle;
    public static FieldTableFlags FieldOffsetEncodedDirectly;
    public static FieldTableFlags IsAnyCanonicalEntry;
    public static FieldTableFlags IsInitOnly;
}
internal class Internal.Runtime.FloatArgumentRegisters : ValueType {
    private M128A d0;
    private M128A d1;
    private M128A d2;
    private M128A d3;
}
internal static class Internal.Runtime.FunctionPointerFlags : object {
    public static UInt32 IsUnmanaged;
    public static UInt32 FlagsMask;
}
internal enum Internal.Runtime.GC_ALLOC_FLAGS : Enum {
    public int value__;
    public static GC_ALLOC_FLAGS GC_ALLOC_NO_FLAGS;
    public static GC_ALLOC_FLAGS GC_ALLOC_ZEROING_OPTIONAL;
    public static GC_ALLOC_FLAGS GC_ALLOC_PINNED_OBJECT_HEAP;
}
internal static class Internal.Runtime.GCStaticRegionConstants : object {
    public static int Uninitialized;
    public static int HasPreInitializedData;
    public static int Mask;
}
internal enum Internal.Runtime.GenericVariance : Enum {
    public byte value__;
    public static GenericVariance NonVariant;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
    public static GenericVariance ArrayCovariant;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwarePointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwareRelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal static class Internal.Runtime.IndirectionConstants : object {
    public static int IndirectionCellPointer;
    public static UInt32 RVAPointsToIndirection;
}
[FlagsAttribute]
public enum Internal.Runtime.InvokeTableFlags : Enum {
    public UInt32 value__;
    public static InvokeTableFlags HasVirtualInvoke;
    public static InvokeTableFlags IsGenericMethod;
    public static InvokeTableFlags HasMetadataHandle;
    public static InvokeTableFlags IsDefaultConstructor;
    public static InvokeTableFlags RequiresInstArg;
    public static InvokeTableFlags HasEntrypoint;
    public static InvokeTableFlags IsUniversalCanonicalEntry;
    public static InvokeTableFlags NeedsParameterInterpretation;
    public static InvokeTableFlags CallingConventionDefault;
    public static InvokeTableFlags Cdecl;
    public static InvokeTableFlags Winapi;
    public static InvokeTableFlags StdCall;
    public static InvokeTableFlags ThisCall;
    public static InvokeTableFlags FastCall;
    public static InvokeTableFlags CallingConventionMask;
}
internal class Internal.Runtime.M128A : ValueType {
    private IntPtr a;
    private IntPtr b;
}
internal static class Internal.Runtime.MethodFixupCellFlagsConstants : object {
    public static int CharSetMask;
    public static int IsObjectiveCMessageSendMask;
    public static int ObjectiveCMessageSendFunctionMask;
    public static int ObjectiveCMessageSendFunctionShift;
}
internal class Internal.Runtime.MethodTable : ValueType {
    private static int POINTER_SIZE;
    private static int PADDING;
    internal static int SZARRAY_BASE_SIZE;
    private UInt32 _uFlags;
    private UInt32 _uBaseSize;
    private RelatedTypeUnion _relatedType;
    private ushort _usNumVtableSlots;
    private ushort _usNumInterfaces;
    private UInt32 _uHashCode;
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    internal static bool SupportsRelativePointers { get; }
    internal static bool SupportsWritableData { get; }
    internal bool HasComponentSize { get; internal set; }
    internal ushort ComponentSize { get; internal set; }
    internal ushort GenericParameterCount { get; internal set; }
    internal UInt32 Flags { get; internal set; }
    internal ushort ExtendedFlags { get; internal set; }
    internal UInt32 RawBaseSize { get; internal set; }
    internal UInt32 BaseSize { get; internal set; }
    internal ushort NumVtableSlots { get; internal set; }
    internal ushort NumInterfaces { get; internal set; }
    internal UInt32 HashCode { get; internal set; }
    private EETypeKind Kind { get; }
    internal bool HasOptionalFields { get; }
    internal bool HasGenericVariance { get; }
    internal bool IsFinalizable { get; }
    internal bool IsNullable { get; }
    internal bool IsCanonical { get; }
    internal bool IsString { get; }
    internal bool IsArray { get; }
    internal int ArrayRank { get; }
    internal bool IsSzArray { get; }
    internal bool IsMultiDimensionalArray { get; }
    internal bool IsGeneric { get; }
    internal bool IsGenericTypeDefinition { get; }
    internal MethodTable* GenericDefinition { get; internal set; }
    internal UInt32 GenericArity { get; }
    internal MethodTableList GenericArguments { get; }
    internal GenericVariance* GenericVariance { get; }
    internal bool IsPointerType { get; }
    internal bool IsByRefType { get; }
    internal bool IsInterface { get; }
    internal bool IsByRefLike { get; }
    internal bool IsDynamicType { get; }
    internal bool IsParameterizedType { get; }
    internal bool IsFunctionPointerType { get; }
    internal UInt32 ParameterizedTypeShape { get; internal set; }
    internal UInt32 NumFunctionPointerParameters { get; internal set; }
    internal bool IsUnmanagedFunctionPointer { get; internal set; }
    internal MethodTableList FunctionPointerParameters { get; }
    internal MethodTable* FunctionPointerReturnType { get; internal set; }
    internal bool RequiresAlign8 { get; }
    internal bool IsIDynamicInterfaceCastable { get; }
    internal bool IsValueType { get; }
    internal bool IsPrimitive { get; }
    internal bool HasSealedVTableEntries { get; }
    internal bool ContainsGCPointers { get; internal set; }
    internal bool IsHFA { get; }
    internal bool IsTrackedReferenceWithFinalizer { get; }
    internal UInt32 ValueTypeFieldPadding { get; }
    internal UInt32 ValueTypeSize { get; }
    internal MethodTable** InterfaceMap { get; }
    internal bool HasDispatchMap { get; }
    internal DispatchMap* DispatchMap { get; internal set; }
    internal IntPtr FinalizerCode { get; internal set; }
    internal MethodTable* BaseType { get; internal set; }
    internal MethodTable* NonArrayBaseType { get; }
    internal MethodTable* NullableType { get; }
    internal byte NullableValueOffset { get; }
    internal MethodTable* RelatedParameterType { get; internal set; }
    internal Byte* OptionalFieldsPtr { get; internal set; }
    internal MethodTable* DynamicTemplateType { get; internal set; }
    internal IntPtr DynamicGcStaticsData { get; internal set; }
    internal IntPtr DynamicNonGcStaticsData { get; internal set; }
    internal IntPtr DynamicThreadStaticsIndex { get; internal set; }
    internal TypeManagerHandle TypeManager { get; }
    internal IntPtr PointerToTypeManager { get; internal set; }
    internal Void* WritableData { get; internal set; }
    internal EETypeRareFlags RareFlags { get; }
    internal int FieldAlignmentRequirement { get; }
    internal EETypeElementType ElementType { get; internal set; }
    public bool HasCctor { get; }
    [IntrinsicAttribute]
internal static bool get_SupportsRelativePointers();
    internal static bool get_SupportsWritableData();
    [IntrinsicAttribute]
internal static MethodTable* Of();
    internal bool get_HasComponentSize();
    internal void set_HasComponentSize(bool value);
    internal ushort get_ComponentSize();
    internal void set_ComponentSize(ushort value);
    internal ushort get_GenericParameterCount();
    internal void set_GenericParameterCount(ushort value);
    internal UInt32 get_Flags();
    internal void set_Flags(UInt32 value);
    internal ushort get_ExtendedFlags();
    internal void set_ExtendedFlags(ushort value);
    internal UInt32 get_RawBaseSize();
    internal void set_RawBaseSize(UInt32 value);
    internal UInt32 get_BaseSize();
    internal void set_BaseSize(UInt32 value);
    internal ushort get_NumVtableSlots();
    internal void set_NumVtableSlots(ushort value);
    internal ushort get_NumInterfaces();
    internal void set_NumInterfaces(ushort value);
    internal UInt32 get_HashCode();
    internal void set_HashCode(UInt32 value);
    private EETypeKind get_Kind();
    internal bool get_HasOptionalFields();
    internal bool get_HasGenericVariance();
    internal bool get_IsFinalizable();
    internal bool get_IsNullable();
    internal bool get_IsCanonical();
    internal bool get_IsString();
    internal bool get_IsArray();
    internal int get_ArrayRank();
    internal bool get_IsSzArray();
    internal bool get_IsMultiDimensionalArray();
    internal bool get_IsGeneric();
    internal bool get_IsGenericTypeDefinition();
    internal MethodTable* get_GenericDefinition();
    internal void set_GenericDefinition(MethodTable* value);
    internal static int GetGenericCompositionSize(int numArguments);
    internal void SetGenericComposition(IntPtr data);
    internal UInt32 get_GenericArity();
    internal MethodTableList get_GenericArguments();
    internal GenericVariance* get_GenericVariance();
    internal bool get_IsPointerType();
    internal bool get_IsByRefType();
    internal bool get_IsInterface();
    internal bool get_IsByRefLike();
    internal bool get_IsDynamicType();
    internal bool get_IsParameterizedType();
    internal bool get_IsFunctionPointerType();
    internal UInt32 get_ParameterizedTypeShape();
    internal void set_ParameterizedTypeShape(UInt32 value);
    internal UInt32 get_NumFunctionPointerParameters();
    internal void set_NumFunctionPointerParameters(UInt32 value);
    internal bool get_IsUnmanagedFunctionPointer();
    internal void set_IsUnmanagedFunctionPointer(bool value);
    internal MethodTableList get_FunctionPointerParameters();
    internal MethodTable* get_FunctionPointerReturnType();
    internal void set_FunctionPointerReturnType(MethodTable* value);
    internal bool get_RequiresAlign8();
    internal bool get_IsIDynamicInterfaceCastable();
    internal bool get_IsValueType();
    internal bool get_IsPrimitive();
    internal bool get_HasSealedVTableEntries();
    internal bool get_ContainsGCPointers();
    internal void set_ContainsGCPointers(bool value);
    internal bool get_IsHFA();
    internal bool get_IsTrackedReferenceWithFinalizer();
    internal UInt32 get_ValueTypeFieldPadding();
    internal UInt32 get_ValueTypeSize();
    internal MethodTable** get_InterfaceMap();
    internal bool get_HasDispatchMap();
    internal DispatchMap* get_DispatchMap();
    internal void set_DispatchMap(DispatchMap* value);
    internal IntPtr get_FinalizerCode();
    internal void set_FinalizerCode(IntPtr value);
    internal MethodTable* get_BaseType();
    internal void set_BaseType(MethodTable* value);
    internal MethodTable* get_NonArrayBaseType();
    internal MethodTable* get_NullableType();
    internal byte get_NullableValueOffset();
    internal MethodTable* get_RelatedParameterType();
    internal void set_RelatedParameterType(MethodTable* value);
    internal IntPtr* GetVTableStartAddress();
    private static IntPtr FollowRelativePointer(Int32* pDist);
    internal Void* GetSealedVirtualTable();
    internal IntPtr GetSealedVirtualSlot(ushort slotNumber);
    internal Byte* get_OptionalFieldsPtr();
    internal void set_OptionalFieldsPtr(Byte* value);
    internal MethodTable* get_DynamicTemplateType();
    internal void set_DynamicTemplateType(MethodTable* value);
    internal IntPtr get_DynamicGcStaticsData();
    internal void set_DynamicGcStaticsData(IntPtr value);
    internal IntPtr get_DynamicNonGcStaticsData();
    internal void set_DynamicNonGcStaticsData(IntPtr value);
    internal IntPtr get_DynamicThreadStaticsIndex();
    internal void set_DynamicThreadStaticsIndex(IntPtr value);
    internal TypeManagerHandle get_TypeManager();
    internal IntPtr get_PointerToTypeManager();
    internal void set_PointerToTypeManager(IntPtr value);
    internal Void* get_WritableData();
    internal void set_WritableData(Void* value);
    internal EETypeRareFlags get_RareFlags();
    internal int get_FieldAlignmentRequirement();
    internal EETypeElementType get_ElementType();
    internal void set_ElementType(EETypeElementType value);
    public bool get_HasCctor();
    public UInt32 GetFieldOffset(EETypeField eField);
    public T& GetField(EETypeField eField);
    public T& GetField(UInt32 offset);
    internal static UInt32 GetSizeofEEType(ushort cVirtuals, ushort cInterfaces, bool fHasDispatchMap, bool fHasFinalizer, bool fRequiresOptionalFields, bool fHasSealedVirtuals, bool fHasGenericInfo, int cFunctionPointerTypeParameters, bool fHasNonGcStatics, bool fHasGcStatics, bool fHasThreadStatics);
    private static MethodTable* GetArrayEEType();
    internal RuntimeTypeHandle ToRuntimeTypeHandle();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Internal.Runtime.MethodTableList : ValueType {
    private static int IsRelative;
    private Void* _pFirst;
    public MethodTable* Item { get; public set; }
    public MethodTableList(MethodTable* pFirst);
    public MethodTableList(RelativePointer`1* pFirst);
    public MethodTable* get_Item(int index);
    public void set_Item(int index, MethodTable* value);
}
internal class Internal.Runtime.ObjHeader : ValueType {
    private IntPtr _objHeaderContents;
}
internal static class Internal.Runtime.ParameterizedTypeShapeConstants : object {
    public static int Pointer;
    public static int ByRef;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.Pointer : ValueType {
    private IntPtr _value;
    public IntPtr Value { get; }
    public IntPtr get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.Pointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
internal enum Internal.Runtime.ReflectionMapBlob : Enum {
    public int value__;
    public static ReflectionMapBlob TypeMap;
    public static ReflectionMapBlob ArrayMap;
    public static ReflectionMapBlob PointerTypeMap;
    public static ReflectionMapBlob FunctionPointerTypeMap;
    public static ReflectionMapBlob InvokeMap;
    public static ReflectionMapBlob VirtualInvokeMap;
    public static ReflectionMapBlob CommonFixupsTable;
    public static ReflectionMapBlob FieldAccessMap;
    public static ReflectionMapBlob CCtorContextMap;
    public static ReflectionMapBlob ByRefTypeMap;
    public static ReflectionMapBlob EmbeddedMetadata;
    public static ReflectionMapBlob UnboxingAndInstantiatingStubMap;
    public static ReflectionMapBlob StructMarshallingStubMap;
    public static ReflectionMapBlob DelegateMarshallingStubMap;
    public static ReflectionMapBlob GenericVirtualMethodTable;
    public static ReflectionMapBlob InterfaceGenericVirtualMethodTable;
    public static ReflectionMapBlob TypeTemplateMap;
    public static ReflectionMapBlob GenericMethodsTemplateMap;
    public static ReflectionMapBlob BlobIdResourceIndex;
    public static ReflectionMapBlob BlobIdResourceData;
    public static ReflectionMapBlob BlobIdStackTraceEmbeddedMetadata;
    public static ReflectionMapBlob BlobIdStackTraceMethodRvaToTokenMapping;
    public static ReflectionMapBlob NativeLayoutInfo;
    public static ReflectionMapBlob NativeReferences;
    public static ReflectionMapBlob GenericsHashtable;
    public static ReflectionMapBlob NativeStatics;
    public static ReflectionMapBlob StaticsInfoHashtable;
    public static ReflectionMapBlob GenericMethodsHashtable;
    public static ReflectionMapBlob ExactMethodInstantiationsHashtable;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.RelativePointer : ValueType {
    private int _value;
    public IntPtr Value { get; }
    public IntPtr get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.RelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal class Internal.Runtime.ReturnBlock : ValueType {
    private IntPtr returnValue;
}
internal enum Internal.Runtime.RuntimeHelperKind : Enum {
    public int value__;
    public static RuntimeHelperKind AllocateObject;
    public static RuntimeHelperKind IsInst;
    public static RuntimeHelperKind CastClass;
    public static RuntimeHelperKind AllocateArray;
}
internal static class Internal.Runtime.SpecialDispatchMapSlot : object {
    public static ushort Diamond;
    public static ushort Reabstraction;
}
internal static class Internal.Runtime.SpecialGVMInterfaceEntry : object {
    public static UInt32 Diamond;
    public static UInt32 Reabstraction;
}
internal static class Internal.Runtime.StaticVirtualMethodContextSource : object {
    public static ushort None;
    public static ushort ContextFromThisClass;
    public static ushort ContextFromFirstInterface;
}
internal static class Internal.Runtime.StringComponentSize : object {
    public static int Value;
}
internal class Internal.Runtime.TransitionBlock : ValueType {
    private IntPtr m_returnBlockPadding;
    private ReturnBlock m_returnBlock;
    private IntPtr m_alignmentPadding;
    private IntPtr m_ReturnAddress;
    public static int InvalidOffset;
    public static int GetOffsetOfReturnValuesBlock();
    public static int GetOffsetOfArgumentRegisters();
    public static byte GetOffsetOfArgs();
    public static bool IsStackArgumentOffset(int offset);
    public static bool IsArgumentRegisterOffset(int offset);
    public static int GetArgumentIndexFromOffset(int offset);
    public static int GetStackArgumentIndexFromOffset(int offset);
    public static bool IsFloatArgumentRegisterOffset(int offset);
    public static int GetOffsetOfFloatArgumentRegisters();
    public static int GetNegSpaceSize();
    public static int GetThisOffset();
}
internal class Internal.Runtime.TypeLoader.Callbacks : TypeLoaderCallbacks {
    public virtual TypeManagerHandle GetModuleForMetadataReader(MetadataReader reader);
    public virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public virtual IntPtr GetThreadStaticGCDescForDynamicType(TypeManagerHandle typeManagerHandle, int index);
    public virtual IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    public virtual bool GetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public virtual RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public virtual bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public virtual IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    public virtual IntPtr ResolveGenericVirtualMethodTarget(RuntimeTypeHandle targetTypeHandle, RuntimeMethodHandle declMethod);
    public virtual bool GetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public virtual RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string fieldName);
    public virtual IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
    public virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
}
public class Internal.Runtime.TypeLoader.CanonicallyEquivalentEntryLocator : ValueType {
    private RuntimeTypeHandle _typeToFind;
    private RuntimeTypeHandle _genericDefinition;
    private RuntimeTypeHandle[] _genericArgs;
    private DefType _defType;
    private CanonicalFormKind _canonKind;
    public int LookupHashCode { get; }
    public CanonicallyEquivalentEntryLocator(RuntimeTypeHandle typeToFind, CanonicalFormKind kind);
    internal CanonicallyEquivalentEntryLocator(DefType typeToFind, CanonicalFormKind kind);
    public int get_LookupHashCode();
    public bool IsCanonicallyEquivalent(RuntimeTypeHandle other);
    public bool ConversionToCanonFormIsAChange();
}
internal static class Internal.Runtime.TypeLoader.EETypeCreator : object {
    private static void CreateEETypeWorker(MethodTable* pTemplateEEType, UInt32 hashCodeOfNewType, int arity, TypeBuilderState state);
    private static void CreateInstanceGCDesc(TypeBuilderState state, MethodTable* pTemplateEEType, MethodTable* pEEType, int baseSize, int cbGCDesc, bool isValueType, bool isArray, bool isSzArray, int arrayRank);
    private static int GetInstanceGCDescSize(TypeBuilderState state, MethodTable* pTemplateEEType, bool isValueType, bool isArray);
    private static bool IsAllGCPointers(LowLevelList`1<bool> bitfield);
    private static int CreateArrayGCDesc(LowLevelList`1<bool> bitfield, int rank, bool isSzArray, Void* gcdesc);
    private static int CreateGCDesc(LowLevelList`1<bool> bitfield, int size, bool isValueType, bool isStatic, Void* gcdesc);
    public static RuntimeTypeHandle CreateFunctionPointerEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle returnTypeHandle, RuntimeTypeHandle[] parameterHandles, FunctionPointerType functionPointerType);
    public static RuntimeTypeHandle CreatePointerEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle pointeeTypeHandle, TypeDesc pointerType);
    public static RuntimeTypeHandle CreateByRefEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle pointeeTypeHandle, TypeDesc byRefType);
    public static RuntimeTypeHandle CreateEEType(TypeDesc type, TypeBuilderState state);
    public static int GetDictionaryOffsetInEEtype(MethodTable* pEEType);
    public static IntPtr GetDictionaryAtOffset(MethodTable* pEEType, int offset);
    public static IntPtr GetDictionary(MethodTable* pEEType);
    public static int GetDictionarySlotInVTable(TypeDesc type);
}
public class Internal.Runtime.TypeLoader.ExternalReferencesTable : ValueType {
    private IntPtr _elements;
    private UInt32 _elementsCount;
    private bool Initialize(TypeManagerHandle typeManager, ReflectionMapBlob blobId);
    public bool IsInitialized();
    public bool InitializeCommonFixupsTable(TypeManagerHandle module);
    public IntPtr GetIntPtrFromIndex(UInt32 index);
    public IntPtr GetFunctionPointerFromIndex(UInt32 index);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromIndex(UInt32 index);
    public IntPtr GetAddressFromIndex(UInt32 index);
    private bool Initialize(NativeFormatModuleInfo module, ReflectionMapBlob blobId);
    public bool InitializeNativeReferences(NativeFormatModuleInfo module);
    public bool InitializeNativeStatics(NativeFormatModuleInfo module);
    public bool InitializeCommonFixupsTable(NativeFormatModuleInfo module);
}
public class Internal.Runtime.TypeLoader.FieldAccessMetadata : ValueType {
    public TypeManagerHandle MappingTableModule;
    public IntPtr Cookie;
    public FieldTableFlags Flags;
    public int Offset;
}
internal abstract class Internal.Runtime.TypeLoader.GenericDictionary : object {
    protected GenericDictionaryCell[] _cells;
    protected IntPtr _addressOfFirstCellSlot;
    public GenericDictionary(GenericDictionaryCell[] cells);
    public abstract virtual IntPtr Allocate();
    public void Finish(TypeBuilder typeBuilder);
}
public abstract class Internal.Runtime.TypeLoader.GenericDictionaryCell : object {
    internal abstract virtual void Prepare(TypeBuilder builder);
    internal abstract virtual IntPtr Create(TypeBuilder builder);
    internal virtual void WriteCellIntoDictionary(TypeBuilder typeBuilder, IntPtr* pDictionary, int slotIndex);
    internal virtual IntPtr CreateLazyLookupCell(TypeBuilder builder, IntPtr& auxResult);
    private static RuntimeTypeHandle GetRuntimeTypeHandleWithNullableTransform(TypeBuilder builder, TypeDesc type);
    internal static GenericDictionaryCell[] BuildDictionary(TypeBuilder typeBuilder, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser parser);
    internal static GenericDictionaryCell ParseAndCreateCell(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser& parser);
}
internal class Internal.Runtime.TypeLoader.GenericMethodDictionary : GenericDictionary {
    public GenericMethodDictionary(GenericDictionaryCell[] cells);
    public virtual IntPtr Allocate();
}
internal class Internal.Runtime.TypeLoader.GenericTypeDictionary : GenericDictionary {
    public GenericTypeDictionary(GenericDictionaryCell[] cells);
    public virtual IntPtr Allocate();
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.LowLevelListExtensions : object {
    [ExtensionAttribute]
public static void Expand(LowLevelList`1<T> list, int count);
    [ExtensionAttribute]
public static bool HasSetBits(LowLevelList`1<bool> list);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.LowLevelStringConverter : object {
    private static string HexDigits;
    private static string LowLevelToString(ulong arg, int shift);
    [ExtensionAttribute]
public static string LowLevelToString(LayoutInt arg);
    [ExtensionAttribute]
public static string LowLevelToString(byte arg);
    [ExtensionAttribute]
public static string LowLevelToString(ushort arg);
    [ExtensionAttribute]
public static string LowLevelToString(int arg);
    [ExtensionAttribute]
public static string LowLevelToString(UInt32 arg);
    [ExtensionAttribute]
public static string LowLevelToString(ulong arg);
    [ExtensionAttribute]
public static string LowLevelToString(IntPtr arg);
    [ExtensionAttribute]
public static string LowLevelToString(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static string LowLevelToStringRawEETypeAddress(RuntimeTypeHandle rtth);
}
internal static class Internal.Runtime.TypeLoader.MemoryHelpers : object {
    public static int AlignUp(int val, int alignment);
    public static void Memset(IntPtr destination, int length, byte value);
    public static IntPtr AllocateMemory(int cbBytes);
    public static void FreeMemory(IntPtr memoryPtrToFree);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.MetadataNameExtensions : object {
    [ExtensionAttribute]
public static string GetFullName(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ByReferenceSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(PointerSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ArraySignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(SZArraySignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(TypeSpecificationHandle typeSpecHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(TypeInstantiationSignatureHandle typeInstSigHandle, MetadataReader reader);
    [ExtensionAttribute]
public static void GetFullName(TypeDefinitionHandle typeDefHandle, MetadataReader reader, String& name, String& enclosing, String& nspace);
    [ExtensionAttribute]
public static string GetFullName(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetContainingModuleName(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(NamespaceDefinitionHandle namespaceHandle, MetadataReader reader);
    [ExtensionAttribute]
public static void GetFullName(TypeReferenceHandle typeRefHandle, MetadataReader reader, String& name, String& enclosing, String& nspace);
    [ExtensionAttribute]
public static string GetFullName(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetContainingModuleName(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(NamespaceReferenceHandle namespaceHandle, MetadataReader reader);
    [ExtensionAttribute]
private static string GetFullName(ScopeDefinitionHandle scopeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
private static string GetFullName(ScopeReferenceHandle scopeRefHandle, MetadataReader reader);
}
public class Internal.Runtime.TypeLoader.MethodInvokeMetadata : ValueType {
    public NativeFormatModuleInfo MappingTableModule;
    public IntPtr MethodEntryPoint;
    public IntPtr RawMethodEntryPoint;
    public IntPtr DictionaryComponent;
    public UInt32 DynamicInvokeCookie;
    public InvokeTableFlags InvokeTableFlags;
}
public class Internal.Runtime.TypeLoader.MethodSignatureComparer : ValueType {
    private MetadataReader _metadataReader;
    private MethodHandle _methodHandle;
    private Method _method;
    private MethodSignature _methodSignature;
    private bool _isStatic;
    private bool _isGeneric;
    public MethodSignatureComparer(QMethodDefinition methodHandle);
    public MethodSignatureComparer(MetadataReader metadataReader, MethodHandle methodHandle);
    public bool IsMatchingNativeLayoutMethodNameAndSignature(string name, RuntimeSignature signature);
    public bool IsMatchingNativeLayoutMethodSignature(RuntimeSignature signature);
    internal static NativeParser GetNativeParserForSignature(RuntimeSignature signature);
    private bool CompareTypeSigWithType(NativeParser& parser, TypeManagerHandle moduleHandle, Handle typeHandle);
    private bool CompareCallingConventions(MethodCallingConvention callingConvention);
    private static bool CanGetTypeHandle(Type type);
}
public class Internal.Runtime.TypeLoader.ModuleInfo : object {
    [CompilerGeneratedAttribute]
private TypeManagerHandle <Handle>k__BackingField;
    public TypeManagerHandle Handle { get; private set; }
    internal ModuleInfo(TypeManagerHandle moduleHandle);
    [CompilerGeneratedAttribute]
public TypeManagerHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(TypeManagerHandle value);
}
public class Internal.Runtime.TypeLoader.ModuleInfoEnumerator : ValueType {
    private ModuleInfo[] _modules;
    private int _preferredIndex;
    private int _iterationIndex;
    private ModuleInfo _currentModule;
    public ModuleInfo Current { get; }
    internal ModuleInfoEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public ModuleInfo get_Current();
}
public class Internal.Runtime.TypeLoader.ModuleList : object {
    private ModuleMap _loadedModuleMap;
    [CompilerGeneratedAttribute]
private static ModuleList <Instance>k__BackingField;
    public static ModuleList Instance { get; }
    private static ModuleList();
    [CompilerGeneratedAttribute]
public static ModuleList get_Instance();
    public NativeFormatModuleInfo GetModuleInfoByHandle(TypeManagerHandle moduleHandle);
    public bool TryGetModuleInfoByHandle(TypeManagerHandle moduleHandle, ModuleInfo& moduleInfo);
    public MetadataReader GetMetadataReaderForModule(TypeManagerHandle moduleHandle);
    public NativeFormatModuleInfo GetModuleInfoForMetadataReader(MetadataReader reader);
    public TypeManagerHandle GetModuleForMetadataReader(MetadataReader reader);
    public static NativeFormatModuleInfoEnumerable EnumerateModules();
    public static NativeFormatModuleInfoEnumerable EnumerateModules(TypeManagerHandle preferredModule);
}
internal class Internal.Runtime.TypeLoader.ModuleMap : object {
    public ModuleInfo[] Modules;
    public LowLevelDictionary`2<TypeManagerHandle, int> HandleToModuleIndex;
    internal ModuleMap(ModuleInfo[] modules);
}
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfo : ModuleInfo {
    [CompilerGeneratedAttribute]
private MetadataReader <MetadataReader>k__BackingField;
    public MetadataReader MetadataReader { get; private set; }
    internal NativeFormatModuleInfo(TypeManagerHandle moduleHandle, IntPtr pBlob, int cbBlob);
    [CompilerGeneratedAttribute]
public MetadataReader get_MetadataReader();
    [CompilerGeneratedAttribute]
private void set_MetadataReader(MetadataReader value);
    internal bool TryFindBlob(ReflectionMapBlob blobId, Byte*& pBlob, UInt32& cbBlob);
    public bool TryFindBlob(int blobId, Byte*& pBlob, UInt32& cbBlob);
}
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfoEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal NativeFormatModuleInfoEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public NativeFormatModuleInfoEnumerator GetEnumerator();
}
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfoEnumerator : ValueType {
    private ModuleInfo[] _modules;
    private int _preferredIndex;
    private int _iterationIndex;
    private NativeFormatModuleInfo _currentModule;
    public NativeFormatModuleInfo Current { get; }
    internal NativeFormatModuleInfoEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public NativeFormatModuleInfo get_Current();
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInfo : ValueType {
    public UInt32 Offset;
    public NativeFormatModuleInfo Module;
    public NativeReader Reader;
    public NativeLayoutInfoLoadContext LoadContext;
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInfoLoadContext : object {
    public TypeSystemContext _typeSystemContext;
    public NativeFormatModuleInfo _module;
    private ExternalReferencesTable _staticInfoLookup;
    private ExternalReferencesTable _externalReferencesLookup;
    public Instantiation _typeArgumentHandles;
    public Instantiation _methodArgumentHandles;
    private DefType GetInstantiationType(NativeParser& parser, UInt32 arity);
    private TypeDesc GetModifierType(NativeParser& parser, TypeModifierKind modifier);
    private void InitializeExternalReferencesLookup();
    private IntPtr GetExternalReferencePointer(UInt32 index);
    internal TypeDesc GetExternalType(UInt32 index);
    internal IntPtr GetGCStaticInfo(UInt32 index);
    private TypeDesc GetLookbackType(NativeParser& parser, UInt32 lookback);
    internal TypeDesc GetType(NativeParser& parser);
    internal MethodDesc GetMethod(NativeParser& parser, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    internal MethodDesc GetMethod(NativeParser& parser);
    internal TypeDesc[] GetTypeSequence(NativeParser& parser);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
    private static bool InterfaceInSet(DefType[] interfaces, int numInterfaces, DefType interfaceType);
}
internal class Internal.Runtime.TypeLoader.NoMetadataRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
internal class Internal.Runtime.TypeLoader.OptionalFieldsRuntimeBuilder : object {
    private NativePrimitiveEncoder _encoder;
    private OptionalField[] _rgFields;
    internal OptionalFieldsRuntimeBuilder(Byte* pInitializeFromOptionalFields);
    internal UInt32 GetFieldValue(EETypeOptionalFieldTag eTag, UInt32 defaultValueIfNotFound);
    internal void SetFieldValue(EETypeOptionalFieldTag eTag, UInt32 value);
    internal void ClearField(EETypeOptionalFieldTag eTag);
    internal int Encode();
    internal void WriteToEEType(MethodTable* pEEType, int sizeOfOptionalFieldsDataInEEType);
}
[ExtensionAttribute]
public static class Internal.Runtime.TypeLoader.RuntimeSignatureExtensions : object {
    [ExtensionAttribute]
public static IntPtr NativeLayoutSignature(RuntimeSignature signature);
}
[ExtensionAttribute]
public static class Internal.Runtime.TypeLoader.RuntimeSignatureHelper : object {
    [ExtensionAttribute]
public static ModuleInfo GetModuleInfo(RuntimeSignature methodSignature);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.RuntimeTypeHandleEETypeExtensions : object {
    [ExtensionAttribute]
public static MethodTable* ToEETypePtr(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static IntPtr ToIntPtr(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static bool IsDynamicType(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static int GetNumVtableSlots(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static TypeManagerHandle GetTypeManager(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static IntPtr GetDictionary(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static void SetDictionary(RuntimeTypeHandle rtth, int dictionarySlot, IntPtr dictionary);
    [ExtensionAttribute]
public static void SetInterface(RuntimeTypeHandle rtth, int interfaceIndex, RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
public static void SetGenericDefinition(RuntimeTypeHandle rtth, RuntimeTypeHandle genericDefinitionHandle);
    [ExtensionAttribute]
public static void SetGenericArgument(RuntimeTypeHandle rtth, int argumentIndex, RuntimeTypeHandle argumentType);
    [ExtensionAttribute]
public static void SetRelatedParameterType(RuntimeTypeHandle rtth, RuntimeTypeHandle relatedTypeHandle);
    [ExtensionAttribute]
public static void SetParameterizedTypeShape(RuntimeTypeHandle rtth, UInt32 value);
    [ExtensionAttribute]
public static void SetBaseType(RuntimeTypeHandle rtth, RuntimeTypeHandle baseTypeHandle);
    [ExtensionAttribute]
public static void SetComponentSize(RuntimeTypeHandle rtth, ushort componentSize);
}
internal static class Internal.Runtime.TypeLoader.SigParsing : object {
    public static RuntimeTypeHandle GetTypeFromNativeLayoutSignature(NativeParser& parser, TypeManagerHandle moduleHandle, UInt32 offset);
}
internal class Internal.Runtime.TypeLoader.TemplateLocator : ValueType {
    private static UInt32 BadTokenFixupValue;
    public static TypeDesc TryGetTypeTemplate(TypeDesc concreteType, NativeLayoutInfo& nativeLayoutInfo);
    private static TypeDesc TryGetTypeTemplate_Internal(TypeDesc concreteType, CanonicalFormKind kind, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    public static InstantiatedMethod TryGetGenericMethodTemplate(InstantiatedMethod concreteMethod, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private static InstantiatedMethod TryGetGenericMethodTemplate_Internal(InstantiatedMethod concreteMethod, CanonicalFormKind kind, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private static NativeHashtable LoadHashtable(NativeFormatModuleInfo module, ReflectionMapBlob hashtableBlobId, ExternalReferencesTable& externalFixupsTable);
}
internal class Internal.Runtime.TypeLoader.TypeBuilder : object {
    private LowLevelList`1<TypeDesc> _typesThatNeedTypeHandles;
    private LowLevelList`1<InstantiatedMethod> _methodsThatNeedDictionaries;
    private LowLevelList`1<TypeDesc> _typesThatNeedPreparation;
    public static int ClassConstructorOffset { get; }
    public static int get_ClassConstructorOffset();
    internal static bool RetrieveMethodDictionaryIfPossible(InstantiatedMethod method);
    public void RegisterForPreparation(TypeDesc type);
    public void PrepareMethod(MethodDesc method);
    private void InsertIntoNeedsTypeHandleList(TypeDesc type);
    internal void PrepareType(TypeDesc type);
    private void PrepareRuntimeInterfaces(TypeDesc type);
    private void PrepareBaseTypeAndDictionaries(TypeDesc type);
    private void ProcessTypesNeedingPreparation();
    internal void ParseNativeLayoutInfo(InstantiatedMethod method);
    internal void ParseNativeLayoutInfo(TypeBuilderState state, TypeDesc type);
    private void AllocateRuntimeType(TypeDesc type);
    private static void AllocateRuntimeMethodDictionary(InstantiatedMethod method);
    public RuntimeTypeHandle GetRuntimeTypeHandle(TypeDesc type);
    public RuntimeTypeHandle[] GetRuntimeTypeHandles(Instantiation types);
    public static DefType GetBaseTypeUsingRuntimeTypeHandle(TypeDesc type);
    public static DefType GetBaseTypeThatIsCorrectForMDArrays(TypeDesc type);
    private void FinishInterfaces(TypeBuilderState state);
    private void FinishTypeDictionary(TypeDesc type);
    private void FinishMethodDictionary(InstantiatedMethod method);
    private void FinishClassConstructor(TypeDesc type, TypeBuilderState state);
    private void CopyDictionaryFromTypeToAppropriateSlotInDerivedType(DefType baseType, TypeBuilderState derivedTypeState);
    private void FinishBaseTypeAndDictionaries(TypeDesc type, TypeBuilderState state);
    private void FinishRuntimeType(TypeDesc type);
    [IteratorStateMachineAttribute("Internal.Runtime.TypeLoader.TypeBuilder/<TypesToRegister>d__31")]
private IEnumerable`1<GenericTypeEntry> TypesToRegister();
    [IteratorStateMachineAttribute("Internal.Runtime.TypeLoader.TypeBuilder/<MethodsToRegister>d__32")]
private IEnumerable`1<GenericMethodEntry> MethodsToRegister();
    private void RegisterGenericTypesAndMethods();
    private void FinishTypeAndMethodBuilding();
    internal void BuildType(TypeDesc type);
    private void BuildMethod(InstantiatedMethod method);
    private static DefType GetExactDeclaringType(DefType srcDefType, DefType dstDefType);
    private IntPtr BuildGenericLookupTarget(TypeSystemContext typeSystemContext, IntPtr context, IntPtr signature, IntPtr& auxResult);
    public static bool TryBuildGenericType(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public static bool TryBuildArrayType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public static bool TryBuildPointerType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public static bool TryBuildByRefType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public static bool TryBuildFunctionPointerType(RuntimeTypeHandle returnTypeHandle, RuntimeTypeHandle[] parameterHandles, bool isUnmanaged, RuntimeTypeHandle& runtimeTypeHandle);
    internal static bool TryBuildGenericMethod(InstantiatedMethod methodBeingLoaded, IntPtr& methodDictionary);
    private void ResolveSingleCell_Worker(GenericDictionaryCell cell, IntPtr& fixupResolution);
    private void ResolveMultipleCells_Worker(GenericDictionaryCell[] cells, IntPtr[]& fixups);
    internal static void ResolveSingleCell(GenericDictionaryCell cell, IntPtr& fixupResolution);
    public static void ResolveMultipleCells(GenericDictionaryCell[] cells, IntPtr[]& fixups);
    public static IntPtr BuildGenericLookupTarget(IntPtr typeContext, IntPtr signature, IntPtr& auxResult);
}
internal class Internal.Runtime.TypeLoader.TypeBuilderState : object {
    public TypeDesc TypeBeingBuilt;
    public bool AttemptedAndFailedToRetrieveTypeHandle;
    public bool NeedsTypeHandle;
    public bool HasBeenPrepared;
    public RuntimeTypeHandle HalfBakedRuntimeTypeHandle;
    public IntPtr HalfBakedDictionary;
    private bool _templateComputed;
    private bool _nativeLayoutTokenComputed;
    private TypeDesc _templateType;
    private bool _nativeLayoutComputed;
    private bool _templateTypeLoaderNativeLayout;
    private NativeLayoutInfo _nativeLayoutInfo;
    private Nullable`1<bool> _hasDictionarySlotInVTable;
    private Nullable`1<bool> _hasDictionaryInVTable;
    private Nullable`1<ushort> _numVTableSlots;
    public GenericTypeDictionary Dictionary;
    public int NonGcDataSize;
    public int GcDataSize;
    public int ThreadDataSize;
    public Nullable`1<IntPtr> ClassConstructorPointer;
    public IntPtr GcStaticDesc;
    public IntPtr ThreadStaticDesc;
    public UInt32 ThreadStaticOffset;
    public GenericVariance[] GenericVarianceFlags;
    private static LowLevelList`1<bool> s_emptyLayout;
    private LowLevelList`1<bool> _instanceGCLayout;
    private bool _staticGCLayoutPrepared;
    public TypeDesc TemplateType { get; }
    public NativeLayoutInfo NativeLayoutInfo { get; }
    public DefType[] RuntimeInterfaces { get; }
    public bool HasDictionarySlotInVTable { get; }
    public bool HasDictionaryInVTable { get; }
    public ushort NumVTableSlots { get; }
    public bool HasStaticConstructor { get; }
    public LowLevelList`1<bool> InstanceGCLayout { get; }
    public bool IsArrayOfReferenceTypes { get; }
    public Nullable`1<int> ArrayRank { get; }
    public TypeBuilderState(TypeDesc typeBeingBuilt);
    private static TypeBuilderState();
    public TypeDesc get_TemplateType();
    private void EnsureNativeLayoutInfoComputed();
    private static void FinishInitNativeLayoutInfo(TypeDesc type, NativeLayoutInfo& nativeLayoutInfo);
    public NativeLayoutInfo get_NativeLayoutInfo();
    public NativeParser GetParserForNativeLayoutInfo();
    public DefType[] get_RuntimeInterfaces();
    private bool ComputeHasDictionarySlotInVTable();
    public bool get_HasDictionarySlotInVTable();
    private bool ComputeHasDictionaryInVTable();
    public bool get_HasDictionaryInVTable();
    private ushort ComputeNumVTableSlots();
    public ushort get_NumVTableSlots();
    public bool get_HasStaticConstructor();
    public LowLevelList`1<bool> get_InstanceGCLayout();
    public void PrepareStaticGCLayout();
    private static GCLayout GetFieldGCLayout(TypeDesc fieldType);
    public bool get_IsArrayOfReferenceTypes();
    public Nullable`1<int> get_ArrayRank();
}
public class Internal.Runtime.TypeLoader.TypeLoaderEnvironment : object {
    private DynamicGenericMethodsHashtable _dynamicGenericMethods;
    private DynamicGenericMethodComponentsHashtable _dynamicGenericMethodComponents;
    private Lock _dynamicGenericsLock;
    private DynamicGenericTypesHashtable _dynamicGenericTypes;
    private LowLevelDictionary`2<LazyDictionaryContext, IntPtr> _lazyGenericDictionaries;
    [ThreadStaticAttribute]
private static bool t_isReentrant;
    private static TypeLoaderEnvironment s_instance;
    [ThreadStaticAttribute]
private static LowLevelDictionary`2<TypeManagerHandle, NativeReader> t_moduleNativeReaders;
    private Lock _typeLoaderLock;
    private LowLevelDictionary`2<string, IntPtr> _nativeFormatStrings;
    private LowLevelDictionary`2<RuntimeFieldHandleKey, RuntimeFieldHandle> _runtimeFieldHandles;
    private LowLevelDictionary`2<RuntimeMethodHandleKey, RuntimeMethodHandle> _runtimeMethodHandles;
    private Lock _threadStaticsLock;
    private LowLevelDictionary`2<IntPtr, UInt32> _maxThreadLocalIndex;
    private LowLevelDictionary`2<IntPtr, LowLevelDictionary`2<UInt32, IntPtr>> _dynamicGenericsThreadStaticDescs;
    public static TypeLoaderEnvironment Instance { get; }
    public static TypeLoaderEnvironment InstanceOrNull { get; }
    internal bool TryLookupGenericMethodDictionary(GenericMethodLookupData lookupData, IntPtr& result);
    public bool TryGetGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    public static bool TryGetGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    public bool TryLookupExactMethodPointer(InstantiatedMethod method, IntPtr& result);
    public bool TryGetGenericVirtualMethodPointer(InstantiatedMethod method, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private bool TryGetDynamicGenericMethodDictionary(GenericMethodLookupData lookupData, IntPtr& result);
    private static bool TryGetStaticGenericMethodDictionary(GenericMethodLookupData lookupData, IntPtr& result);
    private bool TryGetDynamicGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    private static bool TryGetStaticGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, TypeManagerHandle& typeManager, UInt32& nameAndSigOffset, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    internal void RegisterDynamicGenericTypesAndMethods(DynamicGenericsRegistrationData registrationData);
    public void RegisterConstructedLazyDictionaryForContext(IntPtr context, IntPtr signature, IntPtr dictionary);
    internal bool TryLookupConstructedGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupConstructedLazyDictionaryForContext(IntPtr context, IntPtr signature, IntPtr& dictionary);
    private bool TryGetDynamicGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    internal static bool TryGetStaticGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    private static TypeLoaderEnvironment InitializeInstance();
    public static TypeLoaderEnvironment get_Instance();
    public static TypeLoaderEnvironment get_InstanceOrNull();
    internal static void Initialize();
    public void VerifyTypeLoaderLockHeld();
    public void RunUnderTypeLoaderLock(Action action);
    public IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    private bool EnsureTypeHandleForType(TypeDesc type);
    internal TypeDesc GetConstructedTypeFromParserAndNativeLayoutContext(NativeParser& parser, NativeLayoutInfoLoadContext nativeLayoutContext);
    internal bool GetTypeFromSignatureAndContext(RuntimeSignature signature, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, RuntimeSignature& remainingSignature);
    internal bool GetTypeFromSignatureAndContext(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType);
    public MethodDesc GetMethodFromSignatureAndContext(TypeSystemContext context, RuntimeSignature signature, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeSignature& remainingSignature);
    internal static NativeReader GetNativeLayoutInfoReader(NativeFormatModuleInfo module);
    internal static NativeReader GetNativeLayoutInfoReader(RuntimeSignature signature);
    internal static NativeReader GetNativeLayoutInfoReader(TypeManagerHandle moduleHandle);
    private static RuntimeTypeHandle[] GetTypeSequence(ExternalReferencesTable& extRefs, NativeParser& parser);
    private static RuntimeTypeHandle[] TypeDescsToRuntimeHandles(Instantiation types);
    public bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryGetFunctionPointerTypeForComponents(RuntimeTypeHandle returnTypeHandle, RuntimeTypeHandle[] parameterHandles, bool isUnmanaged, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupFunctionPointerTypeForComponents(RuntimeTypeHandle returnTypeHandle, RuntimeTypeHandle[] parameterHandles, bool isUnmanaged, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    internal static bool TryGetArrayTypeForElementType_LookupOnly(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public static bool TryGetPointerTypeForTargetType_LookupOnly(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public bool TryGetByRefTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public static bool TryGetByRefTypeForTargetType_LookupOnly(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public int GetCanonicalHashCode(RuntimeTypeHandle typeHandle, CanonicalFormKind kind);
    private static object TryParseNativeSignatureWorker(TypeSystemContext typeSystemContext, TypeManagerHandle moduleHandle, NativeParser& parser, RuntimeTypeHandle[] typeGenericArgumentHandles, RuntimeTypeHandle[] methodGenericArgumentHandles, bool isMethodSignature);
    public bool TryGetGenericMethodDictionaryForComponents(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericMethodArgHandles, MethodNameAndSignature nameAndSignature, IntPtr& methodDictionary);
    public bool CanInstantiationsShareCode(RuntimeTypeHandle[] genericArgHandles1, RuntimeTypeHandle[] genericArgHandles2, CanonicalFormKind kind);
    public bool ConversionToCanonFormIsAChange(RuntimeTypeHandle[] genericArgHandles, CanonicalFormKind kind);
    private static bool GetHashtableFromBlob(NativeFormatModuleInfo module, ReflectionMapBlob blobId, NativeHashtable& hashtable, ExternalReferencesTable& externalReferencesLookup);
    public static void GetFieldAlignmentAndSize(RuntimeTypeHandle fieldType, Int32& alignment, Int32& size);
    public static bool TryGetTargetOfUnboxingAndInstantiatingStub(IntPtr maybeInstantiatingAndUnboxingStub, IntPtr& targetMethod);
    public static IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
    public static bool TryGetFieldAccessMetadata(MetadataReader metadataReader, RuntimeTypeHandle runtimeTypeHandle, FieldHandle fieldHandle, FieldAccessMetadata& fieldAccessMetadata);
    private static bool TryGetFieldAccessMetadataFromFieldAccessMap(RuntimeTypeHandle declaringTypeHandle, FieldHandle fieldHandle, CanonicalFormKind canonFormKind, FieldAccessMetadata& fieldAccessMetadata);
    private static string GetTypeNameDebug(TypeDesc type);
    internal static InstantiatedMethod GVMLookupForSlotWorker(DefType targetType, InstantiatedMethod slotMethod);
    internal IntPtr ResolveGenericVirtualMethodTarget(RuntimeTypeHandle type, RuntimeMethodHandle slot);
    private static MethodNameAndSignature GetMethodNameAndSignatureFromNativeReader(NativeReader nativeLayoutReader, TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset);
    private static RuntimeTypeHandle GetTypeDefinition(RuntimeTypeHandle typeHandle);
    private static InstantiatedMethod FindMatchingInterfaceSlot(NativeFormatModuleInfo module, NativeReader nativeLayoutReader, NativeParser& entryParser, ExternalReferencesTable& extRefs, InstantiatedMethod slotMethod, DefType targetType, bool variantDispatch, bool defaultMethods);
    private static InstantiatedMethod ResolveInterfaceGenericVirtualMethodSlot(DefType targetType, InstantiatedMethod slotMethod, bool lookForDefaultImplementation);
    private static InstantiatedMethod ResolveGenericVirtualMethodTarget(DefType targetType, InstantiatedMethod slotMethod);
    private static string GetStringFromMemoryInNativeFormat(IntPtr pointerToDataStream);
    public IntPtr GetNativeFormatStringForString(string str);
    public RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string fieldName);
    public RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, IntPtr fieldName);
    public bool TryGetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    private bool TryGetDynamicRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    private bool TryGetStaticRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, IntPtr methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public MethodDesc GetMethodDescForRuntimeMethodHandle(TypeSystemContext context, RuntimeMethodHandle runtimeMethodHandle);
    public bool TryGetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    private bool TryGetDynamicRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public MethodDesc GetMethodDescForDynamicRuntimeMethodHandle(TypeSystemContext context, RuntimeMethodHandle runtimeMethodHandle);
    private bool TryGetStaticRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public MethodDesc GetMethodDescForStaticRuntimeMethodHandle(TypeSystemContext context, RuntimeMethodHandle runtimeMethodHandle);
    private static bool SequenceEqual(T[] seq1, T[] seq2);
    internal static NativeReader GetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob);
    public static bool TryGetMetadataForNamedType(RuntimeTypeHandle runtimeTypeHandle, QTypeDefinition& qTypeDefinition);
    public static bool TryGetNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public static bool TryGetArrayTypeForNonDynamicElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public static bool TryGetByRefTypeForNonDynamicElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public static bool TryGetPointerTypeForNonDynamicElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    private static bool TryGetParameterizedTypeForNonDynamicElementType(RuntimeTypeHandle elementTypeHandle, int hashCode, ReflectionMapBlob blob, RuntimeTypeHandle& parameterizedTypeHandle);
    public bool TryGetStaticFunctionPointerTypeForComponents(RuntimeTypeHandle returnTypeHandle, RuntimeTypeHandle[] parameterHandles, bool isUnmanaged, RuntimeTypeHandle& runtimeTypeHandle);
    public static IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle typeHandle);
    private static bool TryGetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob, NativeReader& reader);
    internal static IntPtr TryGetDefaultConstructorForType(TypeDesc type);
    public IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    internal static IntPtr TryGetDefaultConstructorForType_Inner(NativeFormatModuleInfo mappingTableModule, CanonicallyEquivalentEntryLocator& canonHelper);
    public static bool TryGetVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle methodHandleDeclaringType, RuntimeTypeHandle[] genericArgs, MethodSignatureComparer& methodSignatureComparer, VirtualResolveDataResult& lookupResult);
    public static bool TryGetMethodInvokeMetadata(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    private static bool TryGetMethodInvokeMetadataFromInvokeMap(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, MethodHandle methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    public bool TryGetMetadataForTypeMethodNameAndSignature(RuntimeTypeHandle declaringTypeHandle, MethodNameAndSignature nameAndSignature, QMethodDefinition& methodHandle);
    public bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public static bool IsStaticMethodSignature(MethodNameAndSignature signature);
    public UInt32 GetGenericArgumentCountFromMethodNameAndSignature(MethodNameAndSignature signature);
    public bool TryGetMethodNameAndSignatureFromNativeLayoutSignature(RuntimeSignature signature, MethodNameAndSignature& nameAndSignature);
    public bool TryGetMethodNameAndSignaturePointersFromNativeLayoutSignature(TypeManagerHandle module, UInt32 methodNameAndSigToken, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    public MethodNameAndSignature GetMethodNameAndSignatureFromNativeLayoutOffset(TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset);
    internal static MethodNameAndSignature GetMethodNameAndSignature(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    private static bool TryGetTypeFromSimpleTypeSignature(NativeParser& parser, NativeFormatModuleInfo moduleHandle, RuntimeTypeHandle& typeHandle);
    private static RuntimeTypeHandle GetExternalTypeHandle(NativeFormatModuleInfo moduleHandle, UInt32 typeIndex);
    private static UInt32 GetGenericArgCountFromSig(NativeParser parser);
    private static bool CompareMethodSigs(NativeParser parser1, NativeFormatModuleInfo moduleHandle1, NativeParser parser2, NativeFormatModuleInfo moduleHandle2);
    private static bool CompareTypeSigs(NativeParser& parser1, NativeFormatModuleInfo moduleHandle1, NativeParser& parser2, NativeFormatModuleInfo moduleHandle2);
    public IntPtr TryGetNonGcStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetGcStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetThreadStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr GetThreadStaticGCDescForDynamicType(TypeManagerHandle typeManagerHandle, UInt32 index);
    public UInt32 GetNextThreadStaticsOffsetValue(TypeManagerHandle typeManagerHandle);
    public void RegisterDynamicThreadStaticsInfo(RuntimeTypeHandle runtimeTypeHandle, UInt32 offsetValue, IntPtr gcDesc);
    private static bool GetStaticsInfoHashtable(NativeFormatModuleInfo module, NativeHashtable& staticsInfoHashtable, ExternalReferencesTable& externalReferencesLookup, ExternalReferencesTable& staticInfoLookup);
    private static NativeParser GetStaticInfo(RuntimeTypeHandle instantiatedType, ExternalReferencesTable& staticsInfoLookup);
    [CompilerGeneratedAttribute]
internal static bool <TryLookupFunctionPointerTypeForComponents>g__AllNonDynamicTypes|56_0(RuntimeTypeHandle[] handles);
}
internal static class Internal.Runtime.TypeLoader.TypeLoaderLogger : object {
    internal static int s_pauseHash;
    [ConditionalAttribute("TYPE_LOADER_TRACE")]
public static void WriteLine(string message);
}
public class Internal.Runtime.TypeLoader.TypeLoaderTypeSystemContext : TypeSystemContext {
    private static NoMetadataRuntimeInterfacesAlgorithm s_noMetadataRuntimeInterfacesAlgorithm;
    private static NativeLayoutInterfacesAlgorithm s_nativeLayoutInterfacesAlgorithm;
    public bool SupportsUniversalCanon { get; }
    public bool SupportsCanon { get; }
    public TypeLoaderTypeSystemContext(TargetDetails targetDetails);
    private static TypeLoaderTypeSystemContext();
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected internal sealed virtual bool IsIDynamicInterfaceCastableInterface(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    protected internal virtual bool ComputeHasStaticConstructor(TypeDesc type);
    public virtual bool get_SupportsUniversalCanon();
    public virtual bool get_SupportsCanon();
}
public static class Internal.Runtime.TypeLoader.TypeSystemContextFactory : object {
    private static GCHandle s_cachedContext;
    private static Lock s_lock;
    private static TypeSystemContextFactory();
    public static TypeSystemContext Create();
    public static void Recycle(TypeSystemContext context);
}
[ExtensionAttribute]
public static class Internal.Runtime.TypeLoader.WellKnownTypeExtensions : object {
    [ExtensionAttribute]
public static RuntimeTypeHandle GetRuntimeTypeHandle(WellKnownType wkt);
}
internal class Internal.Runtime.VirtualInvokeTableEntry : ValueType {
    public static int GenericVirtualMethod;
    public static int FlagsMask;
}
internal static class Internal.Runtime.WritableData : object {
    public static int GetSize(int pointerSize);
    public static int GetAlignment(int pointerSize);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.AlignmentHelper : object {
    [ExtensionAttribute]
public static int AlignUp(int val, int alignment);
}
public class Internal.TypeSystem.ArrayMethod : MethodDesc {
    private ArrayType _owningType;
    private ArrayMethodKind _kind;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public ArrayType OwningArray { get; }
    public ArrayMethodKind Kind { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    internal ArrayMethod(ArrayType owningType, ArrayMethodKind kind);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public ArrayType get_OwningArray();
    public ArrayMethodKind get_Kind();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual MethodNameAndSignature get_NameAndSignature();
}
public enum Internal.TypeSystem.ArrayMethodKind : Enum {
    public int value__;
    public static ArrayMethodKind Get;
    public static ArrayMethodKind Set;
    public static ArrayMethodKind Address;
    public static ArrayMethodKind AddressWithHiddenArg;
    public static ArrayMethodKind Ctor;
}
public class Internal.TypeSystem.ArrayType : ParameterizedType {
    private int _rank;
    internal MethodDesc[] _methods;
    public DefType BaseType { get; }
    public TypeDesc ElementType { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public int Rank { get; }
    internal ArrayType(TypeDesc elementType, int rank);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual DefType get_BaseType();
    public TypeDesc get_ElementType();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public int get_Rank();
    private void InitializeMethods();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual IEnumerable`1<MethodDesc> GetVirtualMethods();
    public MethodDesc GetArrayMethod(ArrayMethodKind kind);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
public class Internal.TypeSystem.BaseTypeRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private static RuntimeInterfacesAlgorithm _singleton;
    public static RuntimeInterfacesAlgorithm Instance { get; }
    private static BaseTypeRuntimeInterfacesAlgorithm();
    public static RuntimeInterfacesAlgorithm get_Instance();
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
public class Internal.TypeSystem.ByRefType : ParameterizedType {
    internal ByRefType(TypeDesc parameter);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
public abstract class Internal.TypeSystem.CanonBaseType : DefType {
    private TypeSystemContext _context;
    public TypeSystemContext Context { get; }
    public DefType ContainingType { get; }
    public CanonBaseType(TypeSystemContext context);
    public sealed virtual TypeSystemContext get_Context();
    public virtual DefType get_ContainingType();
}
public enum Internal.TypeSystem.CanonicalFormKind : Enum {
    public int value__;
    public static CanonicalFormKind Specific;
    public static CanonicalFormKind Universal;
    public static CanonicalFormKind Any;
}
internal class Internal.TypeSystem.CanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public DefType BaseType { get; }
    public CanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    private void Initialize();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Internal.TypeSystem.CastingHelper : object {
    [ExtensionAttribute]
public static bool CanCastTo(TypeDesc thisType, TypeDesc otherType);
    private static TypeFlags GetReducedTypeElementType(TypeDesc type);
    private static TypeFlags GetVerificationTypeElementType(TypeDesc type);
    private static bool AreVerificationTypesEqual(TypeDesc type1, TypeDesc type2);
    private static bool IsMethodSignatureCompatibleWith(TypeDesc fn1Ttype, TypeDesc fn2Type);
    [ExtensionAttribute]
public static bool IsCompatibleWith(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
internal static bool IsCompatibleWith(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect visited);
    [ExtensionAttribute]
public static bool IsEquivalentTo(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
internal static bool IsEquivalentTo(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect visited);
    [ExtensionAttribute]
private static bool CanCastToInternal(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastGenericParameterTo(GenericParameterDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastArrayTo(ArrayType thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastParamTo(ParameterizedType thisType, TypeDesc paramType, StackOverflowProtect protect);
    private static bool IsConstrainedAsGCPointer(GenericParameterDesc type);
    private static TypeFlags GetNormalizedIntegralArrayElementType(TypeDesc type);
    public static bool IsArrayElementTypeCastableBySize(TypeDesc elementType);
    [ExtensionAttribute]
private static bool CanCastToClassOrInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToNonVariantInterface(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
private static bool CanCastByVarianceToInterfaceOrDelegate(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protectInput);
    [ExtensionAttribute]
private static bool CanCastToClass(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool IsBoxedAndCanCastTo(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
}
internal class Internal.TypeSystem.CastingPair : ValueType {
    public TypeDesc FromType;
    public TypeDesc ToType;
    public CastingPair(TypeDesc fromType, TypeDesc toType);
    public bool Equals(CastingPair other);
}
public enum Internal.TypeSystem.DefaultInterfaceMethodResolution : Enum {
    public int value__;
    public static DefaultInterfaceMethodResolution None;
    public static DefaultInterfaceMethodResolution DefaultImplementation;
    public static DefaultInterfaceMethodResolution Reabstraction;
    public static DefaultInterfaceMethodResolution Diamond;
}
public abstract class Internal.TypeSystem.DefType : TypeDesc {
    internal static LayoutInt MaximumAlignmentPossible;
    public string Namespace { get; }
    public string Name { get; }
    public DefType ContainingType { get; }
    public bool HasNativeLayout { get; }
    private static DefType();
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual DefType get_ContainingType();
    public virtual bool get_HasNativeLayout();
}
public class Internal.TypeSystem.EmbeddedSignatureData : ValueType {
    public string index;
    public EmbeddedSignatureDataKind kind;
    public TypeDesc type;
}
public enum Internal.TypeSystem.EmbeddedSignatureDataKind : Enum {
    public int value__;
    public static EmbeddedSignatureDataKind RequiredCustomModifier;
    public static EmbeddedSignatureDataKind OptionalCustomModifier;
    public static EmbeddedSignatureDataKind ArrayShape;
    public static EmbeddedSignatureDataKind UnmanagedCallConv;
}
public class Internal.TypeSystem.ExceptionTypeNameFormatter : TypeNameFormatter {
    [CompilerGeneratedAttribute]
private static ExceptionTypeNameFormatter <Instance>k__BackingField;
    public static ExceptionTypeNameFormatter Instance { get; }
    private static ExceptionTypeNameFormatter();
    [CompilerGeneratedAttribute]
public static ExceptionTypeNameFormatter get_Instance();
    public virtual void AppendName(StringBuilder sb, PointerType type);
    public virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    public virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public virtual void AppendName(StringBuilder sb, ByRefType type);
    public virtual void AppendName(StringBuilder sb, ArrayType type);
    protected virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    private static string GetTypeName(DefType type);
    private static string GetTypeNamespace(DefType type);
}
public abstract class Internal.TypeSystem.FieldDesc : TypeSystemEntity {
    public static FieldDesc[] EmptyFields;
    public string Name { get; }
    public DefType OwningType { get; }
    public TypeDesc FieldType { get; }
    public bool HasEmbeddedSignatureData { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    public bool IsTypicalFieldDefinition { get; }
    private static FieldDesc();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string get_Name();
    public abstract virtual DefType get_OwningType();
    public abstract virtual TypeDesc get_FieldType();
    public abstract virtual EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public abstract virtual bool get_HasEmbeddedSignatureData();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsThreadStatic();
    public abstract virtual bool get_HasRva();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
    public bool get_IsTypicalFieldDefinition();
    public virtual FieldDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class Internal.TypeSystem.FieldForInstantiatedType : FieldDesc {
    private FieldDesc _fieldDef;
    private InstantiatedType _instantiatedType;
    public TypeSystemContext Context { get; }
    public DefType OwningType { get; }
    public string Name { get; }
    public TypeDesc FieldType { get; }
    public bool HasEmbeddedSignatureData { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    internal FieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_OwningType();
    public virtual string get_Name();
    public virtual TypeDesc get_FieldType();
    public virtual EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public virtual bool get_HasEmbeddedSignatureData();
    public virtual bool get_IsStatic();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsThreadStatic();
    public virtual bool get_HasRva();
    public virtual bool get_IsLiteral();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
}
public class Internal.TypeSystem.FunctionPointerType : TypeDesc {
    private MethodSignature _signature;
    private int _hashCode;
    public MethodSignature Signature { get; }
    public TypeSystemContext Context { get; }
    internal FunctionPointerType(MethodSignature signature);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public MethodSignature get_Signature();
    public virtual TypeSystemContext get_Context();
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
[FlagsAttribute]
public enum Internal.TypeSystem.GenericConstraints : Enum {
    public int value__;
    public static GenericConstraints None;
    public static GenericConstraints ReferenceTypeConstraint;
    public static GenericConstraints NotNullableValueTypeConstraint;
    public static GenericConstraints DefaultConstructorConstraint;
    public static GenericConstraints AcceptByRefLike;
}
public abstract class Internal.TypeSystem.GenericParameterDesc : TypeDesc {
    public string Name { get; }
    public GenericParameterKind Kind { get; }
    public int Index { get; }
    public TypeSystemEntity AssociatedTypeOrMethod { get; }
    public GenericVariance Variance { get; }
    public GenericConstraints Constraints { get; }
    public IEnumerable`1<TypeDesc> TypeConstraints { get; }
    public bool HasNotNullableValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool HasAcceptByRefLikeConstraint { get; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected sealed virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Name();
    public abstract virtual GenericParameterKind get_Kind();
    public abstract virtual int get_Index();
    public abstract virtual TypeSystemEntity get_AssociatedTypeOrMethod();
    public virtual GenericVariance get_Variance();
    public virtual GenericConstraints get_Constraints();
    public virtual IEnumerable`1<TypeDesc> get_TypeConstraints();
    public bool get_HasNotNullableValueTypeConstraint();
    public bool get_HasReferenceTypeConstraint();
    public bool get_HasDefaultConstructorConstraint();
    public bool get_HasAcceptByRefLikeConstraint();
    public bool get_IsCovariant();
    public bool get_IsContravariant();
    protected sealed virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public sealed virtual int GetHashCode();
}
public enum Internal.TypeSystem.GenericParameterKind : Enum {
    public int value__;
    public static GenericParameterKind Type;
    public static GenericParameterKind Method;
}
public enum Internal.TypeSystem.GenericVariance : Enum {
    public int value__;
    public static GenericVariance None;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
}
public interface Internal.TypeSystem.IAssemblyDesc {
    public abstract virtual AssemblyName GetName();
}
public class Internal.TypeSystem.InstantiatedMethod : MethodDesc {
    private InstantiatedMethod _specificCanonCache;
    private InstantiatedMethod _universalCanonCache;
    private MethodDesc _methodDef;
    private Instantiation _instantiation;
    private MethodSignature _signature;
    [CompilerGeneratedAttribute]
private bool <NeedsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <RuntimeMethodDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericDictionary <Dictionary>k__BackingField;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsPublic { get; }
    public bool IsDefaultConstructor { get; }
    public bool IsStaticConstructor { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public bool NeedsDictionary { get; public set; }
    public IntPtr RuntimeMethodDictionary { get; private set; }
    internal GenericDictionary Dictionary { get; private set; }
    public bool UnboxingStub { get; }
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation, int hashcode);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    private InstantiatedMethod GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, InstantiatedMethod value);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    protected virtual int ComputeHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool get_IsPublic();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool get_IsDefaultConstructor();
    public virtual bool get_IsStaticConstructor();
    public virtual MethodDesc GetMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual string get_Name();
    public virtual MethodNameAndSignature get_NameAndSignature();
    protected virtual bool ComputeIsNonSharableMethod();
    [CompilerGeneratedAttribute]
public bool get_NeedsDictionary();
    [CompilerGeneratedAttribute]
public void set_NeedsDictionary(bool value);
    [CompilerGeneratedAttribute]
public IntPtr get_RuntimeMethodDictionary();
    [CompilerGeneratedAttribute]
private void set_RuntimeMethodDictionary(IntPtr value);
    [CompilerGeneratedAttribute]
internal GenericDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(GenericDictionary value);
    internal void SetGenericDictionary(GenericDictionary dictionary);
    public void AssociateWithRuntimeMethodDictionary(IntPtr rmd);
    public virtual bool get_UnboxingStub();
}
public class Internal.TypeSystem.InstantiatedType : DefType {
    private DefType _typeDef;
    private Instantiation _instantiation;
    private int _hashCode;
    private DefType _baseType;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public DefType BaseType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public DefType ContainingType { get; }
    public TypeDesc UnderlyingType { get; }
    internal InstantiatedType(DefType typeDef, Instantiation instantiation);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    private DefType InitializeBaseType();
    public virtual DefType get_BaseType();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual string get_Name();
    public virtual string get_Namespace();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetMethods>d__22")]
public virtual IEnumerable`1<MethodDesc> GetMethods();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetVirtualMethods>d__23")]
public virtual IEnumerable`1<MethodDesc> GetVirtualMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature, Instantiation substitution);
    public virtual MethodDesc GetMethodWithEquivalentSignature(string name, MethodSignature signature, Instantiation substitution);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual MethodDesc GetFinalizer();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetFields>d__29")]
public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public static T[] InstantiateTypeArray(T[] uninstantiatedTypes, Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public virtual DefType get_ContainingType();
    public virtual TypeDesc get_UnderlyingType();
}
[DefaultMemberAttribute("GenericParameters")]
public class Internal.TypeSystem.Instantiation : ValueType {
    private TypeDesc[] _genericParameters;
    public static Instantiation Empty;
    public TypeDesc GenericParameters { get; }
    public int Length { get; }
    public bool IsNull { get; }
    public Instantiation(TypeDesc[] genericParameters);
    private static Instantiation();
    public TypeDesc get_GenericParameters(int index);
    public static ReadOnlySpan`1<TypeDesc> op_Implicit(Instantiation instantiation);
    public int get_Length();
    public bool get_IsNull();
    public int ComputeGenericInstanceHashCode(int genericDefinitionHashCode);
    public Enumerator GetEnumerator();
    public virtual string ToString();
    public sealed virtual bool Equals(Instantiation other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Internal.TypeSystem.LayoutInt : ValueType {
    private int _value;
    public static LayoutInt Indeterminate;
    public static LayoutInt Zero;
    public static LayoutInt One;
    public bool IsIndeterminate { get; }
    public int AsInt { get; }
    public LayoutInt(int input);
    private static LayoutInt();
    private static LayoutInt CreateIndeterminateLayoutInt();
    public bool get_IsIndeterminate();
    public int get_AsInt();
    public virtual string ToString();
    public string ToStringInvariant();
    public static bool op_Equality(LayoutInt left, LayoutInt right);
    public static bool op_Inequality(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Addition(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Subtraction(LayoutInt left, LayoutInt right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LayoutInt Max(LayoutInt left, LayoutInt right);
    public static LayoutInt Min(LayoutInt left, LayoutInt right);
    public static LayoutInt AlignUp(LayoutInt value, LayoutInt alignment, TargetDetails target);
}
public class Internal.TypeSystem.LockFreeObjectInterner : LockFreeReaderHashtableOfPointers`2<object, GCHandle> {
    private static LockFreeObjectInterner s_interner;
    private static LockFreeObjectInterner();
    public static GCHandle GetInternedObjectHandle(object obj);
    protected virtual int GetKeyHashCode(object key);
    protected virtual int GetValueHashCode(GCHandle value);
    protected virtual bool CompareKeyToValue(object key, GCHandle value);
    protected virtual bool CompareValueToValue(GCHandle value1, GCHandle value2);
    protected virtual GCHandle CreateValueFromKey(object key);
    protected virtual IntPtr ConvertValueToIntPtr(GCHandle value);
    protected virtual GCHandle ConvertIntPtrToValue(IntPtr pointer);
}
public abstract class Internal.TypeSystem.LockFreeReaderHashtableOfPointers`2 : object {
    private static int _initialSize;
    private static int _fillPercentageBeforeResize;
    private IntPtr[] modreq(System.Runtime.CompilerServices.IsVolatile) _hashtable;
    private IntPtr[] modreq(System.Runtime.CompilerServices.IsVolatile) _newHashTable;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _count;
    private int _reserve;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _resizeCount;
    public int Count { get; }
    private IntPtr[] GetCurrentHashtable();
    private void SetCurrentHashtable(IntPtr[] hashtable);
    public static int HashInt1(int key);
    public static int HashInt2(int key);
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    private static IntPtr WaitForSentinelInHashtableToDisappear(IntPtr[] hashtable, int tableIndex);
    private void Expand(IntPtr[] oldHashtable);
    public void Reserve(int size);
    public bool TryAdd(TValue value);
    public TValue AddOrGetExisting(TValue value);
    private TValue AddOrGetExistingInner(TValue value, Boolean& addedValue);
    private static IntPtr VolatileReadNonSentinelFromHashtable(IntPtr[] hashTable, int tableIndex);
    private bool TryAddOrGetExisting(TValue value, Boolean& addedValue, TValue& valueInHashtable);
    private static bool TryWriteSentinelToLocation(IntPtr[] hashTableLocal, int tableIndex);
    private static void WriteValueToLocation(IntPtr value, IntPtr[] hashTableLocal, int tableIndex);
    private static void WriteAbortNullToLocation(IntPtr[] hashTableLocal, int tableIndex);
    private TValue CreateValueAndEnsureValueIsInTable(TKey key);
    public TValue GetOrCreateValue(TKey key);
    public bool Contains(TKey key);
    public TValue GetValueIfExists(TValue value);
    protected abstract virtual int GetKeyHashCode(TKey key);
    protected abstract virtual int GetValueHashCode(TValue value);
    protected abstract virtual bool CompareKeyToValue(TKey key, TValue value);
    protected abstract virtual bool CompareValueToValue(TValue value1, TValue value2);
    protected abstract virtual TValue CreateValueFromKey(TKey key);
    protected abstract virtual IntPtr ConvertValueToIntPtr(TValue value);
    protected abstract virtual TValue ConvertIntPtrToValue(IntPtr pointer);
}
public abstract class Internal.TypeSystem.MethodDesc : TypeSystemEntity {
    public static MethodDesc[] EmptyMethods;
    private int _hashcode;
    private IntPtr _functionPointer;
    private IntPtr _usgFunctionPointer;
    private Nullable`1<bool> _isNonSharableCache;
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public bool IsConstructor { get; }
    public bool IsDefaultConstructor { get; }
    public bool IsStaticConstructor { get; }
    public string Name { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsPublic { get; }
    public bool IsMethodDefinition { get; }
    public bool IsTypicalMethodDefinition { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsFinalizer { get; }
    public IntPtr FunctionPointer { get; }
    public IntPtr UsgFunctionPointer { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public bool IsNonSharableMethod { get; }
    public bool UnboxingStub { get; }
    private static MethodDesc();
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    protected void SetHashCode(int hashcode);
    public sealed virtual int GetHashCode();
    private int AcquireHashCode();
    protected virtual int ComputeHashCode();
    public virtual bool Equals(object o);
    public abstract virtual TypeDesc get_OwningType();
    public abstract virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    public bool get_IsConstructor();
    public virtual bool get_IsDefaultConstructor();
    public virtual bool get_IsStaticConstructor();
    public virtual string get_Name();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool get_IsPublic();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetMethodDefinition();
    public bool get_IsMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public bool get_IsTypicalMethodDefinition();
    public bool get_IsGenericMethodDefinition();
    public bool get_IsFinalizer();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public void SetFunctionPointer(IntPtr functionPointer, bool isFunctionPointerUSG);
    public IntPtr get_FunctionPointer();
    public IntPtr get_UsgFunctionPointer();
    public abstract virtual MethodNameAndSignature get_NameAndSignature();
    public virtual bool get_IsNonSharableMethod();
    protected virtual bool ComputeIsNonSharableMethod();
    public virtual bool get_UnboxingStub();
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.MethodDescExtensions : object {
    [ExtensionAttribute]
public static bool CanShareNormalGenericCode(InstantiatedMethod method);
}
public class Internal.TypeSystem.MethodForInstantiatedType : MethodDesc {
    private MethodDesc _typicalMethodDef;
    private InstantiatedType _instantiatedType;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsPublic { get; }
    public bool IsDefaultConstructor { get; }
    public bool IsStaticConstructor { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool get_IsPublic();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual bool get_IsDefaultConstructor();
    public virtual bool get_IsStaticConstructor();
    public virtual string get_Name();
    public virtual MethodNameAndSignature get_NameAndSignature();
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.MethodSignature : TypeSystemEntity {
    internal MethodSignatureFlags _flags;
    internal int _genericParameterCount;
    internal TypeDesc _returnType;
    internal TypeDesc[] _parameters;
    internal EmbeddedSignatureData[] _embeddedSignatureData;
    public static string IndexOfCustomModifiersOnReturnType;
    public static EmbeddedSignatureData[] EmbeddedSignatureMismatchPermittedFlag;
    public MethodSignatureFlags Flags { get; }
    public bool IsStatic { get; }
    public int GenericParameterCount { get; }
    public TypeDesc ReturnType { get; }
    public TypeDesc Parameter { get; }
    public int Length { get; }
    public bool HasEmbeddedSignatureData { get; }
    public bool EmbeddedSignatureMismatchPermitted { get; }
    public TypeSystemContext Context { get; }
    public MethodSignature(MethodSignatureFlags flags, int genericParameterCount, TypeDesc returnType, TypeDesc[] parameters, EmbeddedSignatureData[] embeddedSignatureData);
    private static MethodSignature();
    public static string GetIndexOfCustomModifierOnPointedAtTypeByParameterIndex(int parameterIndex);
    public MethodSignature ApplySubstitution(Instantiation substitution);
    public MethodSignatureFlags get_Flags();
    public bool get_IsStatic();
    public int get_GenericParameterCount();
    public TypeDesc get_ReturnType();
    public TypeDesc get_Parameter(int index);
    public int get_Length();
    public bool get_HasEmbeddedSignatureData();
    public bool get_EmbeddedSignatureMismatchPermitted();
    public EmbeddedSignatureData[] GetEmbeddedSignatureData();
    public EmbeddedSignatureData[] GetEmbeddedSignatureData(ReadOnlySpan`1<EmbeddedSignatureDataKind> kinds);
    public sealed virtual bool Equals(MethodSignature otherSignature);
    public bool EquivalentWithCovariantReturnType(MethodSignature otherSignature);
    public bool EquivalentTo(MethodSignature otherSignature);
    internal bool EquivalentTo(MethodSignature otherSignature, StackOverflowProtect visited);
    private bool Equals(MethodSignature otherSignature, bool allowCovariantReturn, bool allowEquivalence, StackOverflowProtect visited);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SignatureEnumerator GetEnumerator();
    public virtual TypeSystemContext get_Context();
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__IsTypeEqualHelper|32_0(TypeDesc type1, TypeDesc type2, bool allowEquivalence, StackOverflowProtect visited);
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.MethodSignatureBuilder : ValueType {
    private MethodSignature _template;
    private MethodSignatureFlags _flags;
    private int _genericParameterCount;
    private TypeDesc _returnType;
    private TypeDesc[] _parameters;
    private EmbeddedSignatureData[] _embeddedSignatureData;
    unknown MethodSignatureFlags Flags {public set; }
    unknown TypeDesc ReturnType {public set; }
    unknown TypeDesc Parameter {public set; }
    unknown int Length {public set; }
    public MethodSignatureBuilder(MethodSignature template);
    public void set_Flags(MethodSignatureFlags value);
    public void set_ReturnType(TypeDesc value);
    public void set_Parameter(int index, TypeDesc value);
    public void set_Length(int value);
    public void SetEmbeddedSignatureData(EmbeddedSignatureData[] embeddedSignatureData);
    public MethodSignature ToSignature();
}
[FlagsAttribute]
public enum Internal.TypeSystem.MethodSignatureFlags : Enum {
    public int value__;
    public static MethodSignatureFlags None;
    public static MethodSignatureFlags UnmanagedCallingConventionMask;
    public static MethodSignatureFlags UnmanagedCallingConventionCdecl;
    public static MethodSignatureFlags UnmanagedCallingConventionStdCall;
    public static MethodSignatureFlags UnmanagedCallingConventionThisCall;
    public static MethodSignatureFlags CallingConventionVarargs;
    public static MethodSignatureFlags UnmanagedCallingConvention;
    public static MethodSignatureFlags Static;
}
public abstract class Internal.TypeSystem.ModuleDesc : TypeSystemEntity {
    [CompilerGeneratedAttribute]
private TypeSystemContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyDesc <Assembly>k__BackingField;
    public TypeSystemContext Context { get; }
    public IAssemblyDesc Assembly { get; }
    public ModuleDesc(TypeSystemContext context, IAssemblyDesc assembly);
    [CompilerGeneratedAttribute]
public virtual TypeSystemContext get_Context();
    [CompilerGeneratedAttribute]
public virtual IAssemblyDesc get_Assembly();
    public DefType GetType(string nameSpace, string name, bool throwIfNotFound);
    public abstract virtual object GetType(string nameSpace, string name, NotFoundBehavior notFoundBehavior);
    public abstract virtual DefType GetGlobalModuleType();
    public abstract virtual IEnumerable`1<DefType> GetAllTypes();
}
internal abstract class Internal.TypeSystem.NoMetadata.NoMetadataMethodDesc : MethodDesc {
}
internal class Internal.TypeSystem.NoMetadata.NoMetadataType : DefType {
    private TypeSystemContext _context;
    private int _hashcode;
    private RuntimeTypeHandle _genericTypeDefinition;
    private DefType _genericTypeDefinitionAsDefType;
    private Instantiation _instantiation;
    private DefType _baseType;
    public TypeSystemContext Context { get; }
    public DefType BaseType { get; }
    public Instantiation Instantiation { get; }
    public TypeDesc UnderlyingType { get; }
    public string NamespaceForDiagnostics { get; }
    public string NameForDiagnostics { get; }
    public string DiagnosticModuleName { get; }
    public NoMetadataType(TypeSystemContext context, RuntimeTypeHandle genericTypeDefinition, int instantiationLength, ReadOnlySpan`1<GenericVariance> runtimeVarianceData, int hashcode);
    public NoMetadataType(TypeSystemContext context, RuntimeTypeHandle genericTypeDefinition, DefType genericTypeDefinitionAsDefType, Instantiation instantiation, int hashcode);
    private void Init(TypeSystemContext context, RuntimeTypeHandle genericTypeDefinition, DefType genericTypeDefinitionAsDefType, Instantiation instantiation, int hashcode);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_BaseType();
    internal virtual void ParseBaseType(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser baseTypeParser);
    public void SetBaseType(DefType baseType);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual TypeDesc GetTypeDefinition();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual Instantiation get_Instantiation();
    public virtual TypeDesc get_UnderlyingType();
    private void GetTypeNameHelper(String& name, String& nsName, String& assemblyName);
    public string get_NamespaceForDiagnostics();
    public string get_NameForDiagnostics();
    public string get_DiagnosticModuleName();
}
internal class Internal.TypeSystem.NoMetadata.RuntimeMethodDesc : NoMetadataMethodDesc {
    private Instantiation _instantiation;
    private TypeDesc _owningType;
    private MethodNameAndSignature _nameAndSignature;
    private bool _unboxingStub;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public string Name { get; }
    public bool UnboxingStub { get; }
    public RuntimeMethodDesc(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual MethodNameAndSignature get_NameAndSignature();
    public virtual string get_Name();
    public virtual bool get_UnboxingStub();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
public enum Internal.TypeSystem.NotFoundBehavior : Enum {
    public int value__;
    public static NotFoundBehavior Throw;
    public static NotFoundBehavior ReturnNull;
    public static NotFoundBehavior ReturnResolutionFailure;
}
public abstract class Internal.TypeSystem.ParameterizedType : TypeDesc {
    private TypeDesc _parameterType;
    public TypeDesc ParameterType { get; }
    public TypeSystemContext Context { get; }
    internal ParameterizedType(TypeDesc parameterType);
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public TypeDesc get_ParameterType();
    public virtual TypeSystemContext get_Context();
}
public class Internal.TypeSystem.PointerType : ParameterizedType {
    internal PointerType(TypeDesc parameterType);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
internal class Internal.TypeSystem.RuntimeGenericParameterDesc : GenericParameterDesc {
    private GenericParameterKind _kind;
    private int _index;
    private GenericVariance _variance;
    private TypeSystemEntity _associatedTypeOrMethod;
    public GenericParameterKind Kind { get; }
    public int Index { get; }
    public TypeSystemContext Context { get; }
    public GenericVariance Variance { get; }
    public TypeSystemEntity AssociatedTypeOrMethod { get; }
    public RuntimeGenericParameterDesc(GenericParameterKind kind, int index, TypeSystemEntity associatedTypeOrMethod, GenericVariance variance);
    public virtual GenericParameterKind get_Kind();
    public virtual int get_Index();
    public virtual TypeSystemContext get_Context();
    public virtual GenericVariance get_Variance();
    public virtual TypeSystemEntity get_AssociatedTypeOrMethod();
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.RuntimeHandleExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static bool IsDynamic(RuntimeFieldHandle rtfh);
    [ExtensionAttribute]
public static bool IsDynamic(RuntimeMethodHandle rtmh);
}
public abstract class Internal.TypeSystem.RuntimeInterfacesAlgorithm : object {
    public abstract virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
public class Internal.TypeSystem.SignatureMethodVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    internal SignatureMethodVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class Internal.TypeSystem.SignatureTypeVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    internal SignatureTypeVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public abstract class Internal.TypeSystem.SignatureVariable : TypeDesc {
    private TypeSystemContext _context;
    private int _index;
    public int Index { get; }
    public TypeSystemContext Context { get; }
    public bool IsMethodSignatureVariable { get; }
    internal SignatureVariable(TypeSystemContext context, int index);
    public int get_Index();
    public virtual TypeSystemContext get_Context();
    public abstract virtual bool get_IsMethodSignatureVariable();
}
internal class Internal.TypeSystem.StackOverflowProtect : object {
    private CastingPair _value;
    private StackOverflowProtect _previous;
    public StackOverflowProtect(CastingPair value, StackOverflowProtect previous);
    public static StackOverflowProtect GetTypeEquivalentForbiddenScope(StackOverflowProtect previous);
    public bool Contains(CastingPair value);
}
public static class Internal.TypeSystem.StandardCanonicalizationAlgorithm : object {
    public static Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    public static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    private static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
}
public enum Internal.TypeSystem.TargetAbi : Enum {
    public int value__;
    public static TargetAbi Unknown;
    public static TargetAbi NativeAot;
    public static TargetAbi NativeAotArmel;
    public static TargetAbi Jit;
    public static TargetAbi CppCodegen;
}
public enum Internal.TypeSystem.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture Unknown;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARM64;
    public static TargetArchitecture X64;
    public static TargetArchitecture X86;
    public static TargetArchitecture Wasm32;
    public static TargetArchitecture LoongArch64;
}
public class Internal.TypeSystem.TargetDetails : object {
    [CompilerGeneratedAttribute]
private TargetArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetOS <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetAbi <Abi>k__BackingField;
    public TargetArchitecture Architecture { get; }
    public TargetOS OperatingSystem { get; }
    public TargetAbi Abi { get; }
    public int PointerSize { get; }
    public bool SupportsRelativePointers { get; }
    public int MaximumAlignment { get; }
    public LayoutInt LayoutPointerSize { get; }
    public int DefaultPackingSize { get; }
    public int MinimumFunctionAlignment { get; }
    public int OptimumFunctionAlignment { get; }
    public int MinimumCodeAlignment { get; }
    public static int MaximumLog2PrimitiveSize { get; }
    public static int MaximumPrimitiveSize { get; }
    public bool IsWindows { get; }
    public bool IsOSXLike { get; }
    public int MaxHomogeneousAggregateElementCount { get; }
    public int CodeDelta { get; }
    public TargetDetails(TargetArchitecture architecture, TargetOS targetOS, TargetAbi abi);
    [CompilerGeneratedAttribute]
public TargetArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public TargetOS get_OperatingSystem();
    [CompilerGeneratedAttribute]
public TargetAbi get_Abi();
    public int get_PointerSize();
    public bool get_SupportsRelativePointers();
    public int get_MaximumAlignment();
    public LayoutInt get_LayoutPointerSize();
    public int get_DefaultPackingSize();
    public int get_MinimumFunctionAlignment();
    public int get_OptimumFunctionAlignment();
    public int get_MinimumCodeAlignment();
    public static int get_MaximumLog2PrimitiveSize();
    public static int get_MaximumPrimitiveSize();
    public LayoutInt GetWellKnownTypeSize(DefType type);
    public LayoutInt GetWellKnownTypeAlignment(DefType type);
    public LayoutInt GetObjectAlignment(LayoutInt fieldAlignment);
    public bool get_IsWindows();
    public bool get_IsOSXLike();
    public int get_MaxHomogeneousAggregateElementCount();
    public int get_CodeDelta();
}
public enum Internal.TypeSystem.TargetOS : Enum {
    public int value__;
    public static TargetOS Unknown;
    public static TargetOS Windows;
    public static TargetOS Linux;
    public static TargetOS OSX;
    public static TargetOS MacCatalyst;
    public static TargetOS iOS;
    public static TargetOS iOSSimulator;
    public static TargetOS tvOS;
    public static TargetOS tvOSSimulator;
    public static TargetOS FreeBSD;
    public static TargetOS NetBSD;
    public static TargetOS SunOS;
    public static TargetOS WebAssembly;
}
public class Internal.TypeSystem.ThreadSafeFlags : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public int Value { get; }
    public int get_Value();
    public bool HasFlags(int value);
    public void AddFlags(int flagsToAdd);
}
public static class Internal.TypeSystem.ThrowHelper : object {
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string nestedTypeName, ModuleDesc module);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string namespace, string name, ModuleDesc module);
    public static void ThrowTypeLoadException(string namespace, string name, string moduleName);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(TypeDesc type);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, MethodDesc method);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type, string messageArg);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type);
    private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName, string messageArg);
    private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName);
    public static void ThrowMissingMethodException(TypeDesc owningType, string methodName, MethodSignature signature);
    public static void ThrowMissingFieldException(TypeDesc owningType, string fieldName);
    public static void ThrowFileNotFoundException(ExceptionStringID id, string fileName);
    public static void ThrowInvalidProgramException();
    public static void ThrowInvalidProgramException(ExceptionStringID id, MethodDesc method);
    public static void ThrowBadImageFormatException();
}
public abstract class Internal.TypeSystem.TypeDesc : TypeSystemEntity {
    private TypeDesc _specificCanonCache;
    private TypeDesc _universalCanonCache;
    public static TypeDesc[] EmptyTypes;
    private TypeFlags _typeFlags;
    private DefType[] _runtimeInterfaces;
    private RuntimeTypeHandle _runtimeTypeHandle;
    [CompilerGeneratedAttribute]
private TypeBuilderState <TypeBuilderState>k__BackingField;
    internal bool IsCanonicalType { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public TypeFlags Category { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsPrimitive { get; }
    public bool IsPrimitiveNumeric { get; }
    public bool IsEnum { get; }
    public bool IsDelegate { get; }
    public bool IsVoid { get; }
    public bool IsString { get; }
    public bool IsObject { get; }
    public bool IsTypedReference { get; }
    public bool IsNullable { get; }
    public bool IsArray { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsFunctionPointer { get; }
    public bool IsSignatureVariable { get; }
    public bool IsGenericParameter { get; }
    public bool IsParameterizedType { get; }
    public bool IsDefType { get; }
    public bool IsGCPointer { get; }
    public DefType BaseType { get; }
    public bool HasBaseType { get; }
    public TypeDesc UnderlyingType { get; }
    public bool HasStaticConstructor { get; }
    public bool IsTypeDefinition { get; }
    public bool HasFinalizer { get; }
    public bool HasVariance { get; }
    public bool IsGenericDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsIDynamicInterfaceCastable { get; }
    public DefType[] RuntimeInterfaces { get; }
    public RuntimeTypeHandle RuntimeTypeHandle { get; }
    internal TypeBuilderState TypeBuilderState { get; internal set; }
    private static TypeDesc();
    private TypeDesc GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, TypeDesc value);
    public TypeDesc ConvertToCanonForm(CanonicalFormKind kind);
    protected abstract virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public abstract virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    internal bool get_IsCanonicalType();
    public abstract virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    internal void SetWellKnownType(WellKnownType wellKnownType);
    protected abstract virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private TypeFlags InitializeTypeFlags(TypeFlags mask);
    protected internal TypeFlags GetTypeFlags(TypeFlags mask);
    public TypeFlags get_Category();
    public bool get_IsInterface();
    public bool get_IsValueType();
    public bool get_IsPrimitive();
    public bool get_IsPrimitiveNumeric();
    public bool get_IsEnum();
    public bool get_IsDelegate();
    public bool get_IsVoid();
    public bool get_IsString();
    public bool get_IsObject();
    public bool get_IsTypedReference();
    public bool get_IsNullable();
    public bool get_IsArray();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public bool get_IsByRef();
    public bool get_IsPointer();
    public bool get_IsFunctionPointer();
    public bool get_IsSignatureVariable();
    public bool get_IsGenericParameter();
    public bool get_IsParameterizedType();
    public bool get_IsDefType();
    public bool get_IsGCPointer();
    public virtual DefType get_BaseType();
    public bool get_HasBaseType();
    public virtual TypeDesc get_UnderlyingType();
    public bool get_HasStaticConstructor();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    [IteratorStateMachineAttribute("Internal.TypeSystem.TypeDesc/<GetVirtualMethods>d__76")]
public virtual IEnumerable`1<MethodDesc> GetVirtualMethods();
    public MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetMethod(string name, MethodSignature signature, Instantiation substitution);
    public virtual MethodDesc GetMethodWithEquivalentSignature(string name, MethodSignature signature, Instantiation substitution);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public bool get_IsTypeDefinition();
    public bool HasSameTypeDefinition(TypeDesc otherType);
    public bool get_HasFinalizer();
    public virtual MethodDesc GetFinalizer();
    public bool get_HasVariance();
    public bool get_IsGenericDefinition();
    public bool get_IsByRefLike();
    public bool get_IsIDynamicInterfaceCastable();
    public DefType[] get_RuntimeInterfaces();
    private DefType[] InitializeRuntimeInterfaces();
    public RuntimeTypeHandle get_RuntimeTypeHandle();
    public void SetRuntimeTypeHandleUnsafe(RuntimeTypeHandle runtimeTypeHandle);
    public RuntimeTypeHandle GetRuntimeTypeHandle();
    [CompilerGeneratedAttribute]
internal TypeBuilderState get_TypeBuilderState();
    [CompilerGeneratedAttribute]
internal void set_TypeBuilderState(TypeBuilderState value);
    internal bool RetrieveRuntimeTypeHandleIfPossible();
    internal TypeBuilderState GetTypeBuilderStateIfExist();
    internal TypeBuilderState GetTypeBuilderState();
    internal TypeBuilderState GetOrCreateTypeBuilderState();
    internal virtual void ParseBaseType(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser baseTypeParser);
    internal TypeDesc ComputeTemplate(bool templateRequired);
    internal static TypeDesc ComputeTemplate(TypeBuilderState state, bool templateRequired);
    internal bool IsTemplateUniversal();
    internal bool IsTemplateCanonical();
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.TypeDescExtensions : object {
    [ExtensionAttribute]
public static bool CanShareNormalGenericCode(TypeDesc type);
    [ExtensionAttribute]
public static bool IsGeneric(TypeDesc type);
    [ExtensionAttribute]
public static bool IsWellKnownType(TypeDesc type, WellKnownType wellKnownType);
    [ExtensionAttribute]
public static ByRefType MakeByRefType(TypeDesc type);
    [ExtensionAttribute]
public static TypeDesc GetParameterType(TypeDesc type);
}
[FlagsAttribute]
public enum Internal.TypeSystem.TypeFlags : Enum {
    public int value__;
    public static TypeFlags CategoryMask;
    public static TypeFlags Unknown;
    public static TypeFlags Void;
    public static TypeFlags Boolean;
    public static TypeFlags Char;
    public static TypeFlags SByte;
    public static TypeFlags Byte;
    public static TypeFlags Int16;
    public static TypeFlags UInt16;
    public static TypeFlags Int32;
    public static TypeFlags UInt32;
    public static TypeFlags Int64;
    public static TypeFlags UInt64;
    public static TypeFlags IntPtr;
    public static TypeFlags UIntPtr;
    public static TypeFlags Single;
    public static TypeFlags Double;
    public static TypeFlags ValueType;
    public static TypeFlags Enum;
    public static TypeFlags Nullable;
    public static TypeFlags Class;
    public static TypeFlags Interface;
    public static TypeFlags Array;
    public static TypeFlags SzArray;
    public static TypeFlags ByRef;
    public static TypeFlags Pointer;
    public static TypeFlags FunctionPointer;
    public static TypeFlags GenericParameter;
    public static TypeFlags SignatureTypeVariable;
    public static TypeFlags SignatureMethodVariable;
    public static TypeFlags HasGenericVariance;
    public static TypeFlags HasGenericVarianceComputed;
    public static TypeFlags HasStaticConstructor;
    public static TypeFlags HasStaticConstructorComputed;
    public static TypeFlags HasFinalizerComputed;
    public static TypeFlags HasFinalizer;
    public static TypeFlags IsByRefLike;
    public static TypeFlags IsInlineArray;
    public static TypeFlags IsIntrinsic;
    public static TypeFlags AttributeCacheComputed;
    public static TypeFlags IsIDynamicInterfaceCastable;
    public static TypeFlags IsIDynamicInterfaceCastableComputed;
}
public abstract class Internal.TypeSystem.TypeNameFormatter : object {
    public void AppendName(StringBuilder sb, TypeDesc type);
    public void AppendName(StringBuilder sb, DefType type);
    public abstract virtual void AppendName(StringBuilder sb, ArrayType type);
    public abstract virtual void AppendName(StringBuilder sb, ByRefType type);
    public abstract virtual void AppendName(StringBuilder sb, PointerType type);
    public abstract virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public abstract virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    protected abstract virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    protected abstract virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected abstract virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    public string FormatName(TypeDesc type);
}
public abstract class Internal.TypeSystem.TypeNameFormatter`2 : object {
    public TState AppendName(StringBuilder sb, TypeDesc type, TOptions options);
    public TState AppendName(StringBuilder sb, DefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ArrayType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ByRefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, PointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, FunctionPointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, GenericParameterDesc type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureMethodVariable type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureTypeVariable type, TOptions options);
    protected abstract virtual TState AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType, TOptions options);
    protected abstract virtual TState AppendNameForNamespaceType(StringBuilder sb, DefType type, TOptions options);
    protected abstract virtual TState AppendNameForInstantiatedType(StringBuilder sb, DefType type, TOptions options);
    protected virtual DefType GetContainingType(DefType possibleInnerType, TOptions options);
    public string FormatName(TypeDesc type, TOptions options);
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.TypeNameHelper : object {
    [ExtensionAttribute]
public static T WithDebugName(T type);
}
public abstract class Internal.TypeSystem.TypeSystemContext : object {
    private CanonType _canonType;
    private UniversalCanonType _universalCanonType;
    [CompilerGeneratedAttribute]
private TargetDetails <Target>k__BackingField;
    private ArrayTypeKeyHashtable _arrayTypes;
    private ByRefHashtable _byRefTypes;
    private PointerHashtable _pointerTypes;
    private FunctionPointerHashtable _functionPointerTypes;
    private InstantiatedTypeKeyHashtable _instantiatedTypes;
    private InstantiatedMethodKeyHashtable _instantiatedMethods;
    private MethodForInstantiatedTypeKeyHashtable _methodForInstantiatedTypes;
    private FieldForInstantiatedTypeKeyHashtable _fieldForInstantiatedTypes;
    private SignatureVariableHashtable _signatureVariables;
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable[] s_ArrayTypesCaches;
    [CompilerGeneratedAttribute]
private static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable <PointerTypesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable <ByRefTypesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private static FunctionPointerRuntimeTypeHandleHashtable <FunctionPointerTypesCache>k__BackingField;
    private LowLevelDictionary`2<RuntimeTypeHandle, TypeDesc> _runtimeTypeHandleResolutionCache;
    private RuntimeMethodKeyHashtable _runtimeMethods;
    private LowLevelDictionary`2<GenericTypeInstanceKey, DefType> _genericTypeInstances;
    private LowLevelList`1<TypeDesc> _typesToFlushTypeSystemStateFrom;
    public CanonBaseType CanonType { get; }
    public CanonBaseType UniversalCanonType { get; }
    public bool SupportsCanon { get; }
    public bool SupportsUniversalCanon { get; }
    public TargetDetails Target { get; }
    public bool SupportsTypeEquivalence { get; }
    public bool SupportsCOMInterop { get; }
    internal static TemplateLocator TemplateLookup { get; }
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable PointerTypesCache { get; }
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable ByRefTypesCache { get; }
    internal static FunctionPointerRuntimeTypeHandleHashtable FunctionPointerTypesCache { get; }
    public int LoadFactor { get; }
    public TypeSystemContext(TargetDetails target);
    private static TypeSystemContext();
    public CanonBaseType get_CanonType();
    public CanonBaseType get_UniversalCanonType();
    public bool IsCanonicalDefinitionType(TypeDesc type, CanonicalFormKind kind);
    public Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    public abstract virtual bool get_SupportsCanon();
    public abstract virtual bool get_SupportsUniversalCanon();
    public DefType GetCanonType(string name);
    [CompilerGeneratedAttribute]
public TargetDetails get_Target();
    public abstract virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    public ArrayType GetArrayType(TypeDesc elementType);
    public ArrayType GetArrayType(TypeDesc elementType, int rank);
    public ByRefType GetByRefType(TypeDesc parameterType);
    public PointerType GetPointerType(TypeDesc parameterType);
    public FunctionPointerType GetFunctionPointerType(MethodSignature signature);
    public InstantiatedType GetInstantiatedType(DefType typeDef, Instantiation instantiation);
    public InstantiatedMethod GetInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    public MethodDesc GetMethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    public FieldDesc GetFieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public TypeDesc GetSignatureVariable(int index, bool method);
    protected internal virtual IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    protected internal virtual IEnumerable`1<MethodDesc> GetAllVirtualMethods(TypeDesc type);
    public RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForType(TypeDesc type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected internal virtual bool ComputeHasGCStaticBase(FieldDesc field);
    internal TypeFlags ComputeTypeFlags(TypeDesc type, TypeFlags flags, TypeFlags mask);
    protected internal abstract virtual bool ComputeHasStaticConstructor(TypeDesc type);
    protected internal abstract virtual bool IsIDynamicInterfaceCastableInterface(DefType type);
    public virtual bool get_SupportsTypeEquivalence();
    public virtual bool get_SupportsCOMInterop();
    internal static TemplateLocator get_TemplateLookup();
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable GetArrayTypesCache(bool isMdArray, int rank);
    [CompilerGeneratedAttribute]
internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable get_PointerTypesCache();
    [CompilerGeneratedAttribute]
internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable get_ByRefTypesCache();
    [CompilerGeneratedAttribute]
internal static FunctionPointerRuntimeTypeHandleHashtable get_FunctionPointerTypesCache();
    public TypeDesc[] ResolveRuntimeTypeHandlesInternal(RuntimeTypeHandle[] runtimeTypeHandles);
    public Instantiation ResolveRuntimeTypeHandles(RuntimeTypeHandle[] runtimeTypeHandles);
    public TypeDesc ResolveRuntimeTypeHandle(RuntimeTypeHandle rtth);
    internal MethodDesc ResolveRuntimeMethod(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, IntPtr functionPointer, bool usgFunctionPointer);
    public DefType ResolveGenericInstantiation(DefType typeDef, Instantiation arguments);
    public MethodDesc ResolveGenericMethodInstantiation(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, Instantiation methodInstantiation, IntPtr functionPointer, bool usgFunctionPointer);
    public virtual int get_LoadFactor();
    internal void RegisterTypeForTypeSystemStateFlushing(TypeDesc type);
    internal void FlushTypeBuilderStates();
}
public abstract class Internal.TypeSystem.TypeSystemEntity : object {
    public TypeSystemContext Context { get; }
    public abstract virtual TypeSystemContext get_Context();
}
internal class Internal.TypeSystem.UniversalCanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public DefType BaseType { get; }
    public UniversalCanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    private void Initialize();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
}
public abstract class Internal.TypeSystem.VirtualMethodAlgorithm : object {
    public abstract virtual MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveInterfaceMethodToStaticVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveVariantInterfaceMethodToStaticVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual DefaultInterfaceMethodResolution ResolveInterfaceMethodToDefaultImplementationOnType(MethodDesc interfaceMethod, TypeDesc currentType, MethodDesc& impl);
    public abstract virtual DefaultInterfaceMethodResolution ResolveVariantInterfaceMethodToDefaultImplementationOnType(MethodDesc interfaceMethod, TypeDesc currentType, MethodDesc& impl);
    public abstract virtual MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, TypeDesc objectType);
    public abstract virtual IEnumerable`1<MethodDesc> ComputeAllVirtualSlots(TypeDesc type);
}
public enum Internal.TypeSystem.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Unknown;
    public static WellKnownType Void;
    public static WellKnownType Boolean;
    public static WellKnownType Char;
    public static WellKnownType SByte;
    public static WellKnownType Byte;
    public static WellKnownType Int16;
    public static WellKnownType UInt16;
    public static WellKnownType Int32;
    public static WellKnownType UInt32;
    public static WellKnownType Int64;
    public static WellKnownType UInt64;
    public static WellKnownType IntPtr;
    public static WellKnownType UIntPtr;
    public static WellKnownType Single;
    public static WellKnownType Double;
    public static WellKnownType ValueType;
    public static WellKnownType Enum;
    public static WellKnownType Nullable;
    public static WellKnownType Object;
    public static WellKnownType String;
    public static WellKnownType Array;
    public static WellKnownType MulticastDelegate;
    public static WellKnownType RuntimeTypeHandle;
    public static WellKnownType RuntimeMethodHandle;
    public static WellKnownType RuntimeFieldHandle;
    public static WellKnownType Exception;
    public static WellKnownType TypedReference;
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _items;
    private int _count;
    public int Count { get; }
    public T Item { get; public set; }
    public T[] ToArray();
    public void Add(T item);
    public void Append(T[] newItems);
    public void Append(T[] newItems, int offset, int length);
    public void Append(ArrayBuilder`1<T> newItems);
    public void ZeroExtend(int numItems);
    public void EnsureCapacity(int requestedCapacity);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public bool Contains(T t);
    public bool Any(Func`2<T, bool> func);
}
[ForceDictionaryLookupsAttribute]
internal static class System.Collections.Generic.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
[DefaultMemberAttribute("Item")]
[ForceDictionaryLookupsAttribute]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ForceDictionaryLookupsAttribute]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    private void EnsureCapacity(int min);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
internal static class System.SR : object {
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string FileNotFound_AssemblyNotFound { get; }
    internal static string FileLoadException_RefDefMismatch { get; }
    internal static string AmbiguousMatchException_Assembly { get; }
    private static SR();
    private static string InternalGetResourceString(string key);
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_FileNotFound_AssemblyNotFound();
    internal static string get_FileLoadException_RefDefMismatch();
    internal static string get_AmbiguousMatchException_Assembly();
}
[ExtensionAttribute]
internal static class System.TypeLoaderFormattingHelpers : object {
    [ExtensionAttribute]
public static string ToStringInvariant(int arg);
    [ExtensionAttribute]
public static string ToStringInvariant(UInt32 arg);
    [ExtensionAttribute]
public static string ToStringInvariant(byte arg);
    [ExtensionAttribute]
public static string ToStringInvariant(ushort arg);
    [ExtensionAttribute]
public static string ToStringInvariant(ulong arg);
    [ExtensionAttribute]
public static string ToStringInvariant(float _);
    [ExtensionAttribute]
public static string ToStringInvariant(double _);
}
