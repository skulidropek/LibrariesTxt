internal static class FxResources.System.IO.FileSystem.SR : object {
}
internal static class Interop : object {
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandle {
    private Nullable`1<bool> _isAsync;
    [CompilerGeneratedAttribute]
private ThreadPoolBoundHandle <ThreadPoolBinding>k__BackingField;
    internal Nullable`1<bool> IsAsync { get; internal set; }
    internal ThreadPoolBoundHandle ThreadPoolBinding { get; internal set; }
    public bool IsInvalid { get; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    internal Nullable`1<bool> get_IsAsync();
    internal void set_IsAsync(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal ThreadPoolBoundHandle get_ThreadPoolBinding();
    [CompilerGeneratedAttribute]
internal void set_ThreadPoolBinding(ThreadPoolBoundHandle value);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
internal static class System.HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_HANDLE;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_INVALIDARG;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
public static class System.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    [SecuritySafeCriticalAttribute]
public static DirectoryInfo CreateDirectory(string path);
    internal static string EnsureTrailingDirectorySeparator(string fullPath);
    [SecuritySafeCriticalAttribute]
public static bool Exists(string path);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    private static String[] InternalGetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    private static String[] InternalGetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private static String[] InternalGetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    internal static String[] InternalGetFileDirectoryNames(string path, string userPathOriginal, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    private static IEnumerable`1<string> InternalEnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    private static IEnumerable`1<string> InternalEnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private static IEnumerable`1<string> InternalEnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private static IEnumerable`1<string> EnumerateFileSystemNames(string path, string searchPattern, SearchOption searchOption, bool includeFiles, bool includeDirs);
    [SecuritySafeCriticalAttribute]
public static string GetDirectoryRoot(string path);
    internal static string InternalGetDirectoryRoot(string path);
    [SecuritySafeCriticalAttribute]
public static string GetCurrentDirectory();
    [SecurityCriticalAttribute]
public static void SetCurrentDirectory(string path);
    [SecuritySafeCriticalAttribute]
public static void Move(string sourceDirName, string destDirName);
    [SecuritySafeCriticalAttribute]
public static void Delete(string path);
    [SecuritySafeCriticalAttribute]
public static void Delete(string path, bool recursive);
}
public class System.IO.DirectoryInfo : FileSystemInfo {
    public string Name { get; }
    public DirectoryInfo Parent { get; }
    public bool Exists { get; }
    public DirectoryInfo Root { get; }
    [SecuritySafeCriticalAttribute]
public DirectoryInfo(string path);
    [SecuritySafeCriticalAttribute]
internal DirectoryInfo(string fullPath, string originalPath);
    [SecurityCriticalAttribute]
internal DirectoryInfo(string fullPath, WIN32_FIND_DATA& findData);
    public virtual string get_Name();
    [SecuritySafeCriticalAttribute]
public DirectoryInfo get_Parent();
    [SecuritySafeCriticalAttribute]
public DirectoryInfo CreateSubdirectory(string path);
    [SecurityCriticalAttribute]
private DirectoryInfo CreateSubdirectoryHelper(string path);
    [SecurityCriticalAttribute]
public void Create();
    [SecuritySafeCriticalAttribute]
public virtual bool get_Exists();
    [SecurityCriticalAttribute]
public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    private FileInfo[] InternalGetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles();
    public DirectoryInfo[] GetDirectories();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    private FileSystemInfo[] InternalGetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    private DirectoryInfo[] InternalGetDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    private IEnumerable`1<DirectoryInfo> InternalEnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    private IEnumerable`1<FileInfo> InternalEnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    private IEnumerable`1<FileSystemInfo> InternalEnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    [SecuritySafeCriticalAttribute]
public DirectoryInfo get_Root();
    [SecuritySafeCriticalAttribute]
public void MoveTo(string destDirName);
    [SecuritySafeCriticalAttribute]
public virtual void Delete();
    [SecuritySafeCriticalAttribute]
public void Delete(bool recursive);
    public virtual string ToString();
    private static string GetDisplayName(string originalPath);
    private static string GetDirName(string fullPath);
}
internal static class System.IO.Error : object {
    internal static Exception GetEndOfFile();
    internal static Exception GetFileNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
}
public static class System.IO.File : object {
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) _UTF8NoBOM;
    private static Encoding UTF8NoBOM { get; }
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    [SecuritySafeCriticalAttribute]
internal static string InternalCopy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    [SecuritySafeCriticalAttribute]
public static void Delete(string path);
    [SecuritySafeCriticalAttribute]
public static bool Exists(string path);
    [SecurityCriticalAttribute]
internal static bool InternalExists(string path);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static DateTimeOffset GetUtcDateTimeOffset(DateTime dateTime);
    public static void SetCreationTime(string path, DateTime creationTimeUtc);
    public static void SetCreationTimeUtc(string path, DateTime creationTime);
    [SecuritySafeCriticalAttribute]
public static DateTime GetCreationTime(string path);
    [SecuritySafeCriticalAttribute]
public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastAccessTime(string path);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastAccessTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastWriteTime(string path);
    [SecuritySafeCriticalAttribute]
public static DateTime GetLastWriteTimeUtc(string path);
    [SecuritySafeCriticalAttribute]
public static FileAttributes GetAttributes(string path);
    [SecurityCriticalAttribute]
public static void SetAttributes(string path, FileAttributes fileAttributes);
    [SecuritySafeCriticalAttribute]
public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    [SecuritySafeCriticalAttribute]
public static string ReadAllText(string path);
    [SecuritySafeCriticalAttribute]
public static string ReadAllText(string path, Encoding encoding);
    [SecurityCriticalAttribute]
private static string InternalReadAllText(string path, Encoding encoding);
    [SecuritySafeCriticalAttribute]
public static void WriteAllText(string path, string contents);
    [SecuritySafeCriticalAttribute]
public static void WriteAllText(string path, string contents, Encoding encoding);
    [SecurityCriticalAttribute]
private static void InternalWriteAllText(string path, string contents, Encoding encoding);
    [SecuritySafeCriticalAttribute]
public static Byte[] ReadAllBytes(string path);
    [SecurityCriticalAttribute]
private static Byte[] InternalReadAllBytes(string path);
    [SecuritySafeCriticalAttribute]
public static void WriteAllBytes(string path, Byte[] bytes);
    [SecurityCriticalAttribute]
private static void InternalWriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    private static String[] InternalReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    private static void InternalWriteAllLines(TextWriter writer, IEnumerable`1<string> contents);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    private static void InternalAppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    [SecuritySafeCriticalAttribute]
public static void Move(string sourceFileName, string destFileName);
    private static Encoding get_UTF8NoBOM();
}
public class System.IO.FileInfo : FileSystemInfo {
    private string _name;
    public string Name { get; }
    public long Length { get; }
    public string DirectoryName { get; }
    public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public bool Exists { get; }
    [SecuritySafeCriticalAttribute]
public FileInfo(string fileName);
    [SecuritySafeCriticalAttribute]
internal FileInfo(string fullPath, string originalPath);
    [SecurityCriticalAttribute]
internal FileInfo(string fullPath, WIN32_FIND_DATA& findData);
    [SecurityCriticalAttribute]
private void Init(string fileName);
    private string GetDisplayPath(string originalPath);
    public virtual string get_Name();
    [SecuritySafeCriticalAttribute]
public long get_Length();
    [SecuritySafeCriticalAttribute]
public string get_DirectoryName();
    public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    [SecuritySafeCriticalAttribute]
public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    [SecuritySafeCriticalAttribute]
public virtual void Delete();
    [SecuritySafeCriticalAttribute]
public virtual bool get_Exists();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    [SecuritySafeCriticalAttribute]
public FileStream OpenRead();
    public FileStream OpenWrite();
    [SecuritySafeCriticalAttribute]
public void MoveTo(string destFileName);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
public class System.IO.FileStream : Stream {
    internal static int DefaultBufferSize;
    private static FileShare DefaultShare;
    private static bool DefaultUseAsync;
    private static bool DefaultIsAsync;
    private FileStreamBase _innerStream;
    public bool IsAsync { get; }
    public string Name { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public bool CanTimeout { get; }
    public int WriteTimeout { get; public set; }
    internal FileStream(FileStreamBase innerStream);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    private void Init(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    private static void ValidatePath(string fullPath, string paramName);
    internal static FileStream InternalOpen(string path, int bufferSize, bool useAsync);
    internal static FileStream InternalCreate(string path, int bufferSize, bool useAsync);
    internal static FileStream InternalAppend(string path, int bufferSize, bool useAsync);
    public virtual bool get_IsAsync();
    public string get_Name();
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual void Flush(bool flushToDisk);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    [SecuritySafeCriticalAttribute]
protected virtual override void Finalize();
}
internal abstract class System.IO.FileStreamBase : Stream {
    protected FileStream _parent;
    public bool IsAsync { get; }
    public string Name { get; }
    public SafeFileHandle SafeFileHandle { get; }
    protected FileStreamBase(FileStream parent);
    internal void DisposeInternal(bool disposing);
    public abstract virtual bool get_IsAsync();
    public abstract virtual string get_Name();
    public abstract virtual SafeFileHandle get_SafeFileHandle();
    public abstract virtual void Flush(bool flushToDisk);
}
internal abstract class System.IO.FileSystem : object {
    private static FileSystem s_current;
    public static FileSystem Current { get; }
    public int MaxPath { get; }
    public int MaxDirectoryPath { get; }
    private static FileSystem();
    public static FileSystem get_Current();
    public abstract virtual void CreateDirectory(string fullPath);
    public abstract virtual bool DirectoryExists(string fullPath);
    public abstract virtual void MoveDirectory(string sourceFullPath, string destFullPath);
    public abstract virtual void RemoveDirectory(string fullPath, bool recursive);
    public abstract virtual void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    public abstract virtual void DeleteFile(string fullPath);
    public abstract virtual bool FileExists(string fullPath);
    public abstract virtual FileStreamBase Open(string fullPath, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, FileStream parent);
    public abstract virtual void MoveFile(string sourceFullPath, string destFullPath);
    public abstract virtual FileAttributes GetAttributes(string fullPath);
    public abstract virtual void SetAttributes(string fullPath, FileAttributes attributes);
    public abstract virtual DateTimeOffset GetCreationTime(string fullPath);
    public abstract virtual void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public abstract virtual DateTimeOffset GetLastAccessTime(string fullPath);
    public abstract virtual void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public abstract virtual DateTimeOffset GetLastWriteTime(string fullPath);
    public abstract virtual void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public abstract virtual IFileSystemObject GetFileSystemInfo(string fullPath, bool asDirectory);
    public abstract virtual IEnumerable`1<string> EnumeratePaths(string fullPath, string searchPattern, SearchOption searchOption, SearchTarget searchTarget);
    public abstract virtual IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string fullPath, string searchPattern, SearchOption searchOption, SearchTarget searchTarget);
    public abstract virtual string GetCurrentDirectory();
    public abstract virtual void SetCurrentDirectory(string fullPath);
    public abstract virtual int get_MaxPath();
    public abstract virtual int get_MaxDirectoryPath();
}
public abstract class System.IO.FileSystemInfo : object {
    protected string FullPath;
    protected string OriginalPath;
    private string _displayPath;
    private WIN32_FILE_ATTRIBUTE_DATA _data;
    private int _dataInitialized;
    public string FullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public FileAttributes Attributes { get; public set; }
    internal string DisplayPath { get; internal set; }
    private FileAttributes System.IO.IFileSystemObject.Attributes { get; private set; }
    private bool System.IO.IFileSystemObject.Exists { get; }
    private DateTimeOffset System.IO.IFileSystemObject.CreationTime { get; private set; }
    private DateTimeOffset System.IO.IFileSystemObject.LastAccessTime { get; private set; }
    private DateTimeOffset System.IO.IFileSystemObject.LastWriteTime { get; private set; }
    private long System.IO.IFileSystemObject.Length { get; }
    internal IFileSystemObject FileSystemObject { get; }
    [SecuritySafeCriticalAttribute]
public virtual string get_FullName();
    public string get_Extension();
    public abstract virtual string get_Name();
    public abstract virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    [SecuritySafeCriticalAttribute]
public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    [SecuritySafeCriticalAttribute]
public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    [SecuritySafeCriticalAttribute]
public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    public void Refresh();
    [SecuritySafeCriticalAttribute]
public FileAttributes get_Attributes();
    [SecurityCriticalAttribute]
public void set_Attributes(FileAttributes value);
    internal string get_DisplayPath();
    internal void set_DisplayPath(string value);
    [SecurityCriticalAttribute]
internal void Init(WIN32_FIND_DATA& findData);
    private sealed virtual override FileAttributes System.IO.IFileSystemObject.get_Attributes();
    private sealed virtual override void System.IO.IFileSystemObject.set_Attributes(FileAttributes value);
    private sealed virtual override bool System.IO.IFileSystemObject.get_Exists();
    private sealed virtual override DateTimeOffset System.IO.IFileSystemObject.get_CreationTime();
    private sealed virtual override void System.IO.IFileSystemObject.set_CreationTime(DateTimeOffset value);
    private sealed virtual override DateTimeOffset System.IO.IFileSystemObject.get_LastAccessTime();
    private sealed virtual override void System.IO.IFileSystemObject.set_LastAccessTime(DateTimeOffset value);
    private sealed virtual override DateTimeOffset System.IO.IFileSystemObject.get_LastWriteTime();
    private sealed virtual override void System.IO.IFileSystemObject.set_LastWriteTime(DateTimeOffset value);
    private sealed virtual override long System.IO.IFileSystemObject.get_Length();
    private void EnsureDataInitialized();
    private sealed virtual override void System.IO.IFileSystemObject.Refresh();
    internal IFileSystemObject get_FileSystemObject();
    internal void Invalidate();
}
internal interface System.IO.IFileSystemObject {
    public FileAttributes Attributes { get; public set; }
    public DateTimeOffset CreationTime { get; public set; }
    public bool Exists { get; }
    public DateTimeOffset LastAccessTime { get; public set; }
    public DateTimeOffset LastWriteTime { get; public set; }
    public long Length { get; }
    public abstract virtual FileAttributes get_Attributes();
    public abstract virtual void set_Attributes(FileAttributes value);
    public abstract virtual DateTimeOffset get_CreationTime();
    public abstract virtual void set_CreationTime(DateTimeOffset value);
    public abstract virtual bool get_Exists();
    public abstract virtual DateTimeOffset get_LastAccessTime();
    public abstract virtual void set_LastAccessTime(DateTimeOffset value);
    public abstract virtual DateTimeOffset get_LastWriteTime();
    public abstract virtual void set_LastWriteTime(DateTimeOffset value);
    public abstract virtual long get_Length();
    public abstract virtual void Refresh();
}
internal abstract class System.IO.Iterator`1 : object {
    private int _threadId;
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal static class System.IO.PathHelpers : object {
    internal static Char[] DirectorySeparatorChars;
    internal static string DirectorySeparatorCharAsString;
    internal static Char[] TrimEndChars;
    internal static Char[] TrimStartChars;
    private static PathHelpers();
    internal static void ThrowIfEmptyOrRootedPath(string path2);
    internal static bool IsRoot(string path);
    internal static bool EndsInDirectorySeparator(string path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static bool ShouldReviseDirectoryPathToCurrent(string path);
    internal static void CheckSearchPattern(string searchPattern);
    internal static string GetDirectoryNameInternal(string path);
    internal static void SplitDirectoryFile(string path, String& directory, String& file);
    internal static string NormalizeSearchPattern(string searchPattern);
    internal static string GetFullSearchString(string fullPath, string searchPattern);
}
[ExtensionAttribute]
internal static class System.IO.PathInternal : object {
    private static bool s_isCaseSensitive;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int MaxLongPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    internal static int MaxComponentLength;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static PathInternal();
    internal static void CheckInvalidPathChars(string path);
    [ExtensionAttribute]
internal static bool StartsWithOrdinal(StringBuilder builder, string value);
    [ExtensionAttribute]
internal static bool StartsWithOrdinal(string source, string value);
    [ExtensionAttribute]
internal static StringBuilder TrimEnd(StringBuilder builder, Char[] trimChars);
    internal static int FindFileNameIndex(string path);
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    private static bool GetIsCaseSensitive();
    internal static Char[] GetInvalidPathChars();
    internal static bool IsValidDriveChar(char value);
    internal static bool IsPathTooLong(string fullPath);
    internal static bool IsDirectoryTooLong(string fullPath);
    internal static string EnsureExtendedPrefixOverMaxPath(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(string path);
    internal static bool IsExtended(string path);
    internal static bool HasIllegalCharacters(string path);
    internal static bool HasWildCardCharacters(string path);
    internal static int GetRootLength(string path);
    private static UInt32 GetRootLength(Char* path, UInt32 pathLength);
    private static bool StartsWithOrdinal(Char* source, UInt32 sourceLength, string value);
    internal static bool IsPartiallyQualified(string path);
    internal static int PathStartSkip(string path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsDirectoryOrVolumeSeparator(char ch);
}
internal class System.IO.PathPair : ValueType {
    internal string UserPath;
    internal string FullPath;
    internal PathPair(string userPath, string fullPath);
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    private string _path;
    private Encoding _encoding;
    private StreamReader _reader;
    private ReadLinesIterator(string path, Encoding encoding, StreamReader reader);
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
    private static ReadLinesIterator CreateIterator(string path, Encoding encoding, StreamReader reader);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal static class System.IO.SearchResultHandler : object {
    private static SearchResultHandler`1<string> s_filePath;
    private static SearchResultHandler`1<string> s_directoryPath;
    private static SearchResultHandler`1<string> s_fileSystemPath;
    private static SearchResultHandler`1<FileInfo> s_fileInfo;
    private static SearchResultHandler`1<DirectoryInfo> s_directoryInfo;
    private static SearchResultHandler`1<FileSystemInfo> s_fileSystemInfo;
    internal static SearchResultHandler`1<string> FilePath { get; }
    internal static SearchResultHandler`1<string> DirectoryPath { get; }
    internal static SearchResultHandler`1<string> FileSystemPath { get; }
    internal static SearchResultHandler`1<FileInfo> FileInfo { get; }
    internal static SearchResultHandler`1<DirectoryInfo> DirectoryInfo { get; }
    internal static SearchResultHandler`1<FileSystemInfo> FileSystemInfo { get; }
    internal static SearchResultHandler`1<string> get_FilePath();
    internal static SearchResultHandler`1<string> get_DirectoryPath();
    internal static SearchResultHandler`1<string> get_FileSystemPath();
    internal static SearchResultHandler`1<FileInfo> get_FileInfo();
    internal static SearchResultHandler`1<DirectoryInfo> get_DirectoryInfo();
    internal static SearchResultHandler`1<FileSystemInfo> get_FileSystemInfo();
}
internal abstract class System.IO.SearchResultHandler`1 : object {
    [SecurityCriticalAttribute]
internal abstract virtual bool IsResultIncluded(string fullPath, string userPath, WIN32_FIND_DATA& findData, TSource& result);
}
internal enum System.IO.SearchTarget : Enum {
    public int value__;
    public static SearchTarget Files;
    public static SearchTarget Directories;
    public static SearchTarget Both;
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToAsyncArgs(Stream source, Stream destination, int bufferSize);
    public static Task ArrayPoolCopyToAsync(Stream source, Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamHelpers/<ArrayPoolCopyToAsyncCore>d__2")]
private static Task ArrayPoolCopyToAsyncCore(Stream source, Stream destination, int bufferSize, CancellationToken cancellationToken);
}
internal static class System.IO.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    private static int DEFAULT_CAPACITY;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal class System.IO.Win32FileStream : FileStreamBase {
    internal static int DefaultBufferSize;
    internal static bool DefaultUseAsync;
    internal static bool DefaultIsAsync;
    private Byte[] _buffer;
    private string _fileName;
    private bool _isAsync;
    private bool _canRead;
    private bool _canWrite;
    private bool _canSeek;
    private bool _exposedHandle;
    private bool _isPipe;
    private int _readPos;
    private int _readLen;
    private int _writePos;
    private int _bufferSize;
    private SafeFileHandle _handle;
    private long _pos;
    private long _appendStart;
    private static IOCompletionCallback s_ioCallback;
    private Task`1<int> _lastSynchronouslyCompletedTask;
    private Task _activeBufferOperation;
    private PreAllocatedOverlapped _preallocatedOverlapped;
    private FileStreamCompletionSource _currentOverlappedOwner;
    private static int FILE_ATTRIBUTE_NORMAL;
    private static int FILE_ATTRIBUTE_ENCRYPTED;
    private static int FILE_FLAG_OVERLAPPED;
    internal static int GENERIC_READ;
    private static int GENERIC_WRITE;
    private static int FILE_BEGIN;
    private static int FILE_CURRENT;
    private static int FILE_END;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_NO_DATA;
    private static int ERROR_HANDLE_EOF;
    private static int ERROR_INVALID_PARAMETER;
    private static int ERROR_IO_PENDING;
    private bool HasActiveBufferOperation { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public string Name { get; }
    public long Position { get; public set; }
    public SafeFileHandle SafeFileHandle { get; }
    [SecuritySafeCriticalAttribute]
public Win32FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, FileStream parent);
    [SecuritySafeCriticalAttribute]
public Win32FileStream(SafeFileHandle handle, FileAccess access, FileStream parent);
    [SecuritySafeCriticalAttribute]
public Win32FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, FileStream parent);
    [SecuritySafeCriticalAttribute]
public Win32FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync, FileStream parent);
    private Win32FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync, bool suppressBindHandle, FileStream parent);
    private static Win32FileStream();
    private static bool GetDefaultIsAsync(SafeFileHandle handle);
    private static bool GetSuppressBindHandle(SafeFileHandle handle);
    [SecuritySafeCriticalAttribute]
private static SECURITY_ATTRIBUTES GetSecAttrs(FileShare share);
    [SecuritySafeCriticalAttribute]
private void VerifyHandleIsSync();
    private bool get_HasActiveBufferOperation();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_IsAsync();
    [SecuritySafeCriticalAttribute]
public virtual long get_Length();
    [SecuritySafeCriticalAttribute]
public virtual string get_Name();
    [SecuritySafeCriticalAttribute]
public virtual long get_Position();
    public virtual void set_Position(long value);
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    [SecuritySafeCriticalAttribute]
public virtual void Flush(bool flushToDisk);
    private void FlushInternalBuffer();
    [SecuritySafeCriticalAttribute]
private void FlushOSBuffer();
    private void FlushRead();
    private Task FlushWriteAsync(CancellationToken cancellationToken);
    private void FlushWrite(bool calledFromFinalizer);
    [SecurityCriticalAttribute]
public virtual SafeFileHandle get_SafeFileHandle();
    [SecuritySafeCriticalAttribute]
public virtual void SetLength(long value);
    [SecuritySafeCriticalAttribute]
private void SetLengthCore(long value);
    [SecuritySafeCriticalAttribute]
public virtual int Read(Byte[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private int ReadCore(Byte[] buffer, int offset, int count);
    [SecuritySafeCriticalAttribute]
public virtual long Seek(long offset, SeekOrigin origin);
    [SecuritySafeCriticalAttribute]
private long SeekCore(long offset, SeekOrigin origin);
    private void EnsureBufferAllocated();
    private void AllocateBuffer();
    private void VerifyOSHandlePosition();
    [SecuritySafeCriticalAttribute]
public virtual void Write(Byte[] array, int offset, int count);
    [SecuritySafeCriticalAttribute]
private void WriteCore(Byte[] buffer, int offset, int count);
    [SecuritySafeCriticalAttribute]
private Task`1<int> ReadInternalAsync(Byte[] array, int offset, int numBytes, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
private Task`1<int> ReadInternalCoreAsync(Byte[] bytes, int offset, int numBytes, int numBufferedBytesRead, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public virtual int ReadByte();
    [SecuritySafeCriticalAttribute]
private Task WriteInternalAsync(Byte[] array, int offset, int numBytes, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
private Task WriteInternalCoreAsync(Byte[] bytes, int offset, int numBytes, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public virtual void WriteByte(byte value);
    [SecurityCriticalAttribute]
private int ReadFileNative(SafeFileHandle handle, Byte[] bytes, int offset, int count, NativeOverlapped* overlapped, Int32& errorCode);
    [SecurityCriticalAttribute]
private int WriteFileNative(SafeFileHandle handle, Byte[] bytes, int offset, int count, NativeOverlapped* overlapped, Int32& errorCode);
    [SecurityCriticalAttribute]
private int GetLastWin32ErrorAndDisposeHandleIfInvalid(bool throwIfInvalidHandle);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Win32FileStream/<AsyncModeCopyToAsync>d__93")]
private Task AsyncModeCopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    private Task`1<int> TaskFromResultOrCache(int result);
}
internal class System.IO.Win32FileSystem : FileSystem {
    public int MaxPath { get; }
    public int MaxDirectoryPath { get; }
    public virtual int get_MaxPath();
    public virtual int get_MaxDirectoryPath();
    public virtual void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    [SecuritySafeCriticalAttribute]
public virtual void CreateDirectory(string fullPath);
    public virtual void DeleteFile(string fullPath);
    public virtual bool DirectoryExists(string fullPath);
    private bool DirectoryExists(string path, Int32& lastError);
    public virtual IEnumerable`1<string> EnumeratePaths(string fullPath, string searchPattern, SearchOption searchOption, SearchTarget searchTarget);
    public virtual IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string fullPath, string searchPattern, SearchOption searchOption, SearchTarget searchTarget);
    [SecurityCriticalAttribute]
internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool tryagain, bool returnErrorOnNotFound);
    public virtual bool FileExists(string fullPath);
    public virtual FileAttributes GetAttributes(string fullPath);
    public virtual string GetCurrentDirectory();
    public virtual DateTimeOffset GetCreationTime(string fullPath);
    public virtual IFileSystemObject GetFileSystemInfo(string fullPath, bool asDirectory);
    public virtual DateTimeOffset GetLastAccessTime(string fullPath);
    public virtual DateTimeOffset GetLastWriteTime(string fullPath);
    public virtual void MoveDirectory(string sourceFullPath, string destFullPath);
    public virtual void MoveFile(string sourceFullPath, string destFullPath);
    public virtual FileStreamBase Open(string fullPath, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, FileStream parent);
    [SecurityCriticalAttribute]
private static SafeFileHandle OpenHandle(string fullPath, bool asDirectory);
    public virtual void RemoveDirectory(string fullPath, bool recursive);
    [SecurityCriticalAttribute]
private static void RemoveDirectoryHelper(string fullPath, bool recursive, bool throwOnTopLevelDirectoryNotFound);
    public virtual void SetAttributes(string fullPath, FileAttributes attributes);
    private static void SetAttributesInternal(string fullPath, FileAttributes attributes);
    public virtual void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    private static void SetCreationTimeInternal(string fullPath, DateTimeOffset time, bool asDirectory);
    public virtual void SetCurrentDirectory(string fullPath);
    public virtual void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    private static void SetLastAccessTimeInternal(string fullPath, DateTimeOffset time, bool asDirectory);
    public virtual void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    private static void SetLastWriteTimeInternal(string fullPath, DateTimeOffset time, bool asDirectory);
}
internal static class System.IO.Win32FileSystemEnumerableFactory : object {
    internal static IEnumerable`1<string> CreateFileNameIterator(string path, string originalUserPath, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption);
    internal static IEnumerable`1<FileInfo> CreateFileInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption);
    internal static IEnumerable`1<DirectoryInfo> CreateDirectoryInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption);
    internal static IEnumerable`1<FileSystemInfo> CreateFileSystemInfoIterator(string path, string originalUserPath, string searchPattern, SearchOption searchOption);
}
internal static class System.IO.Win32FileSystemEnumerableHelpers : object {
    [SecurityCriticalAttribute]
internal static bool IsDir(WIN32_FIND_DATA& data);
    [SecurityCriticalAttribute]
internal static bool IsFile(WIN32_FIND_DATA& data);
}
internal class System.IO.Win32FileSystemEnumerableIterator`1 : Iterator`1<TSource> {
    private static int STATE_INIT;
    private static int STATE_SEARCH_NEXT_DIR;
    private static int STATE_FIND_NEXT_FILE;
    private static int STATE_FINISH;
    private SearchResultHandler`1<TSource> _resultHandler;
    private List`1<PathPair> _searchList;
    private PathPair _searchData;
    private string _searchCriteria;
    [SecurityCriticalAttribute]
private SafeFindHandle _hnd;
    private bool _empty;
    private string _userPath;
    private SearchOption _searchOption;
    private string _fullPath;
    private string _normalizedSearchPath;
    private UInt32 _oldMode;
    [SecuritySafeCriticalAttribute]
internal Win32FileSystemEnumerableIterator`1(string path, string originalUserPath, string searchPattern, SearchOption searchOption, SearchResultHandler`1<TSource> resultHandler);
    [SecuritySafeCriticalAttribute]
private Win32FileSystemEnumerableIterator`1(string fullPath, string normalizedSearchPath, string searchCriteria, string userPath, SearchOption searchOption, SearchResultHandler`1<TSource> resultHandler);
    [SecurityCriticalAttribute]
private void CommonInit();
    protected virtual Iterator`1<TSource> Clone();
    [SecuritySafeCriticalAttribute]
protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
public virtual bool MoveNext();
    [SecurityCriticalAttribute]
private bool IsResultIncluded(WIN32_FIND_DATA& findData, TSource& result);
    [SecurityCriticalAttribute]
private void HandleError(int errorCode, string path);
    [SecurityCriticalAttribute]
private void AddSearchableDirsToList(PathPair localSearchData);
    private static string GetNormalizedSearchCriteria(string fullSearchString, string fullPathMod);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error();
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static int TryMakeWin32ErrorCodeFromHR(int hr);
    internal static string GetMessage(int errorCode);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_DevicesNotSupported { get; }
    internal static string Arg_FileIsDirectory_Name { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string Arg_HandleNotSync { get; }
    internal static string Arg_InvalidFileAttrs { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidSearchPattern { get; }
    internal static string Arg_Path2IsRooted { get; }
    internal static string Arg_PathIsVolume { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentNull_FileName { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string ArgumentOutOfRange_NeedNonNegInt32Range { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Argument_EmptyFileName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_FileNotResized { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSubPath { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string Argument_PathFormatNotSupported { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_BindHandleFailed { get; }
    internal static string IO_CannotCreateDirectory { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_FileStreamHandlePosition { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_FileTooLongOrHandleNotSync { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_SourceDestMustBeDifferent { get; }
    internal static string IO_SourceDestMustHaveSameRoot { get; }
    internal static string IO_SyncOpOnUIThread { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string IndexOutOfRange_IORaceCondition { get; }
    internal static string NotSupported_FileStreamOnNonFiles { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string UnknownError_Num { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_DevicesNotSupported();
    internal static string get_Arg_FileIsDirectory_Name();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_Arg_HandleNotSync();
    internal static string get_Arg_InvalidFileAttrs();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidSearchPattern();
    internal static string get_Arg_Path2IsRooted();
    internal static string get_Arg_PathIsVolume();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentNull_FileName();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_ArgumentOutOfRange_NeedNonNegInt32Range();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Argument_EmptyFileName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_FileNotResized();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSubPath();
    internal static string get_Argument_PathEmpty();
    internal static string get_Argument_PathFormatNotSupported();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_BindHandleFailed();
    internal static string get_IO_CannotCreateDirectory();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_FileStreamHandlePosition();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_FileTooLongOrHandleNotSync();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_SourceDestMustBeDifferent();
    internal static string get_IO_SourceDestMustHaveSameRoot();
    internal static string get_IO_SyncOpOnUIThread();
    internal static string get_IO_UnknownFileName();
    internal static string get_IndexOutOfRange_IORaceCondition();
    internal static string get_NotSupported_FileStreamOnNonFiles();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_UnknownError_Num();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static Type get_ResourceType();
}
