internal static class FxResources.System.Net.Sockets.SR : object {
}
internal static class Interop : object {
}
internal abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal class System.DBNull : object {
    public static DBNull Value;
    private static DBNull();
}
[ExtensionAttribute]
internal static class System.Net.ByteOrder : object {
    [ExtensionAttribute]
public static ushort HostToNetwork(ushort host);
    [ExtensionAttribute]
public static UInt32 HostToNetwork(UInt32 host);
    [ExtensionAttribute]
public static void HostToNetworkBytes(ushort host, Byte[] bytes, int index);
    [ExtensionAttribute]
public static ushort NetworkToHost(ushort network);
    [ExtensionAttribute]
public static UInt32 NetworkToHost(UInt32 network);
    [ExtensionAttribute]
public static ushort NetworkBytesToHostUInt16(Byte[] bytes, int index);
    [ExtensionAttribute]
public static UInt32 NetworkBytesToNetworkUInt32(Byte[] bytes, int index);
    [ExtensionAttribute]
public static void NetworkToNetworkBytes(UInt32 host, Byte[] bytes, int index);
}
internal class System.Net.CallbackClosure : object {
    private AsyncCallback _savedCallback;
    private ExecutionContext _savedContext;
    internal AsyncCallback AsyncCallback { get; }
    internal ExecutionContext Context { get; }
    internal CallbackClosure(ExecutionContext context, AsyncCallback callback);
    internal bool IsCompatible(AsyncCallback callback);
    internal AsyncCallback get_AsyncCallback();
    internal ExecutionContext get_Context();
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    internal ExecutionContext ContextCopy { get; }
    internal ContextAwareResult(object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal ExecutionContext get_ContextCopy();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    internal bool FinishPostingAsyncOp(CallbackClosure& closure);
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
    private void SafeCaptureIdentity();
    private void CleanupInternal();
}
[EventSourceAttribute]
internal class System.Net.EventSourceLogging : EventSource {
    private static EventSourceLogging s_log;
    public static EventSourceLogging Log { get; }
    private static EventSourceLogging();
    public static EventSourceLogging get_Log();
    [EventAttribute("1")]
public void DebugMessage(string message);
    [EventAttribute("2")]
public void DebugDumpArray(Byte[] bufferSegmentArray);
    [EventAttribute("3")]
public void WarningDumpArray(string message);
    [EventAttribute("4")]
public void FunctionStart(string functionName, string parameters);
    [EventAttribute("5")]
public void FunctionStop(string functionName, string result);
    [EventAttribute("6")]
public void WarningMessage(string message);
    [EventAttribute("7")]
public void AssertFailed(string message, string detailMessage);
    [EventAttribute("8")]
public void CriticalMessage(string message, string detailMessage);
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.GlobalLog : object {
    [ThreadStaticAttribute]
private static Stack`1<ThreadKinds> t_threadKindStack;
    private static Stack`1<ThreadKinds> ThreadKindStack { get; }
    internal static ThreadKinds CurrentThreadKind { get; }
    public static bool IsEnabled { get; }
    private static Stack`1<ThreadKinds> get_ThreadKindStack();
    internal static ThreadKinds get_CurrentThreadKind();
    internal static IDisposable SetThreadKind(ThreadKinds kind);
    internal static void SetThreadSource(ThreadKinds source);
    internal static void ThreadContract(ThreadKinds kind, string errorMsg);
    internal static void ThreadContract(ThreadKinds kind, ThreadKinds allowedSources, string errorMsg);
    public static void Print(string msg);
    public static void Enter(string functionName);
    public static void Enter(string functionName, string parameters);
    public static void AssertFormat(string messageFormat, Object[] data);
    public static void Assert(string message);
    public static void Assert(string message, string detailMessage);
    public static void Leave(string functionName);
    public static void Leave(string functionName, string result);
    public static void Leave(string functionName, int returnval);
    public static void Leave(string functionName, bool returnval);
    public static void Dump(Byte[] buffer, int length);
    public static void Dump(Byte[] buffer, int offset, int length);
    public static bool get_IsEnabled();
}
internal class System.Net.InternalException : Exception {
}
[DefaultMemberAttribute("Item")]
internal class System.Net.Internals.SocketAddress : object {
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    internal int InternalSize;
    internal Byte[] Buffer;
    private static int MinSize;
    private static int MaxSize;
    private bool _changed;
    private int _hash;
    public AddressFamily Family { get; }
    public int Size { get; }
    public byte Item { get; public set; }
    public SocketAddress(AddressFamily family);
    public SocketAddress(AddressFamily family, int size);
    internal SocketAddress(IPAddress ipAddress);
    internal SocketAddress(IPAddress ipaddress, int port);
    private static SocketAddress();
    public AddressFamily get_Family();
    public int get_Size();
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    internal IPAddress GetIPAddress();
    internal IPEndPoint GetIPEndPoint();
    internal void CopyAddressSizeIntoBuffer();
    internal int GetAddressSizeOffset();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class System.Net.Internals.SocketExceptionFactory : object {
    public static SocketException CreateSocketException(int socketError, EndPoint endPoint);
}
internal static class System.Net.IPAddressParserStatics : object {
    public static int IPv4AddressBytes;
    public static int IPv6AddressBytes;
}
internal static class System.Net.IPEndPointStatics : object {
    internal static int AnyPort;
    internal static IPEndPoint Any;
    internal static IPEndPoint IPv6Any;
    private static IPEndPointStatics();
}
internal class System.Net.LazyAsyncResult : object {
    private static int HighBit;
    private static int ForceAsyncCount;
    [ThreadStaticAttribute]
private static ThreadContext s_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _errorCode;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; protected set; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack, object result);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    protected void set_AsyncCallback(AsyncCallback value);
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    [ConditionalAttribute("DEBUG")]
protected void DebugProtectState(bool protect);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
internal static class System.Net.LoggingHash : object {
    internal static string GetObjectName(object obj);
    internal static int HashInt(object objectValue);
    internal static string ObjectToString(object objectValue);
    private static string ExceptionMessage(Exception exception);
    internal static string HashString(object objectValue);
    internal static Object[] GetObjectLogHash(object obj);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    private static int FunctionStartId;
    private static int FunctionStopId;
    private static int CriticalExceptionId;
    private static int CriticalErrorId;
    private static NetEventSource s_log;
    public static NetEventSource Log { get; }
    private static NetEventSource();
    public static NetEventSource get_Log();
    [NonEventAttribute]
internal static void Enter(ComponentType componentType, object obj, string method, object paramObject);
    [EventAttribute("1")]
internal void FunctionStart(string callerName, int callerHash, string method, string parametersName, int parametersHash, ComponentType componentType);
    [NonEventAttribute]
internal static void Exit(ComponentType componentType, object obj, string method, object retObject);
    [EventAttribute("2")]
internal void FunctionStop(string callerName, int callerHash, string method, string parametersName, int parametersHash, ComponentType componentType);
    [NonEventAttribute]
internal static void Exception(ComponentType componentType, object obj, string method, Exception e);
    [EventAttribute("3")]
internal void CriticalException(string objName, string method, string message, int objHash, string stackTrace, ComponentType componentType);
    [NonEventAttribute]
internal static void PrintError(ComponentType componentType, string msg);
    [NonEventAttribute]
internal static void PrintError(ComponentType componentType, object obj, string method, string msg);
    [EventAttribute("4")]
internal void CriticalError(string message, string method, string objName, int objHash, ComponentType componentType);
}
[FlagsAttribute]
internal enum System.Net.NetworkInformation.StartIPOptions : Enum {
    public int value__;
    public static StartIPOptions None;
    public static StartIPOptions StartIPv4;
    public static StartIPOptions StartIPv6;
    public static StartIPOptions Both;
}
internal static class System.Net.RangeValidationHelpers : object {
    public static bool ValidateRange(int actual, int fromAllowed, int toAllowed);
    public static void ValidateSegment(ArraySegment`1<byte> segment);
}
internal static class System.Net.SocketAddressPal : object {
    public static int IPv6AddressSize;
    public static int IPv4AddressSize;
    public static int DataOffset;
    public static AddressFamily GetAddressFamily(Byte[] buffer);
    public static void SetAddressFamily(Byte[] buffer, AddressFamily family);
    public static ushort GetPort(Byte[] buffer);
    public static void SetPort(Byte[] buffer, ushort port);
    public static UInt32 GetIPv4Address(Byte[] buffer);
    public static void GetIPv6Address(Byte[] buffer, Byte[] address, UInt32& scope);
    public static void SetIPv4Address(Byte[] buffer, UInt32 address);
    public static void SetIPv6Address(Byte[] buffer, Byte[] address, UInt32 scope);
}
internal class System.Net.SocketPerfCounter : object {
    private static SocketPerfCounter s_instance;
    private static object s_lockObject;
    public static SocketPerfCounter Instance { get; }
    public bool Enabled { get; }
    private static SocketPerfCounter();
    public static SocketPerfCounter get_Instance();
    public bool get_Enabled();
    public void Increment(SocketPerfCounterName perfCounter);
    public void Increment(SocketPerfCounterName perfCounter, long amount);
}
internal enum System.Net.SocketPerfCounterName : Enum {
    public int value__;
    public static SocketPerfCounterName SocketConnectionsEstablished;
    public static SocketPerfCounterName SocketBytesReceived;
    public static SocketPerfCounterName SocketBytesSent;
    public static SocketPerfCounterName SocketDatagramsReceived;
    public static SocketPerfCounterName SocketDatagramsSent;
}
internal class System.Net.SocketProtocolSupportPal : object {
    private static bool s_ipv4;
    private static bool s_ipv6;
    private static bool s_initialized;
    private static object s_initializedLock;
    public static bool OSSupportsIPv6 { get; }
    public static bool OSSupportsIPv4 { get; }
    private static SocketProtocolSupportPal();
    public static bool get_OSSupportsIPv6();
    public static bool get_OSSupportsIPv4();
    private static void EnsureInitialized();
    private static bool IsProtocolSupported(AddressFamily af);
}
internal class System.Net.Sockets.AcceptExDelegate : MulticastDelegate {
    public AcceptExDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket listenSocketHandle, SafeCloseSocket acceptSocketHandle, IntPtr buffer, int len, int localAddressLength, int remoteAddressLength, Int32& bytesReceived, SafeHandle overlapped);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket listenSocketHandle, SafeCloseSocket acceptSocketHandle, IntPtr buffer, int len, int localAddressLength, int remoteAddressLength, Int32& bytesReceived, SafeHandle overlapped, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Int32& bytesReceived, IAsyncResult result);
}
internal class System.Net.Sockets.AcceptOverlappedAsyncResult : BaseOverlappedAsyncResult {
    private int _localBytesTransferred;
    private Socket _listenSocket;
    private Byte[] _buffer;
    private Socket _acceptSocket;
    private int _addressBufferLength;
    internal Byte[] Buffer { get; }
    internal int BytesTransferred { get; }
    unknown Socket AcceptSocket {internal set; }
    internal AcceptOverlappedAsyncResult(Socket listenSocket, object asyncState, AsyncCallback asyncCallback);
    internal Byte[] get_Buffer();
    internal int get_BytesTransferred();
    internal virtual object PostCompletion(int numBytes);
    internal void SetUnmanagedStructures(Byte[] buffer, int addressBufferLength);
    private void LogBuffer(long size);
    internal void set_AcceptSocket(Socket value);
}
internal class System.Net.Sockets.BaseOverlappedAsyncResult : ContextAwareResult {
    private int _cleanupCount;
    private SafeNativeOverlapped _nativeOverlapped;
    private static IOCompletionCallback s_ioCallback;
    internal SafeNativeOverlapped NativeOverlapped { get; }
    internal SafeHandle OverlappedHandle { get; }
    internal BaseOverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    private static BaseOverlappedAsyncResult();
    internal virtual object PostCompletion(int numBytes);
    internal SocketError CheckAsyncCallOverlappedResult(SocketError errorCode);
    internal SafeNativeOverlapped get_NativeOverlapped();
    internal void SetUnmanagedStructures(object objectsToPin);
    private static void CompletionPortCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal SafeHandle get_OverlappedHandle();
    private void ReleaseUnmanagedStructures();
    protected virtual void Cleanup();
    protected virtual void ForceReleaseUnmanagedStructures();
}
internal class System.Net.Sockets.ConnectExDelegate : MulticastDelegate {
    public ConnectExDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket socketHandle, IntPtr socketAddress, int socketAddressSize, IntPtr buffer, int dataLength, Int32& bytesSent, SafeHandle overlapped);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, IntPtr socketAddress, int socketAddressSize, IntPtr buffer, int dataLength, Int32& bytesSent, SafeHandle overlapped, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Int32& bytesSent, IAsyncResult result);
}
internal class System.Net.Sockets.ConnectOverlappedAsyncResult : BaseOverlappedAsyncResult {
    private EndPoint _endPoint;
    internal EndPoint RemoteEndPoint { get; }
    internal ConnectOverlappedAsyncResult(Socket socket, EndPoint endPoint, object asyncState, AsyncCallback asyncCallback);
    internal EndPoint get_RemoteEndPoint();
    internal virtual object PostCompletion(int numBytes);
}
internal static class System.Net.Sockets.DnsAPMExtensions : object {
    public static IAsyncResult BeginGetHostAddresses(string hostNameOrAddress, AsyncCallback requestCallback, object state);
    public static IPAddress[] EndGetHostAddresses(IAsyncResult asyncResult);
}
internal class System.Net.Sockets.DualSocketMultipleConnectAsync : MultipleConnectAsync {
    private Socket _socket4;
    private Socket _socket6;
    protected bool RequiresUserConnectAttempt { get; }
    protected Socket UserSocket { get; }
    public DualSocketMultipleConnectAsync(SocketType socketType, ProtocolType protocolType);
    protected virtual bool get_RequiresUserConnectAttempt();
    protected virtual Socket get_UserSocket();
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnSucceed();
    protected virtual void OnFail(bool abortive);
}
internal class System.Net.Sockets.DynamicWinsockMethods : object {
    private static List`1<DynamicWinsockMethods> s_methodTable;
    private AddressFamily _addressFamily;
    private SocketType _socketType;
    private ProtocolType _protocolType;
    private object _lockObject;
    private AcceptExDelegate _acceptEx;
    private GetAcceptExSockaddrsDelegate _getAcceptExSockaddrs;
    private ConnectExDelegate _connectEx;
    private TransmitPacketsDelegate _transmitPackets;
    private WSARecvMsgDelegate _recvMsg;
    private WSARecvMsgDelegateBlocking _recvMsgBlocking;
    private DynamicWinsockMethods(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    private static DynamicWinsockMethods();
    public static DynamicWinsockMethods GetMethods(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public T GetDelegate(SafeCloseSocket socketHandle);
    private IntPtr LoadDynamicFunctionPointer(SafeCloseSocket socketHandle, Guid& guid);
    private void EnsureAcceptEx(SafeCloseSocket socketHandle);
    private void EnsureGetAcceptExSockaddrs(SafeCloseSocket socketHandle);
    private void EnsureConnectEx(SafeCloseSocket socketHandle);
    private void EnsureWSARecvMsg(SafeCloseSocket socketHandle);
    private void EnsureWSARecvMsgBlocking(SafeCloseSocket socketHandle);
    private void EnsureTransmitPackets(SafeCloseSocket socketHandle);
}
internal class System.Net.Sockets.GetAcceptExSockaddrsDelegate : MulticastDelegate {
    public GetAcceptExSockaddrsDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr buffer, int receiveDataLength, int localAddressLength, int remoteAddressLength, IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength);
    public virtual IAsyncResult BeginInvoke(IntPtr buffer, int receiveDataLength, int localAddressLength, int remoteAddressLength, IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength, AsyncCallback callback, object object);
    public virtual void EndInvoke(IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength, IAsyncResult result);
}
public enum System.Net.Sockets.IOControlCode : Enum {
    public long value__;
    public static IOControlCode AsyncIO;
    public static IOControlCode NonBlockingIO;
    public static IOControlCode DataToRead;
    public static IOControlCode OobDataRead;
    public static IOControlCode AssociateHandle;
    public static IOControlCode EnableCircularQueuing;
    public static IOControlCode Flush;
    public static IOControlCode GetBroadcastAddress;
    public static IOControlCode GetExtensionFunctionPointer;
    public static IOControlCode GetQos;
    public static IOControlCode GetGroupQos;
    public static IOControlCode MultipointLoopback;
    public static IOControlCode MulticastScope;
    public static IOControlCode SetQos;
    public static IOControlCode SetGroupQos;
    public static IOControlCode TranslateHandle;
    public static IOControlCode RoutingInterfaceQuery;
    public static IOControlCode RoutingInterfaceChange;
    public static IOControlCode AddressListQuery;
    public static IOControlCode AddressListChange;
    public static IOControlCode QueryTargetPnpHandle;
    public static IOControlCode NamespaceChange;
    public static IOControlCode AddressListSort;
    public static IOControlCode ReceiveAll;
    public static IOControlCode ReceiveAllMulticast;
    public static IOControlCode ReceiveAllIgmpMulticast;
    public static IOControlCode KeepAliveValues;
    public static IOControlCode AbsorbRouterAlert;
    public static IOControlCode UnicastInterface;
    public static IOControlCode LimitBroadcasts;
    public static IOControlCode BindToInterface;
    public static IOControlCode MulticastInterface;
    public static IOControlCode AddMulticastGroupOnInterface;
    public static IOControlCode DeleteMulticastGroupFromInterface;
}
[ExtensionAttribute]
public static class System.Net.Sockets.IPAddressExtensions : object {
    [ExtensionAttribute]
public static IPAddress Snapshot(IPAddress original);
    [ExtensionAttribute]
public static long GetAddress(IPAddress thisObj);
}
[ExtensionAttribute]
internal static class System.Net.Sockets.IPEndPointExtensions : object {
    public static SocketAddress Serialize(EndPoint endpoint);
    [ExtensionAttribute]
public static EndPoint Create(EndPoint thisObj, SocketAddress socketAddress);
    [ExtensionAttribute]
internal static IPEndPoint Snapshot(IPEndPoint thisObj);
    private static SocketAddress GetInternalSocketAddress(SocketAddress address);
    private static SocketAddress GetNetSocketAddress(SocketAddress address);
}
public class System.Net.Sockets.IPPacketInformation : ValueType {
    private IPAddress _address;
    private int _networkInterface;
    public IPAddress Address { get; }
    public int Interface { get; }
    internal IPPacketInformation(IPAddress address, int networkInterface);
    public IPAddress get_Address();
    public int get_Interface();
    public static bool op_Equality(IPPacketInformation left, IPPacketInformation right);
    public static bool op_Inequality(IPPacketInformation left, IPPacketInformation right);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
}
public enum System.Net.Sockets.IPProtectionLevel : Enum {
    public int value__;
    public static IPProtectionLevel Unspecified;
    public static IPProtectionLevel Unrestricted;
    public static IPProtectionLevel EdgeRestricted;
    public static IPProtectionLevel Restricted;
}
public class System.Net.Sockets.IPv6MulticastOption : object {
    private IPAddress _group;
    private long _interface;
    public IPAddress Group { get; public set; }
    public long InterfaceIndex { get; public set; }
    public IPv6MulticastOption(IPAddress group, long ifindex);
    public IPv6MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public long get_InterfaceIndex();
    public void set_InterfaceIndex(long value);
}
public class System.Net.Sockets.LingerOption : object {
    private bool _enabled;
    private int _lingerTime;
    public bool Enabled { get; public set; }
    public int LingerTime { get; public set; }
    public LingerOption(bool enable, int seconds);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public int get_LingerTime();
    public void set_LingerTime(int value);
}
public class System.Net.Sockets.MulticastOption : object {
    private IPAddress _group;
    private IPAddress _localAddress;
    private int _ifIndex;
    public IPAddress Group { get; public set; }
    public IPAddress LocalAddress { get; public set; }
    public int InterfaceIndex { get; public set; }
    public MulticastOption(IPAddress group, IPAddress mcint);
    public MulticastOption(IPAddress group, int interfaceIndex);
    public MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public IPAddress get_LocalAddress();
    public void set_LocalAddress(IPAddress value);
    public int get_InterfaceIndex();
    public void set_InterfaceIndex(int value);
}
internal abstract class System.Net.Sockets.MultipleConnectAsync : object {
    protected SocketAsyncEventArgs _userArgs;
    protected SocketAsyncEventArgs _internalArgs;
    protected DnsEndPoint _endPoint;
    protected IPAddress[] _addressList;
    protected int _nextAddress;
    private Socket _lastAttemptSocket;
    private State _state;
    private object _lockObject;
    protected bool RequiresUserConnectAttempt { get; }
    protected Socket UserSocket { get; }
    protected abstract virtual bool get_RequiresUserConnectAttempt();
    protected abstract virtual Socket get_UserSocket();
    public bool StartConnectAsync(SocketAsyncEventArgs args, DnsEndPoint endPoint);
    private void DnsCallback(IAsyncResult result);
    private bool DoDnsCallback(IAsyncResult result, bool sync);
    private void InternalConnectCallback(object sender, SocketAsyncEventArgs args);
    private Exception AttemptConnection();
    private Exception AttemptUserConnection();
    private static Exception AttemptConnection(Socket attemptSocket, SocketAsyncEventArgs args);
    protected abstract virtual void OnSucceed();
    private void Succeed();
    protected abstract virtual void OnFail(bool abortive);
    private void OnFailOuter(bool abortive);
    private bool Fail(bool sync, Exception e);
    private void SyncFail(Exception e);
    private void AsyncFail(Exception e);
    public void Cancel();
    private void CallAsyncFail(object ignored);
    protected abstract virtual IPAddress GetNextAddress(Socket& attemptSocket);
    [CompilerGeneratedAttribute]
private void <Cancel>b__27_0(object s);
}
internal class System.Net.Sockets.MultipleSocketMultipleConnectAsync : MultipleConnectAsync {
    private SocketType _socketType;
    private ProtocolType _protocolType;
    private bool _supportsIPv4;
    private bool _supportsIPv6;
    protected bool RequiresUserConnectAttempt { get; }
    protected Socket UserSocket { get; }
    public MultipleSocketMultipleConnectAsync(SocketType socketType, ProtocolType protocolType);
    protected virtual bool get_RequiresUserConnectAttempt();
    protected virtual Socket get_UserSocket();
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnFail(bool abortive);
    protected virtual void OnSucceed();
}
public class System.Net.Sockets.NetworkStream : Stream {
    private Socket _streamSocket;
    private bool _readable;
    private bool _writeable;
    private bool _ownsSocket;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanedUp;
    private int _currentReadTimeout;
    private int _currentWriteTimeout;
    protected Socket Socket { get; }
    internal Socket InternalSocket { get; }
    protected bool Readable { get; protected set; }
    protected bool Writeable { get; protected set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool DataAvailable { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Connected { get; }
    public NetworkStream(Socket socket);
    public NetworkStream(Socket socket, bool ownsSocket);
    internal NetworkStream(NetworkStream networkStream, bool ownsSocket);
    protected Socket get_Socket();
    internal Socket get_InternalSocket();
    internal void InternalAbortSocket();
    internal void ConvertToNotSocketOwner();
    protected bool get_Readable();
    protected void set_Readable(bool value);
    protected bool get_Writeable();
    protected void set_Writeable(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_DataAvailable();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    internal void InitNetworkStream(Socket socket);
    internal bool PollRead();
    internal bool Poll(int microSeconds, SelectMode mode);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal bool get_Connected();
    public IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public int EndRead(IAsyncResult asyncResult);
    public IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    internal virtual IAsyncResult UnsafeBeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int size, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent);
    [ConditionalAttribute("TRACE_VERBOSE")]
internal void DebugMembers();
}
internal class System.Net.Sockets.OverlappedAsyncResult : BaseOverlappedAsyncResult {
    private SocketAddress _socketAddress;
    private SocketAddress _socketAddressOriginal;
    internal WSABuffer _singleBuffer;
    internal WSABuffer[] _wsaBuffers;
    internal SocketAddress SocketAddress { get; internal set; }
    internal SocketAddress SocketAddressOriginal { get; internal set; }
    internal OverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    internal SocketAddress get_SocketAddress();
    internal void set_SocketAddress(SocketAddress value);
    internal SocketAddress get_SocketAddressOriginal();
    internal void set_SocketAddressOriginal(SocketAddress value);
    internal IntPtr GetSocketAddressPtr();
    internal IntPtr GetSocketAddressSizePtr();
    internal int GetSocketAddressSize();
    internal void SetUnmanagedStructures(Byte[] buffer, int offset, int size, SocketAddress socketAddress, bool pinSocketAddress);
    internal void SetUnmanagedStructures(IList`1<ArraySegment`1<byte>> buffers);
    internal virtual object PostCompletion(int numBytes);
    private void LogBuffer(int size);
}
internal enum System.Net.Sockets.ProtocolFamily : Enum {
    public int value__;
    public static ProtocolFamily Unknown;
    public static ProtocolFamily Unspecified;
    public static ProtocolFamily Unix;
    public static ProtocolFamily InterNetwork;
    public static ProtocolFamily ImpLink;
    public static ProtocolFamily Pup;
    public static ProtocolFamily Chaos;
    public static ProtocolFamily NS;
    public static ProtocolFamily Ipx;
    public static ProtocolFamily Iso;
    public static ProtocolFamily Osi;
    public static ProtocolFamily Ecma;
    public static ProtocolFamily DataKit;
    public static ProtocolFamily Ccitt;
    public static ProtocolFamily Sna;
    public static ProtocolFamily DecNet;
    public static ProtocolFamily DataLink;
    public static ProtocolFamily Lat;
    public static ProtocolFamily HyperChannel;
    public static ProtocolFamily AppleTalk;
    public static ProtocolFamily NetBios;
    public static ProtocolFamily VoiceView;
    public static ProtocolFamily FireFox;
    public static ProtocolFamily Banyan;
    public static ProtocolFamily Atm;
    public static ProtocolFamily InterNetworkV6;
    public static ProtocolFamily Cluster;
    public static ProtocolFamily Ieee12844;
    public static ProtocolFamily Irda;
    public static ProtocolFamily NetworkDesigners;
}
public enum System.Net.Sockets.ProtocolType : Enum {
    public int value__;
    public static ProtocolType IP;
    public static ProtocolType IPv6HopByHopOptions;
    public static ProtocolType Icmp;
    public static ProtocolType Igmp;
    public static ProtocolType Ggp;
    public static ProtocolType IPv4;
    public static ProtocolType Tcp;
    public static ProtocolType Pup;
    public static ProtocolType Udp;
    public static ProtocolType Idp;
    public static ProtocolType IPv6;
    public static ProtocolType IPv6RoutingHeader;
    public static ProtocolType IPv6FragmentHeader;
    public static ProtocolType IPSecEncapsulatingSecurityPayload;
    public static ProtocolType IPSecAuthenticationHeader;
    public static ProtocolType IcmpV6;
    public static ProtocolType IPv6NoNextHeader;
    public static ProtocolType IPv6DestinationOptions;
    public static ProtocolType ND;
    public static ProtocolType Raw;
    public static ProtocolType Unspecified;
    public static ProtocolType Ipx;
    public static ProtocolType Spx;
    public static ProtocolType SpxII;
    public static ProtocolType Unknown;
}
internal class System.Net.Sockets.ReceiveMessageOverlappedAsyncResult : BaseOverlappedAsyncResult {
    private SocketAddress _socketAddressOriginal;
    private SocketAddress _socketAddress;
    private SocketFlags _socketFlags;
    private IPPacketInformation _ipPacketInformation;
    private WSAMsg* _message;
    private WSABuffer* _wsaBuffer;
    private Byte[] _wsaBufferArray;
    private Byte[] _controlBuffer;
    internal Byte[] _messageBuffer;
    private static int s_controlDataSize;
    private static int s_controlDataIPv6Size;
    private static int s_wsaBufferSize;
    private static int s_wsaMsgSize;
    internal SocketAddress SocketAddress { get; internal set; }
    internal SocketAddress SocketAddressOriginal { get; internal set; }
    internal SocketFlags SocketFlags { get; }
    internal IPPacketInformation IPPacketInformation { get; }
    internal ReceiveMessageOverlappedAsyncResult(Socket socket, object asyncState, AsyncCallback asyncCallback);
    private static ReceiveMessageOverlappedAsyncResult();
    internal SocketAddress get_SocketAddress();
    internal void set_SocketAddress(SocketAddress value);
    internal SocketAddress get_SocketAddressOriginal();
    internal void set_SocketAddressOriginal(SocketAddress value);
    internal SocketFlags get_SocketFlags();
    internal IPPacketInformation get_IPPacketInformation();
    private IntPtr GetSocketAddressSizePtr();
    internal int GetSocketAddressSize();
    internal void SetUnmanagedStructures(Byte[] buffer, int offset, int size, SocketAddress socketAddress, SocketFlags socketFlags);
    private void InitIPPacketInformation();
    internal void SyncReleaseUnmanagedStructures();
    protected virtual void ForceReleaseUnmanagedStructures();
    internal virtual object PostCompletion(int numBytes);
    private void LogBuffer(int size);
}
internal class System.Net.Sockets.SafeCloseSocket : SafeHandleMinusOneIsInvalid {
    private InnerSafeCloseSocket _innerSocket;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _released;
    private ThreadPoolBoundHandle _iocpBoundHandle;
    private object _iocpBindingLock;
    public bool IsInvalid { get; }
    public ThreadPoolBoundHandle IOCPBoundHandle { get; }
    public virtual bool get_IsInvalid();
    private void SetInnerSocket(InnerSafeCloseSocket socket);
    private static SafeCloseSocket CreateSocket(InnerSafeCloseSocket socket);
    protected static void CreateSocket(InnerSafeCloseSocket socket, SafeCloseSocket target);
    protected virtual bool ReleaseHandle();
    internal void CloseAsIs();
    public ThreadPoolBoundHandle get_IOCPBoundHandle();
    public ThreadPoolBoundHandle GetOrAllocateThreadPoolBoundHandle();
    internal static SafeCloseSocket CreateWSASocket(Byte* pinnedBuffer);
    internal static SafeCloseSocket CreateWSASocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    internal static SafeCloseSocket Accept(SafeCloseSocket socketHandle, Byte[] socketAddress, Int32& socketAddressSize);
    private void InnerReleaseHandle();
}
internal class System.Net.Sockets.SafeNativeOverlapped : SafeHandle {
    private static SafeNativeOverlapped s_zero;
    private SafeCloseSocket _safeCloseSocket;
    internal static SafeNativeOverlapped Zero { get; }
    public bool IsInvalid { get; }
    protected SafeNativeOverlapped(IntPtr handle);
    public SafeNativeOverlapped(SafeCloseSocket socketHandle, NativeOverlapped* handle);
    private static SafeNativeOverlapped();
    internal static SafeNativeOverlapped get_Zero();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    private void FreeNativeOverlapped();
}
public enum System.Net.Sockets.SelectMode : Enum {
    public int value__;
    public static SelectMode SelectRead;
    public static SelectMode SelectWrite;
    public static SelectMode SelectError;
}
public class System.Net.Sockets.SendPacketsElement : object {
    internal string _filePath;
    internal Byte[] _buffer;
    internal int _offset;
    internal int _count;
    internal SendPacketsElementFlags _flags;
    public string FilePath { get; }
    public Byte[] Buffer { get; }
    public int Count { get; }
    public int Offset { get; }
    public bool EndOfPacket { get; }
    public SendPacketsElement(string filepath);
    public SendPacketsElement(string filepath, int offset, int count);
    public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket);
    public SendPacketsElement(Byte[] buffer);
    public SendPacketsElement(Byte[] buffer, int offset, int count);
    public SendPacketsElement(Byte[] buffer, int offset, int count, bool endOfPacket);
    private void Initialize(string filePath, Byte[] buffer, int offset, int count, SendPacketsElementFlags flags, bool endOfPacket);
    public string get_FilePath();
    public Byte[] get_Buffer();
    public int get_Count();
    public int get_Offset();
    public bool get_EndOfPacket();
}
internal enum System.Net.Sockets.SendPacketsElementFlags : Enum {
    public UInt32 value__;
    public static SendPacketsElementFlags File;
    public static SendPacketsElementFlags Memory;
    public static SendPacketsElementFlags EndOfPacket;
}
internal class System.Net.Sockets.SingleSocketMultipleConnectAsync : MultipleConnectAsync {
    private Socket _socket;
    private bool _userSocket;
    protected bool RequiresUserConnectAttempt { get; }
    protected Socket UserSocket { get; }
    public SingleSocketMultipleConnectAsync(Socket socket, bool userSocket);
    protected virtual bool get_RequiresUserConnectAttempt();
    protected virtual Socket get_UserSocket();
    protected virtual IPAddress GetNextAddress(Socket& attemptSocket);
    protected virtual void OnFail(bool abortive);
    protected virtual void OnSucceed();
}
public class System.Net.Sockets.Socket : object {
    internal static int DefaultCloseTimeout;
    private SafeCloseSocket _handle;
    internal EndPoint _rightEndPoint;
    internal EndPoint _remoteEndPoint;
    private bool _isConnected;
    private bool _isDisconnected;
    private bool _willBlock;
    private bool _willBlockInternal;
    private bool _isListening;
    private bool _nonBlockingConnectInProgress;
    private EndPoint _nonBlockingConnectRightEndPoint;
    private AddressFamily _addressFamily;
    private SocketType _socketType;
    private ProtocolType _protocolType;
    private CacheSet _caches;
    private bool _receivingPacketInformation;
    private SocketAddress _permittedRemoteAddress;
    private static object s_internalSyncObject;
    private int _closeTimeout;
    private int _intCleanedUp;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_initialized;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_loggingEnabled;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_perfCountersEnabled;
    private static AsyncCallback s_multipleAddressConnectCallback;
    private DynamicWinsockMethods _dynamicWinsockMethods;
    public static bool OSSupportsIPv4 { get; }
    public static bool OSSupportsIPv6 { get; }
    public int Available { get; }
    public EndPoint LocalEndPoint { get; }
    public EndPoint RemoteEndPoint { get; }
    internal SafeCloseSocket SafeHandle { get; }
    public bool Blocking { get; public set; }
    public bool Connected { get; }
    public AddressFamily AddressFamily { get; }
    public SocketType SocketType { get; }
    public ProtocolType ProtocolType { get; }
    public bool IsBound { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool DualMode { get; public set; }
    private bool IsDualMode { get; }
    private static object InternalSyncObject { get; }
    private CacheSet Caches { get; }
    internal bool CleanedUp { get; }
    internal TransportType Transport { get; }
    private static AsyncCallback CachedMultipleAddressConnectCallback { get; }
    public Socket(SocketType socketType, ProtocolType protocolType);
    public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    private Socket(SafeCloseSocket fd);
    public static bool get_OSSupportsIPv4();
    public static bool get_OSSupportsIPv6();
    public int get_Available();
    public EndPoint get_LocalEndPoint();
    public EndPoint get_RemoteEndPoint();
    internal SafeCloseSocket get_SafeHandle();
    public bool get_Blocking();
    public void set_Blocking(bool value);
    public bool get_Connected();
    public AddressFamily get_AddressFamily();
    public SocketType get_SocketType();
    public ProtocolType get_ProtocolType();
    public bool get_IsBound();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_DualMode();
    public void set_DualMode(bool value);
    private bool get_IsDualMode();
    internal bool CanTryAddressFamily(AddressFamily family);
    public void Bind(EndPoint localEP);
    internal void InternalBind(EndPoint localEP);
    private void DoBind(EndPoint endPointSnapshot, SocketAddress socketAddress);
    public void Connect(EndPoint remoteEP);
    public void Connect(IPAddress address, int port);
    public void Connect(string host, int port);
    public void Connect(IPAddress[] addresses, int port);
    public void Listen(int backlog);
    public Socket Accept();
    public int Send(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, SocketFlags socketFlags);
    public int Send(Byte[] buffer);
    public int Send(IList`1<ArraySegment`1<byte>> buffers);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, EndPoint remoteEP);
    public int Receive(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, SocketFlags socketFlags);
    public int Receive(Byte[] buffer);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation);
    public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP);
    public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);
    public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
    public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);
    public bool Poll(int microSeconds, SelectMode mode);
    public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
    internal IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    private bool CanUseConnectEx(EndPoint remoteEP);
    internal IAsyncResult UnsafeBeginConnect(EndPoint remoteEP, AsyncCallback callback, object state, bool flowContext);
    internal IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    private static void ThrowIfNotSupportsMultipleConnectAttempts();
    internal IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    internal IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    internal void EndConnect(IAsyncResult asyncResult);
    internal IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    private SocketError DoBeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    internal IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    private SocketError DoBeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    internal int EndSend(IAsyncResult asyncResult);
    internal int EndSend(IAsyncResult asyncResult, SocketError& errorCode);
    internal IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state);
    private void DoBeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint endPointSnapshot, SocketAddress socketAddress, OverlappedAsyncResult asyncResult);
    internal int EndSendTo(IAsyncResult asyncResult);
    internal IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    internal IAsyncResult UnsafeBeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    private SocketError DoBeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    internal IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    internal IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    private SocketError DoBeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    internal int EndReceive(IAsyncResult asyncResult);
    internal int EndReceive(IAsyncResult asyncResult, SocketError& errorCode);
    internal IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    internal int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation);
    internal IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    private void DoBeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint endPointSnapshot, SocketAddress socketAddress, OverlappedAsyncResult asyncResult);
    internal int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint);
    internal IAsyncResult BeginAccept(AsyncCallback callback, object state);
    internal IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state);
    internal IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);
    private void DoBeginAccept(Socket acceptSocket, int receiveSize, AcceptOverlappedAsyncResult asyncResult);
    internal Socket EndAccept(IAsyncResult asyncResult);
    internal Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult);
    internal Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult);
    public void Shutdown(SocketShutdown how);
    public bool AcceptAsync(SocketAsyncEventArgs e);
    public bool ConnectAsync(SocketAsyncEventArgs e);
    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);
    public static void CancelConnectAsync(SocketAsyncEventArgs e);
    public bool ReceiveAsync(SocketAsyncEventArgs e);
    public bool ReceiveFromAsync(SocketAsyncEventArgs e);
    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);
    public bool SendAsync(SocketAsyncEventArgs e);
    public bool SendPacketsAsync(SocketAsyncEventArgs e);
    public bool SendToAsync(SocketAsyncEventArgs e);
    private static object get_InternalSyncObject();
    private CacheSet get_Caches();
    internal bool get_CleanedUp();
    internal TransportType get_Transport();
    internal static void GetIPProtocolInformation(AddressFamily addressFamily, SocketAddress socketAddress, Boolean& isIPv4, Boolean& isIPv6);
    private void CheckSetOptionPermissions(SocketOptionLevel optionLevel, SocketOptionName optionName);
    private SocketAddress SnapshotAndSerialize(EndPoint& remoteEP);
    private SocketAddress CallSerializeCheckDnsEndPoint(EndPoint remoteEP);
    private IPEndPoint RemapIPEndPoint(IPEndPoint input);
    private SocketAddress CheckCacheRemote(EndPoint& remoteEP, bool isOverwrite);
    internal static void InitializeSockets();
    internal void InternalConnect(EndPoint remoteEP);
    private void DoConnect(EndPoint endPointSnapshot, SocketAddress socketAddress);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    internal void InternalShutdown(SocketShutdown how);
    internal void SetReceivingPacketInformation();
    internal void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue, bool silent);
    private void SetMulticastOption(SocketOptionName optionName, MulticastOption MR);
    private void SetIPv6MulticastOption(SocketOptionName optionName, IPv6MulticastOption MR);
    private void SetLingerOption(LingerOption lref);
    private LingerOption GetLingerOpt();
    private MulticastOption GetMulticastOpt(SocketOptionName optionName);
    private IPv6MulticastOption GetIPv6MulticastOpt(SocketOptionName optionName);
    private SocketError InternalSetBlocking(bool desired, Boolean& current);
    internal void InternalSetBlocking(bool desired);
    private IAsyncResult BeginConnectEx(EndPoint remoteEP, bool flowContext, AsyncCallback callback, object state);
    private static void DnsCallback(IAsyncResult result);
    private static bool DoDnsCallback(IAsyncResult result, MultipleAddressConnectAsyncResult context);
    private static AsyncCallback get_CachedMultipleAddressConnectCallback();
    private static object PostOneBeginConnect(MultipleAddressConnectAsyncResult context);
    private static void MultipleAddressConnectCallback(IAsyncResult result);
    private static bool DoMultipleAddressConnectCallback(object result, MultipleAddressConnectAsyncResult context);
    internal Socket CreateAcceptSocket(SafeCloseSocket fd, EndPoint remoteEP);
    internal Socket UpdateAcceptSocket(Socket socket, EndPoint remoteEP);
    internal void SetToConnected();
    internal void SetToDisconnected();
    internal void UpdateStatusAfterSocketError(SocketException socketException);
    internal void UpdateStatusAfterSocketError(SocketError errorCode);
    private void ValidateBlockingMode();
    [ConditionalAttribute("TRACE_VERBOSE")]
internal void DebugMembers();
    private void EnsureDynamicWinsockMethods();
    internal bool AcceptEx(SafeCloseSocket listenSocketHandle, SafeCloseSocket acceptSocketHandle, IntPtr buffer, int len, int localAddressLength, int remoteAddressLength, Int32& bytesReceived, SafeHandle overlapped);
    internal void GetAcceptExSockaddrs(IntPtr buffer, int receiveDataLength, int localAddressLength, int remoteAddressLength, IntPtr& localSocketAddress, Int32& localSocketAddressLength, IntPtr& remoteSocketAddress, Int32& remoteSocketAddressLength);
    internal bool ConnectEx(SafeCloseSocket socketHandle, IntPtr socketAddress, int socketAddressSize, IntPtr buffer, int dataLength, Int32& bytesSent, SafeHandle overlapped);
    internal SocketError WSARecvMsg(SafeCloseSocket socketHandle, IntPtr msg, Int32& bytesTransferred, SafeHandle overlapped, IntPtr completionRoutine);
    internal SocketError WSARecvMsgBlocking(IntPtr socketHandle, IntPtr msg, Int32& bytesTransferred, IntPtr overlapped, IntPtr completionRoutine);
    internal bool TransmitPackets(SafeCloseSocket socketHandle, IntPtr packetArray, int elementCount, int sendSize, SafeNativeOverlapped overlapped);
    internal static IntPtr[] SocketListToFileDescriptorSet(IList socketList);
    internal static void SelectFileDescriptor(IList socketList, IntPtr[] fileDescriptorSet);
    private Socket GetOrCreateAcceptSocket(Socket acceptSocket, bool checkDisconnected, string propertyName, SafeCloseSocket& handle);
}
public class System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
    internal Socket _acceptSocket;
    private Socket _connectSocket;
    internal Byte[] _buffer;
    internal int _count;
    internal int _offset;
    internal IList`1<ArraySegment`1<byte>> _bufferList;
    private int _bytesTransferred;
    [CompilerGeneratedAttribute]
private EventHandler`1<SocketAsyncEventArgs> _completed;
    private bool _completedChanged;
    private SocketAsyncOperation _completedOperation;
    private IPPacketInformation _receiveMessageFromPacketInfo;
    private EndPoint _remoteEndPoint;
    internal int _sendPacketsSendSize;
    internal SendPacketsElement[] _sendPacketsElements;
    private SocketError _socketError;
    private Exception _connectByNameError;
    internal SocketFlags _socketFlags;
    private object _userToken;
    internal Byte[] _acceptBuffer;
    internal int _acceptAddressBufferCount;
    internal SocketAddress _socketAddress;
    private ExecutionContext _context;
    private static ContextCallback s_executionCallback;
    private Socket _currentSocket;
    private bool _disposeCalled;
    private static int Configuring;
    private static int Free;
    private static int InProgress;
    private static int Disposed;
    private int _operating;
    private MultipleConnectAsync _multipleConnect;
    private static bool s_loggingEnabled;
    internal static int s_controlDataSize;
    internal static int s_controlDataIPv6Size;
    internal static int s_wsaMsgSize;
    private WSABuffer _wsaBuffer;
    private IntPtr _ptrSingleBuffer;
    private WSABuffer[] _wsaBufferArray;
    private bool _bufferListChanged;
    private Byte[] _wsaMessageBuffer;
    private GCHandle _wsaMessageBufferGCHandle;
    private IntPtr _ptrWSAMessageBuffer;
    private Byte[] _controlBuffer;
    private GCHandle _controlBufferGCHandle;
    private IntPtr _ptrControlBuffer;
    private WSABuffer[] _wsaRecvMsgWSABufferArray;
    private GCHandle _wsaRecvMsgWSABufferArrayGCHandle;
    private IntPtr _ptrWSARecvMsgWSABufferArray;
    private IntPtr _ptrAcceptBuffer;
    private GCHandle _socketAddressGCHandle;
    private SocketAddress _pinnedSocketAddress;
    private IntPtr _ptrSocketAddressBuffer;
    private IntPtr _ptrSocketAddressBufferSize;
    private SendPacketsElement[] _sendPacketsElementsInternal;
    private TransmitPacketsElement[] _sendPacketsDescriptor;
    private int _sendPacketsElementsFileCount;
    private int _sendPacketsElementsBufferCount;
    private FileStream[] _sendPacketsFileStreams;
    private SafeHandle[] _sendPacketsFileHandles;
    private IntPtr _ptrSendPacketsDescriptor;
    private SafeNativeOverlapped _ptrNativeOverlapped;
    private PreAllocatedOverlapped _preAllocatedOverlapped;
    private Object[] _objectsToPin;
    private PinState _pinState;
    private Byte[] _pinnedAcceptBuffer;
    private Byte[] _pinnedSingleBuffer;
    private int _pinnedSingleBufferOffset;
    private int _pinnedSingleBufferCount;
    public Socket AcceptSocket { get; public set; }
    public Socket ConnectSocket { get; }
    public Byte[] Buffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public IList`1<ArraySegment`1<byte>> BufferList { get; public set; }
    public int BytesTransferred { get; }
    public SocketAsyncOperation LastOperation { get; }
    public IPPacketInformation ReceiveMessageFromPacketInfo { get; }
    public EndPoint RemoteEndPoint { get; public set; }
    public SendPacketsElement[] SendPacketsElements { get; public set; }
    public int SendPacketsSendSize { get; public set; }
    public SocketError SocketError { get; public set; }
    public Exception ConnectByNameError { get; }
    public SocketFlags SocketFlags { get; public set; }
    public object UserToken { get; public set; }
    internal Nullable`1<int> SendPacketsDescriptorCount { get; }
    private static SocketAsyncEventArgs();
    [CompilerGeneratedAttribute]
private void add__completed(EventHandler`1<SocketAsyncEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__completed(EventHandler`1<SocketAsyncEventArgs> value);
    public Socket get_AcceptSocket();
    public void set_AcceptSocket(Socket value);
    public Socket get_ConnectSocket();
    public Byte[] get_Buffer();
    public int get_Offset();
    public int get_Count();
    public IList`1<ArraySegment`1<byte>> get_BufferList();
    public void set_BufferList(IList`1<ArraySegment`1<byte>> value);
    public int get_BytesTransferred();
    public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    protected virtual void OnCompleted(SocketAsyncEventArgs e);
    public SocketAsyncOperation get_LastOperation();
    public IPPacketInformation get_ReceiveMessageFromPacketInfo();
    public EndPoint get_RemoteEndPoint();
    public void set_RemoteEndPoint(EndPoint value);
    public SendPacketsElement[] get_SendPacketsElements();
    public void set_SendPacketsElements(SendPacketsElement[] value);
    public int get_SendPacketsSendSize();
    public void set_SendPacketsSendSize(int value);
    public SocketError get_SocketError();
    public void set_SocketError(SocketError value);
    public Exception get_ConnectByNameError();
    public SocketFlags get_SocketFlags();
    public void set_SocketFlags(SocketFlags value);
    public object get_UserToken();
    public void set_UserToken(object value);
    public void SetBuffer(Byte[] buffer, int offset, int count);
    public void SetBuffer(int offset, int count);
    private void SetBufferInternal(Byte[] buffer, int offset, int count);
    internal void SetResults(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void SetResults(Exception exception, int bytesTransferred, SocketFlags flags);
    private static void ExecutionCallback(object state);
    internal void Complete();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void StartConfiguring();
    internal void StartOperationCommon(Socket socket);
    internal void StartOperationAccept();
    internal void StartOperationConnect();
    internal void StartOperationWrapperConnect(MultipleConnectAsync args);
    internal void CancelConnectAsync();
    internal void StartOperationReceive();
    internal void StartOperationReceiveFrom();
    internal void StartOperationReceiveMessageFrom();
    internal void StartOperationSend();
    internal void StartOperationSendPackets();
    internal void StartOperationSendTo();
    internal void UpdatePerfCounters(int size, bool sendOp);
    internal void FinishOperationSyncFailure(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void FinishConnectByNameSyncFailure(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncFailure(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncFailure(Exception exception, int bytesTransferred, SocketFlags flags);
    internal void FinishWrapperConnectSuccess(Socket connectSocket, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationSuccess(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal Nullable`1<int> get_SendPacketsDescriptorCount();
    private void InitializeInternals();
    private void FreeInternals(bool calledFromFinalizer);
    private void SetupSingleBuffer();
    private void SetupMultipleBuffers();
    private void SetupSendPacketsElements();
    private void InnerComplete();
    private void PrepareIOCPOperation();
    private void CompleteIOCPOperation();
    private void InnerStartOperationAccept(bool userSuppliedBuffer);
    internal SocketError DoOperationAccept(Socket socket, SafeCloseSocket handle, SafeCloseSocket acceptHandle, Int32& bytesTransferred);
    private void InnerStartOperationConnect();
    internal SocketError DoOperationConnect(Socket socket, SafeCloseSocket handle, Int32& bytesTransferred);
    private void InnerStartOperationDisconnect();
    private void InnerStartOperationReceive();
    internal SocketError DoOperationReceive(SafeCloseSocket handle, SocketFlags& flags, Int32& bytesTransferred);
    private void InnerStartOperationReceiveFrom();
    internal SocketError DoOperationReceiveFrom(SafeCloseSocket handle, SocketFlags& flags, Int32& bytesTransferred);
    private void InnerStartOperationReceiveMessageFrom();
    internal SocketError DoOperationReceiveMessageFrom(Socket socket, SafeCloseSocket handle, Int32& bytesTransferred);
    private void InnerStartOperationSend();
    internal SocketError DoOperationSend(SafeCloseSocket handle, Int32& bytesTransferred);
    private void InnerStartOperationSendPackets();
    internal SocketError DoOperationSendPackets(Socket socket, SafeCloseSocket handle);
    private void InnerStartOperationSendTo();
    internal SocketError DoOperationSendTo(SafeCloseSocket handle, Int32& bytesTransferred);
    private void CheckPinNoBuffer();
    private void CheckPinSingleBuffer(bool pinUsersBuffer);
    private void CheckPinMultipleBuffers();
    private void CheckPinSendPackets();
    private void PinSocketAddressBuffer();
    private void FreeOverlapped(bool checkForShutdown);
    private void SetupOverlappedSingle(bool pinSingleBuffer);
    private void SetupOverlappedMultiple();
    private void SetupOverlappedSendPackets();
    internal void LogBuffer(int size);
    internal void LogSendPacketsBuffers(int size);
    private SocketError FinishOperationAccept(SocketAddress remoteSocketAddress);
    private SocketError FinishOperationConnect();
    private int GetSocketAddressSize();
    private void FinishOperationReceiveMessageFrom();
    private void FinishOperationSendPackets();
    private void CompletionPortCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
}
public enum System.Net.Sockets.SocketAsyncOperation : Enum {
    public int value__;
    public static SocketAsyncOperation None;
    public static SocketAsyncOperation Accept;
    public static SocketAsyncOperation Connect;
    public static SocketAsyncOperation Disconnect;
    public static SocketAsyncOperation Receive;
    public static SocketAsyncOperation ReceiveFrom;
    public static SocketAsyncOperation ReceiveMessageFrom;
    public static SocketAsyncOperation Send;
    public static SocketAsyncOperation SendPackets;
    public static SocketAsyncOperation SendTo;
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketFlags : Enum {
    public int value__;
    public static SocketFlags None;
    public static SocketFlags OutOfBand;
    public static SocketFlags Peek;
    public static SocketFlags DontRoute;
    public static SocketFlags Truncated;
    public static SocketFlags ControlDataTruncated;
    public static SocketFlags Broadcast;
    public static SocketFlags Multicast;
    public static SocketFlags Partial;
}
public enum System.Net.Sockets.SocketOptionLevel : Enum {
    public int value__;
    public static SocketOptionLevel Socket;
    public static SocketOptionLevel IP;
    public static SocketOptionLevel IPv6;
    public static SocketOptionLevel Tcp;
    public static SocketOptionLevel Udp;
}
public enum System.Net.Sockets.SocketOptionName : Enum {
    public int value__;
    public static SocketOptionName Debug;
    public static SocketOptionName AcceptConnection;
    public static SocketOptionName ReuseAddress;
    public static SocketOptionName KeepAlive;
    public static SocketOptionName DontRoute;
    public static SocketOptionName Broadcast;
    public static SocketOptionName UseLoopback;
    public static SocketOptionName Linger;
    public static SocketOptionName OutOfBandInline;
    public static SocketOptionName DontLinger;
    public static SocketOptionName ExclusiveAddressUse;
    public static SocketOptionName SendBuffer;
    public static SocketOptionName ReceiveBuffer;
    public static SocketOptionName SendLowWater;
    public static SocketOptionName ReceiveLowWater;
    public static SocketOptionName SendTimeout;
    public static SocketOptionName ReceiveTimeout;
    public static SocketOptionName Error;
    public static SocketOptionName Type;
    public static SocketOptionName ReuseUnicastPort;
    public static SocketOptionName MaxConnections;
    public static SocketOptionName IPOptions;
    public static SocketOptionName HeaderIncluded;
    public static SocketOptionName TypeOfService;
    public static SocketOptionName IpTimeToLive;
    public static SocketOptionName MulticastInterface;
    public static SocketOptionName MulticastTimeToLive;
    public static SocketOptionName MulticastLoopback;
    public static SocketOptionName AddMembership;
    public static SocketOptionName DropMembership;
    public static SocketOptionName DontFragment;
    public static SocketOptionName AddSourceMembership;
    public static SocketOptionName DropSourceMembership;
    public static SocketOptionName BlockSource;
    public static SocketOptionName UnblockSource;
    public static SocketOptionName PacketInformation;
    public static SocketOptionName HopLimit;
    public static SocketOptionName IPProtectionLevel;
    public static SocketOptionName IPv6Only;
    public static SocketOptionName NoDelay;
    public static SocketOptionName BsdUrgent;
    public static SocketOptionName Expedited;
    public static SocketOptionName NoChecksum;
    public static SocketOptionName ChecksumCoverage;
    public static SocketOptionName UpdateAcceptContext;
    public static SocketOptionName UpdateConnectContext;
}
internal static class System.Net.Sockets.SocketPal : object {
    public static bool SupportsMultipleConnectAttempts;
    private static int s_protocolInformationSize;
    public static int ProtocolInformationSize { get; }
    private static SocketPal();
    public static int get_ProtocolInformationSize();
    private static void MicrosecondsToTimeValue(long microseconds, TimeValue& socketTime);
    public static void Initialize();
    public static SocketError GetLastSocketError();
    public static SocketError CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, SafeCloseSocket& socket);
    public static SocketError SetBlocking(SafeCloseSocket handle, bool shouldBlock, Boolean& willBlock);
    public static SocketError GetSockName(SafeCloseSocket handle, Byte[] buffer, Int32& nameLen);
    public static SocketError GetAvailable(SafeCloseSocket handle, Int32& available);
    public static SocketError GetPeerName(SafeCloseSocket handle, Byte[] buffer, Int32& nameLen);
    public static SocketError Bind(SafeCloseSocket handle, Byte[] buffer, int nameLen);
    public static SocketError Listen(SafeCloseSocket handle, int backlog);
    public static SocketError Accept(SafeCloseSocket handle, Byte[] buffer, Int32& nameLen, SafeCloseSocket& socket);
    public static SocketError Connect(SafeCloseSocket handle, Byte[] peerAddress, int peerAddressLen);
    public static SocketError Send(SafeCloseSocket handle, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError Send(SafeCloseSocket handle, Byte[] buffer, int offset, int size, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError SendTo(SafeCloseSocket handle, Byte[] buffer, int offset, int size, SocketFlags socketFlags, Byte[] peerAddress, int peerAddressSize, Int32& bytesTransferred);
    public static SocketError Receive(SafeCloseSocket handle, IList`1<ArraySegment`1<byte>> buffers, SocketFlags& socketFlags, Int32& bytesTransferred);
    public static SocketError Receive(SafeCloseSocket handle, Byte[] buffer, int offset, int size, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError ReceiveMessageFrom(Socket socket, SafeCloseSocket handle, Byte[] buffer, int offset, int size, SocketFlags& socketFlags, SocketAddress socketAddress, SocketAddress& receiveAddress, IPPacketInformation& ipPacketInformation, Int32& bytesTransferred);
    public static SocketError ReceiveFrom(SafeCloseSocket handle, Byte[] buffer, int offset, int size, SocketFlags socketFlags, Byte[] socketAddress, Int32& addressLength, Int32& bytesTransferred);
    public static SocketError WindowsIoctl(SafeCloseSocket handle, int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue, Int32& optionLength);
    public static SocketError SetSockOpt(SafeCloseSocket handle, SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    public static SocketError SetSockOpt(SafeCloseSocket handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public static void SetReceivingDualModeIPv4PacketInformation(Socket socket);
    public static SocketError SetMulticastOption(SafeCloseSocket handle, SocketOptionName optionName, MulticastOption optionValue);
    public static SocketError SetIPv6MulticastOption(SafeCloseSocket handle, SocketOptionName optionName, IPv6MulticastOption optionValue);
    public static SocketError SetLingerOption(SafeCloseSocket handle, LingerOption optionValue);
    public static SocketError GetSockOpt(SafeCloseSocket handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Int32& optionValue);
    public static SocketError GetSockOpt(SafeCloseSocket handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue, Int32& optionLength);
    public static SocketError GetMulticastOption(SafeCloseSocket handle, SocketOptionName optionName, MulticastOption& optionValue);
    public static SocketError GetIPv6MulticastOption(SafeCloseSocket handle, SocketOptionName optionName, IPv6MulticastOption& optionValue);
    public static SocketError GetLingerOption(SafeCloseSocket handle, LingerOption& optionValue);
    public static SocketError Poll(SafeCloseSocket handle, int microseconds, SelectMode mode, Boolean& status);
    public static SocketError Select(IList checkRead, IList checkWrite, IList checkError, int microseconds);
    public static SocketError Shutdown(SafeCloseSocket handle, bool isConnected, bool isDisconnected, SocketShutdown how);
    public static SocketError ConnectAsync(Socket socket, SafeCloseSocket handle, Byte[] socketAddress, int socketAddressLen, ConnectOverlappedAsyncResult asyncResult);
    public static SocketError SendAsync(SafeCloseSocket handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    public static SocketError SendAsync(SafeCloseSocket handle, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    public static SocketError SendToAsync(SafeCloseSocket handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, SocketAddress socketAddress, OverlappedAsyncResult asyncResult);
    public static SocketError ReceiveAsync(SafeCloseSocket handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    public static SocketError ReceiveAsync(SafeCloseSocket handle, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, OverlappedAsyncResult asyncResult);
    public static SocketError ReceiveFromAsync(SafeCloseSocket handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, SocketAddress socketAddress, OverlappedAsyncResult asyncResult);
    public static SocketError ReceiveMessageFromAsync(Socket socket, SafeCloseSocket handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, SocketAddress socketAddress, ReceiveMessageOverlappedAsyncResult asyncResult);
    public static SocketError AcceptAsync(Socket socket, SafeCloseSocket handle, SafeCloseSocket acceptHandle, int receiveSize, int socketAddressSize, AcceptOverlappedAsyncResult asyncResult);
    public static void CheckDualModeReceiveSupport(Socket socket);
}
public class System.Net.Sockets.SocketReceiveFromResult : ValueType {
    public int ReceivedBytes;
    public EndPoint RemoteEndPoint;
}
public class System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
    public int ReceivedBytes;
    public SocketFlags SocketFlags;
    public EndPoint RemoteEndPoint;
    public IPPacketInformation PacketInformation;
}
public enum System.Net.Sockets.SocketShutdown : Enum {
    public int value__;
    public static SocketShutdown Receive;
    public static SocketShutdown Send;
    public static SocketShutdown Both;
}
[ExtensionAttribute]
public static class System.Net.Sockets.SocketTaskExtensions : object {
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket);
    [ExtensionAttribute]
public static Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress address, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, IPAddress[] addresses, int port);
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, string host, int port);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
public static Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
}
public enum System.Net.Sockets.SocketType : Enum {
    public int value__;
    public static SocketType Stream;
    public static SocketType Dgram;
    public static SocketType Raw;
    public static SocketType Rdm;
    public static SocketType Seqpacket;
    public static SocketType Unknown;
}
public class System.Net.Sockets.TcpClient : object {
    private AddressFamily _family;
    private Socket _clientSocket;
    private NetworkStream _dataStream;
    private bool _cleanedUp;
    private bool _active;
    protected bool Active { get; protected set; }
    public int Available { get; }
    [DebuggerBrowsableAttribute("0")]
public Socket Client { get; public set; }
    public bool Connected { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    private Socket ClientCore { get; private set; }
    private int AvailableCore { get; }
    private bool ConnectedCore { get; }
    private bool ExclusiveAddressUseCore { get; private set; }
    private int ReceiveBufferSizeCore { get; private set; }
    private int SendBufferSizeCore { get; private set; }
    private int ReceiveTimeoutCore { get; private set; }
    private int SendTimeoutCore { get; private set; }
    private LingerOption LingerStateCore { get; private set; }
    private bool NoDelayCore { get; private set; }
    public TcpClient(AddressFamily family);
    internal TcpClient(Socket acceptedSocket);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public Socket get_Client();
    public void set_Client(Socket value);
    public bool get_Connected();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public Task ConnectAsync(IPAddress address, int port);
    public Task ConnectAsync(string host, int port);
    public Task ConnectAsync(IPAddress[] addresses, int port);
    private IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    private void EndConnect(IAsyncResult asyncResult);
    public NetworkStream GetStream();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    private Socket CreateSocket();
    private void InitializeClientSocket();
    private void DisposeCore();
    private Socket get_ClientCore();
    private void set_ClientCore(Socket value);
    private int get_AvailableCore();
    private bool get_ConnectedCore();
    private bool get_ExclusiveAddressUseCore();
    private void set_ExclusiveAddressUseCore(bool value);
    private IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    private IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    private Task ConnectAsyncCore(string host, int port);
    private Task ConnectAsyncCore(IPAddress[] addresses, int port);
    private int get_ReceiveBufferSizeCore();
    private void set_ReceiveBufferSizeCore(int value);
    private int get_SendBufferSizeCore();
    private void set_SendBufferSizeCore(int value);
    private int get_ReceiveTimeoutCore();
    private void set_ReceiveTimeoutCore(int value);
    private int get_SendTimeoutCore();
    private void set_SendTimeoutCore(int value);
    private LingerOption get_LingerStateCore();
    private void set_LingerStateCore(LingerOption value);
    private bool get_NoDelayCore();
    private void set_NoDelayCore(bool value);
}
public class System.Net.Sockets.TcpListener : object {
    private IPEndPoint _serverSocketEP;
    private Socket _serverSocket;
    private bool _active;
    private bool _exclusiveAddressUse;
    public Socket Server { get; }
    protected bool Active { get; }
    public EndPoint LocalEndpoint { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public TcpListener(IPEndPoint localEP);
    public TcpListener(IPAddress localaddr, int port);
    public Socket get_Server();
    protected bool get_Active();
    public EndPoint get_LocalEndpoint();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void Start();
    public void Start(int backlog);
    public void Stop();
    public bool Pending();
    internal IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state);
    internal Socket EndAcceptSocket(IAsyncResult asyncResult);
    internal IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state);
    internal TcpClient EndAcceptTcpClient(IAsyncResult asyncResult);
    public Task`1<Socket> AcceptSocketAsync();
    public Task`1<TcpClient> AcceptTcpClientAsync();
}
internal class System.Net.Sockets.TransmitPacketsDelegate : MulticastDelegate {
    public TransmitPacketsDelegate(object object, IntPtr method);
    public virtual bool Invoke(SafeCloseSocket socketHandle, IntPtr packetArray, int elementCount, int sendSize, SafeNativeOverlapped overlapped, int flags);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, IntPtr packetArray, int elementCount, int sendSize, SafeNativeOverlapped overlapped, int flags, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Net.Sockets.UdpClient : object {
    private static int MaxUDPSize;
    private Socket _clientSocket;
    private bool _active;
    private Byte[] _buffer;
    private AddressFamily _family;
    private bool _cleanedUp;
    private bool _isBroadcast;
    protected bool Active { get; protected set; }
    public int Available { get; }
    public Socket Client { get; public set; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public UdpClient(AddressFamily family);
    public UdpClient(int port);
    public UdpClient(int port, AddressFamily family);
    public UdpClient(IPEndPoint localEP);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public Socket get_Client();
    public void set_Client(Socket value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    private void FreeResources();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void CheckForBroadcast(IPAddress ipAddress);
    private bool IsBroadcast(IPAddress address);
    internal IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state);
    internal IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);
    internal IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state);
    internal int EndSend(IAsyncResult asyncResult);
    internal IAsyncResult BeginReceive(AsyncCallback requestCallback, object state);
    internal Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP);
    public void JoinMulticastGroup(IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress);
    public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive);
    public void DropMulticastGroup(IPAddress multicastAddr);
    public void DropMulticastGroup(IPAddress multicastAddr, int ifindex);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port);
    public Task`1<UdpReceiveResult> ReceiveAsync();
    private void CreateClientSocket();
}
public class System.Net.Sockets.UdpReceiveResult : ValueType {
    private Byte[] _buffer;
    private IPEndPoint _remoteEndPoint;
    public Byte[] Buffer { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public UdpReceiveResult(Byte[] buffer, IPEndPoint remoteEndPoint);
    public Byte[] get_Buffer();
    public IPEndPoint get_RemoteEndPoint();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UdpReceiveResult other);
    public static bool op_Equality(UdpReceiveResult left, UdpReceiveResult right);
    public static bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right);
}
internal class System.Net.Sockets.WSABuffer : ValueType {
    internal int Length;
    internal IntPtr Pointer;
}
internal class System.Net.Sockets.WSARecvMsgDelegate : MulticastDelegate {
    public WSARecvMsgDelegate(object object, IntPtr method);
    public virtual SocketError Invoke(SafeCloseSocket socketHandle, IntPtr msg, Int32& bytesTransferred, SafeHandle overlapped, IntPtr completionRoutine);
    public virtual IAsyncResult BeginInvoke(SafeCloseSocket socketHandle, IntPtr msg, Int32& bytesTransferred, SafeHandle overlapped, IntPtr completionRoutine, AsyncCallback callback, object object);
    public virtual SocketError EndInvoke(Int32& bytesTransferred, IAsyncResult result);
}
internal class System.Net.Sockets.WSARecvMsgDelegateBlocking : MulticastDelegate {
    public WSARecvMsgDelegateBlocking(object object, IntPtr method);
    public virtual SocketError Invoke(IntPtr socketHandle, IntPtr msg, Int32& bytesTransferred, IntPtr overlapped, IntPtr completionRoutine);
    public virtual IAsyncResult BeginInvoke(IntPtr socketHandle, IntPtr msg, Int32& bytesTransferred, IntPtr overlapped, IntPtr completionRoutine, AsyncCallback callback, object object);
    public virtual SocketError EndInvoke(Int32& bytesTransferred, IAsyncResult result);
}
[EventSourceAttribute]
internal class System.Net.SocketsEventSource : EventSource {
    private static int AcceptedId;
    private static int ConnectedId;
    private static int ConnectedAsyncDnsId;
    private static int NotLoggedFileId;
    private static int DumpArrayId;
    private static int DefaultMaxDumpSize;
    private static SocketsEventSource s_log;
    public static SocketsEventSource Log { get; }
    private static SocketsEventSource();
    public static SocketsEventSource get_Log();
    [NonEventAttribute]
internal static void Accepted(Socket socket, object remoteEp, object localEp);
    [EventAttribute("1")]
internal void Accepted(string remoteEp, string localEp, int socketHash);
    [NonEventAttribute]
internal static void Connected(Socket socket, object localEp, object remoteEp);
    [EventAttribute("2")]
internal void Connected(string localEp, string remoteEp, int socketHash);
    [EventAttribute("3")]
internal void ConnectedAsyncDns(int socketHash);
    [EventAttribute("4")]
internal void NotLoggedFile(string filePath, int socketHash, SocketAsyncOperation completedOperation);
    [NonEventAttribute]
internal static void Dump(IntPtr bufferPtr, int length, string callerName);
    [NonEventAttribute]
internal static void Dump(Byte[] buffer, int offset, int length, string callerName);
    [EventAttribute("5")]
internal void DebugDumpArray(Byte[] buffer, string callerMemberName);
}
internal static class System.Net.TcpValidationHelpers : object {
    public static bool ValidatePortNumber(int port);
}
[FlagsAttribute]
internal enum System.Net.ThreadKinds : Enum {
    public int value__;
    public static ThreadKinds Unknown;
    public static ThreadKinds User;
    public static ThreadKinds System;
    public static ThreadKinds Sync;
    public static ThreadKinds Async;
    public static ThreadKinds Timer;
    public static ThreadKinds CompletionPort;
    public static ThreadKinds Worker;
    public static ThreadKinds Finalization;
    public static ThreadKinds Other;
    public static ThreadKinds OwnerMask;
    public static ThreadKinds SyncMask;
    public static ThreadKinds SourceMask;
    public static ThreadKinds SafeSources;
    public static ThreadKinds ThreadPool;
}
public enum System.Net.TransportType : Enum {
    public int value__;
    public static TransportType Udp;
    public static TransportType Connectionless;
    public static TransportType Tcp;
    public static TransportType ConnectionOriented;
    public static TransportType All;
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string net_invalidversion { get; }
    internal static string net_noseek { get; }
    internal static string net_invasync { get; }
    internal static string net_io_timeout_use_gt_zero { get; }
    internal static string net_notconnected { get; }
    internal static string net_notstream { get; }
    internal static string net_stopped { get; }
    internal static string net_udpconnected { get; }
    internal static string net_readonlystream { get; }
    internal static string net_writeonlystream { get; }
    internal static string net_InvalidSocketHandle { get; }
    internal static string net_InvalidAddressFamily { get; }
    internal static string net_InvalidEndPointAddressFamily { get; }
    internal static string net_InvalidSocketAddressSize { get; }
    internal static string net_invalidAddressList { get; }
    internal static string net_completed_result { get; }
    internal static string net_protocol_invalid_family { get; }
    internal static string net_protocol_invalid_multicast_family { get; }
    internal static string net_sockets_zerolist { get; }
    internal static string net_sockets_blocking { get; }
    internal static string net_sockets_useblocking { get; }
    internal static string net_sockets_select { get; }
    internal static string net_sockets_toolarge_select { get; }
    internal static string net_sockets_empty_select { get; }
    internal static string net_sockets_mustbind { get; }
    internal static string net_sockets_mustlisten { get; }
    internal static string net_sockets_mustnotlisten { get; }
    internal static string net_sockets_mustnotbebound { get; }
    internal static string net_sockets_namedmustnotbebound { get; }
    internal static string net_sockets_invalid_ipaddress_length { get; }
    internal static string net_sockets_invalid_optionValue { get; }
    internal static string net_sockets_invalid_optionValue_all { get; }
    internal static string net_sockets_invalid_dnsendpoint { get; }
    internal static string net_sockets_disconnectedConnect { get; }
    internal static string net_sockets_disconnectedAccept { get; }
    internal static string net_tcplistener_mustbestopped { get; }
    internal static string net_socketopinprogress { get; }
    internal static string net_buffercounttoosmall { get; }
    internal static string net_multibuffernotsupported { get; }
    internal static string net_ambiguousbuffers { get; }
    internal static string net_io_writefailure { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_value_cannot_be_negative { get; }
    internal static string net_log_exception { get; }
    internal static string net_log_socket_connected { get; }
    internal static string event_Accepted { get; }
    internal static string event_NotLoggedFile { get; }
    internal static string event_ConnectedAsyncDns { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper { get; }
    internal static string net_sockets_connect_multiaddress_notsupported { get; }
    internal static string net_sockets_connect_multiconnect_notsupported { get; }
    internal static string net_sockets_dualmode_receivefrom_notsupported { get; }
    internal static string net_sockets_accept_receive_notsupported { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_net_invalidversion();
    internal static string get_net_noseek();
    internal static string get_net_invasync();
    internal static string get_net_io_timeout_use_gt_zero();
    internal static string get_net_notconnected();
    internal static string get_net_notstream();
    internal static string get_net_stopped();
    internal static string get_net_udpconnected();
    internal static string get_net_readonlystream();
    internal static string get_net_writeonlystream();
    internal static string get_net_InvalidSocketHandle();
    internal static string get_net_InvalidAddressFamily();
    internal static string get_net_InvalidEndPointAddressFamily();
    internal static string get_net_InvalidSocketAddressSize();
    internal static string get_net_invalidAddressList();
    internal static string get_net_completed_result();
    internal static string get_net_protocol_invalid_family();
    internal static string get_net_protocol_invalid_multicast_family();
    internal static string get_net_sockets_zerolist();
    internal static string get_net_sockets_blocking();
    internal static string get_net_sockets_useblocking();
    internal static string get_net_sockets_select();
    internal static string get_net_sockets_toolarge_select();
    internal static string get_net_sockets_empty_select();
    internal static string get_net_sockets_mustbind();
    internal static string get_net_sockets_mustlisten();
    internal static string get_net_sockets_mustnotlisten();
    internal static string get_net_sockets_mustnotbebound();
    internal static string get_net_sockets_namedmustnotbebound();
    internal static string get_net_sockets_invalid_ipaddress_length();
    internal static string get_net_sockets_invalid_optionValue();
    internal static string get_net_sockets_invalid_optionValue_all();
    internal static string get_net_sockets_invalid_dnsendpoint();
    internal static string get_net_sockets_disconnectedConnect();
    internal static string get_net_sockets_disconnectedAccept();
    internal static string get_net_tcplistener_mustbestopped();
    internal static string get_net_socketopinprogress();
    internal static string get_net_buffercounttoosmall();
    internal static string get_net_multibuffernotsupported();
    internal static string get_net_ambiguousbuffers();
    internal static string get_net_io_writefailure();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_value_cannot_be_negative();
    internal static string get_net_log_exception();
    internal static string get_net_log_socket_connected();
    internal static string get_event_Accepted();
    internal static string get_event_NotLoggedFile();
    internal static string get_event_ConnectedAsyncDns();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper();
    internal static string get_net_sockets_connect_multiaddress_notsupported();
    internal static string get_net_sockets_connect_multiconnect_notsupported();
    internal static string get_net_sockets_dualmode_receivefrom_notsupported();
    internal static string get_net_sockets_accept_receive_notsupported();
    internal static Type get_ResourceType();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
