internal static class FxResources.System.Private.Reflection.Execution.SR : object {
}
[ExtensionAttribute]
internal static class Internal.LowLevelLinq.LowLevelEnumerable : object {
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values, Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(IEnumerable`1<T> values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(T[] values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Where>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Where(IEnumerable`1<T> source, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static T[] ToArray(IEnumerable`1<T> values);
}
internal enum Internal.NativeFormat.BagElementKind : Enum {
    public UInt32 value__;
    public static BagElementKind End;
    public static BagElementKind BaseType;
    public static BagElementKind ImplementedInterfaces;
    public static BagElementKind DictionaryLayout;
    public static BagElementKind TypeFlags;
    public static BagElementKind NonGcStaticData;
    public static BagElementKind GcStaticData;
    public static BagElementKind NonGcStaticDataSize;
    public static BagElementKind GcStaticDataSize;
    public static BagElementKind GcStaticDesc;
    public static BagElementKind ThreadStaticDataSize;
    public static BagElementKind ThreadStaticDesc;
    public static BagElementKind ThreadStaticIndex;
    public static BagElementKind ThreadStaticOffset;
    public static BagElementKind FieldLayout;
    public static BagElementKind VTableMethodSignatures;
    public static BagElementKind SealedVTableEntries;
    public static BagElementKind ClassConstructorPointer;
    public static BagElementKind BaseTypeSize;
    public static BagElementKind GenericVarianceInfo;
    public static BagElementKind DelegateInvokeSignature;
    public static BagElementKind GcStaticEEType;
}
internal enum Internal.NativeFormat.CallingConventionConverterKind : Enum {
    public UInt32 value__;
    public static CallingConventionConverterKind NoInstantiatingParam;
    public static CallingConventionConverterKind HasInstantiatingParam;
    public static CallingConventionConverterKind MaybeInstantiatingParam;
}
internal enum Internal.NativeFormat.FieldStorage : Enum {
    public UInt32 value__;
    public static FieldStorage Instance;
    public static FieldStorage NonGCStatic;
    public static FieldStorage GCStatic;
    public static FieldStorage TLSStatic;
}
internal enum Internal.NativeFormat.FixupSignatureKind : Enum {
    public UInt32 value__;
    public static FixupSignatureKind Null;
    public static FixupSignatureKind TypeHandle;
    public static FixupSignatureKind InterfaceCall;
    public static FixupSignatureKind MethodDictionary;
    public static FixupSignatureKind StaticData;
    public static FixupSignatureKind UnwrapNullableType;
    public static FixupSignatureKind FieldLdToken;
    public static FixupSignatureKind MethodLdToken;
    public static FixupSignatureKind AllocateObject;
    public static FixupSignatureKind DefaultConstructor;
    public static FixupSignatureKind TlsIndex;
    public static FixupSignatureKind TlsOffset;
    public static FixupSignatureKind Method;
    public static FixupSignatureKind IsInst;
    public static FixupSignatureKind CastClass;
    public static FixupSignatureKind AllocateArray;
    public static FixupSignatureKind CheckArrayElementType;
    public static FixupSignatureKind TypeSize;
    public static FixupSignatureKind FieldOffset;
    public static FixupSignatureKind CallingConventionConverter;
    public static FixupSignatureKind VTableOffset;
    public static FixupSignatureKind NonGenericConstrainedMethod;
    public static FixupSignatureKind GenericConstrainedMethod;
    public static FixupSignatureKind NonGenericDirectConstrainedMethod;
    public static FixupSignatureKind PointerToOtherSlot;
    public static FixupSignatureKind IntValue;
    public static FixupSignatureKind NotYetSupported;
}
internal enum Internal.NativeFormat.GenericContextKind : Enum {
    public UInt32 value__;
    public static GenericContextKind FromThis;
    public static GenericContextKind FromHiddenArg;
    public static GenericContextKind FromMethodHiddenArg;
    public static GenericContextKind HasDeclaringType;
    public static GenericContextKind NeedsUSGContext;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodCallingConvention : Enum {
    public UInt32 value__;
    public static MethodCallingConvention Generic;
    public static MethodCallingConvention Static;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodFlags : Enum {
    public UInt32 value__;
    public static MethodFlags HasInstantiation;
    public static MethodFlags IsUnboxingStub;
    public static MethodFlags HasFunctionPointer;
    public static MethodFlags FunctionPointerIsUSG;
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public BagElementKind GetBagElementKind();
    public FixupSignatureKind GetFixupSignatureKind();
    public TypeSignatureKind GetTypeSignatureKind(UInt32& data);
    public NativeParser GetLookbackParser(UInt32 lookback);
    public Nullable`1<UInt32> GetUnsignedForBagElementKind(BagElementKind kindToFind);
    public NativeParser GetParserForBagElementKind(BagElementKind kindToFind);
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
internal enum Internal.NativeFormat.StaticDataKind : Enum {
    public UInt32 value__;
    public static StaticDataKind Gc;
    public static StaticDataKind NonGc;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.TypeFlags : Enum {
    public UInt32 value__;
    public static TypeFlags HasClassConstructor;
    public static TypeFlags HasInstantiationDeterminedSize;
}
internal enum Internal.NativeFormat.TypeModifierKind : Enum {
    public UInt32 value__;
    public static TypeModifierKind Array;
    public static TypeModifierKind ByRef;
    public static TypeModifierKind Pointer;
}
internal enum Internal.NativeFormat.TypeSignatureKind : Enum {
    public UInt32 value__;
    public static TypeSignatureKind Null;
    public static TypeSignatureKind Lookback;
    public static TypeSignatureKind Modifier;
    public static TypeSignatureKind Instantiation;
    public static TypeSignatureKind Variable;
    public static TypeSignatureKind BuiltIn;
    public static TypeSignatureKind External;
    public static TypeSignatureKind MultiDimArray;
    public static TypeSignatureKind FunctionPointer;
}
[ExtensionAttribute]
internal static class Internal.Reflection.Execution.ConstraintValidator : object {
    [ExtensionAttribute]
private static bool SatisfiesConstraints(Type genericVariable, SigTypeContext typeContextOfConstraintDeclarer, Type typeArg);
    private static void EnsureSatisfiesClassConstraints(Type[] typeParameters, Type[] typeArguments, object definition, SigTypeContext typeContext);
    public static void EnsureSatisfiesClassConstraints(Type typeDefinition, Type[] typeArguments);
    public static void EnsureSatisfiesClassConstraints(MethodInfo reflectionMethodInfo);
    [ExtensionAttribute]
private static Type Instantiate(Type type, SigTypeContext context);
    [ExtensionAttribute]
private static bool IsInstantiatedTypeInfo(Type type);
    [ExtensionAttribute]
private static bool IsNullable(Type type);
    [ExtensionAttribute]
private static Type GetNullableType(Type type);
    [ExtensionAttribute]
private static bool IsSystemObject(Type type);
    [ExtensionAttribute]
private static bool IsSystemValueType(Type type);
    [ExtensionAttribute]
private static bool IsSystemArray(Type type);
    [ExtensionAttribute]
private static bool IsSystemVoid(Type type);
    [ExtensionAttribute]
private static bool HasExplicitOrImplicitPublicDefaultConstructor(Type type);
    [ExtensionAttribute]
private static int NormalizedPrimitiveTypeSizeForIntegerTypes(Type type);
    private static bool ImplementsInterface(Type pObjType, Type pTargetType);
    private static bool TypesAreCompatibleViaGenericVariance(Type pSourceType, Type pTargetType);
    private static bool TypeParametersAreCompatible(Type[] pSourceInstantiation, Type[] pTargetInstantiation, Type[] pVarianceInfo, bool fForceCovariance);
    private static bool AreTypesAssignable(Type pSourceType, Type pTargetType);
    private static bool AreTypesAssignableInternal(Type pSourceType, Type pTargetType, bool fBoxedSource, bool fAllowSizeEquivalence);
    private static bool IsDerived(Type pDerivedType, Type pBaseType);
    private static bool AreTypesEquivalentInternal(Type pType1, Type pType2);
    private static bool ArePrimitveTypesEquivalentSize(Type pType1, Type pType2);
}
internal class Internal.Reflection.Execution.ExecutionEnvironmentImplementation : ExecutionEnvironment {
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _ldftnReverseLookup_InvokeMap;
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _ldftnReverseLookup_ExactInstantiations;
    private Func`2<NativeFormatModuleInfo, FunctionPointersToOffsets> _computeLdFtnLookupInvokeMapInvokeMap;
    private Func`2<NativeFormatModuleInfo, FunctionPointersToOffsets> _computeLdFtnLookupExactInstantiations;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_extractedResourceDictionary;
    public RuntimeTypeHandle ProjectionTypeForArrays { get; }
    private LowLevelDictionary`2<string, LowLevelList`1<ResourceInfo>> ExtractedResourceDictionary { get; }
    public sealed virtual bool IsCOMObject(Type type);
    public sealed virtual object NewObject(RuntimeTypeHandle typeHandle);
    public sealed virtual Array NewArray(RuntimeTypeHandle typeHandleForArrayType, int count);
    public sealed virtual Array NewMultiDimArray(RuntimeTypeHandle typeHandleForArrayType, Int32[] lengths, Int32[] lowerBounds);
    public sealed virtual RuntimeTypeHandle get_ProjectionTypeForArrays();
    public sealed virtual bool IsAssignableFrom(RuntimeTypeHandle dstType, RuntimeTypeHandle srcType);
    public sealed virtual bool TryGetBaseType(RuntimeTypeHandle typeHandle, RuntimeTypeHandle& baseTypeHandle);
    public sealed virtual IEnumerable`1<RuntimeTypeHandle> TryGetImplementedInterfaces(RuntimeTypeHandle typeHandle);
    public sealed virtual string GetLastResortString(RuntimeTypeHandle typeHandle);
    public sealed virtual FieldAccessor CreateLiteralFieldAccessor(object value, RuntimeTypeHandle fieldTypeHandle);
    private RuntimeTypeHandle GetOpenTypeDefinition(RuntimeTypeHandle typeHandle, RuntimeTypeHandle[]& typeArgumentsHandles);
    private RuntimeTypeHandle GetTypeDefinition(RuntimeTypeHandle typeHandle);
    private static bool RuntimeTypeHandleIsNonDefault(RuntimeTypeHandle runtimeTypeHandle);
    private static NativeReader GetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob);
    private static bool TryGetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob, NativeReader& reader);
    public sealed virtual bool TryGetMetadataForNamedType(RuntimeTypeHandle runtimeTypeHandle, QTypeDefinition& qTypeDefinition);
    public sealed virtual bool IsReflectionBlocked(RuntimeTypeHandle runtimeTypeHandle);
    public sealed virtual bool TryGetNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public sealed virtual bool TryGetTypeReferenceForNamedType(RuntimeTypeHandle runtimeTypeHandle, MetadataReader& metadataReader, TypeReferenceHandle& typeRefHandle);
    public sealed virtual bool TryGetNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle);
    public sealed virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& arrayTypeHandle);
    public sealed virtual bool TryGetArrayTypeElementType(RuntimeTypeHandle arrayTypeHandle, RuntimeTypeHandle& elementTypeHandle);
    public sealed virtual bool TryGetMultiDimArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public sealed virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public sealed virtual bool TryGetPointerTypeTargetType(RuntimeTypeHandle pointerTypeHandle, RuntimeTypeHandle& targetTypeHandle);
    public sealed virtual bool TryGetByRefTypeForTargetType(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public sealed virtual bool TryGetByRefTypeTargetType(RuntimeTypeHandle byRefTypeHandle, RuntimeTypeHandle& targetTypeHandle);
    public sealed virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public sealed virtual MethodInvoker TryGetMethodInvoker(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles);
    private void GetDynamicMethodInvokeMethodInfo(NativeFormatModuleInfo module, UInt32 cookie, RuntimeTypeHandle[] argHandles, IntPtr& dynamicInvokeMethod, IntPtr& dynamicInvokeMethodGenericDictionary);
    private IntPtr GetDynamicMethodInvokerThunk(MethodBase methodInfo);
    private RuntimeTypeHandle[] GetDynamicInvokeInstantiationArguments(MethodBase reflectionMethodBase);
    private static RuntimeTypeHandle[] GetTypeSequence(ExternalReferencesTable& extRefs, NativeParser& parser);
    private IntPtr TryGetVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle methodHandleDeclaringType, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericArgs, MethodSignatureComparer& methodSignatureComparer);
    private MethodInvokeInfo TryGetMethodInvokeInfo(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodBase methodInfo, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind);
    private static IntPtr GetCallingConventionConverterForMethodEntrypoint(MetadataReader metadataReader, RuntimeTypeHandle declaringType, IntPtr methodEntrypoint, IntPtr dictionary, MethodBase methodBase, MethodHandle mdHandle);
    private RuntimeTypeHandle GetExactDeclaringType(RuntimeTypeHandle dstType, RuntimeTypeHandle srcType);
    private KeyValuePair`2[] GetLdFtnReverseLookups_Helper(KeyValuePair`2[]& ldftnReverseLookupStatic, Func`2<NativeFormatModuleInfo, FunctionPointersToOffsets> lookupComputer);
    private KeyValuePair`2[] GetLdFtnReverseLookups_InvokeMap();
    private KeyValuePair`2[] GetLdFtnReverseLookups_ExactInstantations();
    internal void GetFunctionPointerAndInstantiationArgumentForOriginalLdFtnResult(IntPtr originalLdFtnResult, IntPtr& canonOriginalLdFtnResult, IntPtr& instantiationArgument);
    internal bool TryGetMethodForOriginalLdFtnResult(IntPtr originalLdFtnResult, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    internal bool TryGetMethodForStartAddress(IntPtr methodStartAddress, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle);
    private static FunctionPointersToOffsets ComputeLdftnReverseLookup_InvokeMap(NativeFormatModuleInfo mappingTableModule);
    private bool TryGetMethodForOriginalLdFtnResult_InvokeMap_Inner(NativeFormatModuleInfo mappingTableModule, bool forStartAddress, IntPtr canonOriginalLdFtnResult, IntPtr instantiationArgument, UInt32 parserOffset, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    private static FunctionPointersToOffsets ComputeLdftnReverseLookup_ExactInstantiations(NativeFormatModuleInfo mappingTableModule);
    private bool TryGetMethodForOriginalLdFtnResult_ExactInstantiation_Inner(NativeFormatModuleInfo mappingTableModule, bool forStartAddress, IntPtr canonOriginalLdFtnResult, UInt32 parserOffset, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    private bool TryGetMethodForOriginalLdFtnResult_GenericMethodWithInstantiationArgument(IntPtr instantiationArgument, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public sealed virtual FieldAccessor TryGetFieldAccessor(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle, FieldHandle fieldHandle);
    public sealed virtual bool TryGetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public sealed virtual bool TryGetMethodFromHandleAndType(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public sealed virtual bool TryGetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, FieldHandle& fieldHandle);
    public sealed virtual bool TryGetFieldFromHandleAndType(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle declaringTypeHandle, FieldHandle& fieldHandle);
    internal IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle typeHandle);
    public sealed virtual ManifestResourceInfo GetManifestResourceInfo(Assembly assembly, string resourceName);
    public sealed virtual String[] GetManifestResourceNames(Assembly assembly);
    public sealed virtual Stream GetManifestResourceStream(Assembly assembly, string name);
    private Stream ReadResourceFromBlob(ResourceInfo resourceInfo);
    private LowLevelList`1<ResourceInfo> GetExtractedResources(Assembly assembly);
    private LowLevelDictionary`2<string, LowLevelList`1<ResourceInfo>> get_ExtractedResourceDictionary();
    private Stream ReadFileFromAppDirectory(string name);
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.InstanceFieldAccessor : FieldAccessor {
    [CompilerGeneratedAttribute]
private int <OffsetPlusHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <DeclaringTypeHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <FieldTypeHandle>k__BackingField;
    public int Offset { get; }
    protected int OffsetPlusHeader { get; }
    protected RuntimeTypeHandle DeclaringTypeHandle { get; }
    protected RuntimeTypeHandle FieldTypeHandle { get; }
    public InstanceFieldAccessor(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle, int offsetPlusHeader);
    public abstract virtual int get_Offset();
    public sealed virtual object GetField(object obj);
    public sealed virtual object GetFieldDirect(TypedReference typedReference);
    protected abstract virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    public sealed virtual void SetField(object obj, object value, BinderBundle binderBundle);
    public sealed virtual void SetFieldDirect(TypedReference typedReference, object value);
    protected abstract virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
    protected abstract virtual object UncheckedGetField(object obj);
    protected abstract virtual void UncheckedSetField(object obj, object value);
    [CompilerGeneratedAttribute]
protected int get_OffsetPlusHeader();
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_DeclaringTypeHandle();
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_FieldTypeHandle();
}
internal class Internal.Reflection.Execution.FieldAccessors.LiteralFieldAccessor : StaticFieldAccessor {
    private object _value;
    public LiteralFieldAccessor(object value, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void SetFieldBypassCctor(object value, BinderBundle binderBundle);
    protected sealed virtual void SetFieldDirectBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.PointerTypeFieldAccessorForInstanceFields : InstanceFieldAccessor {
    public int Offset { get; }
    public PointerTypeFieldAccessorForInstanceFields(int offsetPlusHeader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle);
    public sealed virtual int get_Offset();
    protected sealed virtual object UncheckedGetField(object obj);
    protected sealed virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    protected sealed virtual void UncheckedSetField(object obj, object value);
    protected sealed virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.PointerTypeFieldAccessorForStaticFields : RegularStaticFieldAccessor {
    public PointerTypeFieldAccessorForStaticFields(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, bool isGcStatic, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.PointerTypeFieldAccessorForThreadStaticFields : ThreadStaticFieldAccessor {
    public PointerTypeFieldAccessorForThreadStaticFields(IntPtr cctorContext, RuntimeTypeHandle declaringTypeHandle, int threadStaticsBlockOffset, int fieldOffset, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ReferenceTypeFieldAccessorForInstanceFields : InstanceFieldAccessor {
    public int Offset { get; }
    public ReferenceTypeFieldAccessorForInstanceFields(int offsetPlusHeader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle);
    public sealed virtual int get_Offset();
    protected sealed virtual object UncheckedGetField(object obj);
    protected sealed virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    protected sealed virtual void UncheckedSetField(object obj, object value);
    protected sealed virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ReferenceTypeFieldAccessorForStaticFields : RegularStaticFieldAccessor {
    public ReferenceTypeFieldAccessorForStaticFields(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, bool isGcStatic, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ReferenceTypeFieldAccessorForThreadStaticFields : ThreadStaticFieldAccessor {
    public ReferenceTypeFieldAccessorForThreadStaticFields(IntPtr cctorContext, RuntimeTypeHandle declaringTypeHandle, int threadStaticsBlockOffset, int fieldOffset, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.RegularStaticFieldAccessor : WritableStaticFieldAccessor {
    [CompilerGeneratedAttribute]
private IntPtr <StaticsBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGcStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FieldOffset>k__BackingField;
    protected IntPtr StaticsBase { get; }
    protected bool IsGcStatic { get; }
    protected int FieldOffset { get; }
    protected RegularStaticFieldAccessor(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, bool isGcStatic, RuntimeTypeHandle fieldTypeHandle);
    [CompilerGeneratedAttribute]
protected IntPtr get_StaticsBase();
    [CompilerGeneratedAttribute]
protected bool get_IsGcStatic();
    [CompilerGeneratedAttribute]
protected int get_FieldOffset();
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.StaticFieldAccessor : FieldAccessor {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <FieldTypeHandle>k__BackingField;
    private IntPtr _cctorContext;
    protected RuntimeTypeHandle FieldTypeHandle { get; }
    public int Offset { get; }
    public StaticFieldAccessor(IntPtr cctorContext, RuntimeTypeHandle fieldTypeHandle);
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_FieldTypeHandle();
    public sealed virtual object GetField(object obj);
    public sealed virtual object GetFieldDirect(TypedReference typedReference);
    public sealed virtual void SetField(object obj, object value, BinderBundle binderBundle);
    public sealed virtual void SetFieldDirect(TypedReference typedReference, object value);
    public sealed virtual int get_Offset();
    protected abstract virtual object GetFieldBypassCctor();
    protected abstract virtual void SetFieldBypassCctor(object value, BinderBundle binderBundle);
    protected abstract virtual void SetFieldDirectBypassCctor(object value);
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.ThreadStaticFieldAccessor : WritableStaticFieldAccessor {
    [CompilerGeneratedAttribute]
private int <ThreadStaticsBlockOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FieldOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <DeclaringTypeHandle>k__BackingField;
    protected int ThreadStaticsBlockOffset { get; }
    protected int FieldOffset { get; }
    protected RuntimeTypeHandle DeclaringTypeHandle { get; }
    protected ThreadStaticFieldAccessor(IntPtr cctorContext, RuntimeTypeHandle declaringTypeHandle, int threadStaticsBlockOffset, int fieldOffset, RuntimeTypeHandle fieldTypeHandle);
    [CompilerGeneratedAttribute]
protected int get_ThreadStaticsBlockOffset();
    [CompilerGeneratedAttribute]
protected int get_FieldOffset();
    [CompilerGeneratedAttribute]
protected RuntimeTypeHandle get_DeclaringTypeHandle();
}
internal class Internal.Reflection.Execution.FieldAccessors.ValueTypeFieldAccessorForInstanceFields : InstanceFieldAccessor {
    public int Offset { get; }
    public ValueTypeFieldAccessorForInstanceFields(int offsetPlusHeader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle);
    public sealed virtual int get_Offset();
    protected sealed virtual object UncheckedGetField(object obj);
    protected sealed virtual object UncheckedGetFieldDirectFromValueType(TypedReference typedReference);
    protected sealed virtual void UncheckedSetField(object obj, object value);
    protected sealed virtual void UncheckedSetFieldDirectIntoValueType(TypedReference typedReference, object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ValueTypeFieldAccessorForStaticFields : RegularStaticFieldAccessor {
    public ValueTypeFieldAccessorForStaticFields(IntPtr cctorContext, IntPtr staticsBase, int fieldOffset, bool isGcStatic, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal class Internal.Reflection.Execution.FieldAccessors.ValueTypeFieldAccessorForThreadStaticFields : ThreadStaticFieldAccessor {
    public ValueTypeFieldAccessorForThreadStaticFields(IntPtr cctorContext, RuntimeTypeHandle declaringTypeHandle, int threadStaticsBlockOffset, int fieldOffset, RuntimeTypeHandle fieldTypeHandle);
    protected sealed virtual object GetFieldBypassCctor();
    protected sealed virtual void UncheckedSetFieldBypassCctor(object value);
}
internal abstract class Internal.Reflection.Execution.FieldAccessors.WritableStaticFieldAccessor : StaticFieldAccessor {
    protected WritableStaticFieldAccessor(IntPtr cctorContext, RuntimeTypeHandle fieldTypeHandle);
    protected abstract virtual object GetFieldBypassCctor();
    protected sealed virtual void SetFieldBypassCctor(object value, BinderBundle binderBundle);
    protected sealed virtual void SetFieldDirectBypassCctor(object value);
    protected abstract virtual void UncheckedSetFieldBypassCctor(object value);
}
[ExtensionAttribute]
internal static class Internal.Reflection.Execution.MetadataReaderExtensions : object {
    [ExtensionAttribute]
public static string GetString(ConstantStringValueHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetStringOrNull(ConstantStringValueHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsMethodHandle(int i);
    [ExtensionAttribute]
public static int AsInt(MethodHandle methodHandle);
    [ExtensionAttribute]
public static MethodHandle AsMethodHandle(int i);
    [ExtensionAttribute]
public static int AsInt(FieldHandle fieldHandle);
    [ExtensionAttribute]
public static FieldHandle AsFieldHandle(int i);
    [ExtensionAttribute]
public static TypeDefinitionHandle AsTypeDefinitionHandle(int i);
    [ExtensionAttribute]
public static int WithoutHandleType(int constantStringValueHandle);
    [ExtensionAttribute]
public static bool IsConstantStringValueHandle(int i);
}
internal class Internal.Reflection.Execution.MethodInvokeInfo : object {
    [CompilerGeneratedAttribute]
private IntPtr <LdFtnResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <DynamicInvokeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <DynamicInvokeGenericDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodBase <MethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <VirtualResolveData>k__BackingField;
    public IntPtr LdFtnResult { get; public set; }
    public IntPtr DynamicInvokeMethod { get; public set; }
    public IntPtr DynamicInvokeGenericDictionary { get; public set; }
    public MethodBase MethodInfo { get; public set; }
    public IntPtr VirtualResolveData { get; public set; }
    [CompilerGeneratedAttribute]
public IntPtr get_LdFtnResult();
    [CompilerGeneratedAttribute]
public void set_LdFtnResult(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_DynamicInvokeMethod();
    [CompilerGeneratedAttribute]
public void set_DynamicInvokeMethod(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_DynamicInvokeGenericDictionary();
    [CompilerGeneratedAttribute]
public void set_DynamicInvokeGenericDictionary(IntPtr value);
    [CompilerGeneratedAttribute]
public MethodBase get_MethodInfo();
    [CompilerGeneratedAttribute]
public void set_MethodInfo(MethodBase value);
    [CompilerGeneratedAttribute]
public IntPtr get_VirtualResolveData();
    [CompilerGeneratedAttribute]
public void set_VirtualResolveData(IntPtr value);
}
internal class Internal.Reflection.Execution.MethodInvokers.InstanceMethodInvoker : MethodInvokerWithMethodInvokeInfo {
    private RuntimeTypeHandle _declaringTypeHandle;
    public IntPtr LdFtnResult { get; }
    public InstanceMethodInvoker(MethodInvokeInfo methodInvokeInfo, RuntimeTypeHandle declaringTypeHandle);
    [DebuggerGuidedStepThroughAttribute]
protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal abstract class Internal.Reflection.Execution.MethodInvokers.MethodInvokerWithMethodInvokeInfo : MethodInvoker {
    [CompilerGeneratedAttribute]
private MethodInvokeInfo <MethodInvokeInfo>k__BackingField;
    protected MethodInvokeInfo MethodInvokeInfo { get; private set; }
    public MethodInvokerWithMethodInvokeInfo(MethodInvokeInfo methodInvokeInfo);
    public virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    internal static MethodInvoker CreateMethodInvoker(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, MethodInvokeInfo methodInvokeInfo);
    [CompilerGeneratedAttribute]
protected MethodInvokeInfo get_MethodInvokeInfo();
    [CompilerGeneratedAttribute]
private void set_MethodInvokeInfo(MethodInvokeInfo value);
}
internal class Internal.Reflection.Execution.MethodInvokers.StaticMethodInvoker : MethodInvokerWithMethodInvokeInfo {
    public IntPtr LdFtnResult { get; }
    public StaticMethodInvoker(MethodInvokeInfo methodInvokeInfo);
    [DebuggerGuidedStepThroughAttribute]
protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal class Internal.Reflection.Execution.MethodInvokers.VirtualMethodInvoker : MethodInvokerWithMethodInvokeInfo {
    private RuntimeTypeHandle _declaringTypeHandle;
    public IntPtr LdFtnResult { get; }
    public VirtualMethodInvoker(MethodInvokeInfo methodInvokeInfo, RuntimeTypeHandle declaringTypeHandle);
    public sealed virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    [DebuggerGuidedStepThroughAttribute]
protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal static class Internal.Reflection.Execution.PayForPlayExperience.DiagnosticMappingTables : object {
    public static bool TryGetDiagnosticStringForNamedType(RuntimeTypeHandle runtimeTypeHandle, String& diagnosticName, List`1<int> genericParameterOffsets);
    private static void TryGetFullNameFromTypeDefEcma(QTypeDefinition qTypeDefinition, List`1<int> genericParameterOffsets, String& result);
    private static string GetTypeFullNameFromTypeRef(TypeReferenceHandle typeReferenceHandle, MetadataReader reader, List`1<int> genericParameterOffsets);
    public static string ConvertBackTickNameToNameWithReducerInputFormat(string typename, List`1<int> genericParameterOffsets);
    private static string GetTypeFullNameFromTypeDef(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader, List`1<int> genericParameterOffsets);
    public static bool TryGetArrayTypeElementType(RuntimeTypeHandle arrayTypeHandle, RuntimeTypeHandle& elementTypeHandle);
    public static bool TryGetPointerTypeTargetType(RuntimeTypeHandle pointerTypeHandle, RuntimeTypeHandle& targetTypeHandle);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Reflection.Execution.PayForPlayExperience.MissingMetadataExceptionCreator : object {
    internal static MissingMetadataException Create(string resourceId, MemberInfo pertainant);
    internal static MissingMetadataException Create(TypeInfo pertainant);
    internal static MissingMetadataException Create(TypeInfo pertainant, string nestedTypeName);
    internal static MissingMetadataException Create(Type pertainant);
    internal static MissingMetadataException Create(RuntimeTypeHandle pertainant);
    private static MissingMetadataException CreateFromString(string pertainant);
    internal static MissingMetadataException CreateMissingArrayTypeException(Type elementType, bool isMultiDim, int rank);
    internal static MissingMetadataException CreateMissingConstructedGenericTypeException(Type genericTypeDefinition, Type[] genericTypeArguments);
    internal static MissingMetadataException CreateFromMetadataObject(string resourceId, object pertainant);
    public static string ComputeUsefulPertainantIfPossible(object pertainant);
    [ExtensionAttribute]
internal static string ToDisplayStringIfAvailable(Type type, List`1<int> genericParameterOffsets);
    private static string CreateArrayTypeStringIfAvailable(Type elementType, int rank);
    private static string CreateConstructedGenericTypeStringIfAvailable(Type genericTypeDefinition, Type[] genericTypeArguments);
    private static string Format(string resourceMessage, object parameter);
}
internal class Internal.Reflection.Execution.ReflectionDomainSetupImplementation : ReflectionDomainSetup {
    private AssemblyBinderImplementation _assemblyBinder;
    private ExecutionEnvironmentImplementation _executionEnvironment;
    public AssemblyBinder AssemblyBinder { get; }
    public ReflectionDomainSetupImplementation(ExecutionEnvironmentImplementation executionEnvironment);
    public sealed virtual AssemblyBinder get_AssemblyBinder();
    public sealed virtual Exception CreateMissingMetadataException(TypeInfo pertainant);
    public sealed virtual Exception CreateMissingMetadataException(Type pertainant);
    public sealed virtual Exception CreateMissingMetadataException(TypeInfo pertainant, string nestedTypeName);
    public sealed virtual Exception CreateNonInvokabilityException(MemberInfo pertainant);
    public sealed virtual Exception CreateMissingArrayTypeException(Type elementType, bool isMultiDim, int rank);
    public sealed virtual Exception CreateMissingConstructedGenericTypeException(Type genericTypeDefinition, Type[] genericTypeArguments);
}
[__BlockReflectionAttribute]
public static class Internal.Reflection.Execution.ReflectionExecution : object {
    [CompilerGeneratedAttribute]
private static ExecutionEnvironmentImplementation <ExecutionEnvironment>k__BackingField;
    internal static IList`1<string> DefaultAssemblyNamesForGetType;
    internal static ExecutionEnvironmentImplementation ExecutionEnvironment { get; private set; }
    internal static void Initialize();
    public static Type GetType(string typeName, string callingAssemblyName, bool throwOnError, bool ignoreCase);
    public static Type ExtensibleGetType(string typeName, string callingAssemblyName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static bool TryGetMethodMetadataFromStartAddress(IntPtr methodStartAddress, MetadataReader& reader, TypeDefinitionHandle& typeHandle, MethodHandle& methodHandle);
    [CompilerGeneratedAttribute]
internal static ExecutionEnvironmentImplementation get_ExecutionEnvironment();
    [CompilerGeneratedAttribute]
private static void set_ExecutionEnvironment(ExecutionEnvironmentImplementation value);
}
internal class Internal.Reflection.Execution.ReflectionExecutionDomainCallbacksImplementation : ReflectionExecutionDomainCallbacks {
    private ExecutionDomain _executionDomain;
    private ExecutionEnvironmentImplementation _executionEnvironment;
    public ReflectionExecutionDomainCallbacksImplementation(ExecutionDomain executionDomain, ExecutionEnvironmentImplementation executionEnvironment);
    public sealed virtual Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, string defaultAssemblyName);
    public sealed virtual bool IsReflectionBlocked(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetNamedTypeForHandle(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    public sealed virtual Type GetArrayTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetMdArrayTypeForHandle(RuntimeTypeHandle typeHandle, int rank);
    public sealed virtual Type GetPointerTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetByRefTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Type GetConstructedGenericTypeForHandle(RuntimeTypeHandle typeHandle);
    public sealed virtual Exception CreateMissingMetadataException(Type pertainant);
    public sealed virtual string GetBetterDiagnosticInfoIfAvailable(RuntimeTypeHandle runtimeTypeHandle);
    public sealed virtual MethodBase GetMethodBaseFromStartAddressIfAvailable(IntPtr methodStartAddress);
    public sealed virtual IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle runtimeTypeHandle);
    public sealed virtual int ValueTypeGetHashCodeUsingReflection(object valueType);
    public sealed virtual bool ValueTypeEqualsUsingReflection(object left, object right);
    public sealed virtual bool TryGetDefaultParameterValue(object defaultParametersContext, RuntimeTypeHandle thType, int argIndex, Object& defaultValue);
    public sealed virtual RuntimeTypeHandle GetTypeHandleIfAvailable(Type type);
    public sealed virtual bool SupportsReflection(Type type);
    public sealed virtual MethodInfo GetDelegateMethod(Delegate del);
    public sealed virtual Exception GetExceptionForHR(int hr);
}
[ExtensionAttribute]
internal static class Internal.Reflection.Execution.RuntimeHandlesExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle rtth);
}
internal class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string p0);
}
[__BlockReflectionAttribute]
public static class Internal.Reflection.Extensions.NonPortable.DelegateMethodInfoRetriever : object {
    public static MethodInfo GetDelegateMethodInfo(Delegate del);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
internal enum Internal.Runtime.ReflectionMapBlob : Enum {
    public int value__;
    public static ReflectionMapBlob TypeMap;
    public static ReflectionMapBlob ArrayMap;
    public static ReflectionMapBlob GenericInstanceMap;
    public static ReflectionMapBlob GenericParameterMap;
    public static ReflectionMapBlob BlockReflectionTypeMap;
    public static ReflectionMapBlob InvokeMap;
    public static ReflectionMapBlob VirtualInvokeMap;
    public static ReflectionMapBlob CommonFixupsTable;
    public static ReflectionMapBlob FieldAccessMap;
    public static ReflectionMapBlob CCtorContextMap;
    public static ReflectionMapBlob DiagGenericInstanceMap;
    public static ReflectionMapBlob DiagGenericParameterMap;
    public static ReflectionMapBlob EmbeddedMetadata;
    public static ReflectionMapBlob DefaultConstructorMap;
    public static ReflectionMapBlob UnboxingAndInstantiatingStubMap;
    public static ReflectionMapBlob StructMarshallingStubMap;
    public static ReflectionMapBlob DelegateMarshallingStubMap;
    public static ReflectionMapBlob GenericVirtualMethodTable;
    public static ReflectionMapBlob InterfaceGenericVirtualMethodTable;
    public static ReflectionMapBlob TypeTemplateMap;
    public static ReflectionMapBlob GenericMethodsTemplateMap;
    public static ReflectionMapBlob DynamicInvokeTemplateData;
    public static ReflectionMapBlob BlobIdResourceIndex;
    public static ReflectionMapBlob BlobIdResourceData;
    public static ReflectionMapBlob BlobIdStackTraceEmbeddedMetadata;
    public static ReflectionMapBlob BlobIdStackTraceMethodRvaToTokenMapping;
    public static ReflectionMapBlob NativeLayoutInfo;
    public static ReflectionMapBlob NativeReferences;
    public static ReflectionMapBlob GenericsHashtable;
    public static ReflectionMapBlob NativeStatics;
    public static ReflectionMapBlob StaticsInfoHashtable;
    public static ReflectionMapBlob GenericMethodsHashtable;
    public static ReflectionMapBlob ExactMethodInstantiationsHashtable;
}
internal static class System.Collections.Generic.Empty`1 : object {
    private static IEnumerable`1<T> _enumerable;
    public static IEnumerable`1<T> Enumerable { get; }
    private static Empty`1();
    public static IEnumerable`1<T> get_Enumerable();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    private void EnsureCapacity(int min);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int index);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public T[] ToArray();
}
internal class System.Collections.Generic.LowLevelListWithIList`1 : LowLevelList`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public LowLevelListWithIList`1(int capacity);
    public LowLevelListWithIList`1(IEnumerable`1<T> collection);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Collections.HashHelpers : object {
    public static int HashCollisionThreshold;
    private static int HashPrime;
    public static Int32[] primes;
    public static int MaxPrimeArrayLength;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int GetMinPrime();
    public static int ExpandPrime(int oldSize);
}
internal static class System.CommonRuntimeTypes : object {
    private static Type s_object;
    private static Type s_valuetype;
    private static Type s_type;
    private static Type s_attribute;
    private static Type s_string;
    private static Type s_array;
    private static Type s_enum;
    private static Type s_boolean;
    private static Type s_char;
    private static Type s_byte;
    private static Type s_sByte;
    private static Type s_uInt16;
    private static Type s_int16;
    private static Type s_uInt32;
    private static Type s_int32;
    private static Type s_uInt64;
    private static Type s_int64;
    private static Type s_uIntPtr;
    private static Type s_intPtr;
    private static Type s_single;
    private static Type s_double;
    private static Type s_decimal;
    private static Type s_datetime;
    private static Type s_nullable;
    private static Type s_void;
    private static Type s_multicastDelegate;
    internal static Type Object { get; }
    internal static Type ValueType { get; }
    internal static Type Type { get; }
    internal static Type Attribute { get; }
    internal static Type String { get; }
    internal static Type Array { get; }
    internal static Type Enum { get; }
    internal static Type Boolean { get; }
    internal static Type Char { get; }
    internal static Type Byte { get; }
    internal static Type SByte { get; }
    internal static Type UInt16 { get; }
    internal static Type Int16 { get; }
    internal static Type UInt32 { get; }
    internal static Type Int32 { get; }
    internal static Type UInt64 { get; }
    internal static Type Int64 { get; }
    internal static Type UIntPtr { get; }
    internal static Type IntPtr { get; }
    internal static Type Single { get; }
    internal static Type Double { get; }
    internal static Type Decimal { get; }
    internal static Type DateTime { get; }
    internal static Type Nullable { get; }
    internal static Type Void { get; }
    internal static Type MulticastDelegate { get; }
    private static CommonRuntimeTypes();
    internal static Type get_Object();
    internal static Type get_ValueType();
    internal static Type get_Type();
    internal static Type get_Attribute();
    internal static Type get_String();
    internal static Type get_Array();
    internal static Type get_Enum();
    internal static Type get_Boolean();
    internal static Type get_Char();
    internal static Type get_Byte();
    internal static Type get_SByte();
    internal static Type get_UInt16();
    internal static Type get_Int16();
    internal static Type get_UInt32();
    internal static Type get_Int32();
    internal static Type get_UInt64();
    internal static Type get_Int64();
    internal static Type get_UIntPtr();
    internal static Type get_IntPtr();
    internal static Type get_Single();
    internal static Type get_Double();
    internal static Type get_Decimal();
    internal static Type get_DateTime();
    internal static Type get_Nullable();
    internal static Type get_Void();
    internal static Type get_MulticastDelegate();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
internal class System.Reflection.MissingRuntimeArtifactException : MemberAccessException {
    public MissingRuntimeArtifactException(string message);
}
internal class System.Runtime.CompilerServices.__BlockReflectionActivateAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionInvokeAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Reflection_InsufficientMetadata_NoHelpAvailable { get; }
    internal static string Reflection_InsufficientMetadata_EdbNeeded { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string MissingMember { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static string RFLCT_Targ_StatFldReqTarg { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MultiDim_Of_This_Rank_Not_Supported { get; }
    internal static string Object_NotInvokable { get; }
    internal static string MakeGenericMethod_NoMetadata { get; }
    internal static string PlatformNotSupported_CannotInvokeDelegateCtor { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_NeverValidGenericArgument { get; }
    internal static string Argument_ConstraintFailed { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string DelegateGetMethodInfo_NoDynamic { get; }
    internal static string DelegateGetMethodInfo_NoDynamic_WithDisplayString { get; }
    internal static string DelegateGetMethodInfo_NoInstantiation { get; }
    internal static string DelegateGetMethodInfo_ObjectArrayDelegate { get; }
    internal static Type ResourceType { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Reflection_InsufficientMetadata_NoHelpAvailable();
    internal static string get_Reflection_InsufficientMetadata_EdbNeeded();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_EmptyArray();
    internal static string get_MissingMember();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_InvalidOperation_NoValue();
    internal static string get_RFLCT_Targ_StatFldReqTarg();
    internal static string get_MissingConstructor_Name();
    internal static string get_MultiDim_Of_This_Rank_Not_Supported();
    internal static string get_Object_NotInvokable();
    internal static string get_MakeGenericMethod_NoMetadata();
    internal static string get_PlatformNotSupported_CannotInvokeDelegateCtor();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_NeverValidGenericArgument();
    internal static string get_Argument_ConstraintFailed();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Acc_ReadOnly();
    internal static string get_DelegateGetMethodInfo_NoDynamic();
    internal static string get_DelegateGetMethodInfo_NoDynamic_WithDisplayString();
    internal static string get_DelegateGetMethodInfo_NoInstantiation();
    internal static string get_DelegateGetMethodInfo_ObjectArrayDelegate();
    internal static Type get_ResourceType();
}
