internal static class FxResources.System.Private.Reflection.Core.SR : object {
}
[ExtensionAttribute]
internal static class Internal.LowLevelLinq.LowLevelEnumerable : object {
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values, Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(IEnumerable`1<T> values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(T[] values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Where>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Where(IEnumerable`1<T> source, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static T[] ToArray(IEnumerable`1<T> values);
}
[__BlockReflectionAttribute]
public class Internal.Reflection.Core.Execution.ExecutionDomain : object {
    [CompilerGeneratedAttribute]
private ExecutionEnvironment <ExecutionEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionDomainSetup <ReflectionDomainSetup>k__BackingField;
    private static Type[] s_primitiveTypes;
    internal ExecutionEnvironment ExecutionEnvironment { get; }
    internal ReflectionDomainSetup ReflectionDomainSetup { get; }
    internal IEnumerable`1<Type> PrimitiveTypes { get; }
    internal ExecutionDomain(ReflectionDomainSetup executionDomainSetup, ExecutionEnvironment executionEnvironment);
    private static ExecutionDomain();
    public Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, IList`1<string> defaultAssemblyNames);
    private static CoreAssemblyResolver CreateCoreAssemblyResolver(Func`2<AssemblyName, Assembly> assemblyResolver);
    private static CoreTypeResolver CreateCoreTypeResolver(Func`4<Assembly, string, bool, Type> typeResolver, IList`1<string> defaultAssemblyNames, bool throwOnError, bool ignoreCase);
    public MethodBase GetMethod(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles);
    public Type GetNamedTypeForHandle(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    public Type GetArrayTypeForHandle(RuntimeTypeHandle typeHandle);
    public Type GetMdArrayTypeForHandle(RuntimeTypeHandle typeHandle, int rank);
    public Type GetPointerTypeForHandle(RuntimeTypeHandle typeHandle);
    public Type GetByRefTypeForHandle(RuntimeTypeHandle typeHandle);
    public Type GetConstructedGenericTypeForHandle(RuntimeTypeHandle typeHandle);
    public Exception CreateMissingMetadataException(Type pertainant);
    public Exception CreateMissingMetadataException(TypeInfo pertainant);
    public Exception CreateMissingMetadataException(TypeInfo pertainant, string nestedTypeName);
    public Exception CreateNonInvokabilityException(MemberInfo pertainant);
    public Exception CreateMissingArrayTypeException(Type elementType, bool isMultiDim, int rank);
    public Exception CreateMissingConstructedGenericTypeException(Type genericTypeDefinition, Type[] genericTypeArguments);
    public RuntimeTypeHandle GetTypeHandleIfAvailable(Type type);
    public bool SupportsReflection(Type type);
    [CompilerGeneratedAttribute]
internal ExecutionEnvironment get_ExecutionEnvironment();
    [CompilerGeneratedAttribute]
internal ReflectionDomainSetup get_ReflectionDomainSetup();
    internal IEnumerable`1<Type> get_PrimitiveTypes();
}
[__BlockReflectionAttribute]
public abstract class Internal.Reflection.Core.Execution.ExecutionEnvironment : object {
    public RuntimeTypeHandle ProjectionTypeForArrays { get; }
    public abstract virtual object NewObject(RuntimeTypeHandle typeHandle);
    public abstract virtual Array NewArray(RuntimeTypeHandle typeHandleForArrayType, int count);
    public abstract virtual Array NewMultiDimArray(RuntimeTypeHandle typeHandleForArrayType, Int32[] lengths, Int32[] lowerBounds);
    public abstract virtual RuntimeTypeHandle get_ProjectionTypeForArrays();
    public abstract virtual bool IsAssignableFrom(RuntimeTypeHandle dstType, RuntimeTypeHandle srcType);
    public abstract virtual bool TryGetBaseType(RuntimeTypeHandle typeHandle, RuntimeTypeHandle& baseTypeHandle);
    public abstract virtual IEnumerable`1<RuntimeTypeHandle> TryGetImplementedInterfaces(RuntimeTypeHandle typeHandle);
    public abstract virtual bool IsReflectionBlocked(RuntimeTypeHandle typeHandle);
    public abstract virtual string GetLastResortString(RuntimeTypeHandle typeHandle);
    public abstract virtual bool TryGetMetadataForNamedType(RuntimeTypeHandle runtimeTypeHandle, QTypeDefinition& qTypeDefinition);
    public abstract virtual bool TryGetNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public abstract virtual bool TryGetTypeReferenceForNamedType(RuntimeTypeHandle runtimeTypeHandle, MetadataReader& metadataReader, TypeReferenceHandle& typeRefHandle);
    public abstract virtual bool TryGetNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle);
    public abstract virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& arrayTypeHandle);
    public abstract virtual bool TryGetArrayTypeElementType(RuntimeTypeHandle arrayTypeHandle, RuntimeTypeHandle& elementTypeHandle);
    public abstract virtual bool TryGetMultiDimArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public abstract virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public abstract virtual bool TryGetPointerTypeTargetType(RuntimeTypeHandle pointerTypeHandle, RuntimeTypeHandle& targetTypeHandle);
    public abstract virtual bool TryGetByRefTypeForTargetType(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public abstract virtual bool TryGetByRefTypeTargetType(RuntimeTypeHandle byRefTypeHandle, RuntimeTypeHandle& targetTypeHandle);
    public abstract virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public abstract virtual MethodInvoker TryGetMethodInvoker(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles);
    public abstract virtual FieldAccessor TryGetFieldAccessor(MetadataReader reader, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle fieldTypeHandle, FieldHandle fieldHandle);
    public abstract virtual bool TryGetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public abstract virtual bool TryGetMethodFromHandleAndType(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle, QMethodDefinition& methodHandle, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    public abstract virtual bool TryGetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, FieldHandle& fieldHandle);
    public abstract virtual bool TryGetFieldFromHandleAndType(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle declaringTypeHandle, FieldHandle& fieldHandle);
    public abstract virtual ManifestResourceInfo GetManifestResourceInfo(Assembly assembly, string resourceName);
    public abstract virtual String[] GetManifestResourceNames(Assembly assembly);
    public abstract virtual Stream GetManifestResourceStream(Assembly assembly, string name);
    public abstract virtual bool IsCOMObject(Type type);
    public abstract virtual FieldAccessor CreateLiteralFieldAccessor(object value, RuntimeTypeHandle fieldTypeHandle);
    internal MethodInvoker GetMethodInvoker(RuntimeTypeInfo declaringType, QMethodDefinition methodHandle, RuntimeTypeInfo[] genericMethodTypeArguments, MemberInfo exceptionPertainant);
}
[__BlockReflectionAttribute]
public abstract class Internal.Reflection.Core.Execution.FieldAccessor : object {
    public int Offset { get; }
    public abstract virtual object GetField(object obj);
    public abstract virtual object GetFieldDirect(TypedReference typedReference);
    public abstract virtual void SetField(object obj, object value, BinderBundle binderBundle);
    public abstract virtual void SetFieldDirect(TypedReference typedReference, object value);
    public abstract virtual int get_Offset();
}
[__BlockReflectionAttribute]
public abstract class Internal.Reflection.Core.Execution.MethodInvoker : object {
    public IntPtr LdFtnResult { get; }
    [DebuggerGuidedStepThroughAttribute]
public object Invoke(object thisObject, Object[] arguments, Binder binder, BindingFlags invokeAttr, CultureInfo cultureInfo);
    protected abstract virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public abstract virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    public abstract virtual IntPtr get_LdFtnResult();
    protected static void ValidateThis(object thisObject, RuntimeTypeHandle declaringTypeHandle);
}
[__BlockReflectionAttribute]
public static class Internal.Reflection.Core.Execution.ReflectionCoreExecution : object {
    private static ExecutionDomain modreq(System.Runtime.CompilerServices.IsVolatile) s_executionDomain;
    public static ExecutionDomain ExecutionDomain { get; }
    internal static ExecutionEnvironment ExecutionEnvironment { get; }
    public static void InitializeExecutionDomain(ReflectionDomainSetup executionDomainSetup, ExecutionEnvironment executionEnvironment);
    public static ExecutionDomain get_ExecutionDomain();
    internal static ExecutionEnvironment get_ExecutionEnvironment();
}
[__BlockReflectionAttribute]
public abstract class Internal.Reflection.Core.ReflectionDomainSetup : object {
    public AssemblyBinder AssemblyBinder { get; }
    public abstract virtual AssemblyBinder get_AssemblyBinder();
    public abstract virtual Exception CreateMissingMetadataException(TypeInfo pertainant);
    public abstract virtual Exception CreateMissingMetadataException(Type pertainant);
    public abstract virtual Exception CreateMissingMetadataException(TypeInfo pertainant, string nestedTypeName);
    public abstract virtual Exception CreateNonInvokabilityException(MemberInfo pertainant);
    public abstract virtual Exception CreateMissingArrayTypeException(Type elementType, bool isMultiDim, int rank);
    public abstract virtual Exception CreateMissingConstructedGenericTypeException(Type genericTypeDefinition, Type[] genericTypeArguments);
}
internal class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string p0);
}
internal interface Internal.Reflection.Tracing.ITraceableTypeMember {
    public string MemberName { get; }
    public Type ContainingType { get; }
    public abstract virtual string get_MemberName();
    public abstract virtual Type get_ContainingType();
}
[ExtensionAttribute]
[DeveloperExperienceModeOnlyAttribute]
[__BlockReflectionAttribute]
public static class Internal.Reflection.Tracing.ReflectionTrace : object {
    public static bool Enabled { get; }
    public static bool get_Enabled();
    [ExtensionAttribute]
public static string GetTraceString(TypeInfo typeInfo);
    public static void Type_MakeGenericType(Type type, Type[] typeArguments);
    public static void Type_MakeArrayType(Type type);
    public static void Type_FullName(Type type);
    public static void Type_Namespace(Type type);
    public static void Type_AssemblyQualifiedName(Type type);
    public static void Type_Name(Type type);
    public static void TypeInfo_CustomAttributes(TypeInfo typeInfo);
    public static void TypeInfo_Name(TypeInfo typeInfo);
    public static void TypeInfo_BaseType(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredConstructors(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredEvents(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredFields(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredMembers(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredMethods(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredNestedTypes(TypeInfo typeInfo);
    public static void TypeInfo_DeclaredProperties(TypeInfo typeInfo);
    public static void TypeInfo_DeclaringMethod(TypeInfo typeInfo);
    public static void TypeInfo_FullName(TypeInfo typeInfo);
    public static void TypeInfo_AssemblyQualifiedName(TypeInfo typeInfo);
    public static void TypeInfo_Namespace(TypeInfo typeInfo);
    public static void TypeInfo_GetDeclaredEvent(TypeInfo typeInfo, string eventName);
    public static void TypeInfo_GetDeclaredField(TypeInfo typeInfo, string fieldName);
    public static void TypeInfo_GetDeclaredMethod(TypeInfo typeInfo, string methodName);
    public static void TypeInfo_GetDeclaredProperty(TypeInfo typeInfo, string propertyName);
    public static void TypeInfo_MakeArrayType(TypeInfo typeInfo);
    public static void TypeInfo_MakeArrayType(TypeInfo typeInfo, int rank);
    public static void TypeInfo_MakeByRefType(TypeInfo typeInfo);
    public static void TypeInfo_MakeGenericType(TypeInfo typeInfo, Type[] typeArguments);
    public static void TypeInfo_MakePointerType(TypeInfo typeInfo);
    public static void Assembly_DefinedTypes(Assembly assembly);
    public static void Assembly_GetType(Assembly assembly, string typeName);
    public static void Assembly_CustomAttributes(Assembly assembly);
    public static void Assembly_FullName(Assembly assembly);
    public static void Assembly_GetName(Assembly assembly);
    public static void CustomAttributeData_ConstructorArguments(CustomAttributeData customAttributeData);
    public static void CustomAttributeData_NamedArguments(CustomAttributeData customAttributeData);
    public static void EventInfo_AddMethod(EventInfo eventInfo);
    public static void EventInfo_RaiseMethod(EventInfo eventInfo);
    public static void EventInfo_RemoveMethod(EventInfo eventInfo);
    public static void EventInfo_CustomAttributes(EventInfo eventInfo);
    public static void EventInfo_Name(EventInfo eventInfo);
    public static void EventInfo_DeclaringType(EventInfo eventInfo);
    public static void FieldInfo_SetValue(FieldInfo fieldInfo, object obj, object value);
    public static void FieldInfo_GetValue(FieldInfo fieldInfo, object obj);
    public static void FieldInfo_CustomAttributes(FieldInfo fieldInfo);
    public static void FieldInfo_Name(FieldInfo fieldInfo);
    public static void FieldInfo_DeclaringType(FieldInfo fieldInfo);
    public static void MethodBase_CustomAttributes(MethodBase methodBase);
    public static void MethodBase_Name(MethodBase methodBase);
    public static void MethodBase_DeclaringType(MethodBase methodBase);
    public static void MethodBase_GetParameters(MethodBase methodBase);
    public static void ConstructorInfo_Invoke(ConstructorInfo constructor, Object[] parameters);
    public static void MethodBase_Invoke(MethodBase methodBase, object obj, Object[] parameters);
    public static void MethodInfo_ReturnParameter(MethodInfo methodInfo);
    public static void MethodInfo_ReturnType(MethodInfo methodInfo);
    public static void MethodInfo_MakeGenericMethod(MethodInfo methodInfo, Type[] typeArguments);
    public static void MethodInfo_CreateDelegate(MethodInfo methodInfo, Type delegateType);
    public static void MethodInfo_CreateDelegate(MethodInfo methodInfo, Type delegateType, object target);
    public static void PropertyInfo_GetValue(PropertyInfo propertyInfo, object obj, Object[] index);
    public static void PropertyInfo_SetValue(PropertyInfo propertyInfo, object obj, object value, Object[] index);
    public static void PropertyInfo_GetMethod(PropertyInfo propertyInfo);
    public static void PropertyInfo_SetMethod(PropertyInfo propertyInfo);
    public static void PropertyInfo_GetConstantValue(PropertyInfo propertyInfo);
    public static void PropertyInfo_PropertyType(PropertyInfo propertyInfo);
    public static void PropertyInfo_CustomAttributes(PropertyInfo propertyInfo);
    public static void PropertyInfo_Name(PropertyInfo propertyInfo);
    public static void PropertyInfo_DeclaringType(PropertyInfo propertyInfo);
    [ExtensionAttribute]
private static string NameString(Type type);
    [ExtensionAttribute]
private static string NameString(Assembly assembly);
    [ExtensionAttribute]
private static string AttributeTypeNameString(CustomAttributeData customAttributeData);
    [ExtensionAttribute]
private static string DeclaringTypeNameString(MemberInfo memberInfo);
    [ExtensionAttribute]
private static string NameString(MemberInfo memberInfo);
    [ExtensionAttribute]
private static string GenericTypeArgumentStrings(Type[] typeArguments);
    [ExtensionAttribute]
private static string NonQualifiedTypeName(Type type);
    [ExtensionAttribute]
private static string AssemblyQualifiedTypeName(Type type);
    [ExtensionAttribute]
private static string ContainingAssemblyName(Type type);
}
internal static class System.ActivatorImplementation : object {
    [DebuggerGuidedStepThroughAttribute]
public static object CreateInstance(Type type, bool nonPublic);
    [DebuggerGuidedStepThroughAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    private static void CreateInstanceCheckType(Type type);
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifier`2 : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private Lock _lock;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifierW`2 : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private Lock _lock;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifierWKeyed`2 : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private Lock _lock;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal interface System.Collections.Concurrent.IKeyedItem`1 {
    public K Key { get; }
    public abstract virtual void PrepareKey();
    public abstract virtual K get_Key();
}
internal static class System.Collections.Generic.Empty`1 : object {
    private static IEnumerable`1<T> _enumerable;
    public static IEnumerable`1<T> Enumerable { get; }
    private static Empty`1();
    public static IEnumerable`1<T> get_Enumerable();
}
[ExtensionAttribute]
internal static class System.Collections.Generic.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("System.Collections.Generic.EnumerableExtensions/<AsNothingButIEnumerable>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AsNothingButIEnumerable(IEnumerable`1<T> en);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    private void EnsureCapacity(int min);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int index);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public T[] ToArray();
}
internal class System.Collections.Generic.LowLevelListWithIList`1 : LowLevelList`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public LowLevelListWithIList`1(int capacity);
    public LowLevelListWithIList`1(IEnumerable`1<T> collection);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Collections.HashHelpers : object {
    public static int HashCollisionThreshold;
    private static int HashPrime;
    public static Int32[] primes;
    public static int MaxPrimeArrayLength;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int GetMinPrime();
    public static int ExpandPrime(int oldSize);
}
internal static class System.CommonRuntimeTypes : object {
    private static Type s_object;
    private static Type s_valuetype;
    private static Type s_type;
    private static Type s_attribute;
    private static Type s_string;
    private static Type s_array;
    private static Type s_enum;
    private static Type s_boolean;
    private static Type s_char;
    private static Type s_byte;
    private static Type s_sByte;
    private static Type s_uInt16;
    private static Type s_int16;
    private static Type s_uInt32;
    private static Type s_int32;
    private static Type s_uInt64;
    private static Type s_int64;
    private static Type s_uIntPtr;
    private static Type s_intPtr;
    private static Type s_single;
    private static Type s_double;
    private static Type s_decimal;
    private static Type s_datetime;
    private static Type s_nullable;
    private static Type s_void;
    private static Type s_multicastDelegate;
    internal static Type Object { get; }
    internal static Type ValueType { get; }
    internal static Type Type { get; }
    internal static Type Attribute { get; }
    internal static Type String { get; }
    internal static Type Array { get; }
    internal static Type Enum { get; }
    internal static Type Boolean { get; }
    internal static Type Char { get; }
    internal static Type Byte { get; }
    internal static Type SByte { get; }
    internal static Type UInt16 { get; }
    internal static Type Int16 { get; }
    internal static Type UInt32 { get; }
    internal static Type Int32 { get; }
    internal static Type UInt64 { get; }
    internal static Type Int64 { get; }
    internal static Type UIntPtr { get; }
    internal static Type IntPtr { get; }
    internal static Type Single { get; }
    internal static Type Double { get; }
    internal static Type Decimal { get; }
    internal static Type DateTime { get; }
    internal static Type Nullable { get; }
    internal static Type Void { get; }
    internal static Type MulticastDelegate { get; }
    private static CommonRuntimeTypes();
    internal static Type get_Object();
    internal static Type get_ValueType();
    internal static Type get_Type();
    internal static Type get_Attribute();
    internal static Type get_String();
    internal static Type get_Array();
    internal static Type get_Enum();
    internal static Type get_Boolean();
    internal static Type get_Char();
    internal static Type get_Byte();
    internal static Type get_SByte();
    internal static Type get_UInt16();
    internal static Type get_Int16();
    internal static Type get_UInt32();
    internal static Type get_Int32();
    internal static Type get_UInt64();
    internal static Type get_Int64();
    internal static Type get_UIntPtr();
    internal static Type get_IntPtr();
    internal static Type get_Single();
    internal static Type get_Double();
    internal static Type get_Decimal();
    internal static Type get_DateTime();
    internal static Type get_Nullable();
    internal static Type get_Void();
    internal static Type get_MulticastDelegate();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
internal enum System.Reflection.Metadata.Ecma335.CorElementType : Enum {
    public byte value__;
    public static CorElementType Invalid;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VAR;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_GENERICINST;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
    public static CorElementType ELEMENT_TYPE_MVAR;
    public static CorElementType ELEMENT_TYPE_CMOD_REQD;
    public static CorElementType ELEMENT_TYPE_CMOD_OPT;
    public static CorElementType ELEMENT_TYPE_HANDLE;
    public static CorElementType ELEMENT_TYPE_SENTINEL;
    public static CorElementType ELEMENT_TYPE_PINNED;
}
internal class System.Reflection.Runtime.Assemblies.EcmaFormat.EcmaFormatRuntimeAssembly : RuntimeAssembly {
    [CompilerGeneratedAttribute]
private AssemblyDefinition <AssemblyDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReader <MetadataReader>k__BackingField;
    private LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCaseInsensitiveTypeDictionary;
    private static Dispenser`2<EcmaRuntimeAssemblyKey, RuntimeAssembly> s_EcmaAssemblyDispenser;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    protected IEnumerable`1<TypeForwardInfo> TypeForwardInfos { get; }
    public string ImageRuntimeVersion { get; }
    public Module ManifestModule { get; }
    internal RuntimeAssemblyName RuntimeAssemblyName { get; }
    public MethodInfo EntryPoint { get; }
    internal AssemblyDefinition AssemblyDefinition { get; }
    internal MetadataReader MetadataReader { get; }
    internal PEReader PEReader { get; }
    private LowLevelDictionary`2<string, Handle> CaseInsensitiveTypeDictionary { get; }
    private EcmaFormatRuntimeAssembly(MetadataReader reader);
    private static EcmaFormatRuntimeAssembly();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.EcmaFormat.EcmaFormatRuntimeAssembly/<get_CustomAttributes>d__2")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.EcmaFormat.EcmaFormatRuntimeAssembly/<get_DefinedTypes>d__4")]
public sealed virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public sealed virtual IEnumerable`1<Type> get_ExportedTypes();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.EcmaFormat.EcmaFormatRuntimeAssembly/<get_TypeForwardInfos>d__8")]
protected sealed virtual IEnumerable`1<TypeForwardInfo> get_TypeForwardInfos();
    private InternalManifestResourceInfo GetInternalManifestResourceInfo(string resourceName);
    public sealed virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public sealed virtual String[] GetManifestResourceNames();
    public sealed virtual Stream GetManifestResourceStream(string name);
    public sealed virtual string get_ImageRuntimeVersion();
    public sealed virtual Module get_ManifestModule();
    internal sealed virtual RuntimeAssemblyName get_RuntimeAssemblyName();
    public sealed virtual bool Equals(object obj);
    public bool Equals(EcmaFormatRuntimeAssembly other);
    public sealed virtual int GetHashCode();
    public sealed virtual MethodInfo get_EntryPoint();
    [CompilerGeneratedAttribute]
internal AssemblyDefinition get_AssemblyDefinition();
    [CompilerGeneratedAttribute]
internal MetadataReader get_MetadataReader();
    internal PEReader get_PEReader();
    internal sealed virtual void RunModuleConstructor();
    internal sealed virtual RuntimeTypeInfo GetTypeCoreCaseInsensitive(string fullName);
    private LowLevelDictionary`2<string, Handle> get_CaseInsensitiveTypeDictionary();
    private LowLevelDictionary`2<string, Handle> CreateCaseInsensitiveTypeDictionary();
    internal sealed virtual RuntimeTypeInfo UncachedGetTypeCoreCaseSensitive(string fullName);
    internal static RuntimeAssembly GetRuntimeAssembly(MetadataReader ecmaMetadataReader);
}
internal class System.Reflection.Runtime.Assemblies.NativeFormat.NativeFormatRuntimeAssembly : RuntimeAssembly {
    [CompilerGeneratedAttribute]
private QScopeDefinition <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<QScopeDefinition> <OverflowScopes>k__BackingField;
    private static Dispenser`2<RuntimeAssemblyKey, RuntimeAssembly> s_scopeToAssemblyDispenser;
    private LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCaseInsensitiveTypeDictionary;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public MethodInfo EntryPoint { get; }
    protected IEnumerable`1<TypeForwardInfo> TypeForwardInfos { get; }
    public string ImageRuntimeVersion { get; }
    public Module ManifestModule { get; }
    internal RuntimeAssemblyName RuntimeAssemblyName { get; }
    internal QScopeDefinition Scope { get; }
    internal IEnumerable`1<QScopeDefinition> OverflowScopes { get; }
    internal IEnumerable`1<QScopeDefinition> AllScopes { get; }
    private LowLevelDictionary`2<string, QHandle> CaseInsensitiveTypeDictionary { get; }
    private NativeFormatRuntimeAssembly(MetadataReader reader, ScopeDefinitionHandle scope, IEnumerable`1<QScopeDefinition> overflowScopes);
    private static NativeFormatRuntimeAssembly();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.NativeFormat.NativeFormatRuntimeAssembly/<get_CustomAttributes>d__2")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.NativeFormat.NativeFormatRuntimeAssembly/<get_DefinedTypes>d__4")]
public sealed virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.NativeFormat.NativeFormatRuntimeAssembly/<get_ExportedTypes>d__6")]
public sealed virtual IEnumerable`1<Type> get_ExportedTypes();
    public sealed virtual MethodInfo get_EntryPoint();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.NativeFormat.NativeFormatRuntimeAssembly/<get_TypeForwardInfos>d__10")]
protected sealed virtual IEnumerable`1<TypeForwardInfo> get_TypeForwardInfos();
    public sealed virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public sealed virtual String[] GetManifestResourceNames();
    public sealed virtual Stream GetManifestResourceStream(string name);
    public sealed virtual string get_ImageRuntimeVersion();
    public sealed virtual Module get_ManifestModule();
    internal sealed virtual RuntimeAssemblyName get_RuntimeAssemblyName();
    public sealed virtual bool Equals(object obj);
    public bool Equals(NativeFormatRuntimeAssembly other);
    public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal QScopeDefinition get_Scope();
    [CompilerGeneratedAttribute]
internal IEnumerable`1<QScopeDefinition> get_OverflowScopes();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.NativeFormat.NativeFormatRuntimeAssembly/<get_AllScopes>d__30")]
internal IEnumerable`1<QScopeDefinition> get_AllScopes();
    internal sealed virtual void RunModuleConstructor();
    internal sealed virtual RuntimeTypeInfo UncachedGetTypeCoreCaseSensitive(string fullName);
    private bool TryResolveNamespaceDefinitionCaseSensitive(MetadataReader reader, String[] namespaceParts, ScopeDefinitionHandle scopeDefinitionHandle, NamespaceDefinition& namespaceDefinition);
    internal static RuntimeAssembly GetRuntimeAssembly(MetadataReader reader, ScopeDefinitionHandle scope, IEnumerable`1<QScopeDefinition> overflowScopes);
    internal sealed virtual RuntimeTypeInfo GetTypeCoreCaseInsensitive(string fullName);
    private LowLevelDictionary`2<string, QHandle> get_CaseInsensitiveTypeDictionary();
    private LowLevelDictionary`2<string, QHandle> CreateCaseInsensitiveTypeDictionary();
}
internal abstract class System.Reflection.Runtime.Assemblies.RuntimeAssembly : Assembly {
    [CompilerGeneratedAttribute]
private ModuleResolveEventHandler ModuleResolve;
    private CaseSensitiveTypeCache modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCaseSensitiveTypeTable;
    private static Dispenser`2<RuntimeAssemblyName, object> s_assemblyRefNameToAssemblyDispenser;
    public string FullName { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool ReflectionOnly { get; }
    internal RuntimeAssemblyName RuntimeAssemblyName { get; }
    protected IEnumerable`1<TypeForwardInfo> TypeForwardInfos { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public MethodInfo EntryPoint { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public string ImageRuntimeVersion { get; }
    private CaseSensitiveTypeCache CaseSensitiveTypeTable { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    public string Location { get; }
    public string CodeBase { get; }
    private static RuntimeAssembly();
    public sealed virtual bool Equals(RuntimeAssembly other);
    public sealed virtual string get_FullName();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual Module get_ManifestModule();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.Assemblies.RuntimeAssembly/<get_Modules>d__7")]
public sealed virtual IEnumerable`1<Module> get_Modules();
    public sealed virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public sealed virtual bool get_ReflectionOnly();
    internal abstract virtual RuntimeAssemblyName get_RuntimeAssemblyName();
    public sealed virtual AssemblyName GetName();
    public sealed virtual Type[] GetForwardedTypes();
    protected abstract virtual IEnumerable`1<TypeForwardInfo> get_TypeForwardInfos();
    private static void AddPublicNestedTypes(Type type, List`1<Type> types);
    internal RuntimeTypeInfo GetTypeCore(string fullName, bool ignoreCase);
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public abstract virtual MethodInfo get_EntryPoint();
    public abstract virtual IEnumerable`1<Type> get_ExportedTypes();
    public abstract virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public abstract virtual String[] GetManifestResourceNames();
    public abstract virtual Stream GetManifestResourceStream(string name);
    public abstract virtual string get_ImageRuntimeVersion();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    internal abstract virtual void RunModuleConstructor();
    internal abstract virtual RuntimeTypeInfo UncachedGetTypeCoreCaseSensitive(string fullName);
    internal abstract virtual RuntimeTypeInfo GetTypeCoreCaseInsensitive(string fullName);
    internal RuntimeTypeInfo GetTypeCoreCaseSensitive(string fullName);
    private CaseSensitiveTypeCache get_CaseSensitiveTypeTable();
    public sealed virtual bool get_GlobalAssemblyCache();
    public sealed virtual long get_HostContext();
    public sealed virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public sealed virtual FileStream GetFile(string name);
    public sealed virtual FileStream[] GetFiles(bool getResourceModules);
    public sealed virtual SecurityRuleSet get_SecurityRuleSet();
    internal static Assembly[] GetLoadedAssemblies();
    internal static RuntimeAssembly GetRuntimeAssembly(RuntimeAssemblyName assemblyRefName);
    internal static RuntimeAssembly GetRuntimeAssemblyFromByteArray(Byte[] rawAssembly, Byte[] pdbSymbolStore);
    internal static RuntimeAssembly GetRuntimeAssemblyIfExists(RuntimeAssemblyName assemblyRefName);
    internal static Exception TryGetRuntimeAssembly(RuntimeAssemblyName assemblyRefName, RuntimeAssembly& result);
    private static RuntimeAssembly GetRuntimeAssembly(AssemblyBindResult bindResult);
    private static void GetNativeFormatRuntimeAssembly(AssemblyBindResult bindResult, RuntimeAssembly& runtimeAssembly);
    private static void GetEcmaRuntimeAssembly(AssemblyBindResult bindResult, RuntimeAssembly& runtimeAssembly);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual Type[] GetExportedTypes();
    public sealed virtual Module[] GetLoadedModules(bool getResourceModules);
    public sealed virtual Module[] GetModules(bool getResourceModules);
    public sealed virtual Type[] GetTypes();
    public sealed virtual AssemblyName GetName(bool copiedName);
    public sealed virtual Stream GetManifestResourceStream(Type type, string name);
    public sealed virtual string get_Location();
    public sealed virtual string get_CodeBase();
    public sealed virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public sealed virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public sealed virtual AssemblyName[] GetReferencedAssemblies();
    public sealed virtual Module GetModule(string name);
}
internal class System.Reflection.Runtime.BindingFlagSupport.ConstructorPolicies : MemberPolicies`1<ConstructorInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<ConstructorInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<ConstructorInfo> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public sealed virtual BindingFlags ModifyBindingFlags(BindingFlags bindingFlags);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(ConstructorInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(ConstructorInfo baseMember, ConstructorInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(ConstructorInfo member, ConstructorInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(ConstructorInfo m1, ConstructorInfo m2);
}
internal class System.Reflection.Runtime.BindingFlagSupport.EventPolicies : MemberPolicies`1<EventInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<EventInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<EventInfo> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(EventInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(EventInfo member, EventInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool ImplicitlyOverrides(EventInfo baseMember, EventInfo derivedMember);
    public sealed virtual bool OkToIgnoreAmbiguity(EventInfo m1, EventInfo m2);
    private MethodInfo GetAccessorMethod(EventInfo e);
}
internal class System.Reflection.Runtime.BindingFlagSupport.FieldPolicies : MemberPolicies`1<FieldInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<FieldInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<FieldInfo> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(FieldInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(FieldInfo baseMember, FieldInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(FieldInfo member, FieldInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(FieldInfo m1, FieldInfo m2);
}
internal abstract class System.Reflection.Runtime.BindingFlagSupport.MemberPolicies`1 : object {
    public static MemberPolicies`1<M> Default;
    public static int MemberTypeIndex;
    public bool AlwaysTreatAsDeclaredOnly { get; }
    private static MemberPolicies`1();
    public abstract virtual IEnumerable`1<M> GetDeclaredMembers(TypeInfo typeInfo);
    public abstract virtual IEnumerable`1<M> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public abstract virtual void GetMemberAttributes(M member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public abstract virtual bool ImplicitlyOverrides(M baseMember, M derivedMember);
    public virtual BindingFlags ModifyBindingFlags(BindingFlags bindingFlags);
    public abstract virtual bool get_AlwaysTreatAsDeclaredOnly();
    public abstract virtual bool IsSuppressedByMoreDerivedMember(M member, M[] priorMembers, int startIndex, int endIndex);
    public abstract virtual bool OkToIgnoreAmbiguity(M m1, M m2);
    protected static bool AreNamesAndSignaturesEqual(MethodInfo method1, MethodInfo method2);
    private static bool GenericMethodAwareAreParameterTypesEqual(Type t1, Type t2);
}
internal static class System.Reflection.Runtime.BindingFlagSupport.MemberTypeIndex : object {
    public static int Constructor;
    public static int Event;
    public static int Field;
    public static int Method;
    public static int NestedType;
    public static int Property;
    public static int Count;
}
internal class System.Reflection.Runtime.BindingFlagSupport.MethodPolicies : MemberPolicies`1<MethodInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<MethodInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<MethodInfo> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(MethodInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(MethodInfo baseMember, MethodInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(MethodInfo member, MethodInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(MethodInfo m1, MethodInfo m2);
}
internal abstract class System.Reflection.Runtime.BindingFlagSupport.NameFilter : object {
    [CompilerGeneratedAttribute]
private string <ExpectedName>k__BackingField;
    protected string ExpectedName { get; }
    protected NameFilter(string expectedName);
    public abstract virtual bool Matches(StringHandle stringHandle, MetadataReader reader);
    public abstract virtual bool Matches(string name);
    [CompilerGeneratedAttribute]
protected string get_ExpectedName();
    public abstract virtual bool Matches(ConstantStringValueHandle stringHandle, MetadataReader reader);
}
internal class System.Reflection.Runtime.BindingFlagSupport.NameFilterCaseInsensitive : NameFilter {
    public NameFilterCaseInsensitive(string expectedName);
    public sealed virtual bool Matches(StringHandle stringHandle, MetadataReader reader);
    public sealed virtual bool Matches(string name);
    public sealed virtual bool Matches(ConstantStringValueHandle stringHandle, MetadataReader reader);
}
internal class System.Reflection.Runtime.BindingFlagSupport.NameFilterCaseSensitive : NameFilter {
    public NameFilterCaseSensitive(string expectedName);
    public sealed virtual bool Matches(StringHandle stringHandle, MetadataReader reader);
    public sealed virtual bool Matches(string name);
    public sealed virtual bool Matches(ConstantStringValueHandle stringHandle, MetadataReader reader);
}
internal class System.Reflection.Runtime.BindingFlagSupport.NestedTypePolicies : MemberPolicies`1<Type> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<Type> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<Type> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(Type member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(Type baseMember, Type derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(Type member, Type[] priorMembers, int startIndex, int endIndex);
    public sealed virtual BindingFlags ModifyBindingFlags(BindingFlags bindingFlags);
    public sealed virtual bool OkToIgnoreAmbiguity(Type m1, Type m2);
}
internal class System.Reflection.Runtime.BindingFlagSupport.PropertyPolicies : MemberPolicies`1<PropertyInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<PropertyInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<PropertyInfo> CoreGetDeclaredMembers(RuntimeTypeInfo type, NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(PropertyInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(PropertyInfo baseMember, PropertyInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(PropertyInfo member, PropertyInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(PropertyInfo m1, PropertyInfo m2);
    private MethodInfo GetAccessorMethod(PropertyInfo property);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Runtime.BindingFlagSupport.QueriedMemberList`1 : object {
    private int _totalCount;
    private int _declaredOnlyCount;
    private M[] _members;
    private BindingFlags[] _allFlagsThatMustMatch;
    private RuntimeTypeInfo _typeThatBlockedBrowsing;
    private static int Grow;
    public int TotalCount { get; }
    public int DeclaredOnlyCount { get; }
    public M Item { get; }
    private QueriedMemberList`1(int totalCount, int declaredOnlyCount, M[] members, BindingFlags[] allFlagsThatMustMatch, RuntimeTypeInfo typeThatBlockedBrowsing);
    public int get_TotalCount();
    public int get_DeclaredOnlyCount();
    public M get_Item(int index);
    public bool Matches(int index, BindingFlags bindingAttr);
    public QueriedMemberList`1<M> Filter(Func`2<M, bool> predicate);
    public static QueriedMemberList`1<M> Create(RuntimeTypeInfo type, string optionalNameFilter, bool ignoreCase);
    public void Compact();
    private void Add(M member, BindingFlags allFlagsThatMustMatch);
}
internal class System.Reflection.Runtime.BindingFlagSupport.QueryResult`1 : ValueType {
    private BindingFlags _bindingAttr;
    private int _lazyCount;
    private QueriedMemberList`1<M> _queriedMembers;
    public int Count { get; }
    private int UnfilteredCount { get; }
    public QueryResult`1(BindingFlags bindingAttr, QueriedMemberList`1<M> queriedMembers);
    public QueryResultEnumerator<M> GetEnumerator();
    public int get_Count();
    public M[] ToArray();
    public void CopyTo(MemberInfo[] array, int startIndex);
    public M Disambiguate();
    private int get_UnfilteredCount();
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.BindingFlagSupport.Shared : object {
    [ExtensionAttribute]
public static bool QualifiesBasedOnParameterCount(MethodBase methodBase, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    [ExtensionAttribute]
public static M GetImplicitlyOverriddenBaseClassMember(M member);
}
internal class System.Reflection.Runtime.CustomAttributes.EcmaFormat.EcmaFormatCustomAttributeData : RuntimeCustomAttributeData {
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _namedArguments;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _fixedArguments;
    private MetadataReader _reader;
    private CustomAttribute _customAttribute;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAttributeType;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    internal string AttributeTypeString { get; }
    internal EcmaFormatCustomAttributeData(MetadataReader reader, CustomAttributeHandle customAttributeHandle);
    public sealed virtual Type get_AttributeType();
    public sealed virtual ConstructorInfo get_Constructor();
    internal sealed virtual string get_AttributeTypeString();
    internal sealed virtual IList`1<CustomAttributeTypedArgument> GetConstructorArguments(bool throwIfMissingMetadata);
    internal sealed virtual IList`1<CustomAttributeNamedArgument> GetNamedArguments(bool throwIfMissingMetadata);
    private void LoadArgumentInfo(bool throwIfMissingMetadata, IList`1& namedArguments, IList`1& fixedArguments, Boolean& metadataWasMissing);
}
internal class System.Reflection.Runtime.CustomAttributes.NativeFormat.NativeFormatCustomAttributeData : RuntimeCustomAttributeData {
    private MetadataReader _reader;
    private CustomAttribute _customAttribute;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAttributeType;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    internal string AttributeTypeString { get; }
    internal NativeFormatCustomAttributeData(MetadataReader reader, CustomAttributeHandle customAttributeHandle);
    public sealed virtual Type get_AttributeType();
    public sealed virtual ConstructorInfo get_Constructor();
    internal sealed virtual string get_AttributeTypeString();
    internal sealed virtual IList`1<CustomAttributeTypedArgument> GetConstructorArguments(bool throwIfMissingMetadata);
    internal sealed virtual IList`1<CustomAttributeNamedArgument> GetNamedArguments(bool throwIfMissingMetadata);
    private CustomAttributeTypedArgument ParseFixedArgument(MetadataReader reader, FixedArgumentHandle fixedArgumentHandle, bool throwIfMissingMetadata, Func`1<RuntimeTypeInfo> getTypeFromConstructor);
}
internal abstract class System.Reflection.Runtime.CustomAttributes.RuntimeCustomAttributeData : RuntimeImplementedCustomAttributeData {
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    internal string AttributeTypeString { get; }
    private string LastResortToString { get; }
    [IteratorStateMachineAttribute("System.Reflection.Runtime.CustomAttributes.RuntimeCustomAttributeData/<GetCustomAttributes>d__0")]
internal static IEnumerable`1<CustomAttributeData> GetCustomAttributes(MetadataReader reader, CustomAttributeHandleCollection customAttributeHandles);
    public static CustomAttributeData GetCustomAttributeData(MetadataReader reader, CustomAttributeHandle customAttributeHandle);
    public abstract virtual Type get_AttributeType();
    public abstract virtual ConstructorInfo get_Constructor();
    public sealed virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public sealed virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public sealed virtual string ToString();
    protected static ConstructorInfo ResolveAttributeConstructor(Type attributeType, Type[] parameterTypes);
    internal abstract virtual string get_AttributeTypeString();
    internal abstract virtual IList`1<CustomAttributeTypedArgument> GetConstructorArguments(bool throwIfMissingMetadata);
    internal abstract virtual IList`1<CustomAttributeNamedArgument> GetNamedArguments(bool throwIfMissingMetadata);
    private static string ComputeTypedArgumentString(CustomAttributeTypedArgument cat, bool typed);
    private string get_LastResortToString();
    protected CustomAttributeTypedArgument WrapInCustomAttributeTypedArgument(object value, Type argumentType);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.CustomAttributes.RuntimeCustomAttributeData/<GetCustomAttributes>d__20")]
internal static IEnumerable`1<CustomAttributeData> GetCustomAttributes(MetadataReader reader, CustomAttributeHandleCollection customAttributeHandles);
    private static CustomAttributeData GetCustomAttributeData(MetadataReader reader, CustomAttributeHandle customAttributeHandle);
}
internal class System.Reflection.Runtime.CustomAttributes.RuntimePseudoCustomAttributeData : RuntimeCustomAttributeData {
    private Type _attributeType;
    private ReadOnlyCollection`1<CustomAttributeTypedArgument> _constructorArguments;
    private ReadOnlyCollection`1<CustomAttributeNamedArgument> _namedArguments;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    internal string AttributeTypeString { get; }
    public RuntimePseudoCustomAttributeData(Type attributeType, IList`1<CustomAttributeTypedArgument> constructorArguments, IList`1<CustomAttributeNamedArgument> namedArguments);
    public sealed virtual Type get_AttributeType();
    public sealed virtual ConstructorInfo get_Constructor();
    internal sealed virtual string get_AttributeTypeString();
    internal sealed virtual IList`1<CustomAttributeTypedArgument> GetConstructorArguments(bool throwIfMissingMetadata);
    internal sealed virtual IList`1<CustomAttributeNamedArgument> GetNamedArguments(bool throwIfMissingMetadata);
}
internal class System.Reflection.Runtime.Dispensers.DefaultDispenserPolicy : DispenserPolicy {
    public sealed virtual DispenserAlgorithm GetAlgorithm(DispenserScenario scenario);
}
internal abstract class System.Reflection.Runtime.Dispensers.Dispenser`2 : object {
    public abstract virtual V GetOrAdd(K key);
}
internal class System.Reflection.Runtime.Dispensers.DispenserAlgorithm : object {
    public static DispenserAlgorithm CreateAlways;
    public static DispenserAlgorithm ReuseAlways;
    public static DispenserAlgorithm ReuseAsLongAsValueIsAlive;
    public static DispenserAlgorithm ReuseAsLongAsKeyIsAlive;
    private static DispenserAlgorithm();
}
internal static class System.Reflection.Runtime.Dispensers.DispenserFactory : object {
    private static DispenserPolicy s_dispenserPolicy;
    private static DispenserFactory();
    public static Dispenser`2<K, V> CreateDispenser(DispenserScenario scenario, Func`2<K, V> factory);
    public static Dispenser`2<K, V> CreateDispenserV(DispenserScenario scenario, Func`2<K, V> factory);
}
internal abstract class System.Reflection.Runtime.Dispensers.DispenserPolicy : object {
    public abstract virtual DispenserAlgorithm GetAlgorithm(DispenserScenario scenario);
}
internal enum System.Reflection.Runtime.Dispensers.DispenserScenario : Enum {
    public int value__;
    public static DispenserScenario AssemblyAndNamespaceTypeName_Type;
    public static DispenserScenario AssemblyRefName_Assembly;
    public static DispenserScenario RuntimeAssembly_CaseInsensitiveTypeDictionary;
    public static DispenserScenario Scope_Assembly;
}
internal class System.Reflection.Runtime.Dispensers.DispenserThatAlwaysCreates`2 : Dispenser`2<K, V> {
    private Func`2<K, V> _factory;
    public DispenserThatAlwaysCreates`2(Func`2<K, V> factory);
    public sealed virtual V GetOrAdd(K key);
}
internal class System.Reflection.Runtime.Dispensers.DispenserThatAlwaysReuses`2 : Dispenser`2<K, V> {
    private FactoryConcurrentUnifier<K, V> _concurrentUnifier;
    public DispenserThatAlwaysReuses`2(Func`2<K, V> factory);
    public sealed virtual V GetOrAdd(K key);
}
internal class System.Reflection.Runtime.Dispensers.DispenserThatReusesAsLongAsKeyIsAlive`2 : Dispenser`2<K, V> {
    private Func`2<K, V> _factory;
    private ConditionalWeakTable`2<K, V> _conditionalWeakTable;
    private CreateValueCallback<K, V> _createValueCallback;
    public DispenserThatReusesAsLongAsKeyIsAlive`2(Func`2<K, V> factory);
    public sealed virtual V GetOrAdd(K key);
    private V CreateValue(K key);
}
internal class System.Reflection.Runtime.Dispensers.DispenserThatReusesAsLongAsValueIsAlive`2 : Dispenser`2<K, V> {
    private FactoryConcurrentUnifierW<K, V> _concurrentUnifier;
    public DispenserThatReusesAsLongAsValueIsAlive`2(Func`2<K, V> factory);
    public sealed virtual V GetOrAdd(K key);
}
[__BlockReflectionAttribute]
public static class System.Reflection.Runtime.EcmaMetadataHelpers : object {
    public static bool IsConstructor(MethodDefinition& method, MetadataReader reader);
    public static void GetAttributeTypeDefRefOrSpecHandle(MetadataReader metadataReader, EntityHandle attributeCtor, EntityHandle& ctorType);
    public static bool GetAttributeNamespaceAndName(MetadataReader metadataReader, EntityHandle typeDefOrRef, StringHandle& namespaceHandle, StringHandle& nameHandle);
    public static bool IsNested(TypeAttributes flags);
    public static void SkipType(BlobReader& reader);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal class System.Reflection.Runtime.EventInfos.EcmaFormat.EcmaFormatRuntimeEventInfo : RuntimeEventInfo {
    private EcmaFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private EventDefinitionHandle _eventHandle;
    private MetadataReader _reader;
    private EventDefinition _event;
    public EventAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type EventHandlerType { get; }
    public int MetadataToken { get; }
    protected string MetadataName { get; }
    protected RuntimeTypeInfo DefiningTypeInfo { get; }
    private EcmaFormatRuntimeEventInfo(EventDefinitionHandle eventHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    protected sealed virtual MethodInfo GetEventMethod(EventMethodSemantics whichMethod);
    public sealed virtual EventAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual Type get_EventHandlerType();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual string get_MetadataName();
    protected sealed virtual RuntimeTypeInfo get_DefiningTypeInfo();
    internal static RuntimeEventInfo GetRuntimeEventInfo(EventDefinitionHandle eventHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal class System.Reflection.Runtime.EventInfos.NativeFormat.NativeFormatRuntimeEventInfo : RuntimeEventInfo {
    private NativeFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private EventHandle _eventHandle;
    private MetadataReader _reader;
    private Event _event;
    public EventAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type EventHandlerType { get; }
    public int MetadataToken { get; }
    protected string MetadataName { get; }
    protected RuntimeTypeInfo DefiningTypeInfo { get; }
    private NativeFormatRuntimeEventInfo(EventHandle eventHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    protected sealed virtual MethodInfo GetEventMethod(EventMethodSemantics whichMethod);
    public sealed virtual EventAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual Type get_EventHandlerType();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual string get_MetadataName();
    protected sealed virtual RuntimeTypeInfo get_DefiningTypeInfo();
    internal static RuntimeEventInfo GetRuntimeEventInfo(EventHandle eventHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal abstract class System.Reflection.Runtime.EventInfos.RuntimeEventInfo : EventInfo {
    protected RuntimeTypeInfo ContextTypeInfo;
    protected RuntimeTypeInfo ReflectedTypeInfo;
    private MethodInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAdder;
    private MethodInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRemover;
    private string _debugName;
    public MethodInfo AddMethod { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public MethodInfo RaiseMethod { get; }
    public MethodInfo RemoveMethod { get; }
    private string Internal.Reflection.Tracing.ITraceableTypeMember.MemberName { get; }
    private Type Internal.Reflection.Tracing.ITraceableTypeMember.ContainingType { get; }
    public EventAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type EventHandlerType { get; }
    public int MetadataToken { get; }
    protected string MetadataName { get; }
    protected RuntimeTypeInfo DefiningTypeInfo { get; }
    protected RuntimeEventInfo(RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    public sealed virtual MethodInfo get_AddMethod();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Module get_Module();
    public sealed virtual string get_Name();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual MethodInfo get_RaiseMethod();
    public sealed virtual MethodInfo get_RemoveMethod();
    public sealed virtual string ToString();
    private sealed virtual override string Internal.Reflection.Tracing.ITraceableTypeMember.get_MemberName();
    private sealed virtual override Type Internal.Reflection.Tracing.ITraceableTypeMember.get_ContainingType();
    protected RuntimeEventInfo WithDebugName();
    public abstract virtual EventAttributes get_Attributes();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual Type get_EventHandlerType();
    public abstract virtual int get_MetadataToken();
    protected abstract virtual MethodInfo GetEventMethod(EventMethodSemantics whichMethod);
    protected abstract virtual string get_MetadataName();
    protected abstract virtual RuntimeTypeInfo get_DefiningTypeInfo();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual MethodInfo GetAddMethod(bool nonPublic);
    public sealed virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public sealed virtual MethodInfo GetRaiseMethod(bool nonPublic);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal class System.Reflection.Runtime.FieldInfos.EcmaFormat.EcmaFormatRuntimeFieldInfo : RuntimeFieldInfo {
    private EcmaFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private FieldDefinitionHandle _fieldHandle;
    private MetadataReader _reader;
    private FieldDefinition _field;
    public FieldAttributes Attributes { get; }
    public int MetadataToken { get; }
    protected string MetadataName { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    protected RuntimeTypeInfo FieldRuntimeType { get; }
    protected RuntimeTypeInfo DefiningType { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    protected int ExplicitLayoutFieldOffsetData { get; }
    private EcmaFormatRuntimeFieldInfo(FieldDefinitionHandle fieldHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    public sealed virtual FieldAttributes get_Attributes();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual string get_MetadataName();
    public sealed virtual string ToString();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual RuntimeFieldHandle get_FieldHandle();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    protected sealed virtual bool GetDefaultValueIfAvailable(bool raw, Object& defaultValue);
    protected sealed virtual FieldAccessor TryGetFieldAccessor();
    protected sealed virtual RuntimeTypeInfo get_FieldRuntimeType();
    protected sealed virtual RuntimeTypeInfo get_DefiningType();
    protected sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    protected sealed virtual int get_ExplicitLayoutFieldOffsetData();
    internal static RuntimeFieldInfo GetRuntimeFieldInfo(FieldDefinitionHandle fieldHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal class System.Reflection.Runtime.FieldInfos.NativeFormat.NativeFormatRuntimeFieldInfo : RuntimeFieldInfo {
    private NativeFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private FieldHandle _fieldHandle;
    private MetadataReader _reader;
    private Field _field;
    public FieldAttributes Attributes { get; }
    public int MetadataToken { get; }
    protected string MetadataName { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    protected RuntimeTypeInfo FieldRuntimeType { get; }
    protected RuntimeTypeInfo DefiningType { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    protected int ExplicitLayoutFieldOffsetData { get; }
    private Handle FieldTypeHandle { get; }
    private NativeFormatRuntimeFieldInfo(FieldHandle fieldHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    public sealed virtual FieldAttributes get_Attributes();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual string get_MetadataName();
    public sealed virtual string ToString();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual RuntimeFieldHandle get_FieldHandle();
    protected sealed virtual bool GetDefaultValueIfAvailable(bool raw, Object& defaultValue);
    protected sealed virtual FieldAccessor TryGetFieldAccessor();
    protected sealed virtual RuntimeTypeInfo get_FieldRuntimeType();
    protected sealed virtual RuntimeTypeInfo get_DefiningType();
    protected sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    protected sealed virtual int get_ExplicitLayoutFieldOffsetData();
    private Handle get_FieldTypeHandle();
    internal static RuntimeFieldInfo GetRuntimeFieldInfo(FieldHandle fieldHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal abstract class System.Reflection.Runtime.FieldInfos.RuntimeFieldInfo : FieldInfo {
    protected RuntimeTypeInfo _contextTypeInfo;
    protected RuntimeTypeInfo _reflectedType;
    private FieldAccessor modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFieldAccessor;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFieldType;
    private string _debugName;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public Type FieldType { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    private Type Internal.Reflection.Tracing.ITraceableTypeMember.ContainingType { get; }
    protected string MetadataName { get; }
    public string Name { get; }
    private string Internal.Reflection.Tracing.ITraceableTypeMember.MemberName { get; }
    public FieldAttributes Attributes { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    private FieldAccessor FieldAccessor { get; }
    protected RuntimeTypeInfo FieldRuntimeType { get; }
    protected RuntimeTypeInfo DefiningType { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    protected int ExplicitLayoutFieldOffsetData { get; }
    internal int Offset { get; }
    protected RuntimeFieldInfo(RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.FieldInfos.RuntimeFieldInfo/<get_CustomAttributes>d__2")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual Type get_FieldType();
    public abstract virtual Type[] GetOptionalCustomModifiers();
    public abstract virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual object GetValue(object obj);
    public sealed virtual object GetValueDirect(TypedReference obj);
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public sealed virtual void SetValueDirect(TypedReference obj, object value);
    private sealed virtual override Type Internal.Reflection.Tracing.ITraceableTypeMember.get_ContainingType();
    protected abstract virtual string get_MetadataName();
    public sealed virtual string get_Name();
    private sealed virtual override string Internal.Reflection.Tracing.ITraceableTypeMember.get_MemberName();
    public sealed virtual object GetRawConstantValue();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual int get_MetadataToken();
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    protected abstract virtual bool GetDefaultValueIfAvailable(bool raw, Object& defaultValue);
    protected abstract virtual FieldAccessor TryGetFieldAccessor();
    private FieldAccessor get_FieldAccessor();
    protected abstract virtual RuntimeTypeInfo get_FieldRuntimeType();
    protected RuntimeFieldInfo WithDebugName();
    protected abstract virtual RuntimeTypeInfo get_DefiningType();
    protected abstract virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    protected abstract virtual int get_ExplicitLayoutFieldOffsetData();
    internal int get_Offset();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.Assignability : object {
    public static bool IsAssignableFrom(Type toTypeInfo, Type fromTypeInfo);
    [ExtensionAttribute]
private static bool CanCastTo(Type fromTypeInfo, Type toTypeInfo);
    [ExtensionAttribute]
private static bool MatchesWithVariance(Type fromTypeInfo, Type toTypeInfo);
    [ExtensionAttribute]
private static bool IsElementTypeCompatibleWith(Type fromTypeInfo, Type toTypeInfo);
    [ExtensionAttribute]
private static Type ReducedType(Type t);
    [ExtensionAttribute]
private static bool IsGcReferenceTypeAndCastableTo(Type fromTypeInfo, Type toTypeInfo);
    [ExtensionAttribute]
private static bool ProvablyAGcReferenceType(Type t);
    [ExtensionAttribute]
private static bool ProvablyAGcReferenceTypeHelper(Type t);
    [ExtensionAttribute]
private static bool CanCastArrayToInterface(Type fromTypeInfo, Type toTypeInfo);
}
internal static class System.Reflection.Runtime.General.BlockedRuntimeTypeNameGenerator : object {
    private static BlockedRuntimeTypeNameTable s_blockedNameTable;
    private static BlockedRuntimeTypeNameGenerator();
    public static string GetNameForBlockedRuntimeType(RuntimeTypeHandle typeHandle);
}
internal static class System.Reflection.Runtime.General.EcmaFormat.DefaultValueProcessing : object {
    public static bool GetDefaultValueIfAny(MetadataReader reader, FieldDefinition& field, FieldInfo fieldInfo, bool raw, Object& defaultValue);
    public static bool GetDefaultValueIfAny(MetadataReader reader, Parameter& parameter, ParameterInfo parameterInfo, bool raw, Object& defaultValue);
    public static bool GetDefaultValueIfAny(MetadataReader reader, PropertyDefinition& property, PropertyInfo propertyInfo, bool raw, Object& defaultValue);
    private static object ConstantValueAsObject(ConstantHandle constantHandle, MetadataReader metadataReader, Type declaredType, bool raw);
    private static object ConstantValueAsRawObject(ConstantHandle constantHandle, MetadataReader metadataReader);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.EcmaMetadataReaderExtensions : object {
    [ExtensionAttribute]
public static bool IsConstructor(MethodDefinitionHandle methodHandle, MetadataReader reader);
    [ExtensionAttribute]
public static PrimitiveTypeCode GetPrimitiveTypeCode(Type type);
    [ExtensionAttribute]
public static Type GetRuntimeType(PrimitiveTypeCode primitiveCode);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.Helpers : object {
    private static Char[] s_charsToEscape;
    private static Helpers();
    [ExtensionAttribute]
public static EcmaFormatRuntimeNamedTypeInfo CastToEcmaFormatRuntimeNamedTypeInfo(Type type);
    [ExtensionAttribute]
public static NativeFormatRuntimeNamedTypeInfo CastToNativeFormatRuntimeNamedTypeInfo(Type type);
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle h);
    [ExtensionAttribute]
public static Type[] CloneTypeArray(Type[] types);
    [ExtensionAttribute]
public static Type[] GetGenericTypeParameters(Type type);
    [ExtensionAttribute]
public static RuntimeTypeInfo[] ToRuntimeTypeInfoArray(Type[] types);
    [ExtensionAttribute]
public static string LastResortString(RuntimeTypeHandle typeHandle);
    [ExtensionAttribute]
public static RuntimeNamedTypeInfo CastToRuntimeNamedTypeInfo(Type type);
    [ExtensionAttribute]
public static RuntimeTypeInfo CastToRuntimeTypeInfo(Type type);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static MethodInfo FilterAccessor(MethodInfo accessor, bool nonPublic);
    [ExtensionAttribute]
public static Type GetTypeCore(Assembly assembly, string name, bool ignoreCase);
    public static TypeLoadException CreateTypeLoadException(string typeName, Assembly assemblyIfAny);
    public static TypeLoadException CreateTypeLoadException(string typeName, string assemblyName);
    [ExtensionAttribute]
public static string EscapeTypeNameIdentifier(string identifier);
    [ExtensionAttribute]
public static bool NeedsEscapingInTypeName(char c);
    [ExtensionAttribute]
public static RuntimeMethodInfo GetInvokeMethod(RuntimeTypeInfo delegateType);
    [ExtensionAttribute]
public static BinderBundle ToBinderBundle(Binder binder, BindingFlags invokeAttr, CultureInfo cultureInfo);
    [ExtensionAttribute]
public static Object[] InstantiateAsArray(IEnumerable`1<CustomAttributeData> cads, Type actualElementType);
    public static bool GetCustomAttributeDefaultValueIfAny(IEnumerable`1<CustomAttributeData> customAttributes, bool raw, Object& defaultValue);
}
internal interface System.Reflection.Runtime.General.IRuntimeMemberInfoWithNoMetadataDefinition {
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Runtime.General.ListBuilder`1 : ValueType {
    private T[] _items;
    private T _item;
    private int _count;
    private int _capacity;
    public T Item { get; }
    public int Count { get; }
    public ListBuilder`1(int capacity);
    public T get_Item(int index);
    public T[] ToArray();
    public void CopyTo(Object[] array, int index);
    public int get_Count();
    public void Add(T item);
}
internal class System.Reflection.Runtime.General.NamespaceChain : object {
    [CompilerGeneratedAttribute]
private string <NameSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopeDefinitionHandle <DefiningScope>k__BackingField;
    internal string NameSpace { get; }
    internal ScopeDefinitionHandle DefiningScope { get; }
    internal NamespaceChain(MetadataReader reader, NamespaceDefinitionHandle innerMostNamespaceHandle);
    [CompilerGeneratedAttribute]
internal string get_NameSpace();
    [CompilerGeneratedAttribute]
internal ScopeDefinitionHandle get_DefiningScope();
}
internal static class System.Reflection.Runtime.General.NativeFormat.DefaultValueParser : object {
    public static bool GetDefaultValueIfAny(MetadataReader reader, Handle constantHandle, Type declaredType, IEnumerable`1<CustomAttributeData> customAttributes, bool raw, Object& defaultValue);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.NativeFormatMetadataReaderExtensions : object {
    [ExtensionAttribute]
public static bool StringOrNullEquals(ConstantStringValueHandle handle, string valueOrNull, MetadataReader reader);
    [ExtensionAttribute]
public static int AsInt(TypeDefinitionHandle typeDefinitionHandle);
    [ExtensionAttribute]
public static TypeDefinitionHandle AsTypeDefinitionHandle(int i);
    [ExtensionAttribute]
public static int AsInt(MethodHandle methodHandle);
    [ExtensionAttribute]
public static MethodHandle AsMethodHandle(int i);
    [ExtensionAttribute]
public static int AsInt(FieldHandle fieldHandle);
    [ExtensionAttribute]
public static FieldHandle AsFieldHandle(int i);
    [ExtensionAttribute]
public static bool IsNamespaceDefinitionHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsNamespaceReferenceHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static ScopeReferenceHandle ToExpectedScopeReferenceHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static NamespaceReferenceHandle ToExpectedNamespaceReferenceHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static TypeDefinitionHandle ToExpectedTypeDefinitionHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Type[] GetCustomModifiers(Handle handle, MetadataReader reader, TypeContext typeContext, bool optional);
    [ExtensionAttribute]
public static Handle SkipCustomModifiers(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MethodSignature ParseMethodSignature(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static FieldSignature ParseFieldSignature(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static PropertySignature ParsePropertySignature(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsConstructor(MethodHandle methodHandle, MetadataReader reader);
    public static bool IsConstructor(Method& method, MetadataReader reader);
    [ExtensionAttribute]
private static Exception ParseBoxedEnumConstantValue(ConstantBoxedEnumValueHandle handle, MetadataReader reader, Object& value);
    [ExtensionAttribute]
public static object ParseConstantValue(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Exception TryParseConstantValue(Handle handle, MetadataReader reader, Object& value);
    [ExtensionAttribute]
private static Array TryParseConstantArray(Handle handle, MetadataReader reader, Exception& exception);
    [ExtensionAttribute]
private static Array TryParseConstantEnumArray(ConstantEnumArrayHandle handle, MetadataReader reader, Exception& exception);
    [ExtensionAttribute]
public static Handle GetAttributeTypeHandle(CustomAttribute customAttribute, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsCustomAttributeOfType(CustomAttributeHandle customAttributeHandle, MetadataReader reader, string ns, string name);
    [ExtensionAttribute]
public static string ToNamespaceName(NamespaceDefinitionHandle namespaceDefinitionHandle, MetadataReader reader);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.General.NativeFormatMetadataReaderExtensions/<GetTransitiveNamespaces>d__27")]
[ExtensionAttribute]
public static IEnumerable`1<NamespaceDefinitionHandle> GetTransitiveNamespaces(MetadataReader reader, IEnumerable`1<NamespaceDefinitionHandle> namespaceHandles);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.General.NativeFormatMetadataReaderExtensions/<GetTopLevelTypes>d__28")]
[ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTopLevelTypes(MetadataReader reader, IEnumerable`1<NamespaceDefinitionHandle> namespaceHandles);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.General.NativeFormatMetadataReaderExtensions/<GetTransitiveTypes>d__29")]
[ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> GetTransitiveTypes(MetadataReader reader, IEnumerable`1<TypeDefinitionHandle> typeDefinitionHandles, bool publicOnly);
    private static void ReverseStringInStringBuilder(StringBuilder builder, int index, int len);
    [ExtensionAttribute]
public static string ToFullyQualifiedTypeName(NamespaceReferenceHandle namespaceReferenceHandle, string typeName, MetadataReader reader);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.General.NativeFormatMetadataReaderExtensions/<AsEnumerable>d__32")]
[ExtensionAttribute]
public static IEnumerable`1<NamespaceDefinitionHandle> AsEnumerable(NamespaceDefinitionHandleCollection collection);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.General.NativeFormatMetadataReaderExtensions/<AsEnumerable>d__33")]
[ExtensionAttribute]
public static IEnumerable`1<TypeDefinitionHandle> AsEnumerable(TypeDefinitionHandleCollection collection);
    [ExtensionAttribute]
public static Handle[] ToArray(HandleCollection collection);
    [ExtensionAttribute]
public static Boolean[] ToArray(BooleanCollection collection);
    [ExtensionAttribute]
public static Char[] ToArray(CharCollection collection);
    [ExtensionAttribute]
public static Single[] ToArray(SingleCollection collection);
    [ExtensionAttribute]
public static Double[] ToArray(DoubleCollection collection);
    [ExtensionAttribute]
public static Byte[] ToArray(ByteCollection collection, Type enumType);
    [ExtensionAttribute]
public static SByte[] ToArray(SByteCollection collection, Type enumType);
    [ExtensionAttribute]
public static UInt16[] ToArray(UInt16Collection collection, Type enumType);
    [ExtensionAttribute]
public static Int16[] ToArray(Int16Collection collection, Type enumType);
    [ExtensionAttribute]
public static UInt32[] ToArray(UInt32Collection collection, Type enumType);
    [ExtensionAttribute]
public static Int32[] ToArray(Int32Collection collection, Type enumType);
    [ExtensionAttribute]
public static UInt64[] ToArray(UInt64Collection collection, Type enumType);
    [ExtensionAttribute]
public static Int64[] ToArray(Int64Collection collection, Type enumType);
}
[__BlockReflectionAttribute]
public class System.Reflection.Runtime.General.QSignatureTypeHandle : ValueType {
    private object _reader;
    private BlobReader _blobReader;
    private Handle _handle;
    public object Reader { get; }
    public QSignatureTypeHandle(MetadataReader reader, BlobReader blobReader);
    public QSignatureTypeHandle(MetadataReader reader, Handle handle, bool skipCheck);
    private RuntimeTypeInfo TryResolveSignature(TypeContext typeContext, Exception& exception);
    public object get_Reader();
    internal RuntimeTypeInfo Resolve(TypeContext typeContext);
    internal RuntimeTypeInfo TryResolve(TypeContext typeContext, Exception& exception);
    internal Type[] GetCustomModifiers(TypeContext typeContext, bool optional);
    internal string FormatTypeName(TypeContext typeContext);
}
internal class System.Reflection.Runtime.General.ReflectionCoreCallbacksImplementation : ReflectionCoreCallbacks {
    public sealed virtual Assembly Load(AssemblyName assemblyRef, bool throwOnFileNotFound);
    public sealed virtual Assembly Load(Byte[] rawAssembly, Byte[] pdbSymbolStore);
    public sealed virtual MethodBase GetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle);
    public sealed virtual MethodBase GetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle);
    public sealed virtual FieldInfo GetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle);
    public sealed virtual FieldInfo GetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle declaringTypeHandle);
    public sealed virtual EventInfo GetImplicitlyOverriddenBaseClassEvent(EventInfo e);
    public sealed virtual MethodInfo GetImplicitlyOverriddenBaseClassMethod(MethodInfo m);
    public sealed virtual PropertyInfo GetImplicitlyOverriddenBaseClassProperty(PropertyInfo p);
    private FieldInfo GetFieldInfo(RuntimeTypeHandle declaringTypeHandle, FieldHandle fieldHandle);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual object ActivatorCreateInstance(Type type, bool nonPublic);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual object ActivatorCreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public sealed virtual Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public sealed virtual Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    private static Delegate CreateDelegateWorker(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure, bool allowClosed);
    public sealed virtual Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public sealed virtual Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    private static RuntimeMethodInfo LookupMethodForCreateDelegate(RuntimeTypeInfo runtimeDelegateType, RuntimeTypeInfo containingType, string method, bool isStatic, bool ignoreCase);
    public sealed virtual Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    public sealed virtual IntPtr GetFunctionPointer(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle);
    public sealed virtual void RunModuleConstructor(Module module);
    public sealed virtual void MakeTypedReference(object target, FieldInfo[] flds, Type& type, Int32& offset);
    public sealed virtual Assembly[] GetLoadedAssemblies();
    public sealed virtual EnumInfo GetEnumInfo(Type type);
}
internal class System.Reflection.Runtime.General.RuntimeTypeHandleKey : ValueType {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <TypeHandle>k__BackingField;
    public RuntimeTypeHandle TypeHandle { get; }
    public RuntimeTypeHandleKey(RuntimeTypeHandle typeHandle);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_TypeHandle();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeTypeHandleKey other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.ToStringUtils : object {
    [ExtensionAttribute]
public static string FormatTypeName(QTypeDefRefOrSpec qualifiedTypeHandle, TypeContext typeContext);
}
internal class System.Reflection.Runtime.General.TypeContext : ValueType {
    private RuntimeTypeInfo[] _genericTypeArguments;
    private RuntimeTypeInfo[] _genericMethodArguments;
    internal RuntimeTypeInfo[] GenericTypeArguments { get; }
    internal RuntimeTypeInfo[] GenericMethodArguments { get; }
    internal TypeContext(RuntimeTypeInfo[] genericTypeArguments, RuntimeTypeInfo[] genericMethodArguments);
    internal RuntimeTypeInfo[] get_GenericTypeArguments();
    internal RuntimeTypeInfo[] get_GenericMethodArguments();
}
internal class System.Reflection.Runtime.General.TypeForwardInfo : ValueType {
    [CompilerGeneratedAttribute]
private RuntimeAssemblyName <RedirectedAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public RuntimeAssemblyName RedirectedAssemblyName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public TypeForwardInfo(RuntimeAssemblyName redirectedAssemblyName, string namespaceName, string typeName);
    [CompilerGeneratedAttribute]
public RuntimeAssemblyName get_RedirectedAssemblyName();
    [CompilerGeneratedAttribute]
public string get_NamespaceName();
    [CompilerGeneratedAttribute]
public string get_TypeName();
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.TypeResolver : object {
    [ExtensionAttribute]
internal static RuntimeTypeInfo Resolve(Handle typeDefRefOrSpec, MetadataReader reader, TypeContext typeContext);
    [ExtensionAttribute]
internal static RuntimeTypeInfo Resolve(EntityHandle typeDefRefOrSpec, MetadataReader reader, TypeContext typeContext);
    [ExtensionAttribute]
internal static RuntimeTypeInfo TryResolve(Handle typeDefRefOrSpec, MetadataReader reader, TypeContext typeContext, Exception& exception);
    [ExtensionAttribute]
internal static RuntimeTypeInfo ResolveTypeDefinition(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader);
    [ExtensionAttribute]
private static RuntimeTypeInfo TryResolveTypeSignature(TypeSpecificationHandle typeSpecHandle, MetadataReader reader, TypeContext typeContext, Exception& exception);
    [ExtensionAttribute]
private static string GetFullyQualifiedTypeName(TypeReference typeReference, MetadataReader reader);
    private static RuntimeTypeInfo TryResolveTypeByName(MetadataReader reader, string fullName, Exception& exception);
    [ExtensionAttribute]
private static RuntimeTypeInfo TryResolveTypeReference(TypeReferenceHandle typeReferenceHandle, MetadataReader reader, Exception& exception);
    [ExtensionAttribute]
internal static RuntimeTypeInfo Resolve(QTypeDefRefOrSpec typeDefOrRefOrSpec, TypeContext typeContext);
    [ExtensionAttribute]
internal static RuntimeTypeInfo TryResolve(QTypeDefRefOrSpec typeDefOrRefOrSpec, TypeContext typeContext, Exception& exception);
    [ExtensionAttribute]
internal static RuntimeTypeInfo Resolve(Handle typeDefRefOrSpec, MetadataReader reader, TypeContext typeContext);
    [ExtensionAttribute]
internal static RuntimeTypeInfo TryResolve(Handle typeDefRefOrSpec, MetadataReader reader, TypeContext typeContext, Exception& exception);
    [ExtensionAttribute]
internal static RuntimeTypeInfo ResolveTypeDefinition(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader);
    [ExtensionAttribute]
private static RuntimeTypeInfo TryResolveTypeSignature(TypeSpecificationHandle typeSpecHandle, MetadataReader reader, TypeContext typeContext, Exception& exception);
    [ExtensionAttribute]
private static RuntimeTypeInfo TryResolveTypeReference(TypeReferenceHandle typeReferenceHandle, MetadataReader reader, Exception& exception);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.General.TypeUnifier : object {
    [ExtensionAttribute]
public static RuntimeTypeDefinitionTypeInfo GetNamedType(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader);
    [ExtensionAttribute]
public static RuntimeTypeDefinitionTypeInfo GetNamedType(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader, RuntimeTypeHandle precomputedTypeHandle);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetArrayType(RuntimeTypeInfo elementType);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetMultiDimArrayType(RuntimeTypeInfo elementType, int rank);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetByRefType(RuntimeTypeInfo targetType);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetPointerType(RuntimeTypeInfo targetType);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetConstructedGenericType(RuntimeTypeInfo genericTypeDefinition, RuntimeTypeInfo[] genericTypeArguments);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetTypeForRuntimeTypeHandle(RuntimeTypeHandle typeHandle);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetArrayType(RuntimeTypeInfo elementType, RuntimeTypeHandle precomputedTypeHandle);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetMultiDimArrayType(RuntimeTypeInfo elementType, int rank, RuntimeTypeHandle precomputedTypeHandle);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetPointerType(RuntimeTypeInfo targetType, RuntimeTypeHandle precomputedTypeHandle);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetByRefType(RuntimeTypeInfo targetType, RuntimeTypeHandle precomputedTypeHandle);
    [ExtensionAttribute]
public static RuntimeTypeInfo GetConstructedGenericType(RuntimeTypeInfo genericTypeDefinition, RuntimeTypeInfo[] genericTypeArguments, RuntimeTypeHandle precomputedTypeHandle);
    [ExtensionAttribute]
public static RuntimeTypeDefinitionTypeInfo GetNamedType(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader);
    [ExtensionAttribute]
public static RuntimeTypeDefinitionTypeInfo GetNamedType(TypeDefinitionHandle typeDefinitionHandle, MetadataReader reader, RuntimeTypeHandle precomputedTypeHandle);
}
internal class System.Reflection.Runtime.MethodInfos.CustomMethodInvoker : MethodInvoker {
    private InvokerOptions _options;
    private CustomMethodInvokerAction _action;
    private Type _thisType;
    private Type[] _parameterTypes;
    public IntPtr LdFtnResult { get; }
    public CustomMethodInvoker(Type thisType, Type[] parameterTypes, InvokerOptions options, CustomMethodInvokerAction action);
    protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal class System.Reflection.Runtime.MethodInfos.CustomMethodInvokerAction : MulticastDelegate {
    public CustomMethodInvokerAction(object object, IntPtr method);
    public virtual object Invoke(object thisObject, Object[] args, Type thisType);
    public virtual IAsyncResult BeginInvoke(object thisObject, Object[] args, Type thisType, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.MethodInfos.CustomMethodMapper : object {
    [ExtensionAttribute]
public static MethodInvoker GetCustomMethodInvokerIfNeeded(MethodBase methodBase);
    [ExtensionAttribute]
private static void AddConstructor(Dictionary`2<MethodBase, CustomMethodInvokerAction> map, Type declaringType, Type[] parameterTypes, CustomMethodInvokerAction action);
    [ExtensionAttribute]
private static void AddMethod(Dictionary`2<MethodBase, CustomMethodInvokerAction> map, Type declaringType, string name, Type[] parameterTypes, CustomMethodInvokerAction action);
}
internal class System.Reflection.Runtime.MethodInfos.EcmaFormat.EcmaFormatMethodCommon : ValueType {
    private EcmaFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private MethodDefinitionHandle _methodHandle;
    private RuntimeTypeInfo _contextTypeInfo;
    private MetadataReader _reader;
    private MethodDefinition _method;
    public bool IsGenericMethodDefinition { get; }
    public QSignatureTypeHandle[] QualifiedMethodSignature { get; }
    public EcmaFormatMethodCommon RuntimeMethodCommonOfUninstantiatedMethod { get; }
    public int GenericParameterCount { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeTypeInfo ContextTypeInfo { get; }
    public RuntimeTypeInfo DeclaringType { get; }
    public RuntimeNamedTypeInfo DefiningTypeInfo { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public MetadataReader Reader { get; }
    public MethodDefinitionHandle MethodHandle { get; }
    public IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    private QSignatureTypeHandle[] MethodSignature { get; }
    public EcmaFormatMethodCommon(MethodDefinitionHandle methodHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo);
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual MethodInvoker GetUncachedMethodInvoker(RuntimeTypeInfo[] methodArguments, MemberInfo exceptionPertainant);
    public sealed virtual QSignatureTypeHandle[] get_QualifiedMethodSignature();
    public sealed virtual EcmaFormatMethodCommon get_RuntimeMethodCommonOfUninstantiatedMethod();
    public sealed virtual void FillInMetadataDescribedParameters(VirtualRuntimeParameterInfoArray& result, QSignatureTypeHandle[] typeSignatures, MethodBase contextMethod, TypeContext typeContext);
    public sealed virtual int get_GenericParameterCount();
    public sealed virtual RuntimeTypeInfo[] GetGenericTypeParametersWithSpecifiedOwningMethod(RuntimeNamedMethodInfo`1<EcmaFormatMethodCommon> owningMethod);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual RuntimeTypeInfo get_ContextTypeInfo();
    public sealed virtual RuntimeTypeInfo get_DeclaringType();
    public sealed virtual RuntimeNamedTypeInfo get_DefiningTypeInfo();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual Module get_Module();
    public sealed virtual int get_MetadataToken();
    public sealed virtual RuntimeMethodHandle GetRuntimeMethodHandle(Type[] genericArgs);
    public RuntimeParameterInfo[] GetRuntimeParameters(MethodBase contextMethod, RuntimeTypeInfo[] methodTypeArguments, RuntimeParameterInfo& returnParameter);
    public sealed virtual string get_Name();
    public MetadataReader get_Reader();
    public MethodDefinitionHandle get_MethodHandle();
    public sealed virtual bool HasSameMetadataDefinitionAs(EcmaFormatMethodCommon other);
    public sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EcmaFormatMethodCommon other);
    public virtual int GetHashCode();
    private QSignatureTypeHandle[] get_MethodSignature();
}
[FlagsAttribute]
internal enum System.Reflection.Runtime.MethodInfos.InvokerOptions : Enum {
    public int value__;
    public static InvokerOptions None;
    public static InvokerOptions AllowNullThis;
    public static InvokerOptions DontWrapException;
}
internal interface System.Reflection.Runtime.MethodInfos.IRuntimeMethodCommon`1 {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeTypeInfo ContextTypeInfo { get; }
    public RuntimeTypeInfo DeclaringType { get; }
    public RuntimeNamedTypeInfo DefiningTypeInfo { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public QSignatureTypeHandle[] QualifiedMethodSignature { get; }
    public IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    public string Name { get; }
    public bool IsGenericMethodDefinition { get; }
    public int GenericParameterCount { get; }
    public TRuntimeMethodCommon RuntimeMethodCommonOfUninstantiatedMethod { get; }
    public int MetadataToken { get; }
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public abstract virtual RuntimeTypeInfo get_ContextTypeInfo();
    public abstract virtual RuntimeTypeInfo get_DeclaringType();
    public abstract virtual RuntimeNamedTypeInfo get_DefiningTypeInfo();
    public abstract virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual Module get_Module();
    public abstract virtual QSignatureTypeHandle[] get_QualifiedMethodSignature();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    public abstract virtual void FillInMetadataDescribedParameters(VirtualRuntimeParameterInfoArray& result, QSignatureTypeHandle[] parameterTypes, MethodBase contextMethod, TypeContext typeContext);
    public abstract virtual string get_Name();
    public abstract virtual MethodInvoker GetUncachedMethodInvoker(RuntimeTypeInfo[] methodArguments, MemberInfo exceptionPertainant);
    public abstract virtual bool get_IsGenericMethodDefinition();
    public abstract virtual int get_GenericParameterCount();
    public abstract virtual bool HasSameMetadataDefinitionAs(TRuntimeMethodCommon other);
    public abstract virtual TRuntimeMethodCommon get_RuntimeMethodCommonOfUninstantiatedMethod();
    public abstract virtual RuntimeTypeInfo[] GetGenericTypeParametersWithSpecifiedOwningMethod(RuntimeNamedMethodInfo`1<TRuntimeMethodCommon> owningMethod);
    public abstract virtual int get_MetadataToken();
    public abstract virtual RuntimeMethodHandle GetRuntimeMethodHandle(Type[] genericArgs);
}
internal class System.Reflection.Runtime.MethodInfos.NativeFormat.NativeFormatMethodCommon : ValueType {
    private NativeFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private MethodHandle _methodHandle;
    private RuntimeTypeInfo _contextTypeInfo;
    private MetadataReader _reader;
    private Method _method;
    public bool IsGenericMethodDefinition { get; }
    public QSignatureTypeHandle[] QualifiedMethodSignature { get; }
    public NativeFormatMethodCommon RuntimeMethodCommonOfUninstantiatedMethod { get; }
    public int GenericParameterCount { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeTypeInfo ContextTypeInfo { get; }
    public RuntimeTypeInfo DeclaringType { get; }
    public RuntimeNamedTypeInfo DefiningTypeInfo { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public MetadataReader Reader { get; }
    public MethodHandle MethodHandle { get; }
    public IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    private MethodSignature MethodSignature { get; }
    public NativeFormatMethodCommon(MethodHandle methodHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo);
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual MethodInvoker GetUncachedMethodInvoker(RuntimeTypeInfo[] methodArguments, MemberInfo exceptionPertainant);
    public sealed virtual QSignatureTypeHandle[] get_QualifiedMethodSignature();
    public sealed virtual NativeFormatMethodCommon get_RuntimeMethodCommonOfUninstantiatedMethod();
    public sealed virtual void FillInMetadataDescribedParameters(VirtualRuntimeParameterInfoArray& result, QSignatureTypeHandle[] typeSignatures, MethodBase contextMethod, TypeContext typeContext);
    public sealed virtual int get_GenericParameterCount();
    public sealed virtual RuntimeTypeInfo[] GetGenericTypeParametersWithSpecifiedOwningMethod(RuntimeNamedMethodInfo`1<NativeFormatMethodCommon> owningMethod);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual RuntimeTypeInfo get_ContextTypeInfo();
    public sealed virtual RuntimeTypeInfo get_DeclaringType();
    public sealed virtual RuntimeNamedTypeInfo get_DefiningTypeInfo();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual Module get_Module();
    public sealed virtual int get_MetadataToken();
    public sealed virtual RuntimeMethodHandle GetRuntimeMethodHandle(Type[] genericArgs);
    public RuntimeParameterInfo[] GetRuntimeParameters(MethodBase contextMethod, RuntimeTypeInfo[] methodTypeArguments, RuntimeParameterInfo& returnParameter);
    public sealed virtual string get_Name();
    public MetadataReader get_Reader();
    public MethodHandle get_MethodHandle();
    public sealed virtual bool HasSameMetadataDefinitionAs(NativeFormatMethodCommon other);
    public sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NativeFormatMethodCommon other);
    public virtual int GetHashCode();
    private MethodSignature get_MethodSignature();
}
internal class System.Reflection.Runtime.MethodInfos.OpenMethodInvoker : MethodInvoker {
    public IntPtr LdFtnResult { get; }
    protected sealed virtual object Invoke(object thisObject, Object[] arguments, BinderBundle binderBundle, bool wrapInTargetInvocationException);
    public sealed virtual Delegate CreateDelegate(RuntimeTypeHandle delegateType, object target, bool isStatic, bool isVirtual, bool isOpen);
    public sealed virtual IntPtr get_LdFtnResult();
}
internal class System.Reflection.Runtime.MethodInfos.RuntimeCLSIDNullaryConstructorInfo : RuntimeConstructorInfo {
    private RuntimeCLSIDTypeInfo _declaringType;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public string Name { get; }
    protected RuntimeParameterInfo[] RuntimeParameters { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    private RuntimeCLSIDNullaryConstructorInfo(RuntimeCLSIDTypeInfo declaringType);
    internal static RuntimeCLSIDNullaryConstructorInfo GetRuntimeCLSIDNullaryConstructorInfo(RuntimeCLSIDTypeInfo declaringType);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual int get_MetadataToken();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual string get_Name();
    protected sealed virtual RuntimeParameterInfo[] get_RuntimeParameters();
    public sealed virtual string ToString();
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
}
internal class System.Reflection.Runtime.MethodInfos.RuntimeConstructedGenericMethodInfo : RuntimeMethodInfo {
    private RuntimeNamedMethodInfo _genericMethodDefinition;
    private RuntimeTypeInfo[] _genericTypeArguments;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int GenericParameterCount { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public int MetadataToken { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    internal RuntimeTypeInfo RuntimeDeclaringType { get; }
    internal RuntimeTypeInfo[] RuntimeGenericArgumentsOrParameters { get; }
    internal string RuntimeName { get; }
    internal RuntimeMethodInfo WithReflectedTypeSetToDeclaringType { get; }
    private RuntimeConstructedGenericMethodInfo(RuntimeNamedMethodInfo genericMethodDefinition, RuntimeTypeInfo[] genericTypeArguments);
    internal static RuntimeMethodInfo GetRuntimeConstructedGenericMethodInfo(RuntimeNamedMethodInfo genericMethodDefinition, RuntimeTypeInfo[] genericTypeArguments);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual int get_GenericParameterCount();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual int get_MetadataToken();
    public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string ToString();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
    internal sealed virtual RuntimeTypeInfo get_RuntimeDeclaringType();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericArgumentsOrParameters();
    internal sealed virtual string get_RuntimeName();
    internal sealed virtual RuntimeParameterInfo[] GetRuntimeParameters(RuntimeMethodInfo contextMethod, RuntimeParameterInfo& returnParameter);
    internal sealed virtual RuntimeMethodInfo get_WithReflectedTypeSetToDeclaringType();
}
internal abstract class System.Reflection.Runtime.MethodInfos.RuntimeConstructorInfo : ConstructorInfo {
    private MethodInvoker modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodInvoker;
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    protected MethodInvoker MethodInvoker { get; }
    internal IntPtr LdFtnResult { get; }
    protected RuntimeParameterInfo[] RuntimeParameters { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual MethodImplAttributes GetMethodImplementationFlags();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public sealed virtual bool get_ContainsGenericParameters();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual Type get_DeclaringType();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual MethodBody GetMethodBody();
    public sealed virtual ParameterInfo[] GetParameters();
    public sealed virtual ParameterInfo[] GetParametersNoCopy();
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerGuidedStepThroughAttribute]
public sealed virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual MethodBase get_MetadataDefinitionMethod();
    public abstract virtual int get_MetadataToken();
    public sealed virtual Module get_Module();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public abstract virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual string get_Name();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public sealed virtual Type get_ReflectedType();
    public abstract virtual string ToString();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    protected MethodInvoker get_MethodInvoker();
    internal IntPtr get_LdFtnResult();
    protected abstract virtual RuntimeParameterInfo[] get_RuntimeParameters();
    protected abstract virtual MethodInvoker get_UncachedMethodInvoker();
}
internal class System.Reflection.Runtime.MethodInfos.RuntimeDummyMethodInfo : RuntimeNamedMethodInfo {
    public static RuntimeDummyMethodInfo Instance;
    public MethodAttributes Attributes { get; }
    public Type ReflectedType { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public int GenericParameterCount { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    internal RuntimeTypeInfo RuntimeDeclaringType { get; }
    internal string RuntimeName { get; }
    internal RuntimeTypeInfo[] RuntimeGenericArgumentsOrParameters { get; }
    internal RuntimeMethodInfo WithReflectedTypeSetToDeclaringType { get; }
    private static RuntimeDummyMethodInfo();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual string ToString();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual int get_GenericParameterCount();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual Module get_Module();
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual int get_MetadataToken();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
    internal sealed virtual RuntimeParameterInfo[] GetRuntimeParameters(RuntimeMethodInfo contextMethod, RuntimeParameterInfo& returnParameter);
    internal sealed virtual RuntimeTypeInfo get_RuntimeDeclaringType();
    internal sealed virtual string get_RuntimeName();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericArgumentsOrParameters();
    protected internal sealed virtual string ComputeToString(RuntimeMethodInfo contextMethod);
    internal sealed virtual MethodInvoker GetUncachedMethodInvoker(RuntimeTypeInfo[] methodArguments, MemberInfo exceptionPertainant);
    internal sealed virtual RuntimeMethodHandle GetRuntimeMethodHandle(Type[] genericArgs);
    internal sealed virtual RuntimeMethodInfo get_WithReflectedTypeSetToDeclaringType();
}
internal static class System.Reflection.Runtime.MethodInfos.RuntimeMethodHelpers : object {
    internal static RuntimeParameterInfo[] GetRuntimeParameters(TRuntimeMethodCommon& runtimeMethodCommon, MethodBase contextMethod, RuntimeTypeInfo[] methodTypeArguments, RuntimeParameterInfo& returnParameter);
    internal static string ComputeToString(TRuntimeMethodCommon& runtimeMethodCommon, MethodBase contextMethod, RuntimeTypeInfo[] methodTypeArguments);
    internal static string ComputeParametersString(RuntimeParameterInfo[] parameters);
    internal static string ComputeToString(MethodBase contextMethod, RuntimeTypeInfo[] methodTypeArguments, RuntimeParameterInfo[] parameters, RuntimeParameterInfo returnParameter);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal abstract class System.Reflection.Runtime.MethodInfos.RuntimeMethodInfo : MethodInfo {
    private RuntimeParameterInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyParameters;
    private RuntimeParameterInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyReturnParameter;
    private MethodInvoker modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodInvoker;
    private string _debugName;
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public int GenericParameterCount { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public int MetadataToken { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    private Type Internal.Reflection.Tracing.ITraceableTypeMember.ContainingType { get; }
    private string Internal.Reflection.Tracing.ITraceableTypeMember.MemberName { get; }
    internal RuntimeTypeInfo RuntimeDeclaringType { get; }
    internal string RuntimeName { get; }
    internal RuntimeMethodInfo WithReflectedTypeSetToDeclaringType { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    internal RuntimeTypeInfo[] RuntimeGenericArgumentsOrParameters { get; }
    internal RuntimeParameterInfo[] RuntimeParameters { get; }
    internal RuntimeParameterInfo RuntimeReturnParameter { get; }
    internal MethodInvoker MethodInvoker { get; }
    internal IntPtr LdFtnResult { get; }
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual MethodImplAttributes GetMethodImplementationFlags();
    public sealed virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public abstract virtual MethodAttributes get_Attributes();
    public abstract virtual CallingConventions get_CallingConvention();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    private Delegate CreateDelegateWorker(Type delegateType, object target, bool allowClosed);
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type get_DeclaringType();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public sealed virtual MethodInfo GetBaseDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public abstract virtual int get_GenericParameterCount();
    public abstract virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual MethodBody GetMethodBody();
    public sealed virtual ParameterInfo[] GetParameters();
    public sealed virtual ParameterInfo[] GetParametersNoCopy();
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    [DebuggerGuidedStepThroughAttribute]
public sealed virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual bool get_IsConstructedGenericMethod();
    public abstract virtual bool get_IsGenericMethod();
    public abstract virtual bool get_IsGenericMethodDefinition();
    public abstract virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodBase get_MetadataDefinitionMethod();
    public abstract virtual int get_MetadataToken();
    public abstract virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual Module get_Module();
    public sealed virtual string get_Name();
    public abstract virtual Type get_ReflectedType();
    public sealed virtual ParameterInfo get_ReturnParameter();
    public sealed virtual Type get_ReturnType();
    public abstract virtual string ToString();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    private sealed virtual override Type Internal.Reflection.Tracing.ITraceableTypeMember.get_ContainingType();
    private sealed virtual override string Internal.Reflection.Tracing.ITraceableTypeMember.get_MemberName();
    internal abstract virtual RuntimeTypeInfo get_RuntimeDeclaringType();
    internal abstract virtual string get_RuntimeName();
    internal abstract virtual RuntimeMethodInfo get_WithReflectedTypeSetToDeclaringType();
    protected abstract virtual MethodInvoker get_UncachedMethodInvoker();
    internal abstract virtual RuntimeTypeInfo[] get_RuntimeGenericArgumentsOrParameters();
    internal abstract virtual RuntimeParameterInfo[] GetRuntimeParameters(RuntimeMethodInfo contextMethod, RuntimeParameterInfo& returnParameter);
    internal RuntimeParameterInfo[] get_RuntimeParameters();
    internal RuntimeParameterInfo get_RuntimeReturnParameter();
    internal MethodInvoker get_MethodInvoker();
    internal IntPtr get_LdFtnResult();
    internal Delegate CreateDelegateNoThrowOnBindFailure(RuntimeTypeInfo runtimeDelegateType, object target, bool allowClosed);
    internal Delegate CreateDelegateWithoutSignatureValidation(Type delegateType, object target, bool isStatic, bool isOpen);
    private static bool IsAssignableFrom(ExecutionEnvironment executionEnvironment, Type dstType, Type srcType);
    protected RuntimeMethodInfo WithDebugName();
}
internal abstract class System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo : RuntimeMethodInfo {
    protected internal abstract virtual string ComputeToString(RuntimeMethodInfo contextMethod);
    internal abstract virtual MethodInvoker GetUncachedMethodInvoker(RuntimeTypeInfo[] methodArguments, MemberInfo exceptionPertainant);
    internal abstract virtual RuntimeMethodHandle GetRuntimeMethodHandle(Type[] methodArguments);
}
internal class System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo`1 : RuntimeNamedMethodInfo {
    private TRuntimeMethodCommon _common;
    private RuntimeTypeInfo _reflectedType;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public int GenericParameterCount { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    internal RuntimeTypeInfo[] RuntimeGenericArgumentsOrParameters { get; }
    internal RuntimeTypeInfo RuntimeDeclaringType { get; }
    internal string RuntimeName { get; }
    internal RuntimeMethodInfo WithReflectedTypeSetToDeclaringType { get; }
    private RuntimeTypeInfo[] GenericTypeParameters { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    private RuntimeNamedMethodInfo`1(TRuntimeMethodCommon common, RuntimeTypeInfo reflectedType);
    internal static RuntimeNamedMethodInfo`1<TRuntimeMethodCommon> GetRuntimeNamedMethodInfo(TRuntimeMethodCommon common, RuntimeTypeInfo reflectedType);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo`1/<get_CustomAttributes>d__7")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual int get_GenericParameterCount();
    public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual int get_MetadataToken();
    public sealed virtual string ToString();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    protected internal sealed virtual string ComputeToString(RuntimeMethodInfo contextMethod);
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericArgumentsOrParameters();
    internal sealed virtual RuntimeParameterInfo[] GetRuntimeParameters(RuntimeMethodInfo contextMethod, RuntimeParameterInfo& returnParameter);
    internal sealed virtual RuntimeTypeInfo get_RuntimeDeclaringType();
    internal sealed virtual string get_RuntimeName();
    internal sealed virtual RuntimeMethodInfo get_WithReflectedTypeSetToDeclaringType();
    private RuntimeTypeInfo[] get_GenericTypeParameters();
    internal sealed virtual MethodInvoker GetUncachedMethodInvoker(RuntimeTypeInfo[] methodArguments, MemberInfo exceptionPertainant);
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
    internal sealed virtual RuntimeMethodHandle GetRuntimeMethodHandle(Type[] genericArgs);
}
internal class System.Reflection.Runtime.MethodInfos.RuntimePlainConstructorInfo`1 : RuntimeConstructorInfo {
    private RuntimeParameterInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyParameters;
    private TRuntimeMethodCommon _common;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    protected RuntimeParameterInfo[] RuntimeParameters { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    private RuntimePlainConstructorInfo`1(TRuntimeMethodCommon common);
    internal static RuntimePlainConstructorInfo`1<TRuntimeMethodCommon> GetRuntimePlainConstructorInfo(TRuntimeMethodCommon common);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type get_DeclaringType();
    [DebuggerGuidedStepThroughAttribute]
public sealed virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual string get_Name();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual string ToString();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    protected sealed virtual RuntimeParameterInfo[] get_RuntimeParameters();
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
}
internal class System.Reflection.Runtime.MethodInfos.RuntimeSyntheticConstructorInfo : RuntimeConstructorInfo {
    private RuntimeParameterInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyParameters;
    private SyntheticMethodId _syntheticMethodId;
    private RuntimeArrayTypeInfo _declaringType;
    private RuntimeTypeInfo[] _runtimeParameterTypes;
    private InvokerOptions _options;
    private CustomMethodInvokerAction _action;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public int MetadataToken { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public string Name { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    protected RuntimeParameterInfo[] RuntimeParameters { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    private RuntimeSyntheticConstructorInfo(SyntheticMethodId syntheticMethodId, RuntimeArrayTypeInfo declaringType, RuntimeTypeInfo[] runtimeParameterTypes, InvokerOptions options, CustomMethodInvokerAction action);
    internal static RuntimeSyntheticConstructorInfo GetRuntimeSyntheticConstructorInfo(SyntheticMethodId syntheticMethodId, RuntimeArrayTypeInfo declaringType, RuntimeTypeInfo[] runtimeParameterTypes, InvokerOptions options, CustomMethodInvokerAction action);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual int get_MetadataToken();
    [DebuggerGuidedStepThroughAttribute]
public sealed virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual string get_Name();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual string ToString();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    protected sealed virtual RuntimeParameterInfo[] get_RuntimeParameters();
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
}
internal class System.Reflection.Runtime.MethodInfos.RuntimeSyntheticMethodInfo : RuntimeMethodInfo {
    private string _name;
    private SyntheticMethodId _syntheticMethodId;
    private RuntimeArrayTypeInfo _declaringType;
    private RuntimeTypeInfo[] _runtimeParameterTypes;
    private RuntimeTypeInfo _returnType;
    private InvokerOptions _options;
    private CustomMethodInvokerAction _action;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public int GenericParameterCount { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public Type ReflectedType { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    protected MethodInvoker UncachedMethodInvoker { get; }
    internal RuntimeTypeInfo[] RuntimeGenericArgumentsOrParameters { get; }
    internal RuntimeTypeInfo RuntimeDeclaringType { get; }
    internal string RuntimeName { get; }
    internal RuntimeMethodInfo WithReflectedTypeSetToDeclaringType { get; }
    private RuntimeSyntheticMethodInfo(SyntheticMethodId syntheticMethodId, string name, RuntimeArrayTypeInfo declaringType, RuntimeTypeInfo[] parameterTypes, RuntimeTypeInfo returnType, InvokerOptions options, CustomMethodInvokerAction action);
    internal static RuntimeMethodInfo GetRuntimeSyntheticMethodInfo(SyntheticMethodId syntheticMethodId, string name, RuntimeArrayTypeInfo declaringType, RuntimeTypeInfo[] runtimeParameterTypes, RuntimeTypeInfo returnType, InvokerOptions options, CustomMethodInvokerAction action);
    public sealed virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual int GetHashCode();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual int get_GenericParameterCount();
    public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public sealed virtual MethodBase get_MetadataDefinitionMethod();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    public sealed virtual Module get_Module();
    public sealed virtual int get_MetadataToken();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string ToString();
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    protected sealed virtual MethodInvoker get_UncachedMethodInvoker();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericArgumentsOrParameters();
    internal sealed virtual RuntimeTypeInfo get_RuntimeDeclaringType();
    internal sealed virtual string get_RuntimeName();
    internal sealed virtual RuntimeParameterInfo[] GetRuntimeParameters(RuntimeMethodInfo contextMethod, RuntimeParameterInfo& returnParameter);
    internal sealed virtual RuntimeMethodInfo get_WithReflectedTypeSetToDeclaringType();
}
internal enum System.Reflection.Runtime.MethodInfos.SyntheticMethodId : Enum {
    public int value__;
    public static SyntheticMethodId ArrayCtor;
    public static SyntheticMethodId ArrayMultiDimCtor;
    public static SyntheticMethodId ArrayGet;
    public static SyntheticMethodId ArraySet;
    public static SyntheticMethodId ArrayAddress;
    public static SyntheticMethodId ArrayCtorJagged;
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Runtime.MethodInfos.VirtualRuntimeParameterInfoArray : ValueType {
    [CompilerGeneratedAttribute]
private RuntimeParameterInfo <First>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeParameterInfo[] <Remainder>k__BackingField;
    public RuntimeParameterInfo Item { get; public set; }
    public RuntimeParameterInfo First { get; private set; }
    public RuntimeParameterInfo[] Remainder { get; }
    public VirtualRuntimeParameterInfoArray(int count);
    public RuntimeParameterInfo get_Item(int index);
    public void set_Item(int index, RuntimeParameterInfo value);
    [CompilerGeneratedAttribute]
public RuntimeParameterInfo get_First();
    [CompilerGeneratedAttribute]
private void set_First(RuntimeParameterInfo value);
    [CompilerGeneratedAttribute]
public RuntimeParameterInfo[] get_Remainder();
}
internal class System.Reflection.Runtime.Modules.EcmaFormat.EcmaFormatRuntimeModule : RuntimeModule {
    private EcmaFormatRuntimeAssembly _assembly;
    public Assembly Assembly { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    private EcmaFormatRuntimeModule(EcmaFormatRuntimeAssembly assembly);
    public sealed virtual Assembly get_Assembly();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual string get_Name();
    public sealed virtual int get_MetadataToken();
    public sealed virtual Guid get_ModuleVersionId();
    internal static RuntimeModule GetRuntimeModule(EcmaFormatRuntimeAssembly assembly);
}
internal class System.Reflection.Runtime.Modules.NativeFormat.NativeFormatRuntimeModule : RuntimeModule {
    private NativeFormatRuntimeAssembly _assembly;
    public Assembly Assembly { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    private NativeFormatRuntimeModule(NativeFormatRuntimeAssembly assembly);
    internal static RuntimeModule GetRuntimeModule(NativeFormatRuntimeAssembly assembly);
    public sealed virtual Assembly get_Assembly();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual string get_Name();
    public sealed virtual int get_MetadataToken();
    public sealed virtual Guid get_ModuleVersionId();
}
internal abstract class System.Reflection.Runtime.Modules.RuntimeModule : Module {
    public Assembly Assembly { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    public int MDStreamVersion { get; }
    public string ScopeName { get; }
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Assembly get_Assembly();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual string get_FullyQualifiedName();
    public abstract virtual string get_Name();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual int get_MetadataToken();
    public sealed virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public sealed virtual Type[] GetTypes();
    public abstract virtual Guid get_ModuleVersionId();
    public sealed virtual string ToString();
    public sealed virtual bool IsResource();
    public sealed virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public sealed virtual int get_MDStreamVersion();
    public sealed virtual string get_ScopeName();
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public sealed virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual Byte[] ResolveSignature(int metadataToken);
    public sealed virtual string ResolveString(int metadataToken);
    public sealed virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    protected sealed virtual ModuleHandle GetModuleHandleImpl();
}
internal class System.Reflection.Runtime.ParameterInfos.EcmaFormat.EcmaFormatMethodParameterInfo : RuntimeFatMethodParameterInfo {
    private MethodDefinitionHandle _methodHandle;
    private ParameterHandle _parameterHandle;
    private Parameter _parameter;
    private MetadataReader Reader { get; }
    public ParameterAttributes Attributes { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    private EcmaFormatMethodParameterInfo(MethodBase member, MethodDefinitionHandle methodHandle, int position, ParameterHandle parameterHandle, QSignatureTypeHandle qualifiedParameterTypeHandle, TypeContext typeContext);
    private MetadataReader get_Reader();
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual string get_Name();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    protected sealed virtual bool GetDefaultValueIfAvailable(bool raw, Object& defaultValue);
    internal static EcmaFormatMethodParameterInfo GetEcmaFormatMethodParameterInfo(MethodBase member, MethodDefinitionHandle methodHandle, int position, ParameterHandle parameterHandle, QSignatureTypeHandle qualifiedParameterType, TypeContext typeContext);
}
internal class System.Reflection.Runtime.ParameterInfos.NativeFormat.NativeFormatMethodParameterInfo : RuntimeFatMethodParameterInfo {
    private MethodHandle _methodHandle;
    private ParameterHandle _parameterHandle;
    private Parameter _parameter;
    private MetadataReader Reader { get; }
    public ParameterAttributes Attributes { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    private NativeFormatMethodParameterInfo(MethodBase member, MethodHandle methodHandle, int position, ParameterHandle parameterHandle, QSignatureTypeHandle qualifiedParameterTypeHandle, TypeContext typeContext);
    internal static NativeFormatMethodParameterInfo GetNativeFormatMethodParameterInfo(MethodBase member, MethodHandle methodHandle, int position, ParameterHandle parameterHandle, QSignatureTypeHandle qualifiedParameterType, TypeContext typeContext);
    private MetadataReader get_Reader();
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual string get_Name();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    protected sealed virtual bool GetDefaultValueIfAvailable(bool raw, Object& defaultValue);
}
internal abstract class System.Reflection.Runtime.ParameterInfos.RuntimeFatMethodParameterInfo : RuntimeMethodParameterInfo {
    private Tuple`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDefaultValueInfo;
    private Tuple`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawDefaultValueInfo;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    private Tuple`2<bool, object> DefaultValueInfo { get; }
    protected RuntimeFatMethodParameterInfo(MethodBase member, int position, QSignatureTypeHandle qualifiedParameterTypeHandle, TypeContext typeContext);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.ParameterInfos.RuntimeFatMethodParameterInfo/<get_CustomAttributes>d__2")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected abstract virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object get_DefaultValue();
    public sealed virtual object get_RawDefaultValue();
    protected abstract virtual bool GetDefaultValueIfAvailable(bool raw, Object& defaultValue);
    private Tuple`2<bool, object> get_DefaultValueInfo();
    private bool GetDefaultValueOrSentinel(bool raw, Object& defaultValue);
}
internal abstract class System.Reflection.Runtime.ParameterInfos.RuntimeMethodParameterInfo : RuntimeParameterInfo {
    protected QSignatureTypeHandle QualifiedParameterTypeHandle;
    private TypeContext _typeContext;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyParameterType;
    public Type ParameterType { get; }
    internal string ParameterTypeString { get; }
    protected RuntimeMethodParameterInfo(MethodBase member, int position, QSignatureTypeHandle qualifiedParameterTypeHandle, TypeContext typeContext);
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual Type get_ParameterType();
    internal sealed virtual string get_ParameterTypeString();
}
internal abstract class System.Reflection.Runtime.ParameterInfos.RuntimeParameterInfo : ParameterInfo {
    private MemberInfo _member;
    private int _position;
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public int MetadataToken { get; }
    public MemberInfo Member { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    internal string ParameterTypeString { get; }
    protected RuntimeParameterInfo(MemberInfo member, int position);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual ParameterAttributes get_Attributes();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual object get_DefaultValue();
    public abstract virtual object get_RawDefaultValue();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public abstract virtual Type[] GetOptionalCustomModifiers();
    public abstract virtual Type[] GetRequiredCustomModifiers();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual int get_MetadataToken();
    public sealed virtual MemberInfo get_Member();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ParameterType();
    public sealed virtual int get_Position();
    public sealed virtual string ToString();
    internal abstract virtual string get_ParameterTypeString();
}
internal class System.Reflection.Runtime.ParameterInfos.RuntimePropertyIndexParameterInfo : RuntimeParameterInfo {
    private RuntimeParameterInfo _backingParameter;
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    internal string ParameterTypeString { get; }
    public int MetadataToken { get; }
    private RuntimePropertyIndexParameterInfo(RuntimePropertyInfo member, RuntimeParameterInfo backingParameter);
    internal static RuntimePropertyIndexParameterInfo GetRuntimePropertyIndexParameterInfo(RuntimePropertyInfo member, RuntimeParameterInfo backingParameter);
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual object get_DefaultValue();
    public sealed virtual object get_RawDefaultValue();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual string get_Name();
    public sealed virtual Type get_ParameterType();
    internal sealed virtual string get_ParameterTypeString();
    public sealed virtual int get_MetadataToken();
}
internal class System.Reflection.Runtime.ParameterInfos.RuntimeSyntheticParameterInfo : RuntimeParameterInfo {
    private RuntimeTypeInfo _parameterType;
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int MetadataToken { get; }
    internal string ParameterTypeString { get; }
    private RuntimeSyntheticParameterInfo(MemberInfo memberInfo, int position, RuntimeTypeInfo parameterType);
    internal static RuntimeSyntheticParameterInfo GetRuntimeSyntheticParameterInfo(MemberInfo member, int position, RuntimeTypeInfo parameterType);
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual object get_DefaultValue();
    public sealed virtual object get_RawDefaultValue();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual string get_Name();
    public sealed virtual Type get_ParameterType();
    public sealed virtual int get_MetadataToken();
    internal sealed virtual string get_ParameterTypeString();
}
internal class System.Reflection.Runtime.ParameterInfos.RuntimeThinMethodParameterInfo : RuntimeMethodParameterInfo {
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    private RuntimeThinMethodParameterInfo(MethodBase member, int position, QSignatureTypeHandle qualifiedParameterTypeHandle, TypeContext typeContext);
    internal static RuntimeThinMethodParameterInfo GetRuntimeThinMethodParameterInfo(MethodBase member, int position, QSignatureTypeHandle qualifiedParameterType, TypeContext typeContext);
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual object get_DefaultValue();
    public sealed virtual object get_RawDefaultValue();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual string get_Name();
    public sealed virtual int get_MetadataToken();
}
[DebuggerDisplayAttribute("{_debugName}")]
internal class System.Reflection.Runtime.PropertyInfos.EcmaFormat.EcmaFormatRuntimePropertyInfo : RuntimePropertyInfo {
    private EcmaFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private PropertyDefinitionHandle _propertyHandle;
    private MetadataReader _reader;
    private PropertyDefinition _property;
    public PropertyAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    protected QSignatureTypeHandle PropertyTypeHandle { get; }
    protected string MetadataName { get; }
    protected RuntimeTypeInfo DefiningTypeInfo { get; }
    private EcmaFormatRuntimePropertyInfo(PropertyDefinitionHandle propertyHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    public sealed virtual PropertyAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual QSignatureTypeHandle get_PropertyTypeHandle();
    protected sealed virtual bool GetDefaultValueIfAny(bool raw, Object& defaultValue);
    protected sealed virtual RuntimeNamedMethodInfo GetPropertyMethod(PropertyMethodSemantics whichMethod);
    protected sealed virtual string get_MetadataName();
    protected sealed virtual RuntimeTypeInfo get_DefiningTypeInfo();
    internal static RuntimePropertyInfo GetRuntimePropertyInfo(PropertyDefinitionHandle propertyHandle, EcmaFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal class System.Reflection.Runtime.PropertyInfos.NativeFormat.NativeFormatRuntimePropertyInfo : RuntimePropertyInfo {
    private NativeFormatRuntimeNamedTypeInfo _definingTypeInfo;
    private PropertyHandle _propertyHandle;
    private MetadataReader _reader;
    private Property _property;
    public PropertyAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    protected QSignatureTypeHandle PropertyTypeHandle { get; }
    protected string MetadataName { get; }
    protected RuntimeTypeInfo DefiningTypeInfo { get; }
    private NativeFormatRuntimePropertyInfo(PropertyHandle propertyHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    internal static RuntimePropertyInfo GetRuntimePropertyInfo(PropertyHandle propertyHandle, NativeFormatRuntimeNamedTypeInfo definingTypeInfo, RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    public sealed virtual PropertyAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual QSignatureTypeHandle get_PropertyTypeHandle();
    protected sealed virtual bool GetDefaultValueIfAny(bool raw, Object& defaultValue);
    protected sealed virtual RuntimeNamedMethodInfo GetPropertyMethod(PropertyMethodSemantics whichMethod);
    protected sealed virtual string get_MetadataName();
    protected sealed virtual RuntimeTypeInfo get_DefiningTypeInfo();
}
[DebuggerDisplayAttribute("{_debugName}")]
internal abstract class System.Reflection.Runtime.PropertyInfos.RuntimePropertyInfo : PropertyInfo {
    protected RuntimeTypeInfo ContextTypeInfo;
    protected RuntimeTypeInfo _reflectedType;
    private MethodInvoker modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGetterInvoker;
    private MethodInvoker modreq(System.Runtime.CompilerServices.IsVolatile) _lazySetterInvoker;
    private RuntimeNamedMethodInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGetter;
    private RuntimeNamedMethodInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazySetter;
    private ParameterInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIndexParameters;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPropertyType;
    private string _debugName;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public MethodInfo GetMethod { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public MethodInfo SetMethod { get; }
    private string Internal.Reflection.Tracing.ITraceableTypeMember.MemberName { get; }
    private Type Internal.Reflection.Tracing.ITraceableTypeMember.ContainingType { get; }
    private RuntimeNamedMethodInfo Getter { get; }
    private RuntimeNamedMethodInfo Setter { get; }
    public PropertyAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    protected QSignatureTypeHandle PropertyTypeHandle { get; }
    protected string MetadataName { get; }
    protected RuntimeTypeInfo DefiningTypeInfo { get; }
    protected RuntimePropertyInfo(RuntimeTypeInfo contextTypeInfo, RuntimeTypeInfo reflectedType);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual MethodInfo GetGetMethod(bool nonPublic);
    public sealed virtual MethodInfo GetSetMethod(bool nonPublic);
    public sealed virtual MethodInfo[] GetAccessors(bool nonPublic);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual ParameterInfo[] GetIndexParameters();
    public sealed virtual MethodInfo get_GetMethod();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Module get_Module();
    public sealed virtual string get_Name();
    public sealed virtual Type get_PropertyType();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual MethodInfo get_SetMethod();
    public sealed virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public sealed virtual string ToString();
    private sealed virtual override string Internal.Reflection.Tracing.ITraceableTypeMember.get_MemberName();
    private sealed virtual override Type Internal.Reflection.Tracing.ITraceableTypeMember.get_ContainingType();
    private RuntimeNamedMethodInfo get_Getter();
    private RuntimeNamedMethodInfo get_Setter();
    protected RuntimePropertyInfo WithDebugName();
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual int get_MetadataToken();
    public sealed virtual object GetConstantValue();
    public sealed virtual object GetRawConstantValue();
    protected abstract virtual bool GetDefaultValueIfAny(bool raw, Object& defaultValue);
    protected abstract virtual QSignatureTypeHandle get_PropertyTypeHandle();
    protected abstract virtual RuntimeNamedMethodInfo GetPropertyMethod(PropertyMethodSemantics whichMethod);
    protected abstract virtual string get_MetadataName();
    protected abstract virtual RuntimeTypeInfo get_DefiningTypeInfo();
    private object GetConstantValue(bool raw);
}
internal class System.Reflection.Runtime.ReflectionTypeProvider : object {
    private bool _throwOnError;
    private Exception _exceptionResult;
    public bool ExceptionOccurred { get; }
    public Exception ExceptionResult { get; public set; }
    public ReflectionTypeProvider(bool throwOnError);
    public bool get_ExceptionOccurred();
    public Exception get_ExceptionResult();
    public void set_ExceptionResult(Exception value);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ICustomAttributeTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetSystemType();
    private sealed virtual override bool System.Reflection.Metadata.ICustomAttributeTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.IsSystemType(RuntimeTypeInfo type);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ICustomAttributeTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetTypeFromSerializedName(string name);
    private sealed virtual override PrimitiveTypeCode System.Reflection.Metadata.ICustomAttributeTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetUnderlyingEnumType(RuntimeTypeInfo type);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISimpleTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetPrimitiveType(PrimitiveTypeCode primitiveCode);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISZArrayTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetSZArrayType(RuntimeTypeInfo elementType);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISimpleTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISimpleTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISignatureTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo,System.Reflection.Runtime.General.TypeContext>.GetTypeFromSpecification(MetadataReader reader, TypeContext typeContext, TypeSpecificationHandle handle, byte rawTypeKind);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISignatureTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo,System.Reflection.Runtime.General.TypeContext>.GetFunctionPointerType(MethodSignature`1<RuntimeTypeInfo> signature);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISignatureTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo,System.Reflection.Runtime.General.TypeContext>.GetGenericTypeParameter(TypeContext typeContext, int parameter);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISignatureTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo,System.Reflection.Runtime.General.TypeContext>.GetGenericMethodParameter(TypeContext typeContext, int parameter);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISignatureTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo,System.Reflection.Runtime.General.TypeContext>.GetModifiedType(RuntimeTypeInfo modifier, RuntimeTypeInfo unmodifiedType, bool isRequired);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.ISignatureTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo,System.Reflection.Runtime.General.TypeContext>.GetPinnedType(RuntimeTypeInfo elementType);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.IConstructedTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetGenericInstantiation(RuntimeTypeInfo genericType, ImmutableArray`1<RuntimeTypeInfo> typeArguments);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.IConstructedTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetArrayType(RuntimeTypeInfo elementType, ArrayShape shape);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.IConstructedTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetByReferenceType(RuntimeTypeInfo elementType);
    private sealed virtual override RuntimeTypeInfo System.Reflection.Metadata.IConstructedTypeProvider<System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo>.GetPointerType(RuntimeTypeInfo elementType);
}
[EventSourceAttribute]
internal class System.Reflection.Runtime.Tracing.ReflectionEventSource : EventSource {
    public static ReflectionEventSource Log;
    public static bool IsInitialized { get; }
    private static ReflectionEventSource();
    public static bool get_IsInitialized();
    [EventAttribute("1")]
public void TypeInfo_CustomAttributes(string typeName);
    [EventAttribute("2")]
public void TypeInfo_Name(string typeName);
    [EventAttribute("3")]
public void TypeInfo_BaseType(string typeName);
    [EventAttribute("4")]
public void TypeInfo_DeclaredConstructors(string typeName);
    [EventAttribute("5")]
public void TypeInfo_DeclaredEvents(string typeName);
    [EventAttribute("6")]
public void TypeInfo_DeclaredFields(string typeName);
    [EventAttribute("7")]
public void TypeInfo_DeclaredMembers(string typeName);
    [EventAttribute("8")]
public void TypeInfo_DeclaredMethods(string typeName);
    [EventAttribute("9")]
public void TypeInfo_DeclaredNestedTypes(string typeName);
    [EventAttribute("10")]
public void TypeInfo_DeclaredProperties(string typeName);
    [EventAttribute("11")]
public void TypeInfo_DeclaringMethod(string typeName);
    [EventAttribute("12")]
public void TypeInfo_FullName(string typeName);
    [EventAttribute("13")]
public void TypeInfo_Namespace(string typeName);
    [EventAttribute("14")]
public void TypeInfo_GetDeclaredEvent(string typeName, string eventName);
    [EventAttribute("15")]
public void TypeInfo_GetDeclaredField(string typeName, string fieldName);
    [EventAttribute("16")]
public void TypeInfo_GetDeclaredMethod(string typeName, string methodName);
    [EventAttribute("17")]
public void TypeInfo_GetDeclaredProperty(string typeName, string propertyName);
    [EventAttribute("18")]
public void TypeInfo_MakeArrayType(string typeName);
    [EventAttribute("19")]
public void TypeInfo_MakeByRefType(string typeName);
    [EventAttribute("20")]
public void TypeInfo_MakeGenericType(string typeName, string typeArguments);
    [EventAttribute("21")]
public void TypeInfo_MakePointerType(string typeName);
    [EventAttribute("22")]
public void Assembly_DefinedTypes(string assemblyName);
    [EventAttribute("23")]
public void Assembly_GetType(string assemblyName, string typeName);
    [EventAttribute("24")]
public void Assembly_CustomAttributes(string assemblyName);
    [EventAttribute("25")]
public void Assembly_FullName(string assemblyName);
    [EventAttribute("26")]
public void Assembly_GetName(string assemblyName);
    [EventAttribute("27")]
public void CustomAttributeData_ConstructorArguments(string caName);
    [EventAttribute("28")]
public void CustomAttributeData_NamedArguments(string caName);
    [EventAttribute("29")]
public void EventInfo_AddMethod(string typeName, string eventName);
    [EventAttribute("30")]
public void EventInfo_RaiseMethod(string typeName, string eventName);
    [EventAttribute("31")]
public void EventInfo_RemoveMethod(string typeName, string eventName);
    [EventAttribute("32")]
public void EventInfo_CustomAttributes(string typeName, string eventName);
    [EventAttribute("33")]
public void EventInfo_Name(string typeName, string eventName);
    [EventAttribute("34")]
public void EventInfo_DeclaringType(string typeName, string eventName);
    [EventAttribute("35")]
public void FieldInfo_SetValue(string typeName, string fieldName);
    [EventAttribute("36")]
public void FieldInfo_GetValue(string typeName, string fieldName);
    [EventAttribute("37")]
public void FieldInfo_CustomAttributes(string typeName, string fieldName);
    [EventAttribute("38")]
public void FieldInfo_Name(string typeName, string fieldName);
    [EventAttribute("39")]
public void FieldInfo_DeclaringType(string typeName, string fieldName);
    [EventAttribute("40")]
public void MethodBase_CustomAttributes(string typeName, string methodName);
    [EventAttribute("41")]
public void MethodBase_Name(string typeName, string methodName);
    [EventAttribute("42")]
public void MethodBase_DeclaringType(string typeName, string methodName);
    [EventAttribute("43")]
public void MethodBase_GetParameters(string typeName, string methodName);
    [EventAttribute("44")]
public void MethodBase_Invoke(string typeName, string methodName);
    [EventAttribute("45")]
public void MethodInfo_ReturnParameter(string typeName, string methodName);
    [EventAttribute("46")]
public void MethodInfo_ReturnType(string typeName, string methodName);
    [EventAttribute("47")]
public void MethodInfo_MakeGenericMethod(string typeName, string methodName, string typeArguments);
    [EventAttribute("48")]
public void MethodInfo_CreateDelegate(string typeName, string methodName, string delegateTypeName);
    [EventAttribute("49")]
public void PropertyInfo_GetValue(string typeName, string propertyName);
    [EventAttribute("50")]
public void PropertyInfo_SetValue(string typeName, string propertyName);
    [EventAttribute("51")]
public void PropertyInfo_GetMethod(string typeName, string propertyName);
    [EventAttribute("52")]
public void PropertyInfo_SetMethod(string typeName, string propertyName);
    [EventAttribute("53")]
public void PropertyInfo_GetConstantValue(string typeName, string propertyName);
    [EventAttribute("54")]
public void PropertyInfo_PropertyType(string typeName, string propertyName);
    [EventAttribute("55")]
public void PropertyInfo_CustomAttributes(string typeName, string propertyName);
    [EventAttribute("56")]
public void PropertyInfo_Name(string typeName, string propertyName);
    [EventAttribute("57")]
public void PropertyInfo_DeclaringType(string typeName, string propertyName);
    [EventAttribute("58")]
public void TypeInfo_AssemblyQualifiedName(string typeName);
}
internal abstract class System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeGenericParameterTypeInfo : RuntimeGenericParameterTypeInfo {
    [CompilerGeneratedAttribute]
private GenericParameterHandle <GenericParameterHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReader <Reader>k__BackingField;
    private GenericParameter _genericParameter;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int MetadataToken { get; }
    protected GenericParameterHandle GenericParameterHandle { get; }
    protected MetadataReader Reader { get; }
    protected QTypeDefRefOrSpec[] Constraints { get; }
    protected EcmaFormatRuntimeGenericParameterTypeInfo(MetadataReader reader, GenericParameterHandle genericParameterHandle, GenericParameter genericParameter);
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual int InternalGetHashCode();
    [CompilerGeneratedAttribute]
protected GenericParameterHandle get_GenericParameterHandle();
    [CompilerGeneratedAttribute]
protected MetadataReader get_Reader();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    protected sealed virtual QTypeDefRefOrSpec[] get_Constraints();
}
internal class System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeGenericParameterTypeInfoForMethods : EcmaFormatRuntimeGenericParameterTypeInfo {
    private RuntimeNamedMethodInfo _declaringRuntimeNamedMethodInfo;
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public MethodBase DeclaringMethod { get; }
    public UnificationKey Key { get; }
    internal Type InternalDeclaringType { get; }
    internal TypeContext TypeContext { get; }
    private EcmaFormatRuntimeGenericParameterTypeInfoForMethods(MetadataReader reader, GenericParameterHandle genericParameterHandle, RuntimeNamedMethodInfo declaringRuntimeNamedMethodInfo);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual void PrepareKey();
    public sealed virtual UnificationKey get_Key();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual TypeContext get_TypeContext();
    internal static EcmaFormatRuntimeGenericParameterTypeInfoForMethods GetRuntimeGenericParameterTypeInfoForMethods(RuntimeNamedMethodInfo methodOwner, MetadataReader reader, GenericParameterHandle genericParameterHandle);
}
internal class System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeGenericParameterTypeInfoForTypes : EcmaFormatRuntimeGenericParameterTypeInfo {
    private RuntimeTypeDefinitionTypeInfo _declaringType;
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public MethodBase DeclaringMethod { get; }
    internal Type InternalDeclaringType { get; }
    internal TypeContext TypeContext { get; }
    private EcmaFormatRuntimeGenericParameterTypeInfoForTypes(MetadataReader reader, GenericParameterHandle genericParameterHandle, RuntimeTypeDefinitionTypeInfo declaringType);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual MethodBase get_DeclaringMethod();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual TypeContext get_TypeContext();
    internal static EcmaFormatRuntimeGenericParameterTypeInfoForTypes GetRuntimeGenericParameterTypeInfoForTypes(EcmaFormatRuntimeNamedTypeInfo typeOwner, GenericParameterHandle genericParameterHandle);
}
internal class System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo : RuntimeNamedTypeInfo {
    private MetadataReader _reader;
    private TypeDefinitionHandle _typeDefinitionHandle;
    private TypeDefinition _typeDefinition;
    public Assembly Assembly { get; }
    public bool IsGenericTypeDefinition { get; }
    public string Namespace { get; }
    public int MetadataToken { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    internal RuntimeTypeInfo[] RuntimeGenericTypeParameters { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal MetadataReader Reader { get; }
    internal TypeDefinitionHandle TypeDefinitionHandle { get; }
    internal EventDefinitionHandleCollection DeclaredEventHandles { get; }
    internal FieldDefinitionHandleCollection DeclaredFieldHandles { get; }
    internal MethodDefinitionHandleCollection DeclaredMethodAndConstructorHandles { get; }
    internal PropertyDefinitionHandleCollection DeclaredPropertyHandles { get; }
    internal string TraceableTypeName { get; }
    internal QTypeDefRefOrSpec TypeDefinitionQHandle { get; }
    private EcmaFormatRuntimeNamedTypeInfo(MetadataReader reader, TypeDefinitionHandle typeDefinitionHandle, RuntimeTypeHandle typeHandle);
    public sealed virtual Assembly get_Assembly();
    protected sealed virtual Nullable`1<Guid> ComputeGuidFromCustomAttributes();
    protected sealed virtual void GetPackSizeAndSize(Int32& packSize, Int32& size);
    public sealed virtual bool get_IsGenericTypeDefinition();
    public sealed virtual string get_Namespace();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual int get_MetadataToken();
    public sealed virtual string ToString();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual string get_InternalFullNameOfAssembly();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    protected sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericTypeParameters();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal MetadataReader get_Reader();
    internal TypeDefinitionHandle get_TypeDefinitionHandle();
    internal EventDefinitionHandleCollection get_DeclaredEventHandles();
    internal FieldDefinitionHandleCollection get_DeclaredFieldHandles();
    internal MethodDefinitionHandleCollection get_DeclaredMethodAndConstructorHandles();
    internal PropertyDefinitionHandleCollection get_DeclaredPropertyHandles();
    public sealed virtual bool Equals(EcmaFormatRuntimeNamedTypeInfo other);
    internal sealed virtual string get_TraceableTypeName();
    internal sealed virtual QTypeDefRefOrSpec get_TypeDefinitionQHandle();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo/<CoreGetDeclaredConstructors>d__49")]
internal sealed virtual IEnumerable`1<ConstructorInfo> CoreGetDeclaredConstructors(NameFilter optionalNameFilter, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo/<CoreGetDeclaredMethods>d__50")]
internal sealed virtual IEnumerable`1<MethodInfo> CoreGetDeclaredMethods(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo/<CoreGetDeclaredEvents>d__51")]
internal sealed virtual IEnumerable`1<EventInfo> CoreGetDeclaredEvents(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo/<CoreGetDeclaredFields>d__52")]
internal sealed virtual IEnumerable`1<FieldInfo> CoreGetDeclaredFields(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo/<CoreGetDeclaredProperties>d__53")]
internal sealed virtual IEnumerable`1<PropertyInfo> CoreGetDeclaredProperties(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.EcmaFormat.EcmaFormatRuntimeNamedTypeInfo/<CoreGetDeclaredNestedTypes>d__54")]
internal sealed virtual IEnumerable`1<Type> CoreGetDeclaredNestedTypes(NameFilter optionalNameFilter);
    internal static EcmaFormatRuntimeNamedTypeInfo GetRuntimeNamedTypeInfo(MetadataReader metadataReader, TypeDefinitionHandle typeDefHandle, RuntimeTypeHandle precomputedTypeHandle);
}
internal abstract class System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeGenericParameterTypeInfo : RuntimeGenericParameterTypeInfo {
    [CompilerGeneratedAttribute]
private GenericParameterHandle <GenericParameterHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReader <Reader>k__BackingField;
    private GenericParameter _genericParameter;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int MetadataToken { get; }
    protected GenericParameterHandle GenericParameterHandle { get; }
    protected MetadataReader Reader { get; }
    protected QTypeDefRefOrSpec[] Constraints { get; }
    protected NativeFormatRuntimeGenericParameterTypeInfo(MetadataReader reader, GenericParameterHandle genericParameterHandle, GenericParameter genericParameter);
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual int InternalGetHashCode();
    [CompilerGeneratedAttribute]
protected GenericParameterHandle get_GenericParameterHandle();
    [CompilerGeneratedAttribute]
protected MetadataReader get_Reader();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    protected sealed virtual QTypeDefRefOrSpec[] get_Constraints();
}
internal class System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeGenericParameterTypeInfoForMethods : NativeFormatRuntimeGenericParameterTypeInfo {
    private RuntimeNamedMethodInfo _declaringRuntimeNamedMethodInfo;
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public MethodBase DeclaringMethod { get; }
    public UnificationKey Key { get; }
    internal Type InternalDeclaringType { get; }
    internal TypeContext TypeContext { get; }
    private NativeFormatRuntimeGenericParameterTypeInfoForMethods(MetadataReader reader, GenericParameterHandle genericParameterHandle, RuntimeNamedMethodInfo declaringRuntimeNamedMethodInfo);
    internal static NativeFormatRuntimeGenericParameterTypeInfoForMethods GetRuntimeGenericParameterTypeInfoForMethods(RuntimeNamedMethodInfo methodOwner, MetadataReader reader, GenericParameterHandle genericParameterHandle);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual void PrepareKey();
    public sealed virtual UnificationKey get_Key();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual TypeContext get_TypeContext();
}
internal class System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeGenericParameterTypeInfoForTypes : NativeFormatRuntimeGenericParameterTypeInfo {
    private RuntimeTypeDefinitionTypeInfo _declaringType;
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public MethodBase DeclaringMethod { get; }
    internal Type InternalDeclaringType { get; }
    internal TypeContext TypeContext { get; }
    private NativeFormatRuntimeGenericParameterTypeInfoForTypes(MetadataReader reader, GenericParameterHandle genericParameterHandle, RuntimeTypeDefinitionTypeInfo declaringType);
    internal static NativeFormatRuntimeGenericParameterTypeInfoForTypes GetRuntimeGenericParameterTypeInfoForTypes(NativeFormatRuntimeNamedTypeInfo typeOwner, GenericParameterHandle genericParameterHandle);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual MethodBase get_DeclaringMethod();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual TypeContext get_TypeContext();
}
internal class System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo : RuntimeNamedTypeInfo {
    private MetadataReader _reader;
    private TypeDefinitionHandle _typeDefinitionHandle;
    private TypeDefinition _typeDefinition;
    private NamespaceChain modreq(System.Runtime.CompilerServices.IsVolatile) _lazyNamespaceChain;
    public Assembly Assembly { get; }
    public bool IsGenericTypeDefinition { get; }
    public string Namespace { get; }
    public int MetadataToken { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    internal RuntimeTypeInfo[] RuntimeGenericTypeParameters { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal MetadataReader Reader { get; }
    internal TypeDefinitionHandle TypeDefinitionHandle { get; }
    internal EventHandleCollection DeclaredEventHandles { get; }
    internal FieldHandleCollection DeclaredFieldHandles { get; }
    internal MethodHandleCollection DeclaredMethodAndConstructorHandles { get; }
    internal PropertyHandleCollection DeclaredPropertyHandles { get; }
    internal string TraceableTypeName { get; }
    internal QTypeDefRefOrSpec TypeDefinitionQHandle { get; }
    private NamespaceChain NamespaceChain { get; }
    private NativeFormatRuntimeNamedTypeInfo(MetadataReader reader, TypeDefinitionHandle typeDefinitionHandle, RuntimeTypeHandle typeHandle);
    internal static NativeFormatRuntimeNamedTypeInfo GetRuntimeNamedTypeInfo(MetadataReader metadataReader, TypeDefinitionHandle typeDefHandle, RuntimeTypeHandle precomputedTypeHandle);
    public sealed virtual Assembly get_Assembly();
    protected sealed virtual Nullable`1<Guid> ComputeGuidFromCustomAttributes();
    protected sealed virtual void GetPackSizeAndSize(Int32& packSize, Int32& size);
    public sealed virtual bool get_IsGenericTypeDefinition();
    public sealed virtual string get_Namespace();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual int get_MetadataToken();
    public sealed virtual string ToString();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual string get_InternalFullNameOfAssembly();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    protected sealed virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericTypeParameters();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal MetadataReader get_Reader();
    internal TypeDefinitionHandle get_TypeDefinitionHandle();
    internal EventHandleCollection get_DeclaredEventHandles();
    internal FieldHandleCollection get_DeclaredFieldHandles();
    internal MethodHandleCollection get_DeclaredMethodAndConstructorHandles();
    internal PropertyHandleCollection get_DeclaredPropertyHandles();
    public sealed virtual bool Equals(NativeFormatRuntimeNamedTypeInfo other);
    internal sealed virtual string get_TraceableTypeName();
    internal sealed virtual QTypeDefRefOrSpec get_TypeDefinitionQHandle();
    private NamespaceChain get_NamespaceChain();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo/<CoreGetDeclaredConstructors>d__54")]
internal sealed virtual IEnumerable`1<ConstructorInfo> CoreGetDeclaredConstructors(NameFilter optionalNameFilter, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo/<CoreGetDeclaredMethods>d__55")]
internal sealed virtual IEnumerable`1<MethodInfo> CoreGetDeclaredMethods(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo/<CoreGetDeclaredEvents>d__56")]
internal sealed virtual IEnumerable`1<EventInfo> CoreGetDeclaredEvents(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo/<CoreGetDeclaredFields>d__57")]
internal sealed virtual IEnumerable`1<FieldInfo> CoreGetDeclaredFields(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo/<CoreGetDeclaredProperties>d__58")]
internal sealed virtual IEnumerable`1<PropertyInfo> CoreGetDeclaredProperties(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.NativeFormat.NativeFormatRuntimeNamedTypeInfo/<CoreGetDeclaredNestedTypes>d__59")]
internal sealed virtual IEnumerable`1<Type> CoreGetDeclaredNestedTypes(NameFilter optionalNameFilter);
}
internal class System.Reflection.Runtime.TypeInfos.RuntimeArrayTypeInfo : RuntimeHasElementTypeInfo {
    private int _rank;
    private bool _multiDim;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    internal IEnumerable`1<RuntimeConstructorInfo> SyntheticConstructors { get; }
    internal IEnumerable`1<RuntimeMethodInfo> SyntheticMethods { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal TypeContext TypeContext { get; }
    protected string Suffix { get; }
    private RuntimeTypeInfo TypeDefInfoProjectionForArrays { get; }
    private RuntimeArrayTypeInfo(UnificationKey key, bool multiDim, int rank);
    internal static RuntimeArrayTypeInfo GetArrayTypeInfo(RuntimeTypeInfo elementType, bool multiDim, int rank);
    internal static RuntimeArrayTypeInfo GetArrayTypeInfo(RuntimeTypeInfo elementType, bool multiDim, int rank, RuntimeTypeHandle precomputedTypeHandle);
    private static RuntimeTypeHandle GetRuntimeTypeHandleIfAny(RuntimeTypeInfo elementType, bool multiDim, int rank);
    private static void ValidateElementType(RuntimeTypeInfo elementType, RuntimeTypeHandle typeHandle, bool multiDim, int rank);
    public sealed virtual int GetArrayRank();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.RuntimeArrayTypeInfo/<get_SyntheticConstructors>d__18")]
internal sealed virtual IEnumerable`1<RuntimeConstructorInfo> get_SyntheticConstructors();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.RuntimeArrayTypeInfo/<get_SyntheticMethods>d__20")]
internal sealed virtual IEnumerable`1<RuntimeMethodInfo> get_SyntheticMethods();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal sealed virtual TypeContext get_TypeContext();
    protected sealed virtual string get_Suffix();
    private RuntimeTypeInfo get_TypeDefInfoProjectionForArrays();
    private Array CreateJaggedArray(RuntimeTypeInfo arrayType, Int32[] lengths, int index);
}
internal class System.Reflection.Runtime.TypeInfos.RuntimeBlockedTypeInfo : RuntimeTypeDefinitionTypeInfo {
    private RuntimeTypeHandle _typeHandle;
    private bool _isGenericTypeDefinition;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGeneratedName;
    public Assembly Assembly { get; }
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public bool IsGenericTypeDefinition { get; }
    public string Namespace { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public int MetadataToken { get; }
    internal RuntimeNamedTypeInfo AnchoringTypeDefinitionForDeclaredMembers { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal RuntimeTypeInfo[] RuntimeGenericTypeParameters { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal TypeContext TypeContext { get; }
    private string GeneratedName { get; }
    private RuntimeBlockedTypeInfo(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    internal static RuntimeBlockedTypeInfo GetRuntimeBlockedTypeInfo(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    public sealed virtual Assembly get_Assembly();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual string get_FullName();
    public sealed virtual Guid get_GUID();
    public sealed virtual bool get_IsGenericTypeDefinition();
    public sealed virtual string get_Namespace();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual string ToString();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual RuntimeNamedTypeInfo get_AnchoringTypeDefinitionForDeclaredMembers();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericTypeParameters();
    internal sealed virtual Type get_InternalDeclaringType();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal sealed virtual string get_InternalFullNameOfAssembly();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal sealed virtual TypeContext get_TypeContext();
    private string get_GeneratedName();
    internal sealed virtual IEnumerable`1<Type> CoreGetDeclaredNestedTypes(NameFilter optionalNameFilter);
}
internal class System.Reflection.Runtime.TypeInfos.RuntimeByRefTypeInfo : RuntimeHasElementTypeInfo {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    private RuntimeByRefTypeInfo(UnificationKey key);
    internal static RuntimeByRefTypeInfo GetByRefTypeInfo(RuntimeTypeInfo elementType);
    internal static RuntimeByRefTypeInfo GetByRefTypeInfo(RuntimeTypeInfo elementType, RuntimeTypeHandle precomputedTypeHandle);
    private static RuntimeTypeHandle GetRuntimeTypeHandleIfAny(RuntimeTypeInfo elementType);
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.Runtime.TypeInfos.RuntimeCLSIDTypeInfo : RuntimeTypeDefinitionTypeInfo {
    private UnificationKey _key;
    private RuntimeConstructorInfo[] _constructors;
    public Assembly Assembly { get; }
    public bool ContainsGenericParameters { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public bool IsGenericTypeDefinition { get; }
    public int MetadataToken { get; }
    public string Namespace { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    internal Type BaseTypeWithoutTheGenericParameterQuirk { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal IEnumerable`1<RuntimeConstructorInfo> SyntheticConstructors { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal string Server { get; }
    private UnificationKey System.Collections.Concurrent.IKeyedItem<System.Reflection.Runtime.TypeInfos.RuntimeCLSIDTypeInfo.UnificationKey>.Key { get; }
    private RuntimeCLSIDTypeInfo(Guid clsid, string server);
    public static RuntimeCLSIDTypeInfo GetRuntimeCLSIDTypeInfo(Guid clsid, string server);
    public sealed virtual Assembly get_Assembly();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual string get_FullName();
    public sealed virtual Guid get_GUID();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    public sealed virtual bool get_IsGenericTypeDefinition();
    public sealed virtual int get_MetadataToken();
    public sealed virtual string get_Namespace();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual string ToString();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual Type get_BaseTypeWithoutTheGenericParameterQuirk();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual string get_InternalFullNameOfAssembly();
    internal sealed virtual IEnumerable`1<RuntimeConstructorInfo> get_SyntheticConstructors();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal string get_Server();
    private sealed virtual override void System.Collections.Concurrent.IKeyedItem<System.Reflection.Runtime.TypeInfos.RuntimeCLSIDTypeInfo.UnificationKey>.PrepareKey();
    private sealed virtual override UnificationKey System.Collections.Concurrent.IKeyedItem<System.Reflection.Runtime.TypeInfos.RuntimeCLSIDTypeInfo.UnificationKey>.get_Key();
}
internal class System.Reflection.Runtime.TypeInfos.RuntimeConstructedGenericTypeInfo : RuntimeTypeInfo {
    private UnificationKey _key;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public UnificationKey Key { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public bool ContainsGenericParameters { get; }
    public string Namespace { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public int MetadataToken { get; }
    internal RuntimeNamedTypeInfo AnchoringTypeDefinitionForDeclaredMembers { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal RuntimeTypeInfo[] InternalRuntimeGenericTypeArguments { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal TypeContext TypeContext { get; }
    private RuntimeTypeInfo GenericTypeDefinitionTypeInfo { get; }
    private RuntimeConstructedGenericTypeInfo(UnificationKey key);
    internal static RuntimeConstructedGenericTypeInfo GetRuntimeConstructedGenericTypeInfo(RuntimeTypeInfo genericTypeDefinition, RuntimeTypeInfo[] genericTypeArguments);
    internal static RuntimeConstructedGenericTypeInfo GetRuntimeConstructedGenericTypeInfo(RuntimeTypeInfo genericTypeDefinition, RuntimeTypeInfo[] genericTypeArguments, RuntimeTypeHandle precomputedTypeHandle);
    private static RuntimeTypeHandle GetRuntimeTypeHandleIfAny(RuntimeTypeInfo genericTypeDefinition, RuntimeTypeInfo[] genericTypeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual void PrepareKey();
    public sealed virtual UnificationKey get_Key();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual string get_FullName();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Guid get_GUID();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual string get_Namespace();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual int get_MetadataToken();
    public sealed virtual string ToString();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual RuntimeNamedTypeInfo get_AnchoringTypeDefinitionForDeclaredMembers();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual Type get_InternalDeclaringType();
    internal sealed virtual string get_InternalFullNameOfAssembly();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal sealed virtual RuntimeTypeInfo[] get_InternalRuntimeGenericTypeArguments();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal sealed virtual TypeContext get_TypeContext();
    private RuntimeTypeInfo get_GenericTypeDefinitionTypeInfo();
    internal sealed virtual IEnumerable`1<Type> CoreGetDeclaredNestedTypes(NameFilter optionalNameFilter);
}
internal abstract class System.Reflection.Runtime.TypeInfos.RuntimeGenericParameterTypeInfo : RuntimeTypeInfo {
    private int _position;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public Assembly Assembly { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public string FullName { get; }
    public int GenericParameterPosition { get; }
    public string Namespace { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal TypeContext TypeContext { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    protected QTypeDefRefOrSpec[] Constraints { get; }
    private TypeInfo[] ConstraintInfos { get; }
    protected RuntimeGenericParameterTypeInfo(int position);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual bool get_ContainsGenericParameters();
    public abstract virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual string get_FullName();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Namespace();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual string ToString();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual string get_InternalFullNameOfAssembly();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal abstract virtual TypeContext get_TypeContext();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    protected abstract virtual QTypeDefRefOrSpec[] get_Constraints();
    private TypeInfo[] get_ConstraintInfos();
}
internal abstract class System.Reflection.Runtime.TypeInfos.RuntimeHasElementTypeInfo : RuntimeTypeInfo {
    private UnificationKey _key;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public UnificationKey Key { get; }
    public Assembly Assembly { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool ContainsGenericParameters { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public int MetadataToken { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal RuntimeTypeInfo InternalRuntimeElementType { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    protected string Suffix { get; }
    protected RuntimeHasElementTypeInfo(UnificationKey key);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_IsByRefLike();
    public sealed virtual void PrepareKey();
    public sealed virtual UnificationKey get_Key();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual string get_FullName();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual string get_Namespace();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual string ToString();
    public sealed virtual int get_MetadataToken();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual Type get_InternalDeclaringType();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal sealed virtual string get_InternalFullNameOfAssembly();
    internal sealed virtual RuntimeTypeInfo get_InternalRuntimeElementType();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    protected abstract virtual string get_Suffix();
}
internal abstract class System.Reflection.Runtime.TypeInfos.RuntimeNamedTypeInfo : RuntimeTypeDefinitionTypeInfo {
    private RuntimeTypeHandle _typeHandle;
    private static NamedTypeToGuidTable s_namedTypeToGuidTable;
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Guid GUID { get; }
    public string FullName { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    protected IEnumerable`1<CustomAttributeData> TrueCustomAttributes { get; }
    internal RuntimeNamedTypeInfo AnchoringTypeDefinitionForDeclaredMembers { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal TypeContext TypeContext { get; }
    internal string TraceableTypeName { get; }
    internal QTypeDefRefOrSpec TypeDefinitionQHandle { get; }
    protected RuntimeNamedTypeInfo(RuntimeTypeHandle typeHandle);
    private static RuntimeNamedTypeInfo();
    public sealed virtual bool get_ContainsGenericParameters();
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.RuntimeNamedTypeInfo/<get_CustomAttributes>d__4")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool Equals(RuntimeNamedTypeInfo other);
    protected abstract virtual Nullable`1<Guid> ComputeGuidFromCustomAttributes();
    public sealed virtual Guid get_GUID();
    public sealed virtual string get_FullName();
    protected abstract virtual void GetPackSizeAndSize(Int32& packSize, Int32& size);
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    protected abstract virtual IEnumerable`1<CustomAttributeData> get_TrueCustomAttributes();
    internal sealed virtual RuntimeNamedTypeInfo get_AnchoringTypeDefinitionForDeclaredMembers();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal sealed virtual TypeContext get_TypeContext();
    internal abstract virtual string get_TraceableTypeName();
    internal abstract virtual QTypeDefRefOrSpec get_TypeDefinitionQHandle();
    internal abstract virtual IEnumerable`1<ConstructorInfo> CoreGetDeclaredConstructors(NameFilter optionalNameFilter, RuntimeTypeInfo contextTypeInfo);
    internal abstract virtual IEnumerable`1<MethodInfo> CoreGetDeclaredMethods(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    internal abstract virtual IEnumerable`1<EventInfo> CoreGetDeclaredEvents(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    internal abstract virtual IEnumerable`1<FieldInfo> CoreGetDeclaredFields(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
    internal abstract virtual IEnumerable`1<PropertyInfo> CoreGetDeclaredProperties(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType, RuntimeTypeInfo contextTypeInfo);
}
internal class System.Reflection.Runtime.TypeInfos.RuntimeNoMetadataNamedTypeInfo : RuntimeTypeDefinitionTypeInfo {
    private RuntimeTypeHandle _typeHandle;
    private bool _isGenericTypeDefinition;
    public Assembly Assembly { get; }
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public bool IsGenericTypeDefinition { get; }
    public string Namespace { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public int MetadataToken { get; }
    internal RuntimeNamedTypeInfo AnchoringTypeDefinitionForDeclaredMembers { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal RuntimeTypeInfo[] RuntimeGenericTypeParameters { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal TypeContext TypeContext { get; }
    private RuntimeNoMetadataNamedTypeInfo(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    internal static RuntimeNoMetadataNamedTypeInfo GetRuntimeNoMetadataNamedTypeInfo(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    public sealed virtual Assembly get_Assembly();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual string get_FullName();
    public sealed virtual Guid get_GUID();
    public sealed virtual bool get_IsGenericTypeDefinition();
    public sealed virtual string get_Namespace();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual string ToString();
    public sealed virtual int get_MetadataToken();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual int InternalGetHashCode();
    internal sealed virtual RuntimeNamedTypeInfo get_AnchoringTypeDefinitionForDeclaredMembers();
    internal sealed virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal sealed virtual Type get_InternalDeclaringType();
    public sealed virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal sealed virtual string get_InternalFullNameOfAssembly();
    internal sealed virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal sealed virtual RuntimeTypeInfo[] get_RuntimeGenericTypeParameters();
    internal sealed virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal sealed virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal sealed virtual TypeContext get_TypeContext();
    internal sealed virtual IEnumerable`1<Type> CoreGetDeclaredNestedTypes(NameFilter optionalNameFilter);
}
internal class System.Reflection.Runtime.TypeInfos.RuntimePointerTypeInfo : RuntimeHasElementTypeInfo {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    private RuntimePointerTypeInfo(UnificationKey key);
    internal static RuntimePointerTypeInfo GetPointerTypeInfo(RuntimeTypeInfo elementType);
    internal static RuntimePointerTypeInfo GetPointerTypeInfo(RuntimeTypeInfo elementType, RuntimeTypeHandle precomputedTypeHandle);
    private static RuntimeTypeHandle GetRuntimeTypeHandleIfAny(RuntimeTypeInfo elementType);
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    protected sealed virtual string get_Suffix();
}
internal abstract class System.Reflection.Runtime.TypeInfos.RuntimeTypeDefinitionTypeInfo : RuntimeTypeInfo {
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public sealed virtual bool get_IsTypeDefinition();
    public abstract virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_IsByRefLike();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
[DebuggerDisplayAttribute("{_debugName}")]
internal abstract class System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo : TypeInfo {
    private TypeClassification modreq(System.Runtime.CompilerServices.IsVolatile) _lazyClassification;
    private string _debugName;
    private TypeComponentsCache modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCache;
    private static int GenericParameterCountAny;
    public bool IsGenericType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsByRefLike { get; }
    public bool IsCollectible { get; }
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public MethodBase DeclaringMethod { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Type[] GenericTypeArguments { get; }
    public Guid GUID { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    public bool IsEnum { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Namespace { get; }
    public Type[] GenericTypeParameters { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    private string Internal.Reflection.Tracing.ITraceableTypeMember.MemberName { get; }
    private Type Internal.Reflection.Tracing.ITraceableTypeMember.ContainingType { get; }
    internal RuntimeNamedTypeInfo AnchoringTypeDefinitionForDeclaredMembers { get; }
    internal EnumInfo EnumInfo { get; }
    internal Type InternalDeclaringType { get; }
    internal string InternalFullNameOfAssembly { get; }
    internal RuntimeTypeInfo InternalRuntimeElementType { get; }
    internal RuntimeTypeInfo[] InternalRuntimeGenericTypeArguments { get; }
    internal RuntimeTypeHandle InternalTypeHandleIfAvailable { get; }
    internal bool IsDelegate { get; }
    internal bool CanBrowseWithoutMissingMetadataExceptions { get; }
    internal RuntimeTypeInfo[] RuntimeGenericTypeParameters { get; }
    internal IEnumerable`1<RuntimeConstructorInfo> SyntheticConstructors { get; }
    internal IEnumerable`1<RuntimeMethodInfo> SyntheticMethods { get; }
    internal QTypeDefRefOrSpec TypeRefDefOrSpecForBaseType { get; }
    internal QTypeDefRefOrSpec[] TypeRefDefOrSpecsForDirectlyImplementedInterfaces { get; }
    internal TypeContext TypeContext { get; }
    internal Type BaseTypeWithoutTheGenericParameterQuirk { get; }
    private TypeClassification Classification { get; }
    private TypeComponentsCache Cache { get; }
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual bool get_IsGenericType();
    public sealed virtual Type[] GetInterfaces();
    public sealed virtual string GetEnumName(object value);
    public sealed virtual String[] GetEnumNames();
    public sealed virtual Type GetEnumUnderlyingType();
    public sealed virtual Array GetEnumValues();
    public sealed virtual bool IsEnumDefined(object value);
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual Type GetInterface(string name, bool ignoreCase);
    private static void SplitTypeName(string fullname, String& name, String& ns);
    public abstract virtual bool get_IsTypeDefinition();
    public abstract virtual bool get_IsGenericTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsByRefLike();
    public sealed virtual bool get_IsCollectible();
    public abstract virtual Assembly get_Assembly();
    public sealed virtual string get_AssemblyQualifiedName();
    public sealed virtual Type AsType();
    public sealed virtual Type get_BaseType();
    public abstract virtual bool get_ContainsGenericParameters();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual MethodBase get_DeclaringMethod();
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(Type o);
    public sealed virtual int GetHashCode();
    public abstract virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual MemberInfo[] GetDefaultMembers();
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Guid get_GUID();
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public sealed virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public sealed virtual bool IsAssignableFrom(Type c);
    public sealed virtual bool get_IsEnum();
    public sealed virtual MemberTypes get_MemberType();
    public abstract virtual int get_MetadataToken();
    public sealed virtual Module get_Module();
    public abstract virtual string get_Namespace();
    public sealed virtual Type[] get_GenericTypeParameters();
    public virtual int GetArrayRank();
    public sealed virtual Type GetElementType();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    public sealed virtual Type MakeArrayType();
    public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type MakePointerType();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual string get_Name();
    public sealed virtual Type get_ReflectedType();
    public abstract virtual StructLayoutAttribute get_StructLayoutAttribute();
    public abstract virtual string ToString();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
    public sealed virtual Type get_UnderlyingSystemType();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    protected abstract virtual int InternalGetHashCode();
    protected sealed virtual bool IsCOMObjectImpl();
    protected sealed virtual bool IsPrimitiveImpl();
    protected sealed virtual bool IsValueTypeImpl();
    private sealed virtual override string Internal.Reflection.Tracing.ITraceableTypeMember.get_MemberName();
    private sealed virtual override Type Internal.Reflection.Tracing.ITraceableTypeMember.get_ContainingType();
    internal virtual RuntimeNamedTypeInfo get_AnchoringTypeDefinitionForDeclaredMembers();
    internal EnumInfo get_EnumInfo();
    internal abstract virtual Type get_InternalDeclaringType();
    internal abstract virtual string get_InternalFullNameOfAssembly();
    public abstract virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal virtual RuntimeTypeInfo get_InternalRuntimeElementType();
    internal virtual RuntimeTypeInfo[] get_InternalRuntimeGenericTypeArguments();
    internal abstract virtual RuntimeTypeHandle get_InternalTypeHandleIfAvailable();
    internal bool get_IsDelegate();
    internal abstract virtual bool get_CanBrowseWithoutMissingMetadataExceptions();
    internal virtual RuntimeTypeInfo[] get_RuntimeGenericTypeParameters();
    internal virtual IEnumerable`1<RuntimeConstructorInfo> get_SyntheticConstructors();
    internal virtual IEnumerable`1<RuntimeMethodInfo> get_SyntheticMethods();
    internal virtual QTypeDefRefOrSpec get_TypeRefDefOrSpecForBaseType();
    internal virtual QTypeDefRefOrSpec[] get_TypeRefDefOrSpecsForDirectlyImplementedInterfaces();
    internal virtual TypeContext get_TypeContext();
    internal void EstablishDebugName();
    internal virtual Type get_BaseTypeWithoutTheGenericParameterQuirk();
    private string GetDefaultMemberName();
    private TypeClassification get_Classification();
    private sealed virtual override object System.ICloneable.Clone();
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    private MemberInfo[] GetMemberImpl(string optionalNameOrPrefix, MemberTypes type, BindingFlags bindingAttr);
    private M[] QuerySpecificMemberTypeIfRequested(MemberTypes memberType, string optionalName, BindingFlags bindingAttr, Func`2<MemberInfo, bool> optionalPredicate, MemberTypes targetMemberType, QueryResult`1& queryResult);
    public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    private MethodInfo GetMethodImplCommon(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private QueryResult`1<M> Query(BindingFlags bindingAttr);
    private QueryResult`1<M> Query(string name, BindingFlags bindingAttr);
    private QueryResult`1<M> Query(string optionalName, BindingFlags bindingAttr, Func`2<M, bool> optionalPredicate);
    private TypeComponentsCache get_Cache();
    internal IEnumerable`1<ConstructorInfo> CoreGetDeclaredConstructors(NameFilter optionalNameFilter);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo/<CoreGetDeclaredSyntheticConstructors>d__191")]
private IEnumerable`1<ConstructorInfo> CoreGetDeclaredSyntheticConstructors(NameFilter optionalNameFilter);
    internal IEnumerable`1<MethodInfo> CoreGetDeclaredMethods(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    [IteratorStateMachineAttribute("System.Reflection.Runtime.TypeInfos.RuntimeTypeInfo/<CoreGetDeclaredSyntheticMethods>d__193")]
private IEnumerable`1<MethodInfo> CoreGetDeclaredSyntheticMethods(NameFilter optionalNameFilter);
    internal IEnumerable`1<EventInfo> CoreGetDeclaredEvents(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    internal IEnumerable`1<FieldInfo> CoreGetDeclaredFields(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    internal IEnumerable`1<PropertyInfo> CoreGetDeclaredProperties(NameFilter optionalNameFilter, RuntimeTypeInfo reflectedType);
    internal virtual IEnumerable`1<Type> CoreGetDeclaredNestedTypes(NameFilter optionalNameFilter);
    public sealed virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
}
internal class System.Reflection.Runtime.TypeParsing.ArrayTypeName : HasElementTypeName {
    public ArrayTypeName(TypeName elementTypeName);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal class System.Reflection.Runtime.TypeParsing.AssemblyQualifiedTypeName : TypeName {
    private RuntimeAssemblyName _assemblyName;
    private NonQualifiedTypeName _nonQualifiedTypeName;
    public AssemblyQualifiedTypeName(NonQualifiedTypeName nonQualifiedTypeName, RuntimeAssemblyName assemblyName);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal class System.Reflection.Runtime.TypeParsing.ByRefTypeName : HasElementTypeName {
    public ByRefTypeName(TypeName elementTypeName);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal class System.Reflection.Runtime.TypeParsing.ConstructedGenericTypeName : NonQualifiedTypeName {
    private NamedTypeName _genericTypeDefinition;
    private IList`1<TypeName> _genericTypeArguments;
    public ConstructedGenericTypeName(NamedTypeName genericTypeDefinition, IList`1<TypeName> genericTypeArguments);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal class System.Reflection.Runtime.TypeParsing.CoreAssemblyResolver : MulticastDelegate {
    public CoreAssemblyResolver(object object, IntPtr method);
    public virtual Assembly Invoke(RuntimeAssemblyName refName);
    public virtual IAsyncResult BeginInvoke(RuntimeAssemblyName refName, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal class System.Reflection.Runtime.TypeParsing.CoreTypeResolver : MulticastDelegate {
    public CoreTypeResolver(object object, IntPtr method);
    public virtual Type Invoke(Assembly containingAssemblyIfAny, string name);
    public virtual IAsyncResult BeginInvoke(Assembly containingAssemblyIfAny, string name, AsyncCallback callback, object object);
    public virtual Type EndInvoke(IAsyncResult result);
}
internal class System.Reflection.Runtime.TypeParsing.GetTypeOptions : object {
    [CompilerGeneratedAttribute]
private bool <ThrowOnError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    private CoreAssemblyResolver _coreAssemblyResolver;
    private CoreTypeResolver _coreTypeResolver;
    public bool ThrowOnError { get; }
    public bool IgnoreCase { get; }
    public GetTypeOptions(CoreAssemblyResolver coreAssemblyResolver, CoreTypeResolver coreTypeResolver, bool throwOnError, bool ignoreCase);
    public Assembly CoreResolveAssembly(RuntimeAssemblyName name);
    public Type CoreResolveType(Assembly containingAssemblyIfAny, string name);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnError();
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
}
internal abstract class System.Reflection.Runtime.TypeParsing.HasElementTypeName : NonQualifiedTypeName {
    [CompilerGeneratedAttribute]
private TypeName <ElementTypeName>k__BackingField;
    protected TypeName ElementTypeName { get; }
    public HasElementTypeName(TypeName elementTypeName);
    [CompilerGeneratedAttribute]
protected TypeName get_ElementTypeName();
}
internal class System.Reflection.Runtime.TypeParsing.MultiDimArrayTypeName : HasElementTypeName {
    private int _rank;
    public MultiDimArrayTypeName(TypeName elementTypeName, int rank);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal abstract class System.Reflection.Runtime.TypeParsing.NamedTypeName : NonQualifiedTypeName {
}
internal class System.Reflection.Runtime.TypeParsing.NamespaceTypeName : NamedTypeName {
    private string _fullName;
    public NamespaceTypeName(string fullName);
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
    public sealed virtual string ToString();
}
internal class System.Reflection.Runtime.TypeParsing.NestedTypeName : NamedTypeName {
    private string _nestedTypeName;
    private NamedTypeName _declaringType;
    public NestedTypeName(string nestedTypeName, NamedTypeName declaringType);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal abstract class System.Reflection.Runtime.TypeParsing.NonQualifiedTypeName : TypeName {
}
internal class System.Reflection.Runtime.TypeParsing.PointerTypeName : HasElementTypeName {
    public PointerTypeName(TypeName elementTypeName);
    public sealed virtual string ToString();
    public sealed virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
}
internal enum System.Reflection.Runtime.TypeParsing.TokenType : Enum {
    public int value__;
    public static TokenType End;
    public static TokenType OpenSqBracket;
    public static TokenType CloseSqBracket;
    public static TokenType Comma;
    public static TokenType Plus;
    public static TokenType Asterisk;
    public static TokenType Ampersand;
    public static TokenType Other;
}
internal class System.Reflection.Runtime.TypeParsing.TypeLexer : object {
    private int _index;
    private Char[] _chars;
    private static char NUL;
    public TokenType Peek { get; }
    public TokenType PeekSecond { get; }
    public TypeLexer(string s);
    public TokenType get_Peek();
    public TokenType get_PeekSecond();
    public void Skip();
    public TokenType GetNextToken();
    public string GetNextIdentifier();
    public RuntimeAssemblyName GetNextAssemblyName();
    public RuntimeAssemblyName GetNextEmbeddedAssemblyName();
    private static TokenType CharToToken(char c);
    private void SkipWhiteSpace();
}
internal abstract class System.Reflection.Runtime.TypeParsing.TypeName : object {
    public abstract virtual Type ResolveType(Assembly containingAssemblyIfAny, GetTypeOptions getTypeOptions);
    public abstract virtual string ToString();
}
internal class System.Reflection.Runtime.TypeParsing.TypeParser : object {
    private TypeLexer _lexer;
    private TypeParser(string s);
    public static TypeName ParseAssemblyQualifiedTypeName(string s, bool throwOnError);
    private static TypeName ParseAssemblyQualifiedTypeName(string s);
    private NonQualifiedTypeName ParseNonQualifiedTypeName();
    private NonQualifiedTypeName ParseNamedOrConstructedGenericTypeName();
    private NamedTypeName ParseNamedTypeName();
    private NamespaceTypeName ParseNamespaceTypeName();
    private TypeName ParseGenericTypeArgument();
}
internal class System.Runtime.CompilerServices.__BlockReflectionActivateAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionInvokeAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class System.Runtime.CompilerServices.DeveloperExperienceModeOnlyAttribute : Attribute {
}
[DeveloperExperienceModeOnlyAttribute]
internal static class System.Runtime.CompilerServices.DeveloperExperienceState : object {
    public static bool DeveloperExperienceModeEnabled { get; }
    public static bool get_DeveloperExperienceModeEnabled();
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Bif_InvalidMetadata { get; }
    internal static string Acc_CreateAbstEx { get; }
    internal static string Acc_NotClassInit { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string Arg_NotGenericMethodDefinition { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_TypeLoadNullStr { get; }
    internal static string Argument_NotEnoughGenArguments { get; }
    internal static string Reflection_CustomReflectionObjectsNotSupported { get; }
    internal static string TypeLoad_TypeNotFound { get; }
    internal static string TypeLoad_TypeNotFoundInAssembly { get; }
    internal static string FileNotFound_AssemblyNotFound { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_MustBeDelegate { get; }
    internal static string Arg_InvokeMethodMissingMetadata { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_InvalidHandle { get; }
    internal static string Argument_ResolveMethodHandle { get; }
    internal static string Argument_ResolveFieldHandle { get; }
    internal static string Argument_MethodDeclaringTypeGeneric { get; }
    internal static string Argument_FieldDeclaringTypeGeneric { get; }
    internal static string Arg_UnboundGenParam { get; }
    internal static string Argument_AssemblyGetTypeCannotSpecifyAssembly { get; }
    internal static string InvalidOperation_NoPublicAddMethod { get; }
    internal static string InvalidOperation_NoPublicRemoveMethod { get; }
    internal static string Arg_NotGenericTypeDefinition { get; }
    internal static string PlatformNotSupported_MakeGenericType { get; }
    internal static string ArgumentException_InvalidTypeArgument { get; }
    internal static string ArgumentException_InvalidArrayElementType { get; }
    internal static string PlatformNotSupported_NoTypeHandleForOpenTypes { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string MissingMember { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string PlatformNotSupported_InterfaceMap { get; }
    internal static string NoMetadataTokenAvailable { get; }
    internal static string MissingField { get; }
    internal static string Arg_MustBeType { get; }
    internal static string NotSupported_ChangeType { get; }
    internal static string Arg_NoDefCTor { get; }
    internal static string NotSupported_ActivAttr { get; }
    internal static string NotSupported_CallToVarArg { get; }
    internal static string Acc_CreateGenericEx { get; }
    internal static string Acc_CreateVoid { get; }
    internal static string Arg_GenericParameter { get; }
    internal static string Arg_NoAccessSpec { get; }
    internal static string Arg_NamedParamTooBig { get; }
    internal static string Arg_PropSetGet { get; }
    internal static string Arg_PropSetInvoke { get; }
    internal static string Arg_NamedParamNull { get; }
    internal static string Arg_CreatInstAccess { get; }
    internal static string Arg_FldSetGet { get; }
    internal static string Arg_FldGetPropSet { get; }
    internal static string Arg_FldSetPropGet { get; }
    internal static string Arg_FldSetInvoke { get; }
    internal static string Arg_IndexMustBeInt { get; }
    internal static string Arg_FldGetArgErr { get; }
    internal static string Arg_FldSetArgErr { get; }
    internal static string Arg_PlatformNotSupportedInvokeMemberCom { get; }
    internal static string Argument_MustBeRuntimeType { get; }
    internal static string Argument_MustBeRuntimeMethodInfo { get; }
    internal static string Arg_ArrayZeroError { get; }
    internal static string Argument_MustBeRuntimeFieldInfo { get; }
    internal static string Argument_TypedReferenceInvalidField { get; }
    internal static string MissingMemberTypeRef { get; }
    internal static string Arg_TypeRefPrimitve { get; }
    internal static string MissingMemberNestErr { get; }
    internal static string Arg_TypedReference_Null { get; }
    internal static string Acc_CreateAbst { get; }
    internal static string Acc_CreateInterface { get; }
    internal static string CannotCreateByRefOfByRef { get; }
    internal static string CannotCreatePointerOfByRef { get; }
    internal static string Arg_EnumLitValueNotFound { get; }
    internal static string NotSupported_ByRefLike { get; }
    internal static string CannotUseByRefLikeTypeInInstantiation { get; }
    internal static string RFLCT_Targ_StatMethReqTarg { get; }
    internal static string RFLCT_Targ_ITargMismatch { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static Type ResourceType { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Bif_InvalidMetadata();
    internal static string get_Acc_CreateAbstEx();
    internal static string get_Acc_NotClassInit();
    internal static string get_Acc_ReadOnly();
    internal static string get_Arg_NotGenericMethodDefinition();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_TypeLoadNullStr();
    internal static string get_Argument_NotEnoughGenArguments();
    internal static string get_Reflection_CustomReflectionObjectsNotSupported();
    internal static string get_TypeLoad_TypeNotFound();
    internal static string get_TypeLoad_TypeNotFoundInAssembly();
    internal static string get_FileNotFound_AssemblyNotFound();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_MustBeDelegate();
    internal static string get_Arg_InvokeMethodMissingMetadata();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_InvalidHandle();
    internal static string get_Argument_ResolveMethodHandle();
    internal static string get_Argument_ResolveFieldHandle();
    internal static string get_Argument_MethodDeclaringTypeGeneric();
    internal static string get_Argument_FieldDeclaringTypeGeneric();
    internal static string get_Arg_UnboundGenParam();
    internal static string get_Argument_AssemblyGetTypeCannotSpecifyAssembly();
    internal static string get_InvalidOperation_NoPublicAddMethod();
    internal static string get_InvalidOperation_NoPublicRemoveMethod();
    internal static string get_Arg_NotGenericTypeDefinition();
    internal static string get_PlatformNotSupported_MakeGenericType();
    internal static string get_ArgumentException_InvalidTypeArgument();
    internal static string get_ArgumentException_InvalidArrayElementType();
    internal static string get_PlatformNotSupported_NoTypeHandleForOpenTypes();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_EmptyArray();
    internal static string get_MissingMember();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_PlatformNotSupported_InterfaceMap();
    internal static string get_NoMetadataTokenAvailable();
    internal static string get_MissingField();
    internal static string get_Arg_MustBeType();
    internal static string get_NotSupported_ChangeType();
    internal static string get_Arg_NoDefCTor();
    internal static string get_NotSupported_ActivAttr();
    internal static string get_NotSupported_CallToVarArg();
    internal static string get_Acc_CreateGenericEx();
    internal static string get_Acc_CreateVoid();
    internal static string get_Arg_GenericParameter();
    internal static string get_Arg_NoAccessSpec();
    internal static string get_Arg_NamedParamTooBig();
    internal static string get_Arg_PropSetGet();
    internal static string get_Arg_PropSetInvoke();
    internal static string get_Arg_NamedParamNull();
    internal static string get_Arg_CreatInstAccess();
    internal static string get_Arg_FldSetGet();
    internal static string get_Arg_FldGetPropSet();
    internal static string get_Arg_FldSetPropGet();
    internal static string get_Arg_FldSetInvoke();
    internal static string get_Arg_IndexMustBeInt();
    internal static string get_Arg_FldGetArgErr();
    internal static string get_Arg_FldSetArgErr();
    internal static string get_Arg_PlatformNotSupportedInvokeMemberCom();
    internal static string get_Argument_MustBeRuntimeType();
    internal static string get_Argument_MustBeRuntimeMethodInfo();
    internal static string get_Arg_ArrayZeroError();
    internal static string get_Argument_MustBeRuntimeFieldInfo();
    internal static string get_Argument_TypedReferenceInvalidField();
    internal static string get_MissingMemberTypeRef();
    internal static string get_Arg_TypeRefPrimitve();
    internal static string get_MissingMemberNestErr();
    internal static string get_Arg_TypedReference_Null();
    internal static string get_Acc_CreateAbst();
    internal static string get_Acc_CreateInterface();
    internal static string get_CannotCreateByRefOfByRef();
    internal static string get_CannotCreatePointerOfByRef();
    internal static string get_Arg_EnumLitValueNotFound();
    internal static string get_NotSupported_ByRefLike();
    internal static string get_CannotUseByRefLikeTypeInInstantiation();
    internal static string get_RFLCT_Targ_StatMethReqTarg();
    internal static string get_RFLCT_Targ_ITargMismatch();
    internal static string get_InvalidOperation_NoValue();
    internal static Type get_ResourceType();
}
