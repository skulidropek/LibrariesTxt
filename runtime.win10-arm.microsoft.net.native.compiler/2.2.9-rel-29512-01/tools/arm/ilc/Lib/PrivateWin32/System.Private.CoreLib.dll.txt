internal static class FxResources.System.Private.CoreLib.SR : object {
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class Internal.DeveloperExperience.DeveloperExperience : object {
    private static DeveloperExperience s_developerExperience;
    public static DeveloperExperience Default { get; public set; }
    private static bool IsMetadataStackTraceResolutionDisabled();
    public virtual void WriteLine(string s);
    public virtual string CreateStackTraceString(IntPtr ip, bool includeFileInfo);
    public virtual void TryGetSourceLineInfo(IntPtr ip, String& fileName, Int32& lineNumber, Int32& columnNumber);
    public virtual void TryGetILOffsetWithinMethod(IntPtr ip, Int32& ilOffset);
    public virtual void TryGetMethodBase(IntPtr methodStartAddress, MethodBase& method);
    public virtual bool OnContractFailure(string stackTrace, ContractFailureKind contractFailureKind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    public static DeveloperExperience get_Default();
    public static void set_Default(DeveloperExperience value);
    private static string GetFileNameWithoutExtension(string path);
    private static string GetFileName(string path);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Diagnostics.ExceptionExtensions : object {
    [ExtensionAttribute]
public static IntPtr[] GetStackIPs(Exception e);
}
[__BlockReflectionAttribute]
public static class Internal.Diagnostics.StackTraceHelper : object {
    public static string FormatStackTrace(IntPtr[] ips, bool includeFileInfo);
    public static string FormatStackTrace(IntPtr[] ips, int skipFrames, bool includeFileInfo);
}
internal static class Internal.IntrinsicSupport.ComparerHelpers : object {
    private static bool ImplementsIComparable(RuntimeTypeHandle t);
    private static object GetComparer(RuntimeTypeHandle t);
    internal static Comparer`1<T> GetUnknownComparer();
    private static Comparer`1<T> GetKnownGenericComparer();
    private static Comparer`1<Nullable`1<U>> GetKnownNullableComparer();
    private static Comparer`1<T> GetKnownObjectComparer();
    internal static int CompareObjects(object x, object y);
}
internal static class Internal.IntrinsicSupport.EqualityComparerHelpers : object {
    private static bool ImplementsIEquatable(RuntimeTypeHandle t);
    private static bool IsEnum(RuntimeTypeHandle t);
    private static object GetComparer(RuntimeTypeHandle t);
    internal static EqualityComparer`1<T> GetUnknownEquatableComparer();
    private static EqualityComparer`1<T> GetKnownGenericEquatableComparer();
    private static EqualityComparer`1<Nullable`1<U>> GetKnownNullableEquatableComparer();
    private static EqualityComparer`1<T> GetKnownObjectEquatableComparer();
    private static EqualityComparer`1<T> GetKnownEnumEquatableComparer();
    [IntrinsicAttribute]
internal static bool EnumOnlyEquals(T x, T y);
    private static bool StructOnlyEqualsIEquatable(T x, T y);
    private static bool StructOnlyEqualsNullable(Nullable`1<T> x, Nullable`1<T> y);
    [IntrinsicAttribute]
internal static EqualityComparer`1<T> GetComparerForReferenceTypesOnly();
    private static bool StructOnlyNormalEquals(T left, T right);
    [IntrinsicAttribute]
internal static bool StructOnlyEquals(T left, T right);
}
internal static class Internal.IO.File : object {
    public static bool Exists(string path);
    public static Byte[] ReadAllBytes(string path);
    internal static bool InternalExists(string fullPath);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
}
[ExtensionAttribute]
internal static class Internal.LowLevelLinq.LowLevelEnumerable : object {
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool Any(IEnumerable`1<T> values, Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(IEnumerable`1<T> values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Select>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<U> Select(T[] values, Func`2<T, U> func);
    [IteratorStateMachineAttribute("Internal.LowLevelLinq.LowLevelEnumerable/<Where>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Where(IEnumerable`1<T> source, Func`2<T, bool> filter);
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int Count(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static T[] ToArray(IEnumerable`1<T> values);
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.PaddingFor32 : ValueType {
}
internal static class Internal.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class Internal.Reflection.Augments.ReflectionAugments : object {
    private static ReflectionCoreCallbacks s_reflectionCoreCallbacks;
    internal static ReflectionCoreCallbacks ReflectionCoreCallbacks { get; }
    public static void Initialize(ReflectionCoreCallbacks reflectionCoreCallbacks);
    public static CustomAttributeNamedArgument CreateCustomAttributeNamedArgument(Type attributeType, string memberName, bool isField, CustomAttributeTypedArgument typedValue);
    public static TypeCode GetRuntimeTypeCode(Type type);
    public static Type MakeGenericSignatureType(Type genericTypeDefinition, Type[] genericTypeArguments);
    public static TypeLoadException CreateTypeLoadException(string message, string typeName);
    internal static ReflectionCoreCallbacks get_ReflectionCoreCallbacks();
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public abstract class Internal.Reflection.Augments.ReflectionCoreCallbacks : object {
    public abstract virtual Assembly Load(AssemblyName refName, bool throwOnFileNotFound);
    public abstract virtual Assembly Load(Byte[] rawAssembly, Byte[] pdbSymbolStore);
    public abstract virtual MethodBase GetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle);
    public abstract virtual MethodBase GetMethodFromHandle(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle);
    public abstract virtual FieldInfo GetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle);
    public abstract virtual FieldInfo GetFieldFromHandle(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle declaringTypeHandle);
    public abstract virtual EventInfo GetImplicitlyOverriddenBaseClassEvent(EventInfo e);
    public abstract virtual MethodInfo GetImplicitlyOverriddenBaseClassMethod(MethodInfo m);
    public abstract virtual PropertyInfo GetImplicitlyOverriddenBaseClassProperty(PropertyInfo p);
    public abstract virtual object ActivatorCreateInstance(Type type, bool nonPublic);
    public abstract virtual object ActivatorCreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public abstract virtual Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public abstract virtual Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public abstract virtual Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public abstract virtual Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public abstract virtual Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    public abstract virtual IntPtr GetFunctionPointer(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle declaringTypeHandle);
    public abstract virtual void RunModuleConstructor(Module module);
    public abstract virtual void MakeTypedReference(object target, FieldInfo[] flds, Type& type, Int32& offset);
    public abstract virtual Assembly[] GetLoadedAssemblies();
    public abstract virtual EnumInfo GetEnumInfo(Type type);
}
[__BlockReflectionAttribute]
public interface Internal.Reflection.Core.NonPortable.IRuntimeImplementedType {
}
internal static class Internal.Reflection.Core.NonPortable.RuntimeTypeUnifier : object {
    public static Type GetTypeForRuntimeTypeHandle(RuntimeTypeHandle runtimeTypeHandle);
    internal static Type GetRuntimeTypeForEEType(EETypePtr eeType);
}
[AttributeUsageAttribute("5148")]
[__BlockReflectionAttribute]
public class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string assemblyIdentity);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Reflection.Extensions.NonPortable.CustomAttributeInheritanceRules : object {
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeData> GetMatchingCustomAttributes(Assembly element, Type optionalAttributeTypeFilter, bool skipTypeValidation);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeData> GetMatchingCustomAttributes(Module element, Type optionalAttributeTypeFilter, bool skipTypeValidation);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeData> GetMatchingCustomAttributes(ParameterInfo element, Type optionalAttributeTypeFilter, bool inherit, bool skipTypeValidation);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeData> GetMatchingCustomAttributes(MemberInfo element, Type optionalAttributeTypeFilter, bool inherit, bool skipTypeValidation);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Reflection.Extensions.NonPortable.CustomAttributeInstantiator : object {
    [ExtensionAttribute]
public static Attribute Instantiate(CustomAttributeData cad);
    [ExtensionAttribute]
private static object Convert(CustomAttributeTypedArgument typedArgument);
    [ExtensionAttribute]
private static bool IsValidNamedArgumentTarget(FieldInfo fieldInfo);
    [ExtensionAttribute]
private static bool IsValidNamedArgumentTarget(PropertyInfo propertyInfo);
}
internal abstract class Internal.Reflection.Extensions.NonPortable.CustomAttributeSearcher`1 : object {
    public IEnumerable`1<CustomAttributeData> GetMatchingCustomAttributes(E element, Type optionalAttributeTypeFilter, bool inherit, bool skipTypeValidation);
    public virtual E GetParent(E e);
    [IteratorStateMachineAttribute("Internal.Reflection.Extensions.NonPortable.CustomAttributeSearcher`1/<GetMatchingCustomAttributesIterator>d__2")]
private IEnumerable`1<CustomAttributeData> GetMatchingCustomAttributesIterator(E element, Func`2<Type, bool> rawPassesFilter, bool inherit);
    private AttributeUsageAttribute GetAttributeUsage(Type attributeType);
    protected abstract virtual IEnumerable`1<CustomAttributeData> GetDeclaredCustomAttributes(E element);
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum Internal.Reflection.MetadataTransformation : Enum {
    public int value__;
    public static MetadataTransformation None;
    public static MetadataTransformation OriginallyNotSealed;
    public static MetadataTransformation OriginallyVirtual;
    public static MetadataTransformation OriginallySealed;
    public static MetadataTransformation OriginallyNewSlot;
    public static MetadataTransformation OriginallyAccessCheckedOnOverride;
    public static MetadataTransformation OriginallyForeignObject;
    public static MetadataTransformation OriginallyComObject;
}
[DependencyReductionRootAttribute]
[AttributeUsageAttribute("5212")]
[__BlockReflectionAttribute]
public class Internal.Reflection.MetadataTransformedAttribute : Attribute {
    public MetadataTransformedAttribute(MetadataTransformation transformation);
}
internal static class Internal.Runtime.ArrayTypesConstants : object {
    public static int MaxSizeForValueClassInArray;
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.Augments.AsyncStatus : Enum {
    public int value__;
    public static AsyncStatus Started;
    public static AsyncStatus Completed;
    public static AsyncStatus Canceled;
    public static AsyncStatus Error;
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.Augments.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.Augments.CausalitySource : Enum {
    public int value__;
    public static CausalitySource Application;
    public static CausalitySource Library;
    public static CausalitySource System;
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.Augments.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.Augments.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.Augments.DynamicDelegateAugments : object {
    public static Delegate CreateObjectArrayDelegate(Type delegateType, Func`2<Object[], object> invoker);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class Internal.Runtime.Augments.EnumInfo : object {
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Array <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2[] <NamesAndValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFlagsAttribute>k__BackingField;
    internal Type UnderlyingType { get; }
    internal Array Values { get; }
    internal KeyValuePair`2[] NamesAndValues { get; }
    internal bool HasFlagsAttribute { get; }
    public EnumInfo(Type enumType);
    [CompilerGeneratedAttribute]
internal Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
internal Array get_Values();
    [CompilerGeneratedAttribute]
internal KeyValuePair`2[] get_NamesAndValues();
    [CompilerGeneratedAttribute]
internal bool get_HasFlagsAttribute();
    private static RhCorElementType ComputeCorElementType(Type enumType);
    private static Type ComputeUnderlyingType(Type enumType);
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.Augments.EnvironmentAugments : object {
    private static int s_latchedExitCode;
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static string StackTrace { get; }
    public static int TickCount { get; }
    public static int ProcessorCount { get; }
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    private static void ValidateVariableAndValue(string variable, String& value);
    public static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables(EnvironmentVariableTarget target);
    private static bool ValidateAndConvertRegistryTarget(EnvironmentVariableTarget target);
    public static int get_CurrentManagedThreadId();
    public static void FailFast(string message, Exception error);
    internal static void ShutdownCore();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static bool get_HasShutdownStarted();
    public static string get_StackTrace();
    public static int get_TickCount();
    public static int get_ProcessorCount();
    public static void Exit(int exitCode);
    public static String[] GetCommandLineArgs();
    private static string GetEnvironmentVariableCore(string variable);
    private static void SetEnvironmentVariableCore(string variable, string value);
    public static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables();
    [IteratorStateMachineAttribute("Internal.Runtime.Augments.EnvironmentAugments/<EnumerateEnvironmentVariables>d__28")]
private static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariables(Char[] block);
    private static string GetEnvironmentVariableFromRegistry(string variable, bool fromMachine);
    private static void SetEnvironmentVariableFromRegistry(string variable, string value, bool fromMachine);
    [IteratorStateMachineAttribute("Internal.Runtime.Augments.EnvironmentAugments/<EnumerateEnvironmentVariablesFromRegistry>d__31")]
private static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateEnvironmentVariablesFromRegistry(bool fromMachine);
    private static RegistryKey OpenEnvironmentKeyIfExists(bool fromMachine, bool writable);
}
[CLSCompliantAttribute("False")]
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.Augments.InteropCallbacks : object {
    public abstract virtual IntPtr GetForwardDelegateCreationStub(RuntimeTypeHandle delegateTypeHandle);
    public abstract virtual IntPtr GetDelegateMarshallingStub(RuntimeTypeHandle delegateTypeHandle, bool openStaticDelegate);
    public abstract virtual bool TryGetStructUnmarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& unmarshalStub);
    public abstract virtual bool TryGetStructMarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& marshalStub);
    public abstract virtual bool TryGetDestroyStructureStub(RuntimeTypeHandle structureTypeHandle, IntPtr& destroyStructureStub, Boolean& hasInvalidLayout);
    public abstract virtual bool TryGetStructFieldOffset(RuntimeTypeHandle structureTypeHandle, string fieldName, Boolean& structExists, UInt32& offset);
    public abstract virtual bool TryGetStructUnsafeStructSize(RuntimeTypeHandle structureTypeHandle, Int32& size);
}
[CLSCompliantAttribute("False")]
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.Augments.ReflectionExecutionDomainCallbacks : object {
    public abstract virtual Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, string defaultAssembly);
    public abstract virtual IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle runtimeTypeHandle);
    public abstract virtual bool IsReflectionBlocked(RuntimeTypeHandle typeHandle);
    public abstract virtual Type GetNamedTypeForHandle(RuntimeTypeHandle typeHandle, bool isGenericTypeDefinition);
    public abstract virtual Type GetArrayTypeForHandle(RuntimeTypeHandle typeHandle);
    public abstract virtual Type GetMdArrayTypeForHandle(RuntimeTypeHandle typeHandle, int rank);
    public abstract virtual Type GetPointerTypeForHandle(RuntimeTypeHandle typeHandle);
    public abstract virtual Type GetByRefTypeForHandle(RuntimeTypeHandle typeHandle);
    public abstract virtual Type GetConstructedGenericTypeForHandle(RuntimeTypeHandle typeHandle);
    public abstract virtual Exception CreateMissingMetadataException(Type typeWithMissingMetadata);
    public abstract virtual string GetBetterDiagnosticInfoIfAvailable(RuntimeTypeHandle runtimeTypeHandle);
    public abstract virtual MethodBase GetMethodBaseFromStartAddressIfAvailable(IntPtr methodStartAddress);
    public abstract virtual int ValueTypeGetHashCodeUsingReflection(object valueType);
    public abstract virtual bool ValueTypeEqualsUsingReflection(object left, object right);
    public abstract virtual bool TryGetDefaultParameterValue(object defaultParametersContext, RuntimeTypeHandle thType, int argIndex, Object& defaultValue);
    public abstract virtual RuntimeTypeHandle GetTypeHandleIfAvailable(Type type);
    public abstract virtual bool SupportsReflection(Type type);
    public abstract virtual MethodInfo GetDelegateMethod(Delegate del);
    public abstract virtual Exception GetExceptionForHR(int hr);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.Augments.RuntimeAugments : object {
    private static StackTraceMetadataCallbacks s_stackTraceMetadataCallbacks;
    public static string HiddenScopeAssemblyName;
    private static ReflectionExecutionDomainCallbacks modreq(System.Runtime.CompilerServices.IsVolatile) s_reflectionExecutionDomainCallbacks;
    private static TypeLoaderCallbacks s_typeLoaderCallbacks;
    private static InteropCallbacks s_interopCallbacks;
    public static int ObjectHeaderSize { get; }
    public static RuntimeTypeHandle ProjectionTypeForArrays { get; }
    [CLSCompliantAttribute("False")]
public static ReflectionExecutionDomainCallbacks CallbacksIfAvailable { get; }
    [CLSCompliantAttribute("False")]
public static ReflectionExecutionDomainCallbacks Callbacks { get; }
    internal static TypeLoaderCallbacks TypeLoaderCallbacksIfAvailable { get; }
    internal static TypeLoaderCallbacks TypeLoaderCallbacks { get; }
    internal static InteropCallbacks InteropCallbacks { get; }
    internal static StackTraceMetadataCallbacks StackTraceCallbacksIfAvailable { get; }
    [CLSCompliantAttribute("False")]
public static void Initialize(ReflectionExecutionDomainCallbacks callbacks);
    [CLSCompliantAttribute("False")]
public static void InitializeLookups(TypeLoaderCallbacks callbacks);
    [CLSCompliantAttribute("False")]
public static void InitializeInteropLookups(InteropCallbacks callbacks);
    [CLSCompliantAttribute("False")]
public static void InitializeStackTraceMetadataSupport(StackTraceMetadataCallbacks callbacks);
    public static object NewObject(RuntimeTypeHandle typeHandle);
    public static object RawNewObject(RuntimeTypeHandle typeHandle);
    public static Array NewArray(RuntimeTypeHandle typeHandleForArrayType, int count);
    public static Array NewMultiDimArray(RuntimeTypeHandle typeHandleForArrayType, Int32[] lengths, Int32[] lowerBounds);
    public static IntPtr GetAllocateObjectHelperForType(RuntimeTypeHandle type);
    public static IntPtr GetAllocateArrayHelperForType(RuntimeTypeHandle type);
    public static IntPtr GetCastingHelperForType(RuntimeTypeHandle type, bool throwing);
    public static IntPtr GetCheckArrayElementTypeHelperForType(RuntimeTypeHandle type);
    public static IntPtr GetDispatchMapForType(RuntimeTypeHandle typeHandle);
    public static IntPtr GetFallbackDefaultConstructor();
    public static Delegate CreateDelegate(RuntimeTypeHandle typeHandleForDelegate, IntPtr ldftnResult, object thisObject, bool isStatic, bool isOpen);
    public static IntPtr GetDelegateLdFtnResult(Delegate d, RuntimeTypeHandle& typeOfFirstParameterIfInstanceDelegate, Boolean& isOpenResolver, Boolean& isInterpreterEntrypoint);
    public static void GetDelegateData(Delegate delegateObj, Object& firstParameter, Object& helperObject, IntPtr& extraFunctionPointerOrData, IntPtr& functionPointer);
    public static int GetLoadedModules(TypeManagerHandle[] resultArray);
    public static IntPtr GetOSModuleFromPointer(IntPtr pointerVal);
    public static bool FindBlob(TypeManagerHandle typeManager, int blobId, IntPtr ppbBlob, IntPtr pcbBlob);
    public static IntPtr GetPointerFromTypeHandle(RuntimeTypeHandle typeHandle);
    public static TypeManagerHandle GetModuleFromTypeHandle(RuntimeTypeHandle typeHandle);
    public static RuntimeTypeHandle CreateRuntimeTypeHandle(IntPtr ldTokenResult);
    public static IntPtr GetThreadStaticFieldAddress(RuntimeTypeHandle typeHandle, int threadStaticsBlockOffset, int fieldOffset);
    public static void StoreValueTypeField(IntPtr address, object fieldValue, RuntimeTypeHandle fieldType);
    public static Byte& GetRawData(object obj);
    public static object LoadValueTypeField(IntPtr address, RuntimeTypeHandle fieldType);
    public static object LoadPointerTypeField(IntPtr address, RuntimeTypeHandle fieldType);
    public static void StoreValueTypeField(Byte& address, object fieldValue, RuntimeTypeHandle fieldType);
    public static void StoreValueTypeField(object obj, int fieldOffset, object fieldValue, RuntimeTypeHandle fieldType);
    public static object LoadValueTypeField(object obj, int fieldOffset, RuntimeTypeHandle fieldType);
    public static object LoadPointerTypeField(object obj, int fieldOffset, RuntimeTypeHandle fieldType);
    public static void StoreReferenceTypeField(IntPtr address, object fieldValue);
    public static object LoadReferenceTypeField(IntPtr address);
    public static void StoreReferenceTypeField(object obj, int fieldOffset, object fieldValue);
    public static object LoadReferenceTypeField(object obj, int fieldOffset);
    [CLSCompliantAttribute("False")]
public static void StoreValueTypeFieldValueIntoValueType(TypedReference typedReference, int fieldOffset, object fieldValue, RuntimeTypeHandle fieldTypeHandle);
    [CLSCompliantAttribute("False")]
public static object LoadValueTypeFieldValueFromValueType(TypedReference typedReference, int fieldOffset, RuntimeTypeHandle fieldTypeHandle);
    [CLSCompliantAttribute("False")]
public static void StoreReferenceTypeFieldValueIntoValueType(TypedReference typedReference, int fieldOffset, object fieldValue);
    [CLSCompliantAttribute("False")]
public static object LoadReferenceTypeFieldValueFromValueType(TypedReference typedReference, int fieldOffset);
    [CLSCompliantAttribute("False")]
public static object LoadPointerTypeFieldValueFromValueType(TypedReference typedReference, int fieldOffset, RuntimeTypeHandle fieldTypeHandle);
    public static int get_ObjectHeaderSize();
    [DebuggerGuidedStepThroughAttribute]
public static object CallDynamicInvokeMethod(object thisPtr, IntPtr methodToCall, object thisPtrDynamicInvokeMethod, IntPtr dynamicInvokeHelperMethod, IntPtr dynamicInvokeHelperGenericDictionary, object defaultParametersContext, Object[] parameters, BinderBundle binderBundle, bool wrapInTargetInvocationException, bool invokeMethodHelperIsThisCall, bool methodToCallIsThisCall);
    public static void EnsureClassConstructorRun(IntPtr staticClassConstructionContext);
    public static object GetEnumValue(Enum e);
    public static RuntimeTypeHandle GetRelatedParameterTypeHandle(RuntimeTypeHandle parameterTypeHandle);
    public static bool IsValueType(RuntimeTypeHandle type);
    public static bool IsInterface(RuntimeTypeHandle type);
    public static object Box(RuntimeTypeHandle type, IntPtr address);
    public static void SetClosedStaticDelegateFirstParameter(Delegate del, object firstParameter);
    public static RuntimeTypeHandle get_ProjectionTypeForArrays();
    public static bool IsAssignableFrom(RuntimeTypeHandle dstType, RuntimeTypeHandle srcType);
    public static bool IsInstanceOfInterface(object obj, RuntimeTypeHandle interfaceTypeHandle);
    public static bool TryGetBaseType(RuntimeTypeHandle typeHandle, RuntimeTypeHandle& baseTypeHandle);
    public static IEnumerable`1<RuntimeTypeHandle> TryGetImplementedInterfaces(RuntimeTypeHandle typeHandle);
    private static RuntimeTypeHandle CreateRuntimeTypeHandle(EETypePtr eeType);
    private static EETypePtr CreateEETypePtr(RuntimeTypeHandle runtimeTypeHandle);
    public static int GetGCDescSize(RuntimeTypeHandle typeHandle);
    public static bool CreateGenericInstanceDescForType(RuntimeTypeHandle typeHandle, int arity, int nonGcStaticDataSize, int nonGCStaticDataOffset, int gcStaticDataSize, int threadStaticsOffset, IntPtr gcStaticsDesc, IntPtr threadStaticsDesc, Int32[] genericVarianceFlags);
    public static int GetInterfaceCount(RuntimeTypeHandle typeHandle);
    public static RuntimeTypeHandle GetInterface(RuntimeTypeHandle typeHandle, int index);
    public static IntPtr NewInterfaceDispatchCell(RuntimeTypeHandle interfaceTypeHandle, int slotNumber);
    public static int GetValueTypeSize(RuntimeTypeHandle typeHandle);
    [IntrinsicAttribute]
public static RuntimeTypeHandle GetCanonType(CanonTypeKind kind);
    public static RuntimeTypeHandle GetGenericDefinition(RuntimeTypeHandle typeHandle);
    public static RuntimeTypeHandle GetGenericArgument(RuntimeTypeHandle typeHandle, int argumentIndex);
    public static RuntimeTypeHandle GetGenericInstantiation(RuntimeTypeHandle typeHandle, RuntimeTypeHandle[]& genericTypeArgumentHandles);
    public static bool IsGenericType(RuntimeTypeHandle typeHandle);
    public static bool IsArrayType(RuntimeTypeHandle typeHandle);
    public static bool IsByRefLike(RuntimeTypeHandle typeHandle);
    public static bool IsDynamicType(RuntimeTypeHandle typeHandle);
    public static bool HasCctor(RuntimeTypeHandle typeHandle);
    public static RuntimeTypeHandle RuntimeTypeHandleOf();
    public static IntPtr ResolveDispatchOnType(RuntimeTypeHandle instanceType, RuntimeTypeHandle interfaceType, int slot);
    public static IntPtr ResolveDispatch(object instance, RuntimeTypeHandle interfaceType, int slot);
    public static IntPtr GVMLookupForSlot(RuntimeTypeHandle type, RuntimeMethodHandle slot);
    public static bool IsUnmanagedPointerType(RuntimeTypeHandle typeHandle);
    public static bool IsByRefType(RuntimeTypeHandle typeHandle);
    public static bool IsGenericTypeDefinition(RuntimeTypeHandle typeHandle);
    public static bool CanPrimitiveWiden(RuntimeTypeHandle srcType, RuntimeTypeHandle dstType);
    public static object CheckArgument(object srcObject, RuntimeTypeHandle dstType, BinderBundle binderBundle);
    public static object CheckArgumentForDirectFieldAccess(object srcObject, RuntimeTypeHandle dstType);
    public static bool IsAssignable(object srcObject, RuntimeTypeHandle dstType);
    public static bool IsNullable(RuntimeTypeHandle declaringTypeHandle);
    public static RuntimeTypeHandle GetNullableType(RuntimeTypeHandle nullableType);
    public static string TryGetFullPathToMainApplication();
    public static string TryGetFullPathToApplicationModule(IntPtr moduleBase);
    public static int ConvertIpToRva(IntPtr ip);
    public static IntPtr GetRuntimeTypeHandleRawValue(RuntimeTypeHandle runtimeTypeHandle);
    public static IntPtr GetCodeTarget(IntPtr functionPointer);
    public static IntPtr GetTargetOfUnboxingAndInstantiatingStub(IntPtr functionPointer);
    public static IntPtr RuntimeCacheLookup(IntPtr context, IntPtr signature, RuntimeObjectFactory factory, object contextObject, IntPtr& auxResult);
    public static ReflectionExecutionDomainCallbacks get_CallbacksIfAvailable();
    public static ReflectionExecutionDomainCallbacks get_Callbacks();
    internal static TypeLoaderCallbacks get_TypeLoaderCallbacksIfAvailable();
    internal static TypeLoaderCallbacks get_TypeLoaderCallbacks();
    internal static InteropCallbacks get_InteropCallbacks();
    internal static StackTraceMetadataCallbacks get_StackTraceCallbacksIfAvailable();
    public static string TryGetMethodDisplayStringFromIp(IntPtr ip);
    public static void ReportUnhandledException(Exception exception);
    public static void GenerateExceptionInformationForDump(Exception currentException, IntPtr exceptionCCWPtr);
    public static RuntimeTypeHandle GetRuntimeTypeHandleFromObjectReference(object obj);
    public static int GetCorElementType(RuntimeTypeHandle type);
    public static void BulkMoveWithWriteBarrier(IntPtr dmem, IntPtr smem, int size);
    public static IntPtr GetUniversalTransitionThunk();
    public static object CreateThunksHeap(IntPtr commonStubAddress);
    public static IntPtr AllocateThunk(object thunksHeap);
    public static void FreeThunk(object thunksHeap, IntPtr thunkAddress);
    public static void SetThunkData(object thunksHeap, IntPtr thunkAddress, IntPtr context, IntPtr target);
    public static bool TryGetThunkData(object thunksHeap, IntPtr thunkAddress, IntPtr& context, IntPtr& target);
    public static int GetThunkSize();
    [DebuggerStepThroughAttribute]
public static void CallDescrWorker(IntPtr callDescr);
    [DebuggerStepThroughAttribute]
public static void CallDescrWorkerNative(IntPtr callDescr);
    public static Delegate CreateObjectArrayDelegate(Type delegateType, Func`2<Object[], object> invoker);
    [DebuggerGuidedStepThroughAttribute]
public static void RunFunctionWithConservativelyReportedBuffer(int cbBuffer, IntPtr pfnTargetToInvoke, T& context);
    [DebuggerGuidedStepThroughAttribute]
private static void RunFunctionWithConservativelyReportedBufferInternal(int cbBuffer, IntPtr pfnTargetToInvoke, T& context, ConservativelyReportedRegionDesc& regionDesc);
    [DebuggerGuidedStepThroughAttribute]
public static void RunFunctionWithConservativelyReportedBuffer(int cbBuffer, IntPtr pfnTargetToInvoke, T& context, U& context2);
    [DebuggerGuidedStepThroughAttribute]
private static void RunFunctionWithConservativelyReportedBufferInternal(int cbBuffer, IntPtr pfnTargetToInvoke, T& context, U& context2, ConservativelyReportedRegionDesc& regionDesc);
    public static bool FileExists(string path);
    public static string GetLastResortString(RuntimeTypeHandle typeHandle);
    public static void RhpSendCustomEventToDebugger(IntPtr payload, int length);
    [CLSCompliantAttribute("False")]
public static UInt32 RhpGetFuncEvalParameterBufferSize();
    [CLSCompliantAttribute("False")]
public static UInt32 RhpGetFuncEvalMode();
    [CLSCompliantAttribute("False")]
public static UInt32 RhpRecordDebuggeeInitiatedHandle(IntPtr objectHandle);
    public static object RhBoxAny(IntPtr pData, IntPtr pEEType);
    public static IntPtr RhHandleAlloc(object value, GCHandleType type);
    public static void RhHandleFree(IntPtr handle);
    public static IntPtr RhGetOSModuleForMrt();
    public static void RhpVerifyDebuggerCleanup();
    public static IntPtr RhpGetCurrentThread();
    public static void RhpInitiateThreadAbort(IntPtr thread, bool rude);
    public static void RhpCancelThreadAbort(IntPtr thread);
    public static void RhYield();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.Augments.RuntimeThread : object {
    private static ThreadState ThreadPoolThread;
    private static ThreadState PublicThreadStateMask;
    [ThreadStaticAttribute]
private static RuntimeThread t_currentThread;
    private ExecutionContext _executionContext;
    private SynchronizationContext _synchronizationContext;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadState;
    private ThreadPriority _priority;
    private ManagedThreadId _managedThreadId;
    private string _name;
    private Delegate _threadStart;
    private object _threadStartArg;
    private int _maxStackSize;
    private Lock _lock;
    private WaitHandleArray`1<SafeWaitHandle> _waitedSafeWaitHandles;
    internal static int OptimalMaxSpinWaitsPerSpinIteration;
    [ThreadStaticAttribute]
private static int t_currentProcessorIdCache;
    private static int ProcessorIdCacheShift;
    private static int ProcessorIdCacheCountDownMask;
    private static int ProcessorIdRefreshRate;
    [ThreadStaticAttribute]
private static int t_reentrantWaitSuppressionCount;
    [ThreadStaticAttribute]
private static ApartmentType t_apartmentType;
    private SafeWaitHandle _osHandle;
    private WaitHandleArray`1<IntPtr> _waitedHandles;
    public static RuntimeThread CurrentThread { get; }
    internal static ulong CurrentOSThreadId { get; }
    internal ExecutionContext ExecutionContext { get; internal set; }
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public bool IsThreadPoolThread { get; internal set; }
    public int ManagedThreadId { get; }
    public string Name { get; public set; }
    public ThreadPriority Priority { get; public set; }
    public ThreadState ThreadState { get; }
    internal static bool ReentrantWaitsEnabled { get; }
    private RuntimeThread(Delegate threadStart, int maxStackSize);
    private static RuntimeThread();
    public static RuntimeThread Create(ThreadStart start);
    public static RuntimeThread Create(ThreadStart start, int maxStackSize);
    public static RuntimeThread Create(ParameterizedThreadStart start);
    public static RuntimeThread Create(ParameterizedThreadStart start, int maxStackSize);
    public static RuntimeThread get_CurrentThread();
    internal static ulong get_CurrentOSThreadId();
    private static RuntimeThread InitializeExistingThread(bool threadPoolThread);
    internal static RuntimeThread InitializeThreadPoolThread();
    internal void ResetThreadPoolThread();
    internal static void RoInitialize();
    private bool HasStarted();
    internal ExecutionContext get_ExecutionContext();
    internal void set_ExecutionContext(ExecutionContext value);
    internal SynchronizationContext get_SynchronizationContext();
    internal void set_SynchronizationContext(SynchronizationContext value);
    public bool get_IsAlive();
    private bool IsDead();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    public bool get_IsThreadPoolThread();
    internal void set_IsThreadPoolThread(bool value);
    public int get_ManagedThreadId();
    public string get_Name();
    public void set_Name(string value);
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    public ThreadState get_ThreadState();
    private bool GetThreadStateBit(ThreadState bit);
    private void SetThreadStateBit(ThreadState bit);
    private void ClearThreadStateBit(ThreadState bit);
    internal void SetWaitSleepJoinState();
    internal void ClearWaitSleepJoinState();
    private static int VerifyTimeoutMilliseconds(int millisecondsTimeout);
    public void Join();
    public bool Join(int millisecondsTimeout);
    public static void Sleep(int millisecondsTimeout);
    public static void SpinWait(int iterations);
    public static bool Yield();
    public void Start();
    public void Start(object parameter);
    private void StartInternal(object parameter);
    private static void StartThread(IntPtr parameter);
    private static int RefreshCurrentProcessorId();
    public static int GetCurrentProcessorId();
    private void PlatformSpecificInitialize();
    private void PlatformSpecificInitializeExistingThread();
    internal SafeWaitHandle[] RentWaitedSafeWaitHandleArray(int requiredCapacity);
    internal void ReturnWaitedSafeWaitHandleArray(SafeWaitHandle[] waitedSafeWaitHandles);
    internal IntPtr[] RentWaitedHandleArray(int requiredCapacity);
    internal void ReturnWaitedHandleArray(IntPtr[] waitedHandles);
    private static SafeWaitHandle GetOSHandleForCurrentThread();
    private static ThreadPriority MapFromOSPriority(ThreadPriority priority);
    private static ThreadPriority MapToOSPriority(ThreadPriority priority);
    private ThreadPriority GetPriorityLive();
    private bool SetPriorityLive(ThreadPriority priority);
    private ThreadState GetThreadState();
    private bool JoinInternal(int millisecondsTimeout);
    private bool CreateThread(GCHandle thisThreadHandle);
    [NativeCallableAttribute]
private static UInt32 ThreadEntryPoint(IntPtr parameter);
    public ApartmentState GetApartmentState();
    public bool TrySetApartmentState(ApartmentState state);
    public void DisableComObjectEagerCleanup();
    public void Interrupt();
    internal static void UninterruptibleSleep0();
    private static void SleepInternal(int millisecondsTimeout);
    internal static void SuppressReentrantWaits();
    internal static void RestoreReentrantWaits();
    internal static bool get_ReentrantWaitsEnabled();
    internal static ApartmentType GetCurrentApartmentType();
    private static int ComputeCurrentProcessorId();
}
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.Augments.SpinLockTraceCallbacks : object {
    public bool Enabled { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void SpinLock_FastPathFailed(int ownerID);
}
[ReflectionBlockedAttribute]
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.Augments.StackTraceMetadataCallbacks : object {
    public abstract virtual string TryGetMethodNameFromStartAddress(IntPtr methodStartAddress);
}
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.Augments.TaskTraceCallbacks : object {
    public bool Enabled { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
    public abstract virtual void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public abstract virtual void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
}
[CLSCompliantAttribute("False")]
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.Augments.TypeLoaderCallbacks : object {
    public abstract virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public abstract virtual int GetThreadStaticsSizeForDynamicType(int index, Int32& numTlsCells);
    public abstract virtual IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    public abstract virtual bool GetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public abstract virtual bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public abstract virtual IntPtr GetDelegateThunk(Delegate delegateObject, int thunkKind);
    public abstract virtual IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    public abstract virtual bool TryGetGenericVirtualTargetForTypeAndSlot(RuntimeTypeHandle targetHandle, RuntimeTypeHandle& declaringType, RuntimeTypeHandle[] genericArguments, String& methodName, RuntimeSignature& methodSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer, Boolean& slotUpdated);
    public abstract virtual bool GetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public abstract virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public abstract virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public abstract virtual IntPtr UpdateFloatingDictionary(IntPtr context, IntPtr dictionaryPtr);
    public abstract virtual void RegisterThunk(IntPtr thunkAddress);
    public abstract virtual IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.CanonTypeKind : Enum {
    public int value__;
    public static CanonTypeKind NormalCanon;
    public static CanonTypeKind UniversalCanon;
}
internal static class Internal.Runtime.CompilerHelpers.DelegateHelpers : object {
    private static Object[] s_emptyObjectArray;
    private static DelegateHelpers();
    internal static Object[] GetEmptyObjectArray();
}
internal class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerHelpers.MathHelpers : object {
    private static string RuntimeLibrary;
    private static ulong Mul32x32To64(UInt32 a, UInt32 b);
    private static UInt32 Hi32Bits(long a);
    private static UInt32 Hi32Bits(ulong a);
    [RuntimeExportAttribute("LMulOvf")]
public static long LMulOvf(long i, long j);
    [RuntimeExportAttribute("ULMulOvf")]
public static ulong ULMulOvf(ulong i, ulong j);
    [RuntimeExportAttribute("Dbl2IntOvf")]
public static int Dbl2IntOvf(double val);
    [RuntimeExportAttribute("Dbl2UIntOvf")]
public static UInt32 Dbl2UIntOvf(double val);
    [RuntimeExportAttribute("Dbl2LngOvf")]
public static long Dbl2LngOvf(double val);
    [RuntimeExportAttribute("Dbl2ULngOvf")]
public static ulong Dbl2ULngOvf(double val);
    [RuntimeExportAttribute("Flt2IntOvf")]
public static int Flt2IntOvf(float val);
    [RuntimeExportAttribute("Flt2LngOvf")]
public static long Flt2LngOvf(float val);
    [RuntimeImportAttribute("[MRT]", "RhpIDiv")]
private static int RhpIDiv(int i, int j);
    public static int IDiv(int i, int j);
    [RuntimeImportAttribute("[MRT]", "RhpUDiv")]
private static UInt32 RhpUDiv(UInt32 i, UInt32 j);
    public static long UDiv(UInt32 i, UInt32 j);
    [RuntimeImportAttribute("[MRT]", "RhpULDiv")]
private static ulong RhpULDiv(ulong i, ulong j);
    public static ulong ULDiv(ulong i, ulong j);
    [RuntimeImportAttribute("[MRT]", "RhpLDiv")]
private static long RhpLDiv(long i, long j);
    public static long LDiv(long i, long j);
    [RuntimeImportAttribute("[MRT]", "RhpIMod")]
private static int RhpIMod(int i, int j);
    public static int IMod(int i, int j);
    [RuntimeImportAttribute("[MRT]", "RhpUMod")]
private static UInt32 RhpUMod(UInt32 i, UInt32 j);
    public static long UMod(UInt32 i, UInt32 j);
    [RuntimeImportAttribute("[MRT]", "RhpULMod")]
private static ulong RhpULMod(ulong i, ulong j);
    public static ulong ULMod(ulong i, ulong j);
    [RuntimeImportAttribute("[MRT]", "RhpLMod")]
private static long RhpLMod(long i, long j);
    public static long LMod(long i, long j);
    private static int ThrowIntOvf();
    private static UInt32 ThrowUIntOvf();
    private static long ThrowLngOvf();
    private static ulong ThrowULngOvf();
    private static int ThrowIntDivByZero();
    private static UInt32 ThrowUIntDivByZero();
    private static long ThrowLngDivByZero();
    private static ulong ThrowULngDivByZero();
    private static int ThrowIntArithExc();
    private static long ThrowLngArithExc();
}
internal static class Internal.Runtime.CompilerHelpers.ReflectionHelpers : object {
    public static Type GetType(string typeName, string callingAssemblyName, bool throwOnError, bool ignoreCase);
    public static Type ExtensibleGetType(string typeName, string callingAssemblyName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    [DependencyReductionRootAttribute]
public static Assembly GetExecutingAssembly(RuntimeTypeHandle typeHandle);
    [DependencyReductionRootAttribute]
public static MethodBase GetCurrentMethodNonGeneric(RuntimeMethodHandle methodHandle);
    [DependencyReductionRootAttribute]
public static MethodBase GetCurrentMethodGeneric(RuntimeMethodHandle methodHandle, RuntimeTypeHandle typeHandle);
}
[McgIntrinsicsAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerHelpers.StartupCodeHelpers : object {
    private static string s_entryAssemblyName;
    private static int InitialModuleCount;
    private static TypeManagerHandle[] s_modules;
    private static int s_moduleCount;
    public static void InitializeEntryAssembly(string assemblyName);
    internal static Assembly GetEntryAssembly();
    [NativeCallableAttribute]
internal static void InitializeModules(IntPtr osModule, IntPtr* pModuleHeaders, int count, IntPtr* pClasslibFunctions, int nClasslibFunctions);
    internal static int GetLoadedModules(TypeManagerHandle[] outputModules);
    private static void AddModule(TypeManagerHandle newModuleHandle);
    private static TypeManagerHandle[] CreateTypeManagers(IntPtr osModule, IntPtr* pModuleHeaders, int count, IntPtr* pClasslibFunctions, int nClasslibFunctions);
    private static void InitializeGlobalTablesForModule(TypeManagerHandle typeManager, int moduleIndex);
    private static void InitializeFrozenObjectSegment(IntPtr segmentStart, int length);
    private static void InitializeEagerClassConstructorsForModule(TypeManagerHandle typeManager);
    private static void Call(IntPtr pfn);
    private static void RunEagerClassConstructors(IntPtr cctorTableStart, int length);
    private static void InitializeImports(IntPtr importsRegionStart, int length);
    public static void RegisterModuleFromPointer(IntPtr pointerWithinModule);
}
internal static class Internal.Runtime.CompilerHelpers.StartupDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerHelpers.ThreadingHelpers : object {
    public static void CallOnce(Action callOnceAction, Int32& callOnceGuard);
}
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerHelpers.ThrowHelpers : object {
    public static void ThrowOverflowException();
    public static void ThrowIndexOutOfRangeException();
    public static void ThrowNullReferenceException();
    public static void ThrowDivideByZeroException();
    public static void ThrowArrayTypeMismatchException();
    public static void ThrowPlatformNotSupportedException();
    public static void ThrowNotSupportedException();
    public static void ThrowBadImageFormatException(ExceptionStringID id);
    public static void ThrowTypeLoadException(ExceptionStringID id, string className, string typeName);
    public static void ThrowTypeLoadExceptionWithArgument(ExceptionStringID id, string className, string typeName, string messageArg);
    public static void ThrowMissingMethodException(ExceptionStringID id, string methodName);
    public static void ThrowMissingFieldException(ExceptionStringID id, string fieldName);
    public static void ThrowFileNotFoundException(ExceptionStringID id, string fileName);
    public static void ThrowInvalidProgramException(ExceptionStringID id);
    public static void ThrowInvalidProgramExceptionWithArgument(ExceptionStringID id, string methodName);
    public static void ThrowArgumentException();
    public static void ThrowArgumentOutOfRangeException();
}
internal class Internal.Runtime.CompilerHelpers.TypeManagerSlot : ValueType {
    public TypeManagerHandle TypeManager;
    public int ModuleIndex;
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.FixupRuntimeTypeHandle : ValueType {
    private IntPtr _value;
    public RuntimeTypeHandle RuntimeTypeHandle { get; }
    public FixupRuntimeTypeHandle(RuntimeTypeHandle runtimeTypeHandle);
    public RuntimeTypeHandle get_RuntimeTypeHandle();
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerServices.FunctionPointerOps : object {
    private static UInt32 s_genericFunctionPointerNextIndex;
    private static UInt32 c_genericDictionaryChunkSize;
    private static LowLevelList`1<IntPtr> s_genericFunctionPointerCollection;
    private static LowLevelDictionary`2<GenericMethodDescriptorInfo, UInt32> s_genericFunctionPointerDictionary;
    private static FunctionPointerOps();
    public static IntPtr GetGenericMethodFunctionPointer(IntPtr canonFunctionPointer, IntPtr instantiationArgument);
    public static bool IsGenericMethodPointer(IntPtr functionPointer);
    [CLSCompliantAttribute("False")]
public static GenericMethodDescriptor* ConvertToGenericDescriptor(IntPtr functionPointer);
    public static bool Compare(IntPtr functionPointerA, IntPtr functionPointerB);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.GenericMethodDescriptor : ValueType {
    internal IntPtr _MethodFunctionPointer;
    internal IntPtr* _MethodDictionaryPointerPointer;
    public IntPtr MethodFunctionPointer { get; }
    public IntPtr InstantiationArgument { get; }
    public IntPtr get_MethodFunctionPointer();
    public IntPtr get_InstantiationArgument();
}
internal static class Internal.Runtime.CompilerServices.GenericVirtualMethodSupport : object {
    private static IntPtr GVMLookupForSlotWorker(RuntimeTypeHandle type, RuntimeTypeHandle declaringType, RuntimeTypeHandle[] genericArguments, MethodNameAndSignature methodNameAndSignature);
    internal static IntPtr GVMLookupForSlot(RuntimeTypeHandle type, RuntimeMethodHandle slot);
}
[AttributeUsageAttribute("1")]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Internal.Runtime.CompilerServices.HasEmbeddedStringResourcesAttribute : Attribute {
}
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.MethodNameAndSignature : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeSignature <Signature>k__BackingField;
    public string Name { get; private set; }
    public RuntimeSignature Signature { get; private set; }
    public MethodNameAndSignature(string name, RuntimeSignature signature);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public RuntimeSignature get_Signature();
    [CompilerGeneratedAttribute]
private void set_Signature(RuntimeSignature value);
    public virtual bool Equals(object compare);
    public virtual int GetHashCode();
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.OpenMethodResolver : ValueType {
    public static short DispatchResolve;
    public static short GVMResolve;
    public static short OpenNonVirtualResolve;
    public static short OpenNonVirtualResolveLookthruUnboxing;
    private short _resolveType;
    private GCHandle _readerGCHandle;
    private int _handle;
    private IntPtr _methodHandleOrSlotOrCodePointer;
    private IntPtr _nonVirtualOpenInvokeCodePointer;
    private EETypePtr _declaringType;
    private static LowLevelDictionary`2<OpenMethodResolver, IntPtr> s_internedResolverHash;
    public short ResolverType { get; }
    public RuntimeTypeHandle DeclaringType { get; }
    public RuntimeMethodHandle GVMMethodHandle { get; }
    public bool IsOpenNonVirtualResolve { get; }
    public IntPtr CodePointer { get; }
    public object Reader { get; }
    public int Handle { get; }
    public OpenMethodResolver(RuntimeTypeHandle declaringTypeOfSlot, int slot, GCHandle readerGCHandle, int handle);
    public OpenMethodResolver(RuntimeTypeHandle declaringTypeOfSlot, RuntimeMethodHandle gvmSlot, GCHandle readerGCHandle, int handle);
    public OpenMethodResolver(RuntimeTypeHandle declaringType, IntPtr codePointer, GCHandle readerGCHandle, int handle);
    public OpenMethodResolver(RuntimeTypeHandle declaringType, IntPtr codePointer, GCHandle readerGCHandle, int handle, short resolveType);
    private static OpenMethodResolver();
    public short get_ResolverType();
    public RuntimeTypeHandle get_DeclaringType();
    public RuntimeMethodHandle get_GVMMethodHandle();
    public bool get_IsOpenNonVirtualResolve();
    public IntPtr get_CodePointer();
    public object get_Reader();
    public int get_Handle();
    private IntPtr ResolveMethod(object thisObject);
    internal static IntPtr ResolveMethodWorker(IntPtr resolver, object thisObject);
    public static IntPtr ResolveMethod(IntPtr resolver, object thisObject);
    private static int _rotl(int value, int shift);
    private static int CalcHashCode(int hashCode1, int hashCode2, int hashCode3, int hashCode4);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(OpenMethodResolver other);
    public virtual bool Equals(object obj);
    public IntPtr ToIntPtr();
}
[AttributeUsageAttribute("5148")]
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.RelocatedTypeAttribute : Attribute {
    public RelocatedTypeAttribute(string originalAssemblySimpleName);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.RuntimeFieldHandleInfo : ValueType {
    public IntPtr NativeLayoutInfoSignature;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.RuntimeMethodHandleInfo : ValueType {
    public IntPtr NativeLayoutInfoSignature;
    public static RuntimeMethodHandle InfoToHandle(RuntimeMethodHandleInfo* info);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerServices.RuntimeSignature : ValueType {
    private IntPtr _moduleHandle;
    private int _tokenOrOffset;
    private bool _isNativeLayoutSignature;
    public bool IsNativeLayoutSignature { get; }
    public int Token { get; }
    [CLSCompliantAttribute("False")]
public UInt32 NativeLayoutOffset { get; }
    public IntPtr ModuleHandle { get; }
    [CLSCompliantAttribute("False")]
public static RuntimeSignature CreateFromNativeLayoutSignature(TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset);
    [CLSCompliantAttribute("False")]
public static RuntimeSignature CreateFromNativeLayoutSignature(RuntimeSignature oldSignature, UInt32 newNativeLayoutOffset);
    public static RuntimeSignature CreateFromMethodHandle(TypeManagerHandle moduleHandle, int token);
    public static RuntimeSignature CreateFromMethodHandle(IntPtr moduleHandle, int token);
    [CLSCompliantAttribute("False")]
public static RuntimeSignature CreateFromNativeLayoutSignatureForDebugger(UInt32 nativeLayoutOffset);
    public bool get_IsNativeLayoutSignature();
    public int get_Token();
    public UInt32 get_NativeLayoutOffset();
    public IntPtr get_ModuleHandle();
    public bool Equals(RuntimeSignature other);
    public bool StructuralEquals(RuntimeSignature other);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerServices.Unsafe : object {
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int SizeOf();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T As(object value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* Add(Void* source, int elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
internal static T& AddByteOffset(T& source, UInt32 byteOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool AreSame(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T ReadUnaligned(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void WriteUnaligned(Void* destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T Read(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T Read(Byte& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Void* destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Byte& destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AsRef(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AsRef(T& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
}
internal enum Internal.Runtime.CorElementType : Enum {
    public int value__;
    public static CorElementType ELEMENT_TYPE_END;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
}
[DefaultMemberAttribute("Item")]
internal class Internal.Runtime.DispatchMap : ValueType {
    private UInt32 _entryCount;
    private DispatchMapEntry _dispatchMap;
    public bool IsEmpty { get; }
    public UInt32 NumEntries { get; }
    public int Size { get; }
    public DispatchMapEntry* Item { get; }
    public bool get_IsEmpty();
    public UInt32 get_NumEntries();
    public int get_Size();
    public DispatchMapEntry* get_Item(int index);
}
internal class Internal.Runtime.DynamicModule : ValueType {
    private int _cbSize;
    private IntPtr _dynamicTypeSlotDispatchResolve;
    private IntPtr _getRuntimeException;
    public IntPtr DynamicTypeSlotDispatchResolve { get; }
    public IntPtr GetRuntimeException { get; }
    public IntPtr get_DynamicTypeSlotDispatchResolve();
    public IntPtr get_GetRuntimeException();
}
internal class Internal.Runtime.EEInterfaceInfo : ValueType {
    private InterfaceTypeUnion _interfaceType;
    internal EEType* InterfaceType { get; }
    internal EEType* get_InterfaceType();
}
internal class Internal.Runtime.EEType : ValueType {
    private static int POINTER_SIZE;
    private static int PADDING;
    internal static int SZARRAY_BASE_SIZE;
    private ushort _usComponentSize;
    private ushort _usFlags;
    private UInt32 _uBaseSize;
    private RelatedTypeUnion _relatedType;
    private ushort _usNumVtableSlots;
    private ushort _usNumInterfaces;
    private UInt32 _uHashCode;
    private IntPtr _ppTypeManager;
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    internal static bool SupportsRelativePointers { get; }
    internal ushort ComponentSize { get; }
    internal ushort GenericArgumentCount { get; }
    internal ushort Flags { get; }
    internal UInt32 BaseSize { get; }
    internal ushort NumVtableSlots { get; }
    internal ushort NumInterfaces { get; }
    internal UInt32 HashCode { get; }
    private EETypeKind Kind { get; }
    internal bool HasOptionalFields { get; }
    internal bool HasGenericVariance { get; }
    internal bool IsFinalizable { get; }
    internal bool IsNullable { get; }
    internal bool IsCloned { get; }
    internal bool IsCanonical { get; }
    internal bool IsString { get; }
    internal bool IsArray { get; }
    internal int ArrayRank { get; }
    internal bool IsSzArray { get; }
    internal bool IsGeneric { get; }
    internal bool IsGenericTypeDefinition { get; }
    internal EEType* GenericDefinition { get; }
    internal UInt32 GenericArity { get; }
    internal EETypeRef* GenericArguments { get; }
    internal GenericVariance* GenericVariance { get; }
    internal bool IsPointerType { get; }
    internal bool IsByRefType { get; }
    internal bool IsInterface { get; }
    internal bool IsAbstract { get; }
    internal bool IsByRefLike { get; }
    internal bool IsDynamicType { get; }
    internal bool HasDynamicallyAllocatedDispatchMap { get; }
    internal bool IsNullableTypeViaIAT { get; }
    internal bool IsParameterizedType { get; }
    internal UInt32 ParameterizedTypeShape { get; }
    internal bool IsRelatedTypeViaIAT { get; }
    internal bool RequiresAlign8 { get; }
    internal bool IsICastable { get; }
    internal IntPtr ICastableIsInstanceOfInterfaceMethod { get; }
    internal IntPtr ICastableGetImplTypeMethod { get; }
    internal bool IsValueType { get; }
    internal bool HasGCPointers { get; }
    internal bool IsHFA { get; }
    internal UInt32 ValueTypeFieldPadding { get; }
    internal UInt32 ValueTypeSize { get; }
    internal UInt32 FieldByteCountNonGCAligned { get; }
    internal EEInterfaceInfo* InterfaceMap { get; }
    internal bool HasDispatchMap { get; }
    internal IntPtr FinalizerCode { get; }
    internal EEType* BaseType { get; }
    internal EEType* NonArrayBaseType { get; }
    internal EEType* NonClonedNonArrayBaseType { get; }
    internal EEType* RawBaseType { get; }
    internal EEType* CanonicalEEType { get; }
    internal EEType* NullableType { get; }
    internal byte NullableValueOffset { get; }
    internal EEType* RelatedParameterType { get; }
    internal Byte* OptionalFieldsPtr { get; }
    internal EEType* DynamicTemplateType { get; }
    internal IntPtr DynamicGcStaticsData { get; }
    internal IntPtr DynamicNonGcStaticsData { get; }
    internal DynamicModule* DynamicModule { get; }
    internal IntPtr TypeManager { get; }
    internal EETypeRareFlags RareFlags { get; }
    internal int FieldAlignmentRequirement { get; }
    internal CorElementType CorElementType { get; }
    public bool HasCctor { get; }
    internal EEType* GetArrayEEType();
    [IntrinsicAttribute]
internal static bool get_SupportsRelativePointers();
    internal ushort get_ComponentSize();
    internal ushort get_GenericArgumentCount();
    internal ushort get_Flags();
    internal UInt32 get_BaseSize();
    internal ushort get_NumVtableSlots();
    internal ushort get_NumInterfaces();
    internal UInt32 get_HashCode();
    private EETypeKind get_Kind();
    internal bool get_HasOptionalFields();
    internal bool get_HasGenericVariance();
    internal bool get_IsFinalizable();
    internal bool get_IsNullable();
    internal bool get_IsCloned();
    internal bool get_IsCanonical();
    internal bool get_IsString();
    internal bool get_IsArray();
    internal int get_ArrayRank();
    internal bool get_IsSzArray();
    internal bool get_IsGeneric();
    internal bool get_IsGenericTypeDefinition();
    internal EEType* get_GenericDefinition();
    internal UInt32 get_GenericArity();
    internal EETypeRef* get_GenericArguments();
    internal GenericVariance* get_GenericVariance();
    internal bool get_IsPointerType();
    internal bool get_IsByRefType();
    internal bool get_IsInterface();
    internal bool get_IsAbstract();
    internal bool get_IsByRefLike();
    internal bool get_IsDynamicType();
    internal bool get_HasDynamicallyAllocatedDispatchMap();
    internal bool get_IsNullableTypeViaIAT();
    internal bool get_IsParameterizedType();
    internal UInt32 get_ParameterizedTypeShape();
    internal bool get_IsRelatedTypeViaIAT();
    internal bool get_RequiresAlign8();
    internal bool get_IsICastable();
    internal IntPtr get_ICastableIsInstanceOfInterfaceMethod();
    internal IntPtr get_ICastableGetImplTypeMethod();
    internal bool get_IsValueType();
    internal bool get_HasGCPointers();
    internal bool get_IsHFA();
    internal UInt32 get_ValueTypeFieldPadding();
    internal UInt32 get_ValueTypeSize();
    internal UInt32 get_FieldByteCountNonGCAligned();
    internal EEInterfaceInfo* get_InterfaceMap();
    internal bool get_HasDispatchMap();
    internal IntPtr get_FinalizerCode();
    internal EEType* get_BaseType();
    internal EEType* get_NonArrayBaseType();
    internal EEType* get_NonClonedNonArrayBaseType();
    internal EEType* get_RawBaseType();
    internal EEType* get_CanonicalEEType();
    internal EEType* get_NullableType();
    internal byte get_NullableValueOffset();
    internal EEType* get_RelatedParameterType();
    internal IntPtr* GetVTableStartAddress();
    private static IntPtr FollowRelativePointer(Int32* pDist);
    internal IntPtr GetSealedVirtualSlot(ushort slotNumber);
    internal Byte* get_OptionalFieldsPtr();
    internal EEType* get_DynamicTemplateType();
    internal IntPtr get_DynamicGcStaticsData();
    internal IntPtr get_DynamicNonGcStaticsData();
    internal DynamicModule* get_DynamicModule();
    internal IntPtr get_TypeManager();
    internal EETypeRareFlags get_RareFlags();
    internal int get_FieldAlignmentRequirement();
    internal CorElementType get_CorElementType();
    public bool get_HasCctor();
    public UInt32 GetFieldOffset(EETypeField eField);
    public T& GetField(EETypeField eField);
}
internal enum Internal.Runtime.EETypeField : Enum {
    public int value__;
    public static EETypeField ETF_InterfaceMap;
    public static EETypeField ETF_Finalizer;
    public static EETypeField ETF_OptionalFieldsPtr;
    public static EETypeField ETF_NullableType;
    public static EETypeField ETF_SealedVirtualSlots;
    public static EETypeField ETF_DynamicTemplateType;
    public static EETypeField ETF_DynamicDispatchMap;
    public static EETypeField ETF_DynamicModule;
    public static EETypeField ETF_GenericDefinition;
    public static EETypeField ETF_GenericComposition;
    public static EETypeField ETF_DynamicGcStatics;
    public static EETypeField ETF_DynamicNonGcStatics;
    public static EETypeField ETF_DynamicThreadStaticOffset;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeFlags : Enum {
    public ushort value__;
    public static EETypeFlags EETypeKindMask;
    public static EETypeFlags RelatedTypeViaIATFlag;
    public static EETypeFlags ValueTypeFlag;
    public static EETypeFlags HasFinalizerFlag;
    public static EETypeFlags HasPointersFlag;
    public static EETypeFlags ICastableFlag;
    public static EETypeFlags GenericVarianceFlag;
    public static EETypeFlags OptionalFieldsFlag;
    public static EETypeFlags IsInterfaceFlag;
    public static EETypeFlags IsGenericFlag;
    public static EETypeFlags CorElementTypeMask;
    public static EETypeFlags CorElementTypeShift;
    public static EETypeFlags ComplexCastingMask;
}
internal enum Internal.Runtime.EETypeKind : Enum {
    public ushort value__;
    public static EETypeKind CanonicalEEType;
    public static EETypeKind ClonedEEType;
    public static EETypeKind ParameterizedEEType;
    public static EETypeKind GenericTypeDefEEType;
}
internal enum Internal.Runtime.EETypeOptionalFieldTag : Enum {
    public byte value__;
    public static EETypeOptionalFieldTag RareFlags;
    public static EETypeOptionalFieldTag ICastableIsInstSlot;
    public static EETypeOptionalFieldTag DispatchMap;
    public static EETypeOptionalFieldTag ValueTypeFieldPadding;
    public static EETypeOptionalFieldTag ICastableGetImplTypeSlot;
    public static EETypeOptionalFieldTag NullableValueOffset;
    public static EETypeOptionalFieldTag Count;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeRareFlags : Enum {
    public int value__;
    public static EETypeRareFlags RequiresAlign8Flag;
    public static EETypeRareFlags UNUSED1;
    public static EETypeRareFlags IsNullableFlag;
    public static EETypeRareFlags NullableTypeViaIATFlag;
    public static EETypeRareFlags IsDynamicTypeFlag;
    public static EETypeRareFlags HasCctorFlag;
    public static EETypeRareFlags UNUSED2;
    public static EETypeRareFlags HasDynamicallyAllocatedDispatchMapFlag;
    public static EETypeRareFlags IsHFAFlag;
    public static EETypeRareFlags HasSealedVTableEntriesFlag;
    public static EETypeRareFlags IsDynamicTypeWithGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithNonGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithThreadStatics;
    public static EETypeRareFlags HasDynamicModuleFlag;
    public static EETypeRareFlags IsAbstractClassFlag;
    public static EETypeRareFlags IsByRefLikeFlag;
}
internal class Internal.Runtime.EETypeRef : ValueType {
    private Byte* _value;
    public EEType* Value { get; }
    public EEType* get_Value();
}
internal static class Internal.Runtime.FatFunctionPointerConstants : object {
    public static int Offset;
}
internal static class Internal.Runtime.GCStaticRegionConstants : object {
    public static int Uninitialized;
    public static int HasPreInitializedData;
    public static int Mask;
}
internal enum Internal.Runtime.GenericVariance : Enum {
    public byte value__;
    public static GenericVariance NonVariant;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
    public static GenericVariance ArrayCovariant;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwarePointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwareRelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal static class Internal.Runtime.IndirectionConstants : object {
    public static int IndirectionCellPointer;
    public static UInt32 RVAPointsToIndirection;
}
[ExtensionAttribute]
internal static class Internal.Runtime.LowLevelStringConverter : object {
    private static string HexDigits;
    [ExtensionAttribute]
public static string LowLevelToString(int arg);
    [ExtensionAttribute]
public static string LowLevelToString(UInt32 arg);
    [ExtensionAttribute]
public static string LowLevelToString(IntPtr arg);
}
[FlagsAttribute]
internal enum Internal.Runtime.ModuleInfoFlags : Enum {
    public int value__;
    public static ModuleInfoFlags HasEndPointer;
}
internal class Internal.Runtime.ObjHeader : ValueType {
    private IntPtr _objHeaderContents;
}
internal static class Internal.Runtime.ParameterizedTypeShapeConstants : object {
    public static int Pointer;
    public static int ByRef;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.Pointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
internal class Internal.Runtime.ReadyToRunHeader : ValueType {
    private UInt32 Signature;
    private ushort MajorVersion;
    private ushort MinorVersion;
    private UInt32 Flags;
    private ushort NumberOfSections;
    private byte EntrySize;
    private byte EntryType;
}
internal class Internal.Runtime.ReadyToRunHeaderConstants : ValueType {
    public static UInt32 Signature;
    public static ushort CurrentMajorVersion;
    public static ushort CurrentMinorVersion;
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.ReadyToRunSectionType : Enum {
    public int value__;
    public static ReadyToRunSectionType StringTable;
    public static ReadyToRunSectionType GCStaticRegion;
    public static ReadyToRunSectionType ThreadStaticRegion;
    public static ReadyToRunSectionType InterfaceDispatchTable;
    public static ReadyToRunSectionType TypeManagerIndirection;
    public static ReadyToRunSectionType EagerCctor;
    public static ReadyToRunSectionType FrozenObjectRegion;
    public static ReadyToRunSectionType GCStaticDesc;
    public static ReadyToRunSectionType ThreadStaticOffsetRegion;
    public static ReadyToRunSectionType ThreadStaticGCDescRegion;
    public static ReadyToRunSectionType ThreadStaticIndex;
    public static ReadyToRunSectionType LoopHijackFlag;
    public static ReadyToRunSectionType ImportAddressTables;
    public static ReadyToRunSectionType ReadonlyBlobRegionStart;
    public static ReadyToRunSectionType ReadonlyBlobRegionEnd;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.RelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal static class Internal.Runtime.StringComponentSize : object {
    public static int Value;
}
internal static class Internal.Runtime.TypeLoaderExceptionHelper : object {
    public static Exception CreateBadImageFormatException(ExceptionStringID id);
    public static Exception CreateTypeLoadException(ExceptionStringID id, string typeName, string moduleName);
    public static Exception CreateTypeLoadException(ExceptionStringID id, string typeName, string moduleName, string messageArg);
    public static Exception CreateMissingFieldException(ExceptionStringID id, string fieldName);
    public static Exception CreateMissingMethodException(ExceptionStringID id, string methodName);
    public static Exception CreateFileNotFoundException(ExceptionStringID id, string fileName);
    public static Exception CreateInvalidProgramException(ExceptionStringID id);
    public static Exception CreateInvalidProgramException(ExceptionStringID id, string methodName);
    private static string GetFormatString(ExceptionStringID id);
}
[__BlockReflectionAttribute]
public static class Internal.Threading.Tasks.AsyncCausalitySupport : object {
    public static bool LoggingOn { get; }
    public static void AddToActiveTasks(Task task);
    public static void RemoveFromActiveTasks(Task task);
    public static bool get_LoggingOn();
    public static void TraceOperationCreation(Task task, string operationName);
    public static void TraceOperationCompletedSuccess(Task task);
    public static void TraceOperationCompletedError(Task task);
}
[__BlockReflectionAttribute]
public static class Internal.Threading.Tasks.Tracing.TaskTrace : object {
    private static TaskTraceCallbacks s_callbacks;
    public static bool Enabled { get; }
    public static bool get_Enabled();
    public static void Initialize(TaskTraceCallbacks callbacks);
    public static void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
    public static void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    public static void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
}
[__BlockReflectionAttribute]
public static class Internal.Threading.Tracing.SpinLockTrace : object {
    private static SpinLockTraceCallbacks s_callbacks;
    public static bool Enabled { get; }
    public static bool get_Enabled();
    public static void Initialize(SpinLockTraceCallbacks callbacks);
    public static void SpinLock_FastPathFailed(int ownerID);
}
[DependencyReductionRootAttribute]
[AttributeUsageAttribute("32767")]
[__BlockReflectionAttribute]
public class Internal.Toolchain.NonExecutableAttribute : Attribute {
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.ExceptionStringID : Enum {
    public int value__;
    public static ExceptionStringID ClassLoadGeneral;
    public static ExceptionStringID ClassLoadExplicitGeneric;
    public static ExceptionStringID ClassLoadBadFormat;
    public static ExceptionStringID ClassLoadExplicitLayout;
    public static ExceptionStringID ClassLoadValueClassTooLarge;
    public static ExceptionStringID ClassLoadRankTooLarge;
    public static ExceptionStringID MissingMethod;
    public static ExceptionStringID MissingField;
    public static ExceptionStringID FileLoadErrorGeneric;
    public static ExceptionStringID InvalidProgramDefault;
    public static ExceptionStringID InvalidProgramSpecific;
    public static ExceptionStringID InvalidProgramVararg;
    public static ExceptionStringID InvalidProgramCallVirtFinalize;
    public static ExceptionStringID InvalidProgramNativeCallable;
    public static ExceptionStringID BadImageFormatGeneric;
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.LockFreeReaderHashtable`2 : object {
    private static int _initialSize;
    private static int _fillPercentageBeforeResize;
    private TValue[] modreq(System.Runtime.CompilerServices.IsVolatile) _hashtable;
    private TValue[] modreq(System.Runtime.CompilerServices.IsVolatile) _newHashTable;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _count;
    private int _reserve;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _resizeCount;
    public int Count { get; }
    private TValue[] GetCurrentHashtable();
    private void SetCurrentHashtable(TValue[] hashtable);
    public static int HashInt1(int key);
    public static int HashInt2(int key);
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    private void Expand(TValue[] oldHashtable);
    public bool TryAdd(TValue value);
    public TValue AddOrGetExisting(TValue value);
    private TValue AddOrGetExistingInner(TValue value, Boolean& addedValue);
    private TValue TryAddOrGetExisting(TValue value, Boolean& addedValue);
    private bool TryWriteValueToLocation(TValue value, TValue[] hashTableLocal, int tableIndex);
    private TValue CreateValueAndEnsureValueIsInTable(TKey key);
    public TValue GetOrCreateValue(TKey key);
    public bool Contains(TKey key);
    public TValue GetValueIfExists(TValue value);
    protected abstract virtual int GetKeyHashCode(TKey key);
    protected abstract virtual int GetValueHashCode(TValue value);
    protected abstract virtual bool CompareKeyToValue(TKey key, TValue value);
    protected abstract virtual bool CompareValueToValue(TValue value1, TValue value2);
    protected abstract virtual TValue CreateValueFromKey(TKey key);
}
internal static class Interop : object {
    internal static IntPtr InvalidHandleValue { get; }
    internal static void GetRandomBytes(Byte* buffer, int length);
    internal static IntPtr get_InvalidHandleValue();
    internal static IntPtr MemAlloc(UIntPtr sizeInBytes);
    internal static void MemFree(IntPtr allocatedMemory);
    internal static IntPtr MemReAlloc(IntPtr ptr, UIntPtr newSize);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static MethodInfo[] GetMethods(Type type, BindingFlags flags);
    [ExtensionAttribute]
public static FieldInfo[] GetFields(Type type, BindingFlags flags);
    [ExtensionAttribute]
public static Type GetNestedType(Type type, string nestedTypeName);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static object GetRawConstantValue(FieldInfo fi);
    [ExtensionAttribute]
public static bool ReflectionOnly(Assembly assm);
}
internal static class Microsoft.Win32.Registry : object {
    public static RegistryKey CurrentUser;
    public static RegistryKey LocalMachine;
    public static RegistryKey ClassesRoot;
    public static RegistryKey Users;
    public static RegistryKey PerformanceData;
    public static RegistryKey CurrentConfig;
    private static Registry();
    private static RegistryKey GetBaseKeyFromKeyName(string keyName, String& subKeyName);
    public static object GetValue(string keyName, string valueName, object defaultValue);
    public static void SetValue(string keyName, string valueName, object value);
    public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
}
internal enum Microsoft.Win32.RegistryHive : Enum {
    public int value__;
    public static RegistryHive ClassesRoot;
    public static RegistryHive CurrentUser;
    public static RegistryHive LocalMachine;
    public static RegistryHive Users;
    public static RegistryHive PerformanceData;
    public static RegistryHive CurrentConfig;
}
internal class Microsoft.Win32.RegistryKey : object {
    public static IntPtr HKEY_CLASSES_ROOT;
    public static IntPtr HKEY_CURRENT_USER;
    public static IntPtr HKEY_LOCAL_MACHINE;
    public static IntPtr HKEY_USERS;
    public static IntPtr HKEY_PERFORMANCE_DATA;
    public static IntPtr HKEY_CURRENT_CONFIG;
    private static String[] s_hkeyNames;
    private static int MaxKeyLength;
    private static int MaxValueLength;
    private SafeRegistryHandle modreq(System.Runtime.CompilerServices.IsVolatile) _hkey;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _keyName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _remoteKey;
    private StateFlags modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private RegistryView modreq(System.Runtime.CompilerServices.IsVolatile) _regView;
    public int SubKeyCount { get; }
    public RegistryView View { get; }
    public SafeRegistryHandle Handle { get; }
    public int ValueCount { get; }
    public string Name { get; }
    private SafeRegistryHandle SystemKeyHandle { get; }
    private RegistryKey(SafeRegistryHandle hkey, bool writable, RegistryView view);
    private RegistryKey(SafeRegistryHandle hkey, bool writable, bool systemkey, bool remoteKey, bool isPerfData, RegistryView view);
    private static RegistryKey();
    public void Flush();
    public sealed virtual void Dispose();
    public RegistryKey CreateSubKey(string subkey);
    public RegistryKey CreateSubKey(string subkey, bool writable);
    public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options);
    private RegistryKey CreateSubKeyInternal(string subkey, bool writable, RegistryOptions registryOptions);
    public void DeleteValue(string name, bool throwOnMissingValue);
    public static RegistryKey OpenBaseKey(RegistryHive hKey);
    public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
    public RegistryKey OpenSubKey(string name, bool writable);
    public RegistryKey OpenSubKey(string name, RegistryRights rights);
    private RegistryKey InternalOpenSubKey(string name, bool writable);
    public RegistryKey OpenSubKey(string name);
    public int get_SubKeyCount();
    public RegistryView get_View();
    public SafeRegistryHandle get_Handle();
    public static RegistryKey FromHandle(SafeRegistryHandle handle);
    public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
    private int InternalSubKeyCount();
    public String[] GetSubKeyNames();
    private String[] InternalGetSubKeyNames();
    public int get_ValueCount();
    public String[] GetValueNames();
    public object GetValue(string name);
    public object GetValue(string name, object defaultValue);
    public object GetValue(string name, object defaultValue, RegistryValueOptions options);
    public object InternalGetValue(string name, object defaultValue, bool doNotExpand, bool checkSecurity);
    public RegistryValueKind GetValueKind(string name);
    public string get_Name();
    internal void SetValue(string name, string value);
    public virtual string ToString();
    private static string FixupName(string name);
    private static void FixupPath(StringBuilder path);
    private void EnsureNotDisposed();
    private void EnsureWriteable();
    private static void ValidateKeyName(string name);
    private static void ValidateKeyOptions(RegistryOptions options);
    private static void ValidateKeyView(RegistryView view);
    private static RegistryRights GetRegistryKeyRights(bool isWritable);
    private bool IsDirty();
    private bool IsSystemKey();
    private bool IsWritable();
    private bool IsPerfDataKey();
    private void SetDirty();
    public void Close();
    private void Dispose(bool disposing);
    internal static RegistryKey GetBaseKey(IntPtr hKey);
    internal static RegistryKey GetBaseKey(IntPtr hKey, RegistryView view);
    public void SetValue(string name, object value, RegistryValueKind valueKind);
    private void ClosePerfDataKey();
    private void FlushCore();
    private RegistryKey CreateSubKeyInternalCore(string subkey, bool writable, RegistryOptions registryOptions);
    private void DeleteValueCore(string name, bool throwOnMissingValue);
    private static RegistryKey OpenBaseKeyCore(RegistryHive hKeyHive, RegistryView view);
    private RegistryKey InternalOpenSubKeyCore(string name, RegistryRights rights, bool throwOnPermissionFailure);
    private SafeRegistryHandle get_SystemKeyHandle();
    private int InternalSubKeyCountCore();
    private String[] InternalGetSubKeyNamesCore(int subkeys);
    private int InternalValueCountCore();
    private String[] GetValueNamesCore(int values);
    private object InternalGetValueCore(string name, object defaultValue, bool doNotExpand);
    private RegistryValueKind GetValueKindCore(string name);
    private void SetValueCore(string name, string value);
    private void Win32Error(int errorCode, string str);
    private static void Win32ErrorStatic(int errorCode, string str);
    private static bool IsWritable(int rights);
}
[FlagsAttribute]
internal enum Microsoft.Win32.RegistryOptions : Enum {
    public int value__;
    public static RegistryOptions None;
    public static RegistryOptions Volatile;
}
internal enum Microsoft.Win32.RegistryValueKind : Enum {
    public int value__;
    public static RegistryValueKind String;
    public static RegistryValueKind ExpandString;
    public static RegistryValueKind Binary;
    public static RegistryValueKind DWord;
    public static RegistryValueKind MultiString;
    public static RegistryValueKind QWord;
    public static RegistryValueKind Unknown;
    public static RegistryValueKind None;
}
[FlagsAttribute]
internal enum Microsoft.Win32.RegistryValueOptions : Enum {
    public int value__;
    public static RegistryValueOptions None;
    public static RegistryValueOptions DoNotExpandEnvironmentNames;
}
internal enum Microsoft.Win32.RegistryView : Enum {
    public int value__;
    public static RegistryView Default;
    public static RegistryView Registry64;
    public static RegistryView Registry32;
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private Nullable`1<bool> _isAsync;
    [CompilerGeneratedAttribute]
private ThreadPoolBoundHandle <ThreadPoolBinding>k__BackingField;
    internal Nullable`1<bool> IsAsync { get; internal set; }
    internal ThreadPoolBoundHandle ThreadPoolBinding { get; internal set; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    internal Nullable`1<bool> get_IsAsync();
    internal void set_IsAsync(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal ThreadPoolBoundHandle get_ThreadPoolBinding();
    [CompilerGeneratedAttribute]
internal void set_ThreadPoolBinding(ThreadPoolBoundHandle value);
    [__BlockReflectionAttribute]
protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeThreadPoolIOHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    [__BlockReflectionAttribute]
protected virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.ThrowHelper : object {
    internal static void ThrowArgumentException(string msg);
    internal static void ThrowArgumentException(string msg, string argument);
    internal static void ThrowArgumentNullException(string argument);
    internal static void ThrowInvalidOperationException(string msg);
    internal static void ThrowSecurityException(string msg);
    internal static void ThrowUnauthorizedAccessException(string msg);
    internal static void ThrowObjectDisposedException(string objectName, string msg);
}
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
}
internal static class Microsoft.Win32.Win32Native : object {
    private static string CoreProcessThreadsApiSet;
    private static string CoreLocalizationApiSet;
    internal static string KERNEL32;
    internal static string ADVAPI32;
    private static int FORMAT_MESSAGE_IGNORE_INSERTS;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    private static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    [SecuritySafeCriticalAttribute]
internal static string GetMessage(int errorCode);
    [SecurityCriticalAttribute]
internal static UInt32 GetCurrentProcessId();
}
[DependencyReductionRootAttribute]
internal class System.__Boxed`1 : object {
    private T BoxedValue;
}
[CLSCompliantAttribute("False")]
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public class System.__Canon : object {
}
[CLSCompliantAttribute("False")]
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public class System.__CanonAlike : object {
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.__DTString : ValueType {
    internal ReadOnlySpan`1<char> Value;
    internal int Index;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    private static Char[] WhiteSpaceChecks;
    internal int Length { get; }
    internal CompareInfo CompareInfo { get; }
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi);
    private static __DTString();
    internal int get_Length();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool AtEnd();
    internal bool Advance(int count);
    internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.__UniversalCanon : ValueType {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AccessViolationException : SystemException {
    private IntPtr _ip;
    private IntPtr _target;
    private int _accessType;
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Activator : object {
    [ThreadStaticAttribute]
internal static bool s_createInstanceMissingDefaultConstructor;
    private static BindingFlags ConstructorDefault;
    [DebuggerGuidedStepThroughAttribute]
public static T CreateInstance();
    [IntrinsicAttribute]
private static T CreateInstanceIntrinsic();
    [IntrinsicAttribute]
private static IntPtr DefaultConstructorOf();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, bool nonPublic);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, Object[] args);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [__BlockReflectionAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    [__BlockReflectionAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [__BlockReflectionAttribute]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    [__BlockReflectionAttribute]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    [__BlockReflectionAttribute]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [__BlockReflectionAttribute]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
}
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AggregateException : Exception {
    private ReadOnlyCollection`1<Exception> m_innerExceptions;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    private int InnerExceptionCount { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, IList`1<Exception> innerExceptions);
    internal AggregateException(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    private AggregateException(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string get_Message();
    public virtual string ToString();
    private int get_InnerExceptionCount();
}
public static class System.AppContext : object {
    private static Dictionary`2<string, SwitchValueState> s_switchMap;
    private static Dictionary`2<string, object> s_localStore;
    private static string s_defaultBaseDirectory;
    private static object s_appDomain;
    [CompilerGeneratedAttribute]
private static UnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private static EventHandler`1<FirstChanceExceptionEventArgs> FirstChanceException;
    [CompilerGeneratedAttribute]
private static EventHandler ProcessExit;
    [CompilerGeneratedAttribute]
private static EventHandler Unloading;
    public static string TargetFrameworkName { get; }
    public static string BaseDirectory { get; }
    private static AppContext();
    [__BlockReflectionAttribute]
public static void SetAppDomain(object appDomain);
    public static string get_TargetFrameworkName();
    public static string get_BaseDirectory();
    public static object GetData(string name);
    [__BlockReflectionAttribute]
public static void SetData(string name, object data);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public static void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public static void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public static void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public static void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public static void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public static void remove_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_Unloading(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_Unloading(EventHandler value);
    private static void OnUnhandledException(object sender, UnhandledExceptionEventArgs e);
    internal static void OnFirstChanceException(object sender, FirstChanceExceptionEventArgs e);
    [RuntimeExportAttribute("OnFirstChanceException")]
internal static void OnFirstChanceException(object e);
    private static void OnProcessExit(object sender, EventArgs e);
    private static void OnUnloading(object sender, EventArgs e);
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    public static void SetSwitch(string switchName, bool isEnabled);
    internal static void DefineSwitchDefault(string switchName, bool isEnabled);
    private static string GetBaseDirectoryCore();
}
internal static class System.AppContextConfigHelper : object {
    internal static int GetInt32Config(string configName, int defaultValue, bool allowNegative);
    internal static short GetInt16Config(string configName, short defaultValue, bool allowNegative);
}
internal static class System.AppContextDefaultValues : object {
    public static bool TryGetSwitchOverride(string name, Boolean& overrideValue);
    public static void PopulateDefaultValues();
    private static bool TryParseFrameworkName(string frameworkName, String& identifier, Int32& version, String& profile);
}
internal static class System.AppContextSwitches : object {
    private static int _enforceJapaneseEraYearRanges;
    private static int _formatJapaneseFirstYearAsANumber;
    private static int _enforceLegacyJapaneseDateParsing;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    public static bool EnforceJapaneseEraYearRanges { get; }
    public static bool FormatJapaneseFirstYearAsANumber { get; }
    public static bool EnforceLegacyJapaneseDateParsing { get; }
    private static bool DisableCaching { get; private set; }
    private static AppContextSwitches();
    public static bool get_EnforceJapaneseEraYearRanges();
    public static bool get_FormatJapaneseFirstYearAsANumber();
    public static bool get_EnforceLegacyJapaneseDateParsing();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
}
internal static class System.AppDomain : object {
    public static int GetCurrentThreadId();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    protected ApplicationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentException : SystemException {
    private string _paramName;
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_ParamName();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentOutOfRangeException : ArgumentException {
    private object _actualValue;
    public string Message { get; }
    public object ActualValue { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string paramName, string message);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual object get_ActualValue();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Array : object {
    private int _numComponents;
    private static int POINTER_SIZE;
    private static int SZARRAY_BASE_SIZE;
    internal static int MaxArrayLength;
    internal static int MaxByteArrayLength;
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public long LongLength { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Length { get; }
    internal bool IsSzArray { get; }
    public int Rank { get; }
    internal EETypePtr ElementEEType { get; }
    internal UInt32 ElementSize { get; }
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static void Resize(T[]& array, int newSize);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    internal static int CombineHashCodes(int h1, int h2);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public void CopyTo(Array array, long index);
    public static void ForEach(T[] array, Action`1<T> action);
    public long get_LongLength();
    public long GetLongLength(int dimension);
    public object GetValue(long index);
    public object GetValue(long index1, long index2);
    public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public sealed virtual bool get_IsFixedSize();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    private static int GetMedian(int low, int hi);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public void SetValue(object value, long index);
    public void SetValue(object value, long index1, long index2);
    public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    public static void Sort(Array array);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    public sealed virtual IEnumerator GetEnumerator();
    public int get_Length();
    internal bool get_IsSzArray();
    [RuntimeExportAttribute("GetSystemArrayEEType")]
private static EEType* GetSystemArrayEEType();
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    private static Array CreateSzArray(Type elementType, int length);
    private static Array CreateMultiDimArray(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    private static Type GetArrayTypeFromElementType(Type elementType, bool multiDim, int rank);
    private static void ValidateElementType(Type elementType);
    public void Initialize();
    internal Byte& GetRawSzArrayData();
    internal Byte& GetRawArrayData();
    private Int32& GetRawMultiDimArrayBounds();
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    private static void CopyImpl(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    private static bool IsSourceElementABaseClassOrInterfaceOfDestinationValueType(EETypePtr sourceElementEEType, EETypePtr destinationElementEEType);
    private static void CopyImplGcRefArray(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    private static void CopyImplValueTypeArrayToReferenceArray(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    private static void CopyImplReferenceArrayToValueTypeArray(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    private static void CopyImplValueTypeArrayWithInnerGcRefs(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    internal static void CopyImplValueTypeArrayNoInnerGcRefs(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    private static void CopyImplPrimitiveTypeWithWidening(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    public static void Clear(Array array, int index, int length);
    private static void ReportClearErrors(Array array, int index, int length);
    public int GetLength(int dimension);
    public int get_Rank();
    internal static Array NewMultiDimArray(EETypePtr eeType, Int32* pLengths, int rank);
    public static T[] Empty();
    public int GetLowerBound(int dimension);
    public int GetUpperBound(int dimension);
    public object GetValue(int index);
    public object GetValue(int index1, int index2);
    public object GetValue(int index1, int index2, int index3);
    public object GetValue(Int32[] indices);
    private object GetValue(Int32* pIndices, int rank);
    private object GetValueWithFlattenedIndex_NoErrorCheck(int flattenedIndex);
    public void SetValue(object value, int index);
    public void SetValue(object value, int index1, int index2);
    public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    private void SetValue(object value, Int32* pIndices, int rank);
    internal EETypePtr get_ElementEEType();
    internal UInt32 get_ElementSize();
    private static int IndexOfImpl(T[] array, T value, int startIndex, int count);
    private static int LastIndexOfImpl(T[] array, T value, int startIndex, int count);
    private static void SortImpl(Array keys, Array items, int index, int length, IComparer comparer);
}
[DefaultMemberAttribute("Item")]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Array`1 : Array {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    [__BlockReflectionAttribute]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    [__BlockReflectionAttribute]
public sealed virtual int get_Count();
    [__BlockReflectionAttribute]
public sealed virtual bool get_IsReadOnly();
    [__BlockReflectionAttribute]
public sealed virtual void Add(T item);
    [__BlockReflectionAttribute]
public sealed virtual void Clear();
    [__BlockReflectionAttribute]
public sealed virtual bool Contains(T item);
    [__BlockReflectionAttribute]
public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [__BlockReflectionAttribute]
public sealed virtual bool Remove(T item);
    [__BlockReflectionAttribute]
public sealed virtual T get_Item(int index);
    [__BlockReflectionAttribute]
public sealed virtual void set_Item(int index, T value);
    [__BlockReflectionAttribute]
public sealed virtual int IndexOf(T item);
    [__BlockReflectionAttribute]
public sealed virtual void Insert(int index, T item);
    [__BlockReflectionAttribute]
public sealed virtual void RemoveAt(int index);
}
internal class System.ArrayEnumeratorBase : object {
    protected int _index;
    protected int _endIndex;
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArraySegment`1 : ValueType {
    [CompilerGeneratedAttribute]
private static ArraySegment`1<T> <Empty>k__BackingField;
    private T[] _array;
    private int _offset;
    private int _count;
    public static ArraySegment`1<T> Empty { get; }
    public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    private static ArraySegment`1();
    [CompilerGeneratedAttribute]
public static ArraySegment`1<T> get_Empty();
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowInvalidOperationIfDefault();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.AssemblyLoadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    [CompilerGeneratedAttribute]
public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public virtual bool Equals(object obj);
    private static bool AreFieldValuesEqual(object thisValue, object thatValue);
    public virtual int GetHashCode();
    public virtual object get_TypeId();
    public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
    [CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
protected virtual int _ILT_GetNumFields();
    [CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
protected virtual void _ILT_ReadFields(Object[] destination, int offset);
    private Object[] ReadFields();
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    private AttributeTargets _attributeTarget;
    private bool _allowMultiple;
    private bool _inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.BadImageFormatException : SystemException {
    private string _fileName;
    private string _fusionLog;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    public string get_FileName();
    public virtual string ToString();
    public string get_FusionLog();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    public static Byte[] GetBytes(char value);
    public static bool TryWriteBytes(Span`1<byte> destination, char value);
    public static Byte[] GetBytes(short value);
    public static bool TryWriteBytes(Span`1<byte> destination, short value);
    public static Byte[] GetBytes(int value);
    public static bool TryWriteBytes(Span`1<byte> destination, int value);
    public static Byte[] GetBytes(long value);
    public static bool TryWriteBytes(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
    public static Byte[] GetBytes(float value);
    public static bool TryWriteBytes(Span`1<byte> destination, float value);
    public static Byte[] GetBytes(double value);
    public static bool TryWriteBytes(Span`1<byte> destination, double value);
    public static char ToChar(Byte[] value, int startIndex);
    public static char ToChar(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    public static long ToInt64(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value, int startIndex, int length);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    public static long DoubleToInt64Bits(double value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static float Int32BitsToSingle(int value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Boolean : ValueType {
    private bool m_value;
    internal static int True;
    internal static int False;
    internal static string TrueLiteral;
    internal static string FalseLiteral;
    public static string TrueString;
    public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(bool obj);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    internal static bool IsTrueStringIgnoreCase(ReadOnlySpan`1<char> value);
    internal static bool IsFalseStringIgnoreCase(ReadOnlySpan`1<char> value);
    public static bool Parse(string value);
    public static bool Parse(ReadOnlySpan`1<char> value);
    public static bool TryParse(string value, Boolean& result);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    private static ReadOnlySpan`1<char> TrimWhiteSpaceAndNull(ReadOnlySpan`1<char> value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    internal static void ZeroMemory(Byte* src, long len);
    public static int ByteLength(Array array);
    private static int _ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    public static void SetByte(Array array, int index, byte value);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    internal static void Memcpy(Byte* dest, Byte* src, int len);
    internal static void Memmove(Byte* dest, Byte* src, UInt32 len);
    internal static void Memmove(T& destination, T& source, UInt32 elementCount);
    private static void _Memmove(Byte* dest, Byte* src, UInt32 len);
    private static void _Memmove(Byte& dest, Byte& src, UInt32 len);
}
public abstract class System.Buffers.ArrayPool`1 : object {
    [CompilerGeneratedAttribute]
private static ArrayPool`1<T> <Shared>k__BackingField;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    [CompilerGeneratedAttribute]
public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
    [EventAttribute("4")]
internal void BufferTrimmed(int bufferId, int bufferSize, int poolId);
    [EventAttribute("5")]
internal void BufferTrimPoll(int milliseconds, int pressure);
}
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxNumberOfArraysPerBucket;
    private Bucket[] _buckets;
    private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
public interface System.Buffers.IMemoryOwner`1 {
    public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(ulong value);
    public static int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros);
}
internal class System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
    private static int NumBuckets;
    private static int MaxPerCorePerArraySizeStacks;
    private static int MaxBuffersPerArraySizePerCore;
    private Int32[] _bucketArraySizes;
    private PerCoreLockedStacks[] _buckets;
    [ThreadStaticAttribute]
private static T[][] t_tlsBuckets;
    private int _callbackCreated;
    private static bool s_trimBuffers;
    private static ConditionalWeakTable`2<T[][], object> s_allTlsBuckets;
    private int Id { get; }
    private static TlsOverPerCoreLockedStacksArrayPool`1();
    private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
    public bool Trim();
    private static bool Gen2GcCallbackFunc(object target);
    private static MemoryPressure<T> GetMemoryPressure();
    private static bool GetTrimBuffers();
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DependencyReductionRootAttribute]
internal class System.ByReference`1 : ValueType {
    private IntPtr _value;
    public T& Value { get; }
    [IntrinsicAttribute]
public ByReference`1(T& value);
    [IntrinsicAttribute]
public T& get_Value();
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Byte : ValueType {
    private byte m_value;
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, IFormatProvider provider);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Byte& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Char : ValueType {
    private char m_value;
    public static char MaxValue;
    public static char MinValue;
    private static Byte[] s_categoryForLatin1;
    internal static int UNICODE_PLANE00_END;
    internal static int UNICODE_PLANE01_START;
    internal static int UNICODE_PLANE16_END;
    internal static int HIGH_SURROGATE_START;
    internal static int LOW_SURROGATE_END;
    private static Char();
    private static bool IsLatin1(char ch);
    private static bool IsAscii(char ch);
    private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(char obj);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public static string ToString(char c);
    public static char Parse(string s);
    public static bool TryParse(string s, Char& result);
    public static bool IsDigit(char c);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    private static bool IsWhiteSpaceLatin1(char c);
    public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    public static bool IsLetterOrDigit(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(string s, int index);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    private static bool IsSeparatorLatin1(char c);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
}
public class System.CharEnumerator : object {
    private string _str;
    private int _index;
    private char _currentElement;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    private bool _compliant;
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Comparer : object {
    private CompareInfo _compareInfo;
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    private static Comparer();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual int Compare(object a, object b);
}
internal class System.Collections.CompatibleComparer : object {
    private IHashCodeProvider _hcp;
    private IComparer _comparer;
    internal IHashCodeProvider HashCodeProvider { get; }
    internal IComparer Comparer { get; }
    internal CompatibleComparer(IHashCodeProvider hashCodeProvider, IComparer comparer);
    internal IHashCodeProvider get_HashCodeProvider();
    internal IComparer get_Comparer();
    public sealed virtual bool Equals(object a, object b);
    public int Compare(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1")]
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private static int InitialSegmentLength;
    private static int MaxSegmentLength;
    private object _crossSegmentLock;
    private ConcurrentQueueSegment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    private ConcurrentQueueSegment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    private static int GetCount(ConcurrentQueueSegment`1<T> s, int head, int tail);
    private static long GetCount(ConcurrentQueueSegment`1<T> head, int headHead, ConcurrentQueueSegment`1<T> tail, int tailTail);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void SnapForObservation(ConcurrentQueueSegment`1& head, Int32& headHead, ConcurrentQueueSegment`1& tail, Int32& tailTail);
    private T GetItemWhenAvailable(ConcurrentQueueSegment`1<T> segment, int i);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentQueue`1/<Enumerate>d__27")]
private IEnumerator`1<T> Enumerate(ConcurrentQueueSegment`1<T> head, int headHead, ConcurrentQueueSegment`1<T> tail, int tailTail);
    public void Enqueue(T item);
    private void EnqueueSlow(T item);
    public bool TryDequeue(T& result);
    private bool TryDequeueSlow(T& item);
    public bool TryPeek(T& result);
    private bool TryPeek(T& result, bool resultUsed);
    public void Clear();
}
[DebuggerDisplayAttribute("Capacity = {Capacity}")]
internal class System.Collections.Concurrent.ConcurrentQueueSegment`1 : object {
    internal Slot[] _slots;
    internal int _slotsMask;
    internal PaddedHeadAndTail _headAndTail;
    internal bool _preservedForObservation;
    internal bool _frozenForEnqueues;
    internal ConcurrentQueueSegment`1<T> _nextSegment;
    internal int Capacity { get; }
    internal int FreezeOffset { get; }
    internal ConcurrentQueueSegment`1(int boundedLength);
    internal static int RoundUpToPowerOf2(int i);
    internal int get_Capacity();
    internal int get_FreezeOffset();
    internal void EnsureFrozenForEnqueues();
    public bool TryDequeue(T& item);
    public bool TryPeek(T& result, bool resultUsed);
    public bool TryEnqueue(T item);
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifier`2 : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private Lock _lock;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifierW`2 : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private Lock _lock;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifierWKeyed`2 : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private Lock _lock;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal interface System.Collections.Concurrent.IKeyedItem`1 {
    public K Key { get; }
    public abstract virtual void PrepareKey();
    public abstract virtual K get_Key();
}
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
internal class System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public IProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
[DebuggerDisplayAttribute("Head = {Head}, Tail = {Tail}")]
internal class System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
    public int Head;
    public int Tail;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
}
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    private static ArraySortHelper`1<T> s_defaultArraySortHelper;
    public static ArraySortHelper`1<T> Default { get; }
    private static ArraySortHelper`1();
    public void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(T[] keys, int index, int length, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    public static ArraySortHelper`1<T> get_Default();
}
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    private static ArraySortHelper`2<TKey, TValue> s_defaultArraySortHelper;
    public static ArraySortHelper`2<TKey, TValue> Default { get; }
    private static ArraySortHelper`2();
    public void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, IComparer`1<TKey> comparer, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    public static ArraySortHelper`2<TKey, TValue> get_Default();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    private static Comparer`1<T> _default;
    public static Comparer`1<T> Default { get; }
    [IntrinsicAttribute]
private static Comparer`1<T> Create();
    public static Comparer`1<T> get_Default();
    public abstract virtual int Compare(T x, T y);
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] _buckets;
    private Entry[] _entries;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    private object _syncRoot;
    private static string VersionName;
    private static string HashSizeName;
    private static string KeyValuePairsName;
    private static string ComparerName;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private int FindEntry(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    public virtual void OnDeserialization(object sender);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    private EnumEqualityComparer`1(SerializationInfo info, StreamingContext context);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    private static EqualityComparer`1<T> _default;
    public static EqualityComparer`1<T> Default { get; }
    [IntrinsicAttribute]
private static EqualityComparer`1<T> Create();
    [IntrinsicAttribute]
public static EqualityComparer`1<T> get_Default();
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.EqualOnlyComparer`1 : object {
    public static bool Equals(T x, T y);
}
internal static class System.Collections.Generic.EqualOnlyComparerHelper : object {
    public static bool Equals(sbyte x, sbyte y);
    public static bool Equals(byte x, byte y);
    public static bool Equals(short x, short y);
    public static bool Equals(ushort x, ushort y);
    public static bool Equals(int x, int y);
    public static bool Equals(UInt32 x, UInt32 y);
    public static bool Equals(long x, long y);
    public static bool Equals(ulong x, ulong y);
    public static bool Equals(IntPtr x, IntPtr y);
    public static bool Equals(UIntPtr x, UIntPtr y);
    public static bool Equals(float x, float y);
    public static bool Equals(double x, double y);
    public static bool Equals(decimal x, decimal y);
    public static bool Equals(string x, string y);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(T[] array, int index, int length, T value);
    private static void SwapIfGreaterWithItems(T[] keys, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi);
    private static void Heapsort(T[] keys, int lo, int hi);
    private static void DownHeap(T[] keys, int i, int n, int lo);
    private static void InsertionSort(T[] keys, int lo, int hi);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public sealed virtual int Compare(T x, T y);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
[__BlockReflectionAttribute]
public class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
internal enum System.Collections.Generic.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
internal static class System.Collections.Generic.IntrospectiveSortUtilities : object {
    internal static int IntrosortSizeThreshold;
    internal static int FloorLog2PlusOne(int n);
    internal static void ThrowOrIgnoreBadComparer(object comparer);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
    internal static string PairToString(object key, object value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.List`1 : object {
    private static int DefaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    private void AddEnumerable(IEnumerable`1<T> enumerable);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.LongEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    private LongEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    private void EnsureCapacity(int min);
    public void AddRange(IEnumerable`1<T> collection);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int index);
    public sealed virtual void Insert(int index, T item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public sealed virtual bool Remove(T item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public T[] ToArray();
}
internal class System.Collections.Generic.LowLevelListWithIList`1 : LowLevelList`1<T> {
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public LowLevelListWithIList`1(int capacity);
    public LowLevelListWithIList`1(IEnumerable`1<T> collection);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[__BlockReflectionAttribute]
public class System.Collections.Generic.NonRandomizedStringEqualityComparer : EqualityComparer`1<string> {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<string> <Default>k__BackingField;
    internal static IEqualityComparer`1<string> Default { get; }
    private NonRandomizedStringEqualityComparer(SerializationInfo information, StreamingContext context);
    private static NonRandomizedStringEqualityComparer();
    [CompilerGeneratedAttribute]
internal static IEqualityComparer`1<string> get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    public sealed virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    public sealed virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public sealed virtual int GetHashCode(Nullable`1<T> obj);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    public sealed virtual int Compare(T x, T y);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.SByteEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    private SByteEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.ShortEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    private ShortEnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; public set; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public void set_Length(int value);
    public T& get_Item(int index);
    public void Append(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow();
}
internal static class System.Collections.HashHelpers : object {
    public static int HashCollisionThreshold;
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    public static Int32[] primes;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    public static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Hashtable : object {
    private static int InitialSize;
    private static string LoadFactorName;
    private static string VersionName;
    private static string ComparerName;
    private static string HashCodeProviderName;
    private static string HashSizeName;
    private static string KeysName;
    private static string ValuesName;
    private static string KeyComparerName;
    private bucket[] _buckets;
    private int _count;
    private int _occupancy;
    private int _loadsize;
    private float _loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isWriterInProgress;
    private ICollection _keys;
    private ICollection _values;
    private IEqualityComparer _keycomparer;
    private object _syncRoot;
    [ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    [ObsoleteAttribute("Please use KeyComparer properties.")]
protected IComparer comparer { get; protected set; }
    protected IEqualityComparer EqualityComparer { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool trash);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, float loadFactor);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    protected IHashCodeProvider get_hcp();
    protected void set_hcp(IHashCodeProvider value);
    protected IComparer get_comparer();
    protected void set_comparer(IComparer value);
    protected IEqualityComparer get_EqualityComparer();
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode);
    public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DebuggerDisplayAttribute("{_value}")]
internal class System.Collections.KeyValuePairs : object {
    [DebuggerBrowsableAttribute("0")]
private object _key;
    [DebuggerBrowsableAttribute("0")]
private object _value;
    public KeyValuePairs(object key, object value);
}
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Collections.ListDictionaryInternal : object {
    private DictionaryNode head;
    private int version;
    private int count;
    private object _syncRoot;
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ObjectModel.Collection`1 : object {
    private IList`1<T> items;
    private object _syncRoot;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static bool IsCompatibleObject(object value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private IList`1<T> list;
    private object _syncRoot;
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
internal static class System.CommonRuntimeTypes : object {
    private static Type s_object;
    private static Type s_valuetype;
    private static Type s_type;
    private static Type s_attribute;
    private static Type s_string;
    private static Type s_array;
    private static Type s_enum;
    private static Type s_boolean;
    private static Type s_char;
    private static Type s_byte;
    private static Type s_sByte;
    private static Type s_uInt16;
    private static Type s_int16;
    private static Type s_uInt32;
    private static Type s_int32;
    private static Type s_uInt64;
    private static Type s_int64;
    private static Type s_uIntPtr;
    private static Type s_intPtr;
    private static Type s_single;
    private static Type s_double;
    private static Type s_decimal;
    private static Type s_datetime;
    private static Type s_nullable;
    private static Type s_void;
    private static Type s_multicastDelegate;
    internal static Type Object { get; }
    internal static Type ValueType { get; }
    internal static Type Type { get; }
    internal static Type Attribute { get; }
    internal static Type String { get; }
    internal static Type Array { get; }
    internal static Type Enum { get; }
    internal static Type Boolean { get; }
    internal static Type Char { get; }
    internal static Type Byte { get; }
    internal static Type SByte { get; }
    internal static Type UInt16 { get; }
    internal static Type Int16 { get; }
    internal static Type UInt32 { get; }
    internal static Type Int32 { get; }
    internal static Type UInt64 { get; }
    internal static Type Int64 { get; }
    internal static Type UIntPtr { get; }
    internal static Type IntPtr { get; }
    internal static Type Single { get; }
    internal static Type Double { get; }
    internal static Type Decimal { get; }
    internal static Type DateTime { get; }
    internal static Type Nullable { get; }
    internal static Type Void { get; }
    internal static Type MulticastDelegate { get; }
    private static CommonRuntimeTypes();
    internal static Type get_Object();
    internal static Type get_ValueType();
    internal static Type get_Type();
    internal static Type get_Attribute();
    internal static Type get_String();
    internal static Type get_Array();
    internal static Type get_Enum();
    internal static Type get_Boolean();
    internal static Type get_Char();
    internal static Type get_Byte();
    internal static Type get_SByte();
    internal static Type get_UInt16();
    internal static Type get_Int16();
    internal static Type get_UInt32();
    internal static Type get_Int32();
    internal static Type get_UInt64();
    internal static Type get_Int64();
    internal static Type get_UIntPtr();
    internal static Type get_IntPtr();
    internal static Type get_Single();
    internal static Type get_Double();
    internal static Type get_Decimal();
    internal static Type get_DateTime();
    internal static Type get_Nullable();
    internal static Type get_Void();
    internal static Type get_MulticastDelegate();
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    private object _value;
    private static object s_convertFromInvariantString;
    public object Value { get; }
    public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__TryConvertFromInvariantString|2_0(Type typeToConvert, string stringValue, Object& conversionResult);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    private EditorBrowsableState browsableState;
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
[ExtensionAttribute]
public static class System.Convert : object {
    internal static Type[] ConvertTypes;
    private static Type EnumType;
    internal static Char[] base64Table;
    private static int base64LineBreakPosition;
    public static object DBNull;
    private static SByte[] s_decodingMap;
    private static byte EncodingPad;
    private static Convert();
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    private static void ThrowCharOverflowException();
    private static void ThrowByteOverflowException();
    private static void ThrowSByteOverflowException();
    private static void ThrowInt16OverflowException();
    private static void ThrowUInt16OverflowException();
    private static void ThrowInt32OverflowException();
    private static void ThrowUInt32OverflowException();
    private static void ThrowInt64OverflowException();
    private static void ThrowUInt64OverflowException();
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    public static string ToString(byte value, int toBase);
    public static string ToString(short value, int toBase);
    public static string ToString(int value, int toBase);
    public static string ToString(long value, int toBase);
    public static string ToBase64String(Byte[] inArray);
    public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
    private static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks);
    private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
    public static Byte[] FromBase64String(string s);
    public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private static void CopyToTempBufferWithoutWhiteSpace(ReadOnlySpan`1<char> chars, Span`1<char> tempBuffer, Int32& consumed, Int32& charsWritten);
    [ExtensionAttribute]
private static bool IsSpace(char c);
    public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    private static Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength);
    private static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
    private static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> utf16, Span`1<byte> bytes, Int32& consumed, Int32& written);
    private static int Decode(Char& encodedChars, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
internal class System.CoreLib : object {
    public static string Name;
    public static string FixupCoreLibName(string strToFixup);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.CultureAwareComparer : StringComparer {
    private static CompareOptions ValidCompareMaskOffFlags;
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    internal CultureAwareComparer(CultureInfo culture, CompareOptions options);
    internal CultureAwareComparer(CompareInfo compareInfo, CompareOptions options);
    private CultureAwareComparer(SerializationInfo info, StreamingContext context);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("System.CurrentSystemTimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo.Local instead.")]
internal class System.CurrentSystemTimeZone : TimeZone {
    private long m_ticksOffset;
    private string m_standardName;
    private string m_daylightName;
    private Hashtable m_CachedDaylightChanges;
    public string StandardName { get; }
    public string DaylightName { get; }
    public virtual string get_StandardName();
    public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DaylightTime GetDaylightChanges(int year);
    private static DaylightTime CreateDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
    private DaylightTime GetCachedDaylightChanges(int year);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    internal DataMisalignedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DateTime : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    internal static int DaysTo1970;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static long MaxMillis;
    internal static long UnixEpochTicks;
    private static long FileTimeOffset;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static double OADateMinAsDouble;
    private static double OADateMaxAsDouble;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    public static DateTime UnixEpoch;
    private static ulong TicksMask;
    private static ulong FlagsMask;
    private static ulong LocalMask;
    private static long TicksCeiling;
    private static ulong KindUnspecified;
    private static ulong KindUtc;
    private static ulong KindLocal;
    private static ulong KindLocalAmbiguousDst;
    private static int KindShift;
    private static string TicksField;
    private static string DateDataField;
    private ulong _dateData;
    internal long InternalTicks { get; }
    private ulong InternalKind { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public static DateTime UtcNow { get; }
    public DateTime(long ticks);
    private DateTime(ulong dateData);
    public DateTime(long ticks, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    private DateTime(SerializationInfo info, StreamingContext context);
    private static DateTime();
    internal long get_InternalTicks();
    private ulong get_InternalKind();
    public DateTime Add(TimeSpan value);
    private DateTime Add(double value, int scale);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    private static long DateToTicks(int year, int month, int day);
    private static long TimeToTicks(int hour, int minute, int second);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    internal static DateTime FromBinaryRaw(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    public DateTime get_Date();
    private int GetDatePart(int part);
    internal void GetDatePart(Int32& year, Int32& month, Int32& day);
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public virtual int GetHashCode();
    public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private static double TicksToOADate(long value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    internal DateTime ToLocalTime(bool throwOnOverflow);
    public string ToLongDateString();
    public string ToLongTimeString();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
    public static DateTime get_UtcNow();
}
internal static class System.DateTimeFormat : object {
    internal static int MaxSecondsFractionDigits;
    internal static TimeSpan NullOffset;
    internal static Char[] allStandardFormats;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    private static int DEFAULT_ALL_DATETIMES_SIZE;
    internal static DateTimeFormatInfo InvariantFormatInfo;
    internal static String[] InvariantAbbreviatedMonthNames;
    internal static String[] InvariantAbbreviatedDayNames;
    internal static string Gmt;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
    private static void HebrewFormatDigits(StringBuilder outputBuffer, int digits);
    internal static int ParseRepeatPattern(ReadOnlySpan`1<char> format, int pos, char patternChar);
    private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
    private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
    private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
    internal static int ParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result);
    internal static int ParseNextChar(ReadOnlySpan`1<char> format, int pos);
    private static bool IsUseGenitiveForm(ReadOnlySpan`1<char> format, int index, int tokenLen, char patternToMatch);
    private static StringBuilder FormatCustomized(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset, StringBuilder result);
    private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, ReadOnlySpan`1<char> format, int tokenLen, bool timeOnly, StringBuilder result);
    private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result);
    private static void Append2DigitNumber(StringBuilder result, int val);
    internal static string GetRealFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan& offset);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider, TimeSpan offset);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider, TimeSpan offset);
    private static StringBuilder FormatStringBuilder(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset);
    private static bool TryFormatO(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static bool TryFormatR(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static void WriteTwoDecimalDigits(UInt32 value, Span`1<char> destination, int offset);
    private static void WriteFourDecimalDigits(UInt32 value, Span`1<char> buffer, int startingIndex);
    private static void WriteDigits(ulong value, Span`1<char> buffer);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
    internal static void InvalidFormatForLocal(ReadOnlySpan`1<char> format, DateTime dateTime);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DateTimeOffset : ValueType {
    internal static long MaxOffset;
    internal static long MinOffset;
    private static long UnixEpochSeconds;
    private static long UnixEpochMilliseconds;
    internal static long UnixMinSeconds;
    internal static long UnixMaxSeconds;
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset UnixEpoch;
    private DateTime _dateTime;
    private short _offsetMinutes;
    public static DateTimeOffset Now { get; }
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    private DateTime ClockDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    private DateTimeOffset(SerializationInfo info, StreamingContext context);
    private static DateTimeOffset();
    public static DateTimeOffset get_Now();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    private DateTime get_ClockDateTime();
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public long ToUnixTimeSeconds();
    public long ToUnixTimeMilliseconds();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    private static short ValidateOffset(TimeSpan offset);
    private static DateTime ValidateDate(DateTime dateTime, TimeSpan offset);
    private static DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
}
internal static class System.DateTimeParse : object {
    internal static int MaxDateTimeNumberDigits;
    internal static MatchNumberDelegate m_hebrewNumberParser;
    private static DS[][] dateParsingStates;
    internal static string GMTName;
    internal static string ZuluName;
    private static int ORDER_YMD;
    private static int ORDER_MDY;
    private static int ORDER_DMY;
    private static int ORDER_YDM;
    private static int ORDER_YM;
    private static int ORDER_MY;
    private static int ORDER_MD;
    private static int ORDER_DM;
    private static DateTimeParse();
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    private static bool MatchWord(__DTString& str, string target);
    private static bool GetTimeZoneName(__DTString& str);
    internal static bool IsDigit(char ch);
    private static bool ParseFraction(__DTString& str, Double& result);
    private static bool ParseTimeZone(__DTString& str, TimeSpan& result);
    private static bool HandleTimeZone(__DTString& str, DateTimeResult& result);
    private static bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles);
    private static bool VerifyValidPunctuation(__DTString& str);
    private static bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear);
    private static bool SetDateYMD(DateTimeResult& result, int year, int month, int day);
    private static bool SetDateMDY(DateTimeResult& result, int month, int day, int year);
    private static bool SetDateDMY(DateTimeResult& result, int day, int month, int year);
    private static bool SetDateYDM(DateTimeResult& result, int year, int day, int month);
    private static void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles);
    private static bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw);
    private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw);
    private static bool AdjustHour(Int32& hour, TM timeMark);
    private static bool GetTimeOfN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok);
    internal static bool ProcessHebrewTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    private static bool DetermineTimeZoneAdjustments(DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly);
    private static bool DateTimeOffsetTimeZonePostProcessing(DateTimeResult& result, DateTimeStyles styles);
    private static bool AdjustTimeZoneToUniversal(DateTimeResult& result);
    private static bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly);
    private static bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    private static bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result);
    private static bool ParseSign(__DTString& str, Boolean& result);
    private static bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result);
    private static bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result);
    private static DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles);
    private static bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseJapaneseEraStart(__DTString& str, DateTimeFormatInfo dtfi);
    private static void ConfigureFormatR(DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static void ConfigureFormatOS(DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo);
    private static bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result);
    internal static bool TryParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result, Int32& returnValue);
    private static bool DoStrictParse(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result);
    private static bool ParseFormatR(ReadOnlySpan`1<char> source, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseFormatO(ReadOnlySpan`1<char> source, ParsingInfo& parseInfo, DateTimeResult& result);
    private static Exception GetDateTimeParseException(DateTimeResult& result);
    [ConditionalAttribute("_LOGGING")]
private static void LexTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
private static void PTSTraceExit(DS dps, bool passed);
    [ConditionalAttribute("_LOGGING")]
private static void TPTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
private static void DTFITrace(DateTimeFormatInfo dtfi);
}
internal class System.DateTimeRawInfo : ValueType {
    private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool hasSameDateAndTimeSeparators;
    internal void Init(Int32* numberBuffer);
    internal void AddNumber(int value);
    internal int GetNumber(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal string failureMessageID;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal ReadOnlySpan`1<char> originalDateTimeString;
    internal ReadOnlySpan`1<char> failedFormatSpecifier;
    internal void Init(ReadOnlySpan`1<char> originalDateTimeString);
    internal void SetDate(int year, int month, int day);
    internal void SetBadFormatSpecifierFailure();
    internal void SetBadFormatSpecifierFailure(ReadOnlySpan`1<char> failedFormatSpecifier);
    internal void SetBadDateTimeFailure();
    internal void SetFailure(ParseFailureKind failure, string failureMessageID);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
public class System.DBNull : object {
    public static DBNull Value;
    private DBNull(SerializationInfo info, StreamingContext context);
    private static DBNull();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Decimal : ValueType {
    private static int SignMask;
    private static int ScaleMask;
    private static int ScaleShift;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    private int flags;
    private int hi;
    private int lo;
    private int mid;
    internal UInt32 High { get; }
    internal UInt32 Low { get; }
    internal UInt32 Mid { get; }
    internal bool IsNegative { get; }
    internal int Scale { get; }
    private ulong Low64 { get; }
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public Decimal(float value);
    public Decimal(double value);
    public Decimal(Int32[] bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private Decimal(int lo, int mid, int hi, int flags);
    private Decimal(Decimal& d, int flags);
    private static Decimal();
    public static decimal FromOACurrency(long cy);
    public static long ToOACurrency(decimal value);
    private static bool IsValid(int flags);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    internal static decimal Abs(Decimal& d);
    public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(decimal value);
    public virtual int GetHashCode();
    public static bool Equals(decimal d1, decimal d2);
    public static decimal Floor(decimal d);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static Int32[] GetBits(decimal d);
    internal static void GetBytes(decimal d, Byte[] buffer);
    internal static decimal ToDecimal(Byte[] buffer);
    internal static Decimal& Max(Decimal& d1, Decimal& d2);
    internal static Decimal& Min(Decimal& d1, Decimal& d2);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static decimal Round(Decimal& d, int decimals, MidpointRounding mode);
    internal static int Sign(Decimal& d);
    public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    public static double ToDouble(decimal d);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static float ToSingle(decimal d);
    public static decimal Truncate(decimal d);
    private static void Truncate(Decimal& d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_Increment(decimal d);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Division(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal UInt32 get_High();
    internal UInt32 get_Low();
    internal UInt32 get_Mid();
    internal bool get_IsNegative();
    internal int get_Scale();
    private ulong get_Low64();
    private static DecCalc& AsMutable(Decimal& d);
    internal static UInt32 DecDivMod1E9(Decimal& value);
}
[__BlockReflectionAttribute]
public class System.DefaultBinder : Binder {
    private static Primitives[] _primitiveConversions;
    private static DefaultBinder();
    public sealed virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    public sealed virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public sealed virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    public static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    private static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
    private static bool CanChangePrimitive(Type source, Type target);
    private static bool CanChangePrimitiveObjectToType(object source, Type type);
    private static bool CanPrimitiveWiden(Type source, Type target);
}
[DebuggerDisplayAttribute("Target method(s) = {GetTargetMethodsDescriptionForDebugger()}")]
public abstract class System.Delegate : object {
    [__BlockReflectionAttribute]
protected internal object m_firstParameter;
    [__BlockReflectionAttribute]
protected internal object m_helperObject;
    [__BlockReflectionAttribute]
protected internal IntPtr m_extraFunctionPointerOrData;
    [__BlockReflectionAttribute]
protected internal IntPtr m_functionPointer;
    [ThreadStaticAttribute]
[__BlockReflectionAttribute]
protected static string s_DefaultValueString;
    [__BlockReflectionAttribute]
protected static int MulticastThunk;
    [__BlockReflectionAttribute]
protected static int ClosedStaticThunk;
    [__BlockReflectionAttribute]
protected static int OpenStaticThunk;
    [__BlockReflectionAttribute]
protected static int ClosedInstanceThunkOverGenericMethod;
    [__BlockReflectionAttribute]
protected static int DelegateInvokeThunk;
    [__BlockReflectionAttribute]
protected static int OpenInstanceThunk;
    [__BlockReflectionAttribute]
protected static int ReversePinvokeThunk;
    [__BlockReflectionAttribute]
protected static int ObjectArrayThunk;
    private static int DefaultParamTypeNone;
    private static int DefaultParamTypeBool;
    private static int DefaultParamTypeChar;
    private static int DefaultParamTypeI1;
    private static int DefaultParamTypeI2;
    private static int DefaultParamTypeI4;
    private static int DefaultParamTypeI8;
    private static int DefaultParamTypeR4;
    private static int DefaultParamTypeR8;
    private static int DefaultParamTypeString;
    private static int DefaultParamTypeDefault;
    private static int DefaultParamTypeDecimal;
    private static int DefaultParamTypeDateTime;
    private static int DefaultParamTypeNoneButOptional;
    private static int DefaultParamTypeUI1;
    private static int DefaultParamTypeUI2;
    private static int DefaultParamTypeUI4;
    private static int DefaultParamTypeUI8;
    public MethodInfo Method { get; }
    public object Target { get; }
    internal bool IsOpenStatic { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    [__BlockReflectionAttribute]
protected virtual IntPtr GetThunk(int whichThunk);
    [__BlockReflectionAttribute]
protected virtual bool LoadDefaultValueString();
    internal IntPtr GetFunctionPointer(RuntimeTypeHandle& typeOfFirstParameterIfInstanceDelegate, Boolean& isOpenResolver, Boolean& isInterpreterEntrypoint);
    internal IntPtr GetNativeFunctionPointer();
    [__BlockReflectionAttribute]
protected void InitializeClosedInstance(object firstParameter, IntPtr functionPointer);
    [__BlockReflectionAttribute]
protected void InitializeClosedInstanceSlow(object firstParameter, IntPtr functionPointer);
    [__BlockReflectionAttribute]
protected void InitializeClosedInstanceWithGVMResolution(object firstParameter, RuntimeMethodHandle tokenOfGenericVirtualMethod);
    private void InitializeClosedInstanceToInterface(object firstParameter, IntPtr dispatchCell);
    private void InitializeClosedInstanceWithoutNullCheck(object firstParameter, IntPtr functionPointer);
    [__BlockReflectionAttribute]
protected void InitializeClosedStaticThunk(object firstParameter, IntPtr functionPointer, IntPtr functionPointerThunk);
    [__BlockReflectionAttribute]
protected void InitializeClosedStaticWithoutThunk(object firstParameter, IntPtr functionPointer);
    [__BlockReflectionAttribute]
protected void InitializeOpenStaticThunk(object firstParameter, IntPtr functionPointer, IntPtr functionPointerThunk);
    [__BlockReflectionAttribute]
protected void InitializeOpenStaticWithoutThunk(object firstParameter, IntPtr functionPointer);
    [__BlockReflectionAttribute]
protected void InitializeReversePInvokeThunk(object firstParameter, IntPtr functionPointer, IntPtr functionPointerThunk);
    [__BlockReflectionAttribute]
protected void InitializeReversePInvokeWithoutThunk(object firstParameter, IntPtr functionPointer);
    [__BlockReflectionAttribute]
protected void InitializeOpenInstanceThunk(object firstParameter, IntPtr functionPointer, IntPtr functionPointerThunk);
    [__BlockReflectionAttribute]
protected void InitializeOpenInstanceWithoutThunk(object firstParameter, IntPtr functionPointer, IntPtr functionPointerThunk);
    [__BlockReflectionAttribute]
protected void InitializeOpenInstanceThunkDynamic(IntPtr functionPointer, IntPtr functionPointerThunk);
    internal void SetClosedStaticFirstParameter(object firstParameter);
    [__BlockReflectionAttribute]
protected IntPtr GetActualTargetFunctionPointer(object thisObject);
    public virtual int GetHashCode();
    private bool IsDynamicDelegate();
    [DebuggerGuidedStepThroughAttribute]
protected virtual object DynamicInvokeImpl(Object[] args);
    [DebuggerGuidedStepThroughAttribute]
public object DynamicInvoke(Object[] args);
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    public static Delegate Combine(Delegate[] delegates);
    private MulticastDelegate NewMulticastDelegate(Delegate[] invocationList, int invocationCount, bool thisIsMultiCastAlready);
    internal MulticastDelegate NewMulticastDelegate(Delegate[] invocationList, int invocationCount);
    private bool TrySetSlot(Delegate[] a, int index, Delegate o);
    protected virtual Delegate CombineImpl(Delegate d);
    private Delegate[] DeleteFromInvocationList(Delegate[] invocationList, int invocationCount, int deleteIndex, int deleteCount);
    private bool EqualInvocationLists(Delegate[] a, Delegate[] b, int start, int count);
    protected virtual Delegate RemoveImpl(Delegate d);
    public virtual Delegate[] GetInvocationList();
    public MethodInfo get_Method();
    protected virtual MethodInfo GetMethodImpl();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    public object get_Target();
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public virtual object Clone();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal bool get_IsOpenStatic();
    internal static bool InternalEqualTypes(object a, object b);
    internal static Delegate CreateObjectArrayDelegate(Type t, Func`2<Object[], object> handler);
    internal static Delegate CreateDelegate(EETypePtr delegateEEType, IntPtr ldftnResult, object thisObject, bool isStatic, bool isOpen);
    private string GetTargetMethodsDescriptionForDebugger();
    private static string DebuggerFunctionPointerFormattingHook(IntPtr functionPointer, RuntimeTypeHandle typeOfFirstParameterIfInstanceDelegate);
    internal bool TryGetDefaultParameterValue(RuntimeTypeHandle thType, int argIndex, Object& defaultValue);
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public SuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConditionString>k__BackingField;
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    [CompilerGeneratedAttribute]
public string get_ConditionString();
}
public static class System.Diagnostics.Contracts.Contract : object {
    [ThreadStaticAttribute]
private static bool t_assertingMustUseRewriter;
    public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition, string userMessage);
    public static void Requires(bool condition);
    public static void Requires(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    public static T Result();
    public static T ValueAtReturn(T& value);
    public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EndContractBlock();
    [DebuggerNonUserCodeAttribute]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
[AttributeUsageAttribute("5124")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    private Type _typeWithContracts;
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    private Type _typeIAmAContractFor;
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.Diagnostics.Contracts.ContractException : Exception {
    private ContractFailureKind _kind;
    private string _userMessage;
    private string _condition;
    public ContractFailureKind Kind { get; }
    public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    private ContractException(SerializationInfo info, StreamingContext context);
    public ContractFailureKind get_Kind();
    public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    private ContractFailureKind _failureKind;
    private string _message;
    private string _condition;
    private Exception _originalException;
    private bool _handled;
    private bool _unwind;
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    public void SetHandled();
    public bool get_Unwind();
    public void SetUnwind();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    private string _category;
    private string _setting;
    private bool _enabled;
    private string _value;
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    public string get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("256")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    private string _publicName;
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("237")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    private bool _value;
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("6884")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
public static class System.Diagnostics.Debug : object {
    private static object s_lock;
    [ThreadStaticAttribute]
private static int s_indentLevel;
    private static int s_indentSize;
    private static bool s_needIndent;
    private static string s_indentString;
    internal static Action`4<string, string, string, string> s_ShowDialog;
    internal static Action`1<string> s_WriteCore;
    private static object s_ForLock;
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static Debug();
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    internal static void ContractFailure(bool condition, string message, string detailMessage, string failureKindMessage);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    private static string FormatAssert(string stackTrace, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
    private static string GetIndentString();
    [DebuggerHiddenAttribute]
[IntrinsicAttribute]
internal static void DebugBreak();
    private static void ShowDialog(string stackTrace, string message, string detailMessage, string errorSource);
    private static void WriteCore(string message);
    private static void WriteToDebugger(string message);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Diagnostics.DebugAnnotations : object {
    public static void PreviousCallContainsDebuggerStepInCode();
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggingModes <DebuggingFlags>k__BackingField;
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    [CompilerGeneratedAttribute]
public DebuggingModes get_DebuggingFlags();
}
public static class System.Diagnostics.Debugger : object {
    private static bool _isDebuggerAttached;
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    private static Debugger();
    [DebuggerHiddenAttribute]
public static void Break();
    public static bool get_IsAttached();
    public static bool Launch();
    public static void NotifyOfCrossThreadDependency();
    public static void Log(int level, string category, string message);
    public static bool IsLogging();
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggerBrowsableState <State>k__BackingField;
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    [CompilerGeneratedAttribute]
public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[ReflectionBlockedAttribute]
[AttributeUsageAttribute("225")]
[__BlockReflectionAttribute]
public class System.Diagnostics.DebuggerGuidedStepThroughAttribute : Attribute {
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[DependencyReductionRootAttribute]
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <ProxyTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerTypeProxyAttribute(Type type);
    public DebuggerTypeProxyAttribute(string typeName);
    [CompilerGeneratedAttribute]
public string get_ProxyTypeName();
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <VisualizerObjectSourceTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualizerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string VisualizerObjectSourceTypeName { get; }
    public string VisualizerTypeName { get; }
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerVisualizerAttribute(string visualizerTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer);
    public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    [CompilerGeneratedAttribute]
public string get_VisualizerObjectSourceTypeName();
    [CompilerGeneratedAttribute]
public string get_VisualizerTypeName();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[__BlockReflectionAttribute]
public static class System.Diagnostics.LowLevelDebugFuncEval : object {
    private static Action s_highLevelDebugFuncEvalHelper;
    private static Action`1<long> s_highLevelDebugFuncEvalAbortHelper;
    [RuntimeExportAttribute("DebugFuncEvalHelper")]
public static void DebugFuncEvalHelper();
    [NativeCallableAttribute]
public static void DebugFuncEvalAbortHelper(long pointerFromDebugger);
    public static void SetHighLevelDebugFuncEvalHelper(Action highLevelDebugFuncEvalHelper);
    public static void SetHighLevelDebugFuncEvalAbortHelper(Action`1<long> highLevelDebugFuncEvalAbortHelper);
}
public class System.Diagnostics.StackFrame : object {
    private MethodBase _method;
    private int _nativeOffset;
    private int _ilOffset;
    private string _fileName;
    private int _lineNumber;
    private int _columnNumber;
    private bool _isLastFrameFromForeignExceptionStackTrace;
    public static int OFFSET_UNKNOWN;
    private IntPtr _ipAddress;
    private bool _needFileInfo;
    public StackFrame(bool needFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool needFileInfo);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    internal StackFrame(IntPtr ipAddress, bool needFileInfo);
    private void InitMembers();
    internal virtual void SetMethodBase(MethodBase mb);
    internal virtual void SetOffset(int iOffset);
    internal virtual void SetILOffset(int iOffset);
    internal virtual void SetFileName(string strFName);
    internal virtual void SetLineNumber(int iLine);
    internal virtual void SetColumnNumber(int iCol);
    internal virtual void SetIsLastFrameFromForeignExceptionStackTrace(bool fIsLastFrame);
    internal virtual bool GetIsLastFrameFromForeignExceptionStackTrace();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual int GetILOffset();
    public virtual string GetFileName();
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    public virtual string ToString();
    private void InitializeForIpAddress(IntPtr ipAddress, bool needFileInfo);
    private void BuildStackFrame(int frameIndex, bool needFileInfo);
    private IntPtr LocateIpAddressForStackFrame(int frameIndex);
    internal IntPtr GetNativeIPAddress();
    internal bool HasMethod();
    private bool AppendStackFrameWithoutMethodBase(StringBuilder builder);
    internal void AppendToStackTrace(StringBuilder builder);
}
[ExtensionAttribute]
public static class System.Diagnostics.StackFrameExtensions : object {
    [ExtensionAttribute]
public static IntPtr GetNativeImageBase(StackFrame stackFrame);
    [ExtensionAttribute]
public static IntPtr GetNativeIP(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasILOffset(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasMethod(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasNativeImage(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasSource(StackFrame stackFrame);
}
public class System.Diagnostics.StackTrace : object {
    public static int METHODS_TO_SKIP;
    private StackFrame[] _stackFrames;
    public int FrameCount { get; }
    public StackTrace(bool needFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool needFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool needFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool needFileInfo);
    public StackTrace(StackFrame frame);
    internal StackTrace(IntPtr[] ipAddresses, int startIndex, int endIndex, bool needFileInfo);
    private void InitializeForThreadFrameIndex(int skipFrames, bool needFileInfo);
    private void InitializeForExceptionFrameIndex(Exception exception, int skipFrames, bool needFileInfo);
    private void InitializeForIpAddressArray(IntPtr[] ipAddresses, int skipFrames, int endFrameIndex, bool needFileInfo);
    public virtual int get_FrameCount();
    public virtual StackFrame GetFrame(int index);
    public virtual StackFrame[] GetFrames();
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    private static ushort MAX_ACTIVITY_DEPTH;
    public static ActivityTracker Instance { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId);
    public void Enable();
    public static ActivityTracker get_Instance();
    private ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class System.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class System.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
internal class System.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddBinary(string value, int size);
    internal void AddNullTerminatedString(string value);
    internal void AddBinary(Array value, int size);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class System.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class System.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.EtwEventProvider : object {
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventWriteTransferWrapper(long registrationHandle, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class System.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum System.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventProviderType eventProviderType;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    public EventCommand Command { get; internal set; }
    public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; internal set; }
    internal EventOpcode Opcode { get; internal set; }
    internal EventKeywords Keywords { get; internal set; }
    internal EventTags Tags { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal void set_Level(EventLevel value);
    internal EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventTags value);
}
[__BlockReflectionAttribute]
public class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    internal int TraceLoggingId { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    internal int get_TraceLoggingId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    internal string Name { get; internal set; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public class System.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    [CompilerGeneratedAttribute]
private void add__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [__BlockReflectionAttribute]
public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [__BlockReflectionAttribute]
public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    public static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    private static void DisposeOnShutdown(object sender, EventArgs e);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    [ConditionalAttribute("DEBUG")]
internal static void Validate();
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.EventPayload : object {
    private List`1<string> m_names;
    private List`1<object> m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(List`1<string> payloadNames, List`1<object> payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.EventPayload/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    private static bool m_setInformationMissing;
    internal IEventProvider m_eventProvider;
    private EtwEnableCallback m_etwCallback;
    private long m_regHandle;
    private byte m_level;
    private long m_anyKeywordMask;
    private long m_allKeywordMask;
    private List`1<SessionInfo> m_liveSessions;
    private bool m_enabled;
    private string m_providerName;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static int s_basicTypeAllocationBufferSize;
    private static int s_etwMaxNumberArguments;
    private static int s_etwAPIMaxRefObjCount;
    private static int s_maxEventDataDescriptors;
    private static int s_traceEventMaximumSize;
    private static int s_traceEventMaximumStringSize;
    private static Int32[] nibblebits;
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    internal EventProvider(EventProviderType providerType);
    private static EventProvider();
    internal void Register(EventSource eventSource);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual override void Finalize();
    private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, long anyKeyword, long allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    private static int FindNull(Byte[] buffer, int idx);
    private List`1<Tuple`2<SessionInfo, bool>> GetSessions();
    private static void GetSessionInfoCallback(int etwSessionId, long matchAllKeywords, List`1& sessionList);
    private void GetSessionInfo(SessionInfoCallback action, List`1& sessionList);
    private static int IndexOfSessionInList(List`1<SessionInfo> sessions, int etwSessionId);
    private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(int error);
    private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    protected internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    internal bool WriteEventRaw(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback);
    private UInt32 EventUnregister(long registrationHandle);
    private static int bitcount(UInt32 n);
    private static int bitindex(UInt32 n);
    [SecurityCriticalAttribute]
internal int SetInformation(EVENT_INFO_CLASS eventInfoClass, IntPtr data, UInt32 dataSize);
}
internal enum System.Diagnostics.Tracing.EventProviderType : Enum {
    public int value__;
    public static EventProviderType None;
    public static EventProviderType ETW;
    public static EventProviderType EventPipe;
}
public class System.Diagnostics.Tracing.EventSource : object {
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceDisposed;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_etwProvider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    internal static UInt32 s_currentPid;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    [ThreadStaticAttribute]
private static bool m_EventSourceInDecodeObject;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    internal static string s_ActivityStartSuffix;
    internal static string s_ActivityStopSuffix;
    private static Byte[] namespaceBytes;
    private Byte[] providerMetadata;
    private static bool m_EventSourcePreventRecursion;
    public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    internal static Guid InternalCurrentThreadActivityId { get; }
    internal static Guid FallbackActivityId { get; }
    public Exception ConstructionException { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; private set; }
    private bool SelfDescribingEvents { get; private set; }
    public static Guid CurrentThreadActivityId { get; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    public EventSource(string eventSourceName);
    public EventSource(string eventSourceName, EventSourceSettings config);
    public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    public static IEnumerable`1<EventSource> GetSources();
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    internal static Guid get_InternalCurrentThreadActivityId();
    internal static Guid get_FallbackActivityId();
    public Exception get_ConstructionException();
    public string GetTrait(string key);
    public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    internal virtual void GetMetadata(Guid& eventSourceGuid, String& eventSourceName, EventMetadata[]& eventData, Byte[]& manifestBytes);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void WriteEventRaw(string eventName, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private object DecodeObject(int eventId, int parameterId, EventData*& data);
    private EventDispatcher GetDispatcher(EventListener listener);
    private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(ParameterInfo[] infos, Object[] args);
    private void WriteToAllListeners(int eventId, Guid* activityID, Guid* childActivityID, int eventDataCount, EventData* data);
    internal void WriteToAllListeners(int eventId, UInt32* osThreadId, DateTime* timeStamp, Guid* activityID, Guid* childActivityID, Object[] args);
    private void DispatchToAllListeners(int eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs);
    private void WriteEventString(EventLevel level, long keywords, string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(string eventName, Exception innerEx);
    private void ValidateEventOpcodeForTransfer(EventMetadata& eventData, string eventName);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, EventProviderType eventProviderType, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    private void EnsureDescriptorsInitialized();
    private bool SendManifest(Byte[] rawManifest);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    private EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private void set_ThrowOnEventWriteErrors(bool value);
    private bool get_SelfDescribingEvents();
    private void set_SelfDescribingEvents(bool value);
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, Guid* pChildActivityId, EventPayload payload);
    [NonEventAttribute]
private void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
    [SecuritySafeCriticalAttribute]
public static void SetCurrentThreadActivityId(Guid activityId);
    [SecuritySafeCriticalAttribute]
public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    [SecuritySafeCriticalAttribute]
public static Guid get_CurrentThreadActivityId();
    private int GetParameterCount(EventMetadata eventData);
    private Type GetDataType(EventMetadata eventData, int parameterId);
    private Type EventTypeToType(EventParameterType type);
}
internal class System.Diagnostics.Tracing.EventSourceActivity : object {
    private EventSource eventSource;
    private EventSourceOptions startStopOptions;
    internal Guid activityId;
    private State state;
    private string eventName;
    internal static Guid s_empty;
    public EventSource EventSource { get; }
    public Guid Id { get; }
    private bool StartEventWasFired { get; }
    public EventSourceActivity(EventSource eventSource);
    public static EventSourceActivity op_Implicit(EventSource eventSource);
    public EventSource get_EventSource();
    public Guid get_Id();
    public EventSourceActivity Start(string eventName, EventSourceOptions options, T data);
    public EventSourceActivity Start(string eventName);
    public EventSourceActivity Start(string eventName, EventSourceOptions options);
    public EventSourceActivity Start(string eventName, T data);
    public void Stop(T data);
    public void Stop(string eventName);
    public void Stop(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName);
    public void Write(EventSource source, string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
    private EventSourceActivity Start(string eventName, EventSourceOptions& options, T& data);
    private void Write(EventSource eventSource, string eventName, EventSourceOptions& options, T& data);
    private void Stop(string eventName, T& data);
    private bool get_StartEventWasFired();
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
[__BlockReflectionAttribute]
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    internal static byte keywordsSet;
    internal static byte tagsSet;
    internal static byte levelSet;
    internal static byte opcodeSet;
    internal static byte activityOptionsSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    private string m_message;
    private string m_eventName;
    private EventSource m_eventSource;
    private ReadOnlyCollection`1<string> m_payloadNames;
    private Guid m_activityId;
    private Nullable`1<long> m_osThreadId;
    internal EventTags m_tags;
    internal EventOpcode m_opcode;
    internal EventLevel m_level;
    internal EventKeywords m_keywords;
    public string EventName { get; internal set; }
    public int EventId { get; internal set; }
    public Guid ActivityId { get; internal set; }
    public Guid RelatedActivityId { get; internal set; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public EventTags Tags { get; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; }
    public long OSThreadId { get; internal set; }
    public DateTime TimeStamp { get; internal set; }
    internal EventWrittenEventArgs(EventSource eventSource);
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    public Guid get_ActivityId();
    internal void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public EventTags get_Tags();
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
    [__BlockReflectionAttribute]
public long get_OSThreadId();
    [__BlockReflectionAttribute]
internal void set_OSThreadId(long value);
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
[__BlockReflectionAttribute]
internal void set_TimeStamp(DateTime value);
}
internal class System.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, ushort fixedCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, Byte[] custom);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
internal interface System.Diagnostics.Tracing.IEventProvider {
    public abstract virtual UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    public abstract virtual UInt32 EventUnregister(long registrationHandle);
    public abstract virtual int EventWriteTransferWrapper(long registrationHandle, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    public abstract virtual int EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    public abstract virtual IntPtr DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal static class System.Diagnostics.Tracing.Internal.Environment : object {
    public static string NewLine;
    private static ResourceManager rm;
    public static int TickCount { get; }
    private static Environment();
    public static int get_TickCount();
    public static string GetResourceString(string key, Object[] args);
    public static string GetRuntimeResourceString(string key, Object[] args);
}
internal class System.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    internal PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    private static String[] s_escapes;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    internal static ulong ValidPredefinedChannelKeywords;
    private ulong nextChannelKeywordBit;
    private static int MaxCountChannels;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    private static ManifestBuilder();
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private EventChannelType EventChannelToChannelType(EventChannel channel);
    private EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel, ulong channelKeyword);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static List`1<CultureInfo> GetSupportedCultures(ResourceManager resources);
    private static string GetLevelName(EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private string GetKeywords(ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
    private string GetTypeNameHelper(Type type);
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public static int MaxChunkSize;
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class System.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.NoOpEventProvider : object {
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventWriteTransferWrapper(long registrationHandle, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal class System.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    private Func`2<PropertyValue, PropertyValue> hasValueGetter;
    private Func`2<PropertyValue, PropertyValue> valueGetter;
    public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    [__BlockReflectionAttribute]
public static Func`2<object, PropertyValue> GetFactory(Type type);
    [__BlockReflectionAttribute]
public object get_ReferenceValue();
    [__BlockReflectionAttribute]
public Scalar get_ScalarValue();
    [__BlockReflectionAttribute]
public int get_ScalarLength();
    [__BlockReflectionAttribute]
public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
internal static class System.Diagnostics.Tracing.Resources : object {
    internal static string GetResourceString(string key, Object[] args);
    public static string GetRuntimeResourceString(string key, Object[] args);
}
internal class System.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class System.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    internal static int SHIFT_SESSION_TO_KEYWORD;
    internal static UInt32 MASK;
    internal static UInt32 MAX;
    public static SessionMask All { get; }
    public bool Item { get; public set; }
    public SessionMask(SessionMask m);
    public SessionMask(UInt32 mask);
    public bool IsEqualOrSupersetOf(SessionMask m);
    public static SessionMask get_All();
    public static SessionMask FromId(int perEventSourceSessionId);
    public ulong ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public bool get_Item(int perEventSourceSessionId);
    public void set_Item(int perEventSourceSessionId, bool value);
    public static SessionMask op_BitwiseOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_BitwiseAnd(SessionMask m1, SessionMask m2);
    public static SessionMask op_ExclusiveOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_OnesComplement(SessionMask m);
    public static ulong op_Explicit(SessionMask m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal static class System.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    public static TraceLoggingEventTypes get_Instance();
    private static TraceLoggingEventTypes InitInstance();
}
internal static class System.Diagnostics.Tracing.Statics : object {
    public static byte DefaultLevel;
    public static byte TraceLoggingChannel;
    public static byte InTypeMask;
    public static byte InTypeFixedCountFlag;
    public static byte InTypeVariableCountFlag;
    public static byte InTypeCustomCountFlag;
    public static byte InTypeCountMask;
    public static byte InTypeChainFlag;
    public static byte OutTypeMask;
    public static byte OutTypeChainFlag;
    public static EventTags EventTagsMask;
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static byte Combine(int settingValue1, int settingValue2, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static object CreateInstance(Type type, Object[] parameters);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    public static MethodInfo GetDeclaredStaticMethod(Type declaringType, string name);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static Delegate CreateDelegate(Type delegateType, MethodInfo methodInfo);
    public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.TplEtwProvider : EventSource {
    public static TplEtwProvider Log;
    public bool Debug { get; }
    private static TplEtwProvider();
    public bool get_Debug();
    public void DebugFacilityMessage(string Facility, string Message);
    public void DebugFacilityMessage1(string Facility, string Message, string Arg);
    public void SetActivityId(Guid Id);
}
internal class System.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    internal static TraceLoggingDataCollector Instance;
    private static TraceLoggingDataCollector();
    public int BeginBufferedArray();
    public void EndBufferedArray(int bookmark, int count);
    public TraceLoggingDataCollector AddGroup();
    public void AddScalar(PropertyValue value);
    public void AddScalar(long value);
    public void AddScalar(double value);
    public void AddNullTerminatedString(string value);
    public void AddBinary(string value);
    public void AddArray(PropertyValue value, int elementSize);
}
internal enum System.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
[__BlockReflectionAttribute]
public class System.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    internal string Name { get; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    internal EventKeywords get_Keywords();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
}
internal class System.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddBinary(string name, TraceLoggingDataType type);
    public void AddNullTerminatedString(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    public void AddCustom(string name, TraceLoggingDataType type, Byte[] metadata);
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class System.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
    public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Double : ValueType {
    private double m_value;
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    internal static double NegativeZero;
    [NonVersionableAttribute]
public static bool IsFinite(double d);
    [NonVersionableAttribute]
public static bool IsInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNaN(double d);
    [NonVersionableAttribute]
public static bool IsNegative(double d);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNormal(double d);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(double d);
    [NonVersionableAttribute]
public static bool IsSubnormal(double d);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public static bool op_Equality(double left, double right);
    [NonVersionableAttribute]
public static bool op_Inequality(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, IFormatProvider provider);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.DTSubString : ValueType {
    internal ReadOnlySpan`1<char> s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DuplicateWaitObjectException : ArgumentException {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_duplicateWaitObjectMessage;
    private static string DuplicateWaitObjectMessage { get; }
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    private static DuplicateWaitObjectException();
    private static string get_DuplicateWaitObjectMessage();
}
internal class System.EETypePtr : ValueType {
    private EEType* _value;
    internal IntPtr RawValue { get; }
    internal bool IsNull { get; }
    internal bool IsArray { get; }
    internal bool IsSzArray { get; }
    internal bool IsPointer { get; }
    internal bool IsByRef { get; }
    internal bool IsValueType { get; }
    internal bool IsString { get; }
    internal bool IsPrimitive { get; }
    internal bool IsEnum { get; }
    internal bool IsGenericTypeDefinition { get; }
    internal bool IsGeneric { get; }
    internal GenericArgumentCollection Instantiation { get; }
    internal EETypePtr GenericDefinition { get; }
    internal bool IsDefType { get; }
    internal bool IsDynamicType { get; }
    internal bool IsInterface { get; }
    internal bool IsAbstract { get; }
    internal bool IsByRefLike { get; }
    internal bool IsNullable { get; }
    internal bool HasCctor { get; }
    internal EETypePtr NullableType { get; }
    internal EETypePtr ArrayElementType { get; }
    internal int ArrayRank { get; }
    internal InterfaceCollection Interfaces { get; }
    internal EETypePtr BaseType { get; }
    internal ushort ComponentSize { get; }
    internal UInt32 BaseSize { get; }
    internal bool HasPointers { get; }
    internal UInt32 ValueTypeSize { get; }
    internal RhCorElementType CorElementType { get; }
    internal RhCorElementTypeInfo CorElementTypeInfo { get; }
    public EETypePtr(IntPtr value);
    internal EETypePtr(EEType* value);
    internal EEType* ToPointer();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EETypePtr p);
    public static bool op_Equality(EETypePtr value1, EETypePtr value2);
    public static bool op_Inequality(EETypePtr value1, EETypePtr value2);
    public virtual int GetHashCode();
    public bool FastEquals(EETypePtr other);
    internal bool FastEqualsUnreliable(EETypePtr other);
    internal IntPtr get_RawValue();
    internal bool get_IsNull();
    internal bool get_IsArray();
    internal bool get_IsSzArray();
    internal bool get_IsPointer();
    internal bool get_IsByRef();
    internal bool get_IsValueType();
    internal bool get_IsString();
    internal bool get_IsPrimitive();
    internal bool get_IsEnum();
    internal bool get_IsGenericTypeDefinition();
    internal bool get_IsGeneric();
    internal GenericArgumentCollection get_Instantiation();
    internal EETypePtr get_GenericDefinition();
    internal bool get_IsDefType();
    internal bool get_IsDynamicType();
    internal bool get_IsInterface();
    internal bool get_IsAbstract();
    internal bool get_IsByRefLike();
    internal bool get_IsNullable();
    internal bool get_HasCctor();
    internal EETypePtr get_NullableType();
    internal EETypePtr get_ArrayElementType();
    internal int get_ArrayRank();
    internal InterfaceCollection get_Interfaces();
    internal EETypePtr get_BaseType();
    internal ushort get_ComponentSize();
    internal UInt32 get_BaseSize();
    internal bool get_HasPointers();
    internal UInt32 get_ValueTypeSize();
    internal RhCorElementType get_CorElementType();
    internal RhCorElementTypeInfo get_CorElementTypeInfo();
    [IntrinsicAttribute]
internal static EETypePtr EETypePtrOf();
}
[__BlockReflectionAttribute]
public class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
}
internal enum System.EndNoGCRegionStatus : Enum {
    public int value__;
    public static EndNoGCRegionStatus Succeeded;
    public static EndNoGCRegionStatus NotInProgress;
    public static EndNoGCRegionStatus GCInduced;
    public static EndNoGCRegionStatus AllocationExceeded;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Enum : ValueType {
    private static NamesAndValueComparer s_nameAndValueComparer;
    private string LastResortToString { get; }
    private static Enum();
    public sealed virtual int CompareTo(object target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static string Format(Type enumType, object value, string format);
    private static string Format(EnumInfo enumInfo, object value, string format);
    private static string DoFormatD(ulong rawValue, RhCorElementType corElementType);
    private static string DoFormatX(ulong rawValue, RhCorElementType corElementType);
    private static string DoFormatG(EnumInfo enumInfo, ulong rawValue);
    private static string DoFormatF(EnumInfo enumInfo, ulong rawValue);
    internal object GetValue();
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    [IntrinsicAttribute]
public bool HasFlag(Enum flag);
    public static bool IsDefined(Type enumType, object value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static TEnum Parse(string value);
    public static TEnum Parse(string value, bool ignoreCase);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    public static object ToObject(Type enumType, byte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    public static object ToObject(Type enumType, short value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    public static object ToObject(Type enumType, int value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    public static object ToObject(Type enumType, long value);
    private static object ToObject(Type enumType, char value);
    private static object ToObject(Type enumType, bool value);
    private static object ToObjectWorker(Type enumType, long value);
    internal static object ToObject(EETypePtr enumEEType, long value);
    public static object ToObject(Type enumType, object value);
    public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParse(Type enumType, string value, Object& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    public static bool TryParse(string value, TEnum& result);
    public virtual string ToString();
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    private static EnumInfo GetEnumInfo(Type enumType);
    private static bool ValueTypeMatchesEnumType(Type enumType, object value);
    internal static ulong ToUInt64(object value);
    private static bool TryGetUnboxedValueOfEnumOrInteger(object value, UInt64& result);
    private static string GetNameIfAny(EnumInfo enumInfo, ulong rawValue);
    private static bool TryParseEnum(Type enumType, string value, bool ignoreCase, Object& result, Exception& exception);
    private static bool TryParseAsInteger(EETypePtr enumEEType, string value, int valueOffset, Object& result);
    private static bool StillLooksLikeInteger(string value, int index);
    [ConditionalAttribute("BIGENDIAN")]
private static void AdjustForEndianness(Byte*& pValue, EETypePtr enumEEType);
    private string get_LastResortToString();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal static class System.Environment : object {
    public static int TickCount { get; }
    public static int CurrentManagedThreadId { get; }
    public static bool HasShutdownStarted { get; }
    public static string NewLine { get; }
    public static string StackTrace { get; }
    public static int ProcessorCount { get; }
    internal static int CurrentNativeThreadId { get; }
    internal static long TickCount64 { get; }
    internal static string SystemDirectory { get; }
    public static int get_TickCount();
    public static void FailFast(string message);
    public static void FailFast(string message, Exception exception);
    internal static void FailFast(string message, Exception exception, string errorSource);
    public static string GetEnvironmentVariable(string variable);
    public static int get_CurrentManagedThreadId();
    public static bool get_HasShutdownStarted();
    public static string get_NewLine();
    public static string get_StackTrace();
    public static int get_ProcessorCount();
    internal static int get_CurrentNativeThreadId();
    internal static long get_TickCount64();
    public static string ExpandEnvironmentVariables(string name);
    internal static string get_SystemDirectory();
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EventArgs : object {
    public static EventArgs Empty;
    private static EventArgs();
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Exception : object {
    internal string _message;
    private IDictionary _data;
    private Exception _innerException;
    private string _helpURL;
    private string _source;
    private int _HResult;
    private string _stackTrace;
    private IntPtr[] _corDbgStackTrace;
    private int _idxFirstFreeStackTraceEntry;
    private static object s_EDILock;
    internal static int CurrentSerializationSignature;
    public string Message { get; }
    public IDictionary Data { get; }
    public MethodBase TargetSite { get; }
    public Exception InnerException { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    public int HResult { get; public set; }
    public string StackTrace { get; }
    private bool HasBeenThrown { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    protected Exception(SerializationInfo info, StreamingContext context);
    private static Exception();
    private void Init();
    public virtual string get_Message();
    public Type GetType();
    public virtual IDictionary get_Data();
    public MethodBase get_TargetSite();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    internal void AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject);
    internal bool TryGetRestrictedErrorObject(Object& restrictedErrorObject);
    internal bool TryGetRestrictedErrorDetails(String& restrictedError, String& restrictedErrorReference, String& restrictedCapabilitySid);
    internal void SetMessage(string msg);
    private string GetClassName();
    public virtual Exception GetBaseException();
    public Exception get_InnerException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private string GetStackTrace(bool needFileInfo);
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string ToString();
    private string ToString(bool needFileLineInfo, bool needMessage);
    public int get_HResult();
    public void set_HResult(int value);
    public virtual string get_StackTrace();
    internal IntPtr[] GetStackIPs();
    private void AppendStackIP(IntPtr IP, bool isFirstRethrowFrame);
    private void GrowStackTrace();
    private bool get_HasBeenThrown();
    [RuntimeExportAttribute("AppendExceptionStackFrame")]
private static void AppendExceptionStackFrame(object exceptionObj, IntPtr IP, int flags);
    internal EdiCaptureState CaptureEdiState();
    internal void RestoreEdiState(EdiCaptureState ediCaptureState);
    internal Byte[] SerializeForDump();
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument text;
    public static ExceptionArgument values;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument task;
    public static ExceptionArgument s;
    public static ExceptionArgument input;
    public static ExceptionArgument ownedMemory;
    public static ExceptionArgument list;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument pointer;
    public static ExceptionArgument start;
    public static ExceptionArgument format;
    public static ExceptionArgument culture;
    public static ExceptionArgument comparer;
    public static ExceptionArgument comparable;
    public static ExceptionArgument source;
    public static ExceptionArgument state;
    public static ExceptionArgument length;
    public static ExceptionArgument comparisonType;
    public static ExceptionArgument manager;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_NullArray;
    public static ExceptionResource TaskT_TransitionToFinal_AlreadyCompleted;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NullException;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NoExceptions;
    public static ExceptionResource NotSupported_StringComparison;
    public static ExceptionResource ConcurrentCollection_SyncRoot_NotSupported;
}
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    internal ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    protected FormatException(SerializationInfo info, StreamingContext context);
}
public abstract class System.FormattableString : object {
    public string Format { get; }
    public int ArgumentCount { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] GetArguments();
    public abstract virtual int get_ArgumentCount();
    public abstract virtual object GetArgument(int index);
    public abstract virtual string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    [__BlockReflectionAttribute]
public static string CurrentCulture(FormattableString formattable);
    public virtual string ToString();
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    private static UInt32 PressureCount;
    private static UInt32 MinGCMemoryPressureBudget;
    private static UInt32 MaxGCMemoryPressureRatio;
    private static Int32[] s_gcCounts;
    private static Int64[] s_addPressure;
    private static Int64[] s_removePressure;
    private static UInt32 s_iteration;
    public static int MaxGeneration { get; }
    private static GC();
    public static int GetGeneration(object obj);
    public static int GetGeneration(WeakReference wo);
    public static void Collect(int generation);
    public static void Collect();
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    public static void CancelFullGCNotification();
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    private static bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    public static void EndNoGCRegion();
    public static void WaitForPendingFinalizers();
    public static void SuppressFinalize(object obj);
    public static void ReRegisterForFinalize(object obj);
    [IntrinsicAttribute]
public static void KeepAlive(object obj);
    public static int get_MaxGeneration();
    public static int CollectionCount(int generation);
    private static void CheckCollectionCount();
    private static long InterlockedAddMemoryPressure(Int64& pAugend, long addend);
    public static void AddMemoryPressure(long bytesAllocated);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static long GetTotalMemory(bool forceFullCollection);
    public static long GetAllocatedBytesForCurrentThread();
    internal static void GetMemoryInfo(UInt32& highMemLoadThreshold, UInt64& totalPhysicalMem, UInt32& lastRecordedMemLoad, UIntPtr& lastRecordedHeapSize, UIntPtr& lastRecordedFragmentation);
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Func`2<object, bool> _callback;
    private GCHandle _weakTargetObj;
    public static void Register(Func`2<object, bool> callback, object targetObj);
    private void Setup(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
internal enum System.Globalization.BidiCategory : Enum {
    public int value__;
    public static BidiCategory LeftToRight;
    public static BidiCategory LeftToRightEmbedding;
    public static BidiCategory LeftToRightOverride;
    public static BidiCategory RightToLeft;
    public static BidiCategory RightToLeftArabic;
    public static BidiCategory RightToLeftEmbedding;
    public static BidiCategory RightToLeftOverride;
    public static BidiCategory PopDirectionalFormat;
    public static BidiCategory EuropeanNumber;
    public static BidiCategory EuropeanNumberSeparator;
    public static BidiCategory EuropeanNumberTerminator;
    public static BidiCategory ArabicNumber;
    public static BidiCategory CommonNumberSeparator;
    public static BidiCategory NonSpacingMark;
    public static BidiCategory BoundaryNeutral;
    public static BidiCategory ParagraphSeparator;
    public static BidiCategory SegmentSeparator;
    public static BidiCategory Whitespace;
    public static BidiCategory OtherNeutrals;
    public static BidiCategory LeftToRightIsolate;
    public static BidiCategory RightToLeftIsolate;
    public static BidiCategory FirstStrongIsolate;
    public static BidiCategory PopDirectionIsolate;
}
public abstract class System.Globalization.Calendar : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    private int _currentEraValue;
    private bool _isReadOnly;
    public static int CurrentEra;
    internal int twoDigitYearMax;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays);
    private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal static int GetSystemTwoDigitYearSetting(CalendarId CalID, int defaultYearValue);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal static int MAX_CALENDARS;
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    internal int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    private static UInt32 CAL_RETURN_NUMBER;
    private static UInt32 CAL_RETURN_GENITIVE_NAMES;
    private static UInt32 CAL_NOUSEROVERRIDE;
    private static UInt32 CAL_SCALNAME;
    private static UInt32 CAL_SMONTHDAY;
    private static UInt32 CAL_SSHORTDATE;
    private static UInt32 CAL_SLONGDATE;
    private static UInt32 CAL_SYEARMONTH;
    private static UInt32 CAL_SDAYNAME7;
    private static UInt32 CAL_SABBREVDAYNAME7;
    private static UInt32 CAL_SMONTHNAME1;
    private static UInt32 CAL_SABBREVMONTHNAME1;
    private static UInt32 CAL_SSHORTESTDAYNAME7;
    private static UInt32 CAL_SERASTRING;
    private static UInt32 CAL_SABBREVERASTRING;
    private static UInt32 CAL_ICALINTVALUE;
    private static UInt32 CAL_ITWODIGITYEARMAX;
    private static UInt32 ENUM_ALL_CALENDARS;
    private static UInt32 LOCALE_SSHORTDATE;
    private static UInt32 LOCALE_SLONGDATE;
    private static UInt32 LOCALE_SYEARMONTH;
    private static UInt32 LOCALE_ICALENDARTYPE;
    internal CalendarData(string localeName, CalendarId calendarId, bool bUseUserOverrides);
    private static CalendarData();
    private static CalendarData CreateInvariant();
    private void InitializeEraNames(string localeName, CalendarId calendarId);
    private void InitializeAbbreviatedEraNames(string localeName, CalendarId calendarId);
    internal static CalendarData GetCalendarData(CalendarId calendarId);
    private static string CalendarIdToCultureName(CalendarId calendarId);
    private bool LoadCalendarDataFromSystem(string localeName, CalendarId calendarId);
    internal static int GetTwoDigitYearMax(CalendarId calendarId);
    internal static int GetCalendars(string localeName, bool useUserOverride, CalendarId[] calendars);
    private static bool SystemSupportsTaiwaneseCalendar();
    private static void CheckSpecialCalendar(CalendarId& calendar, String& localeName);
    private static bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, UInt32 calType, Int32& data);
    private static bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, UInt32 calType, String& data);
    private static BOOL EnumCalendarInfoCallback(Char* lpCalendarInfoString, UInt32 calendar, IntPtr pReserved, Void* lParam);
    private static bool CallEnumCalendarInfo(string localeName, CalendarId calendar, UInt32 calType, UInt32 lcType, String[]& data);
    private static bool GetCalendarDayInfo(string localeName, CalendarId calendar, UInt32 calType, String[]& outputStrings);
    private static bool GetCalendarMonthInfo(string localeName, CalendarId calendar, UInt32 calType, String[]& outputStrings);
    private static BOOL EnumCalendarsCallback(Char* lpCalendarInfoString, UInt32 calendar, IntPtr reserved, Void* lParam);
    private static string GetUserDefaultLocaleName();
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId UNINITIALIZED_VALUE;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
internal class System.Globalization.CalendricalCalculationsHelper : object {
    private static double FullCircleOfArc;
    private static int HalfCircleOfArc;
    private static double TwelveHours;
    private static double Noon2000Jan01;
    internal static double MeanTropicalYearInDays;
    private static double MeanSpeedOfSun;
    private static double LongitudeSpring;
    private static double TwoDegreesAfterSpring;
    private static int SecondsPerDay;
    private static int DaysInUniformLengthCentury;
    private static int SecondsPerMinute;
    private static int MinutesPerDegree;
    private static long s_startOf1810;
    private static long s_startOf1900Century;
    private static Double[] s_coefficients1900to1987;
    private static Double[] s_coefficients1800to1899;
    private static Double[] s_coefficients1700to1799;
    private static Double[] s_coefficients1620to1699;
    private static Double[] s_lambdaCoefficients;
    private static Double[] s_anomalyCoefficients;
    private static Double[] s_eccentricityCoefficients;
    private static Double[] s_coefficients;
    private static Double[] s_coefficientsA;
    private static Double[] s_coefficientsB;
    private static EphemerisCorrectionAlgorithmMap[] s_ephemerisCorrectionTable;
    private static CalendricalCalculationsHelper();
    private static double RadiansFromDegrees(double degree);
    private static double SinOfDegree(double degree);
    private static double CosOfDegree(double degree);
    private static double TanOfDegree(double degree);
    public static double Angle(int degrees, int minutes, double seconds);
    private static double Obliquity(double julianCenturies);
    internal static long GetNumberOfDays(DateTime date);
    private static int GetGregorianYear(double numberOfDays);
    private static double Reminder(double divisor, double dividend);
    private static double NormalizeLongitude(double longitude);
    public static double AsDayFraction(double longitude);
    private static double PolynomialSum(Double[] coefficients, double indeterminate);
    private static double CenturiesFrom1900(int gregorianYear);
    private static double DefaultEphemerisCorrection(int gregorianYear);
    private static double EphemerisCorrection1988to2019(int gregorianYear);
    private static double EphemerisCorrection1900to1987(int gregorianYear);
    private static double EphemerisCorrection1800to1899(int gregorianYear);
    private static double EphemerisCorrection1700to1799(int gregorianYear);
    private static double EphemerisCorrection1620to1699(int gregorianYear);
    private static double EphemerisCorrection(double time);
    public static double JulianCenturies(double moment);
    private static bool IsNegative(double value);
    private static double CopySign(double value, double sign);
    private static double EquationOfTime(double time);
    private static double AsLocalTime(double apparentMidday, double longitude);
    public static double Midday(double date, double longitude);
    private static double InitLongitude(double longitude);
    public static double MiddayAtPersianObservationSite(double date);
    private static double PeriodicTerm(double julianCenturies, int x, double y, double z);
    private static double SumLongSequenceOfPeriodicTerms(double julianCenturies);
    private static double Aberration(double julianCenturies);
    private static double Nutation(double julianCenturies);
    public static double Compute(double time);
    public static double AsSeason(double longitude);
    private static double EstimatePrior(double longitude, double time);
    internal static long PersianNewYearOnOrBefore(long numberOfDays);
}
public static class System.Globalization.CharUnicodeInfo : object {
    internal static char HIGH_SURROGATE_START;
    internal static char HIGH_SURROGATE_END;
    internal static char LOW_SURROGATE_START;
    internal static char LOW_SURROGATE_END;
    internal static int HIGH_SURROGATE_RANGE;
    internal static int UNICODE_CATEGORY_OFFSET;
    internal static int BIDI_CATEGORY_OFFSET;
    internal static int UNICODE_PLANE01_START;
    private static UInt16[] s_pCategoryLevel1Index;
    private static Byte[] s_pCategoriesValue;
    private static UInt16[] s_pNumericLevel1Index;
    private static Byte[] s_pNumericValues;
    private static UInt16[] s_pDigitValues;
    private static CharUnicodeInfo();
    internal static int InternalConvertToUtf32(string s, int index);
    internal static int InternalConvertToUtf32(StringBuilder s, int index);
    internal static int InternalConvertToUtf32(string s, int index, Int32& charLength);
    internal static bool IsWhiteSpace(string s, int index);
    internal static bool IsWhiteSpace(char c);
    internal static double InternalGetNumericValue(int ch);
    internal static ushort InternalGetDigitValues(int ch);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    internal static byte InternalGetCategoryValue(int ch, int offset);
    internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
    internal static BidiCategory GetBidiCategory(string s, int index);
    internal static BidiCategory GetBidiCategory(StringBuilder s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength);
    internal static bool IsCombiningCategory(UnicodeCategory uc);
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CompareInfo : object {
    private static CompareOptions ValidIndexMaskOffFlags;
    private static CompareOptions ValidCompareMaskOffFlags;
    private static CompareOptions ValidHashCodeOfStringMaskOffFlags;
    private static CompareOptions ValidSortkeyCtorMaskOffFlags;
    internal static CompareInfo Invariant;
    [OptionalFieldAttribute]
private string m_name;
    private string _sortName;
    [OptionalFieldAttribute]
private SortVersion m_SortVersion;
    private bool _invariantMode;
    private int culture;
    private IntPtr _sortHandle;
    private static UInt32 LCMAP_SORTKEY;
    private static UInt32 LCMAP_HASH;
    private static int FIND_STARTSWITH;
    private static int FIND_ENDSWITH;
    private static int FIND_FROMSTART;
    private static int FIND_FROMEND;
    private static int COMPARE_OPTIONS_ORDINAL;
    private static int NORM_IGNORECASE;
    private static int NORM_IGNOREKANATYPE;
    private static int NORM_IGNORENONSPACE;
    private static int NORM_IGNORESYMBOLS;
    private static int NORM_IGNOREWIDTH;
    private static int NORM_LINGUISTIC_CASING;
    private static int SORT_STRINGSORT;
    public string Name { get; }
    public SortVersion Version { get; }
    public int LCID { get; }
    internal CompareInfo(CultureInfo culture);
    private static CompareInfo();
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private void OnDeserialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public virtual string get_Name();
    public virtual int Compare(string string1, string string2);
    public virtual int Compare(string string1, string string2, CompareOptions options);
    internal int Compare(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    internal int CompareOptionNone(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    internal int CompareOptionIgnoreCase(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    internal static int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
    internal static int CompareOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    internal static int CompareOrdinalIgnoreCase(string strA, string strB);
    internal static int CompareOrdinalIgnoreCase(Char& strA, int lengthA, Char& strB, int lengthB);
    internal static bool EqualsOrdinalIgnoreCase(Char& strA, Char& strB, int length);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    internal bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    internal bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int IndexOfOrdinal(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal int LastIndexOfOrdinal(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    internal int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    internal int IndexOf(string source, string value, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal static int GetIgnoreCaseHash(string source);
    internal int GetHashCodeOfString(string source, CompareOptions options);
    public virtual int GetHashCode(string source, CompareOptions options);
    public virtual string ToString();
    public SortVersion get_Version();
    public int get_LCID();
    internal static int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int InvariantIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase, bool fromBeginning);
    internal static int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    private static int InvariantFindString(Char* source, int sourceCount, Char* value, int valueCount, bool ignoreCase, bool fromBeginning);
    private static char InvariantToUpper(char c);
    private SortKey InvariantCreateSortKey(string source, CompareOptions options);
    private void InitSort(CultureInfo culture);
    private static int FindStringOrdinal(UInt32 dwFindStringOrdinalFlags, string stringSource, int offset, int cchSource, string value, int cchValue, bool bIgnoreCase);
    private static int FindStringOrdinal(UInt32 dwFindStringOrdinalFlags, ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool bIgnoreCase);
    internal static int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int IndexOfOrdinalCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase, bool fromBeginning);
    internal static int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    private int GetHashCodeOfStringCore(string source, CompareOptions options);
    private static int CompareStringOrdinalIgnoreCase(Char& string1, int count1, Char& string2, int count2);
    private int CompareString(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    private int CompareString(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    private int FindString(UInt32 dwFindNLSStringFlags, ReadOnlySpan`1<char> lpStringSource, ReadOnlySpan`1<char> lpStringValue, Int32* pcchFound);
    private int FindString(UInt32 dwFindNLSStringFlags, string lpStringSource, int startSource, int cchSource, string lpStringValue, int startValue, int cchValue, Int32* pcchFound);
    internal int IndexOfCore(string source, string target, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr, bool fromBeginning);
    private int LastIndexOfCore(string source, string target, int startIndex, int count, CompareOptions options);
    private bool StartsWith(string source, string prefix, CompareOptions options);
    private bool StartsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    private bool EndsWith(string source, string suffix, CompareOptions options);
    private bool EndsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    private static int FastIndexOfString(string source, string target, int startIndex, int sourceCount, int targetCount, bool findLastIndex);
    private SortKey CreateSortKey(string source, CompareOptions options);
    private static bool IsSortable(Char* text, int length);
    private static int GetNativeCompareFlags(CompareOptions options);
    private SortVersion GetSortVersion();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
internal class System.Globalization.CultureData : object {
    private static int LOCALE_NAME_MAX_LENGTH;
    private static int undef;
    private string _sRealName;
    private string _sWindowsName;
    private string _sName;
    private string _sParent;
    private string _sLocalizedDisplayName;
    private string _sEnglishDisplayName;
    private string _sNativeDisplayName;
    private string _sSpecificCulture;
    private string _sISO639Language;
    private string _sISO639Language2;
    private string _sLocalizedLanguage;
    private string _sEnglishLanguage;
    private string _sNativeLanguage;
    private string _sAbbrevLang;
    private string _sConsoleFallbackName;
    private int _iInputLanguageHandle;
    private string _sRegionName;
    private string _sLocalizedCountry;
    private string _sEnglishCountry;
    private string _sNativeCountry;
    private string _sISO3166CountryName;
    private string _sISO3166CountryName2;
    private int _iGeoId;
    private string _sPositiveSign;
    private string _sNegativeSign;
    private int _iDigits;
    private int _iNegativeNumber;
    private Int32[] _waGrouping;
    private string _sDecimalSeparator;
    private string _sThousandSeparator;
    private string _sNaN;
    private string _sPositiveInfinity;
    private string _sNegativeInfinity;
    private int _iNegativePercent;
    private int _iPositivePercent;
    private string _sPercent;
    private string _sPerMille;
    private string _sCurrency;
    private string _sIntlMonetarySymbol;
    private string _sEnglishCurrency;
    private string _sNativeCurrency;
    private int _iCurrencyDigits;
    private int _iCurrency;
    private int _iNegativeCurrency;
    private Int32[] _waMonetaryGrouping;
    private string _sMonetaryDecimal;
    private string _sMonetaryThousand;
    private int _iMeasure;
    private string _sListSeparator;
    private string _sAM1159;
    private string _sPM2359;
    private string _sTimeSeparator;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saLongTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saShortTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saDurationFormats;
    private int _iFirstDayOfWeek;
    private int _iFirstWeekOfYear;
    private CalendarId[] modreq(System.Runtime.CompilerServices.IsVolatile) _waCalendars;
    private CalendarData[] _calendars;
    private int _iReadingLayout;
    private int _iDefaultAnsiCodePage;
    private int _iDefaultOemCodePage;
    private int _iDefaultMacCodePage;
    private int _iDefaultEbcdicCodePage;
    private int _iLanguage;
    private bool _bUseOverrides;
    private bool _bNeutral;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedRegions;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_RegionNames;
    private static CultureData modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCultures;
    private static object s_lock;
    private static UInt32 LOCALE_NOUSEROVERRIDE;
    private static UInt32 LOCALE_RETURN_NUMBER;
    private static UInt32 LOCALE_SISO3166CTRYNAME;
    private static UInt32 TIME_NOSECONDS;
    private static LowLevelDictionary`2<string, string> RegionNames { get; }
    internal static CultureData Invariant { get; }
    internal string CultureName { get; }
    internal bool UseUserOverride { get; }
    internal string SNAME { get; }
    internal string SPARENT { get; }
    internal string SLOCALIZEDDISPLAYNAME { get; }
    internal string SENGDISPLAYNAME { get; }
    internal string SNATIVEDISPLAYNAME { get; }
    internal string SSPECIFICCULTURE { get; }
    internal string SISO639LANGNAME { get; }
    internal string SISO639LANGNAME2 { get; }
    internal string SABBREVLANGNAME { get; }
    internal string SLOCALIZEDLANGUAGE { get; }
    internal string SENGLISHLANGUAGE { get; }
    internal string SNATIVELANGUAGE { get; }
    internal string SREGIONNAME { get; }
    internal int IGEOID { get; }
    internal string SLOCALIZEDCOUNTRY { get; }
    internal string SENGCOUNTRY { get; }
    internal string SNATIVECOUNTRY { get; }
    internal string SISO3166CTRYNAME { get; }
    internal string SISO3166CTRYNAME2 { get; }
    internal int IINPUTLANGUAGEHANDLE { get; }
    internal string SCONSOLEFALLBACKNAME { get; }
    internal Int32[] WAGROUPING { get; }
    internal string SNAN { get; }
    internal string SPOSINFINITY { get; }
    internal string SNEGINFINITY { get; }
    internal int INEGATIVEPERCENT { get; }
    internal int IPOSITIVEPERCENT { get; }
    internal string SPERCENT { get; }
    internal string SPERMILLE { get; }
    internal string SCURRENCY { get; }
    internal string SINTLSYMBOL { get; }
    internal string SENGLISHCURRENCY { get; }
    internal string SNATIVECURRENCY { get; }
    internal Int32[] WAMONGROUPING { get; }
    internal int IMEASURE { get; }
    internal string SLIST { get; }
    internal string SAM1159 { get; }
    internal string SPM2359 { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal int IFIRSTDAYOFWEEK { get; }
    internal int IFIRSTWEEKOFYEAR { get; }
    internal CalendarId[] CalendarIds { get; }
    internal bool IsRightToLeft { get; }
    private int IREADINGLAYOUT { get; }
    internal string STEXTINFO { get; }
    internal string SCOMPAREINFO { get; }
    internal bool IsSupplementalCustomCulture { get; }
    internal int IDEFAULTANSICODEPAGE { get; }
    internal int IDEFAULTOEMCODEPAGE { get; }
    internal int IDEFAULTMACCODEPAGE { get; }
    internal int IDEFAULTEBCDICCODEPAGE { get; }
    internal int ILANGUAGE { get; }
    internal bool IsNeutralCulture { get; }
    internal bool IsInvariantCulture { get; }
    internal Calendar DefaultCalendar { get; }
    internal string TimeSeparator { get; }
    internal bool IsFramework { get; }
    internal bool IsWin32Installed { get; }
    internal bool IsReplacementCulture { get; }
    private static CultureData();
    private static LowLevelDictionary`2<string, string> get_RegionNames();
    internal static CultureData GetCultureDataForRegion(string cultureName, bool useUserOverride);
    internal static void ClearCachedData();
    internal static CultureInfo[] GetCultures(CultureTypes types);
    private static CultureData CreateCultureWithInvariantData();
    internal static CultureData get_Invariant();
    internal static CultureData GetCultureData(string cultureName, bool useUserOverride);
    private static string NormalizeCultureName(string name, Boolean& isNeutralName);
    private static CultureData CreateCultureData(string cultureName, bool useUserOverride);
    private bool InitCompatibilityCultureData();
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    internal string get_CultureName();
    internal bool get_UseUserOverride();
    internal string get_SNAME();
    internal string get_SPARENT();
    internal string get_SLOCALIZEDDISPLAYNAME();
    internal string get_SENGDISPLAYNAME();
    internal string get_SNATIVEDISPLAYNAME();
    internal string get_SSPECIFICCULTURE();
    internal string get_SISO639LANGNAME();
    internal string get_SISO639LANGNAME2();
    internal string get_SABBREVLANGNAME();
    internal string get_SLOCALIZEDLANGUAGE();
    internal string get_SENGLISHLANGUAGE();
    internal string get_SNATIVELANGUAGE();
    internal string get_SREGIONNAME();
    internal int get_IGEOID();
    internal string get_SLOCALIZEDCOUNTRY();
    internal string get_SENGCOUNTRY();
    internal string get_SNATIVECOUNTRY();
    internal string get_SISO3166CTRYNAME();
    internal string get_SISO3166CTRYNAME2();
    internal int get_IINPUTLANGUAGEHANDLE();
    internal string get_SCONSOLEFALLBACKNAME();
    internal Int32[] get_WAGROUPING();
    internal string get_SNAN();
    internal string get_SPOSINFINITY();
    internal string get_SNEGINFINITY();
    internal int get_INEGATIVEPERCENT();
    internal int get_IPOSITIVEPERCENT();
    internal string get_SPERCENT();
    internal string get_SPERMILLE();
    internal string get_SCURRENCY();
    internal string get_SINTLSYMBOL();
    internal string get_SENGLISHCURRENCY();
    internal string get_SNATIVECURRENCY();
    internal Int32[] get_WAMONGROUPING();
    internal int get_IMEASURE();
    internal string get_SLIST();
    internal string get_SAM1159();
    internal string get_SPM2359();
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    private String[] AdjustShortTimesForMac(String[] shortTimes);
    private String[] DeriveShortTimesFromLong();
    private static string StripSecondsFromPattern(string time);
    private static int GetIndexOfNextTokenAfterSeconds(string time, int index, Boolean& containsSpace);
    internal int get_IFIRSTDAYOFWEEK();
    internal int get_IFIRSTWEEKOFYEAR();
    internal String[] ShortDates(CalendarId calendarId);
    internal String[] LongDates(CalendarId calendarId);
    internal String[] YearMonths(CalendarId calendarId);
    internal String[] DayNames(CalendarId calendarId);
    internal String[] AbbreviatedDayNames(CalendarId calendarId);
    internal String[] SuperShortDayNames(CalendarId calendarId);
    internal String[] MonthNames(CalendarId calendarId);
    internal String[] GenitiveMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(CalendarId calendarId);
    internal String[] LeapYearMonthNames(CalendarId calendarId);
    internal string MonthDay(CalendarId calendarId);
    internal CalendarId[] get_CalendarIds();
    internal string CalendarName(CalendarId calendarId);
    internal CalendarData GetCalendar(CalendarId calendarId);
    internal bool get_IsRightToLeft();
    private int get_IREADINGLAYOUT();
    internal string get_STEXTINFO();
    internal string get_SCOMPAREINFO();
    internal bool get_IsSupplementalCustomCulture();
    internal int get_IDEFAULTANSICODEPAGE();
    internal int get_IDEFAULTOEMCODEPAGE();
    internal int get_IDEFAULTMACCODEPAGE();
    internal int get_IDEFAULTEBCDICCODEPAGE();
    internal int get_ILANGUAGE();
    internal bool get_IsNeutralCulture();
    internal bool get_IsInvariantCulture();
    internal Calendar get_DefaultCalendar();
    internal String[] EraNames(CalendarId calendarId);
    internal String[] AbbrevEraNames(CalendarId calendarId);
    internal String[] AbbreviatedEnglishEraNames(CalendarId calendarId);
    internal string get_TimeSeparator();
    internal string DateSeparator(CalendarId calendarId);
    private static string UnescapeNlsString(string str, int start, int end);
    private static string GetTimeSeparator(string format);
    private static string GetDateSeparator(string format);
    private static string GetSeparator(string format, string timeParts);
    private static int IndexOfTimePart(string format, int startIndex, string timeParts);
    internal static bool IsCustomCultureId(int cultureId);
    internal void GetNFIValues(NumberFormatInfo nfi);
    internal static string AnsiToLower(string testString);
    private bool InitCultureData();
    internal static string GetLocaleInfoEx(string localeName, UInt32 field);
    internal static int GetLocaleInfoExInt(string localeName, UInt32 field);
    internal static int GetLocaleInfoEx(string lpLocaleName, UInt32 lcType, Char* lpLCData, int cchData);
    private string GetLocaleInfo(LocaleStringData type);
    private string GetLocaleInfo(string localeName, LocaleStringData type);
    private int GetLocaleInfo(LocaleNumberData type);
    private Int32[] GetLocaleInfo(LocaleGroupingData type);
    private string GetTimeFormatString();
    private int GetFirstDayOfWeek();
    private String[] GetTimeFormats();
    private String[] GetShortTimeFormats();
    private static CultureData GetCultureDataFromRegionName(string regionName);
    private string GetLanguageDisplayName(string cultureName);
    private string GetRegionDisplayName(string isoCountryCode);
    private static CultureInfo GetUserDefaultCulture();
    private static string GetLocaleInfoFromLCType(string localeName, UInt32 lctype, bool useUserOveride);
    internal static string ReescapeWin32String(string str);
    internal static String[] ReescapeWin32Strings(String[] array);
    private static Int32[] ConvertWin32GroupString(string win32Str);
    private static int ConvertFirstDayOfWeekMonToSun(int iTemp);
    private static BOOL EnumSystemLocalesProc(Char* lpLocaleString, UInt32 flags, Void* contextHandle);
    private static BOOL EnumAllSystemLocalesProc(Char* lpLocaleString, UInt32 flags, Void* contextHandle);
    private static BOOL EnumTimeCallback(Char* lpTimeFormatString, Void* lParam);
    private static String[] nativeEnumTimeFormats(string localeName, UInt32 dwFlags, bool useUserOverride);
    private static int LocaleNameToLCID(string cultureName);
    private static string LCIDToLocaleName(int culture);
    private int GetAnsiCodePage(string cultureName);
    private int GetOemCodePage(string cultureName);
    private int GetMacCodePage(string cultureName);
    private int GetEbcdicCodePage(string cultureName);
    private int GetGeoId(string cultureName);
    private int GetDigitSubstitution(string cultureName);
    private string GetThreeLetterWindowsLanguageName(string cultureName);
    private static CultureInfo[] EnumCultures(CultureTypes types);
    private string GetConsoleFallbackName(string cultureName);
    internal bool get_IsFramework();
    internal bool get_IsWin32Installed();
    internal bool get_IsReplacementCulture();
}
public class System.Globalization.CultureInfo : object {
    private bool _isReadOnly;
    private CompareInfo _compareInfo;
    private TextInfo _textInfo;
    internal NumberFormatInfo numInfo;
    internal DateTimeFormatInfo dateTimeInfo;
    private Calendar _calendar;
    internal CultureData _cultureData;
    internal bool _isInherited;
    private CultureInfo _consoleFallbackCulture;
    internal string _name;
    private string _nonSortName;
    private string _sortName;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultCulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultUICulture;
    private static CultureInfo s_InvariantCultureInfo;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture;
    [ThreadStaticAttribute]
private static CultureInfo s_currentThreadCulture;
    [ThreadStaticAttribute]
private static CultureInfo s_currentThreadUICulture;
    private static Lock s_lock;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_NameCachedCultures;
    private static LowLevelDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_LcidCachedCultures;
    private CultureInfo _parent;
    internal static int LOCALE_NEUTRAL;
    private static int LOCALE_USER_DEFAULT;
    private static int LOCALE_SYSTEM_DEFAULT;
    internal static int LOCALE_CUSTOM_UNSPECIFIED;
    internal static int LOCALE_CUSTOM_DEFAULT;
    internal static int LOCALE_INVARIANT;
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    internal static CultureInfo UserDefaultUICulture { get; }
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public static CultureInfo InvariantCulture { get; }
    public CultureInfo Parent { get; }
    public int LCID { get; }
    public int KeyboardLayoutId { get; }
    public string Name { get; }
    internal string SortName { get; }
    public string IetfLanguageTag { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string EnglishName { get; }
    public string TwoLetterISOLanguageName { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public CompareInfo CompareInfo { get; }
    private static bool OkayToCacheClassWithCompatibilityBehavior { get; }
    public TextInfo TextInfo { get; }
    public bool IsNeutralCulture { get; }
    public CultureTypes CultureTypes { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public Calendar Calendar { get; }
    public Calendar[] OptionalCalendars { get; }
    public bool UseUserOverride { get; }
    public bool IsReadOnly { get; }
    internal bool HasInvariantCultureName { get; }
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    private CultureInfo(CultureData cultureData, bool isReadOnly);
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    internal CultureInfo(string cultureName, string textAndCompareCultureName);
    private static CultureInfo();
    private static CultureInfo InitializeUserDefaultCulture();
    private static CultureInfo InitializeUserDefaultUICulture();
    private static CultureInfo CreateCultureInfoNoThrow(string name, bool useUserOverride);
    private static CultureInfo GetCultureByName(string name, bool userOverride);
    public static CultureInfo CreateSpecificCulture(string name);
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    internal static void ResetThreadCulture();
    internal static CultureInfo get_UserDefaultUICulture();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_DefaultThreadCurrentCulture();
    public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public static CultureInfo get_InvariantCulture();
    public virtual CultureInfo get_Parent();
    public virtual int get_LCID();
    public virtual int get_KeyboardLayoutId();
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual string get_Name();
    internal string get_SortName();
    public string get_IetfLanguageTag();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_EnglishName();
    public virtual string get_TwoLetterISOLanguageName();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual CompareInfo get_CompareInfo();
    private static bool get_OkayToCacheClassWithCompatibilityBehavior();
    public virtual TextInfo get_TextInfo();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual object GetFormat(Type formatType);
    public virtual bool get_IsNeutralCulture();
    public CultureTypes get_CultureTypes();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public void ClearCachedData();
    internal static Calendar GetCalendarInstance(CalendarId calType);
    internal static Calendar GetCalendarInstanceRare(CalendarId calType);
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public bool get_UseUserOverride();
    public CultureInfo GetConsoleFallbackUICulture();
    public virtual object Clone();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public bool get_IsReadOnly();
    private void VerifyWritable();
    internal bool get_HasInvariantCultureName();
    internal static CultureInfo GetCultureInfoHelper(int lcid, string name, string altName);
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    private static CultureInfo GetUserDefaultCultureCacheOverride();
    internal static CultureInfo GetUserDefaultCulture();
    private static CultureInfo GetUserDefaultUICulture();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CultureNotFoundException : ArgumentException {
    private string _invalidCultureName;
    private Nullable`1<int> _invalidCultureId;
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    private static string DefaultMessage { get; }
    private string FormatedInvalidCultureId { get; }
    public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    private static string get_DefaultMessage();
    private string get_FormatedInvalidCultureId();
    public virtual string get_Message();
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
public class System.Globalization.DateTimeFormatInfo : object {
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    private CultureData _cultureData;
    private string _name;
    private string _langName;
    private CompareInfo _compareInfo;
    private CultureInfo _cultureInfo;
    private string amDesignator;
    private string pmDesignator;
    private string dateSeparator;
    private string generalShortTimePattern;
    private string generalLongTimePattern;
    private string timeSeparator;
    private string monthDayPattern;
    private string dateTimeOffsetPattern;
    private static string rfc1123Pattern;
    private static string sortableDateTimePattern;
    private static string universalSortableDateTimePattern;
    private Calendar calendar;
    private int firstDayOfWeek;
    private int calendarWeekRule;
    private string fullDateTimePattern;
    private String[] abbreviatedDayNames;
    private String[] m_superShortDayNames;
    private String[] dayNames;
    private String[] abbreviatedMonthNames;
    private String[] monthNames;
    private String[] genitiveMonthNames;
    private String[] m_genitiveAbbreviatedMonthNames;
    private String[] leapYearMonthNames;
    private string longDatePattern;
    private string shortDatePattern;
    private string yearMonthPattern;
    private string longTimePattern;
    private string shortTimePattern;
    private String[] allYearMonthPatterns;
    private String[] allShortDatePatterns;
    private String[] allLongDatePatterns;
    private String[] allShortTimePatterns;
    private String[] allLongTimePatterns;
    private String[] m_eraNames;
    private String[] m_abbrevEraNames;
    private String[] m_abbrevEnglishEraNames;
    private CalendarId[] optionalCalendars;
    private static int DEFAULT_ALL_DATETIMES_SIZE;
    internal bool _isReadOnly;
    private DateTimeFormatFlags formatFlags;
    private static Char[] s_monthSpaces;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    private string _decimalSeparator;
    private string _fullTimeSpanPositivePattern;
    private string _fullTimeSpanNegativePattern;
    internal static DateTimeStyles InvalidDateTimeStyles;
    private TokenHashValue[] _dtfiTokenHash;
    private static int TOKEN_HASH_SIZE;
    private static int SECOND_PRIME;
    private static string dateSeparatorOrTimeZoneOffset;
    private static string invariantDateSeparator;
    private static string invariantTimeSeparator;
    internal static string IgnorablePeriod;
    internal static string IgnorableComma;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal static string JapaneseEraStart;
    internal static string LocalTimeMark;
    internal static string GMTName;
    internal static string ZuluName;
    internal static string KoreanLangName;
    internal static string JapaneseLangName;
    internal static string EnglishLangName;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI;
    private string CultureName { get; }
    private CultureInfo Culture { get; }
    private string LanguageName { get; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    private CalendarId[] OptionalCalendars { get; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    private String[] AllYearMonthPatterns { get; }
    private String[] AllShortDatePatterns { get; }
    private String[] AllShortTimePatterns { get; }
    private String[] AllLongDatePatterns { get; }
    private String[] AllLongTimePatterns { get; }
    private String[] UnclonedYearMonthPatterns { get; }
    private String[] UnclonedShortDatePatterns { get; }
    private String[] UnclonedLongDatePatterns { get; }
    private String[] UnclonedShortTimePatterns { get; }
    private String[] UnclonedLongTimePatterns { get; }
    public bool IsReadOnly { get; }
    public string NativeCalendarName { get; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    internal string DecimalSeparator { get; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private static DateTimeFormatInfo();
    private string get_CultureName();
    private CultureInfo get_Culture();
    private string get_LanguageName();
    private String[] internalGetAbbreviatedDayOfWeekNames();
    private String[] internalGetAbbreviatedDayOfWeekNamesCore();
    private String[] internalGetSuperShortDayNames();
    private String[] internalGetSuperShortDayNamesCore();
    private String[] internalGetDayOfWeekNames();
    private String[] internalGetDayOfWeekNamesCore();
    private String[] internalGetAbbreviatedMonthNames();
    private String[] internalGetAbbreviatedMonthNamesCore();
    private String[] internalGetMonthNames();
    private String[] internalGetMonthNamesCore();
    private void InitializeOverridableProperties(CultureData cultureData, CalendarId calendarId);
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    private CalendarId[] get_OptionalCalendars();
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    private static void CheckNullValue(String[] values, int length);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    private String[] internalGetGenitiveMonthNames(bool abbreviated);
    internal String[] internalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    private static String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    private static String[] GetMergedPatterns(String[] patterns, string defaultPattern);
    private String[] get_AllYearMonthPatterns();
    private String[] get_AllShortDatePatterns();
    private String[] get_AllShortTimePatterns();
    private String[] get_AllLongDatePatterns();
    private String[] get_AllLongTimePatterns();
    private String[] get_UnclonedYearMonthPatterns();
    private String[] get_UnclonedShortDatePatterns();
    private String[] get_UnclonedLongDatePatterns();
    private String[] get_UnclonedShortTimePatterns();
    private String[] get_UnclonedLongTimePatterns();
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_DecimalSeparator();
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, string parameterName);
    internal DateTimeFormatFlags get_FormatFlags();
    private DateTimeFormatFlags InitializeFormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    private void ClearTokenHashTable();
    internal TokenHashValue[] CreateTokenHashTable();
    private void AddMonthNames(TokenHashValue[] temp, string monthPostfix);
    private static bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number);
    private static bool IsHebrewChar(char ch);
    private bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
    internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
    private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
    private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
    private bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal static char MonthPostfixChar;
    internal static char IgnorableSymbolChar;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal List`1<string> m_dateWords;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_knownWords;
    private FoundDatePattern _ymdFlags;
    private static Dictionary`2<string, string> KnownWords { get; }
    private static Dictionary`2<string, string> get_KnownWords();
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
    private static bool EqualStringArrays(String[] array1, String[] array2);
    private static bool ArrayElementsHaveSpace(String[] array);
    private static bool ArrayElementsBeginWithDigit(String[] array);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    private DateTime _start;
    private DateTime _end;
    private TimeSpan _delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
[IsReadOnlyAttribute]
internal class System.Globalization.DaylightTimeStruct : ValueType {
    public DateTime Start;
    public DateTime End;
    public TimeSpan Delta;
    public DaylightTimeStruct(DateTime start, DateTime end, TimeSpan delta);
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    internal static int LeapMonth;
    internal static int Jan1Month;
    internal static int Jan1Date;
    internal static int nDaysPerMonth;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    private static int DEFAULT_GREGORIAN_TWO_DIGIT_YEAR_MAX;
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static EastAsianLunisolarCalendar();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    private static int GregorianIsLeapYear(int y);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal void GregorianToLunar(int nSYear, int nSMonth, int nSDate, Int32& nLYear, Int32& nLMonth, Int32& nLDate);
    internal bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, Int32& nSolarYear, Int32& nSolarMonth, Int32& nSolarDay);
    internal DateTime LunarToTime(DateTime time, int year, int month, int day);
    internal void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    internal string eraName;
    internal string abbrevEraName;
    internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
internal static class System.Globalization.GlobalizationMode : object {
    private static string c_InvariantModeConfigSwitch;
    [CompilerGeneratedAttribute]
private static bool <Invariant>k__BackingField;
    internal static bool Invariant { get; }
    private static GlobalizationMode();
    [CompilerGeneratedAttribute]
internal static bool get_Invariant();
    private static bool GetGlobalizationInvariantMode();
}
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    internal static int MinYear;
    internal static int MaxYear;
    internal GregorianCalendarTypes m_type;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    private static GregorianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual CalendarId get_ID();
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal virtual long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    internal int m_maxYear;
    internal int m_minYear;
    internal Calendar m_Cal;
    internal EraInfo[] m_EraInfo;
    internal Int32[] m_eras;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    private static GregorianCalendarHelper();
    internal int get_MaxYear();
    private int GetYearOffset(int year, int era, bool throwOnError);
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int DatePartDayOfWeek;
    private static int HebrewYearOf1AD;
    private static int FirstGregorianTableYear;
    private static int LastGregorianTableYear;
    private static int TABLESIZE;
    private static int MinHebrewYear;
    private static int MaxHebrewYear;
    private static Byte[] s_hebrewTable;
    private static int MaxMonthPlusOne;
    private static Byte[] s_lunarMonthLen;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    private static void CheckHebrewYearValue(int y, int era, string varName);
    private void CheckHebrewMonthValue(int year, int month, int era);
    private void CheckHebrewDayValue(int year, int month, int day, int era);
    internal static void CheckEraRange(int era);
    private static void CheckTicksRange(long ticks);
    internal static int GetResult(__DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    private static int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
    private static DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.HebrewNumber : object {
    private static HebrewValue[] s_hebrewValues;
    private static int minHebrewNumberCh;
    private static char s_maxHebrewNumberCh;
    private static HS[] s_numberPasingState;
    private static int HebrewTokenCount;
    private static HebrewNumber();
    internal static string ToString(int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MinAdvancedHijri;
    internal static int MaxAdvancedHijri;
    internal static Int32[] HijriMonthDays;
    private int _hijriAdvance;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    private static string InternationalRegKey;
    private static string HijriAdvanceRegKeyEntry;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private long GetAbsoluteDateHijri(int y, int m, int d);
    private long DaysUpToHijriYear(int HijriYear);
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    private int GetHijriDateAdjustment();
    private static int GetAdvanceHijriDate();
}
public class System.Globalization.IdnMapping : object {
    private bool _allowUnassigned;
    private bool _useStd3AsciiRules;
    private static char c_delimiter;
    private static string c_strAcePrefix;
    private static int c_labelLimit;
    private static int c_defaultNameLimit;
    private static int c_initialN;
    private static int c_maxint;
    private static int c_initialBias;
    private static int c_punycodeBase;
    private static int c_tmin;
    private static int c_tmax;
    private static int c_skew;
    private static int c_damp;
    private static Char[] c_Dots;
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    private UInt32 Flags { get; }
    private static IdnMapping();
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetStringForOutput(string originalString, Char* input, int inputLength, Char* output, int outputLength);
    private string GetAsciiInvariant(string unicode, int index, int count);
    private static bool ValidateStd3AndAscii(string unicode, bool bUseStd3, bool bCheckAscii);
    private static string PunycodeEncode(string unicode);
    private static bool IsDot(char c);
    private static bool IsSupplementary(int cTest);
    private static bool Basic(UInt32 cp);
    private static void ValidateStd3(char c, bool bNextToDot);
    private string GetUnicodeInvariant(string ascii, int index, int count);
    private static string PunycodeDecode(string ascii);
    private static int DecodeDigit(char cp);
    private static int Adapt(int delta, int numpoints, bool firsttime);
    private static char EncodeBasic(char bcp);
    private static bool HasUpperCaseFlag(char punychar);
    private static char EncodeDigit(int d);
    private string GetAsciiCore(string unicodeString, Char* unicode, int count);
    private string GetAsciiCore(string unicodeString, Char* unicode, int count, UInt32 flags, Char* output, int outputLength);
    private string GetUnicodeCore(string asciiString, Char* ascii, int count);
    private string GetUnicodeCore(string asciiString, Char* ascii, int count, UInt32 flags, Char* output, int outputLength);
    private UInt32 get_Flags();
    private static void ThrowForZeroLength(bool unicode);
}
internal class System.Globalization.InternalGlobalizationHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerTenthSecond;
    internal static long TicksPerSecond;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo10000;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    internal static long MaxTicks;
    internal static long MinTicks;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static int StringBuilderDefaultCapacity;
    internal static long MaxOffset;
    internal static long MinOffset;
    internal static long TimeToTicks(int hour, int minute, int second);
}
[__BlockReflectionAttribute]
public static class System.Globalization.ISOWeek : object {
    private static int WeeksInLongYear;
    private static int WeeksInShortYear;
    private static int MinWeek;
    private static int MaxWeek;
    public static int GetWeekOfYear(DateTime date);
    public static int GetYear(DateTime date);
    public static DateTime GetYearStart(int year);
    public static DateTime GetYearEnd(int year);
    public static int GetWeeksInYear(int year);
    public static DateTime ToDateTime(int year, int week, DayOfWeek dayOfWeek);
    private static int GetWeekNumber(DateTime date);
    private static int GetWeekday(DayOfWeek dayOfWeek);
    [CompilerGeneratedAttribute]
internal static int <GetWeeksInYear>g__P|8_0(int y);
}
public class System.Globalization.JapaneseCalendar : Calendar {
    internal static DateTime calendarMinValue;
    internal static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) japaneseEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    private static string c_japaneseErasHive;
    private static string c_japaneseErasHivePermissionList;
    private static String[] s_japaneseErasEnglishNames;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    internal static Calendar GetDefaultInstance();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    private static EraInfo[] GetJapaneseEras();
    private static int CompareEraRanges(EraInfo a, EraInfo b);
    private static EraInfo GetEraFromValue(string value, string data);
    private static string GetJapaneseEnglishEraName(int era);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    internal GregorianCalendarHelper helper;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    private static EraInfo[] TrimEras(EraInfo[] baseEras);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static int JulianDaysPerYear;
    private static int JulianDaysPer4Years;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    internal int MaxYear;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    internal static EraInfo[] koreanEraInfo;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
internal static class System.Globalization.Normalization : object {
    internal static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    internal static string Normalize(string strInput, NormalizationForm normalizationForm);
}
public class System.Globalization.NumberFormatInfo : object {
    private static NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    internal Int32[] numberGroupSizes;
    internal Int32[] currencyGroupSizes;
    internal Int32[] percentGroupSizes;
    internal string positiveSign;
    internal string negativeSign;
    internal string numberDecimalSeparator;
    internal string numberGroupSeparator;
    internal string currencyGroupSeparator;
    internal string currencyDecimalSeparator;
    internal string currencySymbol;
    internal string nanSymbol;
    internal string positiveInfinitySymbol;
    internal string negativeInfinitySymbol;
    internal string percentDecimalSeparator;
    internal string percentGroupSeparator;
    internal string percentSymbol;
    internal string perMilleSymbol;
    internal String[] nativeDigits;
    internal int numberDecimalDigits;
    internal int currencyDecimalDigits;
    internal int currencyPositivePattern;
    internal int currencyNegativePattern;
    internal int numberNegativePattern;
    internal int percentPositivePattern;
    internal int percentNegativePattern;
    internal int percentDecimalDigits;
    internal int digitSubstitution;
    internal bool isReadOnly;
    internal bool m_isInvariant;
    private static NumberStyles InvalidNumberStyles;
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public DigitShapes DigitSubstitution { get; public set; }
    internal NumberFormatInfo(CultureData cultureData);
    private static void VerifyDecimalSeparator(string decSep, string propertyName);
    private static void VerifyGroupSeparator(string groupSep, string propertyName);
    private static void VerifyNativeDigits(String[] nativeDig, string propertyName);
    private static void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName);
    private void VerifyWritable();
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
    [CompilerGeneratedAttribute]
internal static NumberFormatInfo <GetInstance>g__GetProviderNonNull|39_0(IFormatProvider provider);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    internal static long PersianEpoch;
    private static int ApproximateHalfYear;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MonthsPerYear;
    internal static Int32[] DaysToMonth;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    private long GetAbsoluteDatePersian(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static int MonthFromOrdinalDay(int ordinalDay);
    private static int DaysInPreviousMonths(int month);
    internal int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.RegionInfo : object {
    internal string _name;
    internal CultureData _cultureData;
    internal static RegionInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_currentRegionInfo;
    public static RegionInfo CurrentRegion { get; }
    public string Name { get; }
    public string EnglishName { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string TwoLetterISORegionName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public bool IsMetric { get; }
    public int GeoId { get; }
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public string ISOCurrencySymbol { get; }
    public RegionInfo(string name);
    public RegionInfo(int culture);
    internal RegionInfo(CultureData cultureData);
    private void SetName(string name);
    public static RegionInfo get_CurrentRegion();
    public virtual string get_Name();
    public virtual string get_EnglishName();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_TwoLetterISORegionName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual bool get_IsMetric();
    public virtual int get_GeoId();
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public virtual string get_ISOCurrencySymbol();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortKey : object {
    internal string _localeName;
    internal CompareOptions _options;
    internal string _string;
    internal Byte[] _keyData;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(string localeName, string str, CompareOptions options, Byte[] keyData);
    public virtual string get_OriginalString();
    public virtual Byte[] get_KeyData();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.SortVersion : object {
    private int m_NlsVersion;
    private Guid m_SortId;
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
public class System.Globalization.StringInfo : object {
    private string _str;
    private Int32[] _indexes;
    private Int32[] Indexes { get; }
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    private Int32[] get_Indexes();
    public string get_String();
    public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    internal static int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
public class System.Globalization.TaiwanCalendar : Calendar {
    internal static EraInfo[] taiwanEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    internal static DateTime calendarMinValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    internal static EraInfo[] taiwanLunisolarEraInfo;
    internal GregorianCalendarHelper helper;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
public class System.Globalization.TextElementEnumerator : object {
    private string _str;
    private int _index;
    private int _startIndex;
    private int _strLen;
    private int _currTextElementLen;
    private UnicodeCategory _uc;
    private int _charLen;
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex, int strLen);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
public class System.Globalization.TextInfo : object {
    private string _listSeparator;
    private bool _isReadOnly;
    private string _cultureName;
    private CultureData _cultureData;
    private string _textInfoName;
    private Tristate _isAsciiCasingSameAsInvariant;
    private bool _invariantMode;
    internal static TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static int c_wordSeparatorMask;
    private IntPtr _sortHandle;
    private static UInt32 LCMAP_LINGUISTIC_CASING;
    private static UInt32 LCMAP_LOWERCASE;
    private static UInt32 LCMAP_UPPERCASE;
    internal static TextInfo Invariant { get; }
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    public int LCID { get; }
    public string CultureName { get; }
    public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    private bool IsAsciiCasingSameAsInvariant { get; }
    public bool IsRightToLeft { get; }
    internal TextInfo(CultureData cultureData);
    internal static TextInfo get_Invariant();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual int get_ANSICodePage();
    public virtual int get_OEMCodePage();
    public virtual int get_MacCodePage();
    public virtual int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    public virtual string get_ListSeparator();
    public virtual void set_ListSeparator(string value);
    public virtual char ToLower(char c);
    public virtual string ToLower(string str);
    private char ChangeCase(char c, bool toUpper);
    private string ChangeCase(string source, bool toUpper);
    internal void ChangeCase(ReadOnlySpan`1<char> source, Span`1<char> destination, bool toUpper);
    private static string ToLowerAsciiInvariant(string s);
    internal static void ToLowerAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private static string ToUpperAsciiInvariant(string s);
    internal static void ToUpperAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private static char ToLowerAsciiInvariant(char c);
    public virtual char ToUpper(char c);
    public virtual string ToUpper(string str);
    internal static char ToUpperAsciiInvariant(char c);
    private static bool IsAscii(char c);
    private bool get_IsAsciiCasingSameAsInvariant();
    public bool get_IsRightToLeft();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    private static int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private static bool IsWordSeparator(UnicodeCategory category);
    private static bool IsLetterCategory(UnicodeCategory uc);
    private void FinishInitialization();
    private void ChangeCase(Char* pSource, int pSourceLen, Char* pResult, int pResultLen, bool toUpper);
    private static bool IsInvariantLocale(string localeName);
}
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    internal static EraInfo[] thaiBuddhistEraInfo;
    public static int ThaiBuddhistEra;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    private static void AppendNonNegativeInt32(StringBuilder sb, int n, int digits);
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    internal static bool TryFormat(TimeSpan value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    internal static string FormatC(TimeSpan value);
    private static string FormatG(TimeSpan value, DateTimeFormatInfo dtfi, StandardFormat format);
    private static bool TryFormatStandard(TimeSpan value, StandardFormat format, string decimalSeparator, Span`1<char> destination, Int32& charsWritten);
    private static void WriteTwoDigits(UInt32 value, Span`1<char> buffer);
    private static void WriteDigits(UInt32 value, Span`1<char> buffer);
    private static StringBuilder FormatCustomized(TimeSpan value, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, StringBuilder result);
}
internal static class System.Globalization.TimeSpanParse : object {
    private static int MaxFractionDigits;
    private static int MaxDays;
    private static int MaxHours;
    private static int MaxMinutes;
    private static int MaxSeconds;
    private static int MaxFraction;
    internal static long Pow10(int pow);
    private static bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result);
    internal static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    internal static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    private static bool TryParseTimeSpan(ReadOnlySpan`1<char> input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result);
    private static bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool TryParseExactTimeSpan(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool TryParseByFormat(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result);
    private static bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, StringBuilder enquotedString);
    private static bool TryParseTimeSpanConstant(ReadOnlySpan`1<char> input, TimeSpanResult& result);
    private static bool TryParseExactMultipleTimeSpan(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    internal static int MinCalendarYear;
    internal static int MaxCalendarYear;
    private static DateMapping[] s_hijriYearInfo;
    public static int UmAlQuraEra;
    internal static int DateCycle;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    private static DateMapping[] InitDateMapping();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private static void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg);
    private static long GetAbsoluteDateUmAlQura(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay);
    internal virtual int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    public Guid(Byte[] b);
    public Guid(ReadOnlySpan`1<byte> b);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(string g);
    private static Guid();
    public static Guid Parse(string input);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Guid& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    public static Guid ParseExact(string input, string format);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    public static bool TryParseExact(string input, string format, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    private static bool TryParseGuid(ReadOnlySpan`1<char> guidString, GuidStyles flags, GuidResult& result);
    private static bool TryParseGuidWithHexPrefix(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseGuidWithNoStyle(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseGuidWithDashes(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool StringToShort(ReadOnlySpan`1<char> str, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToShort(ReadOnlySpan`1<char> str, Int32& parsePos, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToInt(ReadOnlySpan`1<char> str, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToInt(ReadOnlySpan`1<char> str, Int32& parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToLong(ReadOnlySpan`1<char> str, Int32& parsePos, int flags, Int64& result, GuidResult& parseResult);
    private static ReadOnlySpan`1<char> EatAllWhitespace(ReadOnlySpan`1<char> str);
    private static bool IsHexPrefix(ReadOnlySpan`1<char> str, int i);
    private void WriteByteHelper(Span`1<byte> destination);
    public Byte[] ToByteArray();
    public bool TryWriteBytes(Span`1<byte> destination);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    private int GetResult(UInt32 me, UInt32 them);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public string ToString(string format);
    private static char HexToChar(int a);
    private static int HexsToChars(Char* guidChars, int a, int b);
    private static int HexsToCharsHexOutput(Char* guidChars, int a, int b);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static Guid NewGuid();
    internal bool Equals(Guid& g);
}
public class System.HashCode : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static UInt32 Rol(UInt32 value, int count);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
[ExtensionAttribute]
internal static class System.Helpers : object {
    [ExtensionAttribute]
public static bool TryGetEEType(Type type, EETypePtr& eeType);
}
internal static class System.HighPerformanceCounter : object {
    [CompilerGeneratedAttribute]
private static ulong <Frequency>k__BackingField;
    public static ulong TickCount { get; }
    public static ulong Frequency { get; }
    private static HighPerformanceCounter();
    public static ulong get_TickCount();
    [CompilerGeneratedAttribute]
public static ulong get_Frequency();
    private static ulong GetFrequency();
}
internal static class System.HResults : object {
    internal static int S_OK;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_BADEXEFORMAT;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_COMEMULATE;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIRECTORYNOTFOUND;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENDOFSTREAM;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FILELOAD;
    internal static int COR_E_FILENOTFOUND;
    internal static int COR_E_FORMAT;
    internal static int COR_E_HOSTPROTECTION;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INSUFFICIENTMEMORY;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_IO;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PATHTOOLONG;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SAFEHANDLEMISSINGATTRIBUTE;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SEMAPHOREFULL;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_THREADSTOP;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_UNSUPPORTEDFORMAT;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int DISP_E_OVERFLOW;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    internal static int E_FAIL;
    internal static int E_HANDLE;
    internal static int E_INVALIDARG;
    internal static int E_NOTIMPL;
    internal static int E_POINTER;
    internal static int ERROR_MRM_MAP_NOT_FOUND;
    internal static int RO_E_CLOSED;
    internal static int TYPE_E_TYPEMISMATCH;
    internal static int CO_E_NOTINITIALIZED;
}
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
public interface System.ICloneable {
    public abstract virtual object Clone();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
    internal InsufficientExecutionStackException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
    private InsufficientMemoryException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int16 : ValueType {
    private short m_value;
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, IFormatProvider provider);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int32 : ValueType {
    private int m_value;
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(int value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, IFormatProvider provider);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int64 : ValueType {
    private long m_value;
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, IFormatProvider provider);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal enum System.InternalGCCollectionMode : Enum {
    public int value__;
    public static InternalGCCollectionMode NonBlocking;
    public static InternalGCCollectionMode Blocking;
    public static InternalGCCollectionMode Optimized;
    public static InternalGCCollectionMode Compacting;
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IntPtr : ValueType {
    private Void* _value;
    [IntrinsicAttribute]
public static IntPtr Zero;
    public static int Size { get; }
    [IntrinsicAttribute]
[NonVersionableAttribute]
public IntPtr(int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public IntPtr(long value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public IntPtr(Void* value);
    private IntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
    public virtual int GetHashCode();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public int ToInt32();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public long ToInt64();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Explicit(int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Explicit(long value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Explicit(Void* value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static long op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static IntPtr Add(IntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int get_Size();
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[DependencyReductionRootAttribute]
public Void* ToPointer();
    public virtual string ToString();
    public string ToString(string format);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    internal InvalidProgramException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
[ReflectionBlockedAttribute]
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public static class System.InvokeUtils : object {
    [ThreadStaticAttribute]
private static Object[] s_parameters;
    [ThreadStaticAttribute]
private static Object[] s_nullableCopyBackObjects;
    [ThreadStaticAttribute]
private static int s_curIndex;
    [ThreadStaticAttribute]
private static object s_targetMethodOrDelegate;
    [ThreadStaticAttribute]
private static BinderBundle s_binderBundle;
    [ThreadStaticAttribute]
private static Object[] s_customBinderProvidedParameters;
    private static Func`1<Type> s_getExactTypeForCustomBinder;
    private static Object modreq(System.Runtime.CompilerServices.IsVolatile) _nullByRefValueSentinel;
    public static object NullByRefValueSentinel { get; }
    private static InvokeUtils();
    public static object CheckArgument(object srcObject, RuntimeTypeHandle dstType, BinderBundle binderBundle);
    internal static object CheckArgument(object srcObject, EETypePtr dstEEType, CheckArgumentSemantics semantics, BinderBundle binderBundle, Func`1<Type> getExactTypeForCustomBinder);
    private static Exception ConvertOrWidenPrimitivesEnumsAndPointersIfPossible(object srcObject, EETypePtr srcEEType, EETypePtr dstEEType, CheckArgumentSemantics semantics, Object& dstObject);
    private static Exception ConvertPointerIfPossible(object srcObject, EETypePtr srcEEType, EETypePtr dstEEType, CheckArgumentSemantics semantics, IntPtr& dstIntPtr);
    private static Exception CreateChangeTypeException(EETypePtr srcEEType, EETypePtr dstEEType, CheckArgumentSemantics semantics);
    private static ArgumentException CreateChangeTypeArgumentException(EETypePtr srcEEType, EETypePtr dstEEType);
    private static InvalidCastException CreateChangeTypeInvalidCastException(EETypePtr srcEEType, EETypePtr dstEEType);
    private static object GetDefaultValue(RuntimeTypeHandle thType, int argIndex);
    private static Type GetExactTypeForCustomBinder();
    [DebuggerGuidedStepThroughAttribute]
internal static object CallDynamicInvokeMethod(object thisPtr, IntPtr methodToCall, object thisPtrDynamicInvokeMethod, IntPtr dynamicInvokeHelperMethod, IntPtr dynamicInvokeHelperGenericDictionary, object targetMethodOrDelegate, Object[] parameters, BinderBundle binderBundle, bool wrapInTargetInvocationException, bool invokeMethodHelperIsThisCall, bool methodToCallIsThisCall);
    internal static void DynamicInvokeArgSetupComplete(ArgSetupState& argSetupState);
    public static void DynamicInvokeArgSetupPtrComplete(IntPtr argSetupStatePtr);
    internal static object DynamicInvokeThisCallTemplate(object thisPtr, IntPtr methodToCall, ArgSetupState& argSetupState);
    internal static object DynamicInvokeCallTemplate(object thisPtr, IntPtr methodToCall, ArgSetupState& argSetupState, bool targetIsThisCall);
    [DebuggerStepThroughAttribute]
private static void DynamicInvokeUnboxIntoActualNullable(object actualBoxedNullable, object boxedFillObject, EETypePtr nullableType);
    [DebuggerStepThroughAttribute]
private static object DynamicInvokeBoxIntoNonNullable(object actualBoxedNullable);
    [DebuggerStepThroughAttribute]
internal static IntPtr& DynamicInvokeParamHelperIn(RuntimeTypeHandle rth);
    [DebuggerStepThroughAttribute]
internal static IntPtr& DynamicInvokeParamHelperRef(RuntimeTypeHandle rth);
    internal static object DynamicInvokeBoxedValuetypeReturn(DynamicInvokeParamLookupType& paramLookupType, object boxedValuetype, int index, RuntimeTypeHandle type, DynamicInvokeParamType paramType);
    internal static object DynamicInvokeUnmanagedPointerReturn(DynamicInvokeParamLookupType& paramLookupType, object boxedPointerType, int index, RuntimeTypeHandle type, DynamicInvokeParamType paramType);
    public static object DynamicInvokeParamHelperCore(RuntimeTypeHandle type, DynamicInvokeParamLookupType& paramLookupType, Int32& index, DynamicInvokeParamType paramType);
    public static object get_NullByRefValueSentinel();
}
public class System.IO.BinaryReader : object {
    private static int MaxCharBytesSize;
    private Stream _stream;
    private Byte[] _buffer;
    private Decoder _decoder;
    private Byte[] _charBytes;
    private Char[] _singleChar;
    private Char[] _charBuffer;
    private int _maxCharsSize;
    private bool _2BytesPerChar;
    private bool _isMemoryStream;
    private bool _leaveOpen;
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual void Close();
    public virtual int PeekChar();
    public virtual int Read();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual char ReadChar();
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    private int InternalReadChars(Span`1<char> buffer);
    public virtual Char[] ReadChars(int count);
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Byte[] ReadBytes(int count);
    protected virtual void FillBuffer(int numBytes);
    protected internal int Read7BitEncodedInt();
}
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    private Byte[] _buffer;
    private Encoding _encoding;
    private Encoder _encoder;
    private bool _leaveOpen;
    private Byte[] _largeByteBuffer;
    private int _maxChars;
    private static int LargeByteBufferSize;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<char> chars);
    protected void Write7BitEncodedInt(int value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.DisableMediaInsertionPrompt : ValueType {
    private bool _disableSuccess;
    private UInt32 _oldMode;
    public static DisableMediaInsertionPrompt Create();
    public sealed virtual void Dispose();
}
internal static class System.IO.EncodingCache : object {
    internal static Encoding UTF8NoBOM;
    private static EncodingCache();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.Error : object {
    internal static Exception GetStreamIsClosed();
    internal static Exception GetEndOfFile();
    internal static Exception GetFileNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileLoadException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileNotFoundException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
public class System.IO.FileStream : Stream {
    private static FileShare DefaultShare;
    private static bool DefaultIsAsync;
    internal static int DefaultBufferSize;
    private Byte[] _buffer;
    private int _bufferLength;
    private SafeFileHandle _fileHandle;
    private FileAccess _access;
    private string _path;
    private int _readPos;
    private int _readLength;
    private int _writePos;
    private bool _useAsyncIO;
    private Task`1<int> _lastSynchronouslyCompletedTask;
    private long _filePosition;
    private bool _exposedHandle;
    private bool _canSeek;
    private bool _isPipe;
    private long _appendStart;
    private static IOCompletionCallback s_ioCallback;
    private Task _activeBufferOperation;
    private PreAllocatedOverlapped _preallocatedOverlapped;
    private FileStreamCompletionSource _currentOverlappedOwner;
    private static int FILE_ATTRIBUTE_NORMAL;
    private static int FILE_ATTRIBUTE_ENCRYPTED;
    private static int FILE_FLAG_OVERLAPPED;
    internal static int GENERIC_READ;
    private static int GENERIC_WRITE;
    private static int FILE_BEGIN;
    private static int FILE_CURRENT;
    private static int FILE_END;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_NO_DATA;
    private static int ERROR_HANDLE_EOF;
    private static int ERROR_INVALID_PARAMETER;
    private static int ERROR_IO_PENDING;
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public string Name { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool IsClosed { get; }
    private bool HasActiveBufferOperation { get; }
    public bool CanSeek { get; }
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    private static FileStream();
    private void ValidateAndInitFromHandle(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public virtual IntPtr get_Handle();
    public virtual void Lock(long position, long length);
    public virtual void Unlock(long position, long length);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    [__BlockReflectionAttribute]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [__BlockReflectionAttribute]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private Task`1<int> ReadAsyncTask(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    [__BlockReflectionAttribute]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [__BlockReflectionAttribute]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    private void ValidateReadWriteArgs(Byte[] array, int offset, int count);
    public virtual void SetLength(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual string get_Name();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    private void VerifyOSHandlePosition();
    [ConditionalAttribute("DEBUG")]
private void AssertBufferInvariants();
    private void PrepareForReading();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal virtual bool get_IsClosed();
    private static bool IsIoRelatedException(Exception e);
    private Byte[] GetBuffer();
    private void OnBufferAllocated();
    private void FlushInternalBuffer();
    private void FlushReadBuffer();
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    private void PrepareForWriting();
    protected virtual override void Finalize();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void Init(FileMode mode, FileShare share, string originalPath);
    private void InitFromHandle(SafeFileHandle handle, FileAccess access, bool useAsyncIO);
    private void InitFromHandleImpl(SafeFileHandle handle, FileAccess access, bool useAsyncIO);
    private static SECURITY_ATTRIBUTES GetSecAttrs(FileShare share);
    private bool get_HasActiveBufferOperation();
    public virtual bool get_CanSeek();
    private long GetLengthInternal();
    protected virtual void Dispose(bool disposing);
    private void FlushOSBuffer();
    private Task FlushWriteAsync(CancellationToken cancellationToken);
    private void FlushWriteBufferForWriteByte();
    private void FlushWriteBuffer(bool calledFromFinalizer);
    private void SetLengthInternal(long value);
    private void SetLengthCore(long value);
    private FileStreamCompletionSource CompareExchangeCurrentOverlappedOwner(FileStreamCompletionSource newSource, FileStreamCompletionSource existingSource);
    private int ReadSpan(Span`1<byte> destination);
    [ConditionalAttribute("DEBUG")]
private void AssertCanRead();
    private int FillReadBufferForReadByte();
    private int ReadNative(Span`1<byte> buffer);
    public virtual long Seek(long offset, SeekOrigin origin);
    private long SeekCore(SafeFileHandle fileHandle, long offset, SeekOrigin origin, bool closeInvalidHandle);
    private void WriteSpan(ReadOnlySpan`1<byte> source);
    private void WriteCore(ReadOnlySpan`1<byte> source);
    private Task`1<int> ReadAsyncInternal(Memory`1<byte> destination, CancellationToken cancellationToken, Int32& synchronousResult);
    private Task`1<int> ReadNativeAsync(Memory`1<byte> destination, int numBufferedBytesRead, CancellationToken cancellationToken);
    private ValueTask WriteAsyncInternal(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private Task WriteAsyncInternalCore(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private int ReadFileNative(SafeFileHandle handle, Span`1<byte> bytes, NativeOverlapped* overlapped, Int32& errorCode);
    private int WriteFileNative(SafeFileHandle handle, ReadOnlySpan`1<byte> buffer, NativeOverlapped* overlapped, Int32& errorCode);
    private int GetLastWin32ErrorAndDisposeHandleIfInvalid();
    [__BlockReflectionAttribute]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.FileStream/<AsyncModeCopyToAsync>d__133")]
private Task AsyncModeCopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void LockInternal(long position, long length);
    private void UnlockInternal(long position, long length);
    private SafeFileHandle ValidateFileHandle(SafeFileHandle fileHandle);
    private SafeFileHandle OpenHandle(FileMode mode, FileShare share, FileOptions options);
    private SafeFileHandle CreateFileOpenHandle(FileMode mode, FileShare share, FileOptions options);
    private static bool GetDefaultIsAsync(SafeFileHandle handle);
    private static Nullable`1<bool> IsHandleSynchronous(SafeFileHandle fileHandle, bool ignoreInvalid);
    private static void VerifyHandleIsSync(SafeFileHandle handle, int fileType, FileAccess access);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, int hresult);
    public IOException(string message, Exception innerException);
    protected IOException(SerializationInfo info, StreamingContext context);
}
public class System.IO.MemoryStream : Stream {
    private Byte[] _buffer;
    private int _origin;
    private int _position;
    private int _length;
    private int _capacity;
    private bool _expandable;
    private bool _writable;
    private bool _exposable;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    private static int MemStreamMaxLength;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureNotClosed();
    private void EnsureWriteable();
    protected virtual void Dispose(bool disposing);
    private bool EnsureCapacity(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    internal Byte[] InternalGetBuffer();
    internal int InternalGetPosition();
    internal int InternalReadInt32();
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
public static class System.IO.Path : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static char PathSeparator;
    private static int KeyLength;
    [ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    private static Char[] s_base32Char;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static Path();
    public static string ChangeExtension(string path, string extension);
    public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    private static int GetDirectoryNameOffset(ReadOnlySpan`1<char> path);
    public static string GetExtension(string path);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    public static string GetFileName(string path);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    public static string GetFileNameWithoutExtension(string path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    public static string GetRandomFileName();
    public static bool IsPathFullyQualified(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    public static bool HasExtension(string path);
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    [__BlockReflectionAttribute]
public static string Join(string path1, string path2);
    [__BlockReflectionAttribute]
public static string Join(string path1, string path2, string path3);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    private static string CombineInternal(string first, string second);
    private static string CombineInternal(string first, string second, string third);
    private static string CombineInternal(string first, string second, string third, string fourth);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third, ReadOnlySpan`1<char> fourth);
    private static void Populate83FileNameFromRandomBytes(Byte* bytes, int byteCount, Char* chars, int charCount);
    public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    internal static StringComparison get_StringComparison();
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static string GetFullPath(string path);
    public static string GetFullPath(string path, string basePath);
    public static string GetTempPath();
    private static void GetTempPath(ValueStringBuilder& builder);
    public static string GetTempFileName();
    public static bool IsPathRooted(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    public static string GetPathRoot(string path);
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    internal static bool get_IsCaseSensitive();
    internal static ReadOnlySpan`1<char> GetVolumeName(ReadOnlySpan`1<char> path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static int GetUncRootLength(ReadOnlySpan`1<char> path);
}
internal class System.IO.PathHelper : object {
    internal static string Normalize(string path);
    internal static string Normalize(ValueStringBuilder& path);
    private static void GetFullPathName(ReadOnlySpan`1<char> path, ValueStringBuilder& builder);
    internal static int PrependDevicePathChars(ValueStringBuilder& content, bool isDosUnc, ValueStringBuilder& buffer);
    internal static string TryExpandShortFileName(ValueStringBuilder& outputBuilder, string originalPath);
}
internal static class System.IO.PathInternal : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static char PathSeparator;
    internal static string DirectorySeparatorCharAsString;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static string ParentDirectoryPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static bool RemoveRelativeSegments(ReadOnlySpan`1<char> path, int rootLength, ValueStringBuilder& sb);
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefixOverMaxPath(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static bool HasWildCardCharacters(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    private Byte[] _array;
    private GCHandle _pinningHandle;
    internal PinnedBufferMemoryStream(Byte[] array);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    private static int DefaultCopyBufferSize;
    private ReadWriteTask _activeReadWriteTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private static Stream();
    internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<CopyToAsyncInternal>d__28")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    private int GetCopyBufferSize();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    public virtual int EndRead(IAsyncResult asyncResult);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    private void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask);
    private void RunReadWriteTask(ReadWriteTask readWriteTask);
    private void FinishTrackingAsyncOperation();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<FinishWriteAsync>d__57")]
private Task FinishWriteAsync(Task writeTask, Byte[] localBuffer);
    private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static int BlockingEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static void BlockingEndWrite(IAsyncResult asyncResult);
    private bool HasOverriddenBeginEndRead();
    private bool HasOverriddenBeginEndWrite();
    [AsyncStateMachineAttribute("System.IO.Stream/<<ReadAsync>g__FinishReadAsync|44_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|44_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    private static int DefaultBufferSize;
    private static int DefaultFileStreamBufferSize;
    private static int MinBufferSize;
    private Stream _stream;
    private Encoding _encoding;
    private Decoder _decoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private int _byteLen;
    private int _bytePos;
    private int _maxCharsPerBuffer;
    private bool _detectEncoding;
    private bool _checkPreamble;
    private bool _isBlocked;
    private bool _closable;
    private Task _asyncReadTask;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    private static StreamReader();
    private void CheckAsyncTaskInProgress();
    private static void ThrowAsyncIOInProgress();
    private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    internal void Init(Stream stream);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    public void DiscardBufferedData();
    public bool get_EndOfStream();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    private int ReadSpan(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    private void CompressBuffer(int n);
    private void DetectEncoding();
    private bool IsPreamble();
    internal virtual int ReadBuffer();
    private int ReadBuffer(Span`1<char> userBuffer, Boolean& readToUserBuffer);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadLineAsyncInternal>d__61")]
private Task`1<string> ReadLineAsyncInternal();
    public virtual Task`1<string> ReadToEndAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadToEndAsyncInternal>d__63")]
private Task`1<string> ReadToEndAsyncInternal();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadAsyncInternal>d__66")]
internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadBufferAsync>d__69")]
private Task`1<int> ReadBufferAsync();
}
public class System.IO.StreamWriter : TextWriter {
    private static int DefaultBufferSize;
    private static int DefaultFileStreamBufferSize;
    private static int MinBufferSize;
    private static int DontCopyOnWriteLineThreshold;
    public static StreamWriter Null;
    private Stream _stream;
    private Encoding _encoding;
    private Encoder _encoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private bool _autoFlush;
    private bool _haveWrittenPreamble;
    private bool _closable;
    private Task _asyncWriteTask;
    private static Encoding UTF8NoBOM { get; }
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    internal bool LeaveOpen { get; }
    unknown bool HaveWrittenPreamble {internal set; }
    public Encoding Encoding { get; }
    unknown int CharPos_Prop {private set; }
    unknown bool HaveWrittenPreamble_Prop {private set; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    private static StreamWriter();
    private void CheckAsyncTaskInProgress();
    private static void ThrowAsyncIOInProgress();
    private static Encoding get_UTF8NoBOM();
    private void Init(Stream streamArg, Encoding encodingArg, int bufferSize, bool shouldLeaveOpen);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    private void Flush(bool flushStream, bool flushEncoder);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    internal bool get_LeaveOpen();
    internal void set_HaveWrittenPreamble(bool value);
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    private void WriteSpan(ReadOnlySpan`1<char> buffer, bool appendNewLine);
    public virtual void Write(string value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> value);
    private void WriteFormatHelper(string format, ParamsArray args, bool appendNewLine);
    [__BlockReflectionAttribute]
public virtual void Write(string format, object arg0);
    [__BlockReflectionAttribute]
public virtual void Write(string format, object arg0, object arg1);
    [__BlockReflectionAttribute]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    [__BlockReflectionAttribute]
public virtual void Write(string format, Object[] arg);
    [__BlockReflectionAttribute]
public virtual void WriteLine(string format, object arg0);
    [__BlockReflectionAttribute]
public virtual void WriteLine(string format, object arg0, object arg1);
    [__BlockReflectionAttribute]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    [__BlockReflectionAttribute]
public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__63")]
private static Task WriteAsyncInternal(StreamWriter _this, char value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(string value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__65")]
private static Task WriteAsyncInternal(StreamWriter _this, string value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__68")]
private static Task WriteAsyncInternal(StreamWriter _this, ReadOnlyMemory`1<char> source, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    private void set_CharPos_Prop(int value);
    private void set_HaveWrittenPreamble_Prop(bool value);
    private Task FlushAsyncInternal(bool flushStream, bool flushEncoder, Char[] sCharBuffer, int sCharPos, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<FlushAsyncInternal>d__80")]
private static Task FlushAsyncInternal(StreamWriter _this, bool flushStream, bool flushEncoder, Char[] charBuffer, int charPos, bool haveWrittenPreamble, Encoding encoding, Encoder encoder, Byte[] byteBuffer, Stream stream, CancellationToken cancellationToken);
}
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    private static TextReader();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadToEndAsync>d__14")]
public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadBlockAsyncInternal>d__20")]
internal ValueTask`1<int> ReadBlockAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public static TextReader Synchronized(TextReader reader);
}
public abstract class System.IO.TextWriter : MarshalByRefObject {
    public static TextWriter Null;
    private static Char[] s_coreNewLine;
    protected Char[] CoreNewLine;
    private string CoreNewLineStr;
    private IFormatProvider _internalFormatProvider;
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    protected TextWriter(IFormatProvider formatProvider);
    private static TextWriter();
    public virtual IFormatProvider get_FormatProvider();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual void Flush();
    public abstract virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(string value);
    public virtual void Write(object value);
    [__BlockReflectionAttribute]
public virtual void Write(StringBuilder value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(string value);
    [__BlockReflectionAttribute]
public virtual void WriteLine(StringBuilder value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    [__BlockReflectionAttribute]
public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    [__BlockReflectionAttribute]
public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
    [AsyncStateMachineAttribute("System.IO.TextWriter/<<WriteAsync>g__WriteAsyncCore|59_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|59_0(StringBuilder sb, CancellationToken ct);
    [AsyncStateMachineAttribute("System.IO.TextWriter/<<WriteLineAsync>g__WriteLineAsyncCore|65_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteLineAsync>g__WriteLineAsyncCore|65_0(StringBuilder sb, CancellationToken ct);
}
public class System.IO.UnmanagedMemoryAccessor : object {
    private SafeBuffer _buffer;
    private long _offset;
    private long _capacity;
    private FileAccess _access;
    private bool _isOpen;
    private bool _canRead;
    private bool _canWrite;
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    public decimal ReadDecimal(long position);
    public float ReadSingle(long position);
    public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    public void Write(long position, decimal value);
    public void Write(long position, float value);
    public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void Write(long position, T& structure);
    public void WriteArray(long position, T[] array, int offset, int count);
    private void EnsureSafeToRead(long position, int sizeOfType);
    private void EnsureSafeToWrite(long position, int sizeOfType);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    private SafeBuffer _buffer;
    private Byte* _mem;
    private long _length;
    private long _capacity;
    private long _position;
    private long _offset;
    private FileAccess _access;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    private void EnsureNotClosed();
    private void EnsureReadable();
    private void EnsureWriteable();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public long get_Capacity();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    internal int ReadCore(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [__BlockReflectionAttribute]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [__BlockReflectionAttribute]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    private UnmanagedMemoryStream _unmanagedStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static int TryMakeWin32ErrorCodeFromHR(int hr);
    internal static string GetMessage(int errorCode);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
internal interface System.ISpanFormattable {
    public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
internal interface System.ITupleInternal {
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
internal interface System.IValueTupleInternal {
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual string ToStringEnd();
}
[DebuggerTypeProxyAttribute("System.LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
public class System.Lazy`1 : object {
    private LazyHelper modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Func`1<T> _factory;
    private T _value;
    internal T ValueForDebugDisplay { get; }
    internal Nullable`1<LazyThreadSafetyMode> Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode, bool useDefaultConstructor);
    private static T CreateViaDefaultConstructor();
    private void ViaConstructor();
    private void ViaFactory(LazyThreadSafetyMode mode);
    private void ExecutionAndPublication(LazyHelper executionAndPublication, bool useDefaultConstructor);
    private void PublicationOnly(LazyHelper publicationOnly, T possibleValue);
    private void PublicationOnlyViaConstructor(LazyHelper initializer);
    private void PublicationOnlyViaFactory(LazyHelper initializer);
    private void PublicationOnlyWaitForOtherThreadToPublish();
    private T CreateValue();
    public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal Nullable`1<LazyThreadSafetyMode> get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
internal class System.LazyDebugView`1 : object {
    private Lazy`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Nullable`1<LazyThreadSafetyMode> Mode { get; }
    public bool IsValueFaulted { get; }
    public LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public Nullable`1<LazyThreadSafetyMode> get_Mode();
    public bool get_IsValueFaulted();
}
internal class System.LazyHelper : object {
    internal static LazyHelper NoneViaConstructor;
    internal static LazyHelper NoneViaFactory;
    internal static LazyHelper PublicationOnlyViaConstructor;
    internal static LazyHelper PublicationOnlyViaFactory;
    internal static LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
    [CompilerGeneratedAttribute]
private LazyState <State>k__BackingField;
    private ExceptionDispatchInfo _exceptionDispatch;
    internal LazyState State { get; }
    internal LazyHelper(LazyState state);
    internal LazyHelper(LazyThreadSafetyMode mode, Exception exception);
    private static LazyHelper();
    [CompilerGeneratedAttribute]
internal LazyState get_State();
    internal void ThrowException();
    private LazyThreadSafetyMode GetMode();
    internal static Nullable`1<LazyThreadSafetyMode> GetMode(LazyHelper state);
    internal static bool GetIsValueFaulted(LazyHelper state);
    internal static LazyHelper Create(LazyThreadSafetyMode mode, bool useDefaultConstructor);
    internal static object CreateViaDefaultConstructor(Type type);
    internal static LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
}
internal enum System.LazyState : Enum {
    public int value__;
    public static LazyState NoneViaConstructor;
    public static LazyState NoneViaFactory;
    public static LazyState NoneException;
    public static LazyState PublicationOnlyViaConstructor;
    public static LazyState PublicationOnlyViaFactory;
    public static LazyState PublicationOnlyWait;
    public static LazyState PublicationOnlyException;
    public static LazyState ExecutionAndPublicationViaConstructor;
    public static LazyState ExecutionAndPublicationViaFactory;
    public static LazyState ExecutionAndPublicationException;
}
public abstract class System.MarshalByRefObject : object {
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
internal static class System.Marvin : object {
    [CompilerGeneratedAttribute]
private static ulong <DefaultSeed>k__BackingField;
    public static ulong DefaultSeed { get; }
    private static Marvin();
    public static int ComputeHash32(ReadOnlySpan`1<byte> data, ulong seed);
    public static int ComputeHash32(Byte& data, int count, ulong seed);
    private static void Block(UInt32& rp0, UInt32& rp1);
    private static UInt32 _rotl(UInt32 value, int shift);
    [CompilerGeneratedAttribute]
public static ulong get_DefaultSeed();
    private static ulong GenerateSeed();
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    private static int maxRoundingDigits;
    private static double doubleRoundLimit;
    private static Double[] roundPower10Double;
    private static Math();
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static decimal Abs(decimal value);
    [StackTraceHiddenAttribute]
private static void ThrowAbsOverflow();
    public static long BigMul(int a, int b);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    internal static UInt32 DivRem(UInt32 a, UInt32 b, UInt32& result);
    internal static ulong DivRem(ulong a, ulong b, UInt64& result);
    public static decimal Ceiling(decimal d);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    public static decimal Floor(decimal d);
    public static double IEEERemainder(double x, double y);
    public static double Log(double a, double newBase);
    [NonVersionableAttribute]
public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    [NonVersionableAttribute]
public static short Max(short val1, short val2);
    [NonVersionableAttribute]
public static int Max(int val1, int val2);
    [NonVersionableAttribute]
public static long Max(long val1, long val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Max(ulong val1, ulong val2);
    [NonVersionableAttribute]
public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    [NonVersionableAttribute]
public static short Min(short val1, short val2);
    [NonVersionableAttribute]
public static int Min(int val1, int val2);
    [NonVersionableAttribute]
public static long Min(long val1, long val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Min(ulong val1, ulong val2);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    [IntrinsicAttribute]
public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
    private static double copysign(double x, double y);
    private static void ThrowMinMaxException(T min, T max);
    [IntrinsicAttribute]
public static float Abs(float value);
    [IntrinsicAttribute]
public static double Abs(double value);
    [IntrinsicAttribute]
public static double Acos(double d);
    [IntrinsicAttribute]
public static double Acosh(double d);
    [IntrinsicAttribute]
public static double Asin(double d);
    [IntrinsicAttribute]
public static double Asinh(double d);
    [IntrinsicAttribute]
public static double Atan(double d);
    [IntrinsicAttribute]
public static double Atan2(double y, double x);
    [IntrinsicAttribute]
public static double Atanh(double d);
    [IntrinsicAttribute]
public static double Cbrt(double d);
    [IntrinsicAttribute]
public static double Ceiling(double a);
    [IntrinsicAttribute]
public static double Cos(double d);
    [IntrinsicAttribute]
public static double Cosh(double value);
    [IntrinsicAttribute]
public static double Exp(double d);
    [IntrinsicAttribute]
public static double Floor(double d);
    [IntrinsicAttribute]
public static double Log(double d);
    [IntrinsicAttribute]
public static double Log10(double d);
    [IntrinsicAttribute]
public static double Pow(double x, double y);
    [IntrinsicAttribute]
public static double Sin(double a);
    [IntrinsicAttribute]
public static double Sinh(double value);
    [IntrinsicAttribute]
public static double Sqrt(double d);
    [IntrinsicAttribute]
public static double Tan(double a);
    [IntrinsicAttribute]
public static double Tanh(double value);
    [IntrinsicAttribute]
private static double FMod(double x, double y);
    [IntrinsicAttribute]
private static double ModF(double x, Double* intptr);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    private static int maxRoundingDigits;
    private static Single[] roundPower10Single;
    private static float singleRoundLimit;
    private static MathF();
    public static float Abs(float x);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x, float y);
    public static float Max(float x, float y);
    public static float Min(float x, float y);
    [IntrinsicAttribute]
public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, MidpointRounding mode);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static int Sign(float x);
    public static float Truncate(float x);
    private static float CopySign(float x, float y);
    [IntrinsicAttribute]
public static float Acos(float x);
    [IntrinsicAttribute]
public static float Acosh(float x);
    [IntrinsicAttribute]
public static float Asin(float x);
    [IntrinsicAttribute]
public static float Asinh(float x);
    [IntrinsicAttribute]
public static float Atan(float x);
    [IntrinsicAttribute]
public static float Atan2(float y, float x);
    [IntrinsicAttribute]
public static float Atanh(float x);
    [IntrinsicAttribute]
public static float Cbrt(float x);
    [IntrinsicAttribute]
public static float Ceiling(float x);
    [IntrinsicAttribute]
public static float Cos(float x);
    [IntrinsicAttribute]
public static float Cosh(float x);
    [IntrinsicAttribute]
public static float Exp(float x);
    [IntrinsicAttribute]
public static float Floor(float x);
    [IntrinsicAttribute]
public static float Log(float x);
    [IntrinsicAttribute]
public static float Log10(float x);
    [IntrinsicAttribute]
public static float Pow(float x, float y);
    [IntrinsicAttribute]
public static float Sin(float x);
    [IntrinsicAttribute]
public static float Sinh(float x);
    [IntrinsicAttribute]
public static float Sqrt(float x);
    [IntrinsicAttribute]
public static float Tan(float x);
    [IntrinsicAttribute]
public static float Tanh(float x);
    [IntrinsicAttribute]
private static float FMod(float x, float y);
    [IntrinsicAttribute]
private static float ModF(float x, Single* intptr);
}
[__BlockReflectionAttribute]
public class System.MDArray : object {
    public static int MinRank;
    public static int MaxRank;
}
[__BlockReflectionAttribute]
public class System.MDArrayRank10`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank11`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank12`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank13`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank14`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank15`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank16`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank17`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank18`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank19`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank2`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _lowerBound1;
    private int _lowerBound2;
    private T _data;
    public static T[0...,0...] Ctor(int length1, int length2);
    public static object PointerArrayCtor(int length1, int length2);
    private static T& InternalAddress(T[0...,0...] array, int index1, int index2);
    public static T& Address(T[0...,0...] array, int index1, int index2);
    public static T& ReadonlyAddress(T[0...,0...] array, int index1, int index2);
    public static T Get(T[0...,0...] array, int index1, int index2);
    public static void Set(T[0...,0...] array, int index1, int index2, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank20`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank21`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank22`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank23`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank24`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank25`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank26`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank27`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _upperBound27;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private int _lowerBound27;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank28`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _upperBound27;
    private int _upperBound28;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private int _lowerBound27;
    private int _lowerBound28;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank29`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _upperBound27;
    private int _upperBound28;
    private int _upperBound29;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private int _lowerBound27;
    private int _lowerBound28;
    private int _lowerBound29;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank3`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private T _data;
    public static T[0...,0...,0...] Ctor(int length1, int length2, int length3);
    public static object PointerArrayCtor(int length1, int length2, int length3);
    private static T& InternalAddress(T[0...,0...,0...] array, int index1, int index2, int index3);
    public static T& Address(T[0...,0...,0...] array, int index1, int index2, int index3);
    public static T& ReadonlyAddress(T[0...,0...,0...] array, int index1, int index2, int index3);
    public static T Get(T[0...,0...,0...] array, int index1, int index2, int index3);
    public static void Set(T[0...,0...,0...] array, int index1, int index2, int index3, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank30`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _upperBound27;
    private int _upperBound28;
    private int _upperBound29;
    private int _upperBound30;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private int _lowerBound27;
    private int _lowerBound28;
    private int _lowerBound29;
    private int _lowerBound30;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29, int length30);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29, int length30);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank31`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _upperBound27;
    private int _upperBound28;
    private int _upperBound29;
    private int _upperBound30;
    private int _upperBound31;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private int _lowerBound27;
    private int _lowerBound28;
    private int _lowerBound29;
    private int _lowerBound30;
    private int _lowerBound31;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29, int length30, int length31);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29, int length30, int length31);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank32`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _upperBound10;
    private int _upperBound11;
    private int _upperBound12;
    private int _upperBound13;
    private int _upperBound14;
    private int _upperBound15;
    private int _upperBound16;
    private int _upperBound17;
    private int _upperBound18;
    private int _upperBound19;
    private int _upperBound20;
    private int _upperBound21;
    private int _upperBound22;
    private int _upperBound23;
    private int _upperBound24;
    private int _upperBound25;
    private int _upperBound26;
    private int _upperBound27;
    private int _upperBound28;
    private int _upperBound29;
    private int _upperBound30;
    private int _upperBound31;
    private int _upperBound32;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private int _lowerBound10;
    private int _lowerBound11;
    private int _lowerBound12;
    private int _lowerBound13;
    private int _lowerBound14;
    private int _lowerBound15;
    private int _lowerBound16;
    private int _lowerBound17;
    private int _lowerBound18;
    private int _lowerBound19;
    private int _lowerBound20;
    private int _lowerBound21;
    private int _lowerBound22;
    private int _lowerBound23;
    private int _lowerBound24;
    private int _lowerBound25;
    private int _lowerBound26;
    private int _lowerBound27;
    private int _lowerBound28;
    private int _lowerBound29;
    private int _lowerBound30;
    private int _lowerBound31;
    private int _lowerBound32;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29, int length30, int length31, int length32);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9, int length10, int length11, int length12, int length13, int length14, int length15, int length16, int length17, int length18, int length19, int length20, int length21, int length22, int length23, int length24, int length25, int length26, int length27, int length28, int length29, int length30, int length31, int length32);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31, int index32);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31, int index32);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31, int index32);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31, int index32);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, int index10, int index11, int index12, int index13, int index14, int index15, int index16, int index17, int index18, int index19, int index20, int index21, int index22, int index23, int index24, int index25, int index26, int index27, int index28, int index29, int index30, int index31, int index32, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank4`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private T _data;
    public static T[0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4);
    private static T& InternalAddress(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4);
    public static T& Address(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4);
    public static T Get(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4);
    public static void Set(T[0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank5`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private T _data;
    public static T[0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5);
    public static T& Address(T[0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5);
    public static T Get(T[0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5);
    public static void Set(T[0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank6`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6);
    public static T& Address(T[0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6);
    public static T Get(T[0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6);
    public static void Set(T[0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank7`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank8`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, T value);
}
[__BlockReflectionAttribute]
public class System.MDArrayRank9`1 : object {
    private IntPtr _count;
    private int _upperBound1;
    private int _upperBound2;
    private int _upperBound3;
    private int _upperBound4;
    private int _upperBound5;
    private int _upperBound6;
    private int _upperBound7;
    private int _upperBound8;
    private int _upperBound9;
    private int _lowerBound1;
    private int _lowerBound2;
    private int _lowerBound3;
    private int _lowerBound4;
    private int _lowerBound5;
    private int _lowerBound6;
    private int _lowerBound7;
    private int _lowerBound8;
    private int _lowerBound9;
    private T _data;
    public static T[0...,0...,0...,0...,0...,0...,0...,0...,0...] Ctor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9);
    public static object PointerArrayCtor(int length1, int length2, int length3, int length4, int length5, int length6, int length7, int length8, int length9);
    private static T& InternalAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9);
    public static T& Address(T[0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9);
    public static T& ReadonlyAddress(T[0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9);
    public static T Get(T[0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9);
    public static void Set(T[0...,0...,0...,0...,0...,0...,0...,0...,0...] array, int index1, int index2, int index3, int index4, int index5, int index6, int index7, int index8, int index9, T value);
}
internal static class System.MDPointerArrayHelper : object {
    public static object GetMDPointerArray(EETypePtr pointerDepthType, EETypePtr elementType, Int32[] lengths);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    private static int RemoveFlagsBitMask;
    public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
[__BlockReflectionAttribute]
public static bool Contains(Span`1<T> span, T value);
    [ExtensionAttribute]
[__BlockReflectionAttribute]
public static bool Contains(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    private static bool IsTypeComparableAsBytes(UInt32& size);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool EqualsOrdinal(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
[__BlockReflectionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
    public MissingFieldException(string className, string fieldName);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    public MissingMemberException(string className, string memberName);
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    internal static string FormatSignature(Byte[] signature);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
    public MissingMethodException(string className, string methodName);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
public class System.ModuleHandle : ValueType {
    public static ModuleHandle EmptyHandle;
    private Module _ptr;
    internal Module AssociatedModule { get; }
    public int MDStreamVersion { get; }
    [__BlockReflectionAttribute]
public ModuleHandle(Module module);
    private static ModuleHandle();
    internal Module get_AssociatedModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ModuleHandle handle);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public int get_MDStreamVersion();
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
public abstract class System.MulticastDelegate : Delegate {
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    private bool InvocationListEquals(MulticastDelegate d);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    public sealed virtual Delegate[] GetInvocationList();
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotFiniteNumberException : ArithmeticException {
    private double _offendingNumber;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [NonVersionableAttribute]
public Nullable`1(T value);
    [NonVersionableAttribute]
public bool get_HasValue();
    public T get_Value();
    [NonVersionableAttribute]
public T GetValueOrDefault();
    [NonVersionableAttribute]
public T GetValueOrDefault(T defaultValue);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NonVersionableAttribute]
public static Nullable`1<T> op_Implicit(T value);
    [NonVersionableAttribute]
public static T op_Explicit(Nullable`1<T> value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
internal static class System.Number : object {
    internal static int DecimalPrecision;
    private static int FloatPrecision;
    private static int DoublePrecision;
    private static int ScaleNAN;
    private static int ScaleINF;
    private static int MaxUInt32DecDigits;
    private static int CharStackBufferSize;
    private static string PosNumberFormat;
    private static String[] s_singleDigitStringCache;
    private static String[] s_posCurrencyFormats;
    private static String[] s_negCurrencyFormats;
    private static String[] s_posPercentFormats;
    private static String[] s_negPercentFormats;
    private static String[] s_negNumberFormats;
    private static int NumberMaxDigits;
    private static int Int32Precision;
    private static int UInt32Precision;
    private static int Int64Precision;
    private static int UInt64Precision;
    private static Int32[] s_charToHexLookup;
    private static int _CVTBUFSIZE;
    private static UInt64[] s_rgval64Power10;
    private static SByte[] s_rgexp64Power10;
    private static UInt64[] s_rgval64Power10By16;
    private static Int16[] s_rgexp64Power10By16;
    private static Number();
    public static string FormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static bool TryFormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static void DecimalToNumber(Decimal& d, NumberBuffer& number);
    public static string FormatDouble(double value, string format, NumberFormatInfo info);
    public static bool TryFormatDouble(double value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatDouble(ValueStringBuilder& sb, double value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static string FormatSingle(float value, string format, NumberFormatInfo info);
    public static bool TryFormatSingle(float value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatSingle(ValueStringBuilder& sb, float value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static bool TryCopyTo(string source, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    private static void Int32ToNumber(int value, NumberBuffer& number);
    private static string NegativeInt32ToDecStr(int value, int digits, string sNegative);
    private static bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int32ToHexStr(int value, char hexBase, int digits);
    private static bool TryInt32ToHexStr(int value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static Char* Int32ToHexChars(Char* buffer, UInt32 value, int hexBase, int digits);
    private static void UInt32ToNumber(UInt32 value, NumberBuffer& number);
    internal static Char* UInt32ToDecChars(Char* bufferEnd, UInt32 value, int digits);
    private static string UInt32ToDecStr(UInt32 value, int digits);
    private static bool TryUInt32ToDecStr(UInt32 value, int digits, Span`1<char> destination, Int32& charsWritten);
    private static bool TryCopyTo(Char* src, int length, Span`1<char> destination, Int32& charsWritten);
    private static void Int64ToNumber(long input, NumberBuffer& number);
    private static string NegativeInt64ToDecStr(long input, int digits, string sNegative);
    private static bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int64ToHexStr(long value, char hexBase, int digits);
    private static bool TryInt64ToHexStr(long value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static void UInt64ToNumber(ulong value, NumberBuffer& number);
    private static string UInt64ToDecStr(ulong value, int digits);
    private static bool TryUInt64ToDecStr(ulong value, int digits, Span`1<char> destination, Int32& charsWritten);
    internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    internal static void NumberToString(ValueStringBuilder& sb, NumberBuffer& number, char format, int nMaxDigits, NumberFormatInfo info, bool isDecimal);
    internal static void NumberToStringFormat(ValueStringBuilder& sb, NumberBuffer& number, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static void FormatCurrency(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatFixed(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, Int32[] groupDigits, string sDecimal, string sGroup);
    private static void FormatNumber(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatScientific(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar);
    private static void FormatExponent(ValueStringBuilder& sb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
    private static void FormatGeneral(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar, bool bSuppressScientific);
    private static void FormatPercent(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void RoundNumber(NumberBuffer& number, int pos);
    private static int FindSection(ReadOnlySpan`1<char> format, int section);
    private static UInt32 Low32(ulong value);
    private static UInt32 High32(ulong value);
    private static UInt32 Int64DivMod1E9(UInt64& value);
    private static bool NumberToInt32(NumberBuffer& number, Int32& value);
    private static bool NumberToInt64(NumberBuffer& number, Int64& value);
    private static bool NumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool NumberToUInt64(NumberBuffer& number, UInt64& value);
    internal static int ParseInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static long ParseInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static UInt32 ParseUInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static ulong ParseUInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    private static bool ParseNumber(Char*& str, Char* strEnd, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    internal static bool TryParseInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result);
    private static bool TryParseInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result, Boolean& failureIsOverflow);
    private static bool TryParseInt64IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result, Boolean& failureIsOverflow);
    internal static bool TryParseInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result);
    internal static bool TryParseUInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result);
    private static bool TryParseUInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result, Boolean& failureIsOverflow);
    private static bool TryParseUInt32HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result, Boolean& failureIsOverflow);
    internal static bool TryParseUInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result);
    private static bool TryParseUInt64IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result, Boolean& failureIsOverflow);
    private static bool TryParseUInt64HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result, Boolean& failureIsOverflow);
    internal static decimal ParseDecimal(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    private static bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value);
    internal static double ParseDouble(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static float ParseSingle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static bool TryParseDecimal(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Decimal& result);
    internal static bool TryParseDouble(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Double& result);
    internal static bool TryParseSingle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Single& result);
    private static void StringToNumber(ReadOnlySpan`1<char> value, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    internal static bool TryStringToNumber(ReadOnlySpan`1<char> value, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    private static bool TrailingZeros(ReadOnlySpan`1<char> value, int index);
    private static Char* MatchChars(Char* p, Char* pEnd, string value);
    private static bool IsWhite(int ch);
    private static bool IsDigit(int ch);
    private static void ThrowOverflowOrFormatException(bool overflow, string overflowResourceKey);
    private static bool NumberBufferToDouble(NumberBuffer& number, Double& value);
    private static UInt32 DigitsToInt(Char* p, int count);
    private static ulong Mul32x32To64(UInt32 a, UInt32 b);
    private static ulong Mul64Lossy(ulong a, ulong b, Int32& pexp);
    private static int abs(int value);
    private static double NumberToDouble(NumberBuffer& number);
    private static void DoubleToNumber(double value, int precision, NumberBuffer& number);
}
internal class System.Numerics.ConstantHelper : object {
    public static byte GetByteWithAllBitsSet();
    public static sbyte GetSByteWithAllBitsSet();
    public static ushort GetUInt16WithAllBitsSet();
    public static short GetInt16WithAllBitsSet();
    public static UInt32 GetUInt32WithAllBitsSet();
    public static int GetInt32WithAllBitsSet();
    public static ulong GetUInt64WithAllBitsSet();
    public static long GetInt64WithAllBitsSet();
    public static float GetSingleWithAllBitsSet();
    public static double GetDoubleWithAllBitsSet();
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int RandomSeed;
    private static HashHelpers();
    public static int Combine(int h1, int h2);
}
internal class System.Numerics.Register : ValueType {
    internal byte byte_0;
    internal byte byte_1;
    internal byte byte_2;
    internal byte byte_3;
    internal byte byte_4;
    internal byte byte_5;
    internal byte byte_6;
    internal byte byte_7;
    internal byte byte_8;
    internal byte byte_9;
    internal byte byte_10;
    internal byte byte_11;
    internal byte byte_12;
    internal byte byte_13;
    internal byte byte_14;
    internal byte byte_15;
    internal sbyte sbyte_0;
    internal sbyte sbyte_1;
    internal sbyte sbyte_2;
    internal sbyte sbyte_3;
    internal sbyte sbyte_4;
    internal sbyte sbyte_5;
    internal sbyte sbyte_6;
    internal sbyte sbyte_7;
    internal sbyte sbyte_8;
    internal sbyte sbyte_9;
    internal sbyte sbyte_10;
    internal sbyte sbyte_11;
    internal sbyte sbyte_12;
    internal sbyte sbyte_13;
    internal sbyte sbyte_14;
    internal sbyte sbyte_15;
    internal ushort uint16_0;
    internal ushort uint16_1;
    internal ushort uint16_2;
    internal ushort uint16_3;
    internal ushort uint16_4;
    internal ushort uint16_5;
    internal ushort uint16_6;
    internal ushort uint16_7;
    internal short int16_0;
    internal short int16_1;
    internal short int16_2;
    internal short int16_3;
    internal short int16_4;
    internal short int16_5;
    internal short int16_6;
    internal short int16_7;
    internal UInt32 uint32_0;
    internal UInt32 uint32_1;
    internal UInt32 uint32_2;
    internal UInt32 uint32_3;
    internal int int32_0;
    internal int int32_1;
    internal int int32_2;
    internal int int32_3;
    internal ulong uint64_0;
    internal ulong uint64_1;
    internal long int64_0;
    internal long int64_1;
    internal float single_0;
    internal float single_1;
    internal float single_2;
    internal float single_3;
    internal double double_0;
    internal double double_1;
}
[IntrinsicAttribute]
public static class System.Numerics.Vector : object {
    public static bool IsHardwareAccelerated { get; }
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<byte> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<ushort> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<UInt32> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<sbyte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<short> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<int> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<float> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<byte> Narrow(Vector`1<ushort> low, Vector`1<ushort> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> low, Vector`1<UInt32> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> low, Vector`1<ulong> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<sbyte> Narrow(Vector`1<short> low, Vector`1<short> high);
    [IntrinsicAttribute]
public static Vector`1<short> Narrow(Vector`1<int> low, Vector`1<int> high);
    [IntrinsicAttribute]
public static Vector`1<int> Narrow(Vector`1<long> low, Vector`1<long> high);
    [IntrinsicAttribute]
public static Vector`1<float> Narrow(Vector`1<double> low, Vector`1<double> high);
    [IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    [IntrinsicAttribute]
public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [IntrinsicAttribute]
public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    public static Vector`1<T> Abs(Vector`1<T> value);
    public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    public static T Dot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> SquareRoot(Vector`1<T> value);
    public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Negate(Vector`1<T> value);
    public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> OnesComplement(Vector`1<T> value);
    public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Vector`1 : ValueType {
    private Register register;
    private static int s_count;
    private static Vector`1<T> s_zero;
    private static Vector`1<T> s_one;
    private static Vector`1<T> s_allOnes;
    public static int Count { get; }
    public static Vector`1<T> Zero { get; }
    public static Vector`1<T> One { get; }
    internal static Vector`1<T> AllOnes { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public Vector`1(T value);
    [IntrinsicAttribute]
public Vector`1(T[] values);
    public Vector`1(T[] values, int index);
    internal Vector`1(Void* dataPointer);
    internal Vector`1(Void* dataPointer, int offset);
    private Vector`1(Register& existingRegister);
    public Vector`1(Span`1<T> values);
    private static Vector`1();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector`1<T> get_Zero();
    [IntrinsicAttribute]
public static Vector`1<T> get_One();
    internal static Vector`1<T> get_AllOnes();
    private static int InitializeCount();
    [IntrinsicAttribute]
public void CopyTo(T[] destination);
    [IntrinsicAttribute]
public void CopyTo(T[] destination, int startIndex);
    [IntrinsicAttribute]
public T get_Item(int index);
    public virtual bool Equals(object obj);
    [IntrinsicAttribute]
public sealed virtual bool Equals(Vector`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Abs(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static T DotProduct(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> SquareRoot(Vector`1<T> value);
    private static bool ScalarEquals(T left, T right);
    private static bool ScalarLessThan(T left, T right);
    private static bool ScalarGreaterThan(T left, T right);
    private static T ScalarAdd(T left, T right);
    private static T ScalarSubtract(T left, T right);
    private static T ScalarMultiply(T left, T right);
    private static T ScalarDivide(T left, T right);
    private static T GetOneValue();
    private static T GetAllBitsSetValue();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Object {
    internal IntPtr m_pEEType;
    internal EETypePtr EETypePtr { get; }
    [NonVersionableAttribute]
protected virtual void Finalize();
    [IntrinsicAttribute]
public Type GetType();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    public static bool ReferenceEquals(object objA, object objB);
    public virtual int GetHashCode();
    internal EETypePtr get_EETypePtr();
    protected object MemberwiseClone();
    internal Byte& GetRawData();
    internal UInt32 GetRawDataSize();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ObjectDisposedException : InvalidOperationException {
    private string _objectName;
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string objectName, string message);
    public ObjectDisposedException(string message, Exception innerException);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    private string _message;
    private bool _error;
    public string Message { get; }
    public bool IsError { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_Message();
    public bool get_IsError();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OperationCanceledException : SystemException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalCaseSensitiveComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[__BlockReflectionAttribute]
public class System.OrdinalComparer : StringComparer {
    private bool _ignoreCase;
    internal OrdinalComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.OrdinalIgnoreCaseComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class System.ParamsArray : ValueType {
    private static Object[] s_oneArgArray;
    private static Object[] s_twoArgArray;
    private static Object[] s_threeArgArray;
    private object _arg0;
    private object _arg1;
    private object _arg2;
    private Object[] _args;
    public int Length { get; }
    public object Item { get; }
    public ParamsArray(object arg0);
    public ParamsArray(object arg0, object arg1);
    public ParamsArray(object arg0, object arg1, object arg2);
    public ParamsArray(Object[] args);
    private static ParamsArray();
    public int get_Length();
    public object get_Item(int index);
    private object GetAtSlow(int index);
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull;
    public static ParseFailureKind Format;
    public static ParseFailureKind FormatWithParameter;
    public static ParseFailureKind FormatWithOriginalDateTime;
    public static ParseFailureKind FormatWithFormatSpecifier;
    public static ParseFailureKind FormatWithOriginalDateTimeAndParameter;
    public static ParseFailureKind FormatBadDateTimeCalendar;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    internal static int LeftAlign;
    internal static int RightAlign;
    internal static int PrefixSpace;
    internal static int PrintSign;
    internal static int PrintBase;
    internal static int PrintAsI1;
    internal static int PrintAsI2;
    internal static int PrintAsI4;
    internal static int TreatAsUnsigned;
    internal static int TreatAsI1;
    internal static int TreatAsI2;
    internal static int IsTight;
    internal static int NoSpace;
    internal static int PrintRadixBase;
    private static int MinRadix;
    private static int MaxRadix;
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags);
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static string IntToString(int n, int radix, int width, char paddingChar, int flags);
    public static string LongToString(long n, int radix, int width, char paddingChar, int flags);
    private static void EatWhiteSpace(ReadOnlySpan`1<char> s, Int32& i);
    private static long GrabLongs(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static int GrabInts(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static void ThrowOverflowInt32Exception();
    private static void ThrowOverflowInt64Exception();
    private static void ThrowOverflowUInt32Exception();
    private static void ThrowOverflowUInt64Exception();
    private static bool IsDigit(char c, int radix, Int32& result);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fCustomNumberParser;
    internal MatchNumberDelegate parseNumberDelegate;
    internal void Init();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class System.PreallocatedOutOfMemoryException : object {
    [CompilerGeneratedAttribute]
private static OutOfMemoryException <Instance>k__BackingField;
    public static OutOfMemoryException Instance { get; private set; }
    [CompilerGeneratedAttribute]
public static OutOfMemoryException get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(OutOfMemoryException value);
    internal static void Initialize();
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Progress`1 : object {
    private SynchronizationContext _synchronizationContext;
    private Action`1<T> _handler;
    private SendOrPostCallback _invokeHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<T> ProgressChanged;
    public Progress`1(Action`1<T> handler);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    private void InvokeHandlers(object state);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
public class System.Random : object {
    private static int MBIG;
    private static int MSEED;
    private static int MZ;
    private int _inext;
    private int _inextp;
    private Int32[] _seedArray;
    [ThreadStaticAttribute]
private static Random t_threadRandom;
    private static Random s_globalRandom;
    public Random(int Seed);
    private static Random();
    protected virtual double Sample();
    private int InternalSample();
    private static int GenerateSeed();
    private static int GenerateGlobalSeed();
    public virtual int Next();
    private double GetSampleForLargeRange();
    public virtual int Next(int minValue, int maxValue);
    public virtual int Next(int maxValue);
    public virtual double NextDouble();
    public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Span`1<byte> buffer);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    protected RankException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
public class System.ReadOnlySpan`1 : ValueType {
    internal ByReference`1<T> _pointer;
    [BoundAttribute]
private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static ReadOnlySpan`1<T> Empty { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(T& ptr, int length);
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    [BoundsCheckingAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Assembly : object {
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public bool IsFullyTrusted { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string EscapedCodeBase { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Type[] GetTypes();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual Type[] GetExportedTypes();
    public virtual Type[] GetForwardedTypes();
    public virtual string get_CodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_FullName();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public bool get_IsFullyTrusted();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string get_EscapedCodeBase();
    public object CreateInstance(string typeName);
    public object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual Module get_ManifestModule();
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual IEnumerable`1<Module> get_Modules();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    public static Assembly Load(Byte[] rawAssembly);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    public static Assembly UnsafeLoadFrom(string assemblyFile);
    public Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual SecurityRuleSet get_SecurityRuleSet();
    public static Assembly GetEntryAssembly();
    [IntrinsicAttribute]
public static Assembly GetExecutingAssembly();
    public static Assembly GetCallingAssembly();
    public static Assembly Load(AssemblyName assemblyRef);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly Load(string assemblyString);
    public static Assembly LoadFile(string path);
    public static Assembly LoadFrom(string assemblyFile);
    public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <AlgorithmId>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    [CompilerGeneratedAttribute]
public UInt32 get_AlgorithmId();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    [CompilerGeneratedAttribute]
public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultAlias>k__BackingField;
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    [CompilerGeneratedAttribute]
public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    private AssemblyNameFlags _flags;
    [ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Reflection.AssemblyName : object {
    private string _name;
    private Byte[] _publicKey;
    private Byte[] _publicKeyToken;
    private CultureInfo _cultureInfo;
    private string _codeBase;
    private Version _version;
    private StrongNameKeyPair _strongNameKeyPair;
    private AssemblyHashAlgorithm _hashAlgorithm;
    private AssemblyVersionCompatibility _versionCompatibility;
    private AssemblyNameFlags _flags;
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    public string CodeBase { get; public set; }
    public string EscapedCodeBase { get; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public string FullName { get; }
    public AssemblyName(string assemblyName);
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public string get_EscapedCodeBase();
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public sealed virtual object Clone();
    public static AssemblyName GetAssemblyName(string assemblyFile);
    public Byte[] GetPublicKey();
    public void SetPublicKey(Byte[] publicKey);
    public Byte[] GetPublicKeyToken();
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public string get_FullName();
    public virtual string ToString();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    internal static string EscapeCodeBase(string codebase);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
[ExtensionAttribute]
internal static class System.Reflection.AssemblyNameFormatter : object {
    public static KeyValuePair`2[] EscapeSequences;
    private static AssemblyNameFormatter();
    public static string ComputeDisplayName(string name, Version version, string cultureName, Byte[] pkt, AssemblyNameFlags flags, AssemblyContentType contentType);
    [ExtensionAttribute]
private static void AppendQuoted(StringBuilder sb, string s);
    [ExtensionAttribute]
private static Version CanonicalizeVersion(Version version);
}
[ExtensionAttribute]
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Reflection.AssemblyNameHelpers : object {
    private static UInt32 ALG_CLASS_HASH;
    private static UInt32 ALG_SID_SHA1;
    private static UInt32 ALG_CLASS_SIGNATURE;
    private static UInt32 PUBLICKEYBLOB;
    private static UInt32 SizeOfPublicKeyBlob;
    private static int PUBLIC_KEY_TOKEN_LEN;
    private static Byte[] s_ecmaKey;
    private static AssemblyNameHelpers();
    public static Byte[] ComputePublicKeyToken(Byte[] publicKey);
    private static bool IsValidPublicKey(Byte[] publicKey);
    private static bool ByteArrayEquals(Byte[] b1, Byte[] b2);
    private static UInt32 GetAlgClass(UInt32 x);
    private static UInt32 GetAlgSid(UInt32 x);
    [ExtensionAttribute]
public static RuntimeAssemblyName ToRuntimeAssemblyName(AssemblyName assemblyName);
    [ExtensionAttribute]
public static RuntimeAssemblyName CanonicalizePublicKeyToken(RuntimeAssemblyName name);
    [ExtensionAttribute]
internal static AssemblyContentType ExtractAssemblyContentType(AssemblyNameFlags flags);
    [ExtensionAttribute]
internal static ProcessorArchitecture ExtractProcessorArchitecture(AssemblyNameFlags flags);
    [ExtensionAttribute]
public static AssemblyNameFlags ExtractAssemblyNameFlags(AssemblyNameFlags combinedFlags);
    internal static AssemblyNameFlags CombineAssemblyNameFlags(AssemblyNameFlags flags, AssemblyContentType contentType, ProcessorArchitecture processorArchitecture);
}
internal class System.Reflection.AssemblyNameLexer : ValueType {
    private Char[] _chars;
    private int _index;
    internal AssemblyNameLexer(string s);
    internal Token GetNext();
    internal Token GetNext(String& tokenString);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Reflection.AssemblyNameParser : object {
    private static Char[] s_illegalCharactersInSimpleName;
    private static AssemblyNameParser();
    public static void Parse(AssemblyName blank, string s);
    public static RuntimeAssemblyName Parse(string s);
    private static Version ParseVersion(string attributeValue);
    private static string ParseCulture(string attributeValue);
    private static Byte[] ParsePKT(string attributeValue);
    private static ProcessorArchitecture ParseProcessorArchitecture(string attributeValue);
    private static byte ParseHexNybble(char c);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    [CompilerGeneratedAttribute]
public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Countersignature>k__BackingField;
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public string get_Countersignature();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Trademark>k__BackingField;
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    [CompilerGeneratedAttribute]
public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class System.Reflection.BinderBundle : object {
    private Binder _binder;
    private CultureInfo _culture;
    public BinderBundle(Binder binder, CultureInfo culture);
    public object ChangeType(object value, Type type);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags DoNotWrapExceptions;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    public static string ConstructorName;
    public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    public virtual MemberTypes get_MemberType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
public class System.Reflection.CustomAttributeData : object {
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public virtual Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
private static T OneOrNull(IEnumerable`1<CustomAttributeData> results);
    [ExtensionAttribute]
private static IEnumerable`1<Attribute> Instantiate(IEnumerable`1<CustomAttributeData> cads, Type actualElementType);
    [ExtensionAttribute]
internal static Attribute[] AsAttributeArray(IEnumerable`1<Attribute> attributes);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    [CompilerGeneratedAttribute]
private CustomAttributeTypedArgument <TypedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsField>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    private Type _attributeType;
    private MemberInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMemberInfo;
    public CustomAttributeTypedArgument TypedValue { get; }
    public bool IsField { get; }
    public string MemberName { get; }
    public MemberInfo MemberInfo { get; }
    internal CustomAttributeNamedArgument(Type attributeType, string memberName, bool isField, CustomAttributeTypedArgument typedValue);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    [CompilerGeneratedAttribute]
public CustomAttributeTypedArgument get_TypedValue();
    [CompilerGeneratedAttribute]
public bool get_IsField();
    [CompilerGeneratedAttribute]
public string get_MemberName();
    public MemberInfo get_MemberInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
}
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    [CompilerGeneratedAttribute]
private Type <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(object value);
    public CustomAttributeTypedArgument(Type argumentType, object value);
    [CompilerGeneratedAttribute]
public Type get_ArgumentType();
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
    internal string ToString(bool typed);
    private static object CanonicalizeValue(object value);
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    public string FullName { get; }
    public bool IsDynamic { get; }
    public Module ManifestModule { get; }
    public virtual string get_FullName();
    public virtual bool get_IsDynamic();
    public virtual Module get_ManifestModule();
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    public ModuleBuilder DefineDynamicModule(string name);
    public virtual bool Equals(object obj);
    public ModuleBuilder GetDynamicModule(string name);
    public virtual int GetHashCode();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess RunAndCollect;
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public virtual string ToString();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public RuntimeMethodHandle MethodHandle { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.EnumBuilder : TypeInfo {
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public bool IsConstructedGenericType { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public FieldBuilder UnderlyingField { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsByRefLike { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual bool get_IsConstructedGenericType();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public FieldBuilder get_UnderlyingField();
    public virtual Type get_UnderlyingSystemType();
    public TypeInfo CreateTypeInfo();
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual Type GetEnumUnderlyingType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsByRefLike();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakePointerType();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.EventBuilder : object {
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    public FieldAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual object GetValue(object obj);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetOffset(int iOffset);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
}
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsByRefLike { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Guid get_GUID();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public virtual bool Equals(object o);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsByRefLike();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public void SetBaseTypeConstraint(Type baseTypeConstraint);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
    public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public virtual string ToString();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.ILGenerator : object {
    public int ILOffset { get; }
    public virtual int get_ILOffset();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginExceptFilterBlock();
    public virtual Label BeginExceptionBlock();
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void BeginScope();
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual Label DefineLabel();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual void EmitWriteLine(string value);
    public virtual void EndExceptionBlock();
    public virtual void EndScope();
    public virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    public virtual void UsingNamespace(string usingNamespace);
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.Label : ValueType {
    internal int m_label;
    internal Label(int label);
    internal int GetLabelValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public Type DeclaringType { get; }
    public bool InitLocals { get; public set; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsConstructedGenericMethod { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type get_DeclaringType();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    public virtual bool Equals(object obj);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual int GetHashCode();
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public void SetParameters(Type[] parameterTypes);
    public void SetReturnType(Type returnType);
    public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public virtual string ToString();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.ModuleBuilder : Module {
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public void CreateGlobalFunctions();
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    public virtual bool Equals(object obj);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public virtual int GetHashCode();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public class System.Reflection.Emit.OpCode : ValueType {
    internal static int OperandTypeMask;
    internal static int FlowControlShift;
    internal static int FlowControlMask;
    internal static int OpCodeTypeShift;
    internal static int OpCodeTypeMask;
    internal static int StackBehaviourPopShift;
    internal static int StackBehaviourPushShift;
    internal static int StackBehaviourMask;
    internal static int SizeShift;
    internal static int SizeMask;
    internal static int EndsUncondJmpBlkFlag;
    internal static int StackChangeShift;
    private OpCodeValues m_value;
    private int m_flags;
    private static String[] modreq(System.Runtime.CompilerServices.IsVolatile) g_nameCache;
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public int Size { get; }
    public short Value { get; }
    public string Name { get; }
    internal OpCode(OpCodeValues value, int flags);
    internal bool EndsUncondJmpBlk();
    internal int StackChange();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public int get_Size();
    public short get_Value();
    public string get_Name();
    public virtual bool Equals(object obj);
    public bool Equals(OpCode obj);
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum System.Reflection.Emit.OpCodeValues : Enum {
    public int value__;
    public static OpCodeValues Nop;
    public static OpCodeValues Break;
    public static OpCodeValues Ldarg_0;
    public static OpCodeValues Ldarg_1;
    public static OpCodeValues Ldarg_2;
    public static OpCodeValues Ldarg_3;
    public static OpCodeValues Ldloc_0;
    public static OpCodeValues Ldloc_1;
    public static OpCodeValues Ldloc_2;
    public static OpCodeValues Ldloc_3;
    public static OpCodeValues Stloc_0;
    public static OpCodeValues Stloc_1;
    public static OpCodeValues Stloc_2;
    public static OpCodeValues Stloc_3;
    public static OpCodeValues Ldarg_S;
    public static OpCodeValues Ldarga_S;
    public static OpCodeValues Starg_S;
    public static OpCodeValues Ldloc_S;
    public static OpCodeValues Ldloca_S;
    public static OpCodeValues Stloc_S;
    public static OpCodeValues Ldnull;
    public static OpCodeValues Ldc_I4_M1;
    public static OpCodeValues Ldc_I4_0;
    public static OpCodeValues Ldc_I4_1;
    public static OpCodeValues Ldc_I4_2;
    public static OpCodeValues Ldc_I4_3;
    public static OpCodeValues Ldc_I4_4;
    public static OpCodeValues Ldc_I4_5;
    public static OpCodeValues Ldc_I4_6;
    public static OpCodeValues Ldc_I4_7;
    public static OpCodeValues Ldc_I4_8;
    public static OpCodeValues Ldc_I4_S;
    public static OpCodeValues Ldc_I4;
    public static OpCodeValues Ldc_I8;
    public static OpCodeValues Ldc_R4;
    public static OpCodeValues Ldc_R8;
    public static OpCodeValues Dup;
    public static OpCodeValues Pop;
    public static OpCodeValues Jmp;
    public static OpCodeValues Call;
    public static OpCodeValues Calli;
    public static OpCodeValues Ret;
    public static OpCodeValues Br_S;
    public static OpCodeValues Brfalse_S;
    public static OpCodeValues Brtrue_S;
    public static OpCodeValues Beq_S;
    public static OpCodeValues Bge_S;
    public static OpCodeValues Bgt_S;
    public static OpCodeValues Ble_S;
    public static OpCodeValues Blt_S;
    public static OpCodeValues Bne_Un_S;
    public static OpCodeValues Bge_Un_S;
    public static OpCodeValues Bgt_Un_S;
    public static OpCodeValues Ble_Un_S;
    public static OpCodeValues Blt_Un_S;
    public static OpCodeValues Br;
    public static OpCodeValues Brfalse;
    public static OpCodeValues Brtrue;
    public static OpCodeValues Beq;
    public static OpCodeValues Bge;
    public static OpCodeValues Bgt;
    public static OpCodeValues Ble;
    public static OpCodeValues Blt;
    public static OpCodeValues Bne_Un;
    public static OpCodeValues Bge_Un;
    public static OpCodeValues Bgt_Un;
    public static OpCodeValues Ble_Un;
    public static OpCodeValues Blt_Un;
    public static OpCodeValues Switch;
    public static OpCodeValues Ldind_I1;
    public static OpCodeValues Ldind_U1;
    public static OpCodeValues Ldind_I2;
    public static OpCodeValues Ldind_U2;
    public static OpCodeValues Ldind_I4;
    public static OpCodeValues Ldind_U4;
    public static OpCodeValues Ldind_I8;
    public static OpCodeValues Ldind_I;
    public static OpCodeValues Ldind_R4;
    public static OpCodeValues Ldind_R8;
    public static OpCodeValues Ldind_Ref;
    public static OpCodeValues Stind_Ref;
    public static OpCodeValues Stind_I1;
    public static OpCodeValues Stind_I2;
    public static OpCodeValues Stind_I4;
    public static OpCodeValues Stind_I8;
    public static OpCodeValues Stind_R4;
    public static OpCodeValues Stind_R8;
    public static OpCodeValues Add;
    public static OpCodeValues Sub;
    public static OpCodeValues Mul;
    public static OpCodeValues Div;
    public static OpCodeValues Div_Un;
    public static OpCodeValues Rem;
    public static OpCodeValues Rem_Un;
    public static OpCodeValues And;
    public static OpCodeValues Or;
    public static OpCodeValues Xor;
    public static OpCodeValues Shl;
    public static OpCodeValues Shr;
    public static OpCodeValues Shr_Un;
    public static OpCodeValues Neg;
    public static OpCodeValues Not;
    public static OpCodeValues Conv_I1;
    public static OpCodeValues Conv_I2;
    public static OpCodeValues Conv_I4;
    public static OpCodeValues Conv_I8;
    public static OpCodeValues Conv_R4;
    public static OpCodeValues Conv_R8;
    public static OpCodeValues Conv_U4;
    public static OpCodeValues Conv_U8;
    public static OpCodeValues Callvirt;
    public static OpCodeValues Cpobj;
    public static OpCodeValues Ldobj;
    public static OpCodeValues Ldstr;
    public static OpCodeValues Newobj;
    public static OpCodeValues Castclass;
    public static OpCodeValues Isinst;
    public static OpCodeValues Conv_R_Un;
    public static OpCodeValues Unbox;
    public static OpCodeValues Throw;
    public static OpCodeValues Ldfld;
    public static OpCodeValues Ldflda;
    public static OpCodeValues Stfld;
    public static OpCodeValues Ldsfld;
    public static OpCodeValues Ldsflda;
    public static OpCodeValues Stsfld;
    public static OpCodeValues Stobj;
    public static OpCodeValues Conv_Ovf_I1_Un;
    public static OpCodeValues Conv_Ovf_I2_Un;
    public static OpCodeValues Conv_Ovf_I4_Un;
    public static OpCodeValues Conv_Ovf_I8_Un;
    public static OpCodeValues Conv_Ovf_U1_Un;
    public static OpCodeValues Conv_Ovf_U2_Un;
    public static OpCodeValues Conv_Ovf_U4_Un;
    public static OpCodeValues Conv_Ovf_U8_Un;
    public static OpCodeValues Conv_Ovf_I_Un;
    public static OpCodeValues Conv_Ovf_U_Un;
    public static OpCodeValues Box;
    public static OpCodeValues Newarr;
    public static OpCodeValues Ldlen;
    public static OpCodeValues Ldelema;
    public static OpCodeValues Ldelem_I1;
    public static OpCodeValues Ldelem_U1;
    public static OpCodeValues Ldelem_I2;
    public static OpCodeValues Ldelem_U2;
    public static OpCodeValues Ldelem_I4;
    public static OpCodeValues Ldelem_U4;
    public static OpCodeValues Ldelem_I8;
    public static OpCodeValues Ldelem_I;
    public static OpCodeValues Ldelem_R4;
    public static OpCodeValues Ldelem_R8;
    public static OpCodeValues Ldelem_Ref;
    public static OpCodeValues Stelem_I;
    public static OpCodeValues Stelem_I1;
    public static OpCodeValues Stelem_I2;
    public static OpCodeValues Stelem_I4;
    public static OpCodeValues Stelem_I8;
    public static OpCodeValues Stelem_R4;
    public static OpCodeValues Stelem_R8;
    public static OpCodeValues Stelem_Ref;
    public static OpCodeValues Ldelem;
    public static OpCodeValues Stelem;
    public static OpCodeValues Unbox_Any;
    public static OpCodeValues Conv_Ovf_I1;
    public static OpCodeValues Conv_Ovf_U1;
    public static OpCodeValues Conv_Ovf_I2;
    public static OpCodeValues Conv_Ovf_U2;
    public static OpCodeValues Conv_Ovf_I4;
    public static OpCodeValues Conv_Ovf_U4;
    public static OpCodeValues Conv_Ovf_I8;
    public static OpCodeValues Conv_Ovf_U8;
    public static OpCodeValues Refanyval;
    public static OpCodeValues Ckfinite;
    public static OpCodeValues Mkrefany;
    public static OpCodeValues Ldtoken;
    public static OpCodeValues Conv_U2;
    public static OpCodeValues Conv_U1;
    public static OpCodeValues Conv_I;
    public static OpCodeValues Conv_Ovf_I;
    public static OpCodeValues Conv_Ovf_U;
    public static OpCodeValues Add_Ovf;
    public static OpCodeValues Add_Ovf_Un;
    public static OpCodeValues Mul_Ovf;
    public static OpCodeValues Mul_Ovf_Un;
    public static OpCodeValues Sub_Ovf;
    public static OpCodeValues Sub_Ovf_Un;
    public static OpCodeValues Endfinally;
    public static OpCodeValues Leave;
    public static OpCodeValues Leave_S;
    public static OpCodeValues Stind_I;
    public static OpCodeValues Conv_U;
    public static OpCodeValues Prefix7;
    public static OpCodeValues Prefix6;
    public static OpCodeValues Prefix5;
    public static OpCodeValues Prefix4;
    public static OpCodeValues Prefix3;
    public static OpCodeValues Prefix2;
    public static OpCodeValues Prefix1;
    public static OpCodeValues Prefixref;
    public static OpCodeValues Arglist;
    public static OpCodeValues Ceq;
    public static OpCodeValues Cgt;
    public static OpCodeValues Cgt_Un;
    public static OpCodeValues Clt;
    public static OpCodeValues Clt_Un;
    public static OpCodeValues Ldftn;
    public static OpCodeValues Ldvirtftn;
    public static OpCodeValues Ldarg;
    public static OpCodeValues Ldarga;
    public static OpCodeValues Starg;
    public static OpCodeValues Ldloc;
    public static OpCodeValues Ldloca;
    public static OpCodeValues Stloc;
    public static OpCodeValues Localloc;
    public static OpCodeValues Endfilter;
    public static OpCodeValues Unaligned_;
    public static OpCodeValues Volatile_;
    public static OpCodeValues Tail_;
    public static OpCodeValues Initobj;
    public static OpCodeValues Constrained_;
    public static OpCodeValues Cpblk;
    public static OpCodeValues Initblk;
    public static OpCodeValues Rethrow;
    public static OpCodeValues Sizeof;
    public static OpCodeValues Refanytype;
    public static OpCodeValues Readonly_;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.ParameterBuilder : object {
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public string Name { get; }
    public int Position { get; }
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOptional();
    public bool get_IsOut();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
[__BlockReflectionAttribute]
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetGetMethod(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
}
internal static class System.Reflection.Emit.ReflectionEmitThrower : object {
    public static void ThrowPlatformNotSupportedException();
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.SignatureHelper : object {
    public void AddArgument(Type clsArgument);
    public void AddArgument(Type argument, bool pinned);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public void AddSentinel();
    public virtual bool Equals(object obj);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public virtual int GetHashCode();
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public Byte[] GetSignature();
    public virtual string ToString();
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
[__BlockReflectionAttribute]
public class System.Reflection.Emit.TypeBuilder : TypeInfo {
    public static int UnspecifiedTypeSize;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public PackingSize PackingSize { get; }
    public Type ReflectedType { get; }
    public int Size { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Guid get_GUID();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public PackingSize get_PackingSize();
    public virtual Type get_ReflectedType();
    public int get_Size();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public void AddInterfaceImplementation(Type interfaceType);
    public Type CreateType();
    public TypeInfo CreateTypeInfo();
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ConstructorBuilder DefineTypeInitializer();
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public static FieldInfo GetField(Type type, FieldInfo field);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    public bool IsCreated();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetParent(Type parent);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
    public static EventAttributes ReservedMask;
}
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public bool IsMulticast { get; }
    public Type EventHandlerType { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual EventAttributes get_Attributes();
    public bool get_IsSpecialName();
    public MethodInfo[] GetOtherMethods();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public MethodInfo GetAddMethod();
    public MethodInfo GetRemoveMethod();
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual bool get_IsMulticast();
    public virtual Type get_EventHandlerType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
}
public class System.Reflection.ExceptionHandlingClause : object {
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes ReservedMask;
}
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual Type get_FieldType();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public abstract virtual object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public virtual object GetRawConstantValue();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
public class System.Reflection.InterfaceMapping : ValueType {
    public Type TargetType;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
public class System.Reflection.LocalVariableInfo : object {
    public Type LocalType { get; }
    public int LocalIndex { get; }
    public bool IsPinned { get; }
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public virtual bool get_IsPinned();
    public virtual string ToString();
}
public class System.Reflection.ManifestResourceInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <ReferencedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceLocation <ResourceLocation>k__BackingField;
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    [CompilerGeneratedAttribute]
public virtual Assembly get_ReferencedAssembly();
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
public virtual ResourceLocation get_ResourceLocation();
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsAbstract { get; }
    public bool IsConstructor { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public MethodBase MetadataDefinitionMethod { get; }
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodBody GetMethodBody();
    public virtual CallingConventions get_CallingConvention();
    public bool get_IsAbstract();
    public bool get_IsConstructor();
    public bool get_IsFinal();
    public bool get_IsHideBySig();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    [IntrinsicAttribute]
public static MethodBase GetCurrentMethod();
    [__BlockReflectionAttribute]
public virtual ParameterInfo[] GetParametersNoCopy();
    [__BlockReflectionAttribute]
public virtual MethodBase get_MetadataDefinitionMethod();
}
public class System.Reflection.MethodBody : object {
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
}
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public int GenericParameterCount { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodInfo GetBaseDefinition();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    public static bool op_Inequality(MethodInfo left, MethodInfo right);
    [__BlockReflectionAttribute]
public virtual int get_GenericParameterCount();
}
public class System.Reflection.Missing : object {
    public static Missing Value;
    private static Missing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Reflection.MissingMetadataException : TypeAccessException {
    [__BlockReflectionAttribute]
public MissingMetadataException(string message);
}
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    private static BindingFlags DefaultLookup;
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private static Module();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public ModuleHandle get_ModuleHandle();
    [__BlockReflectionAttribute]
protected virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual bool IsResource();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual Type[] GetTypes();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual int get_MetadataToken();
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public virtual string ToString();
    private static bool FilterTypeNameImpl(Type cls, object filterCriteria, StringComparison comparison);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AssemblyIsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    [CompilerGeneratedAttribute]
public bool get_AssemblyIsPrivate();
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
}
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToMembers();
    [CompilerGeneratedAttribute]
public void set_ApplyToMembers(bool value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    protected Type ClassImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    protected string NameImpl;
    protected int PositionImpl;
    private static int MetadataToken_ParamDef;
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_MetadataToken();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    private Void* _ptr;
    private Type _ptrType;
    private Pointer(Void* ptr, Type ptrType);
    public static object Box(Void* ptr, Type type);
    public static Void* Unbox(object ptr);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal Type GetPointerType();
    internal IntPtr GetPointerValue();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual Type get_PropertyType();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public bool get_IsSpecialName();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo get_GetMethod();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo get_SetMethod();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
}
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception[] <LoaderExceptions>k__BackingField;
    public Type[] Types { get; }
    public Exception[] LoaderExceptions { get; }
    public string Message { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    private ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public Exception[] get_LoaderExceptions();
    [__BlockReflectionAttribute]
public virtual string get_Message();
    [__BlockReflectionAttribute]
public virtual string ToString();
    private string CreateString(bool isMessage);
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public abstract class System.Reflection.Runtime.CustomAttributes.RuntimeImplementedCustomAttributeData : CustomAttributeData {
    public Type AttributeType { get; }
    public abstract virtual Type get_AttributeType();
}
[__BlockReflectionAttribute]
public class System.Reflection.RuntimeAssemblyName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PublicKeyOrToken>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public string CultureName { get; }
    public AssemblyNameFlags Flags { get; }
    public Byte[] PublicKeyOrToken { get; }
    public string FullName { get; }
    public RuntimeAssemblyName(string name, Version version, string cultureName, AssemblyNameFlags flags, Byte[] publicKeyOrToken);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public AssemblyNameFlags get_Flags();
    [CompilerGeneratedAttribute]
public Byte[] get_PublicKeyOrToken();
    public sealed virtual bool Equals(RuntimeAssemblyName other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public AssemblyName ToAssemblyName();
    public void CopyToAssemblyName(AssemblyName blank);
    public string get_FullName();
}
internal class System.Reflection.SignatureArrayType : SignatureHasElementType {
    private int _rank;
    private bool _isMultiDim;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureArrayType(SignatureType elementType, int rank, bool isMultiDim);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureByRefType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureByRefType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureConstructedGenericType : SignatureType {
    private Type _genericTypeDefinition;
    private Type[] _genericTypeArguments;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal SignatureConstructedGenericType(Type genericTypeDefinition, Type[] typeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal class System.Reflection.SignatureGenericMethodParameterType : SignatureGenericParameterType {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public string Name { get; }
    internal SignatureGenericMethodParameterType(int position);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual string get_Name();
}
internal abstract class System.Reflection.SignatureGenericParameterType : SignatureType {
    private int _position;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected SignatureGenericParameterType(int position);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public abstract virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal abstract class System.Reflection.SignatureHasElementType : SignatureType {
    private SignatureType _elementType;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected string Suffix { get; }
    protected SignatureHasElementType(SignatureType elementType);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    protected abstract virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public abstract virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
    protected abstract virtual string get_Suffix();
}
internal class System.Reflection.SignaturePointerType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignaturePointerType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal abstract class System.Reflection.SignatureType : Type {
    public bool IsSignatureType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MemberTypes MemberType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    internal SignatureType ElementType { get; }
    public Type UnderlyingSystemType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type BaseType { get; }
    public int MetadataToken { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public Guid GUID { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsEnum { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public sealed virtual bool get_IsSignatureType();
    public abstract virtual bool get_IsTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    public abstract virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public sealed virtual bool get_IsGenericType();
    public abstract virtual bool get_IsGenericTypeDefinition();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_ContainsGenericParameters();
    public sealed virtual MemberTypes get_MemberType();
    public sealed virtual Type MakeArrayType();
    public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakePointerType();
    public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type GetElementType();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetGenericTypeDefinition();
    public abstract virtual Type[] get_GenericTypeArguments();
    public abstract virtual Type[] GetGenericArguments();
    public abstract virtual int get_GenericParameterPosition();
    internal abstract virtual SignatureType get_ElementType();
    public sealed virtual Type get_UnderlyingSystemType();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public sealed virtual string get_FullName();
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string ToString();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual Type get_BaseType();
    public sealed virtual Type[] GetInterfaces();
    public sealed virtual bool IsAssignableFrom(Type c);
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual bool IsEnumDefined(object value);
    public sealed virtual string GetEnumName(object value);
    public sealed virtual String[] GetEnumNames();
    public sealed virtual Type GetEnumUnderlyingType();
    public sealed virtual Array GetEnumValues();
    public sealed virtual Guid get_GUID();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetDefaultMembers();
    public sealed virtual EventInfo[] GetEvents();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Type GetInterface(string name, bool ignoreCase);
    protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual bool IsCOMObjectImpl();
    protected sealed virtual bool IsPrimitiveImpl();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    protected sealed virtual bool IsContextfulImpl();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool IsEquivalentTo(Type other);
    public sealed virtual bool IsInstanceOfType(object o);
    protected sealed virtual bool IsMarshalByRefImpl();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool IsSubclassOf(Type c);
    protected sealed virtual bool IsValueTypeImpl();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
}
[ExtensionAttribute]
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Reflection.SignatureTypeExtensions : object {
    [ExtensionAttribute]
public static bool MatchesParameterTypeExactly(Type pattern, ParameterInfo parameter);
    [ExtensionAttribute]
internal static bool MatchesExactly(SignatureType pattern, Type actual);
    [ExtensionAttribute]
internal static Type TryResolveAgainstGenericMethod(SignatureType signatureType, MethodInfo genericMethod);
    [ExtensionAttribute]
private static Type TryResolve(SignatureType signatureType, Type[] genericMethodParameters);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type, int rank);
    [ExtensionAttribute]
private static Type TryMakeByRefType(Type type);
    [ExtensionAttribute]
private static Type TryMakePointerType(Type type);
    [ExtensionAttribute]
private static Type TryMakeGenericType(Type type, Type[] instantiation);
}
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(FileStream keyPairFile);
    public StrongNameKeyPair(Byte[] keyPairArray);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    protected TargetException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    internal TargetInvocationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    internal TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
}
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsCollectible { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    [__BlockReflectionAttribute]
public virtual bool get_IsCollectible();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.TypeInfo : Type {
    private static BindingFlags DeclaredOnlyLookup;
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<GetDeclaredMethods>d__10")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<get_DeclaredNestedTypes>d__22")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
}
public class System.ResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class System.Resources.ExtensionMethods : object {
    [ExtensionAttribute]
public static Assembly InternalGetSatelliteAssembly(Assembly mainAssembly, string name, CultureInfo culture, Version version, bool throwOnFileNotFound);
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
    private string FindResourceFile(CultureInfo culture, string fileName);
    private ResourceSet CreateResourceSet(string file);
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
    private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture);
    internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    private Stream GetManifestResourceStream(Assembly satellite, string fileName);
    private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name);
    private Assembly GetSatelliteAssembly(CultureInfo lookForCulture);
    private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
    private string GetSatelliteAssemblyName();
    private void HandleSatelliteMissing();
    private void HandleResourceStreamMissing(string fileName);
    internal static bool GetNeutralResourcesLanguageAttribute(Assembly assemblyHandle, String& cultureName, Int16& fallbackLocation);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    private string _cultureName;
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
[AttributeUsageAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private UltimateResourceFallbackLocation <Location>k__BackingField;
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public UltimateResourceFallbackLocation get_Location();
}
internal class System.Resources.ResourceFallbackManager : object {
    private CultureInfo m_startingCulture;
    private CultureInfo m_neutralResourcesCulture;
    private bool m_useParents;
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Resources.ResourceFallbackManager/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
internal class System.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
public class System.Resources.ResourceManager : object {
    [__BlockReflectionAttribute]
protected string BaseNameField;
    private Dictionary`2<string, ResourceSet> _resourceSets;
    private string moduleDir;
    protected Assembly MainAssembly;
    private Type _locationInfo;
    private Type _userResourceSet;
    private CultureInfo _neutralResourcesCulture;
    private CultureNameResourceSetPair _lastUsedResourceCache;
    private bool _ignoreCase;
    private bool UseManifest;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _installedSatelliteInfo;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _checkedConfigFile;
    [OptionalFieldAttribute]
private UltimateResourceFallbackLocation _fallbackLoc;
    [OptionalFieldAttribute]
private Version _satelliteContractVersion;
    [OptionalFieldAttribute]
private bool _lookedForSatelliteContractVersion;
    private IResourceGroveler resourceGroveler;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    private static Type _minResourceSet;
    internal static string ResReaderTypeName;
    internal static string ResSetTypeName;
    internal static string MscorlibName;
    internal static string ResFileExtension;
    internal static int ResFileExtensionLength;
    internal static int DEBUG;
    [ThreadStaticAttribute]
private static int ts_recursionCount;
    private bool _bUsingModernResourceManagement;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    private ResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    private void Init();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    private void CommonAssemblyInit();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    private static void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs);
    protected static Version GetSatelliteContractVersion(Assembly a);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2);
    private void SetAppXConfiguration();
    public virtual string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, CultureInfo culture);
    private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream);
    public UnmanagedMemoryStream GetStream(string name);
    public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    private bool TryLookingForSatellite(CultureInfo lookForCulture);
    private Dictionary`2<string, String[]> GetSatelliteAssembliesFromConfig();
}
public class System.Resources.ResourceReader : object {
    private static int DefaultFileStreamBufferSize;
    private BinaryReader _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    private Int32* _namePositionsPtr;
    private Type[] _typeTable;
    private Int32[] _typeNamePositions;
    private int _numResources;
    private UnmanagedMemoryStream _ums;
    private int _version;
    public ResourceReader(string fileName);
    public ResourceReader(Stream stream);
    internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static int ReadUnalignedI4(Int32* p);
    internal int Read7BitEncodedInt();
    private void SkipInt32();
    private void SkipString();
    private int GetNameHash(int index);
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    private bool CompareStringEqualsName(string name);
    private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    private object _LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private void ReadResources();
    private void _ReadResources();
    private Type FindType(int typeIndex);
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
}
public class System.Resources.ResourceSet : object {
    [__BlockReflectionAttribute]
protected IResourceReader Reader;
    private Dictionary`2<object, object> _table;
    private Dictionary`2<object, object> _caseInsensitiveTable;
    internal ResourceSet(bool junk);
    public ResourceSet(string fileName);
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    private void CommonInit();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private object GetObjectInternal(string name);
    private object GetCaseInsensitiveObjectInternal(string name);
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
public class System.Resources.RuntimeResourceSet : ResourceSet {
    internal static int Version;
    private Dictionary`2<string, ResourceLocator> _resCache;
    private ResourceReader _defaultReader;
    private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable;
    private bool _haveReadFromReader;
    internal RuntimeResourceSet(string fileName);
    internal RuntimeResourceSet(Stream stream);
    [__BlockReflectionAttribute]
protected virtual void Dispose(bool disposing);
    [__BlockReflectionAttribute]
public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    [__BlockReflectionAttribute]
public virtual string GetString(string key);
    [__BlockReflectionAttribute]
public virtual string GetString(string key, bool ignoreCase);
    [__BlockReflectionAttribute]
public virtual object GetObject(string key);
    [__BlockReflectionAttribute]
public virtual object GetObject(string key, bool ignoreCase);
    private object GetObject(string key, bool ignoreCase, bool isString);
    private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<string, ResourceLocator> copyOfCache, bool keyInWrongCase);
}
[AttributeUsageAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
internal static class System.Runtime.CommandLine : object {
    [DebuggerHiddenAttribute]
[NativeCallableAttribute]
public static int InvokeExeMain(IntPtr pfnUserMain);
    [RuntimeExportAttribute("CreateCommandLine")]
public static String[] InternalCreateCommandLine();
    internal static String[] InternalCreateCommandLine(bool includeArg0);
    private static int SegmentCommandLine(Char* pCmdLine, String[] argArray, bool includeArg0);
    private static int ScanArgument0(Char*& psrc, Char[] arg);
    private static int ScanArgument(Char*& psrc, Boolean& inquote, Char[] arg);
}
internal class System.Runtime.CompilerServices.__BlockReflectionActivateAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionInvokeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal static class System.Runtime.CompilerServices.AsyncMethodBuilderCore : object {
    [DebuggerStepThroughAttribute]
internal static void Start(TStateMachine& stateMachine);
    internal static Action GetCompletionAction(Action& cachedMoveNextAction, TStateMachine& stateMachine, Task taskIfDebuggingEnabled);
    private static Action GetCompletionActionHelper(Action& cachedMoveNextAction, Byte& stateMachineAddress, EETypePtr stateMachineType, Task taskIfDebuggingEnabled);
    internal static void SetStateMachine(IAsyncStateMachine stateMachine, Action cachedMoveNextAction);
    internal static void CallOnCompleted(Action continuation, TAwaiter& awaiter);
    internal static void CallUnsafeOnCompleted(Action continuation, TAwaiter& awaiter);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
    [DependencyReductionRootAttribute]
internal static Action TryGetStateMachineForDebugger(Action action);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
internal static class System.Runtime.CompilerServices.AsyncTaskCache : object {
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private static Task`1<VoidTaskResult> s_cachedCompleted;
    private Action m_moveNextAction;
    private Task`1<VoidTaskResult> m_task;
    public Task Task { get; }
    private object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder();
    public static AsyncTaskMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    private void EnsureTaskCreated();
    public Task get_Task();
    public void SetResult();
    public void SetException(Exception exception);
    internal static void SetException(Task task, Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    private object get_ObjectIdForDebugger();
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    private Action m_moveNextAction;
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    private object ObjectIdForDebugger { get; }
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    private void EnsureTaskCreated();
    public Task`1<TResult> get_Task();
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    private object get_ObjectIdForDebugger();
    internal static Task`1<TResult> GetTaskForResult(TResult result);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask Task { get; }
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private AsyncTaskMethodBuilder`1<TResult> _methodBuilder;
    private TResult _result;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask`1<TResult> Task { get; }
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private Action m_moveNextAction;
    private SynchronizationContext m_synchronizationContext;
    private Task m_task;
    internal Task Task { get; }
    private object ObjectIdForDebugger { get; }
    public static AsyncVoidMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    private void NotifySynchronizationContextOfCompletion();
    internal Task get_Task();
    private object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("256")]
internal class System.Runtime.CompilerServices.BoundAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.BoundsCheckingAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[__BlockReflectionAttribute]
public abstract class System.Runtime.CompilerServices.CastableObject : object {
    [DebuggerBrowsableAttribute("0")]
private object _hiddenCacheField;
    private sealed virtual override object System.Runtime.CompilerServices.ICastableObject.CastToInterface(EETypePtr interfaceType, bool produceCastErrorException, Exception& castError);
    protected abstract virtual object CastToInterface(RuntimeTypeHandle interfaceType, bool produceCastErrorException, Exception& castError);
    private sealed virtual override RuntimeTypeHandle System.Runtime.CompilerServices.ICastable.GetImplType(RuntimeTypeHandle interfaceType);
    private sealed virtual override bool System.Runtime.CompilerServices.ICastable.IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
}
[McgIntrinsicsAttribute]
internal static class System.Runtime.CompilerServices.ClassConstructorRunner : object {
    private static Lock s_cctorGlobalLock;
    private static Cctor[][] s_cctorArrays;
    private static int s_cctorArraysCount;
    private static int s_count;
    private static int ManagedThreadIdNone;
    private static int CurrentManagedThreadId { get; }
    [RuntimeExportAttribute("CheckStaticClassConstruction")]
public static Void* CheckStaticClassConstruction(Void* returnValue, StaticClassConstructionContext* pContext);
    public static void EnsureClassConstructorRun(StaticClassConstructionContext* pContext);
    private static bool DeadlockAwareAcquire(CctorHandle cctor, IntPtr pfnCctor);
    internal static void Initialize();
    [ConditionalAttribute("ENABLE_NOISY_CCTOR_LOG")]
private static void NoisyLog(string format, IntPtr cctorMethod, int threadId);
    [ConditionalAttribute("DEBUG")]
private static void DebugLog(string format, IntPtr cctorMethod, int threadId);
    private static void Call(IntPtr pfn);
    private static int get_CurrentManagedThreadId();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <CompilationRelaxations>k__BackingField;
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    [CompilerGeneratedAttribute]
public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    private static int InitialCapacity;
    private Lock _lock;
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private int _activeEnumeratorRefCount;
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    private TValue GetValueLocked(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public TValue GetOrCreateValue(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CreateEntry(TKey key, TValue value);
    private static bool IsPowerOfTwo(int value);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable(Task task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1<TResult> value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
public static class System.Runtime.CompilerServices.ContractHelper : object {
    private static EventHandler`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_contractFailedEvent;
    private static object s_lockObject;
    internal static int COR_E_CODECONTRACTFAILED;
    private static ContractHelper();
    internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    private static string GetFailureMessage(ContractFailureKind failureKind, string conditionText);
    private static string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText);
    [DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
private static void RaiseContractFailedEventImplementation(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException, String& resultFailureMessage);
    [DebuggerNonUserCodeAttribute]
private static void TriggerFailureImplementation(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    private DateTime _date;
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    private decimal _dec;
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DependentAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public string get_DependentAssembly();
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("12")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.DependencyReductionConditionallyDependentAttribute : Attribute {
    public DependencyReductionConditionallyDependentAttribute(Type dependencyType);
}
[AttributeUsageAttribute("1132")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.DependencyReductionRootAttribute : Attribute {
}
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.DependencyReductionTypeRemoved : object {
}
internal class System.Runtime.CompilerServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    public object GetPrimary();
    public object GetPrimaryAndSecondary(Object& secondary);
    public void SetPrimary(object primary);
    public void SetSecondary(object secondary);
    public void Free();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("12")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.EagerStaticClassConstructionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.ElemTypeAttribute : Attribute {
    public ElemTypeAttribute(Type elemType);
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("12")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.FakeElementAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.FeatureRemovedException : Exception {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    public string FeatureName { get; }
    public string Message { get; }
    public FeatureRemovedException(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    public virtual string get_Message();
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.FieldAddrFixupAttribute : Attribute {
    public FieldAddrFixupAttribute(int offset, Type containerType, string fieldName);
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Length();
}
[AttributeUsageAttribute("12")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.ForceDictionaryLookupsAttribute : Attribute {
}
[DependencyReductionRootAttribute]
[AttributeUsageAttribute("5212")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.ForceLazyDictionaryAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] arguments);
}
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
[__BlockReflectionAttribute]
public interface System.Runtime.CompilerServices.ICastable {
    public abstract virtual bool IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    public abstract virtual RuntimeTypeHandle GetImplType(RuntimeTypeHandle interfaceType);
}
internal interface System.Runtime.CompilerServices.ICastableObject {
    public abstract virtual object CastToInterface(EETypePtr interfaceType, bool produceCastErrorException, Exception& castError);
}
internal interface System.Runtime.CompilerServices.IConfiguredTaskAwaiter {
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("100")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.ILTransformInjectedAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.InitDataBlobAttribute : Attribute {
    public InitDataBlobAttribute(Type containerType, string rvaFieldName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllInternalsVisible>k__BackingField;
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public bool get_AllInternalsVisible();
    [CompilerGeneratedAttribute]
public void set_AllInternalsVisible(bool value);
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
internal interface System.Runtime.CompilerServices.ITaskAwaiter {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.MethodAddrFixupAttribute : Attribute {
    public MethodAddrFixupAttribute(int offset, Type containerType, string methodName);
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    [CompilerGeneratedAttribute]
private MethodImplOptions <Value>k__BackingField;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    [CompilerGeneratedAttribute]
public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions InternalCall;
}
[AttributeUsageAttribute("1")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.NetNativeToolsVersionAttribute : Attribute {
    public NetNativeToolsVersionAttribute(string netNativeToolsVersion);
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.NonArrayAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.PreInitializedAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("5148")]
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.ReflectionBlockedAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WrapNonExceptionThrows>k__BackingField;
    public bool WrapNonExceptionThrows { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WrapNonExceptionThrows();
    [CompilerGeneratedAttribute]
public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string PortablePdb;
    public static bool IsSupported(string feature);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    [ThreadStaticAttribute]
private static int t_hashSeed;
    [ThreadStaticAttribute]
private static Byte* t_sufficientStackLimit;
    public static int OffsetToStringData { get; }
    [IntrinsicAttribute]
public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static void RunClassConstructor(RuntimeTypeHandle type);
    public static void RunModuleConstructor(ModuleHandle module);
    public static object GetObjectValue(object obj);
    public static bool Equals(object o1, object o2);
    internal static int GetNewHashCode();
    public static int GetHashCode(object o);
    public static int get_OffsetToStringData();
    public static void EnsureSufficientExecutionStack();
    public static bool TryEnsureSufficientExecutionStack();
    private static Byte* GetSufficientStackLimit();
    [IntrinsicAttribute]
public static bool IsReferenceOrContainsReferences();
    [IntrinsicAttribute]
[__BlockReflectionAttribute]
public static bool IsReference();
    public static void ProbeForSufficientStack();
    public static void PrepareConstrainedRegions();
    public static void PrepareConstrainedRegionsNoOP();
    public static void PrepareMethod(RuntimeMethodHandle method);
    public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareDelegate(Delegate d);
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    public static object GetUninitializedObject(Type type);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    private object _wrappedException;
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    private RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <StateMachineType>k__BackingField;
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.StaticClassConstructionContext : ValueType {
    public IntPtr cctorMethodAddress;
    public Int32 modreq(System.Runtime.CompilerServices.IsVolatile) initialized;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    internal Task m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter(Task task);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public void GetResult();
    [StackTraceHiddenAttribute]
internal static void ValidateEnd(Task task);
    [StackTraceHiddenAttribute]
private static void HandleNonSuccessAndDebuggerNotification(Task task);
    [StackTraceHiddenAttribute]
private static void ThrowForNonSuccess(Task task);
    internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
    private static Action OutputWaitEtwEvents(Task task, Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter`1(Task`1<TResult> task);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public TResult GetResult();
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("11148")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Destination>k__BackingField;
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    [CompilerGeneratedAttribute]
public Type get_Destination();
}
[AttributeUsageAttribute("256")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.TypeHandleFixupAttribute : Attribute {
    public TypeHandleFixupAttribute(int offset, Type type);
    public TypeHandleFixupAttribute(int offset, string typeName);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1<TResult> value);
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Consistency <ConsistencyGuarantee>k__BackingField;
    [CompilerGeneratedAttribute]
private Cer <Cer>k__BackingField;
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    [CompilerGeneratedAttribute]
public Consistency get_ConsistencyGuarantee();
    [CompilerGeneratedAttribute]
public Cer get_Cer();
}
[__BlockReflectionAttribute]
public enum System.Runtime.ExceptionIDs : Enum {
    public int value__;
    public static ExceptionIDs OutOfMemory;
    public static ExceptionIDs Arithmetic;
    public static ExceptionIDs ArrayTypeMismatch;
    public static ExceptionIDs DivideByZero;
    public static ExceptionIDs IndexOutOfRange;
    public static ExceptionIDs InvalidCast;
    public static ExceptionIDs Overflow;
    public static ExceptionIDs NullReference;
    public static ExceptionIDs AccessViolation;
    public static ExceptionIDs DataMisaligned;
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    private Exception _exception;
    private EdiCaptureState _ediCaptureState;
    public Exception SourceException { get; }
    private ExceptionDispatchInfo(Exception exception);
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    [StackTraceHiddenAttribute]
public void Throw();
    public static void Throw(Exception source);
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
internal static class System.Runtime.FinalizerInitRunner : object {
    [RuntimeExportAttribute("InitializeFinalizerThread")]
public static void DoInitialize();
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static bool IsServerGC { get; }
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
    public static bool get_IsServerGC();
}
[McgIntrinsicsAttribute]
internal static class System.Runtime.InteropServices.AddrofIntrinsics : object {
    internal static IntPtr AddrOf(T ftn);
}
[AttributeUsageAttribute("1037")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <BestFitMapping>k__BackingField;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    [CompilerGeneratedAttribute]
public bool get_BestFitMapping();
}
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    [CompilerGeneratedAttribute]
public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private bool _isClosed;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    protected virtual override void Finalize();
    private void Cleanup();
    protected void SetHandle(IntPtr handle);
    internal void SetHandleInternal(IntPtr handle);
    internal IntPtr GetHandleInternal();
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CharSet <CharSet>k__BackingField;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    [CompilerGeneratedAttribute]
public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DllImportSearchPath <Paths>k__BackingField;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    [CompilerGeneratedAttribute]
public DllImportSearchPath get_Paths();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool PreserveSig;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    public DllImportAttribute(string dllName);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    [CompilerGeneratedAttribute]
public int get_Value();
}
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private static GCHandleType MaxHandleType;
    private IntPtr _handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    internal GCHandle(object value, GCHandleType type);
    internal GCHandle(IntPtr handle);
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public void Free();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public bool get_IsAllocated();
    public static GCHandle op_Explicit(IntPtr value);
    public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static IntPtr ToIntPtr(GCHandle value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    internal IntPtr GetHandleValue();
    internal bool IsPinned();
    internal void SetIsPinned();
    private static void GCHandleValidatePinnedObject(object obj);
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("5149")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public GuidAttribute(string guid);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.HandleRef : ValueType {
    private object _wrapper;
    private IntPtr _handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
}
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.InteropExtensions : object {
    internal static int RefCountedHandleType;
    public static double ToNativeOleDate(DateTime dateTime);
    public static DateTime FromNativeOleDate(double nativeOleDate);
    public static void InitializeHandle(SafeHandle safeHandle, IntPtr win32Handle);
    public static void PinObjectAndCall(object obj, Action`1<IntPtr> del);
    [ExtensionAttribute]
public static int GetElementSize(Array array);
    [ExtensionAttribute]
internal static bool MightBeBlittable(EETypePtr eeType);
    [ExtensionAttribute]
public static bool IsBlittable(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsBlittable(object obj);
    [ExtensionAttribute]
public static bool IsGenericType(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static int GetGenericArgumentCount(RuntimeTypeHandle genericTypeDefinitionHandle);
    [ExtensionAttribute]
public static IntPtr GetNativeFunctionPointer(Delegate del);
    [ExtensionAttribute]
public static IntPtr GetFunctionPointer(Delegate del, RuntimeTypeHandle& typeOfFirstParameterIfInstanceDelegate);
    [ExtensionAttribute]
public static IntPtr GetRawFunctionPointerForOpenStaticDelegate(Delegate del);
    [ExtensionAttribute]
public static IntPtr GetRawValue(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsOfType(object obj, RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle handle);
    public static Type GetTypeFromHandle(IntPtr typeHandle);
    public static Type GetTypeFromHandle(RuntimeTypeHandle typeHandle);
    [ExtensionAttribute]
public static int GetValueTypeSize(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsValueType(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsClass(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsEnum(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsInterface(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsPrimitive(RuntimeTypeHandle handle);
    [ExtensionAttribute]
public static bool IsDelegate(RuntimeTypeHandle handle);
    public static bool AreTypesAssignable(RuntimeTypeHandle sourceType, RuntimeTypeHandle targetType);
    public static void Memcpy(IntPtr destination, IntPtr source, int bytesToCopy);
    public static bool RuntimeRegisterGcCalloutForGCStart(IntPtr pCalloutMethod);
    public static bool RuntimeRegisterGcCalloutForGCEnd(IntPtr pCalloutMethod);
    public static bool RuntimeRegisterGcCalloutForAfterMarkPhase(IntPtr pCalloutMethod);
    public static bool RuntimeRegisterRefCountedHandleCallback(IntPtr pCalloutMethod, RuntimeTypeHandle pTypeFilter);
    public static void RuntimeUnregisterRefCountedHandleCallback(IntPtr pCalloutMethod, RuntimeTypeHandle pTypeFilter);
    public static IntPtr RuntimeHandleAllocRefCounted(object value);
    public static void RuntimeHandleSet(IntPtr handle, object value);
    public static void RuntimeHandleFree(IntPtr handle);
    public static IntPtr RuntimeHandleAllocDependent(object primary, object secondary);
    public static bool RuntimeIsPromoted(object obj);
    public static void RuntimeHandleSetDependentSecondary(IntPtr handle, object secondary);
    public static T UncheckedCast(object obj);
    public static bool IsArray(RuntimeTypeHandle type);
    public static RuntimeTypeHandle GetArrayElementType(RuntimeTypeHandle arrayType);
    public static bool IsSzArray(RuntimeTypeHandle type);
    [ExtensionAttribute]
public static RuntimeTypeHandle GetTypeHandle(object target);
    public static bool IsInstanceOf(object obj, RuntimeTypeHandle typeHandle);
    public static bool IsInstanceOfClass(object obj, RuntimeTypeHandle classTypeHandle);
    public static bool IsInstanceOfInterface(object obj, RuntimeTypeHandle interfaceTypeHandle);
    public static bool GuidEquals(Guid& left, Guid& right);
    public static bool ComparerEquals(T left, T right);
    public static object RuntimeNewObject(RuntimeTypeHandle typeHnd);
    [ExtensionAttribute]
public static void UnsafeCopyTo(StringBuilder stringBuilder, Char* destination);
    [ExtensionAttribute]
public static void ReplaceBuffer(StringBuilder stringBuilder, Char* newBuffer);
    [ExtensionAttribute]
public static void ReplaceBuffer(StringBuilder stringBuilder, Char[] newBuffer);
    [ExtensionAttribute]
public static Char[] GetBuffer(StringBuilder stringBuilder, Int32& len);
    public static IntPtr RuntimeHandleAllocVariable(object value, UInt32 type);
    public static UInt32 RuntimeHandleGetVariableType(IntPtr handle);
    public static void RuntimeHandleSetVariableType(IntPtr handle, UInt32 type);
    public static UInt32 RuntimeHandleCompareExchangeVariableType(IntPtr handle, UInt32 oldType, UInt32 newType);
    public static void SetExceptionErrorCode(Exception exception, int hr);
    public static void SetExceptionMessage(Exception exception, string message);
    public static Exception CreateDataMisalignedException(string message);
    public static Delegate CreateDelegate(RuntimeTypeHandle typeHandleForDelegate, IntPtr ldftnResult, object thisObject, bool isStatic, bool isVirtual, bool isOpen);
    public static void AddExceptionDataForRestrictedErrorInfo(Exception ex, string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject);
    public static bool TryGetRestrictedErrorObject(Exception ex, Object& restrictedErrorObject);
    public static bool TryGetRestrictedErrorDetails(Exception ex, String& restrictedError, String& restrictedErrorReference, String& restrictedCapabilitySid);
    public static IntPtr[] ExceptionGetStackIPs(Exception ex);
    public static TypeInitializationException CreateTypeInitializationException(string message);
    public static IntPtr GetObjectID(object obj);
    public static bool RhpETWShouldWalkCom();
    public static void RhpETWLogLiveCom(int eventType, IntPtr CCWHandle, IntPtr objectID, IntPtr typeRawValue, IntPtr IUnknown, IntPtr VTable, int comRefCount, int jupiterRefCount, int flags);
    [ExtensionAttribute]
public static bool SupportsReflection(Type type);
    public static void SuppressReentrantWaits();
    public static void RestoreReentrantWaits();
    public static IntPtr GetCriticalHandle(CriticalHandle criticalHandle);
    public static void SetCriticalHandle(CriticalHandle criticalHandle, IntPtr handle);
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
internal class System.Runtime.InteropServices.Marshal : object {
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr);
    public static int GetLastWin32Error();
    public static int GetHRForLastWin32Error();
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static IntPtr AllocHGlobal(int cb);
    public static void FreeHGlobal(IntPtr hglobal);
    public static IntPtr AllocCoTaskMem(int cb);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void ThrowExceptionForHR(int errorCode);
}
[AttributeUsageAttribute("10496")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UnmanagedType <Value>k__BackingField;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int IidParameterIndex;
    public UnmanagedType ArraySubType;
    public short SizeParamIndex;
    public int SizeConst;
    public string MarshalType;
    public Type MarshalTypeRef;
    public string MarshalCookie;
    public UnmanagedType Value { get; }
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public MarshalAsAttribute(short unmanagedType);
    [CompilerGeneratedAttribute]
public UnmanagedType get_Value();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgGeneratedNativeCallCodeAttribute : Attribute {
}
[AttributeUsageAttribute("68")]
internal class System.Runtime.InteropServices.McgIntrinsicsAttribute : Attribute {
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static T& GetReference(Span`1<T> span);
    public static T& GetReference(ReadOnlySpan`1<T> span);
    internal static T& GetNonNullPinnableReference(Span`1<T> span);
    internal static T& GetNonNullPinnableReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    public static Span`1<T> CreateSpan(T& reference, int length);
    public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
    public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__14`1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    [__BlockReflectionAttribute]
public static T& AsRef(Span`1<byte> span);
    [__BlockReflectionAttribute]
public static T& modreq(System.Runtime.InteropServices.InAttribute) AsRef(ReadOnlySpan`1<byte> span);
    public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
}
[AttributeUsageAttribute("64")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
    public CallingConvention CallingConvention;
    public string EntryPoint;
}
[__BlockReflectionAttribute]
public abstract class System.Runtime.InteropServices.NativeFunctionPointerWrapper : object {
    private IntPtr m_nativeFunctionPointer;
    public IntPtr NativeFunctionPointer { get; }
    public NativeFunctionPointerWrapper(IntPtr nativeFunctionPointer);
    public IntPtr get_NativeFunctionPointer();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.PInvokeMarshal : object {
    [ThreadStaticAttribute]
internal static int s_lastWin32Error;
    private static object s_thunkPoolHeap;
    private static ConditionalWeakTable`2<Delegate, PInvokeDelegateThunk> s_pInvokeDelegates;
    private static CreateValueCallback<Delegate, PInvokeDelegateThunk> s_AllocateThunk;
    private static long HIWORDMASK;
    public static int GetLastWin32Error();
    public static void SetLastWin32Error(int errorCode);
    public static int GetHRForLastWin32Error();
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static IntPtr AllocHGlobal(int cb);
    public static void FreeHGlobal(IntPtr hglobal);
    public static IntPtr AllocCoTaskMem(int cb);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static void CopyToManaged(IntPtr source, Array destination, int startIndex, int length);
    public static void CopyToNative(Array source, int startIndex, IntPtr destination, int length);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr GetFunctionPointerForDelegate(Delegate del);
    private static ConditionalWeakTable`2<Delegate, PInvokeDelegateThunk> GetPInvokeDelegates();
    private static PInvokeDelegateThunk AllocateThunk(Delegate del);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, RuntimeTypeHandle delegateType);
    public static IntPtr GetCurrentCalleeOpenStaticDelegateFunctionPointer();
    public static T GetCurrentCalleeDelegate();
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr);
    public static void StringBuilderToUnicodeString(StringBuilder stringBuilder, UInt16* destination);
    public static void UnicodeStringToStringBuilder(UInt16* newBuffer, StringBuilder stringBuilder);
    public static void StringBuilderToAnsiString(StringBuilder stringBuilder, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    public static void AnsiStringToStringBuilder(Byte* newBuffer, StringBuilder stringBuilder);
    public static string AnsiStringToString(Byte* pchBuffer);
    public static Byte* StringToAnsiString(string str, bool bestFit, bool throwOnUnmappableChar);
    public static void ByValWideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, int expectedCharCount, bool bestFit, bool throwOnUnmappableChar);
    public static void ByValAnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    public static void WideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    public static void AnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    public static byte WideCharToAnsiChar(char managedValue, bool bestFit, bool throwOnUnmappableChar);
    public static char AnsiCharToWideChar(byte nativeValue);
    public static void StringToByValAnsiString(string str, Byte* pNative, int charCount, bool bestFit, bool throwOnUnmappableChar, bool truncate);
    public static string ByValAnsiStringToString(Byte* pchBuffer, int charCount);
    private static int GetAnsiStringLen(Byte* pchBuffer);
    private static Byte* StringToAnsiString(Char* pManaged, int lenUnicode, Byte* pNative, bool terminateWithNull, bool bestFit, bool throwOnUnmappableChar);
    private static bool CalculateStringLength(Byte* pchBuffer, Int32& ansiBufferLen, Int32& unicodeBufferLen);
    private static bool IsWin32Atom(IntPtr ptr);
    private static bool IsNotWin32Atom(IntPtr ptr);
    public static void SaveLastWin32Error();
    public static void ClearLastWin32Error();
    public static IntPtr MemAlloc(IntPtr cb);
    public static void MemFree(IntPtr hglobal);
    public static IntPtr MemReAlloc(IntPtr pv, IntPtr cb);
    public static IntPtr CoTaskMemAlloc(UIntPtr bytes);
    public static void CoTaskMemFree(IntPtr allocatedMemory);
    public static IntPtr CoTaskMemReAlloc(IntPtr pv, IntPtr cb);
    public static IntPtr SecureStringToBSTR(SecureString s);
    internal static IntPtr AllocBSTR(int length);
    internal static void FreeBSTR(IntPtr ptr);
    public static int ConvertMultiByteToWideChar(Byte* buffer, int ansiLength, Char* pWChar, int uniLength);
    public static int ConvertWideCharToMultiByte(Char* wideCharStr, int wideCharLen, Byte* multiByteStr, int multiByteLen);
    public static int ConvertWideCharToMultiByte(Char* wideCharStr, int wideCharLen, Byte* multiByteStr, int multiByteLen, bool bestFit, bool throwOnUnmappableChar);
    public static int GetByteCount(Char* wStr, int wideStrLen);
    public static int GetCharCount(Byte* multiByteStr, int multiByteLen);
    public static int GetSystemMaxDBCSCharSize();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    private static UIntPtr Uninitialized;
    private UIntPtr _numBytes;
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static SafeBuffer();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    public ulong get_ByteLength();
    private void SpaceCheck(Byte* ptr, ulong sizeInBytes);
    private static void NotEnoughRoom();
    private static InvalidOperationException NotInitialized();
    internal static UInt32 AlignedSizeOf();
    internal static UInt32 SizeOf();
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private int _state;
    private bool _ownsHandle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual override void Finalize();
    protected void SetHandle(IntPtr handle);
    internal void InitializeHandle(IntPtr _handle);
    public IntPtr DangerousGetHandle();
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
    public void DangerousAddRef(Boolean& success);
    public void DangerousRelease();
    internal void DangerousAddRef_WithNoNullCheck();
    private void InternalRelease(bool fDispose);
}
[ExtensionAttribute]
internal static class System.Runtime.InteropServices.SafeHandleExtensions : object {
    [ExtensionAttribute]
public static void DangerousAddRef(SafeHandle safeHandle);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LayoutKind <Value>k__BackingField;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    [CompilerGeneratedAttribute]
public LayoutKind get_Value();
}
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CallingConvention <CallingConvention>k__BackingField;
    public bool BestFitMapping;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public CharSet CharSet;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public CallingConvention get_CallingConvention();
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    public static UnmanagedType IDispatch;
    public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    public static UnmanagedType VBByRefStr;
    public static UnmanagedType AnsiBStr;
    public static UnmanagedType TBStr;
    public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType IInspectable;
    public static UnmanagedType HString;
    public static UnmanagedType LPUTF8Str;
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.UnsafeGCHandle : ValueType {
    private static GCHandleType MaxHandleType;
    private IntPtr _handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    private UnsafeGCHandle(object value, GCHandleType type);
    public static UnsafeGCHandle Alloc(object value, GCHandleType type);
    public object get_Target();
    public void set_Target(object value);
    public void Free();
    public IntPtr GetRawTargetAddress();
    public bool get_IsAllocated();
}
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken : ValueType {
    internal long m_value;
    public long Value { get; }
    [__BlockReflectionAttribute]
public EventRegistrationToken(long value);
    [__BlockReflectionAttribute]
public long get_Value();
    public static bool op_Equality(EventRegistrationToken left, EventRegistrationToken right);
    public static bool op_Inequality(EventRegistrationToken left, EventRegistrationToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool System.IEquatable<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken>.Equals(EventRegistrationToken other);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.Intrinsics.Arm.Arm64.Aes : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> MixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.Intrinsics.Arm.Arm64.Base : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static int LeadingSignCount(int value);
    public static int LeadingSignCount(long value);
    public static int LeadingZeroCount(int value);
    public static int LeadingZeroCount(UInt32 value);
    public static int LeadingZeroCount(long value);
    public static int LeadingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.Intrinsics.Arm.Arm64.Sha1 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashChoose(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashMajority(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashParity(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static UInt32 FixedRotate(UInt32 hash_e);
    public static Vector128`1<UInt32> SchedulePart1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7, Vector128`1<UInt32> w8_11);
    public static Vector128`1<UInt32> SchedulePart2(Vector128`1<UInt32> tw0_3, Vector128`1<UInt32> w12_15);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.Intrinsics.Arm.Arm64.Sha256 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashLower(Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashUpper(Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> SchedulePart1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7);
    public static Vector128`1<UInt32> SchedulePart2(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w8_11, Vector128`1<UInt32> w12_15);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.Intrinsics.Arm.Arm64.Simd : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector64`1<byte> Abs(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> Abs(Vector64`1<short> value);
    public static Vector64`1<UInt32> Abs(Vector64`1<int> value);
    public static Vector64`1<float> Abs(Vector64`1<float> value);
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<ulong> Abs(Vector128`1<long> value);
    public static Vector128`1<float> Abs(Vector128`1<float> value);
    public static Vector128`1<double> Abs(Vector128`1<double> value);
    public static Vector64`1<T> Add(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Add(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> And(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> And(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> AndNot(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> AndNot(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> BitwiseSelect(Vector64`1<T> sel, Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> BitwiseSelect(Vector128`1<T> sel, Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareEqual(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareEqual(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareGreaterThan(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareGreaterThan(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareGreaterThanZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareGreaterThanZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareGreaterThanOrEqual(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareGreaterThanOrEqual(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareGreaterThanOrEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareGreaterThanOrEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareLessThanZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareLessThanZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareLessThanOrEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareLessThanOrEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareTest(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareTest(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<float> Divide(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static T Extract(Vector64`1<T> vector, byte index);
    public static T Extract(Vector128`1<T> vector, byte index);
    public static Vector64`1<T> Insert(Vector64`1<T> vector, byte index, T data);
    public static Vector128`1<T> Insert(Vector128`1<T> vector, byte index, T data);
    public static Vector64`1<sbyte> LeadingSignCount(Vector64`1<sbyte> value);
    public static Vector64`1<short> LeadingSignCount(Vector64`1<short> value);
    public static Vector64`1<int> LeadingSignCount(Vector64`1<int> value);
    public static Vector128`1<sbyte> LeadingSignCount(Vector128`1<sbyte> value);
    public static Vector128`1<short> LeadingSignCount(Vector128`1<short> value);
    public static Vector128`1<int> LeadingSignCount(Vector128`1<int> value);
    public static Vector64`1<byte> LeadingZeroCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> LeadingZeroCount(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> LeadingZeroCount(Vector64`1<ushort> value);
    public static Vector64`1<short> LeadingZeroCount(Vector64`1<short> value);
    public static Vector64`1<UInt32> LeadingZeroCount(Vector64`1<UInt32> value);
    public static Vector64`1<int> LeadingZeroCount(Vector64`1<int> value);
    public static Vector128`1<byte> LeadingZeroCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> LeadingZeroCount(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> LeadingZeroCount(Vector128`1<ushort> value);
    public static Vector128`1<short> LeadingZeroCount(Vector128`1<short> value);
    public static Vector128`1<UInt32> LeadingZeroCount(Vector128`1<UInt32> value);
    public static Vector128`1<int> LeadingZeroCount(Vector128`1<int> value);
    public static Vector64`1<byte> Max(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Max(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Max(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Max(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Max(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Max(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Max(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<byte> Min(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Min(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Min(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Min(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Min(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Min(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Min(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<byte> Multiply(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Multiply(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Multiply(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Multiply(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Multiply(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Multiply(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Multiply(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Multiply(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Multiply(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Multiply(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Multiply(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<sbyte> Negate(Vector64`1<sbyte> value);
    public static Vector64`1<short> Negate(Vector64`1<short> value);
    public static Vector64`1<int> Negate(Vector64`1<int> value);
    public static Vector64`1<float> Negate(Vector64`1<float> value);
    public static Vector128`1<sbyte> Negate(Vector128`1<sbyte> value);
    public static Vector128`1<short> Negate(Vector128`1<short> value);
    public static Vector128`1<int> Negate(Vector128`1<int> value);
    public static Vector128`1<long> Negate(Vector128`1<long> value);
    public static Vector128`1<float> Negate(Vector128`1<float> value);
    public static Vector128`1<double> Negate(Vector128`1<double> value);
    public static Vector64`1<T> Not(Vector64`1<T> value);
    public static Vector128`1<T> Not(Vector128`1<T> value);
    public static Vector64`1<T> Or(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Or(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> OrNot(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> OrNot(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<byte> PopCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> PopCount(Vector64`1<sbyte> value);
    public static Vector128`1<byte> PopCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> PopCount(Vector128`1<sbyte> value);
    public static Vector64`1<T> SetAllVector64(T value);
    public static Vector128`1<T> SetAllVector128(T value);
    public static Vector64`1<float> Sqrt(Vector64`1<float> value);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector64`1<T> Subtract(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Subtract(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> Xor(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Xor(Vector128`1<T> left, Vector128`1<T> right);
}
[IsReadOnlyAttribute]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector128DebugView`1")]
[__BlockReflectionAttribute]
public class System.Runtime.Intrinsics.Vector128`1 : ValueType {
    private ulong _00;
    private ulong _01;
    private string DisplayString { get; }
    private string get_DisplayString();
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector128DebugView`1 : ValueType {
    private Vector128`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector128DebugView`1(Vector128`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[IsReadOnlyAttribute]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector256DebugView`1")]
[__BlockReflectionAttribute]
public class System.Runtime.Intrinsics.Vector256`1 : ValueType {
    private ulong _00;
    private ulong _01;
    private ulong _02;
    private ulong _03;
    private string DisplayString { get; }
    private string get_DisplayString();
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector256DebugView`1 : ValueType {
    private Vector256`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector256DebugView`1(Vector256`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[IsReadOnlyAttribute]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector64DebugView`1")]
[__BlockReflectionAttribute]
public class System.Runtime.Intrinsics.Vector64`1 : ValueType {
    private ulong _00;
    private string DisplayString { get; }
    private string get_DisplayString();
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector64DebugView`1 : ValueType {
    private Vector64`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector64DebugView`1(Vector64`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Aes : Sse2 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> DecryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> EncryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> KeygenAssist(Vector128`1<byte> value, byte control);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Avx : Sse42 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector256`1<float> Add(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Add(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AddSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AddSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> And(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> And(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AndNot(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AndNot(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Blend(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Blend(Vector256`1<double> left, Vector256`1<double> right, byte control);
    public static Vector256`1<float> BlendVariable(Vector256`1<float> left, Vector256`1<float> right, Vector256`1<float> mask);
    public static Vector256`1<double> BlendVariable(Vector256`1<double> left, Vector256`1<double> right, Vector256`1<double> mask);
    public static Vector128`1<float> BroadcastScalarToVector128(Single* source);
    public static Vector256`1<float> BroadcastScalarToVector256(Single* source);
    public static Vector256`1<double> BroadcastScalarToVector256(Double* source);
    public static Vector256`1<float> BroadcastVector128ToVector256(Single* address);
    public static Vector256`1<double> BroadcastVector128ToVector256(Double* address);
    public static Vector256`1<float> Ceiling(Vector256`1<float> value);
    public static Vector256`1<double> Ceiling(Vector256`1<double> value);
    public static Vector128`1<float> Compare(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static Vector128`1<double> Compare(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector256`1<float> Compare(Vector256`1<float> left, Vector256`1<float> right, FloatComparisonMode mode);
    public static Vector256`1<double> Compare(Vector256`1<double> left, Vector256`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<double> CompareScalar(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<float> CompareScalar(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static float ConvertToSingle(Vector256`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector256`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector256`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector256`1<float> value);
    public static Vector256`1<float> ConvertToVector256Single(Vector256`1<int> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<float> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<int> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector256`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32WithTruncation(Vector256`1<float> value);
    public static Vector256`1<float> Divide(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Divide(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> DotProduct(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<float> DuplicateEvenIndexed(Vector256`1<float> value);
    public static Vector256`1<double> DuplicateEvenIndexed(Vector256`1<double> value);
    public static Vector256`1<float> DuplicateOddIndexed(Vector256`1<float> value);
    public static byte Extract(Vector256`1<byte> value, byte index);
    public static ushort Extract(Vector256`1<ushort> value, byte index);
    public static int Extract(Vector256`1<int> value, byte index);
    public static UInt32 Extract(Vector256`1<UInt32> value, byte index);
    public static long Extract(Vector256`1<long> value, byte index);
    public static ulong Extract(Vector256`1<ulong> value, byte index);
    public static Vector128`1<T> ExtractVector128(Vector256`1<T> value, byte index);
    public static void ExtractVector128(Byte* address, Vector256`1<byte> value, byte index);
    public static void ExtractVector128(SByte* address, Vector256`1<sbyte> value, byte index);
    public static void ExtractVector128(Int16* address, Vector256`1<short> value, byte index);
    public static void ExtractVector128(UInt16* address, Vector256`1<ushort> value, byte index);
    public static void ExtractVector128(Int32* address, Vector256`1<int> value, byte index);
    public static void ExtractVector128(UInt32* address, Vector256`1<UInt32> value, byte index);
    public static void ExtractVector128(Int64* address, Vector256`1<long> value, byte index);
    public static void ExtractVector128(UInt64* address, Vector256`1<ulong> value, byte index);
    public static void ExtractVector128(Single* address, Vector256`1<float> value, byte index);
    public static void ExtractVector128(Double* address, Vector256`1<double> value, byte index);
    public static Vector256`1<T> ExtendToVector256(Vector128`1<T> value);
    public static Vector256`1<float> Floor(Vector256`1<float> value);
    public static Vector256`1<double> Floor(Vector256`1<double> value);
    public static Vector128`1<T> GetLowerHalf(Vector256`1<T> value);
    public static Vector256`1<float> HorizontalAdd(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalAdd(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> HorizontalSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<sbyte> Insert(Vector256`1<sbyte> value, sbyte data, byte index);
    public static Vector256`1<byte> Insert(Vector256`1<byte> value, byte data, byte index);
    public static Vector256`1<short> Insert(Vector256`1<short> value, short data, byte index);
    public static Vector256`1<ushort> Insert(Vector256`1<ushort> value, ushort data, byte index);
    public static Vector256`1<int> Insert(Vector256`1<int> value, int data, byte index);
    public static Vector256`1<UInt32> Insert(Vector256`1<UInt32> value, UInt32 data, byte index);
    public static Vector256`1<long> Insert(Vector256`1<long> value, long data, byte index);
    public static Vector256`1<ulong> Insert(Vector256`1<ulong> value, ulong data, byte index);
    public static Vector256`1<T> InsertVector128(Vector256`1<T> value, Vector128`1<T> data, byte index);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, SByte* address, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Byte* address, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Int16* address, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, UInt16* address, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Int32* address, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, UInt32* address, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Int64* address, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, UInt64* address, byte index);
    public static Vector256`1<float> InsertVector128(Vector256`1<float> value, Single* address, byte index);
    public static Vector256`1<double> InsertVector128(Vector256`1<double> value, Double* address, byte index);
    public static Vector256`1<sbyte> LoadVector256(SByte* address);
    public static Vector256`1<byte> LoadVector256(Byte* address);
    public static Vector256`1<short> LoadVector256(Int16* address);
    public static Vector256`1<ushort> LoadVector256(UInt16* address);
    public static Vector256`1<int> LoadVector256(Int32* address);
    public static Vector256`1<UInt32> LoadVector256(UInt32* address);
    public static Vector256`1<long> LoadVector256(Int64* address);
    public static Vector256`1<ulong> LoadVector256(UInt64* address);
    public static Vector256`1<float> LoadVector256(Single* address);
    public static Vector256`1<double> LoadVector256(Double* address);
    public static Vector256`1<sbyte> LoadAlignedVector256(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256(UInt64* address);
    public static Vector256`1<float> LoadAlignedVector256(Single* address);
    public static Vector256`1<double> LoadAlignedVector256(Double* address);
    public static Vector256`1<sbyte> LoadDquVector256(SByte* address);
    public static Vector256`1<byte> LoadDquVector256(Byte* address);
    public static Vector256`1<short> LoadDquVector256(Int16* address);
    public static Vector256`1<ushort> LoadDquVector256(UInt16* address);
    public static Vector256`1<int> LoadDquVector256(Int32* address);
    public static Vector256`1<UInt32> LoadDquVector256(UInt32* address);
    public static Vector256`1<long> LoadDquVector256(Int64* address);
    public static Vector256`1<ulong> LoadDquVector256(UInt64* address);
    public static Vector128`1<float> MaskLoad(Single* address, Vector128`1<float> mask);
    public static Vector128`1<double> MaskLoad(Double* address, Vector128`1<double> mask);
    public static Vector256`1<float> MaskLoad(Single* address, Vector256`1<float> mask);
    public static Vector256`1<double> MaskLoad(Double* address, Vector256`1<double> mask);
    public static void MaskStore(Single* address, Vector128`1<float> mask, Vector128`1<float> source);
    public static void MaskStore(Double* address, Vector128`1<double> mask, Vector128`1<double> source);
    public static void MaskStore(Single* address, Vector256`1<float> mask, Vector256`1<float> source);
    public static void MaskStore(Double* address, Vector256`1<double> mask, Vector256`1<double> source);
    public static Vector256`1<float> Max(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Max(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Min(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Min(Vector256`1<double> left, Vector256`1<double> right);
    public static int MoveMask(Vector256`1<float> value);
    public static int MoveMask(Vector256`1<double> value);
    public static Vector256`1<float> Multiply(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Multiply(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Or(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Or(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector128`1<float> Permute(Vector128`1<float> value, byte control);
    public static Vector128`1<double> Permute(Vector128`1<double> value, byte control);
    public static Vector256`1<float> Permute(Vector256`1<float> value, byte control);
    public static Vector256`1<double> Permute(Vector256`1<double> value, byte control);
    public static Vector256`1<T> Permute2x128(Vector256`1<T> left, Vector256`1<T> right, byte control);
    public static Vector128`1<float> PermuteVar(Vector128`1<float> left, Vector128`1<int> control);
    public static Vector128`1<double> PermuteVar(Vector128`1<double> left, Vector128`1<long> control);
    public static Vector256`1<float> PermuteVar(Vector256`1<float> left, Vector256`1<int> control);
    public static Vector256`1<double> PermuteVar(Vector256`1<double> left, Vector256`1<long> control);
    public static Vector256`1<float> Reciprocal(Vector256`1<float> value);
    public static Vector256`1<float> ReciprocalSqrt(Vector256`1<float> value);
    public static Vector256`1<float> RoundToNearestInteger(Vector256`1<float> value);
    public static Vector256`1<float> RoundToNegativeInfinity(Vector256`1<float> value);
    public static Vector256`1<float> RoundToPositiveInfinity(Vector256`1<float> value);
    public static Vector256`1<float> RoundToZero(Vector256`1<float> value);
    public static Vector256`1<float> RoundCurrentDirection(Vector256`1<float> value);
    public static Vector256`1<double> RoundToNearestInteger(Vector256`1<double> value);
    public static Vector256`1<double> RoundToNegativeInfinity(Vector256`1<double> value);
    public static Vector256`1<double> RoundToPositiveInfinity(Vector256`1<double> value);
    public static Vector256`1<double> RoundToZero(Vector256`1<double> value);
    public static Vector256`1<double> RoundCurrentDirection(Vector256`1<double> value);
    public static Vector256`1<sbyte> SetVector256(sbyte e31, sbyte e30, sbyte e29, sbyte e28, sbyte e27, sbyte e26, sbyte e25, sbyte e24, sbyte e23, sbyte e22, sbyte e21, sbyte e20, sbyte e19, sbyte e18, sbyte e17, sbyte e16, sbyte e15, sbyte e14, sbyte e13, sbyte e12, sbyte e11, sbyte e10, sbyte e9, sbyte e8, sbyte e7, sbyte e6, sbyte e5, sbyte e4, sbyte e3, sbyte e2, sbyte e1, sbyte e0);
    public static Vector256`1<byte> SetVector256(byte e31, byte e30, byte e29, byte e28, byte e27, byte e26, byte e25, byte e24, byte e23, byte e22, byte e21, byte e20, byte e19, byte e18, byte e17, byte e16, byte e15, byte e14, byte e13, byte e12, byte e11, byte e10, byte e9, byte e8, byte e7, byte e6, byte e5, byte e4, byte e3, byte e2, byte e1, byte e0);
    public static Vector256`1<short> SetVector256(short e15, short e14, short e13, short e12, short e11, short e10, short e9, short e8, short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0);
    public static Vector256`1<ushort> SetVector256(ushort e15, ushort e14, ushort e13, ushort e12, ushort e11, ushort e10, ushort e9, ushort e8, ushort e7, ushort e6, ushort e5, ushort e4, ushort e3, ushort e2, ushort e1, ushort e0);
    public static Vector256`1<int> SetVector256(int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0);
    public static Vector256`1<UInt32> SetVector256(UInt32 e7, UInt32 e6, UInt32 e5, UInt32 e4, UInt32 e3, UInt32 e2, UInt32 e1, UInt32 e0);
    public static Vector256`1<long> SetVector256(long e3, long e2, long e1, long e0);
    public static Vector256`1<ulong> SetVector256(ulong e3, ulong e2, ulong e1, ulong e0);
    public static Vector256`1<float> SetVector256(float e7, float e6, float e5, float e4, float e3, float e2, float e1, float e0);
    public static Vector256`1<double> SetVector256(double e3, double e2, double e1, double e0);
    public static Vector256`1<T> SetAllVector256(T value);
    public static Vector256`1<T> SetHighLow(Vector128`1<T> hi, Vector128`1<T> lo);
    public static Vector256`1<T> SetZeroVector256();
    public static Vector256`1<float> Shuffle(Vector256`1<float> value, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Shuffle(Vector256`1<double> value, Vector256`1<double> right, byte control);
    public static Vector256`1<float> Sqrt(Vector256`1<float> value);
    public static Vector256`1<double> Sqrt(Vector256`1<double> value);
    public static Vector256`1<U> StaticCast(Vector256`1<T> value);
    public static void StoreAligned(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector256`1<byte> source);
    public static void StoreAligned(Int16* address, Vector256`1<short> source);
    public static void StoreAligned(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector256`1<int> source);
    public static void StoreAligned(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector256`1<long> source);
    public static void StoreAligned(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAligned(Single* address, Vector256`1<float> source);
    public static void StoreAligned(Double* address, Vector256`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector256`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector256`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector256`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector256`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector256`1<float> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector256`1<double> source);
    public static void Store(SByte* address, Vector256`1<sbyte> source);
    public static void Store(Byte* address, Vector256`1<byte> source);
    public static void Store(Int16* address, Vector256`1<short> source);
    public static void Store(UInt16* address, Vector256`1<ushort> source);
    public static void Store(Int32* address, Vector256`1<int> source);
    public static void Store(UInt32* address, Vector256`1<UInt32> source);
    public static void Store(Int64* address, Vector256`1<long> source);
    public static void Store(UInt64* address, Vector256`1<ulong> source);
    public static void Store(Single* address, Vector256`1<float> source);
    public static void Store(Double* address, Vector256`1<double> source);
    public static Vector256`1<float> Subtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Subtract(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestC(Vector256`1<T> left, Vector256`1<T> right);
    public static bool TestNotZAndNotC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestNotZAndNotC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestNotZAndNotC(Vector256`1<T> left, Vector256`1<T> right);
    public static bool TestZ(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestZ(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestZ(Vector256`1<T> left, Vector256`1<T> right);
    public static Vector256`1<float> UnpackHigh(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackHigh(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> UnpackLow(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackLow(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Xor(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Xor(Vector256`1<double> left, Vector256`1<double> right);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Avx2 : Avx {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector256`1<byte> Abs(Vector256`1<sbyte> value);
    public static Vector256`1<ushort> Abs(Vector256`1<short> value);
    public static Vector256`1<UInt32> Abs(Vector256`1<int> value);
    public static Vector256`1<sbyte> Add(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Add(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Add(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Add(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Add(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Add(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Add(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Add(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AddSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AddSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AddSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<sbyte> AlignRight(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte mask);
    public static Vector256`1<sbyte> And(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> And(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> And(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> And(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> And(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> And(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> And(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> And(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AndNot(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AndNot(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AndNot(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AndNot(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> AndNot(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> AndNot(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> AndNot(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> AndNot(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<byte> Average(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> Average(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector128`1<int> Blend(Vector128`1<int> left, Vector128`1<int> right, byte control);
    public static Vector128`1<UInt32> Blend(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte control);
    public static Vector256`1<short> Blend(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Blend(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Blend(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Blend(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<sbyte> BlendVariable(Vector256`1<sbyte> left, Vector256`1<sbyte> right, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> BlendVariable(Vector256`1<byte> left, Vector256`1<byte> right, Vector256`1<byte> mask);
    public static Vector128`1<T> BroadcastScalarToVector128(Vector128`1<T> value);
    public static Vector256`1<T> BroadcastScalarToVector256(Vector128`1<T> value);
    public static Vector256`1<sbyte> BroadcastVector128ToVector256(SByte* address);
    public static Vector256`1<byte> BroadcastVector128ToVector256(Byte* address);
    public static Vector256`1<short> BroadcastVector128ToVector256(Int16* address);
    public static Vector256`1<ushort> BroadcastVector128ToVector256(UInt16* address);
    public static Vector256`1<int> BroadcastVector128ToVector256(Int32* address);
    public static Vector256`1<UInt32> BroadcastVector128ToVector256(UInt32* address);
    public static Vector256`1<long> BroadcastVector128ToVector256(Int64* address);
    public static Vector256`1<ulong> BroadcastVector128ToVector256(UInt64* address);
    public static Vector256`1<sbyte> CompareEqual(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> CompareEqual(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> CompareEqual(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> CompareEqual(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> CompareEqual(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> CompareEqual(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> CompareEqual(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> CompareEqual(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> CompareGreaterThan(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> CompareGreaterThan(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> CompareGreaterThan(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<long> CompareGreaterThan(Vector256`1<long> left, Vector256`1<long> right);
    public static double ConvertToDouble(Vector256`1<double> value);
    public static int ConvertToInt32(Vector256`1<int> value);
    public static UInt32 ConvertToUInt32(Vector256`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector128`1<sbyte> value);
    public static Vector256`1<ushort> ConvertToVector256UInt16(Vector128`1<byte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<sbyte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<short> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector128`1<byte> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector128`1<ushort> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<sbyte> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<short> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<int> value);
    public static Vector256`1<ulong> ConvertToVector256UInt64(Vector128`1<byte> value);
    public static Vector256`1<ulong> ConvertToVector256UInt64(Vector128`1<ushort> value);
    public static Vector256`1<ulong> ConvertToVector256UInt64(Vector128`1<UInt32> value);
    public static Vector128`1<sbyte> ExtractVector128(Vector256`1<sbyte> value, byte index);
    public static void ExtractVector128(SByte* address, Vector256`1<sbyte> value, byte index);
    public static Vector128`1<byte> ExtractVector128(Vector256`1<byte> value, byte index);
    public static void ExtractVector128(Byte* address, Vector256`1<byte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector256`1<short> value, byte index);
    public static void ExtractVector128(Int16* address, Vector256`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector256`1<ushort> value, byte index);
    public static void ExtractVector128(UInt16* address, Vector256`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector256`1<int> value, byte index);
    public static void ExtractVector128(Int32* address, Vector256`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector256`1<UInt32> value, byte index);
    public static void ExtractVector128(UInt32* address, Vector256`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector256`1<long> value, byte index);
    public static void ExtractVector128(Int64* address, Vector256`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector256`1<ulong> value, byte index);
    public static void ExtractVector128(UInt64* address, Vector256`1<ulong> value, byte index);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector256`1<int> GatherVector256(Int32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<UInt32> GatherVector256(UInt32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<float> GatherVector256(Single* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<int> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<int> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<int> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector128`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<long> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<long> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<long> index, Vector128`1<double> mask, byte scale);
    public static Vector256`1<int> GatherMaskVector256(Vector256`1<int> source, Int32* baseAddress, Vector256`1<int> index, Vector256`1<int> mask, byte scale);
    public static Vector256`1<UInt32> GatherMaskVector256(Vector256`1<UInt32> source, UInt32* baseAddress, Vector256`1<int> index, Vector256`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector256`1<ulong> mask, byte scale);
    public static Vector256`1<float> GatherMaskVector256(Vector256`1<float> source, Single* baseAddress, Vector256`1<int> index, Vector256`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector256`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector256`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector256`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector256`1<long> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector256`1<long> index, Vector256`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector256`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector256`1<long> index, Vector256`1<double> mask, byte scale);
    public static Vector256`1<short> HorizontalAdd(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalAdd(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalAddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> HorizontalSubtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalSubtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalSubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, SByte* address, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Byte* address, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Vector128`1<short> data, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Int16* address, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, UInt16* address, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Vector128`1<int> data, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Int32* address, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, UInt32* address, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Vector128`1<long> data, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Int64* address, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, UInt64* address, byte index);
    public static Vector256`1<sbyte> LoadAlignedVector256NonTemporal(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256NonTemporal(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256NonTemporal(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256NonTemporal(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256NonTemporal(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256NonTemporal(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256NonTemporal(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256NonTemporal(UInt64* address);
    public static Vector128`1<int> MaskLoad(Int32* address, Vector128`1<int> mask);
    public static Vector128`1<UInt32> MaskLoad(UInt32* address, Vector128`1<UInt32> mask);
    public static Vector128`1<long> MaskLoad(Int64* address, Vector128`1<long> mask);
    public static Vector128`1<ulong> MaskLoad(UInt64* address, Vector128`1<ulong> mask);
    public static Vector256`1<int> MaskLoad(Int32* address, Vector256`1<int> mask);
    public static Vector256`1<UInt32> MaskLoad(UInt32* address, Vector256`1<UInt32> mask);
    public static Vector256`1<long> MaskLoad(Int64* address, Vector256`1<long> mask);
    public static Vector256`1<ulong> MaskLoad(UInt64* address, Vector256`1<ulong> mask);
    public static void MaskStore(Int32* address, Vector128`1<int> mask, Vector128`1<int> source);
    public static void MaskStore(UInt32* address, Vector128`1<UInt32> mask, Vector128`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector128`1<long> mask, Vector128`1<long> source);
    public static void MaskStore(UInt64* address, Vector128`1<ulong> mask, Vector128`1<ulong> source);
    public static void MaskStore(Int32* address, Vector256`1<int> mask, Vector256`1<int> source);
    public static void MaskStore(UInt32* address, Vector256`1<UInt32> mask, Vector256`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector256`1<long> mask, Vector256`1<long> source);
    public static void MaskStore(UInt64* address, Vector256`1<ulong> mask, Vector256`1<ulong> source);
    public static Vector256`1<int> MultiplyAddAdjacent(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyAddAdjacent(Vector256`1<byte> left, Vector256`1<sbyte> right);
    public static Vector256`1<sbyte> Max(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Max(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Max(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Max(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Max(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Max(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<sbyte> Min(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Min(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Min(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Min(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Min(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Min(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static int MoveMask(Vector256`1<sbyte> value);
    public static int MoveMask(Vector256`1<byte> value);
    public static Vector256`1<ushort> MultipleSumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right, byte mask);
    public static Vector256`1<long> Multiply(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<ulong> Multiply(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<short> MultiplyHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> MultiplyHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<short> MultiplyHighRoundScale(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> MultiplyLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Or(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Or(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Or(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Or(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Or(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Or(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Or(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Or(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> PackSignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> PackSignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<byte> PackUnsignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> PackUnsignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Permute2x128(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte control);
    public static Vector256`1<byte> Permute2x128(Vector256`1<byte> left, Vector256`1<byte> right, byte control);
    public static Vector256`1<short> Permute2x128(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Permute2x128(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Permute2x128(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Permute2x128(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<long> Permute2x128(Vector256`1<long> left, Vector256`1<long> right, byte control);
    public static Vector256`1<ulong> Permute2x128(Vector256`1<ulong> left, Vector256`1<ulong> right, byte control);
    public static Vector256`1<long> Permute4x64(Vector256`1<long> value, byte control);
    public static Vector256`1<ulong> Permute4x64(Vector256`1<ulong> value, byte control);
    public static Vector256`1<double> Permute4x64(Vector256`1<double> value, byte control);
    public static Vector256`1<int> PermuteVar8x32(Vector256`1<int> left, Vector256`1<int> control);
    public static Vector256`1<UInt32> PermuteVar8x32(Vector256`1<UInt32> left, Vector256`1<UInt32> control);
    public static Vector256`1<float> PermuteVar8x32(Vector256`1<float> left, Vector256`1<int> control);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftLeftLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftLeftLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftLeftLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftLeftLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftLeftLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftLeftLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftLeftLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftLeftLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftLeftLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector128`1<int> ShiftLeftLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftLeftLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftLeftLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, byte count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, byte count);
    public static Vector256`1<int> ShiftRightArithmeticVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector128`1<int> ShiftRightArithmeticVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftRightLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftRightLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftRightLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftRightLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftRightLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftRightLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftRightLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftRightLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftRightLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector128`1<int> ShiftRightLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftRightLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftRightLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<sbyte> Shuffle(Vector256`1<sbyte> value, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> Shuffle(Vector256`1<byte> value, Vector256`1<byte> mask);
    public static Vector256`1<int> Shuffle(Vector256`1<int> value, byte control);
    public static Vector256`1<UInt32> Shuffle(Vector256`1<UInt32> value, byte control);
    public static Vector256`1<short> ShuffleHigh(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleHigh(Vector256`1<ushort> value, byte control);
    public static Vector256`1<short> ShuffleLow(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleLow(Vector256`1<ushort> value, byte control);
    public static Vector256`1<sbyte> Sign(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> Sign(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> Sign(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Subtract(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Subtract(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Subtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Subtract(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Subtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Subtract(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Subtract(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Subtract(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> SubtractSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> SubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<byte> SubtractSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> SubtractSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<ulong> SumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<sbyte> UnpackHigh(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackHigh(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackHigh(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackHigh(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackHigh(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackHigh(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> UnpackLow(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackLow(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackLow(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackLow(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackLow(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackLow(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> Xor(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Xor(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Xor(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Xor(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Xor(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Xor(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Xor(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Xor(Vector256`1<ulong> left, Vector256`1<ulong> right);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Bmi1 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 AndNot(UInt32 left, UInt32 right);
    public static ulong AndNot(ulong left, ulong right);
    public static UInt32 BitFieldExtract(UInt32 value, byte start, byte length);
    public static ulong BitFieldExtract(ulong value, byte start, byte length);
    public static UInt32 BitFieldExtract(UInt32 value, ushort control);
    public static ulong BitFieldExtract(ulong value, ushort control);
    public static UInt32 ExtractLowestSetBit(UInt32 value);
    public static ulong ExtractLowestSetBit(ulong value);
    public static UInt32 GetMaskUpToLowestSetBit(UInt32 value);
    public static ulong GetMaskUpToLowestSetBit(ulong value);
    public static UInt32 ResetLowestSetBit(UInt32 value);
    public static ulong ResetLowestSetBit(ulong value);
    public static UInt32 TrailingZeroCount(UInt32 value);
    public static ulong TrailingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Bmi2 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 ZeroHighBits(UInt32 value, UInt32 index);
    public static ulong ZeroHighBits(ulong value, ulong index);
    public static UInt32 MultiplyNoFlags(UInt32 left, UInt32 right, UInt32* high);
    public static ulong MultiplyNoFlags(ulong left, ulong right, UInt64* high);
    public static UInt32 ParallelBitDeposit(UInt32 value, UInt32 mask);
    public static ulong ParallelBitDeposit(ulong value, ulong mask);
    public static UInt32 ParallelBitExtract(UInt32 value, UInt32 mask);
    public static ulong ParallelBitExtract(ulong value, ulong mask);
}
[__BlockReflectionAttribute]
public enum System.Runtime.Intrinsics.X86.FloatComparisonMode : Enum {
    public byte value__;
    public static FloatComparisonMode EqualOrderedNonSignaling;
    public static FloatComparisonMode LessThanOrderedSignaling;
    public static FloatComparisonMode LessThanOrEqualOrderedSignaling;
    public static FloatComparisonMode UnorderedNonSignaling;
    public static FloatComparisonMode NotEqualUnorderedNonSignaling;
    public static FloatComparisonMode NotLessThanUnorderedSignaling;
    public static FloatComparisonMode NotLessThanOrEqualUnorderedSignaling;
    public static FloatComparisonMode OrderedNonSignaling;
    public static FloatComparisonMode EqualUnorderedNonSignaling;
    public static FloatComparisonMode NotGreaterThanOrEqualUnorderedSignaling;
    public static FloatComparisonMode NotGreaterThanUnorderedSignaling;
    public static FloatComparisonMode FalseOrderedNonSignaling;
    public static FloatComparisonMode NotEqualOrderedNonSignaling;
    public static FloatComparisonMode GreaterThanOrEqualOrderedSignaling;
    public static FloatComparisonMode GreaterThanOrderedSignaling;
    public static FloatComparisonMode TrueUnorderedNonSignaling;
    public static FloatComparisonMode EqualOrderedSignaling;
    public static FloatComparisonMode LessThanOrderedNonSignaling;
    public static FloatComparisonMode LessThanOrEqualOrderedNonSignaling;
    public static FloatComparisonMode UnorderedSignaling;
    public static FloatComparisonMode NotEqualUnorderedSignaling;
    public static FloatComparisonMode NotLessThanUnorderedNonSignaling;
    public static FloatComparisonMode NotLessThanOrEqualUnorderedNonSignaling;
    public static FloatComparisonMode OrderedSignaling;
    public static FloatComparisonMode EqualUnorderedSignaling;
    public static FloatComparisonMode NotGreaterThanOrEqualUnorderedNonSignaling;
    public static FloatComparisonMode NotGreaterThanUnorderedNonSignaling;
    public static FloatComparisonMode FalseOrderedSignaling;
    public static FloatComparisonMode NotEqualOrderedSignaling;
    public static FloatComparisonMode GreaterThanOrEqualOrderedNonSignaling;
    public static FloatComparisonMode GreaterThanOrderedNonSignaling;
    public static FloatComparisonMode TrueUnorderedSignaling;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Fma : Avx {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> MultiplyAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplyAddSubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddSubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddSubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddSubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Lzcnt : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 LeadingZeroCount(UInt32 value);
    public static ulong LeadingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Pclmulqdq : Sse2 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<long> CarrylessMultiply(Vector128`1<long> left, Vector128`1<long> right, byte control);
    public static Vector128`1<ulong> CarrylessMultiply(Vector128`1<ulong> left, Vector128`1<ulong> right, byte control);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Popcnt : Sse42 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static int PopCount(UInt32 value);
    public static long PopCount(ulong value);
}
[__BlockReflectionAttribute]
public enum System.Runtime.Intrinsics.X86.ResultsFlag : Enum {
    public byte value__;
    public static ResultsFlag CFlag;
    public static ResultsFlag NotCFlagAndNotZFlag;
    public static ResultsFlag OFlag;
    public static ResultsFlag SFlag;
    public static ResultsFlag ZFlag;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> Add(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AddScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> And(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AndNot(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanOrEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareGreaterThanOrEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanOrEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareLessThanOrEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareNotEqualOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareNotEqualUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanOrEqualScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareOrdered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareOrderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareUnordered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareUnorderedScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static int ConvertToInt32(Vector128`1<float> value);
    public static long ConvertToInt64(Vector128`1<float> value);
    public static float ConvertToSingle(Vector128`1<float> value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, int value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, long value);
    public static int ConvertToInt32WithTruncation(Vector128`1<float> value);
    public static long ConvertToInt64WithTruncation(Vector128`1<float> value);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> DivideScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> LoadVector128(Single* address);
    public static Vector128`1<float> LoadScalarVector128(Single* address);
    public static Vector128`1<float> LoadAlignedVector128(Single* address);
    public static Vector128`1<float> LoadHigh(Vector128`1<float> lower, Single* address);
    public static Vector128`1<float> LoadLow(Vector128`1<float> upper, Single* address);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MaxScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MinScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> MoveHighToLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveLowToHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static int MoveMask(Vector128`1<float> value);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MultiplyScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static void Prefetch0(Void* address);
    public static void Prefetch1(Void* address);
    public static void Prefetch2(Void* address);
    public static void PrefetchNonTemporal(Void* address);
    public static Vector128`1<float> Or(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Reciprocal(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrt(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> SetVector128(float e3, float e2, float e1, float e0);
    public static Vector128`1<float> SetScalarVector128(float value);
    public static Vector128`1<float> SetAllVector128(float value);
    public static Vector128`1<float> SetZeroVector128();
    public static Vector128`1<U> StaticCast(Vector128`1<T> value);
    public static Vector128`1<float> Shuffle(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static void StoreAligned(Single* address, Vector128`1<float> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector128`1<float> source);
    public static void Store(Single* address, Vector128`1<float> source);
    public static void StoreFence();
    public static void StoreScalar(Single* address, Vector128`1<float> source);
    public static void StoreHigh(Single* address, Vector128`1<float> source);
    public static void StoreLow(Single* address, Vector128`1<float> source);
    public static Vector128`1<float> Subtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> SubtractScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Xor(Vector128`1<float> left, Vector128`1<float> right);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse2 : Sse {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Add(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Add(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Add(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Add(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Add(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Add(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Add(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Add(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Add(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> AddScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> AddSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> And(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> And(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> And(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> And(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> And(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> And(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> And(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> And(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> And(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> AndNot(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> AndNot(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> AndNot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AndNot(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> AndNot(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> AndNot(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> AndNot(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> AndNot(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> AndNot(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Average(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> Average(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<sbyte> CompareEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> CompareEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareGreaterThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareGreaterThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareGreaterThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanOrEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareGreaterThanOrEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareLessThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareLessThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareLessThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanOrEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareLessThanOrEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareNotEqualOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareNotEqualUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanOrEqualScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareOrdered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareOrderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareUnordered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareUnorderedScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<int> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<double> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<int> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<float> value);
    public static double ConvertToDouble(Vector128`1<double> value);
    public static int ConvertToInt32(Vector128`1<double> value);
    public static int ConvertToInt32(Vector128`1<int> value);
    public static long ConvertToInt64(Vector128`1<double> value);
    public static long ConvertToInt64(Vector128`1<long> value);
    public static UInt32 ConvertToUInt32(Vector128`1<UInt32> value);
    public static ulong ConvertToUInt64(Vector128`1<ulong> value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, int value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, long value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, Vector128`1<float> value);
    public static Vector128`1<int> ConvertScalarToVector128Int32(int value);
    public static Vector128`1<long> ConvertScalarToVector128Int64(long value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, Vector128`1<double> value);
    public static Vector128`1<UInt32> ConvertScalarToVector128UInt32(UInt32 value);
    public static Vector128`1<ulong> ConvertScalarToVector128UInt64(ulong value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<double> value);
    public static int ConvertToInt32WithTruncation(Vector128`1<double> value);
    public static long ConvertToInt64WithTruncation(Vector128`1<double> value);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> DivideScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static ushort Extract(Vector128`1<ushort> value, byte index);
    public static Vector128`1<short> Insert(Vector128`1<short> value, short data, byte index);
    public static Vector128`1<ushort> Insert(Vector128`1<ushort> value, ushort data, byte index);
    public static Vector128`1<sbyte> LoadVector128(SByte* address);
    public static Vector128`1<byte> LoadVector128(Byte* address);
    public static Vector128`1<short> LoadVector128(Int16* address);
    public static Vector128`1<ushort> LoadVector128(UInt16* address);
    public static Vector128`1<int> LoadVector128(Int32* address);
    public static Vector128`1<UInt32> LoadVector128(UInt32* address);
    public static Vector128`1<long> LoadVector128(Int64* address);
    public static Vector128`1<ulong> LoadVector128(UInt64* address);
    public static Vector128`1<double> LoadVector128(Double* address);
    public static Vector128`1<double> LoadScalarVector128(Double* address);
    public static Vector128`1<sbyte> LoadAlignedVector128(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128(UInt64* address);
    public static Vector128`1<double> LoadAlignedVector128(Double* address);
    public static void LoadFence();
    public static Vector128`1<double> LoadHigh(Vector128`1<double> lower, Double* address);
    public static Vector128`1<double> LoadLow(Vector128`1<double> upper, Double* address);
    public static Vector128`1<int> LoadScalarVector128(Int32* address);
    public static Vector128`1<UInt32> LoadScalarVector128(UInt32* address);
    public static Vector128`1<long> LoadScalarVector128(Int64* address);
    public static Vector128`1<ulong> LoadScalarVector128(UInt64* address);
    public static void MaskMove(Vector128`1<sbyte> source, Vector128`1<sbyte> mask, SByte* address);
    public static void MaskMove(Vector128`1<byte> source, Vector128`1<byte> mask, Byte* address);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MaxScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static void MemoryFence();
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MinScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MoveScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static int MoveMask(Vector128`1<sbyte> value);
    public static int MoveMask(Vector128`1<byte> value);
    public static int MoveMask(Vector128`1<double> value);
    public static Vector128`1<long> MoveScalar(Vector128`1<long> value);
    public static Vector128`1<ulong> MoveScalar(Vector128`1<ulong> value);
    public static Vector128`1<ulong> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MultiplyScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> MultiplyHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> MultiplyHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> MultiplyHorizontalAdd(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> Or(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Or(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Or(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Or(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Or(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Or(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Or(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Or(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Or(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> PackSignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> PackSignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<byte> PackUnsignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> SetVector128(sbyte e15, sbyte e14, sbyte e13, sbyte e12, sbyte e11, sbyte e10, sbyte e9, sbyte e8, sbyte e7, sbyte e6, sbyte e5, sbyte e4, sbyte e3, sbyte e2, sbyte e1, sbyte e0);
    public static Vector128`1<byte> SetVector128(byte e15, byte e14, byte e13, byte e12, byte e11, byte e10, byte e9, byte e8, byte e7, byte e6, byte e5, byte e4, byte e3, byte e2, byte e1, byte e0);
    public static Vector128`1<short> SetVector128(short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0);
    public static Vector128`1<ushort> SetVector128(ushort e7, ushort e6, ushort e5, ushort e4, ushort e3, ushort e2, ushort e1, ushort e0);
    public static Vector128`1<int> SetVector128(int e3, int e2, int e1, int e0);
    public static Vector128`1<UInt32> SetVector128(UInt32 e3, UInt32 e2, UInt32 e1, UInt32 e0);
    public static Vector128`1<long> SetVector128(long e1, long e0);
    public static Vector128`1<ulong> SetVector128(ulong e1, ulong e0);
    public static Vector128`1<double> SetVector128(double e1, double e0);
    public static Vector128`1<double> SetScalarVector128(double value);
    public static Vector128`1<byte> SetAllVector128(byte value);
    public static Vector128`1<sbyte> SetAllVector128(sbyte value);
    public static Vector128`1<short> SetAllVector128(short value);
    public static Vector128`1<ushort> SetAllVector128(ushort value);
    public static Vector128`1<int> SetAllVector128(int value);
    public static Vector128`1<UInt32> SetAllVector128(UInt32 value);
    public static Vector128`1<long> SetAllVector128(long value);
    public static Vector128`1<ulong> SetAllVector128(ulong value);
    public static Vector128`1<double> SetAllVector128(double value);
    public static Vector128`1<T> SetZeroVector128();
    public static Vector128`1<long> SumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> Shuffle(Vector128`1<int> value, byte control);
    public static Vector128`1<UInt32> Shuffle(Vector128`1<UInt32> value, byte control);
    public static Vector128`1<double> Shuffle(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<short> ShuffleHigh(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleHigh(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShuffleLow(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleLow(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftLeftLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftLeftLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftLeftLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftLeftLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftLeftLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftLeftLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftLeftLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftLeftLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, byte count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftRightLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftRightLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftRightLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftRightLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftRightLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftRightLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftRightLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static void StoreScalar(Double* address, Vector128`1<double> source);
    public static void StoreAligned(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector128`1<byte> source);
    public static void StoreAligned(Int16* address, Vector128`1<short> source);
    public static void StoreAligned(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector128`1<int> source);
    public static void StoreAligned(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector128`1<long> source);
    public static void StoreAligned(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAligned(Double* address, Vector128`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector128`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector128`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector128`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector128`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector128`1<double> source);
    public static void Store(SByte* address, Vector128`1<sbyte> source);
    public static void Store(Byte* address, Vector128`1<byte> source);
    public static void Store(Int16* address, Vector128`1<short> source);
    public static void Store(UInt16* address, Vector128`1<ushort> source);
    public static void Store(Int32* address, Vector128`1<int> source);
    public static void Store(UInt32* address, Vector128`1<UInt32> source);
    public static void Store(Int64* address, Vector128`1<long> source);
    public static void Store(UInt64* address, Vector128`1<ulong> source);
    public static void Store(Double* address, Vector128`1<double> source);
    public static void StoreHigh(Double* address, Vector128`1<double> source);
    public static void StoreLow(Int64* address, Vector128`1<long> source);
    public static void StoreLow(UInt64* address, Vector128`1<ulong> source);
    public static void StoreLow(Double* address, Vector128`1<double> source);
    public static void StoreNonTemporal(Int32* address, int value);
    public static void StoreNonTemporal(UInt32* address, UInt32 value);
    public static void StoreNonTemporal(Int64* address, long value);
    public static void StoreNonTemporal(UInt64* address, ulong value);
    public static Vector128`1<byte> Subtract(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Subtract(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Subtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Subtract(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Subtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Subtract(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Subtract(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Subtract(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Subtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> SubtractScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> SubtractSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> SubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> SubtractSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> UnpackHigh(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackHigh(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackHigh(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackHigh(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackHigh(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackHigh(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackHigh(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> UnpackLow(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackLow(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackLow(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackLow(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackLow(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackLow(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackLow(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Xor(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Xor(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Xor(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Xor(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Xor(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Xor(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Xor(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Xor(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Xor(Vector128`1<double> left, Vector128`1<double> right);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse3 : Sse2 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> AddSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> AddSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalAdd(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalAdd(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> LoadAndDuplicateToVector128(Double* address);
    public static Vector128`1<sbyte> LoadDquVector128(SByte* address);
    public static Vector128`1<byte> LoadDquVector128(Byte* address);
    public static Vector128`1<short> LoadDquVector128(Int16* address);
    public static Vector128`1<ushort> LoadDquVector128(UInt16* address);
    public static Vector128`1<int> LoadDquVector128(Int32* address);
    public static Vector128`1<UInt32> LoadDquVector128(UInt32* address);
    public static Vector128`1<long> LoadDquVector128(Int64* address);
    public static Vector128`1<ulong> LoadDquVector128(UInt64* address);
    public static Vector128`1<double> MoveAndDuplicate(Vector128`1<double> source);
    public static Vector128`1<float> MoveHighAndDuplicate(Vector128`1<float> source);
    public static Vector128`1<float> MoveLowAndDuplicate(Vector128`1<float> source);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse41 : Ssse3 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<short> Blend(Vector128`1<short> left, Vector128`1<short> right, byte control);
    public static Vector128`1<ushort> Blend(Vector128`1<ushort> left, Vector128`1<ushort> right, byte control);
    public static Vector128`1<float> Blend(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> Blend(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<sbyte> BlendVariable(Vector128`1<sbyte> left, Vector128`1<sbyte> right, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> BlendVariable(Vector128`1<byte> left, Vector128`1<byte> right, Vector128`1<byte> mask);
    public static Vector128`1<float> BlendVariable(Vector128`1<float> left, Vector128`1<float> right, Vector128`1<float> mask);
    public static Vector128`1<double> BlendVariable(Vector128`1<double> left, Vector128`1<double> right, Vector128`1<double> mask);
    public static Vector128`1<float> Ceiling(Vector128`1<float> value);
    public static Vector128`1<double> Ceiling(Vector128`1<double> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<long> CompareEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<sbyte> value);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<sbyte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<short> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<sbyte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<byte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<short> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<int> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<UInt32> value);
    public static Vector128`1<float> DotProduct(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> DotProduct(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static byte Extract(Vector128`1<byte> value, byte index);
    public static int Extract(Vector128`1<int> value, byte index);
    public static UInt32 Extract(Vector128`1<UInt32> value, byte index);
    public static long Extract(Vector128`1<long> value, byte index);
    public static ulong Extract(Vector128`1<ulong> value, byte index);
    public static float Extract(Vector128`1<float> value, byte index);
    public static Vector128`1<float> Floor(Vector128`1<float> value);
    public static Vector128`1<double> Floor(Vector128`1<double> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<sbyte> Insert(Vector128`1<sbyte> value, sbyte data, byte index);
    public static Vector128`1<byte> Insert(Vector128`1<byte> value, byte data, byte index);
    public static Vector128`1<int> Insert(Vector128`1<int> value, int data, byte index);
    public static Vector128`1<UInt32> Insert(Vector128`1<UInt32> value, UInt32 data, byte index);
    public static Vector128`1<long> Insert(Vector128`1<long> value, long data, byte index);
    public static Vector128`1<ulong> Insert(Vector128`1<ulong> value, ulong data, byte index);
    public static Vector128`1<float> Insert(Vector128`1<float> value, Vector128`1<float> data, byte index);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> MinHorizontal(Vector128`1<ushort> value);
    public static Vector128`1<ushort> MultipleSumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right, byte mask);
    public static Vector128`1<long> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<ushort> PackUnsignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> RoundToNearestInteger(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZero(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirection(Vector128`1<float> value);
    public static Vector128`1<double> RoundToNearestInteger(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinity(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinity(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZero(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirection(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<sbyte> LoadAlignedVector128NonTemporal(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128NonTemporal(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128NonTemporal(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128NonTemporal(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128NonTemporal(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128NonTemporal(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128NonTemporal(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128NonTemporal(UInt64* address);
    public static bool TestAllOnes(Vector128`1<sbyte> value);
    public static bool TestAllOnes(Vector128`1<byte> value);
    public static bool TestAllOnes(Vector128`1<short> value);
    public static bool TestAllOnes(Vector128`1<ushort> value);
    public static bool TestAllOnes(Vector128`1<int> value);
    public static bool TestAllOnes(Vector128`1<UInt32> value);
    public static bool TestAllOnes(Vector128`1<long> value);
    public static bool TestAllOnes(Vector128`1<ulong> value);
    public static bool TestAllZeros(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestAllZeros(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestAllZeros(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestAllZeros(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestAllZeros(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestAllZeros(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestAllZeros(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestAllZeros(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestMixOnesZeros(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestMixOnesZeros(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestMixOnesZeros(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestMixOnesZeros(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestMixOnesZeros(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestMixOnesZeros(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestMixOnesZeros(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestMixOnesZeros(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestNotZAndNotC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestNotZAndNotC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestNotZAndNotC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestNotZAndNotC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestNotZAndNotC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestNotZAndNotC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestNotZAndNotC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestNotZAndNotC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestZ(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestZ(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestZ(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestZ(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestZ(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestZ(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestZ(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestZ(Vector128`1<ulong> left, Vector128`1<ulong> right);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse42 : Sse41 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static bool CompareImplicitLength(Vector128`1<sbyte> left, Vector128`1<sbyte> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareImplicitLength(Vector128`1<byte> left, Vector128`1<byte> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareImplicitLength(Vector128`1<short> left, Vector128`1<short> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareImplicitLength(Vector128`1<ushort> left, Vector128`1<ushort> right, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static bool CompareExplicitLength(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<sbyte> left, Vector128`1<sbyte> right, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<byte> left, Vector128`1<byte> right, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<short> left, Vector128`1<short> right, StringComparisonMode mode);
    public static int CompareImplicitLengthIndex(Vector128`1<ushort> left, Vector128`1<ushort> right, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, StringComparisonMode mode);
    public static int CompareExplicitLengthIndex(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthBitMask(Vector128`1<sbyte> left, Vector128`1<sbyte> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthBitMask(Vector128`1<byte> left, Vector128`1<byte> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthBitMask(Vector128`1<short> left, Vector128`1<short> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthBitMask(Vector128`1<ushort> left, Vector128`1<ushort> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthUnitMask(Vector128`1<sbyte> left, Vector128`1<sbyte> right, StringComparisonMode mode);
    public static Vector128`1<byte> CompareImplicitLengthUnitMask(Vector128`1<byte> left, Vector128`1<byte> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthUnitMask(Vector128`1<short> left, Vector128`1<short> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareImplicitLengthUnitMask(Vector128`1<ushort> left, Vector128`1<ushort> right, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthBitMask(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthBitMask(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthBitMask(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthBitMask(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthUnitMask(Vector128`1<sbyte> left, byte leftLength, Vector128`1<sbyte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<byte> CompareExplicitLengthUnitMask(Vector128`1<byte> left, byte leftLength, Vector128`1<byte> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthUnitMask(Vector128`1<short> left, byte leftLength, Vector128`1<short> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<ushort> CompareExplicitLengthUnitMask(Vector128`1<ushort> left, byte leftLength, Vector128`1<ushort> right, byte rightLength, StringComparisonMode mode);
    public static Vector128`1<long> CompareGreaterThan(Vector128`1<long> left, Vector128`1<long> right);
    public static UInt32 Crc32(UInt32 crc, byte data);
    public static UInt32 Crc32(UInt32 crc, ushort data);
    public static UInt32 Crc32(UInt32 crc, UInt32 data);
    public static ulong Crc32(ulong crc, ulong data);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.Intrinsics.X86.Ssse3 : Sse3 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<sbyte> AlignRight(Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte mask);
    public static Vector128`1<short> HorizontalAdd(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalAdd(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalAddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> HorizontalSubtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalSubtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalSubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyAddAdjacent(Vector128`1<byte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> MultiplyHighRoundScale(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> Shuffle(Vector128`1<sbyte> value, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> Shuffle(Vector128`1<byte> value, Vector128`1<byte> mask);
    public static Vector128`1<sbyte> Sign(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Sign(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Sign(Vector128`1<int> left, Vector128`1<int> right);
}
[__BlockReflectionAttribute]
public enum System.Runtime.Intrinsics.X86.StringComparisonMode : Enum {
    public byte value__;
    public static StringComparisonMode EqualAny;
    public static StringComparisonMode Ranges;
    public static StringComparisonMode EqualEach;
    public static StringComparisonMode EqualOrdered;
    public static StringComparisonMode NegativePolarity;
    public static StringComparisonMode MaskedNegativePolarity;
    public static StringComparisonMode LeastSignificant;
    public static StringComparisonMode MostSignificant;
}
[__BlockReflectionAttribute]
public abstract class System.Runtime.Loader.AssemblyLoadContext : object {
    [CompilerGeneratedAttribute]
private static AssemblyLoadEventHandler AssemblyLoad;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler TypeResolve;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler ResourceResolve;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler AssemblyResolve;
    [CompilerGeneratedAttribute]
private Func`3<AssemblyLoadContext, AssemblyName, Assembly> Resolving;
    [CompilerGeneratedAttribute]
private Action`1<AssemblyLoadContext> Unloading;
    [CompilerGeneratedAttribute]
private static AssemblyLoadContext <Default>k__BackingField;
    public static AssemblyLoadContext Default { get; }
    private static AssemblyLoadContext();
    public static Assembly[] GetLoadedAssemblies();
    [CompilerGeneratedAttribute]
public static void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
public void remove_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
public void add_Unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
public void remove_Unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
public static AssemblyLoadContext get_Default();
    public static AssemblyLoadContext GetLoadContext(Assembly assembly);
    public Assembly LoadFromAssemblyPath(string assemblyPath);
    public void SetProfileOptimizationRoot(string directoryPath);
    public void StartProfileOptimization(string profile);
}
internal class System.Runtime.Loader.DefaultAssemblyLoadContext : AssemblyLoadContext {
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    private static ulong s_topOfMemory;
    private static long s_hiddenLastKnownFreeAddressSpace;
    private static long s_hiddenLastTimeCheckingAddressSpace;
    private static int CheckThreshold;
    private static int LowMemoryFudgeFactor;
    private static int MemoryCheckGranularity;
    private static ulong s_GCSegmentSize;
    private ulong _reservedMemory;
    private bool _mustSubtractReservation;
    private static long s_memFailPointReservedMemory;
    private static long LastKnownFreeAddressSpace { get; private set; }
    private static long LastTimeCheckingAddressSpace { get; private set; }
    internal static ulong MemoryFailPointReservedMemory { get; }
    private static MemoryFailPoint();
    public MemoryFailPoint(int sizeInMegabytes);
    private static long get_LastKnownFreeAddressSpace();
    private static void set_LastKnownFreeAddressSpace(long value);
    private static long AddToLastKnownFreeAddressSpace(long addend);
    private static long get_LastTimeCheckingAddressSpace();
    private static void set_LastTimeCheckingAddressSpace(long value);
    private static void CheckForAvailableMemory(UInt64& availPageFile, UInt64& totalAddressSpaceFree);
    private static bool CheckForFreeAddressSpace(ulong size, bool shouldThrow);
    private static ulong MemFreeAfterAddress(Void* address, ulong size);
    private static void GetMemorySettings(UInt64& maxGCSegmentSize, UInt64& topOfMemory);
    [__BlockReflectionAttribute]
protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static long AddMemoryFailPointReservation(long size);
    internal static ulong get_MemoryFailPointReservedMemory();
}
[McgIntrinsicsAttribute]
internal class System.Runtime.RawCalliHelper : object {
    public static T Call(IntPtr pfn, IntPtr arg);
    public static void Call(IntPtr pfn, object arg);
    public static T Call(IntPtr pfn, IntPtr arg1, IntPtr arg2);
    public static T Call(IntPtr pfn, IntPtr arg1, IntPtr arg2, object arg3, IntPtr& arg4);
    public static void Call(IntPtr pfn, IntPtr arg1, object arg2);
    public static T Call(IntPtr pfn, object arg1, IntPtr arg2);
    public static T Call(IntPtr pfn, String[] arg0);
}
[__BlockReflectionAttribute]
public class System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
    private object _wrappedObject;
    public ObjectHandle(object o);
    public object Unwrap();
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.RuntimeExportAttribute : Attribute {
    public string EntryPoint;
    public RuntimeExportAttribute(string entry);
}
[AttributeUsageAttribute("96")]
[__BlockReflectionAttribute]
public class System.Runtime.RuntimeImportAttribute : Attribute {
    public string DllName;
    public string EntryPoint;
    public RuntimeImportAttribute(string entry);
    public RuntimeImportAttribute(string dllName, string entry);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Runtime.RuntimeImports : object {
    private static string RuntimeLibrary;
    [RuntimeImportAttribute("[MRT]", "RhpSendCustomEventToDebugger")]
internal static void RhpSendCustomEventToDebugger(IntPtr payload, int length);
    internal static UInt32 RhpGetFuncEvalParameterBufferSize();
    internal static UInt32 RhpGetFuncEvalMode();
    internal static UInt32 RhpRecordDebuggeeInitiatedHandle(Void* objectHandle);
    internal static void RhpVerifyDebuggerCleanup();
    internal static IntPtr RhpGetCurrentThread();
    [RuntimeImportAttribute("[MRT]", "RhpInitiateThreadAbort")]
internal static void RhpInitiateThreadAbort(IntPtr thread, Exception exception, bool doRudeAbort);
    [RuntimeImportAttribute("[MRT]", "RhpCancelThreadAbort")]
internal static void RhpCancelThreadAbort(IntPtr thread);
    [RuntimeImportAttribute("[MRT]", "RhCollect")]
internal static void RhCollect(int generation, InternalGCCollectionMode mode);
    [RuntimeImportAttribute("[MRT]", "RhSuppressFinalize")]
internal static void RhSuppressFinalize(object obj);
    internal static void RhReRegisterForFinalize(object obj);
    [RuntimeImportAttribute("[MRT]", "RhReRegisterForFinalize")]
private static bool _RhReRegisterForFinalize(object obj);
    private static void RhWaitForPendingFinalizers(int allowReentrantWait);
    internal static void RhWaitForPendingFinalizers(bool allowReentrantWait);
    [RuntimeImportAttribute("[MRT]", "RhGetMaxGcGeneration")]
internal static int RhGetMaxGcGeneration();
    [RuntimeImportAttribute("[MRT]", "RhGetGcCollectionCount")]
internal static int RhGetGcCollectionCount(int generation, bool getSpecialGCCount);
    [RuntimeImportAttribute("[MRT]", "RhGetGeneration")]
internal static int RhGetGeneration(object obj);
    [RuntimeImportAttribute("[MRT]", "RhGetGcLatencyMode")]
internal static GCLatencyMode RhGetGcLatencyMode();
    [RuntimeImportAttribute("[MRT]", "RhSetGcLatencyMode")]
internal static int RhSetGcLatencyMode(GCLatencyMode newLatencyMode);
    [RuntimeImportAttribute("[MRT]", "RhIsServerGc")]
internal static bool RhIsServerGc();
    [RuntimeImportAttribute("[MRT]", "RhGetGcTotalMemory")]
internal static long RhGetGcTotalMemory();
    [RuntimeImportAttribute("[MRT]", "RhGetLohCompactionMode")]
internal static int RhGetLohCompactionMode();
    [RuntimeImportAttribute("[MRT]", "RhSetLohCompactionMode")]
internal static void RhSetLohCompactionMode(int newLohCompactionMode);
    [RuntimeImportAttribute("[MRT]", "RhGetCurrentObjSize")]
internal static long RhGetCurrentObjSize();
    [RuntimeImportAttribute("[MRT]", "RhGetGCNow")]
internal static long RhGetGCNow();
    [RuntimeImportAttribute("[MRT]", "RhGetLastGCStartTime")]
internal static long RhGetLastGCStartTime(int generation);
    [RuntimeImportAttribute("[MRT]", "RhGetLastGCDuration")]
internal static long RhGetLastGCDuration(int generation);
    [RuntimeImportAttribute("[MRT]", "RhpRegisterFrozenSegment")]
internal static bool RhpRegisterFrozenSegment(IntPtr pSegmentStart, int length);
    [RuntimeImportAttribute("[MRT]", "RhRegisterForFullGCNotification")]
internal static bool RhRegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    [RuntimeImportAttribute("[MRT]", "RhWaitForFullGCApproach")]
internal static int RhWaitForFullGCApproach(int millisecondsTimeout);
    [RuntimeImportAttribute("[MRT]", "RhWaitForFullGCComplete")]
internal static int RhWaitForFullGCComplete(int millisecondsTimeout);
    [RuntimeImportAttribute("[MRT]", "RhCancelFullGCNotification")]
internal static bool RhCancelFullGCNotification();
    [RuntimeImportAttribute("[MRT]", "RhStartNoGCRegion")]
internal static int RhStartNoGCRegion(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    [RuntimeImportAttribute("[MRT]", "RhEndNoGCRegion")]
internal static int RhEndNoGCRegion();
    [RuntimeImportAttribute("[MRT]", "RhpShutdown")]
internal static void RhpShutdown();
    [RuntimeImportAttribute("[MRT]", "RhGetGCSegmentSize")]
internal static ulong RhGetGCSegmentSize();
    [RuntimeImportAttribute("[MRT]", "RhGetAllocatedBytesForCurrentThread")]
internal static long RhGetAllocatedBytesForCurrentThread();
    [RuntimeImportAttribute("[MRT]", "RhCompareObjectContentsAndPadding")]
internal static bool RhCompareObjectContentsAndPadding(object obj1, object obj2);
    [RuntimeImportAttribute("[MRT]", "RhGetProcessCpuCount")]
internal static int RhGetProcessCpuCount();
    [RuntimeImportAttribute("[MRT]", "RhpHandleAlloc")]
private static IntPtr RhpHandleAlloc(object value, GCHandleType type);
    internal static IntPtr RhHandleAlloc(object value, GCHandleType type);
    [RuntimeImportAttribute("[MRT]", "RhpHandleAllocDependent")]
private static IntPtr RhpHandleAllocDependent(object primary, object secondary);
    internal static IntPtr RhHandleAllocDependent(object primary, object secondary);
    [RuntimeImportAttribute("[MRT]", "RhpHandleAllocVariable")]
private static IntPtr RhpHandleAllocVariable(object value, UInt32 type);
    internal static IntPtr RhHandleAllocVariable(object value, UInt32 type);
    [RuntimeImportAttribute("[MRT]", "RhHandleFree")]
internal static void RhHandleFree(IntPtr handle);
    [RuntimeImportAttribute("[MRT]", "RhHandleGet")]
private static object _RhHandleGet(IntPtr handle);
    internal static object RhHandleGet(IntPtr handle);
    [RuntimeImportAttribute("[MRT]", "RhHandleGetDependent")]
internal static object RhHandleGetDependent(IntPtr handle, Object& secondary);
    [RuntimeImportAttribute("[MRT]", "RhHandleSet")]
internal static void RhHandleSet(IntPtr handle, object value);
    [RuntimeImportAttribute("[MRT]", "RhHandleSetDependentSecondary")]
internal static void RhHandleSetDependentSecondary(IntPtr handle, object secondary);
    [RuntimeImportAttribute("[MRT]", "RhHandleGetVariableType")]
internal static UInt32 RhHandleGetVariableType(IntPtr handle);
    [RuntimeImportAttribute("[MRT]", "RhHandleSetVariableType")]
internal static void RhHandleSetVariableType(IntPtr handle, UInt32 type);
    [RuntimeImportAttribute("[MRT]", "RhHandleCompareExchangeVariableType")]
internal static UInt32 RhHandleCompareExchangeVariableType(IntPtr handle, UInt32 oldType, UInt32 newType);
    [RuntimeImportAttribute("[MRT]", "RhTypeCast_AreTypesEquivalent")]
internal static bool AreTypesEquivalent(EETypePtr pType1, EETypePtr pType2);
    [RuntimeImportAttribute("[MRT]", "RhTypeCast_AreTypesAssignable")]
internal static bool AreTypesAssignable(EETypePtr pSourceType, EETypePtr pTargetType);
    [RuntimeImportAttribute("[MRT]", "RhTypeCast_CheckArrayStore")]
internal static void RhCheckArrayStore(object array, object obj);
    [RuntimeImportAttribute("[MRT]", "RhTypeCast_IsInstanceOf")]
internal static object IsInstanceOf(object obj, EETypePtr pTargetType);
    [RuntimeImportAttribute("[MRT]", "RhTypeCast_IsInstanceOfClass")]
internal static object IsInstanceOfClass(object obj, EETypePtr pTargetType);
    [RuntimeImportAttribute("[MRT]", "RhTypeCast_IsInstanceOfInterface")]
internal static object IsInstanceOfInterface(object obj, EETypePtr pTargetType);
    [RuntimeImportAttribute("[MRT]", "RhBoxAny")]
internal static object RhBoxAny(Void* pData, EETypePtr pEEType);
    [RuntimeImportAttribute("[MRT]", "RhBoxAny")]
internal static object RhBoxAny(Byte& pData, EETypePtr pEEType);
    [RuntimeImportAttribute("[MRT]", "RhNewObject")]
internal static object RhNewObject(EETypePtr pEEType);
    [RuntimeImportAttribute("[MRT]", "RhNewArray")]
internal static Array RhNewArray(EETypePtr pEEType, int length);
    [RuntimeImportAttribute("[MRT]", "RhNewString")]
internal static string RhNewString(EETypePtr pEEType, int length);
    [RuntimeImportAttribute("[MRT]", "RhBox")]
internal static object RhBox(EETypePtr pEEType, Void* pData);
    [RuntimeImportAttribute("[MRT]", "RhBox")]
internal static object RhBox(EETypePtr pEEType, Byte& data);
    [RuntimeImportAttribute("[MRT]", "RhUnbox")]
internal static void RhUnbox(object obj, Void* pData, EETypePtr pUnboxToEEType);
    [RuntimeImportAttribute("[MRT]", "RhUnbox")]
internal static void RhUnbox(object obj, Byte& data, EETypePtr pUnboxToEEType);
    [RuntimeImportAttribute("[MRT]", "RhMemberwiseClone")]
internal static object RhMemberwiseClone(object obj);
    [RuntimeImportAttribute("[MRT]", "RhSpinWait")]
internal static void RhSpinWait(int iterations);
    private static int _RhYield();
    internal static bool RhYield();
    internal static void RhFlushProcessWriteBuffers();
    private static int RhCompatibleReentrantWaitAny(int alertable, int timeout, int count, IntPtr* handles);
    internal static int RhCompatibleReentrantWaitAny(bool alertable, int timeout, int count, IntPtr* handles);
    [RuntimeImportAttribute("[MRT]", "RhGetGCDescSize")]
internal static int RhGetGCDescSize(EETypePtr eeType);
    [RuntimeImportAttribute("[MRT]", "RhCreateGenericInstanceDescForType2")]
internal static bool RhCreateGenericInstanceDescForType2(EETypePtr pEEType, int arity, int nonGcStaticDataSize, int nonGCStaticDataOffset, int gcStaticDataSize, int threadStaticsOffset, Void* pGcStaticsDesc, Void* pThreadStaticsDesc, Int32* pGenericVarianceFlags);
    [RuntimeImportAttribute("[MRT]", "RhNewInterfaceDispatchCell")]
internal static IntPtr RhNewInterfaceDispatchCell(EETypePtr pEEType, int slotNumber);
    [RuntimeImportAttribute("[MRT]", "RhResolveDispatch")]
internal static IntPtr RhResolveDispatch(object pObject, EETypePtr pInterfaceType, ushort slot);
    [RuntimeImportAttribute("[MRT]", "RhpResolveInterfaceMethod")]
internal static IntPtr RhpResolveInterfaceMethod(object pObject, IntPtr pCell);
    [RuntimeImportAttribute("[MRT]", "RhCreateThunksHeap")]
internal static object RhCreateThunksHeap(IntPtr commonStubAddress);
    [RuntimeImportAttribute("[MRT]", "RhAllocateThunk")]
internal static IntPtr RhAllocateThunk(object thunksHeap);
    [RuntimeImportAttribute("[MRT]", "RhFreeThunk")]
internal static void RhFreeThunk(object thunksHeap, IntPtr thunkAddress);
    [RuntimeImportAttribute("[MRT]", "RhSetThunkData")]
internal static void RhSetThunkData(object thunksHeap, IntPtr thunkAddress, IntPtr context, IntPtr target);
    [RuntimeImportAttribute("[MRT]", "RhTryGetThunkData")]
internal static bool RhTryGetThunkData(object thunksHeap, IntPtr thunkAddress, IntPtr& context, IntPtr& target);
    [RuntimeImportAttribute("[MRT]", "RhGetThunkSize")]
internal static int RhGetThunkSize();
    [RuntimeImportAttribute("[MRT]", "RhGetThreadLocalStorageForDynamicType")]
internal static IntPtr RhGetThreadLocalStorageForDynamicType(int index, int tlsStorageSize, int numTlsCells);
    [RuntimeImportAttribute("[MRT]", "RhResolveDispatchOnType")]
internal static IntPtr RhResolveDispatchOnType(EETypePtr instanceType, EETypePtr interfaceType, ushort slot);
    [RuntimeImportAttribute("[MRT]", "RhGetRuntimeHelperForType")]
internal static IntPtr RhGetRuntimeHelperForType(EETypePtr pEEType, RuntimeHelperKind kind);
    [RuntimeImportAttribute("[MRT]", "RhGetDispatchMapForType")]
internal static IntPtr RhGetDispatchMapForType(EETypePtr pEEType);
    [RuntimeImportAttribute("[MRT]", "RhRegisterGcCallout")]
internal static bool RhRegisterGcCallout(GcRestrictedCalloutKind eKind, IntPtr pCalloutMethod);
    [RuntimeImportAttribute("[MRT]", "RhUnregisterGcCallout")]
internal static void RhUnregisterGcCallout(GcRestrictedCalloutKind eKind, IntPtr pCalloutMethod);
    [RuntimeImportAttribute("[MRT]", "RhRegisterRefCountedHandleCallback")]
internal static bool RhRegisterRefCountedHandleCallback(IntPtr pCalloutMethod, EETypePtr pTypeFilter);
    [RuntimeImportAttribute("[MRT]", "RhUnregisterRefCountedHandleCallback")]
internal static void RhUnregisterRefCountedHandleCallback(IntPtr pCalloutMethod, EETypePtr pTypeFilter);
    [RuntimeImportAttribute("[MRT]", "RhIsPromoted")]
internal static bool RhIsPromoted(object obj);
    [RuntimeImportAttribute("[MRT]", "RhFindBlob")]
private static bool RhFindBlob(TypeManagerHandle& typeManagerHandle, UInt32 blobId, Byte** ppbBlob, UInt32* pcbBlob);
    internal static bool RhFindBlob(TypeManagerHandle typeManagerHandle, UInt32 blobId, Byte** ppbBlob, UInt32* pcbBlob);
    [RuntimeImportAttribute("[MRT]", "RhpCreateTypeManager")]
internal static TypeManagerHandle RhpCreateTypeManager(IntPtr osModule, IntPtr moduleHeader, IntPtr* pClasslibFunctions, int nClasslibFunctions);
    [RuntimeImportAttribute("[MRT]", "RhpRegisterOsModule")]
internal static IntPtr RhpRegisterOsModule(IntPtr osModule);
    [RuntimeImportAttribute("[MRT]", "RhpGetModuleSection")]
private static IntPtr RhGetModuleSection(TypeManagerHandle& module, ReadyToRunSectionType section, Int32& length);
    internal static IntPtr RhGetModuleSection(TypeManagerHandle module, ReadyToRunSectionType section, Int32& length);
    [RuntimeImportAttribute("[MRT]", "RhGetLoadedOSModules")]
internal static UInt32 RhGetLoadedOSModules(IntPtr[] resultArray);
    [RuntimeImportAttribute("[MRT]", "RhGetOSModuleFromPointer")]
internal static IntPtr RhGetOSModuleFromPointer(IntPtr pointerVal);
    [RuntimeImportAttribute("[MRT]", "RhGetModuleFromEEType")]
internal static TypeManagerHandle RhGetModuleFromEEType(IntPtr pEEType);
    [RuntimeImportAttribute("[MRT]", "RhGetOSModuleFromEEType")]
internal static IntPtr RhGetOSModuleFromEEType(IntPtr pEEType);
    [RuntimeImportAttribute("[MRT]", "RhGetOSModuleForMrt")]
internal static IntPtr RhGetOSModuleForMrt();
    [RuntimeImportAttribute("[MRT]", "RhGetThreadStaticFieldAddress")]
internal static Byte* RhGetThreadStaticFieldAddress(EETypePtr pEEType, int threadStaticsBlockOffset, int fieldOffset);
    [RuntimeImportAttribute("[MRT]", "RhCurrentOSThreadId")]
internal static ulong RhCurrentOSThreadId();
    [RuntimeImportAttribute("*", "RhGetCurrentThunkContext")]
internal static IntPtr GetCurrentInteropThunkContext();
    [RuntimeImportAttribute("*", "RhGetCommonStubAddress")]
internal static IntPtr GetInteropCommonStubAddress();
    [RuntimeImportAttribute("[MRT]", "RhGetCodeTarget")]
public static IntPtr RhGetCodeTarget(IntPtr pCode);
    [RuntimeImportAttribute("[MRT]", "RhGetJmpStubCodeTarget")]
internal static IntPtr RhGetJmpStubCodeTarget(IntPtr pCode);
    [RuntimeImportAttribute("[MRT]", "RhGetTargetOfUnboxingAndInstantiatingStub")]
public static IntPtr RhGetTargetOfUnboxingAndInstantiatingStub(IntPtr pCode);
    [RuntimeImportAttribute("[MRT]", "RhGetModuleFileName")]
internal static int RhGetModuleFileName(IntPtr moduleHandle, Char*& moduleName);
    [RuntimeImportAttribute("[MRT]", "RhGetExceptionsForCurrentThread")]
internal static bool RhGetExceptionsForCurrentThread(Exception[] outputArray, Int32& writtenCountOut);
    [RuntimeImportAttribute("[MRT]", "RhSetErrorInfoBuffer")]
internal static Void* RhSetErrorInfoBuffer(Void* pNewBuffer);
    [RuntimeImportAttribute("[MRT]", "RhFindMethodStartAddress")]
internal static IntPtr RhFindMethodStartAddress(IntPtr codeAddr);
    [RuntimeImportAttribute("[MRT]", "RhGetCurrentThreadStackTrace")]
internal static int RhGetCurrentThreadStackTrace(IntPtr[] outputBuffer);
    [RuntimeImportAttribute("[MRT]", "RhGetCurrentThreadStackBounds")]
internal static void RhGetCurrentThreadStackBounds(IntPtr& pStackLow, IntPtr& pStackHigh);
    [RuntimeImportAttribute("[MRT]", "RhGetUniversalTransitionThunk")]
internal static IntPtr RhGetUniversalTransitionThunk();
    [RuntimeImportAttribute("[MRT]", "RhCallDescrWorker")]
internal static void RhCallDescrWorker(IntPtr callDescr);
    internal static void RhCallDescrWorkerNative(IntPtr callDescr);
    [RuntimeImportAttribute("[MRT]", "RhBulkMoveWithWriteBarrier")]
internal static void RhBulkMoveWithWriteBarrier(Byte& dmem, Byte& smem, UInt32 size);
    [RuntimeImportAttribute("[MRT]", "RhInitializeConservativeReportingRegion")]
internal static void RhInitializeConservativeReportingRegion(ConservativelyReportedRegionDesc* regionDesc, Void* bufferBegin, int cbBuffer);
    [RuntimeImportAttribute("[MRT]", "RhDisableConservativeReportingRegion")]
internal static void RhDisableConservativeReportingRegion(ConservativelyReportedRegionDesc* regionDesc);
    internal static Byte[] ConvertPublicKeyToPublicKeyToken(Byte[] publicKey);
    [RuntimeImportAttribute("[MRT]", "RhConvertPublicKeyToPublicKeyToken")]
private static void RhConvertPublicKeyToPublicKeyToken(Byte* pbPublicKey, int cbPublicKey, Byte* pbPublicKeyTokenOut, int cbPublicKeyTokenOut);
    [RuntimeImportAttribute("[MRT]", "RhpETWLogLiveCom")]
internal static void RhpETWLogLiveCom(int eventType, IntPtr CCWHandle, IntPtr objectID, IntPtr typeRawValue, IntPtr IUnknown, IntPtr VTable, int comRefCount, int jupiterRefCount, int flags);
    [RuntimeImportAttribute("[MRT]", "RhpETWShouldWalkCom")]
internal static bool RhpETWShouldWalkCom();
    [RuntimeImportAttribute("[MRT]", "RhpEtwExceptionThrown")]
internal static void RhpEtwExceptionThrown(Char* exceptionTypeName, Char* exceptionMessage, IntPtr faultingIP, long hresult);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "fabs")]
internal static double fabs(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "fabsf")]
internal static float fabsf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "acos")]
internal static double acos(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "acosf")]
internal static float acosf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "acosh")]
internal static double acosh(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "acoshf")]
internal static float acoshf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "asin")]
internal static double asin(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "asinf")]
internal static float asinf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "asinh")]
internal static double asinh(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "asinhf")]
internal static float asinhf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "atan")]
internal static double atan(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "atanf")]
internal static float atanf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "atan2")]
internal static double atan2(double y, double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "atan2f")]
internal static float atan2f(float y, float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "atanh")]
internal static double atanh(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "atanhf")]
internal static float atanhf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "cbrt")]
internal static double cbrt(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "cbrtf")]
internal static float cbrtf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "ceil")]
internal static double ceil(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "ceilf")]
internal static float ceilf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "cos")]
internal static double cos(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "cosf")]
internal static float cosf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "cosh")]
internal static double cosh(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "coshf")]
internal static float coshf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "exp")]
internal static double exp(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "expf")]
internal static float expf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "floor")]
internal static double floor(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "floorf")]
internal static float floorf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "log")]
internal static double log(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "logf")]
internal static float logf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "log10")]
internal static double log10(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "log10f")]
internal static float log10f(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "pow")]
internal static double pow(double x, double y);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "powf")]
internal static float powf(float x, float y);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "sin")]
internal static double sin(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "sinf")]
internal static float sinf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "sinh")]
internal static double sinh(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "sinhf")]
internal static float sinhf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "sqrt")]
internal static double sqrt(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "sqrtf")]
internal static float sqrtf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "tan")]
internal static double tan(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "tanf")]
internal static float tanf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "tanh")]
internal static double tanh(double x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "tanhf")]
internal static float tanhf(float x);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "fmod")]
internal static double fmod(double x, double y);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "fmodf")]
internal static float fmodf(float x, float y);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "modf")]
internal static double modf(double x, Double* intptr);
    [IntrinsicAttribute]
[RuntimeImportAttribute("[MRT]", "modff")]
internal static float modff(float x, Single* intptr);
    internal static void _ecvt_s(Byte* buffer, int sizeInBytes, double value, int count, Int32* dec, Int32* sign);
    internal static void memmove(Byte* dmem, Byte* smem, UInt32 size);
    internal static void memset(Byte* mem, int value, UInt32 size);
    internal static void RhZeroMemory(Byte& b, UInt32 byteLength);
    internal static void RhZeroMemory(IntPtr p, UIntPtr byteLength);
    [RuntimeImportAttribute("[MRT]", "RhpArrayCopy")]
internal static bool TryArrayCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    [RuntimeImportAttribute("[MRT]", "RhpArrayClear")]
internal static bool TryArrayClear(Array array, int index, int length);
    internal static RhCorElementTypeInfo GetRhCorElementTypeInfo(RhCorElementType elementType);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.RuntimeObjectFactory : MulticastDelegate {
    public RuntimeObjectFactory(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr context, IntPtr signature, object contextObject, IntPtr& auxResult);
    public virtual IAsyncResult BeginInvoke(IntPtr context, IntPtr signature, object contextObject, IntPtr& auxResult, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IntPtr& auxResult, IAsyncResult result);
}
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    private int _versionAdded;
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    private List`1<object> _serializedStates;
    [CompilerGeneratedAttribute]
private StreamingContext <StreamingContext>k__BackingField;
    public StreamingContext StreamingContext { get; }
    public void AddSerializedState(ISafeSerializationData serializedState);
    [CompilerGeneratedAttribute]
public StreamingContext get_StreamingContext();
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private string _name;
    private object _value;
    private Type _type;
    public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.Serialization.SerializationException : SystemException {
    private static string s_nullMessage;
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
    private static SerializationException();
}
public class System.Runtime.Serialization.SerializationInfo : object {
    private static int DefaultSize;
    private String[] _names;
    private Object[] _values;
    private Type[] _types;
    private int _count;
    private Dictionary`2<string, int> _nameToIndex;
    private IFormatterConverter _converter;
    private string _rootTypeName;
    private string _rootTypeAssemblyName;
    private Type _rootType;
    [CompilerGeneratedAttribute]
private bool <IsFullTypeNameSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAssemblyNameSetExplicit>k__BackingField;
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public bool IsFullTypeNameSetExplicit { get; private set; }
    public bool IsAssemblyNameSetExplicit { get; private set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFullTypeNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsFullTypeNameSetExplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAssemblyNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsAssemblyNameSetExplicit(bool value);
    public void SetType(Type type);
    public int get_MemberCount();
    public Type get_ObjectType();
    public SerializationInfoEnumerator GetEnumerator();
    private void ExpandArrays();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValueInternal(string name, object value, Type type);
    public void UpdateValue(string name, object value, Type type);
    private int FindElement(string name);
    private object GetElement(string name, Type& foundType);
    private object GetElementNoThrow(string name, Type& foundType);
    public object GetValue(string name, Type type);
    internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
}
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private String[] _members;
    private Object[] _data;
    private Type[] _types;
    private int _numItems;
    private int _currItem;
    private bool _current;
    private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    public object get_Value();
    public Type get_ObjectType();
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _additionalContext;
    private StreamingContextStates _state;
    public StreamingContextStates State { get; }
    public object Context { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
    public object get_Context();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
internal enum System.Runtime.SetLatencyModeStatus : Enum {
    public int value__;
    public static SetLatencyModeStatus Success;
    public static SetLatencyModeStatus FailureNoGC;
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public static class System.Runtime.TypeLoaderExports : object {
    private static Entry[] s_cache;
    private static Lock s_lock;
    private static GCHandle s_previousCache;
    private static int InitialCacheSize;
    private static int DefaultCacheSize;
    private static int MaximumCacheSize;
    private static long s_tickCountOfLastOverflow;
    private static int s_entries;
    private static bool s_roundRobinFlushing;
    [RuntimeExportAttribute("GetThreadStaticsForDynamicType")]
public static IntPtr GetThreadStaticsForDynamicType(int index);
    [RuntimeExportAttribute("ActivatorCreateInstanceAny")]
public static void ActivatorCreateInstanceAny(Object& ptrToData, IntPtr pEETypePtr);
    internal static void Initialize();
    [RuntimeExportAttribute("GenericLookup")]
public static IntPtr GenericLookup(IntPtr context, IntPtr signature);
    [RuntimeExportAttribute("GenericLookupAndCallCtor")]
public static void GenericLookupAndCallCtor(object arg, IntPtr context, IntPtr signature);
    [RuntimeExportAttribute("GenericLookupAndAllocObject")]
public static object GenericLookupAndAllocObject(IntPtr context, IntPtr signature);
    [RuntimeExportAttribute("GenericLookupAndAllocArray")]
public static object GenericLookupAndAllocArray(IntPtr context, IntPtr arg, IntPtr signature);
    [RuntimeExportAttribute("GenericLookupAndCheckArrayElemType")]
public static void GenericLookupAndCheckArrayElemType(IntPtr context, object arg, IntPtr signature);
    [RuntimeExportAttribute("GenericLookupAndCast")]
public static object GenericLookupAndCast(object arg, IntPtr context, IntPtr signature);
    [RuntimeExportAttribute("UpdateTypeFloatingDictionary")]
public static IntPtr UpdateTypeFloatingDictionary(IntPtr eetypePtr, IntPtr dictionaryPtr);
    [RuntimeExportAttribute("UpdateMethodFloatingDictionary")]
public static IntPtr UpdateMethodFloatingDictionary(IntPtr dictionaryPtr);
    public static IntPtr GetDelegateThunk(object delegateObj, int whichThunk);
    public static IntPtr GVMLookupForSlot(object obj, RuntimeMethodHandle slot);
    internal static IntPtr OpenInstanceMethodLookup(IntPtr openResolver, object obj);
    private static Entry LookupInCache(Entry[] cache, IntPtr context, IntPtr signature);
    internal static IntPtr RuntimeCacheLookupInCache(IntPtr context, IntPtr signature, RuntimeObjectFactory factory, object contextObject, IntPtr& auxResult);
    private static Entry CacheMiss(IntPtr ctx, IntPtr sig);
    private static Entry CacheMiss(IntPtr context, IntPtr signature, RuntimeObjectFactory factory, object contextObject);
    private static Entry[] ResizeCacheForNewEntryAsNecessary();
}
[__BlockReflectionAttribute]
public class System.Runtime.TypeManagerHandle : ValueType {
    private IntPtr _handleValue;
    public bool IsNull { get; }
    public bool IsTypeManager { get; }
    private IntPtr AsOsModuleIntPtr { get; }
    private TypeManager* AsTypeManagerPtr { get; }
    public IntPtr OsModuleBase { get; }
    public TypeManagerHandle(IntPtr handleValue);
    public IntPtr GetIntPtrUNSAFE();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(TypeManagerHandle left, TypeManagerHandle right);
    public static bool op_Inequality(TypeManagerHandle left, TypeManagerHandle right);
    public sealed virtual bool Equals(TypeManagerHandle other);
    public bool get_IsNull();
    public bool get_IsTypeManager();
    private IntPtr get_AsOsModuleIntPtr();
    private TypeManager* get_AsTypeManagerPtr();
    public IntPtr get_OsModuleBase();
    [CLSCompliantAttribute("False")]
public Byte* ConvertRVAToPointer(int rva);
    [CLSCompliantAttribute("False")]
public Byte* ConvertRVAToPointer(UInt32 rva);
    public string LowLevelToString();
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    private string _frameworkName;
    private string _frameworkDisplayName;
    public string FrameworkName { get; }
    public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class System.RuntimeExceptionHelpers : object {
    private static ConditionalWeakTable`2<Exception, ExceptionData> s_exceptionDataTable;
    private static int s_currentExceptionId;
    private static GCHandle s_ExceptionInfoBufferPinningHandle;
    private static Lock s_ExceptionInfoBufferLock;
    public static bool SafeToPerformRichExceptionSupport { get; }
    private static RuntimeExceptionHelpers();
    [RuntimeExportAttribute("GetRuntimeException")]
public static Exception GetRuntimeException(ExceptionIDs id);
    private static string GetStringForFailFastReason(RhFailFastReason reason);
    public static void FailFast(string message);
    public static void FailFast(string message, Exception exception);
    public static void ReportUnhandledException(Exception exception);
    [RuntimeExportAttribute("FailFast")]
public static void RuntimeFailFast(RhFailFastReason reason, Exception exception, IntPtr pExAddress, IntPtr pExContext);
    internal static void FailFast(string message, Exception exception, RhFailFastReason reason, IntPtr pExAddress, IntPtr pExContext);
    public static void GenerateExceptionInformationForDump(Exception currentException, IntPtr exceptionCCWPtr);
    private static void SerializeExceptionsForDump(Exception currentException, IntPtr exceptionCCWPtr, LowLevelList`1<Byte[]> serializedExceptions);
    private static void GenerateErrorReportForDump(LowLevelList`1<Byte[]> serializedExceptions);
    public static bool get_SafeToPerformRichExceptionSupport();
    private static void UpdateErrorReportBuffer(Byte[] finalBuffer);
}
public class System.RuntimeFieldHandle : ValueType {
    private IntPtr _value;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    private int _rotl(int value, int shift);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.RuntimeMethodHandle : ValueType {
    private IntPtr _value;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeMethodHandle handle);
    private int _rotl(int value, int shift);
    public virtual int GetHashCode();
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public IntPtr GetFunctionPointer();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.RuntimeTypeHandle : ValueType {
    private IntPtr _value;
    public IntPtr Value { get; }
    internal bool IsNull { get; }
    internal string LastResortToString { get; }
    internal IntPtr RawValue { get; }
    internal RuntimeTypeHandle(EETypePtr pEEType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RuntimeTypeHandle handle);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public IntPtr get_Value();
    public ModuleHandle GetModuleHandle();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal EETypePtr ToEETypePtr();
    internal bool get_IsNull();
    internal string get_LastResortToString();
    [IntrinsicAttribute]
internal static IntPtr GetValueInternal(RuntimeTypeHandle handle);
    internal IntPtr get_RawValue();
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.SByte : ValueType {
    private sbyte m_value;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static sbyte Parse(string s, NumberStyles style, NumberFormatInfo info);
    private static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[FlagsAttribute]
internal enum System.Security.AccessControl.RegistryRights : Enum {
    public int value__;
    public static RegistryRights QueryValues;
    public static RegistryRights SetValue;
    public static RegistryRights CreateSubKey;
    public static RegistryRights EnumerateSubKeys;
    public static RegistryRights Notify;
    public static RegistryRights CreateLink;
    public static RegistryRights ExecuteKey;
    public static RegistryRights ReadKey;
    public static RegistryRights WriteKey;
    public static RegistryRights Delete;
    public static RegistryRights ReadPermissions;
    public static RegistryRights ChangePermissions;
    public static RegistryRights TakeOwnership;
    public static RegistryRights FullControl;
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PartialTrustVisibilityLevel <PartialTrustVisibilityLevel>k__BackingField;
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    [CompilerGeneratedAttribute]
public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    [CompilerGeneratedAttribute]
public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    public CryptographicException(string message);
    public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
internal class System.Security.SafeBSTRHandle : SafeBuffer {
    internal UInt32 Length { get; }
    internal static SafeBSTRHandle Allocate(UInt32 lenInChars);
    protected virtual bool ReleaseHandle();
    internal void ClearBuffer();
    internal UInt32 get_Length();
    internal static void Copy(SafeBSTRHandle source, SafeBSTRHandle target, UInt32 bytesToCopy);
}
public class System.Security.SecureString : object {
    private static int MaxLength;
    private object _methodLock;
    private bool _readOnly;
    private int _decryptedLength;
    private static int BlockSize;
    private SafeBSTRHandle _buffer;
    private bool _encrypted;
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    internal SecureString(SecureString str);
    public int get_Length();
    public void AppendChar(char c);
    public void Clear();
    public SecureString Copy();
    public sealed virtual void Dispose();
    public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    public void RemoveAt(int index);
    public void SetAt(int index, char c);
    private void EnsureNotReadOnly();
    private void EnsureNotDisposed();
    internal IntPtr MarshalToBSTR();
    internal IntPtr MarshalToString(bool globalAlloc, bool unicode);
    private static void MarshalFree(IntPtr ptr, bool globalAlloc);
    private void InitializeSecureString(Char* value, int length);
    private void AppendCharCore(char c);
    private void ClearCore();
    private void DisposeCore();
    private void InsertAtCore(int index, char c);
    private void RemoveAtCore(int index);
    private void SetAtCore(int index, char c);
    internal IntPtr MarshalToBSTRCore();
    internal IntPtr MarshalToStringCore(bool globalAlloc, bool unicode);
    private void AllocateBuffer(UInt32 size);
    private static UInt32 GetAlignedSize(UInt32 size);
    private void EnsureCapacity(int capacity);
    private void ProtectMemory();
    private void UnprotectMemory();
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityCriticalScope <Scope>k__BackingField;
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    [CompilerGeneratedAttribute]
public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.SecurityException : SystemException {
    private static string DemandedName;
    private static string GrantedSetName;
    private static string RefusedSetName;
    private static string DeniedName;
    private static string PermitOnlyName;
    private static string UrlName;
    [CompilerGeneratedAttribute]
private object <Demanded>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DenySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <FailedAssemblyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GrantedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PermissionType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <PermitOnlySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefusedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    protected SecurityException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_Demanded();
    [CompilerGeneratedAttribute]
public void set_Demanded(object value);
    [CompilerGeneratedAttribute]
public object get_DenySetInstance();
    [CompilerGeneratedAttribute]
public void set_DenySetInstance(object value);
    [CompilerGeneratedAttribute]
public AssemblyName get_FailedAssemblyInfo();
    [CompilerGeneratedAttribute]
public void set_FailedAssemblyInfo(AssemblyName value);
    [CompilerGeneratedAttribute]
public string get_GrantedSet();
    [CompilerGeneratedAttribute]
public void set_GrantedSet(string value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public string get_PermissionState();
    [CompilerGeneratedAttribute]
public void set_PermissionState(string value);
    [CompilerGeneratedAttribute]
public Type get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(Type value);
    [CompilerGeneratedAttribute]
public object get_PermitOnlySetInstance();
    [CompilerGeneratedAttribute]
public void set_PermitOnlySetInstance(object value);
    [CompilerGeneratedAttribute]
public string get_RefusedSet();
    [CompilerGeneratedAttribute]
public void set_RefusedSet(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipVerificationInFullTrust>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityRuleSet <RuleSet>k__BackingField;
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    [CompilerGeneratedAttribute]
public bool get_SkipVerificationInFullTrust();
    [CompilerGeneratedAttribute]
public void set_SkipVerificationInFullTrust(bool value);
    [CompilerGeneratedAttribute]
public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    protected VerificationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Single : ValueType {
    private float m_value;
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    internal static float NegativeZero;
    [NonVersionableAttribute]
public static bool IsFinite(float f);
    [NonVersionableAttribute]
public static bool IsInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNaN(float f);
    [NonVersionableAttribute]
public static bool IsNegative(float f);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNormal(float f);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(float f);
    [NonVersionableAttribute]
public static bool IsSubnormal(float f);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    [NonVersionableAttribute]
public static bool op_Equality(float left, float right);
    [NonVersionableAttribute]
public static bool op_Inequality(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(float left, float right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, IFormatProvider provider);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
public class System.Span`1 : ValueType {
    internal ByReference`1<T> _pointer;
    [BoundAttribute]
private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static Span`1<T> Empty { get; }
    public T& Item { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(T& ptr, int length);
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    [BoundsCheckingAttribute]
public T& get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    private static ulong XorPowerOfTwoToHighByte;
    private static ulong XorPowerOfTwoToHighChar;
    public static void ClearWithoutReferences(Byte& b, UInt32 byteLength);
    public static void ClearWithReferences(IntPtr& ip, UInt32 pointerSizeLength);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static bool Contains(Byte& searchSpace, byte value, int length);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, UInt32 length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    private static int LocateLastFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    private static int LocateLastFoundByte(ulong match);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static bool Contains(Char& searchSpace, char value, int length);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    private static int LocateFirstFoundChar(Vector`1<ushort> match);
    private static int LocateFirstFoundChar(ulong match);
    private static int LocateLastFoundChar(Vector`1<ushort> match);
    private static int LocateLastFoundChar(ulong match);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool Contains(T& searchSpace, T value, int length);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_AccessException { get; }
    internal static string Arg_AccessViolationException { get; }
    internal static string Arg_ApplicationException { get; }
    internal static string Arg_ArgumentException { get; }
    internal static string Arg_ArgumentOutOfRangeException { get; }
    internal static string Arg_ArithmeticException { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_ArrayTypeMismatchException { get; }
    internal static string Arg_ArrayZeroError { get; }
    internal static string Arg_BadImageFormatException { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string Arg_CannotBeNaN { get; }
    internal static string Arg_CannotHaveNegativeValue { get; }
    internal static string Arg_CannotMixComparisonInfrastructure { get; }
    internal static string Arg_CopyNonBlittableArray { get; }
    internal static string Arg_CopyOutOfRange { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_DataMisalignedException { get; }
    internal static string Arg_DateTimeRange { get; }
    internal static string Arg_DirectoryNotFoundException { get; }
    internal static string Arg_DecBitCtor { get; }
    internal static string Arg_DivideByZero { get; }
    internal static string Arg_DlgtNullInst { get; }
    internal static string Arg_DlgtTypeMis { get; }
    internal static string Arg_DuplicateWaitObjectException { get; }
    internal static string Arg_EHClauseNotFilter { get; }
    internal static string Arg_EnumAndObjectMustBeSameType { get; }
    internal static string Arg_EntryPointNotFoundException { get; }
    internal static string Arg_EntryPointNotFoundExceptionParameterized { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_ExecutionEngineException { get; }
    internal static string Arg_ExternalException { get; }
    internal static string Arg_FieldAccessException { get; }
    internal static string Arg_FormatException { get; }
    internal static string Arg_GuidArrayCtor { get; }
    internal static string Arg_HexStyleNotSupported { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_InsufficientExecutionStackException { get; }
    internal static string Arg_InvalidBase { get; }
    internal static string Arg_InvalidCastException { get; }
    internal static string Arg_InvalidHexStyle { get; }
    internal static string Arg_InvalidOperationException { get; }
    internal static string Arg_OleAutDateInvalid { get; }
    internal static string Arg_OleAutDateScale { get; }
    internal static string Arg_InvalidRuntimeTypeHandle { get; }
    internal static string Arg_IOException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanSrcString { get; }
    internal static string Arg_LowerBoundsMustMatch { get; }
    internal static string Arg_MissingFieldException { get; }
    internal static string Arg_MethodAccessException { get; }
    internal static string Arg_MissingMemberException { get; }
    internal static string Arg_MissingMethodException { get; }
    internal static string Arg_MulticastNotSupportedException { get; }
    internal static string Arg_MustBeBoolean { get; }
    internal static string Arg_MustBeByte { get; }
    internal static string Arg_MustBeChar { get; }
    internal static string Arg_MustBeDateTime { get; }
    internal static string Arg_MustBeDateTimeOffset { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeDouble { get; }
    internal static string Arg_MustBeEnum { get; }
    internal static string Arg_MustBeGuid { get; }
    internal static string Arg_MustBeInt16 { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeInt64 { get; }
    internal static string Arg_MustBePrimArray { get; }
    internal static string Arg_MustBeSByte { get; }
    internal static string Arg_MustBeSingle { get; }
    internal static string Arg_MustBeStatic { get; }
    internal static string Arg_MustBeString { get; }
    internal static string Arg_MustBeStringPtrNotAtom { get; }
    internal static string Arg_MustBeTimeSpan { get; }
    internal static string Arg_MustBeUInt16 { get; }
    internal static string Arg_MustBeUInt32 { get; }
    internal static string Arg_MustBeUInt64 { get; }
    internal static string Arg_MustBeVersion { get; }
    internal static string Arg_NeedAtLeast1Rank { get; }
    internal static string Arg_Need2DArray { get; }
    internal static string Arg_Need3DArray { get; }
    internal static string Arg_NegativeArgCount { get; }
    internal static string Arg_NotFiniteNumberException { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_NotImplementedException { get; }
    internal static string Arg_NotSupportedException { get; }
    internal static string Arg_NotSupportedNonZeroLowerBound { get; }
    internal static string Arg_NullReferenceException { get; }
    internal static string Arg_ObjObjEx { get; }
    internal static string Arg_OverflowException { get; }
    internal static string Arg_OutOfMemoryException { get; }
    internal static string Arg_PlatformNotSupported { get; }
    internal static string Arg_ParamName_Name { get; }
    internal static string Arg_PathEmpty { get; }
    internal static string Arg_PathIllegalUNC_Path { get; }
    internal static string Arg_RankException { get; }
    internal static string Arg_RankIndices { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_RanksAndBounds { get; }
    internal static string Arg_RegGetOverflowBug { get; }
    internal static string Arg_RegKeyNotFound { get; }
    internal static string Arg_RegInvalidKeyName { get; }
    internal static string Arg_SecurityException { get; }
    internal static string Arg_StackOverflowException { get; }
    internal static string Arg_SynchronizationLockException { get; }
    internal static string Arg_SystemException { get; }
    internal static string Arg_TargetInvocationException { get; }
    internal static string Arg_TargetParameterCountException { get; }
    internal static string Arg_DefaultValueMissingException { get; }
    internal static string Arg_ThreadStartException { get; }
    internal static string Arg_ThreadStateException { get; }
    internal static string Arg_TimeoutException { get; }
    internal static string Arg_TypeAccessException { get; }
    internal static string Arg_TypeLoadException { get; }
    internal static string Arg_UnauthorizedAccessException { get; }
    internal static string Arg_VersionString { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AbsolutePathRequired { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_AdjustmentRulesNoNulls { get; }
    internal static string Argument_AdjustmentRulesOutOfOrder { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_CodepageNotSupported { get; }
    internal static string Argument_CompareOptionOrdinal { get; }
    internal static string Argument_ConflictingDateTimeRoundtripStyles { get; }
    internal static string Argument_ConflictingDateTimeStyles { get; }
    internal static string Argument_ConversionOverflow { get; }
    internal static string Argument_ConvertMismatch { get; }
    internal static string Argument_CultureInvalidIdentifier { get; }
    internal static string Argument_CultureIetfNotSupported { get; }
    internal static string Argument_CultureIsNeutral { get; }
    internal static string Argument_CultureNotSupported { get; }
    internal static string Argument_CustomCultureCannotBePassedByNumber { get; }
    internal static string Argument_DateTimeBadBinaryData { get; }
    internal static string Argument_DateTimeHasTicks { get; }
    internal static string Argument_DateTimeHasTimeOfDay { get; }
    internal static string Argument_DateTimeIsInvalid { get; }
    internal static string Argument_DateTimeIsNotAmbiguous { get; }
    internal static string Argument_DateTimeKindMustBeUnspecified { get; }
    internal static string Argument_DateTimeKindMustBeUnspecifiedOrUtc { get; }
    internal static string Argument_DateTimeOffsetInvalidDateTimeStyles { get; }
    internal static string Argument_DateTimeOffsetIsNotAmbiguous { get; }
    internal static string Argument_EmptyDecString { get; }
    internal static string Argument_EmptyName { get; }
    internal static string Argument_EmptyWaithandleArray { get; }
    internal static string Argument_EncoderFallbackNotEmpty { get; }
    internal static string Argument_EncodingConversionOverflowBytes { get; }
    internal static string Argument_EncodingConversionOverflowChars { get; }
    internal static string Argument_EncodingNotSupported { get; }
    internal static string Argument_EnumTypeDoesNotMatch { get; }
    internal static string Argument_FallbackBufferNotEmpty { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string Argument_InvalidArgumentForComparison { get; }
    internal static string Argument_InvalidArrayLength { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string Argument_InvalidCalendar { get; }
    internal static string Argument_InvalidCharSequence { get; }
    internal static string Argument_InvalidCharSequenceNoIndex { get; }
    internal static string Argument_InvalidCodePageBytesIndex { get; }
    internal static string Argument_InvalidCodePageConversionIndex { get; }
    internal static string Argument_InvalidCultureName { get; }
    internal static string Argument_InvalidDateTimeKind { get; }
    internal static string Argument_InvalidDateTimeStyles { get; }
    internal static string Argument_InvalidDigitSubstitution { get; }
    internal static string Argument_InvalidEnumValue { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidGroupSize { get; }
    internal static string Argument_InvalidHighSurrogate { get; }
    internal static string Argument_InvalidId { get; }
    internal static string Argument_InvalidLowSurrogate { get; }
    internal static string Argument_InvalidNativeDigitCount { get; }
    internal static string Argument_InvalidNativeDigitValue { get; }
    internal static string Argument_InvalidNeutralRegionName { get; }
    internal static string Argument_InvalidNormalizationForm { get; }
    internal static string Argument_InvalidNumberStyles { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidREG_TZI_FORMAT { get; }
    internal static string Argument_InvalidResourceCultureName { get; }
    internal static string Argument_InvalidSerializedString { get; }
    internal static string Argument_InvalidTimeSpanStyles { get; }
    internal static string Argument_MustBeFalse { get; }
    internal static string Argument_MustBeRuntimeType { get; }
    internal static string Argument_NoEra { get; }
    internal static string Argument_NoRegionInvariantCulture { get; }
    internal static string Argument_NotIsomorphic { get; }
    internal static string Argument_OffsetLocalMismatch { get; }
    internal static string Argument_OffsetPrecision { get; }
    internal static string Argument_OffsetOutOfRange { get; }
    internal static string Argument_OffsetUtcMismatch { get; }
    internal static string Argument_OneOfCulturesNotSupported { get; }
    internal static string Argument_OnlyMscorlib { get; }
    internal static string Argument_OutOfOrderDateTimes { get; }
    internal static string ArgumentOutOfRange_HugeArrayNotSupported { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_Length { get; }
    internal static string ArgumentOutOfRange_LengthTooLarge { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string Argument_InvalidTypeName { get; }
    internal static string Argument_PathFormatNotSupported_Path { get; }
    internal static string Argument_RecursiveFallback { get; }
    internal static string Argument_RecursiveFallbackBytes { get; }
    internal static string Argument_ResultCalendarRange { get; }
    internal static string Argument_SemaphoreInitialMaximum { get; }
    internal static string Argument_TimeSpanHasSeconds { get; }
    internal static string Argument_TimeZoneNotFound { get; }
    internal static string Argument_TimeZoneInfoBadTZif { get; }
    internal static string Argument_TimeZoneInfoInvalidTZif { get; }
    internal static string Argument_ToExclusiveLessThanFromExclusive { get; }
    internal static string Argument_TransitionTimesAreIdentical { get; }
    internal static string Argument_UTCOutOfRange { get; }
    internal static string Argument_WaitHandleNameTooLong { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string ArgumentException_TupleIncorrectType { get; }
    internal static string ArgumentException_TupleLastArgumentNotATuple { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    internal static string ArgumentNull_Array { get; }
    internal static string ArgumentNull_ArrayElement { get; }
    internal static string ArgumentNull_ArrayValue { get; }
    internal static string ArgumentNull_Dictionary { get; }
    internal static string ArgumentNull_Generic { get; }
    internal static string ArgumentNull_Key { get; }
    internal static string ArgumentNull_Obj { get; }
    internal static string ArgumentNull_String { get; }
    internal static string ArgumentNull_Type { get; }
    internal static string ArgumentNull_Waithandles { get; }
    internal static string ArgumentOutOfRange_AddValue { get; }
    internal static string ArgumentOutOfRange_ActualValue { get; }
    internal static string ArgumentOutOfRange_BadYearMonthDay { get; }
    internal static string ArgumentOutOfRange_BadHourMinuteSecond { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper { get; }
    internal static string ArgumentOutOfRange_CalendarRange { get; }
    internal static string ArgumentOutOfRange_Capacity { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_DateArithmetic { get; }
    internal static string ArgumentOutOfRange_DateTimeBadMonths { get; }
    internal static string ArgumentOutOfRange_DateTimeBadTicks { get; }
    internal static string ArgumentOutOfRange_DateTimeBadYears { get; }
    internal static string ArgumentOutOfRange_Day { get; }
    internal static string ArgumentOutOfRange_DayOfWeek { get; }
    internal static string ArgumentOutOfRange_DayParam { get; }
    internal static string ArgumentOutOfRange_DecimalRound { get; }
    internal static string ArgumentOutOfRange_DecimalScale { get; }
    internal static string ArgumentOutOfRange_EndIndexStartIndex { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_Era { get; }
    internal static string ArgumentOutOfRange_FileTimeInvalid { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_GetByteCountOverflow { get; }
    internal static string ArgumentOutOfRange_GetCharCountOverflow { get; }
    internal static string ArgumentOutOfRange_HashtableLoadFactor { get; }
    internal static string ArgumentOutOfRange_IndexCount { get; }
    internal static string ArgumentOutOfRange_IndexCountBuffer { get; }
    internal static string ArgumentOutOfRange_IndexLength { get; }
    internal static string ArgumentOutOfRange_IndexString { get; }
    internal static string ArgumentOutOfRange_InvalidEraValue { get; }
    internal static string ArgumentOutOfRange_InvalidHighSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidLowSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidUTF32 { get; }
    internal static string ArgumentOutOfRange_LengthGreaterThanCapacity { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_ListItem { get; }
    internal static string ArgumentOutOfRange_ListRemoveAt { get; }
    internal static string ArgumentOutOfRange_Month { get; }
    internal static string ArgumentOutOfRange_MonthParam { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegInt32 { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ArgumentOutOfRange_NegativeCapacity { get; }
    internal static string ArgumentOutOfRange_NegativeCount { get; }
    internal static string ArgumentOutOfRange_NegativeLength { get; }
    internal static string ArgumentOutOfRange_NoGCLohSizeGreaterTotalSize { get; }
    internal static string ArgumentOutOfRange_OffsetLength { get; }
    internal static string ArgumentOutOfRange_OffsetOut { get; }
    internal static string ArgumentOutOfRange_PartialWCHAR { get; }
    internal static string ArgumentOutOfRange_Range { get; }
    internal static string ArgumentOutOfRange_RoundingDigits { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string ArgumentOutOfRange_SmallMaxCapacity { get; }
    internal static string ArgumentOutOfRange_StartIndex { get; }
    internal static string ArgumentOutOfRange_StartIndexLargerThanLength { get; }
    internal static string ArgumentOutOfRange_StartIndexLessThanLength { get; }
    internal static string ArgumentOutOfRange_UtcOffset { get; }
    internal static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta { get; }
    internal static string ArgumentOutOfRange_Version { get; }
    internal static string ArgumentOutOfRange_Week { get; }
    internal static string ArgumentOutOfRange_Year { get; }
    internal static string Arithmetic_NaN { get; }
    internal static string ArrayTypeMismatch_CantAssignType { get; }
    internal static string BadImageFormatException_CouldNotLoadFileOrAssembly { get; }
    internal static string CollectionCorrupted { get; }
    internal static string Exception_EndOfInnerExceptionStack { get; }
    internal static string Exception_WasThrown { get; }
    internal static string Format_BadBase64Char { get; }
    internal static string Format_BadBase64CharArrayLength { get; }
    internal static string Format_BadBoolean { get; }
    internal static string Format_BadFormatSpecifier { get; }
    internal static string Format_NoFormatSpecifier { get; }
    internal static string Format_BadQuote { get; }
    internal static string Format_EmptyInputString { get; }
    internal static string Format_GuidHexPrefix { get; }
    internal static string Format_GuidInvLen { get; }
    internal static string Format_GuidInvalidChar { get; }
    internal static string Format_GuidBrace { get; }
    internal static string Format_GuidComma { get; }
    internal static string Format_GuidBraceAfterLastNumber { get; }
    internal static string Format_GuidDashes { get; }
    internal static string Format_GuidEndBrace { get; }
    internal static string Format_ExtraJunkAtEnd { get; }
    internal static string Format_GuidUnrecognized { get; }
    internal static string Format_IndexOutOfRange { get; }
    internal static string Format_InvalidGuidFormatSpecification { get; }
    internal static string Format_InvalidString { get; }
    internal static string Format_NeedSingleChar { get; }
    internal static string Format_NoParsibleDigits { get; }
    internal static string Format_BadTimeSpan { get; }
    internal static string InsufficientMemory_MemFailPoint { get; }
    internal static string InsufficientMemory_MemFailPoint_TooBig { get; }
    internal static string InsufficientMemory_MemFailPoint_VAFrag { get; }
    internal static string InvalidCast_CannotCastNullToValueType { get; }
    internal static string InvalidCast_DownCastArrayElement { get; }
    internal static string InvalidCast_FromTo { get; }
    internal static string InvalidCast_IConvertible { get; }
    internal static string InvalidCast_StoreArrayElement { get; }
    internal static string InvalidOperation_Calling { get; }
    internal static string InvalidOperation_DateTimeParsing { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_HandleIsNotInitialized { get; }
    internal static string InvalidOperation_HashInsertFailed { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static string InvalidOperation_NullArray { get; }
    internal static string InvalidOperation_Overlapped_Pack { get; }
    internal static string InvalidOperation_ReadOnly { get; }
    internal static string InvalidOperation_ThreadWrongThreadStart { get; }
    internal static string InvalidOperation_UnknownEnumType { get; }
    internal static string InvalidOperation_WriteOnce { get; }
    internal static string InvalidOperation_ArrayCreateInstance_NotARuntimeType { get; }
    internal static string InvalidOperation_TooEarly { get; }
    internal static string InvalidOperation_NullContext { get; }
    internal static string InvalidOperation_CannotUseAFCOtherThread { get; }
    internal static string InvalidOperation_CannotRestoreUnsupressedFlow { get; }
    internal static string InvalidOperation_CannotSupressFlowMultipleTimes { get; }
    internal static string InvalidOperation_CannotUseAFCMultiple { get; }
    internal static string InvalidOperation_AsyncFlowCtrlCtxMismatch { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string InvalidProgram_Default { get; }
    internal static string InvalidProgram_Specific { get; }
    internal static string InvalidProgram_Vararg { get; }
    internal static string InvalidProgram_CallVirtFinalize { get; }
    internal static string InvalidProgram_NativeCallable { get; }
    internal static string InvalidTimeZone_InvalidRegistryData { get; }
    internal static string InvalidTimeZone_InvalidFileData { get; }
    internal static string InvalidTimeZone_InvalidJulianDay { get; }
    internal static string InvalidTimeZone_NJulianDayNotSupported { get; }
    internal static string InvalidTimeZone_NoTTInfoStructures { get; }
    internal static string InvalidTimeZone_UnparseablePosixMDateString { get; }
    internal static string IO_DriveNotFound_Drive { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileName_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_FileLoad { get; }
    internal static string IO_FileLoad_FileName { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_PathTooLong_Path { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string Lazy_CreateValue_NoParameterlessCtorForT { get; }
    internal static string Lazy_ctor_ModeInvalid { get; }
    internal static string Lazy_StaticInit_InvalidOperation { get; }
    internal static string Lazy_ToString_ValueNotCreated { get; }
    internal static string Lazy_Value_RecursiveCallsToValue { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MustUseCCRewrite { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string NotSupported_MaxWaitHandles { get; }
    internal static string NotSupported_NoCodepageData { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string NotSupported_StringComparison { get; }
    internal static string NotSupported_VoidArray { get; }
    internal static string NotSupported_ByRefLike { get; }
    internal static string NotSupported_Type { get; }
    internal static string NotSupported_WaitAllSTAThread { get; }
    internal static string ObjectDisposed_Generic { get; }
    internal static string ObjectDisposed_ObjectName_Name { get; }
    internal static string Overflow_Byte { get; }
    internal static string Overflow_Char { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Double { get; }
    internal static string Overflow_TimeSpanElementTooLarge { get; }
    internal static string Overflow_Duration { get; }
    internal static string Overflow_Int16 { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_NegateTwosCompNum { get; }
    internal static string Overflow_NegativeUnsigned { get; }
    internal static string Overflow_SByte { get; }
    internal static string Overflow_Single { get; }
    internal static string Overflow_TimeSpanTooLong { get; }
    internal static string Overflow_UInt16 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string Rank_MultiDimNotSupported { get; }
    internal static string RuntimeWrappedException { get; }
    internal static string SpinWait_SpinUntil_ArgumentNull { get; }
    internal static string Serialization_CorruptField { get; }
    internal static string Serialization_InvalidData { get; }
    internal static string Serialization_InvalidEscapeSequence { get; }
    internal static string Serialization_InvalidType { get; }
    internal static string SpinWait_SpinUntil_TimeoutWrong { get; }
    internal static string Threading_AbandonedMutexException { get; }
    internal static string Threading_SemaphoreFullException { get; }
    internal static string Threading_ThreadInterrupted { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle { get; }
    internal static string TimeZoneNotFound_MissingData { get; }
    internal static string TypeInitialization_Default { get; }
    internal static string TypeInitialization_Type { get; }
    internal static string TypeInitialization_Type_NoTypeAvailable { get; }
    internal static string Verification_Exception { get; }
    internal static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Format_InvalidEnumFormatSpecification { get; }
    internal static string Arg_MustBeEnumBaseTypeOrEnum { get; }
    internal static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_MustBeType { get; }
    internal static string Arg_MustContainEnumInfo { get; }
    internal static string Arg_EnumValueNotFound { get; }
    internal static string Argument_StringZeroLength { get; }
    internal static string Argument_StringFirstCharIsZero { get; }
    internal static string Argument_LongEnvVarValue { get; }
    internal static string Argument_IllegalEnvVarName { get; }
    internal static string AssumptionFailed { get; }
    internal static string AssumptionFailed_Cnd { get; }
    internal static string AssertionFailed { get; }
    internal static string AssertionFailed_Cnd { get; }
    internal static string PreconditionFailed { get; }
    internal static string PreconditionFailed_Cnd { get; }
    internal static string PostconditionFailed { get; }
    internal static string PostconditionFailed_Cnd { get; }
    internal static string PostconditionOnExceptionFailed { get; }
    internal static string PostconditionOnExceptionFailed_Cnd { get; }
    internal static string InvariantFailed { get; }
    internal static string InvariantFailed_Cnd { get; }
    internal static string MissingEncodingNameResource { get; }
    internal static string Globalization_cp_1200 { get; }
    internal static string Globalization_cp_1201 { get; }
    internal static string Globalization_cp_12000 { get; }
    internal static string Globalization_cp_12001 { get; }
    internal static string Globalization_cp_20127 { get; }
    internal static string Globalization_cp_28591 { get; }
    internal static string Globalization_cp_65000 { get; }
    internal static string Globalization_cp_65001 { get; }
    internal static string DebugAssertBanner { get; }
    internal static string DebugAssertLongMessage { get; }
    internal static string DebugAssertShortMessage { get; }
    internal static string InvalidCast_Empty { get; }
    internal static string Arg_UnknownTypeCode { get; }
    internal static string Format_BadDatePattern { get; }
    internal static string Format_BadDateTime { get; }
    internal static string Format_BadDateTimeCalendar { get; }
    internal static string Format_BadDayOfWeek { get; }
    internal static string Format_DateOutOfRange { get; }
    internal static string Format_MissingIncompleteDate { get; }
    internal static string Format_OffsetOutOfRange { get; }
    internal static string Format_RepeatDateTimePattern { get; }
    internal static string Format_UnknownDateTimeWord { get; }
    internal static string Format_UTCOutOfRange { get; }
    internal static string RFLCT_Ambiguous { get; }
    internal static string AggregateException_ctor_DefaultMessage { get; }
    internal static string AggregateException_ctor_InnerExceptionNull { get; }
    internal static string AggregateException_DeserializationFailure { get; }
    internal static string AggregateException_InnerException { get; }
    internal static string ArgumentOutOfRange_TimeoutTooLarge { get; }
    internal static string ArgumentOutOfRange_PeriodTooLarge { get; }
    internal static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent { get; }
    internal static string TaskScheduler_ExecuteTask_WrongTaskScheduler { get; }
    internal static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline { get; }
    internal static string TaskSchedulerException_ctor_DefaultMessage { get; }
    internal static string Task_MultiTaskContinuation_FireOptions { get; }
    internal static string Task_ContinueWith_ESandLR { get; }
    internal static string Task_MultiTaskContinuation_EmptyTaskList { get; }
    internal static string Task_MultiTaskContinuation_NullTask { get; }
    internal static string Task_FromAsync_PreferFairness { get; }
    internal static string Task_FromAsync_LongRunning { get; }
    internal static string AsyncMethodBuilder_InstanceNotInitialized { get; }
    internal static string TaskT_TransitionToFinal_AlreadyCompleted { get; }
    internal static string TaskT_DebuggerNoResult { get; }
    internal static string OperationCanceled { get; }
    internal static string CancellationToken_CreateLinkedToken_TokensIsEmpty { get; }
    internal static string CancellationTokenSource_Disposed { get; }
    internal static string CancellationToken_SourceDisposed { get; }
    internal static string TaskExceptionHolder_UnknownExceptionType { get; }
    internal static string TaskExceptionHolder_UnhandledException { get; }
    internal static string Task_Delay_InvalidMillisecondsDelay { get; }
    internal static string Task_Delay_InvalidDelay { get; }
    internal static string Task_Dispose_NotCompleted { get; }
    internal static string Task_WaitMulti_NullTask { get; }
    internal static string Task_ContinueWith_NotOnAnything { get; }
    internal static string Task_RunSynchronously_AlreadyStarted { get; }
    internal static string Task_ThrowIfDisposed { get; }
    internal static string Task_RunSynchronously_TaskCompleted { get; }
    internal static string Task_RunSynchronously_Promise { get; }
    internal static string Task_RunSynchronously_Continuation { get; }
    internal static string Task_Start_AlreadyStarted { get; }
    internal static string Task_Start_ContinuationTask { get; }
    internal static string Task_Start_Promise { get; }
    internal static string Task_Start_TaskCompleted { get; }
    internal static string TaskCanceledException_ctor_DefaultMessage { get; }
    internal static string TaskCompletionSourceT_TrySetException_NoExceptions { get; }
    internal static string TaskCompletionSourceT_TrySetException_NullException { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string ExecutionContext_ExceptionInAsyncLocalNotification { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndCalledMultiple { get; }
    internal static string SpinLock_IsHeldByCurrentThread { get; }
    internal static string SpinLock_TryEnter_LockRecursionException { get; }
    internal static string SpinLock_Exit_SynchronizationLockException { get; }
    internal static string SpinLock_TryReliableEnter_ArgumentException { get; }
    internal static string SpinLock_TryEnter_ArgumentOutOfRange { get; }
    internal static string ManualResetEventSlim_Disposed { get; }
    internal static string ManualResetEventSlim_ctor_SpinCountOutOfRange { get; }
    internal static string ManualResetEventSlim_ctor_TooManyWaiters { get; }
    internal static string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext { get; }
    internal static string SemaphoreSlim_Disposed { get; }
    internal static string SemaphoreSlim_Release_CountWrong { get; }
    internal static string SemaphoreSlim_Wait_TimeoutWrong { get; }
    internal static string SemaphoreSlim_ctor_MaxCountWrong { get; }
    internal static string SemaphoreSlim_ctor_InitialCountWrong { get; }
    internal static string ThreadLocal_ValuesNotAvailable { get; }
    internal static string ThreadLocal_Value_RecursiveCallsToValue { get; }
    internal static string ThreadLocal_Disposed { get; }
    internal static string LockRecursionException_WriteAfterReadNotAllowed { get; }
    internal static string LockRecursionException_RecursiveWriteNotAllowed { get; }
    internal static string LockRecursionException_ReadAfterWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveUpgradeNotAllowed { get; }
    internal static string LockRecursionException_RecursiveReadNotAllowed { get; }
    internal static string SynchronizationLockException_IncorrectDispose { get; }
    internal static string SynchronizationLockException_MisMatchedWrite { get; }
    internal static string LockRecursionException_UpgradeAfterReadNotAllowed { get; }
    internal static string LockRecursionException_UpgradeAfterWriteNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedUpgrade { get; }
    internal static string SynchronizationLockException_MisMatchedRead { get; }
    internal static string InvalidOperation_TimeoutsNotSupported { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string InvalidOperation_NoPublicRemoveMethod { get; }
    internal static string InvalidOperation_NoPublicAddMethod { get; }
    internal static string SerializationException { get; }
    internal static string Serialization_NotFound { get; }
    internal static string Serialization_OptionalFieldVersionValue { get; }
    internal static string Serialization_SameNameTwice { get; }
    internal static string NotSupported_AbstractNonCLS { get; }
    internal static string NotSupported_NoTypeInfo { get; }
    internal static string Arg_CustomAttributeFormatException { get; }
    internal static string Argument_InvalidMemberForNamedArgument { get; }
    internal static string Arg_InvalidFilterCriteriaException { get; }
    internal static string Arg_ParmArraySize { get; }
    internal static string Arg_MustBePointer { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Argument_InvalidEnum { get; }
    internal static string Argument_MustHaveAttributeBaseClass { get; }
    internal static string InvalidFilterCriteriaException_CritString { get; }
    internal static string InvalidFilterCriteriaException_CritInt { get; }
    internal static string InvalidOperation_NotSupportedOnWinRTEvent { get; }
    internal static string PlatformNotSupported_ReflectionOnly { get; }
    internal static string PlatformNotSupported_OSXFileLocking { get; }
    internal static string PlatformNotSupported_ReflectionEmit { get; }
    internal static string MissingMember_Name { get; }
    internal static string MissingMethod_Name { get; }
    internal static string MissingField_Name { get; }
    internal static string Format_StringZeroLength { get; }
    internal static string Security_CannotReadFileData { get; }
    internal static string Security_CannotReadRegistryData { get; }
    internal static string Security_InvalidAssemblyPublicKey { get; }
    internal static string Security_RegistryPermission { get; }
    internal static string ClassLoad_General { get; }
    internal static string ClassLoad_RankTooLarge { get; }
    internal static string ClassLoad_ExplicitGeneric { get; }
    internal static string ClassLoad_BadFormat { get; }
    internal static string ClassLoad_ValueClassTooLarge { get; }
    internal static string ClassLoad_ExplicitLayout { get; }
    internal static string EE_MissingMethod { get; }
    internal static string EE_MissingField { get; }
    internal static string UnauthorizedAccess_RegistryKeyGeneric_Key { get; }
    internal static string UnknownError_Num { get; }
    internal static string Argument_NeedStructWithNoRefs { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_AddressSpace { get; }
    internal static string ArgumentOutOfRange_UIntPtrMax { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string InvalidOperation_MustCallInitialize { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    internal static string Argument_InvalidSafeBufferOffLen { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_NotEnoughBytesToRead { get; }
    internal static string Argument_NotEnoughBytesToWrite { get; }
    internal static string Argument_OffsetAndCapacityOutOfBounds { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamLength { get; }
    internal static string Argument_UnmanagedMemAccessorWrapAround { get; }
    internal static string ArgumentOutOfRange_StreamLength { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround { get; }
    internal static string InvalidOperation_CalledTwice { get; }
    internal static string IO_FixedCapacity { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string IO_StreamTooLong { get; }
    internal static string Arg_BadDecimal { get; }
    internal static string NotSupported_Reading { get; }
    internal static string NotSupported_UmsSafeBuffer { get; }
    internal static string NotSupported_Writing { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string IndexOutOfRange_UMSPosition { get; }
    internal static string ObjectDisposed_ViewAccessorClosed { get; }
    internal static string ArgumentOutOfRange_PositionLessThanCapacityRequired { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string Arg_EndOfStreamException { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string Arg_InvalidSearchPattern { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string Argument_InvalidHandle { get; }
    internal static string Argument_AlreadyBoundOrSyncHandle { get; }
    internal static string Argument_PreAllocatedAlreadyAllocated { get; }
    internal static string Argument_NativeOverlappedAlreadyFree { get; }
    internal static string Argument_NativeOverlappedWrongBoundHandle { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string IO_FileStreamHandlePosition { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string NotSupported_FileStreamOnNonFiles { get; }
    internal static string IO_BindHandleFailed { get; }
    internal static string Arg_HandleNotSync { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_FileTooLongOrHandleNotSync { get; }
    internal static string IndexOutOfRange_IORaceCondition { get; }
    internal static string Arg_ResourceFileUnsupportedVersion { get; }
    internal static string Resources_StreamNotValid { get; }
    internal static string BadImageFormat_ResourcesHeaderCorrupted { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string BadImageFormat_NegativeStringLength { get; }
    internal static string BadImageFormat_ResourcesNameInvalidOffset { get; }
    internal static string BadImageFormat_TypeMismatch { get; }
    internal static string BadImageFormat_ResourceNameCorrupted_NameIndex { get; }
    internal static string BadImageFormat_ResourcesDataInvalidOffset { get; }
    internal static string Format_Bad7BitInt32 { get; }
    internal static string BadImageFormat_InvalidType { get; }
    internal static string ResourceReaderIsClosed { get; }
    internal static string Arg_MissingManifestResourceException { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_NullKey { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string NotSupported_MemStreamNotExpandable { get; }
    internal static string ArgumentNull_Stream { get; }
    internal static string IO_InvalidStringLen_Len { get; }
    internal static string ArgumentOutOfRange_BinaryReaderFillBuffer { get; }
    internal static string Serialization_InsufficientDeserializationState { get; }
    internal static string NotSupported_UnitySerHolder { get; }
    internal static string Serialization_UnableToFindModule { get; }
    internal static string Argument_InvalidUnity { get; }
    internal static string InvalidOperation_InvalidHandle { get; }
    internal static string PlatformNotSupported_NamedSynchronizationPrimitives { get; }
    internal static string InvalidOperation_EmptyQueue { get; }
    internal static string Overflow_MutexReacquireCount { get; }
    internal static string Serialization_InsufficientState { get; }
    internal static string Serialization_UnknownMember { get; }
    internal static string Serialization_NullSignature { get; }
    internal static string Serialization_MemberTypeNotRecognized { get; }
    internal static string Serialization_BadParameterInfo { get; }
    internal static string Serialization_NoParameterInfo { get; }
    internal static string ArgumentNull_Assembly { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc { get; }
    internal static string Arg_InvalidSatelliteContract_Asm_Ver { get; }
    internal static string Arg_ResMgrNotResSet { get; }
    internal static string BadImageFormat_ResourceNameCorrupted { get; }
    internal static string BadImageFormat_ResourcesNameTooLong { get; }
    internal static string InvalidOperation_ResMgrBadResSet_Type { get; }
    internal static string InvalidOperation_ResourceNotStream_Name { get; }
    internal static string MissingManifestResource_MultipleBlobs { get; }
    internal static string MissingManifestResource_NoNeutralAsm { get; }
    internal static string MissingManifestResource_NoNeutralDisk { get; }
    internal static string MissingManifestResource_NoPRIresources { get; }
    internal static string MissingManifestResource_ResWFileNotLoaded { get; }
    internal static string MissingSatelliteAssembly_Culture_Name { get; }
    internal static string MissingSatelliteAssembly_Default { get; }
    internal static string NotSupported_ObsoleteResourcesFile { get; }
    internal static string NotSupported_ResourceObjectSerialization { get; }
    internal static string ObjectDisposed_ResourceSet { get; }
    internal static string Arg_ResourceNameNotExist { get; }
    internal static string BadImageFormat_ResourceDataLengthInvalid { get; }
    internal static string BadImageFormat_ResourcesIndexTooLong { get; }
    internal static string InvalidOperation_ResourceNotString_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Type { get; }
    internal static string NotSupported_WrongResourceReader_Type { get; }
    internal static string Arg_MustBeDelegate { get; }
    internal static string NotSupported_GlobalMethodSerialization { get; }
    internal static string NotSupported_DelegateSerHolderSerial { get; }
    internal static string DelegateSer_InsufficientMetadata { get; }
    internal static string Argument_NoUninitializedStrings { get; }
    internal static string ArgumentOutOfRangeException_NoGCRegionSizeTooLarge { get; }
    internal static string InvalidOperationException_AlreadyInNoGCRegion { get; }
    internal static string InvalidOperationException_NoGCRegionAllocationExceeded { get; }
    internal static string InvalidOperationException_NoGCRegionInduced { get; }
    internal static string InvalidOperationException_NoGCRegionNotInProgress { get; }
    internal static string InvalidOperationException_SetLatencyModeNoGC { get; }
    internal static string InvalidOperation_NotWithConcurrentGC { get; }
    internal static string ThreadState_AlreadyStarted { get; }
    internal static string ThreadState_Dead_Priority { get; }
    internal static string ThreadState_Dead_State { get; }
    internal static string ThreadState_NotStarted { get; }
    internal static string ThreadState_SetPriorityFailed { get; }
    internal static string Serialization_InvalidFieldState { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Acc_CreateAbst { get; }
    internal static string Acc_CreateGeneric { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string NotSupported_ManagedActivation { get; }
    internal static string PlatformNotSupported_ResourceManager_ResWFileUnsupportedMethod { get; }
    internal static string PlatformNotSupported_ResourceManager_ResWFileUnsupportedProperty { get; }
    internal static string Serialization_NonSerType { get; }
    internal static string InvalidCast_DBNull { get; }
    internal static string NotSupported_NYI { get; }
    internal static string Delegate_GarbageCollected { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string NotSupported_ChangeType { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string MissingMember { get; }
    internal static string MissingField { get; }
    internal static string InvalidCast_FromDBNull { get; }
    internal static string NotSupported_DBNullSerial { get; }
    internal static string Serialization_StringBuilderCapacity { get; }
    internal static string Serialization_StringBuilderMaxCapacity { get; }
    internal static string PlatformNotSupported_Remoting { get; }
    internal static string PlatformNotSupported_StrongNameSigning { get; }
    internal static string Serialization_MissingDateTimeData { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Serialization_DateTimeTicksOutOfRange { get; }
    internal static string FeatureRemoved_Message { get; }
    internal static string Arg_InvalidANSIString { get; }
    internal static string Arg_MustBeNullTerminatedString { get; }
    internal static string PlatformNotSupported_ArgIterator { get; }
    internal static string Arg_TypeUnloadedException { get; }
    internal static string Overflow_Currency { get; }
    internal static string PlatformNotSupported_SecureBinarySerialization { get; }
    internal static string Serialization_InvalidPtrValue { get; }
    internal static string Serialization_KeyValueDifferentSizes { get; }
    internal static string EventSource_AbstractMustNotDeclareEventMethods { get; }
    internal static string EventSource_AbstractMustNotDeclareKTOC { get; }
    internal static string EventSource_AddScalarOutOfRange { get; }
    internal static string EventSource_BadHexDigit { get; }
    internal static string EventSource_ChannelTypeDoesNotMatchEventChannelValue { get; }
    internal static string EventSource_DataDescriptorsOutOfRange { get; }
    internal static string EventSource_DuplicateStringKey { get; }
    internal static string EventSource_EnumKindMismatch { get; }
    internal static string EventSource_EvenHexDigits { get; }
    internal static string EventSource_EventChannelOutOfRange { get; }
    internal static string EventSource_EventIdReused { get; }
    internal static string EventSource_EventMustHaveTaskIfNonDefaultOpcode { get; }
    internal static string EventSource_EventMustNotBeExplicitImplementation { get; }
    internal static string EventSource_EventNameDoesNotEqualTaskPlusOpcode { get; }
    internal static string EventSource_EventNameReused { get; }
    internal static string EventSource_EventParametersMismatch { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_EventTooBig { get; }
    internal static string EventSource_EventWithAdminChannelMustHaveMessage { get; }
    internal static string EventSource_IllegalKeywordsValue { get; }
    internal static string EventSource_IllegalOpcodeValue { get; }
    internal static string EventSource_IllegalTaskValue { get; }
    internal static string EventSource_IllegalValue { get; }
    internal static string EventSource_IncorrentlyAuthoredTypeInfo { get; }
    internal static string EventSource_InvalidCommand { get; }
    internal static string EventSource_InvalidEventFormat { get; }
    internal static string EventSource_KeywordCollision { get; }
    internal static string EventSource_KeywordNeedPowerOfTwo { get; }
    internal static string EventSource_ListenerCreatedInsideCallback { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_MaxChannelExceeded { get; }
    internal static string EventSource_MismatchIdToWriteEvent { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedPositiveId { get; }
    internal static string EventSource_NoFreeBuffers { get; }
    internal static string EventSource_NonCompliantTypeError { get; }
    internal static string EventSource_NoRelatedActivityId { get; }
    internal static string EventSource_NotSupportedArrayOfBinary { get; }
    internal static string EventSource_NotSupportedArrayOfNil { get; }
    internal static string EventSource_NotSupportedArrayOfNullTerminatedString { get; }
    internal static string EventSource_NotSupportedCustomSerializedData { get; }
    internal static string EventSource_NotSupportedNestedArraysEnums { get; }
    internal static string EventSource_NullInput { get; }
    internal static string EventSource_OpcodeCollision { get; }
    internal static string EventSource_PinArrayOutOfRange { get; }
    internal static string EventSource_RecursiveTypeDefinition { get; }
    internal static string EventSource_SessionIdError { get; }
    internal static string EventSource_StopsFollowStarts { get; }
    internal static string EventSource_TaskCollision { get; }
    internal static string EventSource_TaskOpcodePairReused { get; }
    internal static string EventSource_TooManyArgs { get; }
    internal static string EventSource_TooManyFields { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_TraitEven { get; }
    internal static string EventSource_TypeMustBeSealedOrAbstract { get; }
    internal static string EventSource_TypeMustDeriveFromEventSource { get; }
    internal static string EventSource_UndefinedChannel { get; }
    internal static string EventSource_UndefinedKeyword { get; }
    internal static string EventSource_UndefinedOpcode { get; }
    internal static string EventSource_UnknownEtwTrait { get; }
    internal static string EventSource_UnsupportedEventTypeInManifest { get; }
    internal static string EventSource_UnsupportedMessageProperty { get; }
    internal static string EventSource_VarArgsParameterMismatch { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Arg_SurrogatesNotAllowedAsSingleChar { get; }
    internal static string CustomAttributeFormat_InvalidFieldFail { get; }
    internal static string CustomAttributeFormat_InvalidPropertyFail { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_OverlapAlignmentMismatch { get; }
    internal static string ArrayTypeMismatch_ConstrainedCopy { get; }
    internal static string Arg_DllNotFoundException { get; }
    internal static string Arg_DllNotFoundExceptionParameterized { get; }
    internal static string Arg_DriveNotFoundException { get; }
    internal static string WrongSizeArrayInNStruct { get; }
    internal static string Arg_InteropMarshalUnmappableChar { get; }
    internal static string Arg_MarshalDirectiveException { get; }
    internal static string Arg_RegSubKeyValueAbsent { get; }
    internal static string Arg_RegValStrLenBug { get; }
    internal static string Serialization_DelegatesNotSupported { get; }
    internal static string Arg_OpenType { get; }
    internal static string Arg_PlatformNotSupported_AssemblyName_GetAssemblyName { get; }
    internal static string NotSupported_OpenType { get; }
    internal static string NotSupported_ByRefLikeArray { get; }
    internal static string StackTrace_AtWord { get; }
    internal static string StackTrace_EndStackTraceFromPreviousThrow { get; }
    internal static string InvalidAssemblyName { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string Argument_IdnBadBidi { get; }
    internal static string Argument_IdnBadLabelSize { get; }
    internal static string Argument_IdnBadNameSize { get; }
    internal static string Argument_IdnBadPunycode { get; }
    internal static string Argument_IdnBadStd3 { get; }
    internal static string Argument_IdnIllegalName { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string NotSupported_SignatureType { get; }
    internal static string MemoryDisposed { get; }
    internal static string Memory_OutstandingReferences { get; }
    internal static string HashCode_HashCodeNotSupported { get; }
    internal static string HashCode_EqualityNotSupported { get; }
    internal static string ObjectDisposed_WriterClosed { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string IO_InvalidReadLength { get; }
    internal static string Arg_BasePathNotFullyQualified { get; }
    internal static string Arg_ElementsInSourceIsGreaterThanDestination { get; }
    internal static string Arg_TypeNotSupported { get; }
    internal static string Arg_NullArgumentNullRef { get; }
    internal static string Arg_InsufficientNumberOfElements { get; }
    internal static string NullReference_InvokeNullRefReturned { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string Thread_Operation_RequiresCurrentThread { get; }
    internal static string ConcurrentCollection_SyncRoot_NotSupported { get; }
    internal static string Arg_WrongAsyncResult { get; }
    internal static string InvalidOperation_EndReadCalledMultiple { get; }
    internal static string InvalidOperation_EndWriteCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple { get; }
    internal static string ArgumentOutOfRange_Week_ISO { get; }
    internal static Type ResourceType { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_AccessException();
    internal static string get_Arg_AccessViolationException();
    internal static string get_Arg_ApplicationException();
    internal static string get_Arg_ArgumentException();
    internal static string get_Arg_ArgumentOutOfRangeException();
    internal static string get_Arg_ArithmeticException();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_ArrayTypeMismatchException();
    internal static string get_Arg_ArrayZeroError();
    internal static string get_Arg_BadImageFormatException();
    internal static string get_Arg_BogusIComparer();
    internal static string get_Arg_CannotBeNaN();
    internal static string get_Arg_CannotHaveNegativeValue();
    internal static string get_Arg_CannotMixComparisonInfrastructure();
    internal static string get_Arg_CopyNonBlittableArray();
    internal static string get_Arg_CopyOutOfRange();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_DataMisalignedException();
    internal static string get_Arg_DateTimeRange();
    internal static string get_Arg_DirectoryNotFoundException();
    internal static string get_Arg_DecBitCtor();
    internal static string get_Arg_DivideByZero();
    internal static string get_Arg_DlgtNullInst();
    internal static string get_Arg_DlgtTypeMis();
    internal static string get_Arg_DuplicateWaitObjectException();
    internal static string get_Arg_EHClauseNotFilter();
    internal static string get_Arg_EnumAndObjectMustBeSameType();
    internal static string get_Arg_EntryPointNotFoundException();
    internal static string get_Arg_EntryPointNotFoundExceptionParameterized();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_ExecutionEngineException();
    internal static string get_Arg_ExternalException();
    internal static string get_Arg_FieldAccessException();
    internal static string get_Arg_FormatException();
    internal static string get_Arg_GuidArrayCtor();
    internal static string get_Arg_HexStyleNotSupported();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_InsufficientExecutionStackException();
    internal static string get_Arg_InvalidBase();
    internal static string get_Arg_InvalidCastException();
    internal static string get_Arg_InvalidHexStyle();
    internal static string get_Arg_InvalidOperationException();
    internal static string get_Arg_OleAutDateInvalid();
    internal static string get_Arg_OleAutDateScale();
    internal static string get_Arg_InvalidRuntimeTypeHandle();
    internal static string get_Arg_IOException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanSrcString();
    internal static string get_Arg_LowerBoundsMustMatch();
    internal static string get_Arg_MissingFieldException();
    internal static string get_Arg_MethodAccessException();
    internal static string get_Arg_MissingMemberException();
    internal static string get_Arg_MissingMethodException();
    internal static string get_Arg_MulticastNotSupportedException();
    internal static string get_Arg_MustBeBoolean();
    internal static string get_Arg_MustBeByte();
    internal static string get_Arg_MustBeChar();
    internal static string get_Arg_MustBeDateTime();
    internal static string get_Arg_MustBeDateTimeOffset();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeDouble();
    internal static string get_Arg_MustBeEnum();
    internal static string get_Arg_MustBeGuid();
    internal static string get_Arg_MustBeInt16();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeInt64();
    internal static string get_Arg_MustBePrimArray();
    internal static string get_Arg_MustBeSByte();
    internal static string get_Arg_MustBeSingle();
    internal static string get_Arg_MustBeStatic();
    internal static string get_Arg_MustBeString();
    internal static string get_Arg_MustBeStringPtrNotAtom();
    internal static string get_Arg_MustBeTimeSpan();
    internal static string get_Arg_MustBeUInt16();
    internal static string get_Arg_MustBeUInt32();
    internal static string get_Arg_MustBeUInt64();
    internal static string get_Arg_MustBeVersion();
    internal static string get_Arg_NeedAtLeast1Rank();
    internal static string get_Arg_Need2DArray();
    internal static string get_Arg_Need3DArray();
    internal static string get_Arg_NegativeArgCount();
    internal static string get_Arg_NotFiniteNumberException();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_NotImplementedException();
    internal static string get_Arg_NotSupportedException();
    internal static string get_Arg_NotSupportedNonZeroLowerBound();
    internal static string get_Arg_NullReferenceException();
    internal static string get_Arg_ObjObjEx();
    internal static string get_Arg_OverflowException();
    internal static string get_Arg_OutOfMemoryException();
    internal static string get_Arg_PlatformNotSupported();
    internal static string get_Arg_ParamName_Name();
    internal static string get_Arg_PathEmpty();
    internal static string get_Arg_PathIllegalUNC_Path();
    internal static string get_Arg_RankException();
    internal static string get_Arg_RankIndices();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_RanksAndBounds();
    internal static string get_Arg_RegGetOverflowBug();
    internal static string get_Arg_RegKeyNotFound();
    internal static string get_Arg_RegInvalidKeyName();
    internal static string get_Arg_SecurityException();
    internal static string get_Arg_StackOverflowException();
    internal static string get_Arg_SynchronizationLockException();
    internal static string get_Arg_SystemException();
    internal static string get_Arg_TargetInvocationException();
    internal static string get_Arg_TargetParameterCountException();
    internal static string get_Arg_DefaultValueMissingException();
    internal static string get_Arg_ThreadStartException();
    internal static string get_Arg_ThreadStateException();
    internal static string get_Arg_TimeoutException();
    internal static string get_Arg_TypeAccessException();
    internal static string get_Arg_TypeLoadException();
    internal static string get_Arg_UnauthorizedAccessException();
    internal static string get_Arg_VersionString();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AbsolutePathRequired();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_AdjustmentRulesNoNulls();
    internal static string get_Argument_AdjustmentRulesOutOfOrder();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_CodepageNotSupported();
    internal static string get_Argument_CompareOptionOrdinal();
    internal static string get_Argument_ConflictingDateTimeRoundtripStyles();
    internal static string get_Argument_ConflictingDateTimeStyles();
    internal static string get_Argument_ConversionOverflow();
    internal static string get_Argument_ConvertMismatch();
    internal static string get_Argument_CultureInvalidIdentifier();
    internal static string get_Argument_CultureIetfNotSupported();
    internal static string get_Argument_CultureIsNeutral();
    internal static string get_Argument_CultureNotSupported();
    internal static string get_Argument_CustomCultureCannotBePassedByNumber();
    internal static string get_Argument_DateTimeBadBinaryData();
    internal static string get_Argument_DateTimeHasTicks();
    internal static string get_Argument_DateTimeHasTimeOfDay();
    internal static string get_Argument_DateTimeIsInvalid();
    internal static string get_Argument_DateTimeIsNotAmbiguous();
    internal static string get_Argument_DateTimeKindMustBeUnspecified();
    internal static string get_Argument_DateTimeKindMustBeUnspecifiedOrUtc();
    internal static string get_Argument_DateTimeOffsetInvalidDateTimeStyles();
    internal static string get_Argument_DateTimeOffsetIsNotAmbiguous();
    internal static string get_Argument_EmptyDecString();
    internal static string get_Argument_EmptyName();
    internal static string get_Argument_EmptyWaithandleArray();
    internal static string get_Argument_EncoderFallbackNotEmpty();
    internal static string get_Argument_EncodingConversionOverflowBytes();
    internal static string get_Argument_EncodingConversionOverflowChars();
    internal static string get_Argument_EncodingNotSupported();
    internal static string get_Argument_EnumTypeDoesNotMatch();
    internal static string get_Argument_FallbackBufferNotEmpty();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_Argument_InvalidArgumentForComparison();
    internal static string get_Argument_InvalidArrayLength();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_Argument_InvalidCalendar();
    internal static string get_Argument_InvalidCharSequence();
    internal static string get_Argument_InvalidCharSequenceNoIndex();
    internal static string get_Argument_InvalidCodePageBytesIndex();
    internal static string get_Argument_InvalidCodePageConversionIndex();
    internal static string get_Argument_InvalidCultureName();
    internal static string get_Argument_InvalidDateTimeKind();
    internal static string get_Argument_InvalidDateTimeStyles();
    internal static string get_Argument_InvalidDigitSubstitution();
    internal static string get_Argument_InvalidEnumValue();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidGroupSize();
    internal static string get_Argument_InvalidHighSurrogate();
    internal static string get_Argument_InvalidId();
    internal static string get_Argument_InvalidLowSurrogate();
    internal static string get_Argument_InvalidNativeDigitCount();
    internal static string get_Argument_InvalidNativeDigitValue();
    internal static string get_Argument_InvalidNeutralRegionName();
    internal static string get_Argument_InvalidNormalizationForm();
    internal static string get_Argument_InvalidNumberStyles();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidREG_TZI_FORMAT();
    internal static string get_Argument_InvalidResourceCultureName();
    internal static string get_Argument_InvalidSerializedString();
    internal static string get_Argument_InvalidTimeSpanStyles();
    internal static string get_Argument_MustBeFalse();
    internal static string get_Argument_MustBeRuntimeType();
    internal static string get_Argument_NoEra();
    internal static string get_Argument_NoRegionInvariantCulture();
    internal static string get_Argument_NotIsomorphic();
    internal static string get_Argument_OffsetLocalMismatch();
    internal static string get_Argument_OffsetPrecision();
    internal static string get_Argument_OffsetOutOfRange();
    internal static string get_Argument_OffsetUtcMismatch();
    internal static string get_Argument_OneOfCulturesNotSupported();
    internal static string get_Argument_OnlyMscorlib();
    internal static string get_Argument_OutOfOrderDateTimes();
    internal static string get_ArgumentOutOfRange_HugeArrayNotSupported();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_Length();
    internal static string get_ArgumentOutOfRange_LengthTooLarge();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_Argument_InvalidTypeName();
    internal static string get_Argument_PathFormatNotSupported_Path();
    internal static string get_Argument_RecursiveFallback();
    internal static string get_Argument_RecursiveFallbackBytes();
    internal static string get_Argument_ResultCalendarRange();
    internal static string get_Argument_SemaphoreInitialMaximum();
    internal static string get_Argument_TimeSpanHasSeconds();
    internal static string get_Argument_TimeZoneNotFound();
    internal static string get_Argument_TimeZoneInfoBadTZif();
    internal static string get_Argument_TimeZoneInfoInvalidTZif();
    internal static string get_Argument_ToExclusiveLessThanFromExclusive();
    internal static string get_Argument_TransitionTimesAreIdentical();
    internal static string get_Argument_UTCOutOfRange();
    internal static string get_Argument_WaitHandleNameTooLong();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_ArgumentException_TupleIncorrectType();
    internal static string get_ArgumentException_TupleLastArgumentNotATuple();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
    internal static string get_ArgumentNull_Array();
    internal static string get_ArgumentNull_ArrayElement();
    internal static string get_ArgumentNull_ArrayValue();
    internal static string get_ArgumentNull_Dictionary();
    internal static string get_ArgumentNull_Generic();
    internal static string get_ArgumentNull_Key();
    internal static string get_ArgumentNull_Obj();
    internal static string get_ArgumentNull_String();
    internal static string get_ArgumentNull_Type();
    internal static string get_ArgumentNull_Waithandles();
    internal static string get_ArgumentOutOfRange_AddValue();
    internal static string get_ArgumentOutOfRange_ActualValue();
    internal static string get_ArgumentOutOfRange_BadYearMonthDay();
    internal static string get_ArgumentOutOfRange_BadHourMinuteSecond();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper();
    internal static string get_ArgumentOutOfRange_CalendarRange();
    internal static string get_ArgumentOutOfRange_Capacity();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_DateArithmetic();
    internal static string get_ArgumentOutOfRange_DateTimeBadMonths();
    internal static string get_ArgumentOutOfRange_DateTimeBadTicks();
    internal static string get_ArgumentOutOfRange_DateTimeBadYears();
    internal static string get_ArgumentOutOfRange_Day();
    internal static string get_ArgumentOutOfRange_DayOfWeek();
    internal static string get_ArgumentOutOfRange_DayParam();
    internal static string get_ArgumentOutOfRange_DecimalRound();
    internal static string get_ArgumentOutOfRange_DecimalScale();
    internal static string get_ArgumentOutOfRange_EndIndexStartIndex();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_Era();
    internal static string get_ArgumentOutOfRange_FileTimeInvalid();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_GetByteCountOverflow();
    internal static string get_ArgumentOutOfRange_GetCharCountOverflow();
    internal static string get_ArgumentOutOfRange_HashtableLoadFactor();
    internal static string get_ArgumentOutOfRange_IndexCount();
    internal static string get_ArgumentOutOfRange_IndexCountBuffer();
    internal static string get_ArgumentOutOfRange_IndexLength();
    internal static string get_ArgumentOutOfRange_IndexString();
    internal static string get_ArgumentOutOfRange_InvalidEraValue();
    internal static string get_ArgumentOutOfRange_InvalidHighSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidLowSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidUTF32();
    internal static string get_ArgumentOutOfRange_LengthGreaterThanCapacity();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_ListItem();
    internal static string get_ArgumentOutOfRange_ListRemoveAt();
    internal static string get_ArgumentOutOfRange_Month();
    internal static string get_ArgumentOutOfRange_MonthParam();
    internal static string get_ArgumentOutOfRange_MustBeNonNegInt32();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ArgumentOutOfRange_NegativeCapacity();
    internal static string get_ArgumentOutOfRange_NegativeCount();
    internal static string get_ArgumentOutOfRange_NegativeLength();
    internal static string get_ArgumentOutOfRange_NoGCLohSizeGreaterTotalSize();
    internal static string get_ArgumentOutOfRange_OffsetLength();
    internal static string get_ArgumentOutOfRange_OffsetOut();
    internal static string get_ArgumentOutOfRange_PartialWCHAR();
    internal static string get_ArgumentOutOfRange_Range();
    internal static string get_ArgumentOutOfRange_RoundingDigits();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_ArgumentOutOfRange_SmallMaxCapacity();
    internal static string get_ArgumentOutOfRange_StartIndex();
    internal static string get_ArgumentOutOfRange_StartIndexLargerThanLength();
    internal static string get_ArgumentOutOfRange_StartIndexLessThanLength();
    internal static string get_ArgumentOutOfRange_UtcOffset();
    internal static string get_ArgumentOutOfRange_UtcOffsetAndDaylightDelta();
    internal static string get_ArgumentOutOfRange_Version();
    internal static string get_ArgumentOutOfRange_Week();
    internal static string get_ArgumentOutOfRange_Year();
    internal static string get_Arithmetic_NaN();
    internal static string get_ArrayTypeMismatch_CantAssignType();
    internal static string get_BadImageFormatException_CouldNotLoadFileOrAssembly();
    internal static string get_CollectionCorrupted();
    internal static string get_Exception_EndOfInnerExceptionStack();
    internal static string get_Exception_WasThrown();
    internal static string get_Format_BadBase64Char();
    internal static string get_Format_BadBase64CharArrayLength();
    internal static string get_Format_BadBoolean();
    internal static string get_Format_BadFormatSpecifier();
    internal static string get_Format_NoFormatSpecifier();
    internal static string get_Format_BadQuote();
    internal static string get_Format_EmptyInputString();
    internal static string get_Format_GuidHexPrefix();
    internal static string get_Format_GuidInvLen();
    internal static string get_Format_GuidInvalidChar();
    internal static string get_Format_GuidBrace();
    internal static string get_Format_GuidComma();
    internal static string get_Format_GuidBraceAfterLastNumber();
    internal static string get_Format_GuidDashes();
    internal static string get_Format_GuidEndBrace();
    internal static string get_Format_ExtraJunkAtEnd();
    internal static string get_Format_GuidUnrecognized();
    internal static string get_Format_IndexOutOfRange();
    internal static string get_Format_InvalidGuidFormatSpecification();
    internal static string get_Format_InvalidString();
    internal static string get_Format_NeedSingleChar();
    internal static string get_Format_NoParsibleDigits();
    internal static string get_Format_BadTimeSpan();
    internal static string get_InsufficientMemory_MemFailPoint();
    internal static string get_InsufficientMemory_MemFailPoint_TooBig();
    internal static string get_InsufficientMemory_MemFailPoint_VAFrag();
    internal static string get_InvalidCast_CannotCastNullToValueType();
    internal static string get_InvalidCast_DownCastArrayElement();
    internal static string get_InvalidCast_FromTo();
    internal static string get_InvalidCast_IConvertible();
    internal static string get_InvalidCast_StoreArrayElement();
    internal static string get_InvalidOperation_Calling();
    internal static string get_InvalidOperation_DateTimeParsing();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_HandleIsNotInitialized();
    internal static string get_InvalidOperation_HashInsertFailed();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_InvalidOperation_NoValue();
    internal static string get_InvalidOperation_NullArray();
    internal static string get_InvalidOperation_Overlapped_Pack();
    internal static string get_InvalidOperation_ReadOnly();
    internal static string get_InvalidOperation_ThreadWrongThreadStart();
    internal static string get_InvalidOperation_UnknownEnumType();
    internal static string get_InvalidOperation_WriteOnce();
    internal static string get_InvalidOperation_ArrayCreateInstance_NotARuntimeType();
    internal static string get_InvalidOperation_TooEarly();
    internal static string get_InvalidOperation_NullContext();
    internal static string get_InvalidOperation_CannotUseAFCOtherThread();
    internal static string get_InvalidOperation_CannotRestoreUnsupressedFlow();
    internal static string get_InvalidOperation_CannotSupressFlowMultipleTimes();
    internal static string get_InvalidOperation_CannotUseAFCMultiple();
    internal static string get_InvalidOperation_AsyncFlowCtrlCtxMismatch();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_InvalidProgram_Default();
    internal static string get_InvalidProgram_Specific();
    internal static string get_InvalidProgram_Vararg();
    internal static string get_InvalidProgram_CallVirtFinalize();
    internal static string get_InvalidProgram_NativeCallable();
    internal static string get_InvalidTimeZone_InvalidRegistryData();
    internal static string get_InvalidTimeZone_InvalidFileData();
    internal static string get_InvalidTimeZone_InvalidJulianDay();
    internal static string get_InvalidTimeZone_NJulianDayNotSupported();
    internal static string get_InvalidTimeZone_NoTTInfoStructures();
    internal static string get_InvalidTimeZone_UnparseablePosixMDateString();
    internal static string get_IO_DriveNotFound_Drive();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileName_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_FileLoad();
    internal static string get_IO_FileLoad_FileName();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_PathTooLong_Path();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_Lazy_CreateValue_NoParameterlessCtorForT();
    internal static string get_Lazy_ctor_ModeInvalid();
    internal static string get_Lazy_StaticInit_InvalidOperation();
    internal static string get_Lazy_ToString_ValueNotCreated();
    internal static string get_Lazy_Value_RecursiveCallsToValue();
    internal static string get_MissingConstructor_Name();
    internal static string get_MustUseCCRewrite();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_NotSupported_MaxWaitHandles();
    internal static string get_NotSupported_NoCodepageData();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_NotSupported_StringComparison();
    internal static string get_NotSupported_VoidArray();
    internal static string get_NotSupported_ByRefLike();
    internal static string get_NotSupported_Type();
    internal static string get_NotSupported_WaitAllSTAThread();
    internal static string get_ObjectDisposed_Generic();
    internal static string get_ObjectDisposed_ObjectName_Name();
    internal static string get_Overflow_Byte();
    internal static string get_Overflow_Char();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Double();
    internal static string get_Overflow_TimeSpanElementTooLarge();
    internal static string get_Overflow_Duration();
    internal static string get_Overflow_Int16();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_NegateTwosCompNum();
    internal static string get_Overflow_NegativeUnsigned();
    internal static string get_Overflow_SByte();
    internal static string get_Overflow_Single();
    internal static string get_Overflow_TimeSpanTooLong();
    internal static string get_Overflow_UInt16();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_Rank_MultiDimNotSupported();
    internal static string get_RuntimeWrappedException();
    internal static string get_SpinWait_SpinUntil_ArgumentNull();
    internal static string get_Serialization_CorruptField();
    internal static string get_Serialization_InvalidData();
    internal static string get_Serialization_InvalidEscapeSequence();
    internal static string get_Serialization_InvalidType();
    internal static string get_SpinWait_SpinUntil_TimeoutWrong();
    internal static string get_Threading_AbandonedMutexException();
    internal static string get_Threading_SemaphoreFullException();
    internal static string get_Threading_ThreadInterrupted();
    internal static string get_Threading_WaitHandleCannotBeOpenedException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException_InvalidHandle();
    internal static string get_TimeZoneNotFound_MissingData();
    internal static string get_TypeInitialization_Default();
    internal static string get_TypeInitialization_Type();
    internal static string get_TypeInitialization_Type_NoTypeAvailable();
    internal static string get_Verification_Exception();
    internal static string get_Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Format_InvalidEnumFormatSpecification();
    internal static string get_Arg_MustBeEnumBaseTypeOrEnum();
    internal static string get_Arg_EnumUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_MustBeType();
    internal static string get_Arg_MustContainEnumInfo();
    internal static string get_Arg_EnumValueNotFound();
    internal static string get_Argument_StringZeroLength();
    internal static string get_Argument_StringFirstCharIsZero();
    internal static string get_Argument_LongEnvVarValue();
    internal static string get_Argument_IllegalEnvVarName();
    internal static string get_AssumptionFailed();
    internal static string get_AssumptionFailed_Cnd();
    internal static string get_AssertionFailed();
    internal static string get_AssertionFailed_Cnd();
    internal static string get_PreconditionFailed();
    internal static string get_PreconditionFailed_Cnd();
    internal static string get_PostconditionFailed();
    internal static string get_PostconditionFailed_Cnd();
    internal static string get_PostconditionOnExceptionFailed();
    internal static string get_PostconditionOnExceptionFailed_Cnd();
    internal static string get_InvariantFailed();
    internal static string get_InvariantFailed_Cnd();
    internal static string get_MissingEncodingNameResource();
    internal static string get_Globalization_cp_1200();
    internal static string get_Globalization_cp_1201();
    internal static string get_Globalization_cp_12000();
    internal static string get_Globalization_cp_12001();
    internal static string get_Globalization_cp_20127();
    internal static string get_Globalization_cp_28591();
    internal static string get_Globalization_cp_65000();
    internal static string get_Globalization_cp_65001();
    internal static string get_DebugAssertBanner();
    internal static string get_DebugAssertLongMessage();
    internal static string get_DebugAssertShortMessage();
    internal static string get_InvalidCast_Empty();
    internal static string get_Arg_UnknownTypeCode();
    internal static string get_Format_BadDatePattern();
    internal static string get_Format_BadDateTime();
    internal static string get_Format_BadDateTimeCalendar();
    internal static string get_Format_BadDayOfWeek();
    internal static string get_Format_DateOutOfRange();
    internal static string get_Format_MissingIncompleteDate();
    internal static string get_Format_OffsetOutOfRange();
    internal static string get_Format_RepeatDateTimePattern();
    internal static string get_Format_UnknownDateTimeWord();
    internal static string get_Format_UTCOutOfRange();
    internal static string get_RFLCT_Ambiguous();
    internal static string get_AggregateException_ctor_DefaultMessage();
    internal static string get_AggregateException_ctor_InnerExceptionNull();
    internal static string get_AggregateException_DeserializationFailure();
    internal static string get_AggregateException_InnerException();
    internal static string get_ArgumentOutOfRange_TimeoutTooLarge();
    internal static string get_ArgumentOutOfRange_PeriodTooLarge();
    internal static string get_TaskScheduler_FromCurrentSynchronizationContext_NoCurrent();
    internal static string get_TaskScheduler_ExecuteTask_WrongTaskScheduler();
    internal static string get_TaskScheduler_InconsistentStateAfterTryExecuteTaskInline();
    internal static string get_TaskSchedulerException_ctor_DefaultMessage();
    internal static string get_Task_MultiTaskContinuation_FireOptions();
    internal static string get_Task_ContinueWith_ESandLR();
    internal static string get_Task_MultiTaskContinuation_EmptyTaskList();
    internal static string get_Task_MultiTaskContinuation_NullTask();
    internal static string get_Task_FromAsync_PreferFairness();
    internal static string get_Task_FromAsync_LongRunning();
    internal static string get_AsyncMethodBuilder_InstanceNotInitialized();
    internal static string get_TaskT_TransitionToFinal_AlreadyCompleted();
    internal static string get_TaskT_DebuggerNoResult();
    internal static string get_OperationCanceled();
    internal static string get_CancellationToken_CreateLinkedToken_TokensIsEmpty();
    internal static string get_CancellationTokenSource_Disposed();
    internal static string get_CancellationToken_SourceDisposed();
    internal static string get_TaskExceptionHolder_UnknownExceptionType();
    internal static string get_TaskExceptionHolder_UnhandledException();
    internal static string get_Task_Delay_InvalidMillisecondsDelay();
    internal static string get_Task_Delay_InvalidDelay();
    internal static string get_Task_Dispose_NotCompleted();
    internal static string get_Task_WaitMulti_NullTask();
    internal static string get_Task_ContinueWith_NotOnAnything();
    internal static string get_Task_RunSynchronously_AlreadyStarted();
    internal static string get_Task_ThrowIfDisposed();
    internal static string get_Task_RunSynchronously_TaskCompleted();
    internal static string get_Task_RunSynchronously_Promise();
    internal static string get_Task_RunSynchronously_Continuation();
    internal static string get_Task_Start_AlreadyStarted();
    internal static string get_Task_Start_ContinuationTask();
    internal static string get_Task_Start_Promise();
    internal static string get_Task_Start_TaskCompleted();
    internal static string get_TaskCanceledException_ctor_DefaultMessage();
    internal static string get_TaskCompletionSourceT_TrySetException_NoExceptions();
    internal static string get_TaskCompletionSourceT_TrySetException_NullException();
    internal static string get_Argument_MinMaxValue();
    internal static string get_ExecutionContext_ExceptionInAsyncLocalNotification();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndCalledMultiple();
    internal static string get_SpinLock_IsHeldByCurrentThread();
    internal static string get_SpinLock_TryEnter_LockRecursionException();
    internal static string get_SpinLock_Exit_SynchronizationLockException();
    internal static string get_SpinLock_TryReliableEnter_ArgumentException();
    internal static string get_SpinLock_TryEnter_ArgumentOutOfRange();
    internal static string get_ManualResetEventSlim_Disposed();
    internal static string get_ManualResetEventSlim_ctor_SpinCountOutOfRange();
    internal static string get_ManualResetEventSlim_ctor_TooManyWaiters();
    internal static string get_InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext();
    internal static string get_SemaphoreSlim_Disposed();
    internal static string get_SemaphoreSlim_Release_CountWrong();
    internal static string get_SemaphoreSlim_Wait_TimeoutWrong();
    internal static string get_SemaphoreSlim_ctor_MaxCountWrong();
    internal static string get_SemaphoreSlim_ctor_InitialCountWrong();
    internal static string get_ThreadLocal_ValuesNotAvailable();
    internal static string get_ThreadLocal_Value_RecursiveCallsToValue();
    internal static string get_ThreadLocal_Disposed();
    internal static string get_LockRecursionException_WriteAfterReadNotAllowed();
    internal static string get_LockRecursionException_RecursiveWriteNotAllowed();
    internal static string get_LockRecursionException_ReadAfterWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveUpgradeNotAllowed();
    internal static string get_LockRecursionException_RecursiveReadNotAllowed();
    internal static string get_SynchronizationLockException_IncorrectDispose();
    internal static string get_SynchronizationLockException_MisMatchedWrite();
    internal static string get_LockRecursionException_UpgradeAfterReadNotAllowed();
    internal static string get_LockRecursionException_UpgradeAfterWriteNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedUpgrade();
    internal static string get_SynchronizationLockException_MisMatchedRead();
    internal static string get_InvalidOperation_TimeoutsNotSupported();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_InvalidOperation_NoPublicRemoveMethod();
    internal static string get_InvalidOperation_NoPublicAddMethod();
    internal static string get_SerializationException();
    internal static string get_Serialization_NotFound();
    internal static string get_Serialization_OptionalFieldVersionValue();
    internal static string get_Serialization_SameNameTwice();
    internal static string get_NotSupported_AbstractNonCLS();
    internal static string get_NotSupported_NoTypeInfo();
    internal static string get_Arg_CustomAttributeFormatException();
    internal static string get_Argument_InvalidMemberForNamedArgument();
    internal static string get_Arg_InvalidFilterCriteriaException();
    internal static string get_Arg_ParmArraySize();
    internal static string get_Arg_MustBePointer();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Argument_InvalidEnum();
    internal static string get_Argument_MustHaveAttributeBaseClass();
    internal static string get_InvalidFilterCriteriaException_CritString();
    internal static string get_InvalidFilterCriteriaException_CritInt();
    internal static string get_InvalidOperation_NotSupportedOnWinRTEvent();
    internal static string get_PlatformNotSupported_ReflectionOnly();
    internal static string get_PlatformNotSupported_OSXFileLocking();
    internal static string get_PlatformNotSupported_ReflectionEmit();
    internal static string get_MissingMember_Name();
    internal static string get_MissingMethod_Name();
    internal static string get_MissingField_Name();
    internal static string get_Format_StringZeroLength();
    internal static string get_Security_CannotReadFileData();
    internal static string get_Security_CannotReadRegistryData();
    internal static string get_Security_InvalidAssemblyPublicKey();
    internal static string get_Security_RegistryPermission();
    internal static string get_ClassLoad_General();
    internal static string get_ClassLoad_RankTooLarge();
    internal static string get_ClassLoad_ExplicitGeneric();
    internal static string get_ClassLoad_BadFormat();
    internal static string get_ClassLoad_ValueClassTooLarge();
    internal static string get_ClassLoad_ExplicitLayout();
    internal static string get_EE_MissingMethod();
    internal static string get_EE_MissingField();
    internal static string get_UnauthorizedAccess_RegistryKeyGeneric_Key();
    internal static string get_UnknownError_Num();
    internal static string get_Argument_NeedStructWithNoRefs();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_AddressSpace();
    internal static string get_ArgumentOutOfRange_UIntPtrMax();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_InvalidOperation_MustCallInitialize();
    internal static string get_ArgumentException_BufferNotFromPool();
    internal static string get_Argument_InvalidSafeBufferOffLen();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_NotEnoughBytesToRead();
    internal static string get_Argument_NotEnoughBytesToWrite();
    internal static string get_Argument_OffsetAndCapacityOutOfBounds();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamLength();
    internal static string get_Argument_UnmanagedMemAccessorWrapAround();
    internal static string get_ArgumentOutOfRange_StreamLength();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamWrapAround();
    internal static string get_InvalidOperation_CalledTwice();
    internal static string get_IO_FixedCapacity();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_IO_StreamTooLong();
    internal static string get_Arg_BadDecimal();
    internal static string get_NotSupported_Reading();
    internal static string get_NotSupported_UmsSafeBuffer();
    internal static string get_NotSupported_Writing();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_IndexOutOfRange_UMSPosition();
    internal static string get_ObjectDisposed_ViewAccessorClosed();
    internal static string get_ArgumentOutOfRange_PositionLessThanCapacityRequired();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_Arg_EndOfStreamException();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_Arg_InvalidSearchPattern();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_Argument_InvalidHandle();
    internal static string get_Argument_AlreadyBoundOrSyncHandle();
    internal static string get_Argument_PreAllocatedAlreadyAllocated();
    internal static string get_Argument_NativeOverlappedAlreadyFree();
    internal static string get_Argument_NativeOverlappedWrongBoundHandle();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_ArgumentNull_Path();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_IO_UnknownFileName();
    internal static string get_IO_FileStreamHandlePosition();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_NotSupported_FileStreamOnNonFiles();
    internal static string get_IO_BindHandleFailed();
    internal static string get_Arg_HandleNotSync();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_FileTooLongOrHandleNotSync();
    internal static string get_IndexOutOfRange_IORaceCondition();
    internal static string get_Arg_ResourceFileUnsupportedVersion();
    internal static string get_Resources_StreamNotValid();
    internal static string get_BadImageFormat_ResourcesHeaderCorrupted();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_BadImageFormat_NegativeStringLength();
    internal static string get_BadImageFormat_ResourcesNameInvalidOffset();
    internal static string get_BadImageFormat_TypeMismatch();
    internal static string get_BadImageFormat_ResourceNameCorrupted_NameIndex();
    internal static string get_BadImageFormat_ResourcesDataInvalidOffset();
    internal static string get_Format_Bad7BitInt32();
    internal static string get_BadImageFormat_InvalidType();
    internal static string get_ResourceReaderIsClosed();
    internal static string get_Arg_MissingManifestResourceException();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_NullKey();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_NotSupported_MemStreamNotExpandable();
    internal static string get_ArgumentNull_Stream();
    internal static string get_IO_InvalidStringLen_Len();
    internal static string get_ArgumentOutOfRange_BinaryReaderFillBuffer();
    internal static string get_Serialization_InsufficientDeserializationState();
    internal static string get_NotSupported_UnitySerHolder();
    internal static string get_Serialization_UnableToFindModule();
    internal static string get_Argument_InvalidUnity();
    internal static string get_InvalidOperation_InvalidHandle();
    internal static string get_PlatformNotSupported_NamedSynchronizationPrimitives();
    internal static string get_InvalidOperation_EmptyQueue();
    internal static string get_Overflow_MutexReacquireCount();
    internal static string get_Serialization_InsufficientState();
    internal static string get_Serialization_UnknownMember();
    internal static string get_Serialization_NullSignature();
    internal static string get_Serialization_MemberTypeNotRecognized();
    internal static string get_Serialization_BadParameterInfo();
    internal static string get_Serialization_NoParameterInfo();
    internal static string get_ArgumentNull_Assembly();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_Asm_Culture();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_FallbackLoc();
    internal static string get_Arg_InvalidSatelliteContract_Asm_Ver();
    internal static string get_Arg_ResMgrNotResSet();
    internal static string get_BadImageFormat_ResourceNameCorrupted();
    internal static string get_BadImageFormat_ResourcesNameTooLong();
    internal static string get_InvalidOperation_ResMgrBadResSet_Type();
    internal static string get_InvalidOperation_ResourceNotStream_Name();
    internal static string get_MissingManifestResource_MultipleBlobs();
    internal static string get_MissingManifestResource_NoNeutralAsm();
    internal static string get_MissingManifestResource_NoNeutralDisk();
    internal static string get_MissingManifestResource_NoPRIresources();
    internal static string get_MissingManifestResource_ResWFileNotLoaded();
    internal static string get_MissingSatelliteAssembly_Culture_Name();
    internal static string get_MissingSatelliteAssembly_Default();
    internal static string get_NotSupported_ObsoleteResourcesFile();
    internal static string get_NotSupported_ResourceObjectSerialization();
    internal static string get_ObjectDisposed_ResourceSet();
    internal static string get_Arg_ResourceNameNotExist();
    internal static string get_BadImageFormat_ResourceDataLengthInvalid();
    internal static string get_BadImageFormat_ResourcesIndexTooLong();
    internal static string get_InvalidOperation_ResourceNotString_Name();
    internal static string get_InvalidOperation_ResourceNotString_Type();
    internal static string get_NotSupported_WrongResourceReader_Type();
    internal static string get_Arg_MustBeDelegate();
    internal static string get_NotSupported_GlobalMethodSerialization();
    internal static string get_NotSupported_DelegateSerHolderSerial();
    internal static string get_DelegateSer_InsufficientMetadata();
    internal static string get_Argument_NoUninitializedStrings();
    internal static string get_ArgumentOutOfRangeException_NoGCRegionSizeTooLarge();
    internal static string get_InvalidOperationException_AlreadyInNoGCRegion();
    internal static string get_InvalidOperationException_NoGCRegionAllocationExceeded();
    internal static string get_InvalidOperationException_NoGCRegionInduced();
    internal static string get_InvalidOperationException_NoGCRegionNotInProgress();
    internal static string get_InvalidOperationException_SetLatencyModeNoGC();
    internal static string get_InvalidOperation_NotWithConcurrentGC();
    internal static string get_ThreadState_AlreadyStarted();
    internal static string get_ThreadState_Dead_Priority();
    internal static string get_ThreadState_Dead_State();
    internal static string get_ThreadState_NotStarted();
    internal static string get_ThreadState_SetPriorityFailed();
    internal static string get_Serialization_InvalidFieldState();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Acc_CreateAbst();
    internal static string get_Acc_CreateGeneric();
    internal static string get_Argument_InvalidValue();
    internal static string get_NotSupported_ManagedActivation();
    internal static string get_PlatformNotSupported_ResourceManager_ResWFileUnsupportedMethod();
    internal static string get_PlatformNotSupported_ResourceManager_ResWFileUnsupportedProperty();
    internal static string get_Serialization_NonSerType();
    internal static string get_InvalidCast_DBNull();
    internal static string get_NotSupported_NYI();
    internal static string get_Delegate_GarbageCollected();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_NotSupported_ChangeType();
    internal static string get_Arg_EmptyArray();
    internal static string get_MissingMember();
    internal static string get_MissingField();
    internal static string get_InvalidCast_FromDBNull();
    internal static string get_NotSupported_DBNullSerial();
    internal static string get_Serialization_StringBuilderCapacity();
    internal static string get_Serialization_StringBuilderMaxCapacity();
    internal static string get_PlatformNotSupported_Remoting();
    internal static string get_PlatformNotSupported_StrongNameSigning();
    internal static string get_Serialization_MissingDateTimeData();
    internal static string get_Serialization_MissingValues();
    internal static string get_Serialization_DateTimeTicksOutOfRange();
    internal static string get_FeatureRemoved_Message();
    internal static string get_Arg_InvalidANSIString();
    internal static string get_Arg_MustBeNullTerminatedString();
    internal static string get_PlatformNotSupported_ArgIterator();
    internal static string get_Arg_TypeUnloadedException();
    internal static string get_Overflow_Currency();
    internal static string get_PlatformNotSupported_SecureBinarySerialization();
    internal static string get_Serialization_InvalidPtrValue();
    internal static string get_Serialization_KeyValueDifferentSizes();
    internal static string get_EventSource_AbstractMustNotDeclareEventMethods();
    internal static string get_EventSource_AbstractMustNotDeclareKTOC();
    internal static string get_EventSource_AddScalarOutOfRange();
    internal static string get_EventSource_BadHexDigit();
    internal static string get_EventSource_ChannelTypeDoesNotMatchEventChannelValue();
    internal static string get_EventSource_DataDescriptorsOutOfRange();
    internal static string get_EventSource_DuplicateStringKey();
    internal static string get_EventSource_EnumKindMismatch();
    internal static string get_EventSource_EvenHexDigits();
    internal static string get_EventSource_EventChannelOutOfRange();
    internal static string get_EventSource_EventIdReused();
    internal static string get_EventSource_EventMustHaveTaskIfNonDefaultOpcode();
    internal static string get_EventSource_EventMustNotBeExplicitImplementation();
    internal static string get_EventSource_EventNameDoesNotEqualTaskPlusOpcode();
    internal static string get_EventSource_EventNameReused();
    internal static string get_EventSource_EventParametersMismatch();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_EventTooBig();
    internal static string get_EventSource_EventWithAdminChannelMustHaveMessage();
    internal static string get_EventSource_IllegalKeywordsValue();
    internal static string get_EventSource_IllegalOpcodeValue();
    internal static string get_EventSource_IllegalTaskValue();
    internal static string get_EventSource_IllegalValue();
    internal static string get_EventSource_IncorrentlyAuthoredTypeInfo();
    internal static string get_EventSource_InvalidCommand();
    internal static string get_EventSource_InvalidEventFormat();
    internal static string get_EventSource_KeywordCollision();
    internal static string get_EventSource_KeywordNeedPowerOfTwo();
    internal static string get_EventSource_ListenerCreatedInsideCallback();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_MaxChannelExceeded();
    internal static string get_EventSource_MismatchIdToWriteEvent();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedPositiveId();
    internal static string get_EventSource_NoFreeBuffers();
    internal static string get_EventSource_NonCompliantTypeError();
    internal static string get_EventSource_NoRelatedActivityId();
    internal static string get_EventSource_NotSupportedArrayOfBinary();
    internal static string get_EventSource_NotSupportedArrayOfNil();
    internal static string get_EventSource_NotSupportedArrayOfNullTerminatedString();
    internal static string get_EventSource_NotSupportedCustomSerializedData();
    internal static string get_EventSource_NotSupportedNestedArraysEnums();
    internal static string get_EventSource_NullInput();
    internal static string get_EventSource_OpcodeCollision();
    internal static string get_EventSource_PinArrayOutOfRange();
    internal static string get_EventSource_RecursiveTypeDefinition();
    internal static string get_EventSource_SessionIdError();
    internal static string get_EventSource_StopsFollowStarts();
    internal static string get_EventSource_TaskCollision();
    internal static string get_EventSource_TaskOpcodePairReused();
    internal static string get_EventSource_TooManyArgs();
    internal static string get_EventSource_TooManyFields();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_TraitEven();
    internal static string get_EventSource_TypeMustBeSealedOrAbstract();
    internal static string get_EventSource_TypeMustDeriveFromEventSource();
    internal static string get_EventSource_UndefinedChannel();
    internal static string get_EventSource_UndefinedKeyword();
    internal static string get_EventSource_UndefinedOpcode();
    internal static string get_EventSource_UnknownEtwTrait();
    internal static string get_EventSource_UnsupportedEventTypeInManifest();
    internal static string get_EventSource_UnsupportedMessageProperty();
    internal static string get_EventSource_VarArgsParameterMismatch();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Arg_SurrogatesNotAllowedAsSingleChar();
    internal static string get_CustomAttributeFormat_InvalidFieldFail();
    internal static string get_CustomAttributeFormat_InvalidPropertyFail();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_OverlapAlignmentMismatch();
    internal static string get_ArrayTypeMismatch_ConstrainedCopy();
    internal static string get_Arg_DllNotFoundException();
    internal static string get_Arg_DllNotFoundExceptionParameterized();
    internal static string get_Arg_DriveNotFoundException();
    internal static string get_WrongSizeArrayInNStruct();
    internal static string get_Arg_InteropMarshalUnmappableChar();
    internal static string get_Arg_MarshalDirectiveException();
    internal static string get_Arg_RegSubKeyValueAbsent();
    internal static string get_Arg_RegValStrLenBug();
    internal static string get_Serialization_DelegatesNotSupported();
    internal static string get_Arg_OpenType();
    internal static string get_Arg_PlatformNotSupported_AssemblyName_GetAssemblyName();
    internal static string get_NotSupported_OpenType();
    internal static string get_NotSupported_ByRefLikeArray();
    internal static string get_StackTrace_AtWord();
    internal static string get_StackTrace_EndStackTraceFromPreviousThrow();
    internal static string get_InvalidAssemblyName();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_Argument_IdnBadBidi();
    internal static string get_Argument_IdnBadLabelSize();
    internal static string get_Argument_IdnBadNameSize();
    internal static string get_Argument_IdnBadPunycode();
    internal static string get_Argument_IdnBadStd3();
    internal static string get_Argument_IdnIllegalName();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_NotSupported_SignatureType();
    internal static string get_MemoryDisposed();
    internal static string get_Memory_OutstandingReferences();
    internal static string get_HashCode_HashCodeNotSupported();
    internal static string get_HashCode_EqualityNotSupported();
    internal static string get_ObjectDisposed_WriterClosed();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_IO_InvalidReadLength();
    internal static string get_Arg_BasePathNotFullyQualified();
    internal static string get_Arg_ElementsInSourceIsGreaterThanDestination();
    internal static string get_Arg_TypeNotSupported();
    internal static string get_Arg_NullArgumentNullRef();
    internal static string get_Arg_InsufficientNumberOfElements();
    internal static string get_NullReference_InvokeNullRefReturned();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_Thread_Operation_RequiresCurrentThread();
    internal static string get_ConcurrentCollection_SyncRoot_NotSupported();
    internal static string get_Arg_WrongAsyncResult();
    internal static string get_InvalidOperation_EndReadCalledMultiple();
    internal static string get_InvalidOperation_EndWriteCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple();
    internal static string get_ArgumentOutOfRange_Week_ISO();
    internal static Type get_ResourceType();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    internal StackOverflowException(SerializationInfo info, StreamingContext context);
}
internal enum System.StartNoGCRegionStatus : Enum {
    public int value__;
    public static StartNoGCRegionStatus Succeeded;
    public static StartNoGCRegionStatus NotEnoughMemory;
    public static StartNoGCRegionStatus AmountTooLarge;
    public static StartNoGCRegionStatus AlreadyInProgress;
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[EagerStaticClassConstructionAttribute]
public class System.String : object {
    private static int StackallocIntBufferSizeLimit;
    private static int PROBABILISTICMAP_BLOCK_INDEX_MASK;
    private static int PROBABILISTICMAP_BLOCK_INDEX_SHIFT;
    private static int PROBABILISTICMAP_SIZE;
    private static int POINTER_SIZE;
    internal static int FIRST_CHAR_OFFSET;
    [BoundAttribute]
private int _stringLength;
    private char _firstChar;
    public static string Empty;
    private static StringInternTable modreq(System.Runtime.CompilerServices.IsVolatile) s_lazyInternTable;
    public char Chars { get; }
    public int Length { get; }
    private static StringInternTable InternTable { get; }
    public String(Char[] value);
    public String(Char[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(Char* value);
    [CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public String(char c, int count);
    public String(ReadOnlySpan`1<char> value);
    private static String();
    [DependencyReductionRootAttribute]
private static string Ctor(Char[] value);
    [DependencyReductionRootAttribute]
private static string Ctor(Char[] value, int startIndex, int length);
    [DependencyReductionRootAttribute]
private static string Ctor(Char* ptr);
    [DependencyReductionRootAttribute]
private static string Ctor(Char* ptr, int startIndex, int length);
    [DependencyReductionRootAttribute]
private static string Ctor(SByte* value);
    [DependencyReductionRootAttribute]
private static string Ctor(SByte* value, int startIndex, int length);
    private static string CreateStringForSByteConstructor(Byte* pb, int numBytes);
    [DependencyReductionRootAttribute]
private static string Ctor(SByte* value, int startIndex, int length, Encoding enc);
    [DependencyReductionRootAttribute]
private static string Ctor(char c, int count);
    [DependencyReductionRootAttribute]
private static string Ctor(ReadOnlySpan`1<char> value);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    public static ReadOnlySpan`1<char> op_Implicit(string value);
    public sealed virtual object Clone();
    public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    [NonVersionableAttribute]
public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    internal Char& GetRawStringData();
    internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    internal static string CreateFromChar(char c);
    internal static void wstrcpy(Char* dmem, Char* smem, int charCount);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static int wcslen(Char* ptr);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    private static bool EqualsHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
    private static bool EqualsOrdinalIgnoreCase(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, string strB);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, string strB);
    internal static int CompareOrdinal(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(string strB);
    public bool EndsWith(string value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public bool Equals(string value, StringComparison comparisonType);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public static bool op_Equality(string a, string b);
    public static bool op_Inequality(string a, string b);
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    internal int GetNonRandomizedHashCode();
    public bool StartsWith(string value);
    public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    internal static void CheckStringComparison(StringComparison comparisonType);
    internal static CompareOptions GetCaseCompareOfComparisonCulture(StringComparison comparisonType);
    private static void FillStringChecked(string dest, int destPos, string src);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(IEnumerable`1<T> values);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    private static string FormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public string Insert(int startIndex, string value);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, String[] value, int startIndex, int count);
    private static string JoinCore(Char* separator, int separatorLength, Object[] values);
    private static string JoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private static string JoinCore(Char* separator, int separatorLength, String[] value, int startIndex, int count);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    private string ReplaceCore(string oldValue, string newValue, CultureInfo culture, CompareOptions options);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    private string ReplaceHelper(int oldValueLength, string newValue, ReadOnlySpan`1<int> indices);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(ReadOnlySpan`1<char> separators, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, String[] separators, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, int count, StringSplitOptions options);
    private String[] SplitKeepEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private String[] SplitOmitEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private void MakeSeparatorList(ReadOnlySpan`1<char> separators, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(string separator, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(String[] separators, ValueListBuilder`1& sepListBuilder, ValueListBuilder`1& lengthListBuilder);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private string InternalSubString(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    private string TrimWhiteSpaceHelper(TrimType trimType);
    private string TrimHelper(Char* trimChars, int trimCharsLength, TrimType trimType);
    private string CreateTrimmedString(int start, int end);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    private int IndexOfAny(char value1, char value2, int startIndex, int count);
    private int IndexOfAny(char value1, char value2, char value3, int startIndex, int count);
    private int IndexOfCharArray(Char[] anyOf, int startIndex, int count);
    private static void InitializeProbabilisticMap(UInt32* charMap, ReadOnlySpan`1<char> anyOf);
    private static bool ArrayContains(char searchChar, Char[] anyOf);
    private static bool IsCharBitSet(UInt32* charMap, byte value);
    private static void SetCharBit(UInt32* charMap, byte value);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    private int LastIndexOfCharArray(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    [BoundsCheckingAttribute]
public char get_Chars(int index);
    public int get_Length();
    internal static string FastAllocateString(int length);
    public static string Intern(string str);
    public static string IsInterned(string str);
    private static StringInternTable get_InternTable();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.StringComparer : object {
    private static CultureAwareComparer s_invariantCulture;
    private static CultureAwareComparer s_invariantCultureIgnoreCase;
    private static OrdinalCaseSensitiveComparer s_ordinal;
    private static OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    private static StringComparer();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    public abstract virtual int Compare(string x, string y);
    public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    protected SystemException(SerializationInfo info, StreamingContext context);
}
public class System.Text.ASCIIEncoding : Encoding {
    internal static ASCIIEncodingSealed s_default;
    public bool IsSingleByte { get; }
    private static ASCIIEncoding();
    internal sealed virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [__BlockReflectionAttribute]
public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [__BlockReflectionAttribute]
public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [__BlockReflectionAttribute]
public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [__BlockReflectionAttribute]
public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal sealed virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
internal class System.Text.CodePageDataItem : object {
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UIFamilyCodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BodyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnglishName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    public int CodePage { get; }
    public int UIFamilyCodePage { get; }
    public string WebName { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public string EnglishName { get; }
    public UInt32 Flags { get; }
    internal CodePageDataItem(int codePage, int uiFamilyCodePage, string webName, string headerName, string bodyName, string englishName, UInt32 flags);
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public int get_UIFamilyCodePage();
    [CompilerGeneratedAttribute]
public string get_WebName();
    [CompilerGeneratedAttribute]
public string get_HeaderName();
    [CompilerGeneratedAttribute]
public string get_BodyName();
    [CompilerGeneratedAttribute]
public string get_EnglishName();
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
}
public abstract class System.Text.Decoder : object {
    internal DecoderFallback _fallback;
    internal DecoderFallbackBuffer _fallbackBuffer;
    public DecoderFallback Fallback { get; public set; }
    public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    private void Throw(Byte[] bytesUnknown, int index);
}
public abstract class System.Text.DecoderFallback : object {
    private static DecoderFallback s_replacementFallback;
    private static DecoderFallback s_exceptionFallback;
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    internal Byte* byteStart;
    internal Char* charEnd;
    public int Remaining { get; }
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.DecoderFallbackException : ArgumentException {
    private Byte[] _bytesUnknown;
    private int _index;
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    private DecoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _bytesUsed;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal DecoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
public abstract class System.Text.Encoder : object {
    internal EncoderFallback _fallback;
    internal EncoderFallbackBuffer _fallbackBuffer;
    public EncoderFallback Fallback { get; public set; }
    public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
public abstract class System.Text.EncoderFallback : object {
    private static EncoderFallback s_replacementFallback;
    private static EncoderFallback s_exceptionFallback;
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    internal Char* charStart;
    internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    private static int iMaxRecursion;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal char InternalGetNextChar();
    internal virtual bool InternalFallback(char ch, Char*& chars);
    internal void ThrowLastCharRecursive(int charRecursive);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.EncoderFallbackException : ArgumentException {
    private char _charUnknown;
    private char _charUnknownHigh;
    private char _charUnknownLow;
    private int _index;
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    private EncoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char _charLeftOver;
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal EncoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
}
public abstract class System.Text.Encoding : object {
    private static UTF8EncodingSealed s_defaultEncoding;
    internal static int MIMECONTF_MAILNEWS;
    internal static int MIMECONTF_BROWSER;
    internal static int MIMECONTF_SAVABLE_MAILNEWS;
    internal static int MIMECONTF_SAVABLE_BROWSER;
    private static int CodePageDefault;
    private static int CodePageNoOEM;
    private static int CodePageNoMac;
    private static int CodePageNoThread;
    private static int CodePageNoSymbol;
    private static int CodePageUnicode;
    private static int CodePageBigEndian;
    private static int CodePageWindows1252;
    private static int CodePageMacGB2312;
    private static int CodePageGB2312;
    private static int CodePageMacKorean;
    private static int CodePageDLLKorean;
    private static int ISO2022JP;
    private static int ISO2022JPESC;
    private static int ISO2022JPSISO;
    private static int ISOKorean;
    private static int ISOSimplifiedCN;
    private static int EUCJP;
    private static int ChineseHZ;
    private static int DuplicateEUCCN;
    private static int EUCCN;
    private static int EUCKR;
    internal static int CodePageASCII;
    internal static int ISO_8859_1;
    private static int ISCIIAssemese;
    private static int ISCIIBengali;
    private static int ISCIIDevanagari;
    private static int ISCIIGujarathi;
    private static int ISCIIKannada;
    private static int ISCIIMalayalam;
    private static int ISCIIOriya;
    private static int ISCIIPanjabi;
    private static int ISCIITamil;
    private static int ISCIITelugu;
    private static int GB18030;
    private static int ISO_8859_8I;
    private static int ISO_8859_8_Visual;
    private static int ENC50229;
    private static int CodePageUTF7;
    private static int CodePageUTF8;
    private static int CodePageUTF32;
    private static int CodePageUTF32BE;
    internal int _codePage;
    internal CodePageDataItem _dataItem;
    [OptionalFieldAttribute]
private bool _isReadOnly;
    internal EncoderFallback encoderFallback;
    internal DecoderFallback decoderFallback;
    public static Encoding Default { get; }
    public ReadOnlySpan`1<byte> Preamble { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsSingleByte { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public DecoderFallback DecoderFallback { get; public set; }
    public bool IsReadOnly { get; }
    public static Encoding ASCII { get; }
    private static Encoding Latin1 { get; }
    public int CodePage { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    private static Encoding BigEndianUTF32 { get; }
    protected Encoding(int codePage);
    protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    private static Encoding();
    public static Encoding get_Default();
    internal virtual void SetDefaultFallbacks();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public static void RegisterProvider(EncodingProvider provider);
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    private void GetDataItem();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    private static string GetLocalizedEncodingNameResource(int codePage);
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public virtual object Clone();
    public bool get_IsReadOnly();
    public static Encoding get_ASCII();
    private static Encoding get_Latin1();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public int GetByteCount(string s, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    [CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    public string GetString(ReadOnlySpan`1<byte> bytes);
    public virtual int get_CodePage();
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    private static Encoding get_BigEndianUTF32();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal virtual Char[] GetBestFitUnicodeToBytesData();
    internal virtual Char[] GetBestFitBytesToUnicodeData();
    internal void ThrowBytesOverflow();
    internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    internal void ThrowCharsOverflow();
    internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
}
public class System.Text.EncodingInfo : object {
    private int iCodePage;
    private string strEncodingName;
    private string strDisplayName;
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    internal EncodingInfo(int codePage, string name, string displayName);
    public int get_CodePage();
    public string get_Name();
    public string get_DisplayName();
    public Encoding GetEncoding();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal abstract class System.Text.EncodingNLS : Encoding {
    protected EncodingNLS(int codePage);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
public abstract class System.Text.EncodingProvider : object {
    private static object s_InternalSyncObject;
    private static EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    private static EncodingProvider();
    public abstract virtual Encoding GetEncoding(string name);
    public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    internal static void AddProvider(EncodingProvider provider);
    internal static Encoding GetEncodingFromProvider(int codepage);
    internal static Encoding GetEncodingFromProvider(string encodingName);
    internal static Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec);
    internal static Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec);
}
internal static class System.Text.EncodingTable : object {
    private static string s_encodingNames;
    private static Int32[] s_encodingNameIndices;
    private static UInt16[] s_codePagesByName;
    private static UInt16[] s_mappedCodePages;
    private static Int32[] s_uiFamilyCodePages;
    private static string s_webNames;
    private static Int32[] s_webNameIndices;
    private static string s_englishNames;
    private static Int32[] s_englishNameIndices;
    private static UInt32 MIMECONTF_MAILNEWS;
    private static UInt32 MIMECONTF_BROWSER;
    private static UInt32 MIMECONTF_SAVABLE_MAILNEWS;
    private static UInt32 MIMECONTF_SAVABLE_BROWSER;
    private static UInt32[] s_flags;
    private static EncodingTable();
    internal static int GetCodePageFromName(string name);
    private static int InternalGetCodePageFromName(string name);
    private static int CompareOrdinal(string s1, string s2, int index, int length);
    internal static EncodingInfo[] GetEncodings();
    internal static CodePageDataItem GetCodePageDataItem(int codePage);
    private static CodePageDataItem InternalGetCodePageDataItem(int codePage);
}
internal class System.Text.InternalDecoderBestFitFallback : DecoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    internal char _cReplacement;
    public int MaxCharCount { get; }
    internal InternalDecoderBestFitFallback(Encoding encoding);
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
    private char _cBestFit;
    private int _iCount;
    private int _iSize;
    private InternalDecoderBestFitFallback _oFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalDecoderBestFitFallbackBuffer(InternalDecoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    private char TryBestFit(Byte[] bytesCheck);
}
internal class System.Text.InternalEncoderBestFitFallback : EncoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    public int MaxCharCount { get; }
    internal InternalEncoderBestFitFallback(Encoding encoding);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
    private char _cBestFit;
    private InternalEncoderBestFitFallback _oFallback;
    private int _iCount;
    private int _iSize;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalEncoderBestFitFallbackBuffer(InternalEncoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    private char TryBestFit(char cUnknown);
}
internal class System.Text.Latin1Encoding : EncodingNLS {
    internal static Latin1Encoding s_default;
    private static Char[] arrayCharBestFit;
    public bool IsSingleByte { get; }
    private static Latin1Encoding();
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    internal virtual Char[] GetBestFitUnicodeToBytesData();
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
[DefaultMemberAttribute("Chars")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.StringBuilder : object {
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    internal static int DefaultCapacity;
    private static string CapacityField;
    private static string MaxCapacityField;
    private static string StringValueField;
    private static string ThreadIDField;
    internal static int MaxChunkSize;
    private static int IndexLimit;
    private static int WidthLimit;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    private Span`1<char> RemainingCurrentChunk { get; }
    public StringBuilder(int capacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    private StringBuilder(SerializationInfo info, StreamingContext context);
    private StringBuilder(StringBuilder from);
    private StringBuilder(int size, int maxCapacity, StringBuilder previousBlock);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [ConditionalAttribute("DEBUG")]
private void AssertInvariants();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    [__BlockReflectionAttribute]
public ChunkEnumerator GetChunks();
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(string value);
    private void AppendHelper(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    private StringBuilder AppendCore(StringBuilder value, int startIndex, int count);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    public StringBuilder Append(char value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    private StringBuilder AppendSpanFormattable(T value);
    public StringBuilder Append(object value);
    public StringBuilder Append(Char[] value);
    public StringBuilder Append(ReadOnlySpan`1<char> value);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, T[] values);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    private static void FormatError();
    internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public StringBuilder Replace(string oldValue, string newValue);
    public bool Equals(StringBuilder sb);
    public bool Equals(ReadOnlySpan`1<char> span);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    private void Insert(int index, Char* value, int valueCount);
    private void ReplaceAllInChunk(Int32[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value);
    private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
    private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char* value, int count);
    private static void ThreadSafeCopy(Char* sourcePtr, Char[] destination, int destinationIndex, int count);
    private static void ThreadSafeCopy(Char[] source, int sourceIndex, Span`1<char> destination, int destinationIndex, int count);
    private StringBuilder FindChunkForIndex(int index);
    private StringBuilder FindChunkForByte(int byteIndex);
    private Span`1<char> get_RemainingCurrentChunk();
    private StringBuilder Next(StringBuilder chunk);
    private void ExpandByABlock(int minBlockCharCount);
    private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doNotMoveFollowingChars);
    private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk);
    internal int GetAllocationLength(int requiredLength);
    internal void ReplaceBuffer(Char* newBuffer);
    internal void ReplaceBuffer(Char[] chunkCharsCandidate);
    private void ReplaceBufferInternal(Char[] chunkChars, int length);
    internal Char[] GetBuffer(Int32& len);
    internal void UnsafeCopyTo(Char* destination);
    private static void ThreadSafeCopy(Char[] source, int sourceIndex, Char* destinationPtr, int count);
}
internal static class System.Text.StringBuilderCache : object {
    internal static int MaxBuilderSize;
    private static int DefaultCapacity;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.Text.UnicodeEncoding : Encoding {
    internal static UnicodeEncoding s_bigEndianDefault;
    internal static UnicodeEncoding s_littleEndianDefault;
    private static Byte[] s_bigEndianPreamble;
    private static Byte[] s_littleEndianPreamble;
    private bool isThrowException;
    private bool bigEndian;
    private bool byteOrderMark;
    public static int CharSize;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    private static UnicodeEncoding();
    internal sealed virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    [__BlockReflectionAttribute]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF32Encoding : Encoding {
    internal static UTF32Encoding s_default;
    internal static UTF32Encoding s_bigEndianDefault;
    private static Byte[] s_bigEndianPreamble;
    private static Byte[] s_littleEndianPreamble;
    private bool _emitUTF32ByteOrderMark;
    private bool _isThrowException;
    private bool _bigEndian;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    private static UTF32Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private UInt32 GetSurrogate(char cHigh, char cLow);
    private char GetHighSurrogate(UInt32 iChar);
    private char GetLowSurrogate(UInt32 iChar);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [__BlockReflectionAttribute]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF7Encoding : Encoding {
    private static string base64Chars;
    private static string directChars;
    private static string optionalChars;
    internal static UTF7Encoding s_default;
    private Byte[] _base64Bytes;
    private SByte[] _base64Values;
    private Boolean[] _directEncode;
    private bool _allowOptionals;
    private static int UTF7_CODEPAGE;
    public UTF7Encoding(bool allowOptionals);
    private static UTF7Encoding();
    private void MakeTables();
    internal sealed virtual void SetDefaultFallbacks();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
public class System.Text.UTF8Encoding : Encoding {
    private static int UTF8_CODEPAGE;
    internal static UTF8EncodingSealed s_default;
    internal static Byte[] s_preamble;
    internal bool _emitUTF8Identifier;
    private bool _isThrowException;
    private static int FinalByte;
    private static int SupplimentarySeq;
    private static int ThreeByteSeq;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    private static UTF8Encoding();
    internal sealed virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [__BlockReflectionAttribute]
public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [__BlockReflectionAttribute]
public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [__BlockReflectionAttribute]
public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [__BlockReflectionAttribute]
public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
    private static bool InRange(int ch, int start, int end);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private bool FallbackInvalidByteSequence(Byte*& pSrc, int ch, DecoderFallbackBuffer fallback, Char*& pTarget);
    private int FallbackInvalidByteSequence(Byte* pSrc, int ch, DecoderFallbackBuffer fallback);
    private Byte[] GetBytesUnknown(Byte*& pSrc, int ch);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [__BlockReflectionAttribute]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int requiredAdditionalCapacity);
    public void Dispose();
}
internal class System.Threading._IOCompletionCallback : object {
    private IOCompletionCallback _ioCompletionCallback;
    private ExecutionContext _executionContext;
    private UInt32 _errorCode;
    private UInt32 _numBytes;
    private NativeOverlapped* _pNativeOverlapped;
    internal static ContextCallback s_ccb;
    internal _IOCompletionCallback(IOCompletionCallback ioCompletionCallback, ExecutionContext executionContext);
    private static _IOCompletionCallback();
    private static void IOCompletionCallback_Context(object state);
    internal static void PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pNativeOverlapped);
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    private WaitOrTimerCallback _waitOrTimerCallback;
    private ExecutionContext _executionContext;
    private object _state;
    private static ContextCallback _ccbt;
    private static ContextCallback _ccbf;
    internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool flowExecutionContext);
    private static _ThreadPoolWaitOrTimerCallback();
    private static void WaitOrTimerCallback_Context_t(object state);
    private static void WaitOrTimerCallback_Context_f(object state);
    private static void WaitOrTimerCallback_Context(object state, bool timedOut);
    internal static void PerformWaitOrTimerCallback(_ThreadPoolWaitOrTimerCallback helper, bool timedOut);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.AbandonedMutexException : SystemException {
    private int _mutexIndex;
    private Mutex _mutex;
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    private void SetupException(int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private RuntimeThread _thread;
    internal void Initialize(RuntimeThread currentThread);
    public void Undo();
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
public class System.Threading.AsyncLocal`1 : object {
    private Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler;
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
    private sealed virtual override void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
}
[IsReadOnlyAttribute]
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadContextChanged>k__BackingField;
    public T PreviousValue { get; }
    public T CurrentValue { get; }
    public bool ThreadContextChanged { get; }
    internal AsyncLocalValueChangedArgs`1(T previousValue, T currentValue, bool contextChanged);
    [CompilerGeneratedAttribute]
public T get_PreviousValue();
    [CompilerGeneratedAttribute]
public T get_CurrentValue();
    [CompilerGeneratedAttribute]
public bool get_ThreadContextChanged();
}
internal static class System.Threading.AsyncLocalValueMap : object {
    [CompilerGeneratedAttribute]
private static IAsyncLocalValueMap <Empty>k__BackingField;
    public static IAsyncLocalValueMap Empty { get; }
    private static AsyncLocalValueMap();
    [CompilerGeneratedAttribute]
public static IAsyncLocalValueMap get_Empty();
    public static bool IsEmpty(IAsyncLocalValueMap asyncLocalValueMap);
    public static IAsyncLocalValueMap Create(IAsyncLocal key, object value, bool treatNullValueAsNonexistent);
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
internal class System.Threading.CancellationCallbackCoreWorkArguments : ValueType {
    internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> _currArrayFragment;
    internal int _currArrayIndex;
    public CancellationCallbackCoreWorkArguments(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
}
internal class System.Threading.CancellationCallbackInfo : object {
    internal Action`1<object> Callback;
    internal object StateForCallback;
    internal ExecutionContext TargetExecutionContext;
    internal CancellationTokenSource CancellationTokenSource;
    private static ContextCallback s_executionContextCallback;
    internal CancellationCallbackInfo(Action`1<object> callback, object stateForCallback, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource);
    internal void ExecuteCallback();
    private static void ExecutionContextCallback(object obj);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource _source;
    private static Action`1<object> s_actionToActionObjShunt;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
    [__BlockReflectionAttribute]
public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
    public bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    private void ThrowOperationCanceledException();
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private CancellationCallbackInfo m_callbackInfo;
    private SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo;
    public CancellationToken Token { get; }
    internal CancellationTokenRegistration(CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo);
    public CancellationToken get_Token();
    [__BlockReflectionAttribute]
public bool Unregister();
    public sealed virtual void Dispose();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
}
public class System.Threading.CancellationTokenSource : object {
    internal static CancellationTokenSource s_canceledSource;
    internal static CancellationTokenSource s_neverCanceledSource;
    private static int s_nLists;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _kernelEvent;
    private SparselyPopulatedArray`1[] modreq(System.Runtime.CompilerServices.IsVolatile) _registeredCallbacksLists;
    private static int CannotBeCanceled;
    private static int NotCanceledState;
    private static int NotifyingState;
    private static int NotifyingCompleteState;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadIDExecutingCallbacks;
    private bool _disposed;
    private CancellationCallbackInfo modreq(System.Runtime.CompilerServices.IsVolatile) _executingCallback;
    private Timer modreq(System.Runtime.CompilerServices.IsVolatile) _timer;
    private static TimerCallback s_timerCallback;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal bool IsDisposed { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal bool CanBeCanceled { get; }
    internal WaitHandle WaitHandle { get; }
    internal CancellationCallbackInfo ExecutingCallback { get; }
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal bool get_IsDisposed();
    internal int get_ThreadIDExecutingCallbacks();
    internal void set_ThreadIDExecutingCallbacks(int value);
    public CancellationToken get_Token();
    internal bool get_CanBeCanceled();
    internal WaitHandle get_WaitHandle();
    internal CancellationCallbackInfo get_ExecutingCallback();
    private void InitializeWithTimer(int millisecondsDelay);
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    private static void TimerCallbackLogic(object obj);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ThrowIfDisposed();
    private static void ThrowObjectDisposedException();
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    private void CancellationCallbackCoreWork_OnSyncContext(object obj);
    private void CancellationCallbackCoreWork(CancellationCallbackCoreWorkArguments args);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    internal static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class System.Threading.Condition : object {
    [ThreadStaticAttribute]
private static Waiter t_waiterForCurrentThread;
    private Lock _lock;
    private Waiter _waitersHead;
    private Waiter _waitersTail;
    public Condition(Lock lock);
    private static Waiter GetWaiterForCurrentThread();
    private void AssertIsInList(Waiter waiter);
    private void AssertIsNotInList(Waiter waiter);
    private void AddWaiter(Waiter waiter);
    private void RemoveWaiter(Waiter waiter);
    public bool Wait();
    public bool Wait(TimeSpan timeout);
    public bool Wait(int millisecondsTimeout);
    public void SignalAll();
    public void SignalOne();
}
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.DeferredDisposableLifetime`1 : ValueType {
    private int _count;
    public bool AddRef(T obj);
    public void Release(T obj);
    public void Dispose(T obj);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
public class System.Threading.EventWaitHandle : WaitHandle {
    private static UInt32 AccessRights;
    public EventWaitHandle(bool initialState, EventResetMode mode);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    private EventWaitHandle(SafeWaitHandle handle);
    public static EventWaitHandle OpenExisting(string name);
    public static bool TryOpenExisting(string name, EventWaitHandle& result);
    private void CreateEventCore(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, EventWaitHandle& result);
    public bool Reset();
    public bool Set();
}
public class System.Threading.ExecutionContext : object {
    internal static ExecutionContext Default;
    internal static ExecutionContext DefaultFlowSuppressed;
    private IAsyncLocalValueMap m_localValues;
    private IAsyncLocal[] m_localChangeNotifications;
    private bool m_isFlowSuppressed;
    private bool m_isDefault;
    internal bool HasChangeNotifications { get; }
    internal bool IsDefault { get; }
    private ExecutionContext(bool isDefault);
    private ExecutionContext(IAsyncLocalValueMap localValues, IAsyncLocal[] localChangeNotifications, bool isFlowSuppressed);
    private static ExecutionContext();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static ExecutionContext Capture();
    private ExecutionContext ShallowClone(bool isFlowSuppressed);
    public static AsyncFlowControl SuppressFlow();
    public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    internal bool get_HasChangeNotifications();
    internal bool get_IsDefault();
    public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void OnValuesChanged(ExecutionContext previousExecutionCtx, ExecutionContext nextExecutionCtx);
    [StackTraceHiddenAttribute]
private static void ThrowNullContext();
    internal static object GetLocalValue(IAsyncLocal local);
    internal static void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications);
    public ExecutionContext CreateCopy();
    public sealed virtual void Dispose();
}
internal class System.Threading.FastRandom : ValueType {
    private UInt32 _w;
    private UInt32 _x;
    private UInt32 _y;
    private UInt32 _z;
    public FastRandom(int seed);
    public int Next(int maxValue);
}
internal class System.Threading.FirstLevelSpinWaiter : ValueType {
    private static int SpinCount;
    private static int SpinYieldThreshold;
    private static int SpinSleep0Threshold;
    private static int s_processorCount;
    private int _spinningThreadCount;
    public void Initialize();
    public bool SpinWaitForCondition(Func`1<bool> condition);
    private static void Wait(int spinIndex);
}
internal interface System.Threading.IAsyncLocal {
    public abstract virtual void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
}
internal interface System.Threading.IAsyncLocalValueMap {
    public abstract virtual bool TryGetValue(IAsyncLocal key, Object& value);
    public abstract virtual IAsyncLocalValueMap Set(IAsyncLocal key, object value, bool treatNullValueAsNonexistent);
}
internal interface System.Threading.IDeferredDisposable {
    public abstract virtual void OnFinalRelease(bool disposed);
}
public static class System.Threading.Interlocked : object {
    [IntrinsicAttribute]
public static int CompareExchange(Int32& location1, int value, int comparand);
    [IntrinsicAttribute]
public static long CompareExchange(Int64& location1, long value, long comparand);
    [IntrinsicAttribute]
public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    [IntrinsicAttribute]
public static float CompareExchange(Single& location1, float value, float comparand);
    [IntrinsicAttribute]
public static double CompareExchange(Double& location1, double value, double comparand);
    [IntrinsicAttribute]
public static T CompareExchange(T& location1, T value, T comparand);
    public static object CompareExchange(Object& location1, object value, object comparand);
    [IntrinsicAttribute]
public static int Exchange(Int32& location1, int value);
    [IntrinsicAttribute]
public static long Exchange(Int64& location1, long value);
    [IntrinsicAttribute]
public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    [IntrinsicAttribute]
public static float Exchange(Single& location1, float value);
    [IntrinsicAttribute]
public static double Exchange(Double& location1, double value);
    [IntrinsicAttribute]
public static T Exchange(T& location1, T value);
    public static object Exchange(Object& location1, object value);
    [IntrinsicAttribute]
public static int Increment(Int32& location);
    [IntrinsicAttribute]
public static long Increment(Int64& location);
    [IntrinsicAttribute]
public static int Decrement(Int32& location);
    [IntrinsicAttribute]
public static long Decrement(Int64& location);
    [IntrinsicAttribute]
public static int Add(Int32& location1, int value);
    [IntrinsicAttribute]
public static long Add(Int64& location1, long value);
    [IntrinsicAttribute]
public static void MemoryBarrier();
    public static long Read(Int64& location);
    public static void MemoryBarrierProcessWide();
}
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface System.Threading.IThreadPoolWorkItem {
    public abstract virtual void ExecuteWorkItem();
}
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    private static T EnsureInitializedCore(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static object EnsureLockInitialized(Object& syncLock);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class System.Threading.Lock : object {
    private static int SpinningNotInitialized;
    private static int SpinningDisabled;
    private static int MaxSpinningValue;
    private static int s_maxSpinCount;
    private static int Locked;
    private static int WaiterWoken;
    private static int WaiterCountIncrement;
    private static int Uncontended;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private UInt32 _recursionCount;
    private IntPtr _owningThreadId;
    private AutoResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEvent;
    private AutoResetEvent Event { get; }
    private static IntPtr CurrentNativeThreadId { get; }
    public bool IsAcquired { get; }
    private AutoResetEvent get_Event();
    private static IntPtr get_CurrentNativeThreadId();
    public void Acquire();
    public bool TryAcquire(TimeSpan timeout);
    public bool TryAcquire(int millisecondsTimeout);
    private bool TryAcquireContended(IntPtr currentThreadId, int millisecondsTimeout);
    public bool get_IsAcquired();
    public void Release();
    internal UInt32 ReleaseAll();
    private void ReleaseCore();
    private void ReleaseContended();
    internal void Reacquire(UInt32 previousRecursionCount);
}
[ReflectionBlockedAttribute]
[__BlockReflectionAttribute]
public class System.Threading.LockHolder : ValueType {
    private Lock _lock;
    public static LockHolder Hold(Lock l);
    public sealed virtual void Dispose();
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
    protected LockRecursionException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
internal class System.Threading.LowLevelLifoSemaphore : object {
    private IntPtr _completionPort;
    public LowLevelLifoSemaphore(int initialSignalCount, int maximumSignalCount);
    public bool Wait(int timeoutMs);
    public int Release(int count);
    public sealed virtual void Dispose();
}
internal class System.Threading.LowLevelLock : object {
    private static int LockedMask;
    private static int WaiterCountIncrement;
    private static int MaximumPreemptingAcquireDurationMilliseconds;
    private int _state;
    private bool _isAnyWaitingThreadSignaled;
    private FirstLevelSpinWaiter _spinWaiter;
    private Func`1<bool> _spinWaitTryAcquireCallback;
    private LowLevelMonitor _monitor;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void VerifyIsLocked();
    public void VerifyIsNotLocked();
    private void VerifyIsNotLockedByAnyThread();
    private void ResetOwnerThread();
    private void SetOwnerThreadToCurrent();
    public bool TryAcquire();
    private bool TryAcquire_NoFastPath(int state);
    private bool SpinWaitTryAcquireCallback();
    public void Acquire();
    private void WaitAndAcquire();
    public void Release();
    private void SignalWaiter();
}
internal class System.Threading.LowLevelMonitor : object {
    private CRITICAL_SECTION _criticalSection;
    private CONDITION_VARIABLE _conditionVariable;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public void VerifyIsLocked();
    public void VerifyIsNotLocked();
    private void VerifyIsNotLockedByAnyThread();
    private void ResetOwnerThread();
    private void SetOwnerThreadToCurrent();
    public void Acquire();
    public void Release();
    public void Wait();
    public bool Wait(int timeoutMilliseconds);
    public void Signal_Release();
    private void DisposeCore();
    private void AcquireCore();
    private void ReleaseCore();
    private void WaitCore();
    private bool WaitCore(int timeoutMilliseconds);
    private void Signal_ReleaseCore();
}
internal class System.Threading.ManagedThreadId : object {
    public static int IdNone;
    public static int IdMainThread;
    [ThreadStaticAttribute]
private static ManagedThreadId t_currentThreadId;
    [ThreadStaticAttribute]
private static int t_currentManagedThreadId;
    private static ImmutableIdDispenser s_idDispenser;
    private int _managedThreadId;
    public int Id { get; }
    public static int Current { get; }
    public int get_Id();
    public static int AllocateId();
    public static void RecycleId(int id);
    public static int get_Current();
    public static ManagedThreadId GetCurrentThreadId();
    private static int MakeForCurrentThread();
    public static int SetForCurrentThread(ManagedThreadId threadId);
    protected virtual override void Finalize();
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private static int DEFAULT_SPIN_SP;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static int SignalledState_BitMask;
    private static int SignalledState_ShiftCount;
    private static int Dispose_BitMask;
    private static int SpinCountState_BitMask;
    private static int SpinCountState_ShiftCount;
    private static int SpinCountState_MaxValue;
    private static int NumWaitersState_BitMask;
    private static int NumWaitersState_ShiftCount;
    private static int NumWaitersState_MaxValue;
    private static Action`1<object> s_cancellationTokenCallback;
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private bool LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
}
public static class System.Threading.Monitor : object {
    private static ConditionalWeakTable`2<object, Condition> s_conditionTable;
    private static CreateValueCallback<object, Condition> s_createCondition;
    [ThreadStaticAttribute]
private static IntPtr t_firstBlockingItem;
    private static Monitor();
    internal static Lock GetLock(object obj);
    private static Condition GetCondition(object obj);
    public static void Enter(object obj);
    public static void Enter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    public static void Exit(object obj);
    public static bool IsEntered(object obj);
    public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj);
    public static void Pulse(object obj);
    public static void PulseAll(object obj);
    internal static bool TryAcquireContended(Lock lck, object obj, int millisecondsTimeout);
}
public class System.Threading.Mutex : WaitHandle {
    private static UInt32 AccessRights;
    public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    public Mutex(bool initiallyOwned, string name);
    public Mutex(bool initiallyOwned);
    private Mutex(SafeWaitHandle handle);
    public static Mutex OpenExisting(string name);
    public static bool TryOpenExisting(string name, Mutex& result);
    private void CreateMutexCore(bool initiallyOwned, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Mutex& result);
    public void ReleaseMutex();
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
internal static class System.Threading.ObjectHeader : object {
    private static int IS_HASHCODE_BIT_NUMBER;
    private static int BIT_SBLK_IS_HASHCODE;
    internal static int MASK_HASHCODE_INDEX;
    public static int ReadVolatileMemory(Int32* pHeader);
    public static int GetHashCode(object o);
    private static int AssignHashCode(Int32* pHeader);
    public static bool GetSyncEntryIndex(int header, Int32& hashOrIndex);
    public static Lock GetLockObject(object o);
    public static void SetSyncEntryIndex(Int32* pHeader, int syncIndex);
}
public class System.Threading.Overlapped : object {
    private OverlappedData _overlappedData;
    public IAsyncResult AsyncResult { get; public set; }
    public int OffsetLow { get; public set; }
    public int OffsetHigh { get; public set; }
    [ObsoleteAttribute("This property is not 64-bit compatible.  Use EventHandleIntPtr instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public int EventHandle { get; public set; }
    public IntPtr EventHandleIntPtr { get; public set; }
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [ObsoleteAttribute("This constructor is not 64-bit compatible.  Use the constructor that takes an IntPtr for the event handle.  http://go.microsoft.com/fwlink/?linkid=14202")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    [ObsoleteAttribute("This method is not safe.  Use Pack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [ObsoleteAttribute("This method is not safe.  Use UnsafePack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
}
internal class System.Threading.OverlappedData : object {
    internal IAsyncResult _asyncResult;
    internal object _callback;
    internal Overlapped _overlapped;
    private object _userObject;
    private NativeOverlapped* _pNativeOverlapped;
    private IntPtr _eventHandle;
    private int _offsetLow;
    private int _offsetHigh;
    private GCHandle[] _pinnedData;
    internal IAsyncResult& AsyncResult { get; }
    internal Int32& OffsetLow { get; }
    internal Int32& OffsetHigh { get; }
    internal IntPtr& EventHandle { get; }
    internal IAsyncResult& get_AsyncResult();
    internal Int32& get_OffsetLow();
    internal Int32& get_OffsetHigh();
    internal IntPtr& get_EventHandle();
    internal NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    internal NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    private NativeOverlapped* AllocateNativeOverlapped();
    internal static void FreeNativeOverlapped(NativeOverlapped* nativeOverlappedPtr);
    private void FreeNativeOverlapped();
    internal static OverlappedData GetOverlappedFromNative(NativeOverlapped* pNativeOverlapped);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.PlatformHelper : object {
    private static int PROCESSOR_COUNT_REFRESH_INTERVAL_MS;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_lastProcessorCountRefreshTicks;
    internal static bool IsSingleProcessor;
    internal static int ProcessorCount { get; }
    private static PlatformHelper();
    internal static int get_ProcessorCount();
}
public class System.Threading.PreAllocatedOverlapped : object {
    internal Win32ThreadPoolNativeOverlapped* _overlapped;
    private DeferredDisposableLifetime`1<PreAllocatedOverlapped> _lifetime;
    [CLSCompliantAttribute("False")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    internal bool AddRef();
    internal void Release();
    public sealed virtual void Dispose();
    [__BlockReflectionAttribute]
protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.QueueUserWorkItemCallback : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    private ExecutionContext _context;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallback(WaitCallback callback, object state, ExecutionContext context);
    private static QueueUserWorkItemCallback();
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.QueueUserWorkItemCallback`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    private ExecutionContext _context;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallback`1(Action`1<TState> callback, TState state, ExecutionContext context);
    private static QueueUserWorkItemCallback`1();
    public virtual void ExecuteWorkItem();
}
internal abstract class System.Threading.QueueUserWorkItemCallbackBase : object {
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallbackDefaultContext(WaitCallback callback, object state);
    private static QueueUserWorkItemCallbackDefaultContext();
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    internal static ContextCallback s_executionContextShim;
    internal QueueUserWorkItemCallbackDefaultContext`1(Action`1<TState> callback, TState state);
    private static QueueUserWorkItemCallbackDefaultContext`1();
    public virtual void ExecuteWorkItem();
}
internal class System.Threading.ReaderWriterCount : object {
    public long lockID;
    public int readercount;
    public int writercount;
    public int upgradecount;
    public ReaderWriterCount next;
}
public class System.Threading.ReaderWriterLockSlim : object {
    private static int ProcessorCount;
    private bool _fIsReentrant;
    private SpinLock _spinLock;
    private UInt32 _numWriteWaiters;
    private UInt32 _numReadWaiters;
    private UInt32 _numWriteUpgradeWaiters;
    private UInt32 _numUpgradeWaiters;
    private WaiterStates _waiterStates;
    private int _upgradeLockOwnerId;
    private int _writeLockOwnerId;
    private EventWaitHandle _writeEvent;
    private EventWaitHandle _readEvent;
    private EventWaitHandle _upgradeEvent;
    private EventWaitHandle _waitUpgradeEvent;
    private static long s_nextLockID;
    private long _lockID;
    [ThreadStaticAttribute]
private static ReaderWriterCount t_rwc;
    private bool _fUpgradeThreadHoldingRead;
    private static int MaxSpinCount;
    private UInt32 _owners;
    private static UInt32 WRITER_HELD;
    private static UInt32 WAITING_WRITERS;
    private static UInt32 WAITING_UPGRADER;
    private static UInt32 MAX_READER;
    private static UInt32 READER_MASK;
    private bool _fDisposed;
    private bool HasNoWaiters { get; private set; }
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    private static ReaderWriterLockSlim();
    private void InitializeThreadCounts();
    private bool get_HasNoWaiters();
    private void set_HasNoWaiters(bool value);
    private static bool IsRWEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRWCount(bool dontAllocate);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(EventWaitHandle& waitEvent, EnterLockType enterLockType);
    private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, EnterLockType enterLockType);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private void ExitAndWakeUpAppropriateReadWaiters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private bool ShouldSpinForEnterAnyRead();
    private bool ShouldSpinForEnterAnyWrite(bool isUpgradeToWrite);
    private static void SpinWait(int spinCount);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    private Lock _lock;
    private SafeWaitHandle _waitHandle;
    private _ThreadPoolWaitOrTimerCallback _callbackHelper;
    private UInt32 _millisecondsTimeout;
    private bool _repeating;
    private bool _unregistering;
    private GCHandle _gcHandle;
    private IntPtr _tpWait;
    internal RegisteredWaitHandle(SafeWaitHandle waitHandle, _ThreadPoolWaitOrTimerCallback callbackHelper, UInt32 millisecondsTimeout, bool repeating);
    [NativeCallableAttribute]
internal static void RegisteredWaitCallback(IntPtr instance, IntPtr context, IntPtr wait, UInt32 waitResult);
    private void PerformCallback(bool timedOut);
    internal void RestartWait();
    public bool Unregister(WaitHandle waitObject);
    private void FinishUnregistering();
    private void FinishUnregisteringAsync(object waitObject);
    [__BlockReflectionAttribute]
protected virtual override void Finalize();
}
public class System.Threading.Semaphore : WaitHandle {
    private static UInt32 AccessRights;
    public Semaphore(int initialCount, int maximumCount);
    public Semaphore(int initialCount, int maximumCount, string name);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private Semaphore(SafeWaitHandle handle);
    public static Semaphore OpenExisting(string name);
    public static bool TryOpenExisting(string name, Semaphore& result);
    public int Release();
    public int Release(int releaseCount);
    private void CreateSemaphoreCore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Semaphore& result);
    private int ReleaseCore(int releaseCount);
}
[TypeForwardedFromAttribute("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
public class System.Threading.SemaphoreSlim : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private int m_waitCount;
    private int m_countOfWaitersPulsedToWake;
    private object m_lockObj;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle;
    private TaskNode m_asyncHead;
    private TaskNode m_asyncTail;
    private static Task`1<bool> s_trueTask;
    private static Task`1<bool> s_falseTask;
    private static int NO_MAXIMUM;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    private TaskNode CreateAndAddAsyncWaiter();
    private bool RemoveAsyncWaiter(TaskNode task);
    [AsyncStateMachineAttribute("System.Threading.SemaphoreSlim/<WaitUntilCountOrTimeoutAsync>d__33")]
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    private static void QueueWaiterTask(TaskNode waiterTask);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.SparselyPopulatedArray`1 : object {
    private SparselyPopulatedArrayFragment`1<T> _head;
    private SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    internal SparselyPopulatedArrayFragment`1<T> Tail { get; }
    internal SparselyPopulatedArray`1(int initialSize);
    internal SparselyPopulatedArrayFragment`1<T> get_Tail();
    internal SparselyPopulatedArrayAddInfo`1<T> Add(T element);
}
internal class System.Threading.SparselyPopulatedArrayAddInfo`1 : ValueType {
    private SparselyPopulatedArrayFragment`1<T> _source;
    private int _index;
    internal SparselyPopulatedArrayFragment`1<T> Source { get; }
    internal int Index { get; }
    internal SparselyPopulatedArrayAddInfo`1(SparselyPopulatedArrayFragment`1<T> source, int index);
    internal SparselyPopulatedArrayFragment`1<T> get_Source();
    internal int get_Index();
}
[DefaultMemberAttribute("Item")]
internal class System.Threading.SparselyPopulatedArrayFragment`1 : object {
    internal T[] _elements;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _freeCount;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _next;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _prev;
    internal T Item { get; }
    internal int Length { get; }
    internal SparselyPopulatedArrayFragment`1<T> Prev { get; }
    internal SparselyPopulatedArrayFragment`1(int size);
    internal SparselyPopulatedArrayFragment`1(int size, SparselyPopulatedArrayFragment`1<T> prev);
    internal T get_Item(int index);
    internal int get_Length();
    internal SparselyPopulatedArrayFragment`1<T> get_Prev();
    internal T SafeAtomicRemove(int index, T expectedElement);
}
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
public class System.Threading.SpinLock : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owner;
    private static int SLEEP_ONE_FREQUENCY;
    private static int TIMEOUT_CHECK_FREQUENCY;
    private static int LOCK_ID_DISABLE_MASK;
    private static int LOCK_ANONYMOUS_OWNED;
    private static int WAITERS_MASK;
    private static int ID_DISABLED_AND_ANONYMOUS_OWNED;
    private static int LOCK_UNOWNED;
    private static int MAXIMUM_WAITERS;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static SpinLock();
    private static int CompareExchange(Int32& location, int value, int comparand, Boolean& success);
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken);
    public void Exit();
    public void Exit(bool useMemoryBarrier);
    private void ExitSlowPath(bool useMemoryBarrier);
    public bool get_IsHeld();
    public bool get_IsHeldByCurrentThread();
    public bool get_IsThreadOwnerTrackingEnabled();
}
public class System.Threading.SpinWait : ValueType {
    internal static int YieldThreshold;
    private static int Sleep0EveryHowManyYields;
    internal static int DefaultSleep1Threshold;
    internal static int SpinCountforSpinBeforeWait;
    internal static int Sleep1ThresholdForLongSpinBeforeWait;
    private int _count;
    public int Count { get; internal set; }
    public bool NextSpinWillYield { get; }
    private static SpinWait();
    public int get_Count();
    internal void set_Count(int value);
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    [__BlockReflectionAttribute]
public void SpinOnce(int sleep1Threshold);
    private void SpinOnceCore(int sleep1Threshold);
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
public class System.Threading.SynchronizationContext : object {
    private SynchronizationContextProperties _props;
    internal static SynchronizationContext CurrentExplicit { get; }
    public static SynchronizationContext Current { get; }
    protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [CLSCompliantAttribute("False")]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public static void SetSynchronizationContext(SynchronizationContext syncContext);
    internal static SynchronizationContext get_CurrentExplicit();
    public virtual SynchronizationContext CreateCopy();
    public static SynchronizationContext get_Current();
}
[FlagsAttribute]
internal enum System.Threading.SynchronizationContextProperties : Enum {
    public int value__;
    public static SynchronizationContextProperties None;
    public static SynchronizationContextProperties RequireWaitNotification;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
[EagerStaticClassConstructionAttribute]
internal static class System.Threading.SyncTable : object {
    private static int InitialSize;
    private static int DoublingSizeThreshold;
    internal static Lock s_freeEntriesLock;
    private static Entry[] s_entries;
    private static int s_freeEntryList;
    private static int s_unusedEntryIndex;
    private static Lock s_usedEntriesLock;
    private static SyncTable();
    public static int AssignEntry(object obj, Int32* pHeader);
    private static int EnsureFreeEntry();
    private static int RecycleDeadEntries();
    private static void FreeDeadEntries();
    private static void Grow();
    private static int CalculateNewSize(int oldSize);
    public static int GetHashCode(int syncIndex);
    public static int SetHashCode(int syncIndex, int hashCode);
    public static void MoveHashCodeToNewEntry(int syncIndex, int hashCode);
    public static Lock GetLockObject(int syncIndex);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> _tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    private ExecutionContext m_capturedContext;
    protected Action m_action;
    private static ContextCallback s_invokeActionCallback;
    internal static bool IsValidLocationForInlining { get; }
    internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    internal virtual void Run(Task ignored, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private static void InvokeAction(object state);
    protected static ContextCallback GetInvokeActionCallback();
    protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    internal static void RunOrScheduleAction(Action action, bool allowInlining, Task& currentTask);
    internal static void UnsafeScheduleAction(Action action);
    protected static void ThrowAsyncIfNecessary(Exception exc);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.CompletionActionInvoker : object {
    private ITaskCompletionAction m_action;
    private Task m_completingTask;
    internal CompletionActionInvoker(ITaskCompletionAction action, Task completingTask);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
}
[DebuggerDisplayAttribute("Concurrent={ConcurrentTaskCountForDebugger}, Exclusive={ExclusiveTaskCountForDebugger}, Mode={ModeForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    private ThreadLocal`1<ProcessingMode> m_threadProcessingMode;
    private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
    private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
    private TaskScheduler m_underlyingTaskScheduler;
    private int m_maxConcurrencyLevel;
    private int m_maxItemsPerTask;
    private int m_processingCount;
    private CompletionState m_completionState;
    private static int UNLIMITED_PROCESSING;
    private static int EXCLUSIVE_PROCESSING_SENTINEL;
    private static int DEFAULT_MAXITEMSPERTASK;
    private static int DefaultMaxConcurrencyLevel { get; }
    private object ValueLock { get; }
    public Task Completion { get; }
    private bool CompletionRequested { get; }
    private bool ReadyToComplete { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    private int ConcurrentTaskCountForDebugger { get; }
    private int ExclusiveTaskCountForDebugger { get; }
    private ProcessingMode ModeForDebugger { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    private static int get_DefaultMaxConcurrencyLevel();
    private object get_ValueLock();
    public void Complete();
    public Task get_Completion();
    private CompletionState EnsureCompletionStateInitialized();
    private bool get_CompletionRequested();
    private void RequestCompletion();
    private void CleanupStateIfCompletingAndQuiesced();
    private bool get_ReadyToComplete();
    private void CompleteTaskAsync();
    private void FaultWithTask(Task faultedTask);
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    private int get_ConcurrentTaskCountForDebugger();
    private int get_ExclusiveTaskCountForDebugger();
    private void ProcessAsyncIfNecessary(bool fairly);
    private void ProcessExclusiveTasks();
    private void ProcessConcurrentTasks();
    private ProcessingMode get_ModeForDebugger();
    [ConditionalAttribute("DEBUG")]
private static void ContractAssertMonitorStatus(object syncObj, bool held);
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    private Task m_antecedent;
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    private Task m_antecedent;
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
[ExtensionAttribute]
internal static class System.Threading.Tasks.DebuggerSupport : object {
    private static LowLevelDictionary`2<int, Task> s_activeTasks;
    private static object s_activeTasksLock;
    public static bool LoggingOn { get; }
    private static DebuggerSupport();
    public static void AddToActiveTasks(Task task);
    private static void AddToActiveTasksNonInlined(Task task);
    public static void RemoveFromActiveTasks(Task task);
    private static void RemoveFromActiveTasksNonInlined(Task task);
    public static Task GetActiveTaskFromId(int taskId);
    [ExtensionAttribute]
public static Task GetTaskIfDebuggingEnabled(AsyncVoidMethodBuilder builder);
    [ExtensionAttribute]
public static Task GetTaskIfDebuggingEnabled(AsyncTaskMethodBuilder builder);
    [ExtensionAttribute]
public static Task GetTaskIfDebuggingEnabled(AsyncTaskMethodBuilder`1<TResult> builder);
    public static bool get_LoggingOn();
    public static void TraceOperationCreation(CausalityTraceLevel traceLevel, Task task, string operationName, ulong relatedContext);
    public static void TraceOperationCompletion(CausalityTraceLevel traceLevel, Task task, AsyncStatus status);
    public static void TraceOperationRelation(CausalityTraceLevel traceLevel, Task task, CausalityRelation relation);
    public static void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, Task task, CausalitySynchronousWork work);
    public static void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work);
}
internal static class System.Threading.Tasks.GenericDelegateCache`2 : object {
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate;
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate;
    private static GenericDelegateCache`2();
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public bool InvokeMayRunArbitraryCode { get; }
    public abstract virtual void Invoke(Task completingTask);
    public abstract virtual bool get_InvokeMayRunArbitraryCode();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
internal class System.Threading.Tasks.PaddingFor32 : ValueType {
}
internal static class System.Threading.Tasks.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private static int INIT_SEGMENT_SIZE;
    private static int MAX_SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public bool TryPeek(T& result);
    private bool TryPeekSlow(Segment& segment, T[]& array, T& result);
    public bool TryDequeueIf(Predicate`1<T> predicate, T& result);
    private bool TryDequeueIfSlow(Predicate`1<T> predicate, Segment& segment, T[]& array, T& result);
    public void Clear();
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual TResult GetResult(short token);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
internal class System.Threading.Tasks.StackGuard : object {
    private int m_inliningDepth;
    private static int MAX_UNCHECKED_INLINING_DEPTH;
    internal bool TryBeginInliningScope();
    internal void EndInliningScope();
}
internal class System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    private TaskScheduler m_taskScheduler;
    internal StandardTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    private static SendOrPostCallback s_postCallback;
    private static ContextCallback s_postActionCallback;
    private SynchronizationContext m_syncContext;
    internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext);
    private static SynchronizationContextAwaitTaskContinuation();
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
    private static void PostAction(object state);
    private static ContextCallback GetPostActionCallback();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
public class System.Threading.Tasks.Task : object {
    internal static int s_taskIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskId;
    internal Delegate m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Task m_parent;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    private static int OptionsMask;
    internal static int TASK_STATE_STARTED;
    internal static int TASK_STATE_DELEGATE_INVOKED;
    internal static int TASK_STATE_DISPOSED;
    internal static int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT;
    internal static int TASK_STATE_CANCELLATIONACKNOWLEDGED;
    internal static int TASK_STATE_FAULTED;
    internal static int TASK_STATE_CANCELED;
    internal static int TASK_STATE_WAITING_ON_CHILDREN;
    internal static int TASK_STATE_RAN_TO_COMPLETION;
    internal static int TASK_STATE_WAITINGFORACTIVATION;
    internal static int TASK_STATE_COMPLETION_RESERVED;
    internal static int TASK_STATE_THREAD_WAS_ABORTED;
    internal static int TASK_STATE_WAIT_COMPLETION_NOTIFICATION;
    private static int TASK_STATE_COMPLETED_MASK;
    private static int CANCELLATION_REQUESTED;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject;
    private static object s_taskCompletionSentinel;
    internal static bool s_asyncDebuggingEnabled;
    internal ContingentProperties modreq(System.Runtime.CompilerServices.IsVolatile) m_contingentProperties;
    private static Action`1<object> s_taskCancelCallback;
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    [ThreadStaticAttribute]
private static StackGuard t_stackGuard;
    private static Func`1<ContingentProperties> s_createContingentProperties;
    [CompilerGeneratedAttribute]
private static TaskFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    private static Predicate`1<Task> s_IsExceptionObservedByParentPredicate;
    private static ContextCallback s_ecCallback;
    private static Predicate`1<object> s_IsTaskContinuationNullPredicate;
    private Task ParentForDebugger { get; }
    private int StateFlagsForDebugger { get; }
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    internal bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    internal static Task InternalCurrent { get; }
    internal static StackGuard CurrentStackGuard { get; }
    public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    public static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    private Task get_ParentForDebugger();
    private int get_StateFlagsForDebugger();
    internal void TaskConstructorCore(Delegate action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
    private static void TaskCancelCallback(object o);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    internal bool TrySetException(object exceptionObject);
    private string get_DebuggerDisplayMethodDescription();
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    private void NotifyDebuggerOfWaitCompletion();
    internal bool MarkStarted();
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions);
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    internal static StackGuard get_CurrentStackGuard();
    public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection);
    private ContingentProperties EnsureContingentPropertiesInitializedCore(bool needsProtection);
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    private static bool IsCompletedMethod(int flags);
    public bool get_IsCompletedSuccessfully();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    [CompilerGeneratedAttribute]
public static TaskFactory get_Factory();
    [CompilerGeneratedAttribute]
public static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool bUserDelegateExecuted);
    internal void FinishStageTwo();
    internal void FinishStageThree();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren();
    private void Execute();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    internal bool ExecuteEntry(bool bPreventDoubleExecution);
    private void ExecuteWithThreadLocal(Task& currentTaskSlot);
    private static void ExecutionContextCallback(object obj);
    internal virtual void InnerInvoke();
    private void HandleException(Exception unhandledException);
    public TaskAwaiter GetAwaiter();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinWait(int millisecondsTimeout);
    internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    internal void FinishContinuations();
    private void LogFinishCompletionNotification();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action);
    private void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
    private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
    private bool AddTaskContinuation(object tc, bool addBeforeOthers);
    internal void RemoveContinuation(object continuationObject);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static void AddToList(T item, LowLevelListWithIList`1& list, int initSize);
    private static bool WaitAllBlockingCore(LowLevelListWithIList`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void AddExceptionsForCompletedTask(LowLevelListWithIList`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    internal static Task FromCancellation(CancellationToken cancellationToken);
    public static Task FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(OperationCanceledException exception);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    private static Task InternalWhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    private static Task`1<TResult[]> InternalWhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    [__BlockReflectionAttribute]
public static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
    [DependencyReductionRootAttribute]
internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    private static Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
    [DependencyReductionRootAttribute]
private static Task GetActiveTaskFromId(int taskId);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
public class System.Threading.Tasks.Task`1 : Task {
    internal TResult m_result;
    private static TaskFactory`1<TResult> s_defaultFactory;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    public TResult get_Result();
    internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task _canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> _task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    private void SpinUntilCompleted();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public void SetCanceled();
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
    [DependencyReductionRootAttribute]
internal abstract virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private static bool s_failFastOnUnobservedException;
    private Task m_task;
    private LowLevelListWithIList`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions;
    private ExceptionDispatchInfo m_cancellationException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled;
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    private static TaskExceptionHolder();
    private static bool ShouldFailFastOnUnobservedException();
    protected virtual override void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject);
    internal void Add(object exceptionObject, bool representsCancellation);
    private void SetCancellationException(object exceptionObject);
    private void AddFaultException(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[DebuggerDisplayAttribute("Id={Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers;
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId;
    private static EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException;
    private static Lock _unobservedTaskExceptionLockObject;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    protected internal abstract virtual void QueueTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    private void AddToActiveTaskSchedulers();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    protected bool TryExecuteTask(Task task);
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    internal Task[] GetScheduledTasksForDebugger();
    internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    private TaskScheduler m_scheduler;
    internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [IteratorStateMachineAttribute("System.Threading.Tasks.ThreadPoolTaskScheduler/<FilterTasksFromWorkItems>d__6")]
private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<IThreadPoolWorkItem> tpwItems);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    private static byte STATE_WAITING_ON_OUTER_TASK;
    private static byte STATE_WAITING_ON_INNER_TASK;
    private static byte STATE_DONE;
    private byte _state;
    private bool _lookForOce;
    public bool InvokeMayRunArbitraryCode { get; }
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
    private void InvokeCore(Task completingTask);
    private void InvokeCoreAsync(Task completingTask);
    private void ProcessCompletedOuterTask(Task task);
    private bool TrySetFromTask(Task task, bool lookForOce);
    private void ProcessInnerTask(Task task);
    public sealed virtual bool get_InvokeMayRunArbitraryCode();
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private static Task s_canceledTask;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    internal static Task CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    private static ValueTask();
    internal static Task get_CompletedTask();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    [StackTraceHiddenAttribute]
internal void ThrowIfCompletedUnsuccessfully();
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1<TResult> s_canceledTask;
    internal object _obj;
    internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public virtual string ToString();
}
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    internal ThreadAbortException(SerializationInfo info, StreamingContext context);
    public object get_ExceptionState();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}, Count={ValuesCountForDebugDisplay}")]
public class System.Threading.ThreadLocal`1 : object {
    private Func`1<T> _valueFactory;
    [ThreadStaticAttribute]
private static LinkedSlotVolatile[] ts_slotArray;
    [ThreadStaticAttribute]
private static FinalizationHelper<T> ts_finalizationHelper;
    private int _idComplement;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initialized;
    private static IdManager<T> s_idManager;
    private LinkedSlot<T> _linkedSlot;
    private bool _trackAllValues;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    private int ValuesCountForDebugDisplay { get; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    private void Initialize(Func`1<T> valueFactory, bool trackAllValues);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private T GetValueSlow();
    private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray);
    private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value);
    public IList`1<T> get_Values();
    private List`1<T> GetValuesAsList();
    private int get_ValuesCountForDebugDisplay();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
    private void GrowTable(LinkedSlotVolatile[]& table, int minLength);
    private static int GetNewTableSize(int minSize);
}
public static class System.Threading.ThreadPool : object {
    private static UInt32 DispatchQuantum;
    private static int MaxThreadCount;
    private static IntPtr s_work;
    internal static bool IsThreadPoolThread { get; }
    private static ThreadPool();
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static bool QueueUserWorkItem(WaitCallback callBack);
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    public static bool QueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    internal static void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal);
    internal static bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem);
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetQueuedWorkItems>d__14")]
internal static IEnumerable`1<IThreadPoolWorkItem> GetQueuedWorkItems();
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetLocallyQueuedWorkItems>d__15")]
internal static IEnumerable`1<IThreadPoolWorkItem> GetLocallyQueuedWorkItems();
    internal static IEnumerable`1<IThreadPoolWorkItem> GetGloballyQueuedWorkItems();
    private static Object[] ToObjectArray(IEnumerable`1<IThreadPoolWorkItem> workitems);
    internal static Object[] GetQueuedWorkItemsForDebugger();
    internal static Object[] GetGloballyQueuedWorkItemsForDebugger();
    internal static Object[] GetLocallyQueuedWorkItemsForDebugger();
    private static void NativeOverlappedCallback(object obj);
    [CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
public static bool BindHandle(IntPtr osHandle);
    public static bool BindHandle(SafeHandle osHandle);
    internal static bool get_IsThreadPoolThread();
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    internal static bool KeepDispatching(int startTickCount);
    internal static void NotifyWorkItemProgress();
    internal static bool NotifyWorkItemComplete();
    [NativeCallableAttribute]
private static void DispatchCallback(IntPtr instance, IntPtr context, IntPtr work);
    internal static void RequestWorkerThread();
    private static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, bool flowExecutionContext);
}
public class System.Threading.ThreadPoolBoundHandle : object {
    private SafeHandle _handle;
    private SafeThreadPoolIOHandle _threadPoolHandle;
    private DeferredDisposableLifetime`1<ThreadPoolBoundHandle> _lifetime;
    public SafeHandle Handle { get; }
    private ThreadPoolBoundHandle(SafeHandle handle, SafeThreadPoolIOHandle threadPoolHandle);
    public SafeHandle get_Handle();
    public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
    private static OverlappedData GetOverlappedData(Win32ThreadPoolNativeOverlapped* overlapped, ThreadPoolBoundHandle expectedBoundHandle);
    [NativeCallableAttribute]
private static void OnNativeIOCompleted(IntPtr instance, IntPtr context, IntPtr overlappedPtr, UInt32 ioResult, UIntPtr numberOfBytesTransferred, IntPtr ioPtr);
    private bool AddRef();
    private void Release();
    public sealed virtual void Dispose();
    [__BlockReflectionAttribute]
protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.ThreadPoolCallbackWrapper : ValueType {
    private RuntimeThread _currentThread;
    public static ThreadPoolCallbackWrapper Enter();
    public void Exit(bool resetThread);
}
internal static class System.Threading.ThreadPoolGlobals : object {
    public static int processorCount;
    private static ThreadPoolWorkQueue _workQueue;
    public static ThreadPoolWorkQueue workQueue { get; }
    private static ThreadPoolGlobals();
    public static ThreadPoolWorkQueue get_workQueue();
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    internal ConcurrentQueue`1<IThreadPoolWorkItem> workItems;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numOutstandingThreadRequests;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numWorkingThreads;
    public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
    internal void EnsureThreadRequested();
    internal void MarkThreadRequestSatisfied();
    public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal);
    internal bool LocalFindAndPop(IThreadPoolWorkItem callback);
    public IThreadPoolWorkItem Dequeue(ThreadPoolWorkQueueThreadLocals tl, Boolean& missedSteal);
    internal static bool Dispatch();
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public FastRandom random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    private void CleanUp();
    protected virtual override void Finalize();
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(Exception reason);
    private ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
public static class System.Threading.Timeout : object {
    public static TimeSpan InfiniteTimeSpan;
    public static int Infinite;
    internal static UInt32 UnsignedInfinite;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
public class System.Threading.Timer : MarshalByRefObject {
    private static UInt32 MAX_SUPPORTED_TIMEOUT;
    private TimerHolder _timer;
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback);
    private void TimerSetup(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public bool Change(int dueTime, int period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public bool Change(long dueTime, long period);
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual void Dispose();
    internal void KeepRootedWhileScheduled();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.TimerHolder : object {
    internal TimerQueueTimer m_timer;
    public TimerHolder(TimerQueueTimer timer);
    protected virtual override void Finalize();
    public void Close();
    public bool Close(WaitHandle notifyObject);
}
internal class System.Threading.TimerQueue : object {
    private static TimerQueue s_queue;
    private int _currentNativeTimerStartTicks;
    private UInt32 _currentNativeTimerDuration;
    private TimerQueueTimer _timers;
    internal Lock Lock;
    private static WaitCallback s_fireQueuedTimerCompletion;
    private IntPtr _nativeTimer;
    public static TimerQueue Instance { get; }
    private static int TickCount { get; }
    private static TimerQueue();
    public static TimerQueue get_Instance();
    private void EnsureAppDomainTimerFiresBy(UInt32 requestedDuration);
    private void FireNextTimers();
    private static void QueueTimerCompletion(TimerQueueTimer timer);
    private static void FireQueuedTimerCompletion(object state);
    public bool UpdateTimer(TimerQueueTimer timer, UInt32 dueTime, UInt32 period);
    public void DeleteTimer(TimerQueueTimer timer);
    [NativeCallableAttribute]
private static void TimerCallback(IntPtr instance, IntPtr context, IntPtr timer);
    private void SetTimer(UInt32 actualDuration);
    private static int get_TickCount();
}
internal class System.Threading.TimerQueueTimer : object {
    internal TimerQueueTimer m_next;
    internal TimerQueueTimer m_prev;
    internal int m_startTicks;
    internal UInt32 m_dueTime;
    internal UInt32 m_period;
    private TimerCallback _timerCallback;
    private object _state;
    private ExecutionContext _executionContext;
    private int _callbacksRunning;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _canceled;
    private WaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) _notifyWhenNoCallbacksRunning;
    private static ContextCallback s_callCallbackInContext;
    internal TimerQueueTimer(TimerCallback timerCallback, object state, UInt32 dueTime, UInt32 period);
    internal bool Change(UInt32 dueTime, UInt32 period);
    public void Close();
    public bool Close(WaitHandle toSignal);
    internal void Fire();
    internal void CallCallback();
    private static void CallCallbackInContext(object state);
    private void SignalNoCallbacksRunning();
}
public static class System.Threading.Volatile : object {
    public static bool Read(Boolean& location);
    public static void Write(Boolean& location, bool value);
    public static byte Read(Byte& location);
    public static void Write(Byte& location, byte value);
    public static double Read(Double& location);
    public static void Write(Double& location, double value);
    public static short Read(Int16& location);
    public static void Write(Int16& location, short value);
    public static int Read(Int32& location);
    public static void Write(Int32& location, int value);
    public static long Read(Int64& location);
    public static void Write(Int64& location, long value);
    public static IntPtr Read(IntPtr& location);
    public static void Write(IntPtr& location, IntPtr value);
    [CLSCompliantAttribute("False")]
public static sbyte Read(SByte& location);
    [CLSCompliantAttribute("False")]
public static void Write(SByte& location, sbyte value);
    public static float Read(Single& location);
    public static void Write(Single& location, float value);
    [CLSCompliantAttribute("False")]
public static ushort Read(UInt16& location);
    [CLSCompliantAttribute("False")]
public static void Write(UInt16& location, ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 Read(UInt32& location);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32& location, UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong Read(UInt64& location);
    [CLSCompliantAttribute("False")]
public static void Write(UInt64& location, ulong value);
    [CLSCompliantAttribute("False")]
public static UIntPtr Read(UIntPtr& location);
    [CLSCompliantAttribute("False")]
public static void Write(UIntPtr& location, UIntPtr value);
    public static T Read(T& location);
    public static void Write(T& location, T value);
}
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    internal static int WaitObject0;
    public static int WaitTimeout;
    internal static int WaitAbandoned;
    internal static int WaitFailed;
    internal static int MaxWaitHandles;
    protected static IntPtr InvalidHandle;
    internal SafeWaitHandle _waitHandle;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    internal static int ToTimeoutMilliseconds(TimeSpan timeout);
    public virtual bool WaitOne(int millisecondsTimeout);
    private bool WaitOneCore(int millisecondsTimeout, bool interruptible);
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    internal bool WaitOne(bool interruptible);
    private static SafeWaitHandle[] ObtainSafeWaitHandles(RuntimeThread currentThread, WaitHandle[] waitHandles, int numWaitHandles, SafeWaitHandle[]& rentedSafeWaitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    internal static int WaitAny(WaitHandle[] waitHandles, int numWaitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    private static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    public virtual void Close();
    protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
    internal static void ThrowInvalidHandleException();
    internal static int WaitForSingleObject(IntPtr handle, int millisecondsTimeout, bool interruptible);
    internal static int WaitForMultipleObjectsIgnoringSyncContext(IntPtr[] handles, int numHandles, bool waitAll, int millisecondsTimeout);
    private static int WaitForMultipleObjectsIgnoringSyncContext(IntPtr* pHandles, int numHandles, bool waitAll, int millisecondsTimeout, bool interruptible);
    private static bool WaitOneCore(IntPtr handle, int millisecondsTimeout, bool interruptible);
    private static int WaitMultiple(RuntimeThread currentThread, SafeWaitHandle[] safeWaitHandles, int count, int millisecondsTimeout, bool waitAll);
    private static int WaitAnyCore(RuntimeThread currentThread, SafeWaitHandle[] safeWaitHandles, WaitHandle[] waitHandles, int numWaitHandles, int millisecondsTimeout);
    private static bool WaitAllCore(RuntimeThread currentThread, SafeWaitHandle[] safeWaitHandles, WaitHandle[] waitHandles, int millisecondsTimeout);
    private static bool SignalAndWaitCore(IntPtr handleToSignal, IntPtr handleToWaitOn, int millisecondsTimeout);
    private static void ThrowAbandonedMutexException();
    private static void ThrowAbandonedMutexException(int location, WaitHandle handle);
    internal static void ThrowSignalOrUnsignalException();
    private static void ThrowWaitFailedException(int errorCode);
    internal static Exception ExceptionFromCreationError(int errorCode, string path);
}
internal class System.Threading.WaitHandleArray`1 : ValueType {
    private static int MaximumCapacity;
    private static int InitialCapacity;
    private T[] _items;
    public T[] Items { get; }
    public WaitHandleArray`1(Func`2<int, T> elementInitializer);
    public T[] get_Items();
    public T[] RentItems();
    public void ReturnItems(T[] items);
    [ConditionalAttribute("DEBUG")]
public void VerifyElementsAreDefault();
    public void EnsureCapacity(int requiredCapacity, Func`2<int, T> elementInitializer);
    private void Grow(int requiredCapacity, Func`2<int, T> elementInitializer);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.Win32ThreadPoolNativeOverlapped : ValueType {
    [ThreadStaticAttribute]
private static ExecutionContextCallbackArgs t_executionContextCallbackArgs;
    private static ContextCallback s_executionContextCallback;
    private static OverlappedData[] s_dataArray;
    private static int s_dataCount;
    private static IntPtr s_freeList;
    private NativeOverlapped _overlapped;
    private IntPtr _nextFree;
    private int _dataIndex;
    internal OverlappedData Data { get; }
    internal OverlappedData get_Data();
    internal static Win32ThreadPoolNativeOverlapped* Allocate(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    private static Win32ThreadPoolNativeOverlapped* AllocateNew();
    private void SetData(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    internal static void Free(Win32ThreadPoolNativeOverlapped* overlapped);
    internal static NativeOverlapped* ToNativeOverlapped(Win32ThreadPoolNativeOverlapped* overlapped);
    internal static Win32ThreadPoolNativeOverlapped* FromNativeOverlapped(NativeOverlapped* overlapped);
    internal static void CompleteWithCallback(UInt32 errorCode, UInt32 bytesWritten, Win32ThreadPoolNativeOverlapped* overlapped);
    private static void OnExecutionContextCallback(object state);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
[StackTraceHiddenAttribute]
internal static class System.ThrowHelper : object {
    internal static void ThrowArrayTypeMismatchException();
    internal static void ThrowInvalidTypeWithPointersNotSupported(Type targetType);
    internal static void ThrowIndexOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    internal static void ThrowArgumentException_DestinationTooShort();
    internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    internal static void ThrowArgumentOutOfRange_IndexException();
    internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    internal static void ThrowWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    internal static void ThrowWrongValueTypeArgumentException(object value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    internal static void ThrowAddingDuplicateWithKeyArgumentException(object key);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    internal static void ThrowKeyNotFoundException(object key);
    internal static void ThrowArgumentException(ExceptionResource resource);
    private static ArgumentException GetArgumentException(ExceptionResource resource, ExceptionArgument argument);
    internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    internal static void ThrowArgumentException_Argument_InvalidArrayType();
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowInvalidOperationException_OutstandingReferences();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    internal static void ThrowInvalidOperationException_InvalidOperation_NoValue();
    internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    internal static void ThrowSerializationException(ExceptionResource resource);
    internal static void ThrowObjectDisposedException_MemoryDisposed();
    internal static void ThrowNotSupportedException();
    internal static void ThrowNotSupportedException(ExceptionResource resource);
    private static Exception GetArraySegmentCtorValidationFailedException(Array array, int offset, int count);
    internal static void ThrowArraySegmentCtorValidationFailedExceptions(Array array, int offset, int count);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    protected TimeoutException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.TimeSpan : ValueType {
    public static long TicksPerMillisecond;
    private static double MillisecondsPerTick;
    public static long TicksPerSecond;
    private static double SecondsPerTick;
    public static long TicksPerMinute;
    private static double MinutesPerTick;
    public static long TicksPerHour;
    private static double HoursPerTick;
    public static long TicksPerDay;
    private static double DaysPerTick;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static long TicksPerTenthSecond;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(long ticks);
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    private static TimeSpan Interval(double value, int scale);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    public TimeSpan Multiply(double factor);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    private static void ValidateStyles(TimeSpanStyles style, string parameterName);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
}
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    private static TimeZone modreq(System.Runtime.CompilerServices.IsVolatile) currentTimeZone;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static TimeZone();
    private static object get_InternalSyncObject();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneInfo : object {
    private string _id;
    private string _displayName;
    private string _standardDisplayName;
    private string _daylightDisplayName;
    private TimeSpan _baseUtcOffset;
    private bool _supportsDaylightSavingTime;
    private AdjustmentRule[] _adjustmentRules;
    private static string UtcId;
    private static string LocalId;
    private static TimeZoneInfo s_utcTimeZone;
    private static CachedData s_cachedData;
    private static DateTime s_maxDateOnly;
    private static DateTime s_minDateOnly;
    private static TimeSpan MaxOffset;
    private static TimeSpan MinOffset;
    private static string TimeZonesRegistryHive;
    private static string DisplayValue;
    private static string DaylightValue;
    private static string StandardValue;
    private static string MuiDisplayValue;
    private static string MuiDaylightValue;
    private static string MuiStandardValue;
    private static string TimeZoneInfoValue;
    private static string FirstEntryValue;
    private static string LastEntryValue;
    private static int MaxKeyLength;
    public string Id { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private TimeZoneInfo(SerializationInfo info, StreamingContext context);
    private TimeZoneInfo(TIME_ZONE_INFORMATION& zone, bool dstDisabled);
    private static TimeZoneInfo();
    public string get_Id();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    private AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(DateTime adjustedTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetPreviousAdjustmentRule(AdjustmentRule rule, Nullable`1<int> ruleIndex);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    private TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    private bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    private static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags, CachedData cachedData);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, bool dateTimeisUtc, Nullable`1& ruleIndex);
    private int CompareAdjustmentRuleToDateTime(AdjustmentRule rule, AdjustmentRule previousRule, DateTime dateTime, DateTime dateOnly, bool dateTimeisUtc);
    private DateTime ConvertToUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertToFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta, bool convertToUtc);
    private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone, Boolean& isAmbiguousLocalDst);
    private DaylightTimeStruct GetDaylightTime(int year, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime, TimeZoneInfoOptions flags);
    private TimeSpan GetDaylightSavingsStartOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private TimeSpan GetDaylightSavingsEndOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule);
    private static bool GetIsDaylightSavingsFromUtc(DateTime time, int year, TimeSpan utc, AdjustmentRule rule, Nullable`1<int> ruleIndex, Boolean& isAmbiguousLocalDst, TimeZoneInfo zone);
    private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment, AdjustmentRule rule);
    private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone, TimeZoneInfoOptions flags);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime);
    private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData);
    private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
    private static TimeSpan GetUtcOffset(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static bool IsValidAdjustmentRuleOffest(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static void NormalizeAdjustmentRuleOffset(TimeSpan baseUtcOffset, AdjustmentRule& adjustmentRule);
    public AdjustmentRule[] GetAdjustmentRules();
    private static void PopulateAllSystemTimeZones(CachedData cachedData);
    private static bool CheckDaylightSavingTimeNotSupported(TIME_ZONE_INFORMATION& timeZone);
    private static AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(REG_TZI_FORMAT& timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset);
    private static string FindIdFromTimeZoneInformation(TIME_ZONE_INFORMATION& timeZone, Boolean& dstDisabled);
    private static TimeZoneInfo GetLocalTimeZone(CachedData cachedData);
    private static TimeZoneInfo GetLocalTimeZoneFromWin32Data(TIME_ZONE_INFORMATION& timeZoneInformation, bool dstDisabled);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    private static bool TransitionTimeFromTimeZoneInformation(REG_TZI_FORMAT& timeZoneInformation, TransitionTime& transitionTime, bool readStartDate);
    private static bool TryCreateAdjustmentRules(string id, REG_TZI_FORMAT& defaultTimeZoneInformation, AdjustmentRule[]& rules, Exception& e, int defaultBaseUtcOffset);
    private static bool TryGetTimeZoneEntryFromRegistry(RegistryKey key, string name, REG_TZI_FORMAT& dtzi);
    private static bool TryCompareStandardDate(TIME_ZONE_INFORMATION& timeZone, REG_TZI_FORMAT& registryTimeZoneInfo);
    private static bool TryCompareTimeZoneInformationToRegistry(TIME_ZONE_INFORMATION& timeZone, string id, Boolean& dstDisabled);
    private static string TryGetLocalizedNameByMuiNativeResource(string resource);
    private static string TryGetLocalizedNameByNativeResource(string filePath, int resource);
    private static void GetLocalizedNamesByRegistryKey(RegistryKey key, String& displayName, String& standardName, String& daylightName);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, TimeZoneInfo& value, Exception& e);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`1 : object {
    private T1 m_Item1;
    public T1 Item1 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
public abstract class System.Type : MemberInfo {
    private static Binder modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultBinder;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static object Missing;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    private static BindingFlags DefaultLookup;
    [__BlockReflectionAttribute]
public static string DefaultTypeNameWhenMissingMetadata;
    public MemberTypes MemberType { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public bool IsNested { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type ReflectedType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool HasElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public TypeAttributes Attributes { get; }
    public bool IsAbstract { get; }
    public bool IsImport { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsClass { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsAutoLayout { get; }
    public bool IsExplicitLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsAnsiClass { get; }
    public bool IsAutoClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsCOMObject { get; }
    public bool IsContextful { get; }
    public bool IsCollectible { get; }
    public bool IsEnum { get; }
    public bool IsMarshalByRef { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsSignatureType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public ConstructorInfo TypeInitializer { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Guid GUID { get; }
    public Type BaseType { get; }
    public static Binder DefaultBinder { get; }
    public bool IsSerializable { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsVisible { get; }
    public bool IsInterface { get; }
    public string InternalNameIfAvailable { get; }
    internal string NameOrDefault { get; }
    internal string FullNameOrDefault { get; }
    private static Type();
    public virtual MemberTypes get_MemberType();
    public Type GetType();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Module get_Module();
    public bool get_IsNested();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_ReflectedType();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool get_IsTypeDefinition();
    public bool get_IsArray();
    protected abstract virtual bool IsArrayImpl();
    public bool get_IsByRef();
    protected abstract virtual bool IsByRefImpl();
    public bool get_IsPointer();
    protected abstract virtual bool IsPointerImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public virtual bool get_IsByRefLike();
    public bool get_HasElementType();
    protected abstract virtual bool HasElementTypeImpl();
    public abstract virtual Type GetElementType();
    public virtual int GetArrayRank();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type[] GetGenericArguments();
    public virtual int get_GenericParameterPosition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Type[] GetGenericParameterConstraints();
    public TypeAttributes get_Attributes();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public bool get_IsAbstract();
    public bool get_IsImport();
    public bool get_IsSealed();
    public bool get_IsSpecialName();
    public bool get_IsClass();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPublic();
    public bool get_IsAutoLayout();
    public bool get_IsExplicitLayout();
    public bool get_IsLayoutSequential();
    public bool get_IsAnsiClass();
    public bool get_IsAutoClass();
    public bool get_IsUnicodeClass();
    public bool get_IsCOMObject();
    protected abstract virtual bool IsCOMObjectImpl();
    public bool get_IsContextful();
    protected virtual bool IsContextfulImpl();
    [__BlockReflectionAttribute]
public virtual bool get_IsCollectible();
    public virtual bool get_IsEnum();
    public bool get_IsMarshalByRef();
    protected virtual bool IsMarshalByRefImpl();
    public bool get_IsPrimitive();
    protected abstract virtual bool IsPrimitiveImpl();
    public bool get_IsValueType();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSignatureType();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public ConstructorInfo get_TypeInitializer();
    public ConstructorInfo GetConstructor(Type[] types);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name, Type returnType);
    public PropertyInfo GetProperty(string name, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    public static Type[] GetTypeArray(Object[] args);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    public static Type GetTypeFromCLSID(Guid clsid);
    public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server);
    public static Type GetTypeFromProgID(string progID);
    public static Type GetTypeFromProgID(string progID, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server);
    public abstract virtual Type get_BaseType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsEquivalentTo(Type other);
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    [__BlockReflectionAttribute]
public static Type MakeGenericSignatureType(Type genericTypeDefinition, Type[] typeArguments);
    public static Type MakeGenericMethodParameter(int position);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool Equals(Type o);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public static Binder get_DefaultBinder();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    private Array GetEnumRawConstantValues();
    private void GetEnumData(String[]& enumNames, Array& enumValues);
    private static int BinarySearch(Array array, object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSerializable();
    public virtual bool get_ContainsGenericParameters();
    internal Type GetRootElementType();
    public bool get_IsVisible();
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual bool IsSubclassOf(Type c);
    public virtual bool IsAssignableFrom(Type c);
    internal bool ImplementInterface(Type ifaceType);
    private static bool FilterAttributeImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameImpl(MemberInfo m, object filterCriteria, StringComparison comparison);
    public bool get_IsInterface();
    [IntrinsicAttribute]
public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    [IntrinsicAttribute]
public static Type GetType(string typeName);
    [IntrinsicAttribute]
public static Type GetType(string typeName, bool throwOnError);
    [IntrinsicAttribute]
public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    [IntrinsicAttribute]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    [IntrinsicAttribute]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    [IntrinsicAttribute]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    [IntrinsicAttribute]
public static bool op_Equality(Type left, Type right);
    [IntrinsicAttribute]
public static bool op_Inequality(Type left, Type right);
    [__BlockReflectionAttribute]
public bool IsRuntimeImplemented();
    [__BlockReflectionAttribute]
public string get_InternalNameIfAvailable();
    [__BlockReflectionAttribute]
public virtual string InternalGetNameIfAvailable(Type& rootCauseForFailure);
    internal string get_NameOrDefault();
    internal string get_FullNameOrDefault();
    [__BlockReflectionAttribute]
public string FormatTypeName();
    private static Exception GetCLSIDFromProgID(string progID, Guid& clsid);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[IsByRefLikeAttribute]
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    private ByReference`1<byte> _value;
    private RuntimeTypeHandle _typeHandle;
    public bool IsNull { get; }
    internal Byte& Value { get; }
    private TypedReference(object target, int offset, RuntimeTypeHandle typeHandle);
    public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    internal static RuntimeTypeHandle RawTargetTypeToken(TypedReference value);
    public static object ToObject(TypedReference value);
    public static void SetTypedReference(TypedReference target, object value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [__BlockReflectionAttribute]
public bool get_IsNull();
    internal Byte& get_Value();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeInitializationException : SystemException {
    private string _typeName;
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(string message);
    internal TypeInitializationException(string fullTypeName, string message, Exception innerException);
    internal TypeInitializationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeLoadException : SystemException {
    private string _typeName;
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    internal TypeLoadException(string message, string typeName);
    public virtual string get_Message();
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.TypeUnificationKey : ValueType {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public TypeUnificationKey(Type type);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeUnificationKey other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt16 : ValueType {
    private ushort m_value;
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt32 : ValueType {
    private UInt32 m_value;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt64 : ValueType {
    private ulong m_value;
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UIntPtr : ValueType {
    private Void* _value;
    [IntrinsicAttribute]
public static UIntPtr Zero;
    public static int Size { get; }
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UIntPtr(UInt32 value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UIntPtr(ulong value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UIntPtr(Void* value);
    private UIntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
    public virtual int GetHashCode();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public UInt32 ToUInt32();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public ulong ToUInt64();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Explicit(UInt32 value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Explicit(ulong value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Explicit(Void* value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static ulong op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static UIntPtr Add(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int get_Size();
    [IntrinsicAttribute]
[NonVersionableAttribute]
[DependencyReductionRootAttribute]
public Void* ToPointer();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
public class System.UnhandledExceptionEventArgs : EventArgs {
    private object _exception;
    private bool _isTerminating;
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.UnitySerializationHolder : object {
    internal static int NullUnity;
    private int _unityType;
    private string _data;
    public UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType);
    [__BlockReflectionAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [__BlockReflectionAttribute]
public sealed virtual object GetRealObject(StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`1 : ValueType {
    public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`1(T1 item1);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.ValueType : object {
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Version : object {
    private int _Major;
    private int _Minor;
    private int _Build;
    private int _Revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    private int DefaultFormatFieldCount { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    public Version(string version);
    private Version(Version version);
    public sealed virtual object Clone();
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int fieldCount);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private int get_DefaultFormatFieldCount();
    private StringBuilder ToCachedStringBuilder(int fieldCount);
    public static Version Parse(string input);
    public static Version Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Version& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    private static Version ParseVersion(ReadOnlySpan`1<char> input, bool throwOnFailure);
    private static bool TryParseComponent(ReadOnlySpan`1<char> component, string componentName, bool throwOnFailure, Int32& parsedComponent);
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
}
public class System.Void : ValueType {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference : object {
    internal IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) m_handle;
    internal bool m_IsLongReference;
    public bool IsAlive { get; }
    public bool TrackResurrection { get; }
    public object Target { get; public set; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual bool get_TrackResurrection();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    private object TryGetComTarget();
    private void TrySetComTarget(object target);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual override void Finalize();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference`1 : object {
    internal IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) m_handle;
    private bool m_trackResurrection;
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    internal WeakReference`1(SerializationInfo info, StreamingContext context);
    public bool TryGetTarget(T& target);
    public void SetTarget(T target);
    private T GetTarget();
    private object TryGetComTarget();
    private void TrySetComTarget(object target);
    [__BlockReflectionAttribute]
protected virtual override void Finalize();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
