internal static class FxResources.Microsoft.CSharp.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.ArgumentObject : ValueType {
    internal object Value;
    internal CSharpArgumentInfo Info;
    internal Type Type;
    public ArgumentObject(object value, CSharpArgumentInfo info, Type type);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.CSharp.RuntimeBinder.Binder : object {
    public static CallSiteBinder BinaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder Convert(CSharpBinderFlags flags, Type type, Type context);
    public static CallSiteBinder GetIndex(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder GetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder Invoke(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder InvokeMember(CSharpBinderFlags flags, string name, IEnumerable`1<Type> typeArguments, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder InvokeConstructor(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder IsEvent(CSharpBinderFlags flags, string name, Type context);
    public static CallSiteBinder SetIndex(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder SetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder UnaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.BinderHelper : object {
    private static MethodInfo s_DoubleIsNaN;
    private static MethodInfo s_SingleIsNaN;
    internal static DynamicMetaObject Bind(ICSharpBinder action, RuntimeBinder binder, DynamicMetaObject[] args, IEnumerable`1<CSharpArgumentInfo> arginfos, DynamicMetaObject onBindingError);
    public static void ValidateBindArgument(DynamicMetaObject argument, string paramName);
    public static void ValidateBindArgument(DynamicMetaObject[] arguments, string paramName);
    private static bool IsTypeOfStaticCall(int parameterIndex, ICSharpInvokeOrInvokeMemberBinder callPayload);
    private static bool IsComObject(object obj);
    private static bool IsTransparentProxy(object obj);
    private static bool IsDynamicallyTypedRuntimeProxy(DynamicMetaObject argument, CSharpArgumentInfo info);
    private static BindingRestrictions DeduceArgumentRestriction(int parameterIndex, ICSharpInvokeOrInvokeMemberBinder callPayload, DynamicMetaObject argument, CSharpArgumentInfo info);
    private static Expression ConvertResult(Expression binding, ICSharpBinder action);
    private static Type GetTypeForErrorMetaObject(ICSharpBinder action, DynamicMetaObject[] args);
    private static bool IsIncrementOrDecrementActionOnLocal(ICSharpBinder action);
    internal static T[] Cons(T sourceHead, T[] sourceTail);
    internal static T[] Cons(T sourceHead, T[] sourceMiddle, T sourceLast);
    internal static T[] ToArray(IEnumerable`1<T> source);
    internal static CallInfo CreateCallInfo(IEnumerable`1& argInfos, int discard);
    [ExtensionAttribute]
internal static string GetCLROperatorName(ExpressionType p);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo : object {
    internal static CSharpArgumentInfo None;
    [CompilerGeneratedAttribute]
private CSharpArgumentInfoFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private CSharpArgumentInfoFlags Flags { get; }
    internal string Name { get; }
    internal bool UseCompileTimeType { get; }
    internal bool LiteralConstant { get; }
    internal bool NamedArgument { get; }
    internal bool IsByRefOrOut { get; }
    internal bool IsOut { get; }
    internal bool IsStaticType { get; }
    private CSharpArgumentInfo(CSharpArgumentInfoFlags flags, string name);
    private static CSharpArgumentInfo();
    [CompilerGeneratedAttribute]
private CSharpArgumentInfoFlags get_Flags();
    [CompilerGeneratedAttribute]
internal string get_Name();
    public static CSharpArgumentInfo Create(CSharpArgumentInfoFlags flags, string name);
    internal bool get_UseCompileTimeType();
    internal bool get_LiteralConstant();
    internal bool get_NamedArgument();
    internal bool get_IsByRefOrOut();
    internal bool get_IsOut();
    internal bool get_IsStaticType();
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
public enum Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags : Enum {
    public int value__;
    public static CSharpArgumentInfoFlags None;
    public static CSharpArgumentInfoFlags UseCompileTimeType;
    public static CSharpArgumentInfoFlags Constant;
    public static CSharpArgumentInfoFlags NamedArgument;
    public static CSharpArgumentInfoFlags IsRef;
    public static CSharpArgumentInfoFlags IsOut;
    public static CSharpArgumentInfoFlags IsStaticType;
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpBinaryOperationBinder : BinaryOperationBinder {
    private CSharpBinaryOperationFlags _binopFlags;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    [ExcludeFromCodeCoverageAttribute]
public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    internal bool IsLogicalOperation { get; }
    public CSharpBinaryOperationBinder(ExpressionType operation, bool isChecked, CSharpBinaryOperationFlags binaryOperationFlags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    internal bool get_IsLogicalOperation();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.CSharpBinaryOperationFlags : Enum {
    public int value__;
    public static CSharpBinaryOperationFlags None;
    public static CSharpBinaryOperationFlags MemberAccess;
    public static CSharpBinaryOperationFlags LogicalOperation;
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
public enum Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags : Enum {
    public int value__;
    public static CSharpBinderFlags None;
    public static CSharpBinderFlags CheckedContext;
    public static CSharpBinderFlags InvokeSimpleName;
    public static CSharpBinderFlags InvokeSpecialName;
    public static CSharpBinderFlags BinaryOperationLogical;
    public static CSharpBinderFlags ConvertExplicit;
    public static CSharpBinderFlags ConvertArrayIndex;
    public static CSharpBinderFlags ResultIndexed;
    public static CSharpBinderFlags ValueFromCompoundAssignment;
    public static CSharpBinderFlags ResultDiscarded;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.CSharpCallFlags : Enum {
    public int value__;
    public static CSharpCallFlags None;
    public static CSharpCallFlags SimpleNameCall;
    public static CSharpCallFlags EventHookup;
    public static CSharpCallFlags ResultDiscarded;
}
internal enum Microsoft.CSharp.RuntimeBinder.CSharpConversionKind : Enum {
    public int value__;
    public static CSharpConversionKind ImplicitConversion;
    public static CSharpConversionKind ExplicitConversion;
    public static CSharpConversionKind ArrayCreationConversion;
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder : ConvertBinder {
    [CompilerGeneratedAttribute]
private CSharpConversionKind <ConversionKind>k__BackingField;
    private RuntimeBinder _binder;
    [ExcludeFromCodeCoverageAttribute]
public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private CSharpConversionKind ConversionKind { get; }
    public CSharpConvertBinder(Type type, CSharpConversionKind conversionKind, bool isChecked, Type callingContext);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    [CompilerGeneratedAttribute]
private CSharpConversionKind get_ConversionKind();
    public virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpGetIndexBinder : GetIndexBinder {
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public CSharpGetIndexBinder(Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpGetMemberBinder : GetMemberBinder {
    private CSharpArgumentInfo[] _argumentInfo;
    [CompilerGeneratedAttribute]
private bool <ResultIndexed>k__BackingField;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool System.Dynamic.IInvokeOnGetBinder.InvokeOnGet { get; }
    private bool ResultIndexed { get; }
    public CSharpGetMemberBinder(string name, bool resultIndexed, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private sealed virtual override bool System.Dynamic.IInvokeOnGetBinder.get_InvokeOnGet();
    [CompilerGeneratedAttribute]
private bool get_ResultIndexed();
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeBinder : InvokeBinder {
    private CSharpCallFlags _flags;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.StaticCall { get; }
    private string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.Name { get; }
    private Type[] Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.TypeArguments { get; }
    private CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.Flags { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    public CSharpInvokeBinder(CSharpCallFlags flags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_StaticCall();
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
    private sealed virtual override Type[] Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_TypeArguments();
    private sealed virtual override CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_Flags();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeConstructorBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private CSharpCallFlags <Flags>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public CSharpCallFlags Flags { get; }
    public bool StaticCall { get; }
    public Type[] TypeArguments { get; }
    public string Name { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    public CSharpInvokeConstructorBinder(CSharpCallFlags flags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpCallFlags get_Flags();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public sealed virtual bool get_StaticCall();
    public sealed virtual Type[] get_TypeArguments();
    public sealed virtual string get_Name();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeMemberBinder : InvokeMemberBinder {
    [CompilerGeneratedAttribute]
private CSharpCallFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CallingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <TypeArguments>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.StaticCall { get; }
    public CSharpCallFlags Flags { get; }
    public Type CallingContext { get; }
    public Type[] TypeArguments { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    public CSharpInvokeMemberBinder(CSharpCallFlags flags, string name, Type callingContext, IEnumerable`1<Type> typeArguments, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_StaticCall();
    [CompilerGeneratedAttribute]
public sealed virtual CSharpCallFlags get_Flags();
    [CompilerGeneratedAttribute]
public Type get_CallingContext();
    [CompilerGeneratedAttribute]
public sealed virtual Type[] get_TypeArguments();
    public sealed virtual CSharpArgumentInfo GetArgumentInfo(int index);
    public CSharpArgumentInfo[] ArgumentInfoArray();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpIsEventBinder : DynamicMetaObjectBinder {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    public CSharpIsEventBinder(string name, Type callingContext);
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public virtual Type get_ReturnType();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpSetIndexBinder : SetIndexBinder {
    [CompilerGeneratedAttribute]
private bool <IsCompoundAssignment>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    internal bool IsCompoundAssignment { get; }
    public CSharpSetIndexBinder(bool isCompoundAssignment, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    [CompilerGeneratedAttribute]
internal bool get_IsCompoundAssignment();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpSetMemberBinder : SetMemberBinder {
    [CompilerGeneratedAttribute]
private bool <IsCompoundAssignment>k__BackingField;
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    internal bool IsCompoundAssignment { get; }
    public CSharpSetMemberBinder(string name, bool isCompoundAssignment, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    [CompilerGeneratedAttribute]
internal bool get_IsCompoundAssignment();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpUnaryOperationBinder : UnaryOperationBinder {
    private CSharpArgumentInfo[] _argumentInfo;
    private RuntimeBinder _binder;
    [ExcludeFromCodeCoverageAttribute]
public string Name { get; }
    public BindingFlag BindingFlags { get; }
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public CSharpUnaryOperationBinder(ExpressionType operation, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual string get_Name();
    public sealed virtual BindingFlag get_BindingFlags();
    public sealed virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public sealed virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public sealed virtual bool get_IsBinderThatCanHaveRefReceiver();
    private sealed virtual override CSharpArgumentInfo Microsoft.CSharp.RuntimeBinder.ICSharpBinder.GetArgumentInfo(int index);
    public virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal static class Microsoft.CSharp.RuntimeBinder.Error : object {
    internal static Exception InternalCompilerError();
    internal static Exception BindPropertyFailedMethodGroup(object p0);
    internal static Exception BindPropertyFailedEvent(object p0);
    internal static Exception BindInvokeFailedNonDelegate();
    internal static Exception BindStaticRequiresType(string paramName);
    internal static Exception NullReferenceOnMemberException();
    internal static Exception BindCallToConditionalMethod(object p0);
    internal static Exception BindToVoidMethodButExpectResult();
    internal static Exception ArgumentNull(string paramName);
    internal static Exception DynamicArgumentNeedsValue(string paramName);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArg : object {
    public ErrArgKind eak;
    public ErrArgFlags eaf;
    internal int n;
    internal SYMKIND sk;
    internal Name name;
    internal Symbol sym;
    internal string psz;
    internal CType pType;
    internal MethPropWithInstMemo mpwiMemo;
    internal SymWithTypeMemo swtMemo;
    public ErrArg(int n);
    public ErrArg(Name name);
    public ErrArg(string psz);
    public ErrArg(CType pType);
    public ErrArg(CType pType, ErrArgFlags eaf);
    public ErrArg(Symbol pSym);
    private ErrArg(Symbol pSym, ErrArgFlags eaf);
    public ErrArg(SymWithType swt);
    public ErrArg(MethPropWithInst mpwi);
    public static ErrArg op_Implicit(int n);
    public static ErrArg op_Implicit(CType type);
    public static ErrArg op_Implicit(string psz);
    public static ErrArg op_Implicit(Name name);
    public static ErrArg op_Implicit(Symbol pSym);
    public static ErrArg op_Implicit(SymWithType swt);
    public static ErrArg op_Implicit(MethPropWithInst mpwi);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrArgFlags : Enum {
    public int value__;
    public static ErrArgFlags None;
    public static ErrArgFlags NoStr;
    public static ErrArgFlags Unique;
    public static ErrArgFlags UseGetErrorInfo;
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrArgKind : Enum {
    public int value__;
    public static ErrArgKind Int;
    public static ErrArgKind SymKind;
    public static ErrArgKind Sym;
    public static ErrArgKind Type;
    public static ErrArgKind Name;
    public static ErrArgKind Str;
    public static ErrArgKind SymWithType;
    public static ErrArgKind MethWithInst;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgNoRef : ErrArg {
    public ErrArgNoRef(CType pType);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgRefOnly : ErrArg {
    public ErrArgRefOnly(Symbol sym);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgSymKind : ErrArg {
    public ErrArgSymKind(Symbol sym);
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrorCode : Enum {
    public int value__;
    public static ErrorCode ERR_BadBinaryOps;
    public static ErrorCode ERR_BadIndexLHS;
    public static ErrorCode ERR_BadIndexCount;
    public static ErrorCode ERR_BadUnaryOp;
    public static ErrorCode ERR_NoImplicitConv;
    public static ErrorCode ERR_NoExplicitConv;
    public static ErrorCode ERR_ConstOutOfRange;
    public static ErrorCode ERR_AmbigBinaryOps;
    public static ErrorCode ERR_AmbigUnaryOp;
    public static ErrorCode ERR_ValueCantBeNull;
    public static ErrorCode ERR_NoSuchMember;
    public static ErrorCode ERR_ObjectRequired;
    public static ErrorCode ERR_AmbigCall;
    public static ErrorCode ERR_BadAccess;
    public static ErrorCode ERR_AssgLvalueExpected;
    public static ErrorCode ERR_NoConstructors;
    public static ErrorCode ERR_PropertyLacksGet;
    public static ErrorCode ERR_ObjectProhibited;
    public static ErrorCode ERR_AssgReadonly;
    public static ErrorCode ERR_AssgReadonlyStatic;
    public static ErrorCode ERR_AssgReadonlyProp;
    public static ErrorCode ERR_UnsafeNeeded;
    public static ErrorCode ERR_BadBoolOp;
    public static ErrorCode ERR_MustHaveOpTF;
    public static ErrorCode ERR_ConstOutOfRangeChecked;
    public static ErrorCode ERR_AmbigMember;
    public static ErrorCode ERR_NoImplicitConvCast;
    public static ErrorCode ERR_InaccessibleGetter;
    public static ErrorCode ERR_InaccessibleSetter;
    public static ErrorCode ERR_BadArity;
    public static ErrorCode ERR_TypeArgsNotAllowed;
    public static ErrorCode ERR_HasNoTypeVars;
    public static ErrorCode ERR_NewConstraintNotSatisfied;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedRefType;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableEnum;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableInterface;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedValType;
    public static ErrorCode ERR_CantInferMethTypeArgs;
    public static ErrorCode ERR_RefConstraintNotSatisfied;
    public static ErrorCode ERR_ValConstraintNotSatisfied;
    public static ErrorCode ERR_AmbigUDConv;
    public static ErrorCode ERR_BindToBogus;
    public static ErrorCode ERR_CantCallSpecialMethod;
    public static ErrorCode ERR_ConvertToStaticClass;
    public static ErrorCode ERR_IncrementLvalueExpected;
    public static ErrorCode ERR_BadArgCount;
    public static ErrorCode ERR_BadArgTypes;
    public static ErrorCode ERR_BadProtectedAccess;
    public static ErrorCode ERR_BindToBogusProp2;
    public static ErrorCode ERR_BindToBogusProp1;
    public static ErrorCode ERR_BadDelArgCount;
    public static ErrorCode ERR_BadDelArgTypes;
    public static ErrorCode ERR_BadCtorArgCount;
    public static ErrorCode ERR_BadNamedArgument;
    public static ErrorCode ERR_DuplicateNamedArgument;
    public static ErrorCode ERR_NamedArgumentUsedInPositional;
    public static ErrorCode ERR_BadNamedArgumentForDelegateInvoke;
    public static ErrorCode ERR_NonInvocableMemberCalled;
    public static ErrorCode ERR_BadNonTrailingNamedArgument;
}
internal static class Microsoft.CSharp.RuntimeBinder.Errors.ErrorFacts : object {
    public static string GetMessage(ErrorCode code);
    public static string GetMessage(MessageID id);
}
internal static class Microsoft.CSharp.RuntimeBinder.Errors.ErrorHandling : object {
    public static RuntimeBinderException Error(ErrorCode id, ErrArg[] args);
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.MessageID : Enum {
    public int value__;
    public static MessageID SK_METHOD;
    public static MessageID SK_CLASS;
    public static MessageID SK_NAMESPACE;
    public static MessageID SK_FIELD;
    public static MessageID SK_PROPERTY;
    public static MessageID SK_UNKNOWN;
    public static MessageID SK_VARIABLE;
    public static MessageID SK_EVENT;
    public static MessageID SK_TYVAR;
    public static MessageID SK_ALIAS;
    public static MessageID ERRORSYM;
    public static MessageID NULL;
    public static MessageID GlobalNamespace;
    public static MessageID MethodGroup;
    public static MessageID AnonMethod;
    public static MessageID Lambda;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.MethPropWithInstMemo : object {
    public Symbol sym;
    public AggregateType ats;
    public TypeArray typeArgs;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.SymWithTypeMemo : object {
    public Symbol sym;
    public AggregateType ats;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.UserStringBuilder : ValueType {
    private StringBuilder _strBuilder;
    private void BeginString();
    private string EndString();
    private static string ErrSK(SYMKIND sk);
    private void ErrAppendParamList(TypeArray params, bool isParamArray);
    private void ErrAppendString(string str);
    private void ErrAppendChar(char ch);
    private void ErrAppendPrintf(string format, Object[] args);
    private void ErrAppendName(Name name);
    private void ErrAppendParentSym(Symbol sym, SubstContext pctx);
    private void ErrAppendParentCore(Symbol parent, SubstContext pctx);
    private void ErrAppendTypeParameters(TypeArray params, SubstContext pctx);
    private void ErrAppendMethod(MethodSymbol meth, SubstContext pctx, bool fArgs);
    private void ErrAppendIndexer(IndexerSymbol indexer, SubstContext pctx);
    private void ErrAppendProperty(PropertySymbol prop, SubstContext pctx);
    private void ErrAppendId(MessageID id);
    private void ErrAppendSym(Symbol sym, SubstContext pctx);
    private void ErrAppendSym(Symbol sym, SubstContext pctx, bool fArgs);
    private void ErrAppendType(CType pType, SubstContext pctx);
    public bool ErrArgToString(String& psz, ErrArg parg, Boolean& fUserStrings);
    private static string ErrId(MessageID id);
}
internal class Microsoft.CSharp.RuntimeBinder.ExpressionTreeCallRewriter : ExprVisitorBase {
    private Dictionary`2<ExprCall, Expression> _DictionaryOfParameters;
    private Expression[] _ListOfParameters;
    private int _currentParameterIndex;
    private ExpressionTreeCallRewriter(Expression[] listOfParameters);
    public static Expression Rewrite(ExprBinOp binOp, Expression[] listOfParameters);
    protected virtual Expr VisitSAVE(ExprBinOp pExpr);
    protected virtual Expr VisitCALL(ExprCall pExpr);
    protected virtual Expr VisitWRAP(ExprWrap pExpr);
    private Expr GenerateLambda(ExprCall pExpr);
    private Expression GenerateCall(ExprCall pExpr);
    private Expression GenerateArrayIndex(ExprCall pExpr);
    private Expression GenerateConvert(ExprCall pExpr);
    private Expression GenerateProperty(ExprCall pExpr);
    private Expression GenerateField(ExprCall pExpr);
    private Expression GenerateInvoke(ExprCall pExpr);
    private Expression GenerateNew(ExprCall pExpr);
    private static Expression GenerateConstantType(ExprCall pExpr);
    private Expression GenerateAssignment(ExprCall pExpr);
    private Expression GenerateBinaryOperator(ExprCall pExpr);
    private Expression GenerateUserDefinedBinaryOperator(ExprCall pExpr);
    private Expression GenerateUnaryOperator(ExprCall pExpr);
    private Expression GenerateUserDefinedUnaryOperator(ExprCall pExpr);
    private Expression GetExpression(Expr pExpr);
    private Expression[] GetArgumentsFromArrayInit(ExprArrayInit arrinit);
}
internal interface Microsoft.CSharp.RuntimeBinder.ICSharpBinder {
    public bool IsBinderThatCanHaveRefReceiver { get; }
    public BindingFlag BindingFlags { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    public abstract virtual CSharpArgumentInfo GetArgumentInfo(int index);
    public abstract virtual bool get_IsBinderThatCanHaveRefReceiver();
    public abstract virtual void PopulateSymbolTableWithName(Type callingType, ArgumentObject[] arguments);
    public abstract virtual Expr DispatchPayload(RuntimeBinder runtimeBinder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    public abstract virtual BindingFlag get_BindingFlags();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ReturnType();
}
internal interface Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder {
    public bool StaticCall { get; }
    public bool ResultDiscarded { get; }
    public CSharpCallFlags Flags { get; }
    public Type[] TypeArguments { get; }
    public abstract virtual bool get_StaticCall();
    public abstract virtual bool get_ResultDiscarded();
    public abstract virtual CSharpCallFlags get_Flags();
    public abstract virtual Type[] get_TypeArguments();
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.RuntimeBinder : ValueType {
    private static object s_bindLock;
    private ExpressionBinder _binder;
    public RuntimeBinder(Type contextType, bool isChecked);
    private static RuntimeBinder();
    public Expression Bind(ICSharpBinder payload, Expression[] parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding);
    private Expression BindCore(ICSharpBinder payload, Expression[] parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding);
    [ConditionalAttribute("DEBUG")]
internal static void EnsureLockIsTaken();
    private bool DeferBinding(ICSharpBinder payload, ArgumentObject[] arguments, DynamicMetaObject[] args, LocalVariableSymbol[] locals, DynamicMetaObject& deferredBinding);
    private static Expression CreateExpressionTreeFromResult(Expression[] parameters, Scope pScope, Expr pResult);
    private Type GetArgumentType(ICSharpBinder p, CSharpArgumentInfo argInfo, Expression param, DynamicMetaObject arg, int index);
    private ArgumentObject[] CreateArgumentArray(ICSharpBinder payload, Expression[] parameters, DynamicMetaObject[] args);
    internal static void PopulateSymbolTableWithPayloadInformation(ICSharpInvokeOrInvokeMemberBinder callOrInvoke, Type callingType, ArgumentObject[] arguments);
    private static void AddConversionsForArguments(ArgumentObject[] arguments);
    internal ExprWithArgs DispatchPayload(ICSharpInvokeOrInvokeMemberBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    private static LocalVariableSymbol[] PopulateLocalScope(ICSharpBinder payload, Scope pScope, ArgumentObject[] arguments, Expression[] parameterExpressions);
    private static ExprBoundLambda GenerateBoundLambda(Scope pScope, Expr call);
    private Expr CreateLocal(Type type, bool isOut, LocalVariableSymbol local);
    internal Expr CreateArgumentListEXPR(ArgumentObject[] arguments, LocalVariableSymbol[] locals, int startIndex, int endIndex);
    private Expr CreateArgumentEXPR(ArgumentObject argument, LocalVariableSymbol local);
    private static ExprMemberGroup CreateMemberGroupExpr(string Name, Type[] typeArguments, Expr callingObject, SYMKIND kind);
    private Expr CreateProperty(SymWithType swt, Expr callingObject, BindingFlag flags);
    private ExprWithArgs CreateIndexer(SymWithType swt, Expr callingObject, Expr arguments, BindingFlag bindFlags);
    private Expr CreateArray(Expr callingObject, Expr optionalIndexerArguments);
    private Expr CreateField(SymWithType swt, Expr callingObject);
    private Expr CreateCallingObjectForCall(ICSharpInvokeOrInvokeMemberBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    private ExprWithArgs BindCall(ICSharpInvokeOrInvokeMemberBinder payload, Expr callingObject, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    private ExprWithArgs BindWinRTEventAccessor(EventWithType ewt, Expr callingObject, ArgumentObject[] arguments, LocalVariableSymbol[] locals, bool isAddAccessor);
    private static void CheckForConditionalMethodError(ExprCall call);
    private void ReorderArgumentsForNamedAndOptional(Expr callingObject, ExprWithArgs result);
    private Expr StripNamedArgument(Expr pArg);
    private Expr StripNamedArguments(Expr pArg);
    internal Expr BindUnaryOperation(CSharpUnaryOperationBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    internal Expr BindBinaryOperation(CSharpBinaryOperationBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    private static OperatorKind GetOperatorKind(ExpressionType p);
    private static OperatorKind GetOperatorKind(ExpressionType p, bool bIsLogical);
    internal Expr BindProperty(ICSharpBinder payload, ArgumentObject argument, LocalVariableSymbol local, Expr optionalIndexerArguments);
    internal Expr BindImplicitConversion(ArgumentObject[] arguments, Type returnType, LocalVariableSymbol[] locals, bool bIsArrayCreationConversion);
    internal Expr BindExplicitConversion(ArgumentObject[] arguments, Type returnType, LocalVariableSymbol[] locals);
    internal Expr BindAssignment(ICSharpBinder payload, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
    internal Expr BindIsEvent(CSharpIsEventBinder binder, ArgumentObject[] arguments, LocalVariableSymbol[] locals);
}
public class Microsoft.CSharp.RuntimeBinder.RuntimeBinderException : Exception {
    public RuntimeBinderException(string message);
    public RuntimeBinderException(string message, Exception innerException);
    protected RuntimeBinderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.RuntimeBinderExtensions : object {
    private static Func`3<MemberInfo, MemberInfo, bool> s_MemberEquivalence;
    private static RuntimeBinderExtensions();
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static bool IsEquivalentTo(MemberInfo mi1, MemberInfo mi2);
    [ExtensionAttribute]
private static bool AreParametersEquivalent(MethodBase method1, MethodBase method2);
    [ExtensionAttribute]
private static bool IsEquivalentTo(ParameterInfo pi1, ParameterInfo pi2, MethodBase method1, MethodBase method2);
    [ExtensionAttribute]
private static bool IsGenericallyEqual(Type t1, Type t2);
    [ExtensionAttribute]
private static bool IsGenericallyEquivalentTo(Type t1, Type t2, MemberInfo member1, MemberInfo member2);
    [ExtensionAttribute]
private static bool IsTypeParameterEquivalentToTypeInst(Type typeParam, Type typeInst, MemberInfo member);
    [ExtensionAttribute]
public static bool HasSameMetadataDefinitionAs(MemberInfo mi1, MemberInfo mi2);
    [ExtensionAttribute]
public static string GetIndexerName(Type type);
    private static string GetTypeIndexerName(Type type);
}
public class Microsoft.CSharp.RuntimeBinder.RuntimeBinderInternalCompilerException : Exception {
    public RuntimeBinderInternalCompilerException(string message);
    public RuntimeBinderInternalCompilerException(string message, Exception innerException);
    protected RuntimeBinderInternalCompilerException(SerializationInfo info, StreamingContext context);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ACCESS : Enum {
    public int value__;
    public static ACCESS ACC_UNKNOWN;
    public static ACCESS ACC_PRIVATE;
    public static ACCESS ACC_INTERNAL_AND_PROTECTED;
    public static ACCESS ACC_INTERNAL;
    public static ACCESS ACC_PROTECTED;
    public static ACCESS ACC_INTERNALPROTECTED;
    public static ACCESS ACC_PUBLIC;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ACCESSERROR : Enum {
    public int value__;
    public static ACCESSERROR ACCESSERROR_NOACCESS;
    public static ACCESSERROR ACCESSERROR_NOACCESSTHRU;
    public static ACCESSERROR ACCESSERROR_NOERROR;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.AggCastResult : Enum {
    public int value__;
    public static AggCastResult Success;
    public static AggCastResult Failure;
    public static AggCastResult Abort;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.AggKindEnum : Enum {
    public int value__;
    public static AggKindEnum Unknown;
    public static AggKindEnum Class;
    public static AggKindEnum Delegate;
    public static AggKindEnum Interface;
    public static AggKindEnum Struct;
    public static AggKindEnum Enum;
    public static AggKindEnum Lim;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateSymbol : NamespaceOrAggregateSymbol {
    public Type AssociatedSystemType;
    public Assembly AssociatedAssembly;
    private AggregateType _atsInst;
    private AggregateType _pBaseClass;
    private AggregateType _pUnderlyingType;
    private TypeArray _ifaces;
    private TypeArray _ifacesAll;
    private TypeArray _typeVarsThis;
    private TypeArray _typeVarsAll;
    private MethodSymbol _pConvFirst;
    private AggKindEnum _aggKind;
    private bool _isPredefined;
    private PredefinedType _iPredef;
    private bool _isAbstract;
    private bool _isSealed;
    private bool _hasPubNoArgCtor;
    private bool _isSkipUDOps;
    private Nullable`1<bool> _hasConversion;
    public NamespaceOrAggregateSymbol Parent { get; }
    public AggregateSymbol GetBaseAgg();
    public AggregateType getThisType();
    public bool FindBaseAgg(AggregateSymbol agg);
    public NamespaceOrAggregateSymbol get_Parent();
    public bool isNested();
    public AggregateSymbol GetOuterAgg();
    public bool isPredefAgg(PredefinedType pt);
    public AggKindEnum AggKind();
    public void SetAggKind(AggKindEnum aggKind);
    public bool IsClass();
    public bool IsDelegate();
    public bool IsInterface();
    public bool IsStruct();
    public bool IsEnum();
    public bool IsValueType();
    public bool IsRefType();
    public bool IsStatic();
    public bool IsAbstract();
    public void SetAbstract(bool abstract);
    public bool IsPredefined();
    public void SetPredefined(bool predefined);
    public PredefinedType GetPredefType();
    public void SetPredefType(PredefinedType predef);
    public bool IsSealed();
    public void SetSealed(bool sealed);
    public bool HasConversion();
    public void SetHasConversion();
    public bool HasPubNoArgCtor();
    public void SetHasPubNoArgCtor(bool hasPubNoArgCtor);
    public bool IsSkipUDOps();
    public void SetSkipUDOps(bool skipUDOps);
    public TypeArray GetTypeVars();
    public void SetTypeVars(TypeArray typeVars);
    public TypeArray GetTypeVarsAll();
    public AggregateType GetBaseClass();
    public void SetBaseClass(AggregateType baseClass);
    public AggregateType GetUnderlyingType();
    public void SetUnderlyingType(AggregateType underlyingType);
    public TypeArray GetIfaces();
    public void SetIfaces(TypeArray ifaces);
    public TypeArray GetIfacesAll();
    public void SetIfacesAll(TypeArray ifacesAll);
    public MethodSymbol GetFirstUDConversion();
    public void SetFirstUDConversion(MethodSymbol conv);
    public bool InternalsVisibleTo(Assembly assembly);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateType : CType {
    private AggregateType _baseType;
    private TypeArray _ifacesAll;
    private TypeArray _winrtifacesAll;
    private Type _associatedSystemType;
    public Nullable`1<bool> ConstraintError;
    public bool AllHidden;
    public bool DiffHidden;
    [CompilerGeneratedAttribute]
private AggregateType <OuterType>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateSymbol <OwningAggregate>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgsThis>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgsAll>k__BackingField;
    public AggregateType OuterType { get; }
    public AggregateSymbol OwningAggregate { get; }
    public AggregateType BaseClass { get; }
    public IEnumerable`1<AggregateType> TypeHierarchy { get; }
    public TypeArray TypeArgsThis { get; }
    public TypeArray TypeArgsAll { get; }
    public TypeArray IfacesAll { get; }
    private bool IsCollectionType { get; }
    public TypeArray WinRTCollectionIfacesAll { get; }
    public bool IsReferenceType { get; }
    public bool IsNonNullableValueType { get; }
    public bool IsValueType { get; }
    public bool IsStaticClass { get; }
    public bool IsPredefined { get; }
    public PredefinedType PredefinedType { get; }
    public bool IsDelegateType { get; }
    public bool IsSimpleType { get; }
    public bool IsSimpleOrEnum { get; }
    public bool IsSimpleOrEnumOrString { get; }
    public bool IsNumericType { get; }
    public bool IsStructOrEnum { get; }
    public bool IsStructType { get; }
    public bool IsEnumType { get; }
    public bool IsInterfaceType { get; }
    public bool IsClassType { get; }
    public AggregateType UnderlyingEnumType { get; }
    public Type AssociatedSystemType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    public AggregateType(AggregateSymbol parent, TypeArray typeArgsThis, AggregateType outerType);
    [CompilerGeneratedAttribute]
public AggregateType get_OuterType();
    [CompilerGeneratedAttribute]
public AggregateSymbol get_OwningAggregate();
    public AggregateType get_BaseClass();
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.AggregateType/<get_TypeHierarchy>d__17")]
public IEnumerable`1<AggregateType> get_TypeHierarchy();
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgsThis();
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgsAll();
    public TypeArray get_IfacesAll();
    private bool get_IsCollectionType();
    public TypeArray get_WinRTCollectionIfacesAll();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsNonNullableValueType();
    public virtual bool get_IsValueType();
    public virtual bool get_IsStaticClass();
    public virtual bool get_IsPredefined();
    public virtual PredefinedType get_PredefinedType();
    public virtual bool IsPredefType(PredefinedType pt);
    public virtual bool get_IsDelegateType();
    public virtual bool get_IsSimpleType();
    public virtual bool get_IsSimpleOrEnum();
    public virtual bool get_IsSimpleOrEnumOrString();
    public virtual bool get_IsNumericType();
    public virtual bool get_IsStructOrEnum();
    public virtual bool get_IsStructType();
    public virtual bool get_IsEnumType();
    public virtual bool get_IsInterfaceType();
    public virtual bool get_IsClassType();
    public virtual AggregateType get_UnderlyingEnumType();
    public virtual Type get_AssociatedSystemType();
    private Type CalculateAssociatedSystemType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
    public virtual AggregateType GetAts();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArgInfos : object {
    public int carg;
    public TypeArray types;
    public List`1<Expr> prgexpr;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArgumentListType : CType {
    public static ArgumentListType Instance;
    private static ArgumentListType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArrayType : CType {
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSZArray>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <ElementType>k__BackingField;
    public int Rank { get; }
    public bool IsSZArray { get; }
    public CType ElementType { get; }
    public CType BaseElementType { get; }
    public bool IsReferenceType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    public ArrayType(CType elementType, int rank, bool isSZArray);
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
public bool get_IsSZArray();
    [CompilerGeneratedAttribute]
public CType get_ElementType();
    public CType get_BaseElementType();
    public virtual bool get_IsReferenceType();
    public virtual bool IsUnsafe();
    public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
    public virtual AggregateType GetAts();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BetterType : Enum {
    public int value__;
    public static BetterType Same;
    public static BetterType Left;
    public static BetterType Right;
    public static BetterType Neither;
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.BindingContext : ValueType {
    [CompilerGeneratedAttribute]
private AggregateSymbol <ContextForMemberLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Checked>k__BackingField;
    public AggregateSymbol ContextForMemberLookup { get; }
    public bool Checked { get; }
    public BindingContext(AggregateSymbol context, bool isChecked);
    public BindingContext(BindingContext parent);
    [CompilerGeneratedAttribute]
public AggregateSymbol get_ContextForMemberLookup();
    [CompilerGeneratedAttribute]
public bool get_Checked();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BindingFlag : Enum {
    public int value__;
    public static BindingFlag BIND_RVALUEREQUIRED;
    public static BindingFlag BIND_MEMBERSET;
    public static BindingFlag BIND_FIXEDVALUE;
    public static BindingFlag BIND_ARGUMENTS;
    public static BindingFlag BIND_BASECALL;
    public static BindingFlag BIND_USINGVALUE;
    public static BindingFlag BIND_STMTEXPRONLY;
    public static BindingFlag BIND_TYPEOK;
    public static BindingFlag BIND_MAYBECONFUSEDNEGATIVECAST;
    public static BindingFlag BIND_METHODNOTOK;
    public static BindingFlag BIND_DECLNOTOK;
    public static BindingFlag BIND_NOPARAMS;
    public static BindingFlag BIND_SPECULATIVELY;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpFuncKind : Enum {
    public int value__;
    public static BinOpFuncKind BoolBinOp;
    public static BinOpFuncKind BoolBitwiseOp;
    public static BinOpFuncKind DecBinOp;
    public static BinOpFuncKind DelBinOp;
    public static BinOpFuncKind EnumBinOp;
    public static BinOpFuncKind IntBinOp;
    public static BinOpFuncKind RealBinOp;
    public static BinOpFuncKind RefCmpOp;
    public static BinOpFuncKind ShiftOp;
    public static BinOpFuncKind StrBinOp;
    public static BinOpFuncKind StrCmpOp;
    public static BinOpFuncKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpKind : Enum {
    public int value__;
    public static BinOpKind Add;
    public static BinOpKind Sub;
    public static BinOpKind Mul;
    public static BinOpKind Shift;
    public static BinOpKind Equal;
    public static BinOpKind Compare;
    public static BinOpKind Bitwise;
    public static BinOpKind BitXor;
    public static BinOpKind Logical;
    public static BinOpKind Lim;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpMask : Enum {
    public int value__;
    public static BinOpMask None;
    public static BinOpMask Add;
    public static BinOpMask Sub;
    public static BinOpMask Mul;
    public static BinOpMask Shift;
    public static BinOpMask Equal;
    public static BinOpMask Compare;
    public static BinOpMask Bitwise;
    public static BinOpMask BitXor;
    public static BinOpMask Logical;
    public static BinOpMask Integer;
    public static BinOpMask Real;
    public static BinOpMask BoolNorm;
    public static BinOpMask Delegate;
    public static BinOpMask Enum;
    public static BinOpMask EnumUnder;
    public static BinOpMask UnderEnum;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CandidateFunctionMember : object {
    public MethPropWithInst mpwi;
    public TypeArray params;
    public byte ctypeLift;
    public bool fExpanded;
    public CandidateFunctionMember(MethPropWithInst mpwi, TypeArray params, byte ctypeLift, bool fExpanded);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.CConversions : object {
    public static bool FImpRefConv(CType typeSrc, CType typeDst);
    public static bool FExpRefConv(CType typeSrc, CType typeDst);
    public static bool HasGenericDelegateExplicitReferenceConversion(CType source, CType target);
    public static bool HasGenericDelegateExplicitReferenceConversion(CType pSource, AggregateType pTarget);
    public static bool FWrappingConv(CType typeSrc, CType typeDst);
    public static bool FUnwrappingConv(CType typeSrc, CType typeDst);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CheckConstraintsFlags : Enum {
    public int value__;
    public static CheckConstraintsFlags None;
    public static CheckConstraintsFlags Outer;
    public static CheckConstraintsFlags NoErrors;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CheckLvalueKind : Enum {
    public int value__;
    public static CheckLvalueKind Assignment;
    public static CheckLvalueKind Increment;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CMemberLookupResults : object {
    [CompilerGeneratedAttribute]
private TypeArray <ContainingTypes>k__BackingField;
    private Name _pName;
    private TypeArray ContainingTypes { get; }
    public CMemberLookupResults(TypeArray containingTypes, Name name);
    [CompilerGeneratedAttribute]
private TypeArray get_ContainingTypes();
    public CMethodIterator GetMethodIterator(CType qualifyingType, AggregateSymbol context, int arity, EXPRFLAG flags, symbmask_t mask, ArgInfos nonTrailingNamedArguments);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstCastResult : Enum {
    public int value__;
    public static ConstCastResult Success;
    public static ConstCastResult Failure;
    public static ConstCastResult CheckFailure;
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ConstVal : ValueType {
    private static object s_false;
    private static object s_true;
    private static object s_zeroInt32;
    [CompilerGeneratedAttribute]
private object <ObjectVal>k__BackingField;
    public object ObjectVal { get; }
    public bool BooleanVal { get; }
    public sbyte SByteVal { get; }
    public byte ByteVal { get; }
    public short Int16Val { get; }
    public ushort UInt16Val { get; }
    public int Int32Val { get; }
    public UInt32 UInt32Val { get; }
    public long Int64Val { get; }
    public ulong UInt64Val { get; }
    public float SingleVal { get; }
    public double DoubleVal { get; }
    public decimal DecimalVal { get; }
    public char CharVal { get; }
    public string StringVal { get; }
    public bool IsNullRef { get; }
    private ConstVal(object value);
    private static ConstVal();
    [CompilerGeneratedAttribute]
public object get_ObjectVal();
    public bool get_BooleanVal();
    public sbyte get_SByteVal();
    public byte get_ByteVal();
    public short get_Int16Val();
    public ushort get_UInt16Val();
    public int get_Int32Val();
    public UInt32 get_UInt32Val();
    public long get_Int64Val();
    public ulong get_UInt64Val();
    public float get_SingleVal();
    public double get_DoubleVal();
    public decimal get_DecimalVal();
    public char get_CharVal();
    public string get_StringVal();
    public bool get_IsNullRef();
    public bool IsZero(ConstValKind kind);
    private static T SpecialUnbox(object o);
    private static bool IsDefault(object o);
    public static ConstVal GetDefaultValue(ConstValKind kind);
    public static ConstVal Get(bool value);
    public static ConstVal Get(int value);
    public static ConstVal Get(UInt32 value);
    public static ConstVal Get(decimal value);
    public static ConstVal Get(string value);
    public static ConstVal Get(float value);
    public static ConstVal Get(double value);
    public static ConstVal Get(long value);
    public static ConstVal Get(ulong value);
    public static ConstVal Get(object p);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstValKind : Enum {
    public int value__;
    public static ConstValKind Int;
    public static ConstValKind Double;
    public static ConstValKind Long;
    public static ConstValKind String;
    public static ConstValKind Decimal;
    public static ConstValKind IntPtr;
    public static ConstValKind Float;
    public static ConstValKind Boolean;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CONVERTTYPE : Enum {
    public int value__;
    public static CONVERTTYPE NOUDC;
    public static CONVERTTYPE STANDARD;
    public static CONVERTTYPE ISEXPLICIT;
    public static CONVERTTYPE CHECKOVERFLOW;
    public static CONVERTTYPE FORCECAST;
    public static CONVERTTYPE STANDARDANDNOUDC;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConvKind : Enum {
    public int value__;
    public static ConvKind Identity;
    public static ConvKind Implicit;
    public static ConvKind Explicit;
    public static ConvKind Unknown;
    public static ConvKind None;
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.CSemanticChecker : object {
    public static void CheckForStaticClass(CType type);
    public static ACCESSERROR CheckAccess2(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
    public static bool CheckTypeAccess(CType type, Symbol symWhere);
    private static ACCESSERROR CheckAccessCore(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
    public static bool CheckBogus(Symbol sym);
    public static RuntimeBinderException ReportAccessError(SymWithType swtBad, Symbol symWhere, CType typeQual);
    public static bool CheckAccess(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.CType : object {
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    public bool IsWindowsRuntimeType { get; }
    [ExcludeFromCodeCoverageAttribute]
public Type AssociatedSystemType { get; }
    public TypeKind TypeKind { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    public bool IsDelegateType { get; }
    public bool IsSimpleType { get; }
    public bool IsSimpleOrEnum { get; }
    public bool IsSimpleOrEnumOrString { get; }
    public bool IsNumericType { get; }
    public bool IsStructOrEnum { get; }
    public bool IsStructType { get; }
    public bool IsEnumType { get; }
    public bool IsInterfaceType { get; }
    public bool IsClassType { get; }
    [ExcludeFromCodeCoverageAttribute]
public AggregateType UnderlyingEnumType { get; }
    public bool IsPredefined { get; }
    [ExcludeFromCodeCoverageAttribute]
public PredefinedType PredefinedType { get; }
    public bool IsStaticClass { get; }
    public bool IsValueType { get; }
    public bool IsNonNullableValueType { get; }
    public bool IsReferenceType { get; }
    private protected CType(TypeKind kind);
    public bool get_IsWindowsRuntimeType();
    public virtual Type get_AssociatedSystemType();
    [CompilerGeneratedAttribute]
public TypeKind get_TypeKind();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
    public CType GetNakedType(bool fStripNub);
    public virtual CType StripNubs();
    public virtual CType StripNubs(Boolean& wasNullable);
    public virtual bool get_IsDelegateType();
    public virtual bool get_IsSimpleType();
    public virtual bool get_IsSimpleOrEnum();
    public virtual bool get_IsSimpleOrEnumOrString();
    public virtual bool get_IsNumericType();
    public virtual bool get_IsStructOrEnum();
    public virtual bool get_IsStructType();
    public virtual bool get_IsEnumType();
    public virtual bool get_IsInterfaceType();
    public virtual bool get_IsClassType();
    public virtual AggregateType get_UnderlyingEnumType();
    public virtual bool IsUnsafe();
    public virtual bool IsPredefType(PredefinedType pt);
    public virtual bool get_IsPredefined();
    public virtual PredefinedType get_PredefinedType();
    public virtual bool get_IsStaticClass();
    public virtual bool get_IsValueType();
    public virtual bool get_IsNonNullableValueType();
    public virtual bool get_IsReferenceType();
    [ExcludeFromCodeCoverageAttribute]
public virtual AggregateType GetAts();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EventSymbol : Symbol {
    public EventInfo AssociatedEventInfo;
    public bool isStatic;
    public bool isOverride;
    public CType type;
    public MethodSymbol methAdd;
    public MethodSymbol methRemove;
    [CompilerGeneratedAttribute]
private bool <IsWindowsRuntimeEvent>k__BackingField;
    public bool IsWindowsRuntimeEvent { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsWindowsRuntimeEvent();
    [CompilerGeneratedAttribute]
public void set_IsWindowsRuntimeEvent(bool value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EventWithType : SymWithType {
    public EventWithType(EventSymbol event, AggregateType ats);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.Expr : object {
    private CType _type;
    [CompilerGeneratedAttribute]
private object <RuntimeObject>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <RuntimeObjectActualType>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private EXPRFLAG <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptionalArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorString>k__BackingField;
    internal object RuntimeObject { get; internal set; }
    internal CType RuntimeObjectActualType { get; internal set; }
    public ExpressionKind Kind { get; }
    public EXPRFLAG Flags { get; public set; }
    public bool IsOptionalArgument { get; public set; }
    public string ErrorString { get; public set; }
    public CType Type { get; protected set; }
    [ExcludeFromCodeCoverageAttribute]
public object Object { get; }
    protected Expr(ExpressionKind kind);
    [CompilerGeneratedAttribute]
internal object get_RuntimeObject();
    [CompilerGeneratedAttribute]
internal void set_RuntimeObject(object value);
    [CompilerGeneratedAttribute]
internal CType get_RuntimeObjectActualType();
    [CompilerGeneratedAttribute]
internal void set_RuntimeObjectActualType(CType value);
    [CompilerGeneratedAttribute]
public ExpressionKind get_Kind();
    [CompilerGeneratedAttribute]
public EXPRFLAG get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(EXPRFLAG value);
    [CompilerGeneratedAttribute]
public bool get_IsOptionalArgument();
    [CompilerGeneratedAttribute]
public void set_IsOptionalArgument(bool value);
    [CompilerGeneratedAttribute]
public string get_ErrorString();
    [CompilerGeneratedAttribute]
public void set_ErrorString(string value);
    public CType get_Type();
    protected void set_Type(CType value);
    public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprArrayIndex : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <Index>k__BackingField;
    public Expr Array { get; public set; }
    public Expr Index { get; public set; }
    public ExprArrayIndex(CType type, Expr array, Expr index);
    [CompilerGeneratedAttribute]
public Expr get_Array();
    [CompilerGeneratedAttribute]
public void set_Array(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprArrayInit : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalArgumentDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <DimensionSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DimensionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneratedForParamArray>k__BackingField;
    public Expr OptionalArguments { get; public set; }
    public Expr OptionalArgumentDimensions { get; public set; }
    public Int32[] DimensionSizes { get; }
    public int DimensionSize { get; public set; }
    public bool GeneratedForParamArray { get; public set; }
    public ExprArrayInit(CType type, Expr arguments, Expr argumentDimensions, Int32[] dimensionSizes, int dimensionSize);
    [CompilerGeneratedAttribute]
public Expr get_OptionalArguments();
    [CompilerGeneratedAttribute]
public void set_OptionalArguments(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalArgumentDimensions();
    [CompilerGeneratedAttribute]
public void set_OptionalArgumentDimensions(Expr value);
    [CompilerGeneratedAttribute]
public Int32[] get_DimensionSizes();
    [CompilerGeneratedAttribute]
public int get_DimensionSize();
    [CompilerGeneratedAttribute]
public void set_DimensionSize(int value);
    [CompilerGeneratedAttribute]
public bool get_GeneratedForParamArray();
    [CompilerGeneratedAttribute]
public void set_GeneratedForParamArray(bool value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprAssignment : Expr {
    private Expr _lhs;
    [CompilerGeneratedAttribute]
private Expr <RHS>k__BackingField;
    public Expr LHS { get; public set; }
    public Expr RHS { get; public set; }
    public ExprAssignment(Expr lhs, Expr rhs);
    public Expr get_LHS();
    public void set_LHS(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_RHS();
    [CompilerGeneratedAttribute]
public void set_RHS(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprBinOp : ExprOperator {
    [CompilerGeneratedAttribute]
private Expr <OptionalLeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalRightChild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    public Expr OptionalLeftChild { get; public set; }
    public Expr OptionalRightChild { get; public set; }
    public bool IsLifted { get; public set; }
    public ExprBinOp(ExpressionKind kind, CType type, Expr left, Expr right);
    public ExprBinOp(ExpressionKind kind, CType type, Expr left, Expr right, Expr call, MethPropWithInst userMethod);
    [CompilerGeneratedAttribute]
public Expr get_OptionalLeftChild();
    [CompilerGeneratedAttribute]
public void set_OptionalLeftChild(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalRightChild();
    [CompilerGeneratedAttribute]
public void set_OptionalRightChild(Expr value);
    [CompilerGeneratedAttribute]
public bool get_IsLifted();
    [CompilerGeneratedAttribute]
public void set_IsLifted(bool value);
    public void SetAssignment();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprBoundLambda : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <ArgumentScope>k__BackingField;
    public Expr Expression { get; }
    public AggregateType DelegateType { get; }
    public Scope ArgumentScope { get; }
    public ExprBoundLambda(AggregateType type, Scope argumentScope, Expr expression);
    [CompilerGeneratedAttribute]
public Expr get_Expression();
    public AggregateType get_DelegateType();
    [CompilerGeneratedAttribute]
public Scope get_ArgumentScope();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprCall : ExprWithArgs {
    [CompilerGeneratedAttribute]
private MethWithInst <MethWithInst>k__BackingField;
    [CompilerGeneratedAttribute]
private PREDEFMETH <PredefinedMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableCallLiftKind <NullableCallLiftKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <PConversions>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <CastOfNonLiftedResultToLiftedType>k__BackingField;
    public MethWithInst MethWithInst { get; public set; }
    public PREDEFMETH PredefinedMethod { get; public set; }
    public NullableCallLiftKind NullableCallLiftKind { get; public set; }
    public Expr PConversions { get; public set; }
    public Expr CastOfNonLiftedResultToLiftedType { get; public set; }
    public ExprCall(CType type, EXPRFLAG flags, Expr arguments, ExprMemberGroup member, MethWithInst method);
    [CompilerGeneratedAttribute]
public MethWithInst get_MethWithInst();
    [CompilerGeneratedAttribute]
public void set_MethWithInst(MethWithInst value);
    [CompilerGeneratedAttribute]
public PREDEFMETH get_PredefinedMethod();
    [CompilerGeneratedAttribute]
public void set_PredefinedMethod(PREDEFMETH value);
    [CompilerGeneratedAttribute]
public NullableCallLiftKind get_NullableCallLiftKind();
    [CompilerGeneratedAttribute]
public void set_NullableCallLiftKind(NullableCallLiftKind value);
    [CompilerGeneratedAttribute]
public Expr get_PConversions();
    [CompilerGeneratedAttribute]
public void set_PConversions(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_CastOfNonLiftedResultToLiftedType();
    [CompilerGeneratedAttribute]
public void set_CastOfNonLiftedResultToLiftedType(Expr value);
    public virtual SymWithType GetSymWithType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprCast : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Argument>k__BackingField;
    public Expr Argument { get; public set; }
    public bool IsBoxingCast { get; }
    public object Object { get; }
    public ExprCast(EXPRFLAG flags, CType type, Expr argument);
    [CompilerGeneratedAttribute]
public Expr get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(Expr value);
    public bool get_IsBoxingCast();
    public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprClass : ExprWithType {
    public ExprClass(CType type);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprConcat : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <FirstArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <SecondArgument>k__BackingField;
    public Expr FirstArgument { get; public set; }
    public Expr SecondArgument { get; public set; }
    public ExprConcat(Expr first, Expr second);
    private static CType TypeFromOperands(Expr first, Expr second);
    [CompilerGeneratedAttribute]
public Expr get_FirstArgument();
    [CompilerGeneratedAttribute]
public void set_FirstArgument(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_SecondArgument();
    [CompilerGeneratedAttribute]
public void set_SecondArgument(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprConstant : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalConstructorCall>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstVal <Val>k__BackingField;
    public Expr OptionalConstructorCall { get; public set; }
    public bool IsZero { get; }
    public ConstVal Val { get; }
    public ulong UInt64Value { get; }
    public long Int64Value { get; }
    public object Object { get; }
    public ExprConstant(CType type, ConstVal value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalConstructorCall();
    [CompilerGeneratedAttribute]
public void set_OptionalConstructorCall(Expr value);
    public bool get_IsZero();
    [CompilerGeneratedAttribute]
public ConstVal get_Val();
    public ulong get_UInt64Value();
    public long get_Int64Value();
    public virtual object get_Object();
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionBinder : ValueType {
    private static Byte[][] s_betterConversionTable;
    private static byte ID;
    private static byte IMP;
    private static byte EXP;
    private static byte NO;
    private static byte CONV_KIND_MASK;
    private static byte UDC;
    private static byte XUD;
    private static byte IUD;
    private static Byte[][] s_simpleTypeConversions;
    private static int NUM_SIMPLE_TYPES;
    private static int NUM_EXT_TYPES;
    private static byte same;
    private static byte left;
    private static byte right;
    private static byte neither;
    private static Byte[][] s_simpleTypeBetter;
    [CompilerGeneratedAttribute]
private BindingContext <Context>k__BackingField;
    private static PredefinedType[] s_rgptIntOp;
    private static PredefinedName[] s_EK2NAME;
    private static BinOpSig[] s_binopSignatures;
    private static UnaOpSig[] s_rguos;
    public BindingContext Context { get; }
    private AggregateSymbol ContextForMemberLookup { get; }
    public ExpressionBinder(BindingContext context);
    private static ExpressionBinder();
    private static BetterType WhichMethodIsBetterTieBreaker(CandidateFunctionMember node1, CandidateFunctionMember node2, CType pTypeThrough, ArgInfos args);
    private static BetterType CompareTypes(TypeArray ta1, TypeArray ta2);
    private static int FindName(List`1<Name> names, Name name);
    private static TypeArray RearrangeNamedArguments(TypeArray pta, MethPropWithInst mpwi, CType pTypeThrough, ArgInfos args);
    private BetterType WhichMethodIsBetter(CandidateFunctionMember node1, CandidateFunctionMember node2, CType pTypeThrough, ArgInfos args);
    private BetterType WhichConversionIsBetter(CType argType, CType p1, CType p2);
    private CandidateFunctionMember FindBestMethod(List`1<CandidateFunctionMember> list, CType pTypeThrough, ArgInfos args, CandidateFunctionMember& methAmbig1, CandidateFunctionMember& methAmbig2);
    private static void RoundToFloat(double d, Single& f);
    private static long I64(long x);
    private static long I64(ulong x);
    private static ConvKind GetConvKind(PredefinedType ptSrc, PredefinedType ptDst);
    private static bool isUserDefinedConversion(PredefinedType ptSrc, PredefinedType ptDst);
    private BetterType WhichSimpleConversionIsBetter(PredefinedType pt1, PredefinedType pt2);
    private BetterType WhichTypeIsBetter(PredefinedType pt1, PredefinedType pt2, CType typeGiven);
    private BetterType WhichTypeIsBetter(CType type1, CType type2, CType typeGiven);
    private bool canConvert(CType src, CType dest, CONVERTTYPE flags);
    public bool canConvert(CType src, CType dest);
    private bool canConvert(Expr expr, CType dest);
    private bool canConvert(Expr expr, CType dest, CONVERTTYPE flags);
    private Expr mustConvertCore(Expr expr, CType destExpr);
    private Expr mustConvertCore(Expr expr, CType dest, CONVERTTYPE flags);
    public Expr tryConvert(Expr expr, CType dest);
    private Expr tryConvert(Expr expr, CType dest, CONVERTTYPE flags);
    public Expr mustConvert(Expr expr, CType dest);
    private Expr mustConvert(Expr expr, CType dest, CONVERTTYPE flags);
    private Expr mustCastCore(Expr expr, CType dest, CONVERTTYPE flags);
    private static RuntimeBinderException CantConvert(Expr expr, CType dest);
    public Expr mustCast(Expr expr, CType dest);
    public Expr mustCast(Expr expr, CType dest, CONVERTTYPE flags);
    private Expr MustCastInUncheckedContext(Expr expr, CType dest, CONVERTTYPE flags);
    private bool canCast(CType src, CType dest, CONVERTTYPE flags);
    private bool BindImplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, CONVERTTYPE flags);
    private bool BindImplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, Expr& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindImplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, bool needsExprDest, Expr& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindExplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, bool needsExprDest, Expr& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindExplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, Expr& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindExplicitConversion(Expr pSourceExpr, CType pSourceType, CType destinationType, CONVERTTYPE flags);
    private bool bindUserDefinedConversion(Expr exprSrc, CType typeSrc, CType typeDst, bool needExprDest, Expr& pexprDst, bool fImplicitOnly);
    private static RuntimeBinderException HandleAmbiguity(CType typeSrc, CType typeDst, List`1<UdConvInfo> prguci, int iuciBestSrc, int iuciBestDst);
    private static void MarkAsIntermediateConversion(Expr pExpr);
    private Expr BindUDConversionCore(Expr pFrom, CType pTypeFrom, CType pTypeTo, CType pTypeDestination, MethWithInst mwiBest);
    private Expr BindUDConversionCore(Expr pFrom, CType pTypeFrom, CType pTypeTo, CType pTypeDestination, MethWithInst mwiBest, Expr& ppTransformedArgument);
    private ConstCastResult bindConstantCast(Expr exprSrc, CType typeDest, bool needExprDest, Expr& pexprDest, bool explicitConversion);
    private int CompareSrcTypesBased(CType type1, bool fImplicit1, CType type2, bool fImplicit2);
    private int CompareDstTypesBased(CType type1, bool fImplicit1, CType type2, bool fImplicit2);
    private static Expr BindDecimalConstCast(CType destType, CType srcType, ExprConstant src);
    private bool CanExplicitConversionBeBoundInUncheckedContext(Expr exprSrc, CType typeSrc, CType typeDest, CONVERTTYPE flags);
    [CompilerGeneratedAttribute]
public BindingContext get_Context();
    private static AggregateType GetPredefindType(PredefinedType pt);
    private Expr GenerateAssignmentConversion(Expr op1, Expr op2, bool allowExplicit);
    public Expr BindAssignment(Expr op1, Expr op2, bool allowExplicit);
    internal Expr BindArrayIndexCore(Expr pOp1, Expr pOp2);
    private void bindSimpleCast(Expr exprSrc, CType typeDest, Expr& pexprDest);
    private void bindSimpleCast(Expr exprSrc, CType typeDest, Expr& pexprDest, EXPRFLAG exprFlags);
    private ExprCall BindToMethod(MethWithInst mwi, Expr pArguments, ExprMemberGroup pMemGroup, MemLookFlags flags);
    internal Expr BindToField(Expr pOptionalObject, FieldWithType fwt, BindingFlag bindFlags);
    internal ExprProperty BindToProperty(Expr pObject, PropWithType pwt, BindingFlag bindFlags, Expr args, ExprMemberGroup pMemGroup);
    internal Expr bindUDUnop(ExpressionKind ek, Expr arg);
    private ExprCall BindLiftedUDUnop(Expr arg, CType typeArg, MethPropWithInst mpwi);
    private ExprCall BindUDUnopCall(Expr arg, CType typeArg, MethPropWithInst mpwi);
    private GroupToArgsBinderResult BindMethodGroupToArgumentsCore(BindingFlag bindFlags, ExprMemberGroup grp, Expr args, int carg, NamedArgumentsKind namedArgumentsKind);
    internal ExprWithArgs BindMethodGroupToArguments(BindingFlag bindFlags, ExprMemberGroup grp, Expr args);
    private static NamedArgumentsKind FindNamedArgumentsType(Expr args);
    private static RuntimeBinderException BadOperatorTypesError(Expr pOperand1, Expr pOperand2);
    private static ErrorCode GetStandardLvalueError(CheckLvalueKind kind);
    private void CheckLvalueProp(ExprProperty prop);
    private void CheckPropertyAccess(MethWithType mwt, PropWithType pwtSlot, CType type);
    private void CheckLvalue(Expr expr, CheckLvalueKind kind);
    private static void PostBindMethod(MethWithInst pMWI);
    private static void PostBindProperty(PropWithType pwt, MethWithType& pmwtGet, MethWithType& pmwtSet);
    private Expr AdjustMemberObject(SymWithType swt, Expr pObject);
    private static bool IsMatchingStatic(SymWithType swt, Expr pObject);
    [ConditionalAttribute("DEBUG")]
private static void AssertObjectIsLvalue(Expr pObject);
    private void verifyMethodArgs(ExprWithArgs call, CType callingObjectType);
    private void AdjustCallArgumentsForParams(CType callingObjectType, CType type, MethodOrPropertySymbol mp, TypeArray pTypeArgs, Expr argsPtr, Expr& newArgs);
    internal CType ChooseArrayIndexType(Expr args);
    internal static void FillInArgInfoFromArgList(ArgInfos argInfo, Expr args);
    private static bool TryGetExpandedParams(TypeArray params, int count, TypeArray& ppExpandedParams);
    public static bool IsMethPropCallable(MethodOrPropertySymbol sym, bool requireUC);
    private static bool IsConvInTable(List`1<UdConvInfo> convTable, MethodSymbol meth, AggregateType ats, bool fSrc, bool fDst);
    private static bool isConstantInRange(ExprConstant exprSrc, CType typeDest);
    private static bool isConstantInRange(ExprConstant exprSrc, CType typeDest, bool realsOk);
    private static Name ExpressionKindName(ExpressionKind ek);
    private static void CheckUnsafe(CType type);
    private AggregateSymbol get_ContextForMemberLookup();
    private static ExprWrap WrapShortLivedExpression(Expr expr);
    private static ExprAssignment GenerateOptimizedAssignment(Expr op1, Expr op2);
    internal static int CountArguments(Expr args);
    private static bool IsNullableConstructor(Expr expr, ExprCall& call);
    private static Expr StripNullableConstructor(Expr pExpr);
    private static Expr BindNubValue(Expr exprSrc);
    private static ExprCall BindNubNew(Expr exprSrc);
    private ExprBinOp BindUserDefinedBinOp(ExpressionKind ek, BinOpArgInfo info);
    private bool GetSpecialBinopSignatures(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private bool GetStandardAndLiftedBinopSignatures(List`1<BinOpFullSig> rgbofs, BinOpArgInfo info);
    private int FindBestSignatureInList(List`1<BinOpFullSig> binopSignatures, BinOpArgInfo info);
    private static ExprBinOp BindNullEqualityComparison(ExpressionKind ek, BinOpArgInfo info);
    public Expr BindStandardBinop(ExpressionKind ek, Expr arg1, Expr arg2);
    private Expr BindStandardBinopCore(BinOpArgInfo info, BinOpFullSig bofs, ExpressionKind ek, EXPRFLAG flags);
    private ExprBinOp BindLiftedStandardBinOp(BinOpArgInfo info, BinOpFullSig bofs, ExpressionKind ek, EXPRFLAG flags);
    private void LiftArgument(Expr pArgument, CType pParameterType, bool bConvertBeforeLift, Expr& ppLiftedArgument, Expr& ppNonLiftedArgument);
    private bool GetDelBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private bool CanConvertArg1(BinOpArgInfo info, CType typeDst, LiftFlags& pgrflt, CType& ptypeSig1, CType& ptypeSig2);
    private bool CanConvertArg2(BinOpArgInfo info, CType typeDst, LiftFlags& pgrflt, CType& ptypeSig1, CType& ptypeSig2);
    private static void RecordBinOpSigFromArgs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private bool GetEnumBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private static bool IsEnumArithmeticBinOp(ExpressionKind ek, BinOpArgInfo info);
    private bool GetRefEqualSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private int WhichBofsIsBetter(BinOpFullSig bofs1, BinOpFullSig bofs2, CType type1, CType type2);
    private static ValueTuple`3<ExpressionKind, UnaOpKind, EXPRFLAG> CalculateExprAndUnaryOpKinds(OperatorKind op, bool bChecked);
    public Expr BindStandardUnaryOperator(OperatorKind op, Expr pArgument);
    private UnaryOperatorSignatureFindResult PopulateSignatureList(Expr pArgument, UnaOpKind unaryOpKind, UnaOpMask unaryOpMask, ExpressionKind exprKind, EXPRFLAG flags, List`1<UnaOpFullSig> pSignatures, Expr& ppResult);
    private bool FindApplicableSignatures(Expr pArgument, UnaOpMask unaryOpMask, List`1<UnaOpFullSig> pSignatures);
    private ExprOperator BindLiftedStandardUnop(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    private int WhichUofsIsBetter(UnaOpFullSig uofs1, UnaOpFullSig uofs2, CType typeArg);
    private static ExprOperator BindIntBinOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static ExprOperator BindIntUnaOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private static ExprOperator BindRealBinOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG _, Expr arg1, Expr arg2);
    private static ExprOperator BindRealUnaOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG _, Expr arg);
    private Expr BindIncOp(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    private Expr BindIncOpCore(ExpressionKind ek, EXPRFLAG flags, Expr exprVal, CType type);
    private Expr LScalar(ExpressionKind ek, EXPRFLAG flags, Expr exprVal, CType type, ConstVal cv, CType typeTmp);
    private ExprMulti BindNonliftedIncOp(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    private ExprMulti BindLiftedIncOp(ExpressionKind ek, EXPRFLAG flags, Expr arg, UnaOpFullSig uofs);
    private static ExprBinOp BindDecBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static ExprUnaryOp BindDecUnaOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private static Expr BindStrBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static ExprBinOp BindShiftOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static ExprBinOp BindBoolBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private ExprOperator BindBoolBitwiseOp(ExpressionKind ek, EXPRFLAG flags, Expr expr1, Expr expr2);
    private static Expr BindLiftedBoolBitwiseOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr expr1, Expr expr2);
    private static Expr BindBoolUnaOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private static ExprBinOp BindStrCmpOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static ExprBinOp BindRefCmpOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static Expr BindDelBinOp(ExpressionBinder _, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static Expr BindEnumBinOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private Expr BindLiftedEnumArithmeticBinOp(ExpressionKind ek, EXPRFLAG flags, Expr arg1, Expr arg2);
    private static Expr BindEnumUnaOp(ExpressionBinder binder, ExpressionKind ek, EXPRFLAG flags, Expr arg);
    private ValueTuple`2<BinOpKind, EXPRFLAG> GetBinopKindAndFlags(ExpressionKind ek);
    private ExprOperator BindIntOp(ExpressionKind kind, EXPRFLAG flags, Expr op1, Expr op2, PredefinedType ptOp);
    private ExprOperator BindIntegerNeg(EXPRFLAG flags, Expr op, PredefinedType ptOp);
    private static ExprOperator BindFloatOp(ExpressionKind kind, Expr op1, Expr op2);
    private static ExprConcat BindStringConcat(Expr op1, Expr op2);
    private static RuntimeBinderException AmbiguousOperatorError(Expr op1, Expr op2);
    private Expr BindUserBoolOp(ExpressionKind kind, ExprCall pCall);
    private static AggregateType GetUserDefinedBinopArgumentType(CType type);
    private static int GetUserDefinedBinopArgumentTypes(CType type1, CType type2, AggregateType[] rgats);
    private static bool UserDefinedBinaryOperatorCanBeLifted(ExpressionKind ek, MethodSymbol method, AggregateType ats, TypeArray Params);
    private bool UserDefinedBinaryOperatorIsApplicable(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, MethodSymbol method, AggregateType ats, Expr arg1, Expr arg2, bool fDontLift);
    private bool GetApplicableUserDefinedBinaryOperatorCandidates(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, AggregateType type, Expr arg1, Expr arg2, bool fDontLift);
    private AggregateType GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, AggregateType type, Expr arg1, Expr arg2, bool fDontLift, AggregateType atsStop);
    private ExprCall BindUDBinop(ExpressionKind ek, Expr arg1, Expr arg2, bool fDontLift, MethPropWithInst& ppmpwi);
    private ExprCall BindUDBinopCall(Expr arg1, Expr arg2, TypeArray Params, CType typeRet, MethPropWithInst mpwi);
    private ExprCall BindLiftedUDBinop(ExpressionKind ek, Expr arg1, Expr arg2, TypeArray Params, MethPropWithInst mpwi);
    private static AggregateType GetEnumBinOpType(ExpressionKind ek, CType argType1, CType argType2, AggregateType& ppEnumType);
    private static ExprBinOp CreateBinopForPredefMethodCall(ExpressionKind ek, PREDEFMETH predefMeth, CType RetType, Expr arg1, Expr arg2);
    private static ExprUnaryOp CreateUnaryOpForPredefMethodCall(ExpressionKind ek, PREDEFMETH predefMeth, CType pRetType, Expr pArg);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionIterator : object {
    private ExprList _pList;
    private Expr _pCurrent;
    public ExpressionIterator(Expr pExpr);
    public bool AtEnd();
    public Expr Current();
    public void MoveNext();
    public static int Count(Expr pExpr);
    private void Init(Expr pExpr);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionKind : Enum {
    public int value__;
    public static ExpressionKind NoOp;
    public static ExpressionKind BinaryOp;
    public static ExpressionKind UnaryOp;
    public static ExpressionKind Assignment;
    public static ExpressionKind List;
    public static ExpressionKind ArrayIndex;
    public static ExpressionKind Call;
    public static ExpressionKind Field;
    public static ExpressionKind Local;
    public static ExpressionKind Constant;
    public static ExpressionKind Class;
    public static ExpressionKind Property;
    public static ExpressionKind Multi;
    public static ExpressionKind MultiGet;
    public static ExpressionKind Wrap;
    public static ExpressionKind Concat;
    public static ExpressionKind ArrayInit;
    public static ExpressionKind Cast;
    public static ExpressionKind UserDefinedConversion;
    public static ExpressionKind TypeOf;
    public static ExpressionKind ZeroInit;
    public static ExpressionKind UserLogicalOp;
    public static ExpressionKind MemberGroup;
    public static ExpressionKind BoundLambda;
    public static ExpressionKind FieldInfo;
    public static ExpressionKind MethodInfo;
    public static ExpressionKind PropertyInfo;
    public static ExpressionKind NamedArgumentSpecification;
    public static ExpressionKind ExpressionKindCount;
    public static ExpressionKind EqualsParam;
    public static ExpressionKind FirstOp;
    public static ExpressionKind Compare;
    public static ExpressionKind True;
    public static ExpressionKind False;
    public static ExpressionKind Inc;
    public static ExpressionKind Dec;
    public static ExpressionKind LogicalNot;
    public static ExpressionKind Eq;
    public static ExpressionKind RelationalMin;
    public static ExpressionKind NotEq;
    public static ExpressionKind LessThan;
    public static ExpressionKind LessThanOrEqual;
    public static ExpressionKind GreaterThan;
    public static ExpressionKind GreaterThanOrEqual;
    public static ExpressionKind RelationalMax;
    public static ExpressionKind Add;
    public static ExpressionKind Subtract;
    public static ExpressionKind Multiply;
    public static ExpressionKind Divide;
    public static ExpressionKind Modulo;
    public static ExpressionKind Negate;
    public static ExpressionKind UnaryPlus;
    public static ExpressionKind BitwiseAnd;
    public static ExpressionKind BitwiseOr;
    public static ExpressionKind BitwiseExclusiveOr;
    public static ExpressionKind BitwiseNot;
    public static ExpressionKind LeftShirt;
    public static ExpressionKind RightShift;
    public static ExpressionKind LogicalAnd;
    public static ExpressionKind LogicalOr;
    public static ExpressionKind Sequence;
    public static ExpressionKind Save;
    public static ExpressionKind Swap;
    public static ExpressionKind Indir;
    public static ExpressionKind Addr;
    public static ExpressionKind StringEq;
    public static ExpressionKind StringNotEq;
    public static ExpressionKind DelegateEq;
    public static ExpressionKind DelegateNotEq;
    public static ExpressionKind DelegateAdd;
    public static ExpressionKind DelegateSubtract;
    public static ExpressionKind DecimalNegate;
    public static ExpressionKind DecimalInc;
    public static ExpressionKind DecimalDec;
    public static ExpressionKind MultiOffset;
    public static ExpressionKind TypeLimit;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionKindExtensions : object {
    [ExtensionAttribute]
public static bool IsRelational(ExpressionKind kind);
    [ExtensionAttribute]
public static bool IsUnaryOperator(ExpressionKind kind);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionTreeRewriter : ExprVisitorBase {
    public static ExprBinOp Rewrite(ExprBoundLambda expr);
    protected virtual Expr Dispatch(Expr expr);
    protected virtual Expr VisitASSIGNMENT(ExprAssignment assignment);
    protected virtual Expr VisitMULTIGET(ExprMultiGet pExpr);
    protected virtual Expr VisitMULTI(ExprMulti pExpr);
    private ExprBinOp VisitBoundLambda(ExprBoundLambda anonmeth);
    protected virtual Expr VisitCONSTANT(ExprConstant expr);
    protected virtual Expr VisitLOCAL(ExprLocal local);
    protected virtual Expr VisitFIELD(ExprField expr);
    protected virtual Expr VisitUSERDEFINEDCONVERSION(ExprUserDefinedConversion expr);
    protected virtual Expr VisitCAST(ExprCast pExpr);
    protected virtual Expr VisitCONCAT(ExprConcat expr);
    protected virtual Expr VisitBINOP(ExprBinOp expr);
    protected virtual Expr VisitUNARYOP(ExprUnaryOp pExpr);
    protected virtual Expr VisitARRAYINDEX(ExprArrayIndex pExpr);
    protected virtual Expr VisitCALL(ExprCall expr);
    protected virtual Expr VisitPROP(ExprProperty expr);
    protected virtual Expr VisitARRINIT(ExprArrayInit expr);
    protected virtual Expr VisitZEROINIT(ExprZeroInit expr);
    protected virtual Expr VisitTYPEOF(ExprTypeOf expr);
    private Expr GenerateDelegateInvoke(ExprCall expr);
    private Expr GenerateBuiltInBinaryOperator(ExprBinOp expr);
    private Expr GenerateBuiltInUnaryOperator(ExprUnaryOp expr);
    private Expr GenerateUserDefinedBinaryOperator(ExprBinOp expr);
    private Expr GenerateUserDefinedUnaryOperator(ExprUnaryOp expr);
    private Expr GenerateUserDefinedComparisonOperator(ExprBinOp expr);
    private Expr GenerateConversion(Expr arg, CType CType, bool bChecked);
    private static Expr GenerateConversionWithSource(Expr pTarget, CType pType, bool bChecked);
    private Expr GenerateValueAccessConversion(Expr pArgument);
    private Expr GenerateUserDefinedConversion(Expr arg, CType type, MethWithInst method);
    private static Expr GenerateUserDefinedConversion(Expr arg, CType CType, Expr target, MethWithInst method);
    private Expr GenerateUserDefinedConversion(ExprUserDefinedConversion pExpr, Expr pArgument);
    private static Expr GenerateParameter(string name, CType CType);
    private static MethodSymbol GetPreDefMethod(PREDEFMETH pdm);
    private static ExprTypeOf CreateTypeOf(CType type);
    private static Expr CreateWraps(ExprBoundLambda anonmeth);
    private Expr GenerateConstructor(ExprCall expr);
    private Expr GenerateArgsList(Expr oldArgs);
    private Expr GenerateIndexList(Expr oldIndices);
    private static Expr GenerateConstant(Expr expr);
    private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1);
    private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1, Expr arg2);
    private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1, Expr arg2, Expr arg3);
    private static ExprCall GenerateCall(PREDEFMETH pdm, Expr arg1, Expr arg2, Expr arg3, Expr arg4);
    private static ExprArrayInit GenerateParamsArray(Expr args, PredefinedType pt);
    private static void FixLiftedUserDefinedBinaryOperators(ExprBinOp expr, Expr& pp1, Expr& pp2);
    private static bool IsNullableValueType(CType pType);
    private static bool IsNullableValueAccess(Expr pExpr, Expr pObject);
    private static bool isEnumToDecimalConversion(CType argtype, CType desttype);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRExtensions : object {
    [ExtensionAttribute]
public static Expr Map(Expr expr, Func`2<Expr, Expr> f);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.EXPRExtensions/<ToEnumerable>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<Expr> ToEnumerable(Expr expr);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertIsBin(Expr expr);
    [ExtensionAttribute]
public static bool isLvalue(Expr expr);
    [ExtensionAttribute]
public static bool isChecked(Expr expr);
    [ExtensionAttribute]
public static bool isNull(Expr expr);
    [ExtensionAttribute]
public static bool IsZero(Expr expr);
    [ExtensionAttribute]
private static Expr GetSeqVal(Expr expr);
    [ExtensionAttribute]
public static Expr GetConst(Expr expr);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ExprFactory : object {
    public static ExprCall CreateCall(EXPRFLAG flags, CType type, Expr arguments, ExprMemberGroup memberGroup, MethWithInst method);
    public static ExprField CreateField(CType type, Expr optionalObject, FieldWithType field);
    public static ExprArrayInit CreateArrayInit(CType type, Expr arguments, Expr argumentDimensions, Int32[] dimSizes, int dimSize);
    public static ExprProperty CreateProperty(CType type, Expr optionalObjectThrough, Expr arguments, ExprMemberGroup memberGroup, PropWithType property, MethWithType setMethod);
    public static ExprMemberGroup CreateMemGroup(EXPRFLAG flags, Name name, TypeArray typeArgs, SYMKIND symKind, CType parentType, Expr obj, CMemberLookupResults memberLookupResults);
    public static ExprMemberGroup CreateMemGroup(Expr obj, MethPropWithInst method);
    public static ExprUserDefinedConversion CreateUserDefinedConversion(Expr arg, Expr call, MethWithInst method);
    public static ExprCast CreateCast(CType type, Expr argument);
    public static ExprCast CreateCast(EXPRFLAG flags, CType type, Expr argument);
    public static ExprLocal CreateLocal(LocalVariableSymbol local);
    public static ExprBoundLambda CreateAnonymousMethod(AggregateType delegateType, Scope argumentScope, Expr expression);
    public static ExprMethodInfo CreateMethodInfo(MethPropWithInst mwi);
    public static ExprMethodInfo CreateMethodInfo(MethodSymbol method, AggregateType methodType, TypeArray methodParameters);
    public static ExprPropertyInfo CreatePropertyInfo(PropertySymbol prop, AggregateType propertyType);
    public static ExprFieldInfo CreateFieldInfo(FieldSymbol field, AggregateType fieldType);
    public static ExprTypeOf CreateTypeOf(CType sourceType);
    public static ExprUserLogicalOp CreateUserLogOp(CType type, Expr trueFalseCall, ExprCall operatorCall);
    public static ExprConcat CreateConcat(Expr first, Expr second);
    public static ExprConstant CreateStringConstant(string str);
    public static ExprMultiGet CreateMultiGet(EXPRFLAG flags, CType type, ExprMulti multi);
    public static ExprMulti CreateMulti(EXPRFLAG flags, CType type, Expr left, Expr op);
    public static Expr CreateZeroInit(CType type);
    public static ExprConstant CreateConstant(CType type, ConstVal constVal);
    public static ExprConstant CreateIntegerConstant(int x);
    public static ExprConstant CreateBoolConstant(bool b);
    public static ExprArrayIndex CreateArrayIndex(CType type, Expr array, Expr index);
    public static ExprBinOp CreateBinop(ExpressionKind exprKind, CType type, Expr left, Expr right);
    public static ExprUnaryOp CreateUnaryOp(ExpressionKind exprKind, CType type, Expr operand);
    public static ExprOperator CreateOperator(ExpressionKind exprKind, CType type, Expr arg1, Expr arg2);
    public static ExprBinOp CreateUserDefinedBinop(ExpressionKind exprKind, CType type, Expr left, Expr right, Expr call, MethPropWithInst userMethod);
    public static ExprUnaryOp CreateUserDefinedUnaryOperator(ExpressionKind exprKind, CType type, Expr operand, ExprCall call, MethPropWithInst userMethod);
    public static ExprUnaryOp CreateNeg(EXPRFLAG flags, Expr operand);
    public static ExprBinOp CreateSequence(Expr first, Expr second);
    public static ExprAssignment CreateAssignment(Expr left, Expr right);
    public static ExprNamedArgumentSpecification CreateNamedArgumentSpecification(Name name, Expr value);
    public static ExprWrap CreateWrap(Expr expression);
    public static ExprBinOp CreateSave(ExprWrap wrap);
    public static ExprConstant CreateNull();
    public static void AppendItemToList(Expr newItem, Expr& first, Expr& last);
    public static ExprList CreateList(Expr op1, Expr op2);
    public static ExprList CreateList(Expr op1, Expr op2, Expr op3);
    public static ExprList CreateList(Expr op1, Expr op2, Expr op3, Expr op4);
    public static ExprClass CreateClass(CType type);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprField : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldWithType <FieldWithType>k__BackingField;
    public Expr OptionalObject { get; public set; }
    public FieldWithType FieldWithType { get; }
    public ExprField(CType type, Expr optionalObject, FieldWithType field);
    [CompilerGeneratedAttribute]
public Expr get_OptionalObject();
    [CompilerGeneratedAttribute]
public void set_OptionalObject(Expr value);
    [CompilerGeneratedAttribute]
public FieldWithType get_FieldWithType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprFieldInfo : ExprWithType {
    [CompilerGeneratedAttribute]
private FieldSymbol <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateType <FieldType>k__BackingField;
    public FieldSymbol Field { get; }
    public AggregateType FieldType { get; }
    public ExprFieldInfo(FieldSymbol field, AggregateType fieldType, CType type);
    [CompilerGeneratedAttribute]
public FieldSymbol get_Field();
    [CompilerGeneratedAttribute]
public AggregateType get_FieldType();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.EXPRFLAG : Enum {
    public int value__;
    public static EXPRFLAG EXF_BINOP;
    public static EXPRFLAG EXF_CTOR;
    public static EXPRFLAG EXF_NEEDSRET;
    public static EXPRFLAG EXF_ASLEAVE;
    public static EXPRFLAG EXF_ISFAULT;
    public static EXPRFLAG EXF_HASHTABLESWITCH;
    public static EXPRFLAG EXF_BOX;
    public static EXPRFLAG EXF_ARRAYCONST;
    public static EXPRFLAG EXF_MEMBERSET;
    public static EXPRFLAG EXF_OPENTYPE;
    public static EXPRFLAG EXF_LABELREFERENCED;
    public static EXPRFLAG EXF_GENERATEDQMARK;
    public static EXPRFLAG EXF_INDEXER;
    public static EXPRFLAG EXF_GOTOCASE;
    public static EXPRFLAG EXF_REMOVEFINALLY;
    public static EXPRFLAG EXF_UNBOX;
    public static EXPRFLAG EXF_ARRAYALLCONST;
    public static EXPRFLAG EXF_CTORPREAMBLE;
    public static EXPRFLAG EXF_USERLABEL;
    public static EXPRFLAG EXF_OPERATOR;
    public static EXPRFLAG EXF_ISPOSTOP;
    public static EXPRFLAG EXF_FINALLYBLOCKED;
    public static EXPRFLAG EXF_REFCHECK;
    public static EXPRFLAG EXF_WRAPASTEMP;
    public static EXPRFLAG EXF_LITERALCONST;
    public static EXPRFLAG EXF_BADGOTO;
    public static EXPRFLAG EXF_RETURNISYIELD;
    public static EXPRFLAG EXF_ISFINALLY;
    public static EXPRFLAG EXF_NEWOBJCALL;
    public static EXPRFLAG EXF_INDEXEXPR;
    public static EXPRFLAG EXF_REPLACEWRAP;
    public static EXPRFLAG EXF_UNREALIZEDGOTO;
    public static EXPRFLAG EXF_CONSTRAINED;
    public static EXPRFLAG EXF_FORCE_BOX;
    public static EXPRFLAG EXF_SIMPLENAME;
    public static EXPRFLAG EXF_ASFINALLYLEAVE;
    public static EXPRFLAG EXF_BASECALL;
    public static EXPRFLAG EXF_FORCE_UNBOX;
    public static EXPRFLAG EXF_ADDRNOCONV;
    public static EXPRFLAG EXF_GOTONOTBLOCKED;
    public static EXPRFLAG EXF_DELEGATE;
    public static EXPRFLAG EXF_STATIC_CAST;
    public static EXPRFLAG EXF_USERCALLABLE;
    public static EXPRFLAG EXF_UNBOXRUNTIME;
    public static EXPRFLAG EXF_NEWSTRUCTASSG;
    public static EXPRFLAG EXF_GENERATEDSTMT;
    public static EXPRFLAG EXF_IMPLICITSTRUCTASSG;
    public static EXPRFLAG EXF_MARKING;
    public static EXPRFLAG EXF_UNREACHABLEBEGIN;
    public static EXPRFLAG EXF_UNREACHABLEEND;
    public static EXPRFLAG EXF_USEORIGDEBUGINFO;
    public static EXPRFLAG EXF_LASTBRACEDEBUGINFO;
    public static EXPRFLAG EXF_NODEBUGINFO;
    public static EXPRFLAG EXF_IMPLICITTHIS;
    public static EXPRFLAG EXF_CANTBENULL;
    public static EXPRFLAG EXF_CHECKOVERFLOW;
    public static EXPRFLAG EXF_PUSH_OP_FIRST;
    public static EXPRFLAG EXF_ASSGOP;
    public static EXPRFLAG EXF_LVALUE;
    public static EXPRFLAG EXF_SAMENAMETYPE;
    public static EXPRFLAG EXF_MASK_ANY;
    public static EXPRFLAG EXF_CAST_ALL;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprList : Expr {
    [CompilerGeneratedAttribute]
private Expr <OptionalElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalNextListNode>k__BackingField;
    public Expr OptionalElement { get; public set; }
    public Expr OptionalNextListNode { get; public set; }
    public ExprList(Expr optionalElement, Expr optionalNextListNode);
    [CompilerGeneratedAttribute]
public Expr get_OptionalElement();
    [CompilerGeneratedAttribute]
public void set_OptionalElement(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalNextListNode();
    [CompilerGeneratedAttribute]
public void set_OptionalNextListNode(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprLocal : Expr {
    [CompilerGeneratedAttribute]
private LocalVariableSymbol <Local>k__BackingField;
    public LocalVariableSymbol Local { get; }
    public ExprLocal(LocalVariableSymbol local);
    [CompilerGeneratedAttribute]
public LocalVariableSymbol get_Local();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMemberGroup : ExprWithType {
    [CompilerGeneratedAttribute]
private Name <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private SYMKIND <SymKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalLHS>k__BackingField;
    [CompilerGeneratedAttribute]
private CMemberLookupResults <MemberLookupResults>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <ParentType>k__BackingField;
    public Name Name { get; }
    public TypeArray TypeArgs { get; }
    public SYMKIND SymKind { get; }
    public Expr OptionalObject { get; public set; }
    public Expr OptionalLHS { get; public set; }
    public CMemberLookupResults MemberLookupResults { get; }
    public CType ParentType { get; }
    public bool IsDelegate { get; }
    public ExprMemberGroup(EXPRFLAG flags, Name name, TypeArray typeArgs, SYMKIND symKind, CType parentType, Expr optionalObject, CMemberLookupResults memberLookupResults);
    [CompilerGeneratedAttribute]
public Name get_Name();
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgs();
    [CompilerGeneratedAttribute]
public SYMKIND get_SymKind();
    [CompilerGeneratedAttribute]
public Expr get_OptionalObject();
    [CompilerGeneratedAttribute]
public void set_OptionalObject(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalLHS();
    [CompilerGeneratedAttribute]
public void set_OptionalLHS(Expr value);
    [CompilerGeneratedAttribute]
public CMemberLookupResults get_MemberLookupResults();
    [CompilerGeneratedAttribute]
public CType get_ParentType();
    public bool get_IsDelegate();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMethodInfo : ExprWithType {
    [CompilerGeneratedAttribute]
private MethWithInst <Method>k__BackingField;
    public MethWithInst Method { get; }
    public MethodInfo MethodInfo { get; }
    public ConstructorInfo ConstructorInfo { get; }
    public object Object { get; }
    public ExprMethodInfo(CType type, MethodSymbol method, AggregateType methodType, TypeArray methodParameters);
    [CompilerGeneratedAttribute]
public MethWithInst get_Method();
    public MethodInfo get_MethodInfo();
    public ConstructorInfo get_ConstructorInfo();
    public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMulti : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <Operator>k__BackingField;
    public Expr Left { get; public set; }
    public Expr Operator { get; public set; }
    public ExprMulti(CType type, EXPRFLAG flags, Expr left, Expr op);
    [CompilerGeneratedAttribute]
public Expr get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(Expr value);
    [CompilerGeneratedAttribute]
public Expr get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprMultiGet : ExprWithType {
    [CompilerGeneratedAttribute]
private ExprMulti <OptionalMulti>k__BackingField;
    public ExprMulti OptionalMulti { get; public set; }
    public ExprMultiGet(CType type, EXPRFLAG flags, ExprMulti multi);
    [CompilerGeneratedAttribute]
public ExprMulti get_OptionalMulti();
    [CompilerGeneratedAttribute]
public void set_OptionalMulti(ExprMulti value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprNamedArgumentSpecification : Expr {
    private Expr _value;
    [CompilerGeneratedAttribute]
private Name <Name>k__BackingField;
    public Name Name { get; }
    public Expr Value { get; public set; }
    public ExprNamedArgumentSpecification(Name name, Expr value);
    [CompilerGeneratedAttribute]
public Name get_Name();
    public Expr get_Value();
    public void set_Value(Expr value);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprOperator : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <OptionalUserDefinedCall>k__BackingField;
    [CompilerGeneratedAttribute]
private MethWithInst <PredefinedMethodToCall>k__BackingField;
    [CompilerGeneratedAttribute]
private MethPropWithInst <UserDefinedCallMethod>k__BackingField;
    public Expr OptionalUserDefinedCall { get; }
    public MethWithInst PredefinedMethodToCall { get; public set; }
    public MethPropWithInst UserDefinedCallMethod { get; public set; }
    protected ExprOperator(ExpressionKind kind, CType type);
    protected ExprOperator(ExpressionKind kind, CType type, Expr call, MethPropWithInst userDefinedMethod);
    [CompilerGeneratedAttribute]
public Expr get_OptionalUserDefinedCall();
    [CompilerGeneratedAttribute]
public MethWithInst get_PredefinedMethodToCall();
    [CompilerGeneratedAttribute]
public void set_PredefinedMethodToCall(MethWithInst value);
    [CompilerGeneratedAttribute]
public MethPropWithInst get_UserDefinedCallMethod();
    [CompilerGeneratedAttribute]
public void set_UserDefinedCallMethod(MethPropWithInst value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprProperty : ExprWithArgs {
    [CompilerGeneratedAttribute]
private Expr <OptionalObjectThrough>k__BackingField;
    [CompilerGeneratedAttribute]
private PropWithType <PropWithTypeSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private MethWithType <MethWithTypeSet>k__BackingField;
    public Expr OptionalObjectThrough { get; }
    public PropWithType PropWithTypeSlot { get; }
    public MethWithType MethWithTypeSet { get; }
    public ExprProperty(CType type, Expr pOptionalObjectThrough, Expr pOptionalArguments, ExprMemberGroup pMemberGroup, PropWithType pwtSlot, MethWithType mwtSet);
    [CompilerGeneratedAttribute]
public Expr get_OptionalObjectThrough();
    [CompilerGeneratedAttribute]
public PropWithType get_PropWithTypeSlot();
    [CompilerGeneratedAttribute]
public MethWithType get_MethWithTypeSet();
    public virtual SymWithType GetSymWithType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprPropertyInfo : ExprWithType {
    [CompilerGeneratedAttribute]
private PropWithType <Property>k__BackingField;
    public PropWithType Property { get; }
    public PropertyInfo PropertyInfo { get; }
    public ExprPropertyInfo(CType type, PropertySymbol propertySymbol, AggregateType propertyType);
    [CompilerGeneratedAttribute]
public PropWithType get_Property();
    public PropertyInfo get_PropertyInfo();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprTypeOf : ExprWithType {
    [CompilerGeneratedAttribute]
private CType <SourceType>k__BackingField;
    public CType SourceType { get; }
    public object Object { get; }
    public ExprTypeOf(CType type, CType sourceType);
    [CompilerGeneratedAttribute]
public CType get_SourceType();
    public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprUnaryOp : ExprOperator {
    [CompilerGeneratedAttribute]
private Expr <Child>k__BackingField;
    public Expr Child { get; public set; }
    public ExprUnaryOp(ExpressionKind kind, CType type, Expr operand);
    public ExprUnaryOp(ExpressionKind kind, CType type, Expr operand, Expr call, MethPropWithInst userMethod);
    [CompilerGeneratedAttribute]
public Expr get_Child();
    [CompilerGeneratedAttribute]
public void set_Child(Expr value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprUserDefinedConversion : Expr {
    private Expr _userDefinedCall;
    [CompilerGeneratedAttribute]
private Expr <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private MethWithInst <UserDefinedCallMethod>k__BackingField;
    public Expr Argument { get; public set; }
    public Expr UserDefinedCall { get; public set; }
    public MethWithInst UserDefinedCallMethod { get; }
    public ExprUserDefinedConversion(Expr argument, Expr call, MethWithInst method);
    [CompilerGeneratedAttribute]
public Expr get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(Expr value);
    public Expr get_UserDefinedCall();
    public void set_UserDefinedCall(Expr value);
    [CompilerGeneratedAttribute]
public MethWithInst get_UserDefinedCallMethod();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprUserLogicalOp : ExprWithType {
    [CompilerGeneratedAttribute]
private Expr <TrueFalseCall>k__BackingField;
    [CompilerGeneratedAttribute]
private ExprCall <OperatorCall>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <FirstOperandToExamine>k__BackingField;
    public Expr TrueFalseCall { get; public set; }
    public ExprCall OperatorCall { get; public set; }
    public Expr FirstOperandToExamine { get; public set; }
    public ExprUserLogicalOp(CType type, Expr trueFalseCall, ExprCall operatorCall);
    [CompilerGeneratedAttribute]
public Expr get_TrueFalseCall();
    [CompilerGeneratedAttribute]
public void set_TrueFalseCall(Expr value);
    [CompilerGeneratedAttribute]
public ExprCall get_OperatorCall();
    [CompilerGeneratedAttribute]
public void set_OperatorCall(ExprCall value);
    [CompilerGeneratedAttribute]
public Expr get_FirstOperandToExamine();
    [CompilerGeneratedAttribute]
public void set_FirstOperandToExamine(Expr value);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprVisitorBase : object {
    protected Expr Visit(Expr pExpr);
    protected virtual Expr Dispatch(Expr pExpr);
    private void VisitChildren(Expr pExpr);
    protected virtual Expr VisitEXPR(Expr pExpr);
    protected virtual Expr VisitBINOP(ExprBinOp pExpr);
    protected virtual Expr VisitLIST(ExprList pExpr);
    protected virtual Expr VisitASSIGNMENT(ExprAssignment pExpr);
    protected virtual Expr VisitARRAYINDEX(ExprArrayIndex pExpr);
    protected virtual Expr VisitUNARYOP(ExprUnaryOp pExpr);
    protected virtual Expr VisitUSERLOGOP(ExprUserLogicalOp pExpr);
    protected virtual Expr VisitTYPEOF(ExprTypeOf pExpr);
    protected virtual Expr VisitCAST(ExprCast pExpr);
    protected virtual Expr VisitUSERDEFINEDCONVERSION(ExprUserDefinedConversion pExpr);
    protected virtual Expr VisitZEROINIT(ExprZeroInit pExpr);
    protected virtual Expr VisitMEMGRP(ExprMemberGroup pExpr);
    protected virtual Expr VisitCALL(ExprCall pExpr);
    protected virtual Expr VisitPROP(ExprProperty pExpr);
    protected virtual Expr VisitFIELD(ExprField pExpr);
    protected virtual Expr VisitLOCAL(ExprLocal pExpr);
    protected virtual Expr VisitCONSTANT(ExprConstant pExpr);
    protected virtual Expr VisitMULTIGET(ExprMultiGet pExpr);
    protected virtual Expr VisitMULTI(ExprMulti pExpr);
    protected virtual Expr VisitWRAP(ExprWrap pExpr);
    protected virtual Expr VisitCONCAT(ExprConcat pExpr);
    protected virtual Expr VisitARRINIT(ExprArrayInit pExpr);
    protected virtual Expr VisitFIELDINFO(ExprFieldInfo pExpr);
    protected virtual Expr VisitMETHODINFO(ExprMethodInfo pExpr);
    protected virtual Expr VisitEQUALS(ExprBinOp pExpr);
    protected virtual Expr VisitCOMPARE(ExprBinOp pExpr);
    protected virtual Expr VisitEQ(ExprBinOp pExpr);
    protected virtual Expr VisitNE(ExprBinOp pExpr);
    protected virtual Expr VisitLE(ExprBinOp pExpr);
    protected virtual Expr VisitGE(ExprBinOp pExpr);
    protected virtual Expr VisitADD(ExprBinOp pExpr);
    protected virtual Expr VisitSUB(ExprBinOp pExpr);
    protected virtual Expr VisitDIV(ExprBinOp pExpr);
    protected virtual Expr VisitBITAND(ExprBinOp pExpr);
    protected virtual Expr VisitBITOR(ExprBinOp pExpr);
    protected virtual Expr VisitLSHIFT(ExprBinOp pExpr);
    protected virtual Expr VisitLOGAND(ExprBinOp pExpr);
    protected virtual Expr VisitSEQUENCE(ExprBinOp pExpr);
    protected virtual Expr VisitSAVE(ExprBinOp pExpr);
    protected virtual Expr VisitINDIR(ExprBinOp pExpr);
    protected virtual Expr VisitSTRINGEQ(ExprBinOp pExpr);
    protected virtual Expr VisitDELEGATEEQ(ExprBinOp pExpr);
    protected virtual Expr VisitDELEGATEADD(ExprBinOp pExpr);
    protected virtual Expr VisitLT(ExprBinOp pExpr);
    protected virtual Expr VisitMUL(ExprBinOp pExpr);
    protected virtual Expr VisitBITXOR(ExprBinOp pExpr);
    protected virtual Expr VisitRSHIFT(ExprBinOp pExpr);
    protected virtual Expr VisitLOGOR(ExprBinOp pExpr);
    protected virtual Expr VisitSTRINGNE(ExprBinOp pExpr);
    protected virtual Expr VisitDELEGATENE(ExprBinOp pExpr);
    protected virtual Expr VisitGT(ExprBinOp pExpr);
    protected virtual Expr VisitMOD(ExprBinOp pExpr);
    protected virtual Expr VisitSWAP(ExprBinOp pExpr);
    protected virtual Expr VisitDELEGATESUB(ExprBinOp pExpr);
    protected virtual Expr VisitTRUE(ExprUnaryOp pExpr);
    protected virtual Expr VisitINC(ExprUnaryOp pExpr);
    protected virtual Expr VisitLOGNOT(ExprUnaryOp pExpr);
    protected virtual Expr VisitNEG(ExprUnaryOp pExpr);
    protected virtual Expr VisitBITNOT(ExprUnaryOp pExpr);
    protected virtual Expr VisitADDR(ExprUnaryOp pExpr);
    protected virtual Expr VisitDECIMALNEG(ExprUnaryOp pExpr);
    protected virtual Expr VisitDECIMALDEC(ExprUnaryOp pExpr);
    protected virtual Expr VisitFALSE(ExprUnaryOp pExpr);
    protected virtual Expr VisitDEC(ExprUnaryOp pExpr);
    protected virtual Expr VisitUPLUS(ExprUnaryOp pExpr);
    protected virtual Expr VisitDECIMALINC(ExprUnaryOp pExpr);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprWithArgs : ExprWithType {
    [CompilerGeneratedAttribute]
private ExprMemberGroup <MemberGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private Expr <OptionalArguments>k__BackingField;
    public ExprMemberGroup MemberGroup { get; public set; }
    public Expr OptionalArguments { get; public set; }
    protected ExprWithArgs(ExpressionKind kind, CType type);
    [CompilerGeneratedAttribute]
public ExprMemberGroup get_MemberGroup();
    [CompilerGeneratedAttribute]
public void set_MemberGroup(ExprMemberGroup value);
    [CompilerGeneratedAttribute]
public Expr get_OptionalArguments();
    [CompilerGeneratedAttribute]
public void set_OptionalArguments(Expr value);
    public abstract virtual SymWithType GetSymWithType();
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ExprWithType : Expr {
    protected ExprWithType(ExpressionKind kind, CType type);
    protected static bool TypesAreEqual(Type t1, Type t2);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprWrap : Expr {
    [CompilerGeneratedAttribute]
private Expr <OptionalExpression>k__BackingField;
    public Expr OptionalExpression { get; }
    public ExprWrap(Expr expression);
    [CompilerGeneratedAttribute]
public Expr get_OptionalExpression();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprZeroInit : ExprWithType {
    public object Object { get; }
    public ExprZeroInit(CType type);
    public virtual object get_Object();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FieldSymbol : VariableSymbol {
    public bool isStatic;
    public bool isReadOnly;
    public bool isEvent;
    public FieldInfo AssociatedFieldInfo;
    public void SetType(CType pType);
    public CType GetType();
    public AggregateSymbol getClass();
    public EventSymbol getEvent();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FieldWithType : SymWithType {
    public FieldWithType(FieldSymbol field, AggregateType ats);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.FUNDTYPE : Enum {
    public int value__;
    public static FUNDTYPE FT_NONE;
    public static FUNDTYPE FT_I1;
    public static FUNDTYPE FT_I2;
    public static FUNDTYPE FT_I4;
    public static FUNDTYPE FT_U1;
    public static FUNDTYPE FT_U2;
    public static FUNDTYPE FT_U4;
    public static FUNDTYPE FT_LASTNONLONG;
    public static FUNDTYPE FT_I8;
    public static FUNDTYPE FT_U8;
    public static FUNDTYPE FT_LASTINTEGRAL;
    public static FUNDTYPE FT_R4;
    public static FUNDTYPE FT_R8;
    public static FUNDTYPE FT_LASTNUMERIC;
    public static FUNDTYPE FT_REF;
    public static FUNDTYPE FT_STRUCT;
    public static FUNDTYPE FT_PTR;
    public static FUNDTYPE FT_VAR;
    public static FUNDTYPE FT_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.IndexerSymbol : PropertySymbol {
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.LiftFlags : Enum {
    public int value__;
    public static LiftFlags None;
    public static LiftFlags Lift1;
    public static LiftFlags Lift2;
    public static LiftFlags Convert1;
    public static LiftFlags Convert2;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ListExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> list);
    [ExtensionAttribute]
public static T Head(List`1<T> list);
    [ExtensionAttribute]
public static List`1<T> Tail(List`1<T> list);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.LocalVariableSymbol : VariableSymbol {
    public ExprWrap wrap;
    public void SetType(CType pType);
    public CType GetType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MemberLookup : object {
    private CType _typeSrc;
    private CType _typeQual;
    private ParentSymbol _symWhere;
    private Name _name;
    private int _arity;
    private MemLookFlags _flags;
    private List`1<AggregateType> _rgtypeStart;
    private List`1<AggregateType> _prgtype;
    private int _csym;
    private SymWithType _swtFirst;
    private List`1<MethPropWithType> _methPropWithTypeList;
    private SymWithType _swtAmbig;
    private SymWithType _swtInaccess;
    private SymWithType _swtBad;
    private SymWithType _swtBogus;
    private SymWithType _swtBadArity;
    private bool _fMulti;
    private void RecordType(AggregateType type, Symbol sym);
    private bool SearchSingleType(AggregateType typeCur, Boolean& pfHideByName);
    private static bool IsDynamicMember(Symbol sym);
    private bool LookupInClass(AggregateType typeStart, AggregateType& ptypeEnd);
    private bool LookupInInterfaces(AggregateType typeStart, TypeArray types);
    private static RuntimeBinderException ReportBogus(SymWithType swt);
    private static bool IsDelegateType(CType pSrcType, AggregateType pAggType);
    public bool Lookup(CType typeSrc, Expr obj, ParentSymbol symWhere, Name name, int arity, MemLookFlags flags);
    private bool FError();
    public SymWithType SwtFirst();
    public Exception ReportErrors();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MemLookFlags : Enum {
    public UInt32 value__;
    public static MemLookFlags None;
    public static MemLookFlags Ctor;
    public static MemLookFlags NewObj;
    public static MemLookFlags Operator;
    public static MemLookFlags Indexer;
    public static MemLookFlags UserCallable;
    public static MemLookFlags BaseCall;
    public static MemLookFlags MustBeInvocable;
    public static MemLookFlags All;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodCallingConventionEnum : Enum {
    public int value__;
    public static MethodCallingConventionEnum Static;
    public static MethodCallingConventionEnum Virtual;
    public static MethodCallingConventionEnum Instance;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodGroupType : CType {
    public static MethodGroupType Instance;
    private static MethodGroupType();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodKindEnum : Enum {
    public int value__;
    public static MethodKindEnum None;
    public static MethodKindEnum Constructor;
    public static MethodKindEnum Destructor;
    public static MethodKindEnum PropAccessor;
    public static MethodKindEnum EventAccessor;
    public static MethodKindEnum ExplicitConv;
    public static MethodKindEnum ImplicitConv;
    public static MethodKindEnum Anonymous;
    public static MethodKindEnum Invoke;
    public static MethodKindEnum BeginInvoke;
    public static MethodKindEnum EndInvoke;
    public static MethodKindEnum AnonymousTypeToString;
    public static MethodKindEnum AnonymousTypeEquals;
    public static MethodKindEnum AnonymousTypeGetHashCode;
    public static MethodKindEnum IteratorDispose;
    public static MethodKindEnum IteratorReset;
    public static MethodKindEnum IteratorGetEnumerator;
    public static MethodKindEnum IteratorGetEnumeratorDelegating;
    public static MethodKindEnum IteratorMoveNext;
    public static MethodKindEnum Latent;
    public static MethodKindEnum Actual;
    public static MethodKindEnum IteratorFinally;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.MethodOrPropertySymbol : ParentSymbol {
    public UInt32 modOptCount;
    public bool isStatic;
    public bool isOverride;
    public bool isOperator;
    public bool isParamArray;
    public bool isHideByName;
    [CompilerGeneratedAttribute]
private List`1<Name> <ParameterNames>k__BackingField;
    private Boolean[] _optionalParameterIndex;
    private Boolean[] _defaultParameterIndex;
    private ConstVal[] _defaultParameters;
    private CType[] _defaultParameterConstValTypes;
    private Boolean[] _marshalAsIndex;
    private UnmanagedType[] _marshalAsBuffer;
    public SymWithType swtSlot;
    public CType RetType;
    private TypeArray _Params;
    public List`1<Name> ParameterNames { get; private set; }
    public TypeArray Params { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Name> get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(List`1<Name> value);
    public TypeArray get_Params();
    public void set_Params(TypeArray value);
    public bool IsParameterOptional(int index);
    public void SetOptionalParameter(int index);
    public bool HasOptionalParameters();
    public bool HasDefaultParameterValue(int index);
    public void SetDefaultParameterValue(int index, CType type, ConstVal cv);
    public ConstVal GetDefaultParameterValue(int index);
    public CType GetDefaultParameterValueConstValType(int index);
    private bool IsMarshalAsParameter(int index);
    public void SetMarshalAsParameter(int index, UnmanagedType umt);
    private UnmanagedType GetMarshalAsParameterValue(int index);
    public bool MarshalAsObject(int index);
    public AggregateSymbol getClass();
    public bool IsExpImpl();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodSignatureEnum : Enum {
    public int value__;
    public static MethodSignatureEnum SIG_CLASS_TYVAR;
    public static MethodSignatureEnum SIG_METH_TYVAR;
    public static MethodSignatureEnum SIG_SZ_ARRAY;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodSymbol : MethodOrPropertySymbol {
    private MethodKindEnum _methKind;
    private bool _inferenceMustFail;
    private bool _checkedInfMustFail;
    private MethodSymbol _convNext;
    private PropertySymbol _prop;
    private EventSymbol _evt;
    public bool isVirtual;
    public MemberInfo AssociatedMemberInfo;
    public TypeArray typeVars;
    public MethodKindEnum MethKind { get; }
    public bool InferenceMustFail();
    public MethodKindEnum get_MethKind();
    public bool IsConstructor();
    public bool IsNullableConstructor();
    public bool isPropertyAccessor();
    public bool isEventAccessor();
    public bool isImplicit();
    public void SetMethKind(MethodKindEnum mk);
    public MethodSymbol ConvNext();
    public void SetConvNext(MethodSymbol conv);
    public PropertySymbol getProperty();
    public void SetProperty(PropertySymbol prop);
    public EventSymbol getEvent();
    public void SetEvent(EventSymbol evt);
    [ConditionalAttribute("DEBUG")]
private void AssertIsConversionOperator();
    public bool isUserCallable();
    private bool isAnyAccessor();
    public bool isSetAccessor();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodTypeInferrer : object {
    private ExpressionBinder _binder;
    private TypeArray _pMethodTypeParameters;
    private TypeArray _pMethodFormalParameterTypes;
    private ArgInfos _pMethodArguments;
    private List`1[] _pExactBounds;
    private List`1[] _pUpperBounds;
    private List`1[] _pLowerBounds;
    private CType[] _pFixedResults;
    private Dependency[][] _ppDependencies;
    private bool _dependenciesDirty;
    private MethodTypeInferrer(ExpressionBinder exprBinder, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments, TypeArray pMethodTypeParameters);
    public static bool Infer(ExpressionBinder binder, MethodSymbol pMethod, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments, TypeArray& ppInferredTypeArguments);
    private TypeArray GetResults();
    private bool IsUnfixed(int iParam);
    private bool IsUnfixed(TypeParameterType pParam);
    private bool AllFixed();
    private void AddLowerBound(TypeParameterType pParam, CType pBound);
    private void AddUpperBound(TypeParameterType pParam, CType pBound);
    private void AddExactBound(TypeParameterType pParam, CType pBound);
    private bool HasBound(int iParam);
    private bool InferTypeArgs();
    private static bool IsReallyAType(CType pType);
    private void InferTypeArgsFirstPhase();
    private bool InferTypeArgsSecondPhase();
    private NewInferenceResult DoSecondPhase();
    private NewInferenceResult FixNondependentParameters();
    private NewInferenceResult FixDependentParameters();
    private void InitializeDependencies();
    private bool DependsOn(int iParam, int jParam);
    private bool DependsTransitivelyOn(int iParam, int jParam);
    private void DeduceAllDependencies();
    private bool DeduceDependencies();
    private void SetUnknownsToNotDependent();
    private void SetIndirectsToUnknown();
    private void UpdateDependenciesAfterFix(int iParam);
    private bool DependsOnAny(int iParam);
    private bool AnyDependsOn(int iParam);
    private void ExactInference(CType pSource, CType pDest);
    private bool ExactTypeParameterInference(CType pSource, CType pDest);
    private bool ExactArrayInference(CType pSource, CType pDest);
    private bool ExactNullableInference(CType pSource, CType pDest);
    private bool ExactConstructedInference(CType pSource, CType pDest);
    private void ExactTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    private void LowerBoundInference(CType pSource, CType pDest);
    private bool LowerBoundTypeParameterInference(CType pSource, CType pDest);
    private bool LowerBoundArrayInference(CType pSource, CType pDest);
    private bool LowerBoundConstructedInference(CType pSource, CType pDest);
    private bool LowerBoundClassInference(CType pSource, AggregateType pDest);
    private bool LowerBoundInterfaceInference(CType pSource, AggregateType pDest);
    private void LowerBoundTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    private void UpperBoundInference(CType pSource, CType pDest);
    private bool UpperBoundTypeParameterInference(CType pSource, CType pDest);
    private bool UpperBoundArrayInference(CType pSource, CType pDest);
    private bool UpperBoundConstructedInference(CType pSource, CType pDest);
    private bool UpperBoundClassInference(AggregateType pSource, CType pDest);
    private bool UpperBoundInterfaceInference(AggregateType pSource, CType pDest);
    private void UpperBoundTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    private bool Fix(int iParam);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethPropWithInst : MethPropWithType {
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgs>k__BackingField;
    public TypeArray TypeArgs { get; private set; }
    public MethPropWithInst(MethodOrPropertySymbol mps, AggregateType ats);
    public MethPropWithInst(MethodOrPropertySymbol mps, AggregateType ats, TypeArray typeArgs);
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgs();
    [CompilerGeneratedAttribute]
private void set_TypeArgs(TypeArray value);
    public virtual void Clear();
    public void Set(MethodOrPropertySymbol mps, AggregateType ats, TypeArray typeArgs);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethPropWithType : SymWithType {
    public MethPropWithType(MethodOrPropertySymbol mps, AggregateType ats);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethWithInst : MethPropWithInst {
    public MethWithInst(MethodSymbol meth, AggregateType ats);
    public MethWithInst(MethodSymbol meth, AggregateType ats, TypeArray typeArgs);
    public MethWithInst(MethPropWithInst mpwi);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethWithType : MethPropWithType {
    public MethWithType(MethodSymbol meth, AggregateType ats);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceOrAggregateSymbol : ParentSymbol {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceSymbol : NamespaceOrAggregateSymbol {
    public static NamespaceSymbol Root;
    private static NamespaceSymbol();
    private static NamespaceSymbol GetRootNamespaceSymbol();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.NullableCallLiftKind : Enum {
    public int value__;
    public static NullableCallLiftKind NotLifted;
    public static NullableCallLiftKind Operator;
    public static NullableCallLiftKind EqualityOperator;
    public static NullableCallLiftKind InequalityOperator;
    public static NullableCallLiftKind UserDefinedConversion;
    public static NullableCallLiftKind NullableConversion;
    public static NullableCallLiftKind NullableConversionConstructor;
    public static NullableCallLiftKind NullableIntermediateConversion;
    public static NullableCallLiftKind NotLiftedIntermediateConversion;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NullableType : CType {
    private AggregateType _ats;
    [CompilerGeneratedAttribute]
private CType <UnderlyingType>k__BackingField;
    public CType UnderlyingType { get; }
    public bool IsValueType { get; }
    public bool IsStructOrEnum { get; }
    public bool IsStructType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    [ExcludeFromCodeCoverageAttribute]
public ConstValKind ConstValKind { get; }
    public NullableType(CType underlyingType);
    public virtual AggregateType GetAts();
    public virtual CType StripNubs();
    public virtual CType StripNubs(Boolean& wasNullable);
    [CompilerGeneratedAttribute]
public CType get_UnderlyingType();
    public virtual bool get_IsValueType();
    public virtual bool get_IsStructOrEnum();
    public virtual bool get_IsStructType();
    public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NullType : CType {
    public static NullType Instance;
    public bool IsReferenceType { get; }
    public FUNDTYPE FundamentalType { get; }
    public ConstValKind ConstValKind { get; }
    private static NullType();
    public virtual bool get_IsReferenceType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.Operators : object {
    private static OperatorInfo[] s_operatorInfos;
    private static Dictionary`2<Name, string> s_operatorsByName;
    private static Operators();
    private static Dictionary`2<Name, string> GetOperatorByName();
    private static OperatorInfo GetInfo(OperatorKind op);
    public static string OperatorOfMethodName(Name name);
    public static string GetDisplayName(OperatorKind op);
    public static ExpressionKind GetExpressionKind(OperatorKind op);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.OpSigFlags : Enum {
    public int value__;
    public static OpSigFlags None;
    public static OpSigFlags Convert;
    public static OpSigFlags CanLift;
    public static OpSigFlags AutoLift;
    public static OpSigFlags Value;
    public static OpSigFlags Reference;
    public static OpSigFlags BoolBit;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ParameterModifierType : CType {
    [CompilerGeneratedAttribute]
private bool <IsOut>k__BackingField;
    [CompilerGeneratedAttribute]
private CType <ParameterType>k__BackingField;
    public bool IsOut { get; }
    public CType ParameterType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public ParameterModifierType(CType parameterType, bool isOut);
    [CompilerGeneratedAttribute]
public bool get_IsOut();
    [CompilerGeneratedAttribute]
public CType get_ParameterType();
    public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.ParentSymbol : Symbol {
    public Symbol firstChild;
    private Symbol _lastChild;
    public void AddToChildList(Symbol sym);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PointerType : CType {
    [CompilerGeneratedAttribute]
private CType <ReferentType>k__BackingField;
    public CType ReferentType { get; }
    public Type AssociatedSystemType { get; }
    public CType BaseOrParameterOrElementType { get; }
    public FUNDTYPE FundamentalType { get; }
    [ExcludeFromCodeCoverageAttribute]
public ConstValKind ConstValKind { get; }
    public PointerType(CType referentType);
    [CompilerGeneratedAttribute]
public CType get_ReferentType();
    public virtual bool IsUnsafe();
    public virtual Type get_AssociatedSystemType();
    public virtual CType get_BaseOrParameterOrElementType();
    public virtual FUNDTYPE get_FundamentalType();
    public virtual ConstValKind get_ConstValKind();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMembers : object {
    private static MethodSymbol[] _methods;
    private static PropertySymbol[] _properties;
    private static PredefinedPropertyInfo[] s_predefinedProperties;
    private static PredefinedMethodInfo[] s_predefinedMethods;
    private static PredefinedMembers();
    private static PropertySymbol LoadProperty(PREDEFPROP property);
    private static PropertySymbol LoadProperty(PREDEFPROP predefProp, Name propertyName, PREDEFMETH propertyGetter);
    private static AggregateSymbol GetPredefAgg(PredefinedType pt);
    private static CType LoadTypeFromSignature(Int32[] signature, Int32& indexIntoSignatures, TypeArray classTyVars);
    private static TypeArray LoadTypeArrayFromSignature(Int32[] signature, Int32& indexIntoSignatures, TypeArray classTyVars);
    public static PropertySymbol GetProperty(PREDEFPROP property);
    public static MethodSymbol GetMethod(PREDEFMETH method);
    private static MethodSymbol LoadMethod(AggregateSymbol type, Int32[] signature, int cMethodTyVars, Name methodName, ACCESS methodAccess, bool isStatic, bool isVirtual);
    private static MethodSymbol LookupMethodWhileLoading(AggregateSymbol type, int cMethodTyVars, Name methodName, ACCESS methodAccess, bool isStatic, bool isVirtual, CType returnType, TypeArray argumentTypes);
    private static MethodSymbol LoadMethod(PREDEFMETH method);
    private static PREDEFMETH GetPropGetter(PREDEFPROP property);
    private static PredefinedType GetPropPredefType(PREDEFPROP property);
    private static PredefinedPropertyInfo GetPropInfo(PREDEFPROP property);
    private static PredefinedMethodInfo GetMethInfo(PREDEFMETH method);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMethodInfo : object {
    public PREDEFMETH method;
    public PredefinedType type;
    public PredefinedName name;
    public MethodCallingConventionEnum callingConvention;
    public ACCESS access;
    public int cTypeVars;
    public Int32[] signature;
    public PredefinedMethodInfo(PREDEFMETH method, PredefinedType type, PredefinedName name, MethodCallingConventionEnum callingConvention, ACCESS access, int cTypeVars, Int32[] signature);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedPropertyInfo : object {
    public PREDEFPROP property;
    public PredefinedName name;
    public PREDEFMETH getter;
    public PredefinedPropertyInfo(PREDEFPROP property, PredefinedName name, PREDEFMETH getter);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedTypeFacts : object {
    private static PredefinedTypeInfo[] s_types;
    private static Dictionary`2<string, PredefinedType> s_typesByName;
    private static PredefinedTypeFacts();
    internal static FUNDTYPE GetFundType(PredefinedType type);
    internal static Type GetAssociatedSystemType(PredefinedType type);
    internal static bool IsSimpleType(PredefinedType type);
    internal static bool IsNumericType(PredefinedType type);
    internal static string GetNiceName(PredefinedType type);
    public static PredefinedType TryGetPredefTypeIndex(string name);
    private static Dictionary`2<string, PredefinedType> CreatePredefinedTypeFacts();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedTypes : object {
    private static AggregateSymbol[] s_predefSymbols;
    private static PredefinedTypes();
    private static AggregateSymbol DelayLoadPredefSym(PredefinedType pt);
    internal static AggregateSymbol InitializePredefinedType(AggregateSymbol sym, PredefinedType pt);
    public static AggregateSymbol GetPredefinedAggregate(PredefinedType pt);
    private static string GetNiceName(PredefinedType pt);
    public static string GetNiceName(AggregateSymbol type);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFMETH : Enum {
    public int value__;
    public static PREDEFMETH PM_DECIMAL_OPDECREMENT;
    public static PREDEFMETH PM_DECIMAL_OPINCREMENT;
    public static PREDEFMETH PM_DECIMAL_OPUNARYMINUS;
    public static PREDEFMETH PM_DELEGATE_COMBINE;
    public static PREDEFMETH PM_DELEGATE_OPEQUALITY;
    public static PREDEFMETH PM_DELEGATE_OPINEQUALITY;
    public static PREDEFMETH PM_DELEGATE_REMOVE;
    public static PREDEFMETH PM_EXPRESSION_ADD;
    public static PREDEFMETH PM_EXPRESSION_ADD_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ADDCHECKED;
    public static PREDEFMETH PM_EXPRESSION_ADDCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_AND;
    public static PREDEFMETH PM_EXPRESSION_AND_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ANDALSO;
    public static PREDEFMETH PM_EXPRESSION_ANDALSO_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ARRAYINDEX;
    public static PREDEFMETH PM_EXPRESSION_ARRAYINDEX2;
    public static PREDEFMETH PM_EXPRESSION_ASSIGN;
    public static PREDEFMETH PM_EXPRESSION_CONSTANT_OBJECT_TYPE;
    public static PREDEFMETH PM_EXPRESSION_CONVERT;
    public static PREDEFMETH PM_EXPRESSION_CONVERT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_CONVERTCHECKED;
    public static PREDEFMETH PM_EXPRESSION_CONVERTCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_DIVIDE;
    public static PREDEFMETH PM_EXPRESSION_DIVIDE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_EQUAL;
    public static PREDEFMETH PM_EXPRESSION_EQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_EXCLUSIVEOR;
    public static PREDEFMETH PM_EXPRESSION_EXCLUSIVEOR_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_FIELD;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHAN;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHAN_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHANOREQUAL;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHANOREQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LAMBDA;
    public static PREDEFMETH PM_EXPRESSION_LEFTSHIFT;
    public static PREDEFMETH PM_EXPRESSION_LEFTSHIFT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LESSTHAN;
    public static PREDEFMETH PM_EXPRESSION_LESSTHAN_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LESSTHANOREQUAL;
    public static PREDEFMETH PM_EXPRESSION_LESSTHANOREQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MODULO;
    public static PREDEFMETH PM_EXPRESSION_MODULO_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLY;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLY_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLYCHECKED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLYCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NOTEQUAL;
    public static PREDEFMETH PM_EXPRESSION_NOTEQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_OR;
    public static PREDEFMETH PM_EXPRESSION_OR_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ORELSE;
    public static PREDEFMETH PM_EXPRESSION_ORELSE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_PARAMETER;
    public static PREDEFMETH PM_EXPRESSION_RIGHTSHIFT;
    public static PREDEFMETH PM_EXPRESSION_RIGHTSHIFT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACT;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACTCHECKED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACTCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_UNARYPLUS_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEGATE;
    public static PREDEFMETH PM_EXPRESSION_NEGATE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEGATECHECKED;
    public static PREDEFMETH PM_EXPRESSION_NEGATECHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_CALL;
    public static PREDEFMETH PM_EXPRESSION_NEW;
    public static PREDEFMETH PM_EXPRESSION_NEW_TYPE;
    public static PREDEFMETH PM_EXPRESSION_QUOTE;
    public static PREDEFMETH PM_EXPRESSION_NOT;
    public static PREDEFMETH PM_EXPRESSION_NOT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEWARRAYINIT;
    public static PREDEFMETH PM_EXPRESSION_PROPERTY;
    public static PREDEFMETH PM_EXPRESSION_INVOKE;
    public static PREDEFMETH PM_G_OPTIONAL_CTOR;
    public static PREDEFMETH PM_G_OPTIONAL_GETVALUE;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_2;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_3;
    public static PREDEFMETH PM_STRING_CONCAT_STRING_2;
    public static PREDEFMETH PM_STRING_OPEQUALITY;
    public static PREDEFMETH PM_STRING_OPINEQUALITY;
    public static PREDEFMETH PM_COUNT;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFPROP : Enum {
    public int value__;
    public static PREDEFPROP PP_G_OPTIONAL_VALUE;
    public static PREDEFPROP PP_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PropertySymbol : MethodOrPropertySymbol {
    [CompilerGeneratedAttribute]
private MethodSymbol <GetterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <SetterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <AssociatedPropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Bogus>k__BackingField;
    public MethodSymbol GetterMethod { get; public set; }
    public MethodSymbol SetterMethod { get; public set; }
    public PropertyInfo AssociatedPropertyInfo { get; public set; }
    public bool Bogus { get; public set; }
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetterMethod();
    [CompilerGeneratedAttribute]
public void set_GetterMethod(MethodSymbol value);
    [CompilerGeneratedAttribute]
public MethodSymbol get_SetterMethod();
    [CompilerGeneratedAttribute]
public void set_SetterMethod(MethodSymbol value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_AssociatedPropertyInfo();
    [CompilerGeneratedAttribute]
public void set_AssociatedPropertyInfo(PropertyInfo value);
    [CompilerGeneratedAttribute]
public bool get_Bogus();
    [CompilerGeneratedAttribute]
public void set_Bogus(bool value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PropWithType : MethPropWithType {
    public PropWithType(PropertySymbol prop, AggregateType ats);
    public PropWithType(SymWithType swt);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.Scope : ParentSymbol {
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SpecCons : Enum {
    public int value__;
    public static SpecCons None;
    public static SpecCons New;
    public static SpecCons Ref;
    public static SpecCons Val;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SubstContext : object {
    public CType[] ClassTypes;
    public CType[] MethodTypes;
    public bool DenormMeth;
    public bool IsNop { get; }
    public SubstContext(TypeArray typeArgsCls, TypeArray typeArgsMeth, bool denormMeth);
    public SubstContext(AggregateType type);
    public SubstContext(AggregateType type, TypeArray typeArgsMeth);
    private SubstContext(AggregateType type, TypeArray typeArgsMeth, bool denormMeth);
    public bool get_IsNop();
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.symbmask_t : Enum {
    public long value__;
    public static symbmask_t MASK_NamespaceSymbol;
    public static symbmask_t MASK_AggregateSymbol;
    public static symbmask_t MASK_TypeParameterSymbol;
    public static symbmask_t MASK_FieldSymbol;
    public static symbmask_t MASK_MethodSymbol;
    public static symbmask_t MASK_PropertySymbol;
    public static symbmask_t MASK_EventSymbol;
    public static symbmask_t MASK_ALL;
    public static symbmask_t MASK_Member;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.Symbol : object {
    private SYMKIND _kind;
    private ACCESS _access;
    public Name name;
    public ParentSymbol parent;
    public Symbol nextChild;
    public Symbol nextSameName;
    public bool isStatic { get; }
    public Symbol LookupNext(symbmask_t kindmask);
    public ACCESS GetAccess();
    public void SetAccess(ACCESS access);
    public SYMKIND getKind();
    public void setKind(SYMKIND kind);
    public symbmask_t mask();
    public CType getType();
    public bool get_isStatic();
    private Assembly GetAssembly();
    private bool InternalsVisibleTo(Assembly assembly);
    public bool SameAssemOrFriend(Symbol sym);
    public bool IsOverride();
    public bool IsHideByName();
    public bool isUserCallable();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymbolLoader : object {
    public static AggregateSymbol GetPredefAgg(PredefinedType pt);
    public static AggregateType GetPredefindType(PredefinedType pt);
    public static Symbol LookupAggMember(Name name, AggregateSymbol agg, symbmask_t mask);
    private static bool IsBaseInterface(AggregateType atsDer, AggregateType pBase);
    public static bool IsBaseClassOfClass(CType pDerived, CType pBase);
    private static bool IsBaseClass(CType pDerived, CType pBase);
    private static bool HasCovariantArrayConversion(ArrayType pSource, ArrayType pDest);
    public static bool HasIdentityOrImplicitReferenceConversion(CType pSource, CType pDest);
    private static bool AreTypesEqualForConversion(CType pType1, CType pType2);
    private static bool HasArrayConversionToInterface(ArrayType pSource, CType pDest);
    private static bool HasImplicitReferenceConversion(CType pSource, CType pDest);
    private static bool HasAnyBaseInterfaceConversion(CType pDerived, CType pBase);
    private static bool HasInterfaceConversion(AggregateType pSource, AggregateType pDest);
    private static bool HasDelegateConversion(AggregateType pSource, AggregateType pDest);
    private static bool HasVariantConversion(AggregateType pSource, AggregateType pDest);
    private static bool HasImplicitBoxingConversion(CType pSource, CType pDest);
    public static bool HasBaseConversion(CType pSource, CType pDest);
    public static bool IsBaseAggregate(AggregateSymbol derived, AggregateSymbol base);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymbolStore : object {
    private static Dictionary`2<Key, Symbol> s_dictionary;
    private static SymbolStore();
    public static Symbol LookupSym(Name name, ParentSymbol parent, symbmask_t kindmask);
    public static void InsertChild(ParentSymbol parent, Symbol child);
    private static void InsertChildNoGrow(Symbol child);
    private static Symbol FindCorrectKind(Symbol sym, symbmask_t kindmask);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymFactory : object {
    private static Symbol NewBasicSymbol(SYMKIND kind, Name name, ParentSymbol parent);
    public static NamespaceSymbol CreateNamespace(Name name, NamespaceSymbol parent);
    public static AggregateSymbol CreateAggregate(Name name, NamespaceOrAggregateSymbol parent);
    public static FieldSymbol CreateMemberVar(Name name, AggregateSymbol parent);
    public static LocalVariableSymbol CreateLocalVar(Name name, Scope parent, CType type);
    public static MethodSymbol CreateMethod(Name name, AggregateSymbol parent);
    public static PropertySymbol CreateProperty(Name name, AggregateSymbol parent);
    public static EventSymbol CreateEvent(Name name, AggregateSymbol parent);
    public static TypeParameterSymbol CreateMethodTypeParameter(Name pName, MethodSymbol pParent, int index, int indexTotal);
    public static TypeParameterSymbol CreateClassTypeParameter(Name pName, AggregateSymbol pParent, int index, int indexTotal);
    public static Scope CreateScope();
    public static IndexerSymbol CreateIndexer(Name name, ParentSymbol parent);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SYMKIND : Enum {
    public int value__;
    public static SYMKIND SK_NamespaceSymbol;
    public static SYMKIND SK_AggregateSymbol;
    public static SYMKIND SK_TypeParameterSymbol;
    public static SYMKIND SK_FieldSymbol;
    public static SYMKIND SK_LocalVariableSymbol;
    public static SYMKIND SK_MethodSymbol;
    public static SYMKIND SK_PropertySymbol;
    public static SYMKIND SK_EventSymbol;
    public static SYMKIND SK_Scope;
    public static SYMKIND SK_IndexerSymbol;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SymWithType : object {
    private AggregateType _ats;
    private Symbol _sym;
    public AggregateType Ats { get; }
    public Symbol Sym { get; }
    public SymWithType(Symbol sym, AggregateType ats);
    public virtual void Clear();
    public AggregateType get_Ats();
    public Symbol get_Sym();
    public AggregateType GetType();
    public static bool op_Equality(SymWithType swt1, SymWithType swt2);
    public static bool op_Inequality(SymWithType swt1, SymWithType swt2);
    [ExcludeFromCodeCoverageAttribute]
public virtual bool Equals(object obj);
    [ExcludeFromCodeCoverageAttribute]
public virtual int GetHashCode();
    public static bool op_Implicit(SymWithType swt);
    public MethodOrPropertySymbol MethProp();
    public MethodSymbol Meth();
    public PropertySymbol Prop();
    public FieldSymbol Field();
    public EventSymbol Event();
    public void Set(Symbol sym, AggregateType ats);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeArray : object {
    private static Dictionary`2<TypeArrayKey, TypeArray> s_tableTypeArrays;
    public static TypeArray Empty;
    [CompilerGeneratedAttribute]
private CType[] <Items>k__BackingField;
    public int Count { get; }
    public CType[] Items { get; }
    public CType Item { get; }
    private TypeArray(CType[] types);
    private static TypeArray();
    public int get_Count();
    [CompilerGeneratedAttribute]
public CType[] get_Items();
    public CType get_Item(int i);
    [ConditionalAttribute("DEBUG")]
public void AssertValid();
    public void CopyItems(int i, int c, CType[] dest);
    public static TypeArray Allocate(int ctype, TypeArray array, int offset);
    public static TypeArray Allocate(CType[] types);
    public static TypeArray Concat(TypeArray pta1, TypeArray pta2);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeBind : object {
    public static bool CheckConstraints(CType type, CheckConstraintsFlags flags);
    public static void CheckMethConstraints(MethWithInst mwi);
    private static bool CheckConstraintsCore(Symbol symErr, TypeArray typeVars, TypeArray typeArgs, TypeArray typeArgsCls, TypeArray typeArgsMeth, CheckConstraintsFlags flags);
    private static bool CheckSingleConstraint(Symbol symErr, TypeParameterType var, CType arg, TypeArray typeArgsCls, TypeArray typeArgsMeth, CheckConstraintsFlags flags);
    private static bool SatisfiesBound(CType arg, CType typeBnd);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.TypeKind : Enum {
    public int value__;
    public static TypeKind TK_AggregateType;
    public static TypeKind TK_VoidType;
    public static TypeKind TK_NullType;
    public static TypeKind TK_MethodGroupType;
    public static TypeKind TK_ArgumentListType;
    public static TypeKind TK_ArrayType;
    public static TypeKind TK_PointerType;
    public static TypeKind TK_ParameterModifierType;
    public static TypeKind TK_NullableType;
    public static TypeKind TK_TypeParameterType;
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeManager : object {
    private static Dictionary`2<ValueTuple`2<Assembly, Assembly>, bool> s_internalsVisibleToCache;
    private static StdTypeVarColl s_stvcMethod;
    private static TypeManager();
    public static ArrayType GetArray(CType elementType, int args, bool isSZArray);
    public static AggregateType GetAggregate(AggregateSymbol agg, AggregateType atsOuter, TypeArray typeArgs);
    public static AggregateType GetAggregate(AggregateSymbol agg, TypeArray typeArgsAll);
    public static PointerType GetPointer(CType baseType);
    public static NullableType GetNullable(CType pUnderlyingType);
    public static ParameterModifierType GetParameterModifier(CType paramType, bool isOut);
    public static AggregateSymbol GetNullable();
    private static CType SubstType(CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, bool denormMeth);
    public static AggregateType SubstType(AggregateType typeSrc, TypeArray typeArgsCls);
    private static CType SubstType(CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, SubstContext ctx);
    public static TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls);
    private static AggregateType SubstTypeCore(AggregateType type, SubstContext ctx);
    private static CType SubstTypeCore(CType type, SubstContext pctx);
    public static bool SubstEqualTypes(CType typeDst, CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, bool denormMeth);
    public static bool SubstEqualTypeArrays(TypeArray taDst, TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    private static bool SubstEqualTypesCore(CType typeDst, CType typeSrc, SubstContext pctx);
    public static bool TypeContainsType(CType type, CType typeFind);
    public static bool TypeContainsTyVars(CType type, TypeArray typeVars);
    public static AggregateSymbol GetPredefAgg(PredefinedType pt);
    public static AggregateType SubstType(AggregateType typeSrc, SubstContext ctx);
    public static CType SubstType(CType typeSrc, SubstContext pctx);
    public static CType SubstType(CType typeSrc, AggregateType atsCls);
    public static CType SubstType(CType typeSrc, AggregateType atsCls, TypeArray typeArgsMeth);
    public static CType SubstType(CType typeSrc, CType typeCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, AggregateType atsCls, TypeArray typeArgsMeth);
    public static TypeArray SubstTypeArray(TypeArray taSrc, AggregateType atsCls);
    private static bool SubstEqualTypes(CType typeDst, CType typeSrc, CType typeCls, TypeArray typeArgsMeth);
    public static bool SubstEqualTypes(CType typeDst, CType typeSrc, CType typeCls);
    public static TypeParameterType GetStdMethTypeVar(int iv);
    public static TypeParameterType GetTypeParameter(TypeParameterSymbol pSymbol);
    internal static CType GetBestAccessibleType(AggregateSymbol context, CType typeSrc);
    private static bool TryVarianceAdjustmentToGetAccessibleType(AggregateSymbol context, AggregateType typeSrc, CType& typeDst);
    private static bool TryArrayVarianceAdjustmentToGetAccessibleType(AggregateSymbol context, ArrayType typeSrc, CType& typeDst);
    internal static bool InternalsVisibleTo(Assembly assemblyThatDefinesAttribute, Assembly assemblyToCheck);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeParameterSymbol : Symbol {
    private bool _bIsMethodTypeParameter;
    private SpecCons _constraints;
    private TypeParameterType _pTypeParameterType;
    private int _nIndexInOwnParameters;
    private int _nIndexInTotalParameters;
    private TypeArray _pBounds;
    public bool Covariant;
    public bool Contravariant;
    public bool Invariant { get; }
    public bool get_Invariant();
    public void SetTypeParameterType(TypeParameterType pType);
    public TypeParameterType GetTypeParameterType();
    public bool IsMethodTypeParameter();
    public void SetIsMethodTypeParameter(bool b);
    public int GetIndexInOwnParameters();
    public void SetIndexInOwnParameters(int index);
    public int GetIndexInTotalParameters();
    public void SetIndexInTotalParameters(int index);
    public void SetBounds(TypeArray pBounds);
    public TypeArray GetBounds();
    public void SetConstraints(SpecCons constraints);
    public bool IsValueType();
    public bool IsReferenceType();
    public bool IsNonNullableValueType();
    public bool HasNewConstraint();
    public bool HasRefConstraint();
    public bool HasValConstraint();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeParameterType : CType {
    [CompilerGeneratedAttribute]
private TypeParameterSymbol <Symbol>k__BackingField;
    public TypeParameterSymbol Symbol { get; }
    public ParentSymbol OwningSymbol { get; }
    public Name Name { get; }
    public bool Covariant { get; }
    public bool Invariant { get; }
    public bool Contravariant { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsNonNullableValueType { get; }
    public bool HasNewConstraint { get; }
    public bool HasRefConstraint { get; }
    public bool HasValConstraint { get; }
    public bool IsMethodTypeParameter { get; }
    public int IndexInOwnParameters { get; }
    public int IndexInTotalParameters { get; }
    public TypeArray Bounds { get; }
    public Type AssociatedSystemType { get; }
    public FUNDTYPE FundamentalType { get; }
    public TypeParameterType(TypeParameterSymbol symbol);
    [CompilerGeneratedAttribute]
public TypeParameterSymbol get_Symbol();
    public ParentSymbol get_OwningSymbol();
    public Name get_Name();
    public bool get_Covariant();
    public bool get_Invariant();
    public bool get_Contravariant();
    public virtual bool get_IsValueType();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsNonNullableValueType();
    public bool get_HasNewConstraint();
    public bool get_HasRefConstraint();
    public bool get_HasValConstraint();
    public bool get_IsMethodTypeParameter();
    public int get_IndexInOwnParameters();
    public int get_IndexInTotalParameters();
    public TypeArray get_Bounds();
    public virtual Type get_AssociatedSystemType();
    public virtual FUNDTYPE get_FundamentalType();
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeTable : object {
    private static Dictionary`2<KeyPair`2<AggregateSymbol, KeyPair`2<AggregateType, TypeArray>>, AggregateType> s_aggregateTable;
    private static Dictionary`2<KeyPair`2<CType, int>, ArrayType> s_arrayTable;
    private static Dictionary`2<KeyPair`2<CType, bool>, ParameterModifierType> s_parameterModifierTable;
    private static Dictionary`2<CType, PointerType> s_pointerTable;
    private static Dictionary`2<CType, NullableType> s_nullableTable;
    private static TypeTable();
    private static KeyPair`2<TKey1, TKey2> MakeKey(TKey1 key1, TKey2 key2);
    public static AggregateType LookupAggregate(AggregateSymbol aggregate, AggregateType outer, TypeArray args);
    public static void InsertAggregate(AggregateSymbol aggregate, AggregateType outer, TypeArray args, AggregateType ats);
    public static ArrayType LookupArray(CType elementType, int rankNum);
    public static void InsertArray(CType elementType, int rankNum, ArrayType pArray);
    public static ParameterModifierType LookupParameterModifier(CType elementType, bool isOut);
    public static void InsertParameterModifier(CType elementType, bool isOut, ParameterModifierType parameterModifier);
    public static PointerType LookupPointer(CType elementType);
    public static void InsertPointer(CType elementType, PointerType pointer);
    public static NullableType LookupNullable(CType underlyingType);
    public static void InsertNullable(CType underlyingType, NullableType nullable);
}
[IsReadOnlyAttribute]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.UdConvInfo : ValueType {
    public MethWithType Meth;
    public bool SrcImplicit;
    public bool DstImplicit;
    public UdConvInfo(MethWithType mwt, bool srcImplicit, bool dstImplicit);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpFuncKind : Enum {
    public int value__;
    public static UnaOpFuncKind BoolUnaOp;
    public static UnaOpFuncKind DecUnaOp;
    public static UnaOpFuncKind EnumUnaOp;
    public static UnaOpFuncKind IntUnaOp;
    public static UnaOpFuncKind RealUnaOp;
    public static UnaOpFuncKind LiftedIncOpCore;
    public static UnaOpFuncKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpKind : Enum {
    public int value__;
    public static UnaOpKind Plus;
    public static UnaOpKind Minus;
    public static UnaOpKind Tilde;
    public static UnaOpKind Bang;
    public static UnaOpKind IncDec;
    public static UnaOpKind Lim;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpMask : Enum {
    public int value__;
    public static UnaOpMask None;
    public static UnaOpMask Plus;
    public static UnaOpMask Minus;
    public static UnaOpMask Tilde;
    public static UnaOpMask Bang;
    public static UnaOpMask IncDec;
    public static UnaOpMask Signed;
    public static UnaOpMask Unsigned;
    public static UnaOpMask Real;
    public static UnaOpMask Bool;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaryOperatorSignatureFindResult : Enum {
    public int value__;
    public static UnaryOperatorSignatureFindResult Match;
    public static UnaryOperatorSignatureFindResult Continue;
    public static UnaryOperatorSignatureFindResult Return;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.VariableSymbol : Symbol {
    protected CType type;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.VoidType : CType {
    public static VoidType Instance;
    private static VoidType();
    public virtual bool IsPredefType(PredefinedType pt);
}
internal static class Microsoft.CSharp.RuntimeBinder.SpecialNames : object {
    public static string ImplicitConversion;
    public static string ExplicitConversion;
    public static string Invoke;
    public static string Constructor;
    public static string Indexer;
    public static string CLR_Add;
    public static string CLR_Subtract;
    public static string CLR_Multiply;
    public static string CLR_Division;
    public static string CLR_Modulus;
    public static string CLR_LShift;
    public static string CLR_RShift;
    public static string CLR_LT;
    public static string CLR_GT;
    public static string CLR_LTE;
    public static string CLR_GTE;
    public static string CLR_Equality;
    public static string CLR_Inequality;
    public static string CLR_BitwiseAnd;
    public static string CLR_ExclusiveOr;
    public static string CLR_BitwiseOr;
    public static string CLR_LogicalNot;
    public static string CLR_InPlaceAdd;
    public static string CLR_InPlaceSubtract;
    public static string CLR_InPlaceMultiply;
    public static string CLR_InPlaceDivide;
    public static string CLR_InPlaceModulus;
    public static string CLR_InPlaceBitwiseAnd;
    public static string CLR_InPlaceExclusiveOr;
    public static string CLR_InPlaceBitwiseOr;
    public static string CLR_InPlaceLShift;
    public static string CLR_InPlaceRShift;
    public static string CLR_UnaryNegation;
    public static string CLR_UnaryPlus;
    public static string CLR_OnesComplement;
    public static string CLR_True;
    public static string CLR_False;
    public static string CLR_Increment;
    public static string CLR_Decrement;
}
internal static class Microsoft.CSharp.RuntimeBinder.SymbolTable : object {
    private static HashSet`1<Type> s_typesWithConversionsLoaded;
    private static HashSet`1<NameHashKey> s_namesLoadedForEachType;
    private static Type s_Sentinel;
    private static Type s_EventRegistrationTokenType;
    private static Type s_WindowsRuntimeMarshal;
    private static Type s_EventRegistrationTokenTable;
    internal static Type EventRegistrationTokenType { get; }
    internal static Type WindowsRuntimeMarshalType { get; }
    private static Type EventRegistrationTokenTableType { get; }
    private static SymbolTable();
    internal static void PopulateSymbolTableWithName(string name, IEnumerable`1<Type> typeArguments, Type callingType);
    internal static SymWithType LookupMember(string name, Expr callingObject, ParentSymbol context, int arity, MemberLookup mem, bool allowSpecialNames, bool requireInvocable);
    private static void AddParameterConversions(MethodBase method);
    private static void AddNamesOnType(NameHashKey key);
    private static void AddNamesInInheritanceHierarchy(string name, List`1<Type> inheritance);
    private static List`1<Type> CreateInheritanceHierarchyList(Type type);
    private static Name GetName(string p);
    private static Name GetName(Type type);
    private static TypeArray GetMethodTypeParameters(MethodInfo method, MethodSymbol parent);
    private static TypeArray GetAggregateTypeParameters(Type type, AggregateSymbol agg);
    private static TypeParameterType LoadClassTypeParameter(AggregateSymbol parent, Type t);
    private static bool AreTypeParametersEquivalent(Type t1, Type t2);
    private static Type GetOriginalTypeParameterType(Type t);
    private static TypeParameterType LoadMethodTypeParameter(MethodSymbol parent, Type t);
    private static TypeParameterType AddTypeParameterToSymbolTable(AggregateSymbol agg, MethodSymbol meth, Type t, bool bIsAggregate);
    private static CType LoadSymbolsFromType(Type type);
    private static TypeParameterType ProcessMethodTypeParameter(MethodInfo methinfo, Type t, AggregateSymbol parent);
    private static CType GetConstructedType(Type type, AggregateSymbol agg);
    private static CType ProcessSpecialTypeInChain(NamespaceOrAggregateSymbol parent, Type t);
    private static List`1<object> BuildDeclarationChain(Type callingType);
    private static AggregateSymbol FindSymForType(Symbol sym, Type t);
    private static NamespaceSymbol AddNamespaceToSymbolTable(NamespaceOrAggregateSymbol parent, string sz);
    internal static CType[] GetCTypeArrayFromTypes(Type[] types);
    internal static CType GetCTypeFromType(Type type);
    private static AggregateSymbol AddAggregateToSymbolTable(NamespaceOrAggregateSymbol parent, Type type);
    private static void SetInterfacesOnAggregate(AggregateSymbol aggregate, Type type);
    private static FieldSymbol AddFieldToSymbolTable(FieldInfo fieldInfo, AggregateSymbol aggregate);
    internal static Type get_EventRegistrationTokenType();
    internal static Type get_WindowsRuntimeMarshalType();
    private static Type get_EventRegistrationTokenTableType();
    private static Type GetTypeByName(Type& cachedResult, string name);
    private static void AddEventToSymbolTable(EventInfo eventInfo, AggregateSymbol aggregate, FieldSymbol addedField);
    internal static void AddPredefinedPropertyToSymbolTable(AggregateSymbol type, Name property);
    private static void AddPropertyToSymbolTable(PropertyInfo property, AggregateSymbol aggregate);
    internal static void AddPredefinedMethodToSymbolTable(AggregateSymbol type, Name methodName);
    private static MethodSymbol AddMethodToSymbolTable(MethodBase member, AggregateSymbol callingAggregate, MethodKindEnum kind);
    private static void SetParameterDataForMethProp(MethodOrPropertySymbol methProp, ParameterInfo[] parameters);
    private static void SetParameterAttributes(MethodOrPropertySymbol methProp, ParameterInfo[] parameters, int i);
    private static MethodSymbol FindMatchingMethod(MemberInfo method, AggregateSymbol callingAggregate);
    private static UInt32 GetCountOfModOpts(ParameterInfo[] parameters);
    private static TypeArray CreateParameterArray(MemberInfo associatedInfo, ParameterInfo[] parameters);
    private static CType GetTypeOfParameter(ParameterInfo p, MemberInfo m);
    private static bool DoesMethodHaveParameterArray(ParameterInfo[] parameters);
    private static SymWithType GetSlotForOverride(MethodInfo method);
    private static MethodSymbol FindMethodFromMemberInfo(MemberInfo baseMemberInfo);
    internal static bool AggregateContainsMethod(AggregateSymbol agg, string szName, symbmask_t mask);
    internal static void AddConversionsForType(Type type);
    private static void AddConversionsForOneType(Type type);
    private static bool IsOperator(MethodInfo method);
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.Name : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public Name(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
    public virtual string ToString();
}
internal static class Microsoft.CSharp.RuntimeBinder.Syntax.NameManager : object {
    private static Name[] s_predefinedNames;
    private static NameTable s_names;
    private static NameManager();
    private static NameTable GetKnownNames();
    internal static Name Add(string key);
    internal static Name Add(string key, int length);
    internal static Name GetPredefinedName(PredefinedName id);
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.NameTable : object {
    private Entry[] _entries;
    private int _count;
    private int _mask;
    public Name Add(string key);
    public Name Add(string key, int length);
    internal void Add(Name name);
    private static int ComputeHashCode(string key);
    private static int ComputeHashCode(string key, int length);
    private static bool Equals(string candidate, string key, int length);
    private Name AddEntry(Name name, int hashCode);
    private void Grow();
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.OperatorKind : Enum {
    public UInt32 value__;
    public static OperatorKind OP_NONE;
    public static OperatorKind OP_ASSIGN;
    public static OperatorKind OP_ADDEQ;
    public static OperatorKind OP_SUBEQ;
    public static OperatorKind OP_MULEQ;
    public static OperatorKind OP_DIVEQ;
    public static OperatorKind OP_MODEQ;
    public static OperatorKind OP_ANDEQ;
    public static OperatorKind OP_XOREQ;
    public static OperatorKind OP_OREQ;
    public static OperatorKind OP_LSHIFTEQ;
    public static OperatorKind OP_RSHIFTEQ;
    public static OperatorKind OP_QUESTION;
    public static OperatorKind OP_VALORDEF;
    public static OperatorKind OP_LOGOR;
    public static OperatorKind OP_LOGAND;
    public static OperatorKind OP_BITOR;
    public static OperatorKind OP_BITXOR;
    public static OperatorKind OP_BITAND;
    public static OperatorKind OP_EQ;
    public static OperatorKind OP_NEQ;
    public static OperatorKind OP_LT;
    public static OperatorKind OP_LE;
    public static OperatorKind OP_GT;
    public static OperatorKind OP_GE;
    public static OperatorKind OP_IS;
    public static OperatorKind OP_AS;
    public static OperatorKind OP_LSHIFT;
    public static OperatorKind OP_RSHIFT;
    public static OperatorKind OP_ADD;
    public static OperatorKind OP_SUB;
    public static OperatorKind OP_MUL;
    public static OperatorKind OP_DIV;
    public static OperatorKind OP_MOD;
    public static OperatorKind OP_NOP;
    public static OperatorKind OP_UPLUS;
    public static OperatorKind OP_NEG;
    public static OperatorKind OP_BITNOT;
    public static OperatorKind OP_LOGNOT;
    public static OperatorKind OP_PREINC;
    public static OperatorKind OP_PREDEC;
    public static OperatorKind OP_TYPEOF;
    public static OperatorKind OP_CHECKED;
    public static OperatorKind OP_UNCHECKED;
    public static OperatorKind OP_MAKEREFANY;
    public static OperatorKind OP_REFVALUE;
    public static OperatorKind OP_REFTYPE;
    public static OperatorKind OP_ARGS;
    public static OperatorKind OP_CAST;
    public static OperatorKind OP_INDIR;
    public static OperatorKind OP_ADDR;
    public static OperatorKind OP_COLON;
    public static OperatorKind OP_THIS;
    public static OperatorKind OP_BASE;
    public static OperatorKind OP_NULL;
    public static OperatorKind OP_TRUE;
    public static OperatorKind OP_FALSE;
    public static OperatorKind OP_CALL;
    public static OperatorKind OP_DEREF;
    public static OperatorKind OP_PAREN;
    public static OperatorKind OP_POSTINC;
    public static OperatorKind OP_POSTDEC;
    public static OperatorKind OP_DOT;
    public static OperatorKind OP_IMPLICIT;
    public static OperatorKind OP_EXPLICIT;
    public static OperatorKind OP_EQUALS;
    public static OperatorKind OP_COMPARE;
    public static OperatorKind OP_DEFAULT;
    public static OperatorKind OP_LAST;
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.PredefinedName : Enum {
    public int value__;
    public static PredefinedName PN_CTOR;
    public static PredefinedName PN_DTOR;
    public static PredefinedName PN_STATCTOR;
    public static PredefinedName PN_PTR;
    public static PredefinedName PN_NUB;
    public static PredefinedName PN_OUTPARAM;
    public static PredefinedName PN_REFPARAM;
    public static PredefinedName PN_ARRAY0;
    public static PredefinedName PN_ARRAY1;
    public static PredefinedName PN_ARRAY2;
    public static PredefinedName PN_GARRAY0;
    public static PredefinedName PN_GARRAY1;
    public static PredefinedName PN_GARRAY2;
    public static PredefinedName PN_INVOKE;
    public static PredefinedName PN_LENGTH;
    public static PredefinedName PN_INDEXER;
    public static PredefinedName PN_INDEXERINTERNAL;
    public static PredefinedName PN_COMBINE;
    public static PredefinedName PN_REMOVE;
    public static PredefinedName PN_OPEXPLICITMN;
    public static PredefinedName PN_OPIMPLICITMN;
    public static PredefinedName PN_OPUNARYPLUS;
    public static PredefinedName PN_OPUNARYMINUS;
    public static PredefinedName PN_OPCOMPLEMENT;
    public static PredefinedName PN_OPINCREMENT;
    public static PredefinedName PN_OPDECREMENT;
    public static PredefinedName PN_OPPLUS;
    public static PredefinedName PN_OPMINUS;
    public static PredefinedName PN_OPMULTIPLY;
    public static PredefinedName PN_OPDIVISION;
    public static PredefinedName PN_OPMODULUS;
    public static PredefinedName PN_OPXOR;
    public static PredefinedName PN_OPBITWISEAND;
    public static PredefinedName PN_OPBITWISEOR;
    public static PredefinedName PN_OPLEFTSHIFT;
    public static PredefinedName PN_OPRIGHTSHIFT;
    public static PredefinedName PN_OPEQUALS;
    public static PredefinedName PN_OPCOMPARE;
    public static PredefinedName PN_OPEQUALITY;
    public static PredefinedName PN_OPINEQUALITY;
    public static PredefinedName PN_OPGREATERTHAN;
    public static PredefinedName PN_OPLESSTHAN;
    public static PredefinedName PN_OPGREATERTHANOREQUAL;
    public static PredefinedName PN_OPLESSTHANOREQUAL;
    public static PredefinedName PN_OPTRUE;
    public static PredefinedName PN_OPFALSE;
    public static PredefinedName PN_OPNEGATION;
    public static PredefinedName PN_CONCAT;
    public static PredefinedName PN_ADD;
    public static PredefinedName PN_GETLENGTH;
    public static PredefinedName PN_GETCHARS;
    public static PredefinedName PN_CREATEDELEGATE;
    public static PredefinedName PN_FIXEDELEMENT;
    public static PredefinedName PN_HASVALUE;
    public static PredefinedName PN_GETHASVALUE;
    public static PredefinedName PN_CAP_VALUE;
    public static PredefinedName PN_GETVALUE;
    public static PredefinedName PN_GET_VALUE_OR_DEF;
    public static PredefinedName PN_MISSING;
    public static PredefinedName PN_MISSINGSYM;
    public static PredefinedName PN_LAMBDA;
    public static PredefinedName PN_PARAMETER;
    public static PredefinedName PN_CONSTANT;
    public static PredefinedName PN_CONVERT;
    public static PredefinedName PN_CONVERTCHECKED;
    public static PredefinedName PN_ADDCHECKED;
    public static PredefinedName PN_DIVIDE;
    public static PredefinedName PN_MODULO;
    public static PredefinedName PN_MULTIPLY;
    public static PredefinedName PN_MULTIPLYCHECKED;
    public static PredefinedName PN_SUBTRACT;
    public static PredefinedName PN_SUBTRACTCHECKED;
    public static PredefinedName PN_AND;
    public static PredefinedName PN_OR;
    public static PredefinedName PN_EXCLUSIVEOR;
    public static PredefinedName PN_LEFTSHIFT;
    public static PredefinedName PN_RIGHTSHIFT;
    public static PredefinedName PN_ANDALSO;
    public static PredefinedName PN_ORELSE;
    public static PredefinedName PN_EQUAL;
    public static PredefinedName PN_NOTEQUAL;
    public static PredefinedName PN_GREATERTHANOREQUAL;
    public static PredefinedName PN_GREATERTHAN;
    public static PredefinedName PN_LESSTHAN;
    public static PredefinedName PN_LESSTHANOREQUAL;
    public static PredefinedName PN_ARRAYINDEX;
    public static PredefinedName PN_ASSIGN;
    public static PredefinedName PN_CONDITION;
    public static PredefinedName PN_CAP_FIELD;
    public static PredefinedName PN_CALL;
    public static PredefinedName PN_NEW;
    public static PredefinedName PN_QUOTE;
    public static PredefinedName PN_ARRAYLENGTH;
    public static PredefinedName PN_PLUS;
    public static PredefinedName PN_NEGATE;
    public static PredefinedName PN_NEGATECHECKED;
    public static PredefinedName PN_NOT;
    public static PredefinedName PN_NEWARRAYINIT;
    public static PredefinedName PN_EXPRESSION_PROPERTY;
    public static PredefinedName PN_ADDEVENTHANDLER;
    public static PredefinedName PN_REMOVEEVENTHANDLER;
    public static PredefinedName PN_INVOCATIONLIST;
    public static PredefinedName PN_GETORCREATEEVENTREGISTRATIONTOKENTABLE;
    public static PredefinedName PN_VOID;
    public static PredefinedName PN_EMPTY;
    public static PredefinedName PN_COUNT;
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.PredefinedType : Enum {
    public UInt32 value__;
    public static PredefinedType PT_BYTE;
    public static PredefinedType PT_SHORT;
    public static PredefinedType PT_INT;
    public static PredefinedType PT_LONG;
    public static PredefinedType PT_FLOAT;
    public static PredefinedType PT_DOUBLE;
    public static PredefinedType PT_DECIMAL;
    public static PredefinedType PT_CHAR;
    public static PredefinedType PT_BOOL;
    public static PredefinedType PT_SBYTE;
    public static PredefinedType PT_USHORT;
    public static PredefinedType PT_UINT;
    public static PredefinedType PT_ULONG;
    public static PredefinedType FirstNonSimpleType;
    public static PredefinedType PT_INTPTR;
    public static PredefinedType PT_UINTPTR;
    public static PredefinedType PT_OBJECT;
    public static PredefinedType PT_STRING;
    public static PredefinedType PT_DELEGATE;
    public static PredefinedType PT_MULTIDEL;
    public static PredefinedType PT_ARRAY;
    public static PredefinedType PT_TYPE;
    public static PredefinedType PT_VALUE;
    public static PredefinedType PT_ENUM;
    public static PredefinedType PT_DATETIME;
    public static PredefinedType PT_IENUMERABLE;
    public static PredefinedType PT_G_IENUMERABLE;
    public static PredefinedType PT_G_OPTIONAL;
    public static PredefinedType PT_G_IQUERYABLE;
    public static PredefinedType PT_G_ICOLLECTION;
    public static PredefinedType PT_G_ILIST;
    public static PredefinedType PT_G_EXPRESSION;
    public static PredefinedType PT_EXPRESSION;
    public static PredefinedType PT_BINARYEXPRESSION;
    public static PredefinedType PT_UNARYEXPRESSION;
    public static PredefinedType PT_CONSTANTEXPRESSION;
    public static PredefinedType PT_PARAMETEREXPRESSION;
    public static PredefinedType PT_MEMBEREXPRESSION;
    public static PredefinedType PT_METHODCALLEXPRESSION;
    public static PredefinedType PT_NEWEXPRESSION;
    public static PredefinedType PT_NEWARRAYEXPRESSION;
    public static PredefinedType PT_INVOCATIONEXPRESSION;
    public static PredefinedType PT_FIELDINFO;
    public static PredefinedType PT_METHODINFO;
    public static PredefinedType PT_CONSTRUCTORINFO;
    public static PredefinedType PT_PROPERTYINFO;
    public static PredefinedType PT_MISSING;
    public static PredefinedType PT_G_IREADONLYLIST;
    public static PredefinedType PT_G_IREADONLYCOLLECTION;
    public static PredefinedType PT_FUNC;
    public static PredefinedType PT_COUNT;
    public static PredefinedType PT_VOID;
    public static PredefinedType PT_UNDEFINEDINDEX;
}
internal static class Microsoft.CSharp.RuntimeBinder.Syntax.TokenFacts : object {
    internal static string GetText(TokenKind kind);
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.TokenKind : Enum {
    public byte value__;
    public static TokenKind ArgList;
    public static TokenKind MakeRef;
    public static TokenKind RefType;
    public static TokenKind RefValue;
    public static TokenKind As;
    public static TokenKind Base;
    public static TokenKind Checked;
    public static TokenKind Explicit;
    public static TokenKind False;
    public static TokenKind Implicit;
    public static TokenKind Is;
    public static TokenKind Null;
    public static TokenKind This;
    public static TokenKind True;
    public static TokenKind TypeOf;
    public static TokenKind Unchecked;
    public static TokenKind Void;
    public static TokenKind Equal;
    public static TokenKind PlusEqual;
    public static TokenKind MinusEqual;
    public static TokenKind SplatEqual;
    public static TokenKind SlashEqual;
    public static TokenKind PercentEqual;
    public static TokenKind AndEqual;
    public static TokenKind HatEqual;
    public static TokenKind BarEqual;
    public static TokenKind LeftShiftEqual;
    public static TokenKind RightShiftEqual;
    public static TokenKind Question;
    public static TokenKind Colon;
    public static TokenKind ColonColon;
    public static TokenKind LogicalOr;
    public static TokenKind LogicalAnd;
    public static TokenKind Bar;
    public static TokenKind Hat;
    public static TokenKind Ampersand;
    public static TokenKind EqualEqual;
    public static TokenKind NotEqual;
    public static TokenKind LessThan;
    public static TokenKind LessThanEqual;
    public static TokenKind GreaterThan;
    public static TokenKind GreaterThanEqual;
    public static TokenKind LeftShift;
    public static TokenKind RightShift;
    public static TokenKind Plus;
    public static TokenKind Minus;
    public static TokenKind Splat;
    public static TokenKind Slash;
    public static TokenKind Percent;
    public static TokenKind Tilde;
    public static TokenKind Bang;
    public static TokenKind PlusPlus;
    public static TokenKind MinusMinus;
    public static TokenKind Dot;
    public static TokenKind QuestionQuestion;
    public static TokenKind Unknown;
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string InternalCompilerError { get; }
    internal static string BindPropertyFailedMethodGroup { get; }
    internal static string BindPropertyFailedEvent { get; }
    internal static string BindInvokeFailedNonDelegate { get; }
    internal static string NullReferenceOnMemberException { get; }
    internal static string BindCallToConditionalMethod { get; }
    internal static string BindToVoidMethodButExpectResult { get; }
    internal static string BadBinaryOps { get; }
    internal static string BadIndexLHS { get; }
    internal static string BadIndexCount { get; }
    internal static string BadUnaryOp { get; }
    internal static string NoImplicitConv { get; }
    internal static string NoExplicitConv { get; }
    internal static string ConstOutOfRange { get; }
    internal static string AmbigBinaryOps { get; }
    internal static string AmbigUnaryOp { get; }
    internal static string ValueCantBeNull { get; }
    internal static string NoSuchMember { get; }
    internal static string ObjectRequired { get; }
    internal static string AmbigCall { get; }
    internal static string BadAccess { get; }
    internal static string AssgLvalueExpected { get; }
    internal static string NoConstructors { get; }
    internal static string PropertyLacksGet { get; }
    internal static string ObjectProhibited { get; }
    internal static string AssgReadonly { get; }
    internal static string AssgReadonlyStatic { get; }
    internal static string AssgReadonlyProp { get; }
    internal static string UnsafeNeeded { get; }
    internal static string BadBoolOp { get; }
    internal static string MustHaveOpTF { get; }
    internal static string ConstOutOfRangeChecked { get; }
    internal static string AmbigMember { get; }
    internal static string NoImplicitConvCast { get; }
    internal static string InaccessibleGetter { get; }
    internal static string InaccessibleSetter { get; }
    internal static string BadArity { get; }
    internal static string TypeArgsNotAllowed { get; }
    internal static string HasNoTypeVars { get; }
    internal static string NewConstraintNotSatisfied { get; }
    internal static string GenericConstraintNotSatisfiedRefType { get; }
    internal static string GenericConstraintNotSatisfiedNullableEnum { get; }
    internal static string GenericConstraintNotSatisfiedNullableInterface { get; }
    internal static string GenericConstraintNotSatisfiedValType { get; }
    internal static string CantInferMethTypeArgs { get; }
    internal static string RefConstraintNotSatisfied { get; }
    internal static string ValConstraintNotSatisfied { get; }
    internal static string AmbigUDConv { get; }
    internal static string BindToBogus { get; }
    internal static string CantCallSpecialMethod { get; }
    internal static string ConvertToStaticClass { get; }
    internal static string IncrementLvalueExpected { get; }
    internal static string BadArgCount { get; }
    internal static string BadArgTypes { get; }
    internal static string BadProtectedAccess { get; }
    internal static string BindToBogusProp2 { get; }
    internal static string BindToBogusProp1 { get; }
    internal static string BadDelArgCount { get; }
    internal static string BadDelArgTypes { get; }
    internal static string BadCtorArgCount { get; }
    internal static string NonInvocableMemberCalled { get; }
    internal static string BadNamedArgument { get; }
    internal static string BadNamedArgumentForDelegateInvoke { get; }
    internal static string DuplicateNamedArgument { get; }
    internal static string NamedArgumentUsedInPositional { get; }
    internal static string TypeArgumentRequiredForStaticCall { get; }
    internal static string DynamicArgumentNeedsValue { get; }
    internal static string BadNonTrailingNamedArgument { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_InternalCompilerError();
    internal static string get_BindPropertyFailedMethodGroup();
    internal static string get_BindPropertyFailedEvent();
    internal static string get_BindInvokeFailedNonDelegate();
    internal static string get_NullReferenceOnMemberException();
    internal static string get_BindCallToConditionalMethod();
    internal static string get_BindToVoidMethodButExpectResult();
    internal static string get_BadBinaryOps();
    internal static string get_BadIndexLHS();
    internal static string get_BadIndexCount();
    internal static string get_BadUnaryOp();
    internal static string get_NoImplicitConv();
    internal static string get_NoExplicitConv();
    internal static string get_ConstOutOfRange();
    internal static string get_AmbigBinaryOps();
    internal static string get_AmbigUnaryOp();
    internal static string get_ValueCantBeNull();
    internal static string get_NoSuchMember();
    internal static string get_ObjectRequired();
    internal static string get_AmbigCall();
    internal static string get_BadAccess();
    internal static string get_AssgLvalueExpected();
    internal static string get_NoConstructors();
    internal static string get_PropertyLacksGet();
    internal static string get_ObjectProhibited();
    internal static string get_AssgReadonly();
    internal static string get_AssgReadonlyStatic();
    internal static string get_AssgReadonlyProp();
    internal static string get_UnsafeNeeded();
    internal static string get_BadBoolOp();
    internal static string get_MustHaveOpTF();
    internal static string get_ConstOutOfRangeChecked();
    internal static string get_AmbigMember();
    internal static string get_NoImplicitConvCast();
    internal static string get_InaccessibleGetter();
    internal static string get_InaccessibleSetter();
    internal static string get_BadArity();
    internal static string get_TypeArgsNotAllowed();
    internal static string get_HasNoTypeVars();
    internal static string get_NewConstraintNotSatisfied();
    internal static string get_GenericConstraintNotSatisfiedRefType();
    internal static string get_GenericConstraintNotSatisfiedNullableEnum();
    internal static string get_GenericConstraintNotSatisfiedNullableInterface();
    internal static string get_GenericConstraintNotSatisfiedValType();
    internal static string get_CantInferMethTypeArgs();
    internal static string get_RefConstraintNotSatisfied();
    internal static string get_ValConstraintNotSatisfied();
    internal static string get_AmbigUDConv();
    internal static string get_BindToBogus();
    internal static string get_CantCallSpecialMethod();
    internal static string get_ConvertToStaticClass();
    internal static string get_IncrementLvalueExpected();
    internal static string get_BadArgCount();
    internal static string get_BadArgTypes();
    internal static string get_BadProtectedAccess();
    internal static string get_BindToBogusProp2();
    internal static string get_BindToBogusProp1();
    internal static string get_BadDelArgCount();
    internal static string get_BadDelArgTypes();
    internal static string get_BadCtorArgCount();
    internal static string get_NonInvocableMemberCalled();
    internal static string get_BadNamedArgument();
    internal static string get_BadNamedArgumentForDelegateInvoke();
    internal static string get_DuplicateNamedArgument();
    internal static string get_NamedArgumentUsedInPositional();
    internal static string get_TypeArgumentRequiredForStaticCall();
    internal static string get_DynamicArgumentNeedsValue();
    internal static string get_BadNonTrailingNamedArgument();
}
