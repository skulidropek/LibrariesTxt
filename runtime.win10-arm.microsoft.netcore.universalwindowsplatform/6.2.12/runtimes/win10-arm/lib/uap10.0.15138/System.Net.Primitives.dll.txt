internal static class FxResources.System.Net.Primitives.SR : object {
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeLocalAllocHandle : SafeBuffer {
    internal static SafeLocalAllocHandle Zero;
    internal static SafeLocalAllocHandle InvalidHandle { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    private static SafeLocalAllocHandle();
    internal static SafeLocalAllocHandle LocalAlloc(int cb);
    internal static SafeLocalAllocHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
}
internal static class System.IO.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    private static int DEFAULT_CAPACITY;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal static class System.IPv4AddressHelper : object {
    internal static long Invalid;
    private static long MaxIPv4Value;
    private static int Octal;
    private static int Decimal;
    private static int Hex;
    private static int NumberOfLabels;
    internal static int ParseHostNumber(ReadOnlySpan`1<char> str, int start, int end);
    internal static bool IsValid(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile, bool unknownScheme);
    internal static bool IsValidCanonical(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile);
    internal static long ParseNonCanonical(Char* name, int start, Int32& end, bool notImplicitFile);
    private static bool ParseCanonical(ReadOnlySpan`1<char> name, Byte* numbers, int start, int end);
}
internal static class System.IPv6AddressHelper : object {
    private static int NumberOfLabels;
    internal static ValueTuple`2<int, int> FindCompressionRange(UInt16[] numbers, int fromInclusive, int toExclusive);
    internal static bool ShouldHaveIpv4Embedded(UInt16[] numbers);
    internal static bool IsValidStrict(Char* name, int start, Int32& end);
    internal static void Parse(ReadOnlySpan`1<char> address, Span`1<ushort> numbers, int start, String& scopeId);
}
internal static class System.Marvin : object {
    [CompilerGeneratedAttribute]
private static ulong <DefaultSeed>k__BackingField;
    public static ulong DefaultSeed { get; }
    private static Marvin();
    public static int ComputeHash32(ReadOnlySpan`1<byte> data, ulong seed);
    public static long ComputeHash(ReadOnlySpan`1<byte> data, ulong seed);
    private static void Block(UInt32& rp0, UInt32& rp1);
    private static UInt32 _rotl(UInt32 value, int shift);
    [CompilerGeneratedAttribute]
public static ulong get_DefaultSeed();
    private static ulong GenerateSeed();
}
[FlagsAttribute]
public enum System.Net.AuthenticationSchemes : Enum {
    public int value__;
    public static AuthenticationSchemes None;
    public static AuthenticationSchemes Digest;
    public static AuthenticationSchemes Negotiate;
    public static AuthenticationSchemes Ntlm;
    public static AuthenticationSchemes Basic;
    public static AuthenticationSchemes Anonymous;
    public static AuthenticationSchemes IntegratedWindowsAuthentication;
}
[ExtensionAttribute]
internal static class System.Net.ByteOrder : object {
    [ExtensionAttribute]
public static void HostToNetworkBytes(ushort host, Byte[] bytes, int index);
    [ExtensionAttribute]
public static ushort NetworkBytesToHostUInt16(Byte[] bytes, int index);
}
public enum System.Net.Cache.RequestCacheLevel : Enum {
    public int value__;
    public static RequestCacheLevel Default;
    public static RequestCacheLevel BypassCache;
    public static RequestCacheLevel CacheOnly;
    public static RequestCacheLevel CacheIfAvailable;
    public static RequestCacheLevel Revalidate;
    public static RequestCacheLevel Reload;
    public static RequestCacheLevel NoCacheNoStore;
}
public class System.Net.Cache.RequestCachePolicy : object {
    [CompilerGeneratedAttribute]
private RequestCacheLevel <Level>k__BackingField;
    public RequestCacheLevel Level { get; }
    public RequestCachePolicy(RequestCacheLevel level);
    [CompilerGeneratedAttribute]
public RequestCacheLevel get_Level();
    public virtual string ToString();
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Cookie : object {
    internal static int MaxSupportedVersion;
    internal static string MaxSupportedVersionString;
    internal static string SeparatorLiteral;
    internal static string EqualsLiteral;
    internal static string QuotesLiteral;
    internal static string SpecialAttributeLiteral;
    internal static Char[] PortSplitDelimiters;
    internal static Char[] ReservedToName;
    internal static Char[] ReservedToValue;
    private string m_comment;
    private Uri m_commentUri;
    private CookieVariant m_cookieVariant;
    private bool m_discard;
    private string m_domain;
    private bool m_domain_implicit;
    private DateTime m_expires;
    private string m_name;
    private string m_path;
    private bool m_path_implicit;
    private string m_port;
    private bool m_port_implicit;
    private Int32[] m_port_list;
    private bool m_secure;
    [OptionalFieldAttribute]
private bool m_httpOnly;
    private DateTime m_timeStamp;
    private string m_value;
    private int m_version;
    private string m_domainKey;
    public bool IsQuotedVersion;
    public bool IsQuotedDomain;
    public string Comment { get; public set; }
    public Uri CommentUri { get; public set; }
    public bool HttpOnly { get; public set; }
    public bool Discard { get; public set; }
    public string Domain { get; public set; }
    internal bool DomainImplicit { get; internal set; }
    public bool Expired { get; public set; }
    public DateTime Expires { get; public set; }
    public string Name { get; public set; }
    public string Path { get; public set; }
    internal bool Plain { get; }
    public string Port { get; public set; }
    internal Int32[] PortList { get; }
    public bool Secure { get; public set; }
    public DateTime TimeStamp { get; }
    public string Value { get; public set; }
    public CookieVariant Variant { get; public set; }
    internal string DomainKey { get; }
    public int Version { get; public set; }
    public Cookie(string name, string value);
    public Cookie(string name, string value, string path);
    public Cookie(string name, string value, string path, string domain);
    private static Cookie();
    public string get_Comment();
    public void set_Comment(string value);
    public Uri get_CommentUri();
    public void set_CommentUri(Uri value);
    public bool get_HttpOnly();
    public void set_HttpOnly(bool value);
    public bool get_Discard();
    public void set_Discard(bool value);
    public string get_Domain();
    public void set_Domain(string value);
    internal bool get_DomainImplicit();
    internal void set_DomainImplicit(bool value);
    public bool get_Expired();
    public void set_Expired(bool value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public string get_Name();
    public void set_Name(string value);
    public bool InternalSetName(string value);
    public string get_Path();
    public void set_Path(string value);
    internal bool get_Plain();
    public Cookie Clone();
    private static bool IsDomainEqualToHost(string domain, string host);
    internal bool VerifySetDefaults(CookieVariant variant, Uri uri, bool isLocalDomain, string localDomain, bool setDefault, bool shouldThrow);
    private static bool DomainCharsTest(string name);
    public string get_Port();
    public void set_Port(string value);
    internal Int32[] get_PortList();
    public bool get_Secure();
    public void set_Secure(bool value);
    public DateTime get_TimeStamp();
    public string get_Value();
    public void set_Value(string value);
    public CookieVariant get_Variant();
    public void set_Variant(CookieVariant value);
    internal string get_DomainKey();
    public int get_Version();
    public void set_Version(int value);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal void ToString(StringBuilder sb);
    public string ToServerString();
}
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.CookieCollection : object {
    private ArrayList m_list;
    private int m_version;
    private DateTime m_TimeStamp;
    private bool m_has_other_versions;
    public Cookie Item { get; }
    public Cookie Item { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal bool IsOtherVersionSeen { get; }
    public Cookie get_Item(int index);
    public Cookie get_Item(string name);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    public void Add(Cookie cookie);
    public void Add(CookieCollection cookies);
    public bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Cookie[] array, int index);
    internal DateTime TimeStamp(Stamp how);
    internal bool get_IsOtherVersionSeen();
    public int InternalAdd(Cookie cookie, bool isStrict);
    internal int IndexOf(Cookie cookie);
    internal void RemoveAt(int idx);
    public sealed virtual IEnumerator GetEnumerator();
}
internal static class System.Net.CookieComparer : object {
    internal static int Compare(Cookie left, Cookie right);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.CookieContainer : object {
    public static int DefaultCookieLimit;
    public static int DefaultPerDomainCookieLimit;
    public static int DefaultCookieLengthLimit;
    private static string s_fqdnMyDomain;
    private static HeaderVariantInfo[] s_headerInfo;
    private Hashtable m_domainTable;
    private int m_maxCookieSize;
    private int m_maxCookies;
    private int m_maxCookiesPerDomain;
    private int m_count;
    private string m_fqdnMyDomain;
    public int Capacity { get; public set; }
    public int Count { get; }
    public int MaxCookieSize { get; public set; }
    public int PerDomainCapacity { get; public set; }
    public CookieContainer(int capacity);
    public CookieContainer(int capacity, int perDomainCapacity, int maxCookieSize);
    private static CookieContainer();
    private static string CreateFqdnMyDomain();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public int get_MaxCookieSize();
    public void set_MaxCookieSize(int value);
    public int get_PerDomainCapacity();
    public void set_PerDomainCapacity(int value);
    public void Add(Cookie cookie);
    internal void Add(Cookie cookie, bool throwOnError);
    private bool AgeCookies(string domain);
    private int ExpireCollection(CookieCollection cc);
    public void Add(CookieCollection cookies);
    internal bool IsLocalDomain(string host);
    public void Add(Uri uri, Cookie cookie);
    public void Add(Uri uri, CookieCollection cookies);
    internal CookieCollection CookieCutter(Uri uri, string headerName, string setCookieHeader, bool isThrow);
    public CookieCollection GetCookies(Uri uri);
    internal CookieCollection InternalGetCookies(Uri uri);
    private void BuildCookieCollectionFromDomainMatches(Uri uri, bool isSecure, int port, CookieCollection& cookies, List`1<string> domainAttribute, bool matchOnlyPlainCookie);
    private void MergeUpdateCollections(CookieCollection& destination, CookieCollection source, int port, bool isSecure, bool isPlainOnly);
    public string GetCookieHeader(Uri uri);
    internal string GetCookieHeader(Uri uri, String& optCookie2);
    public void SetCookies(Uri uri, string cookieHeader);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.CookieException : FormatException {
    internal CookieException(string message);
    internal CookieException(string message, Exception inner);
    protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.Net.CookieFields : object {
    internal static string CommentAttributeName;
    internal static string CommentUrlAttributeName;
    internal static string DiscardAttributeName;
    internal static string DomainAttributeName;
    internal static string ExpiresAttributeName;
    internal static string MaxAgeAttributeName;
    internal static string PathAttributeName;
    internal static string PortAttributeName;
    internal static string SecureAttributeName;
    internal static string VersionAttributeName;
    internal static string HttpOnlyAttributeName;
}
internal class System.Net.CookieParser : object {
    private CookieTokenizer _tokenizer;
    private Cookie _savedCookie;
    private static FieldInfo s_isQuotedDomainField;
    private static FieldInfo s_isQuotedVersionField;
    private static FieldInfo IsQuotedDomainField { get; }
    private static FieldInfo IsQuotedVersionField { get; }
    internal CookieParser(string cookieString);
    private static CookieParser();
    internal string GetString();
    private static bool InternalSetNameMethod(Cookie cookie, string value);
    private static FieldInfo get_IsQuotedDomainField();
    private static FieldInfo get_IsQuotedVersionField();
    internal Cookie Get();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
    internal bool EndofHeader();
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : object {
    private bool _eofCookie;
    private int _index;
    private int _length;
    private string _name;
    private bool _quoted;
    private int _start;
    private CookieToken _token;
    private int _tokenLength;
    private string _tokenStream;
    private string _value;
    private int _cookieStartIndex;
    private int _cookieLength;
    private static RecognizedAttribute[] s_recognizedAttributes;
    private static RecognizedAttribute[] s_recognizedServerAttributes;
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string GetCookieString();
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.Net.CookieVariant : Enum {
    public int value__;
    public static CookieVariant Unknown;
    public static CookieVariant Plain;
    public static CookieVariant Rfc2109;
    public static CookieVariant Rfc2965;
    public static CookieVariant Default;
}
public class System.Net.CredentialCache : object {
    private Dictionary`2<CredentialKey, NetworkCredential> _cache;
    private Dictionary`2<CredentialHostKey, NetworkCredential> _cacheForHosts;
    private int _version;
    public static ICredentials DefaultCredentials { get; }
    public static NetworkCredential DefaultNetworkCredentials { get; }
    public void Add(Uri uriPrefix, string authType, NetworkCredential cred);
    public void Add(string host, int port, string authenticationType, NetworkCredential credential);
    public void Remove(Uri uriPrefix, string authType);
    public void Remove(string host, int port, string authenticationType);
    public sealed virtual NetworkCredential GetCredential(Uri uriPrefix, string authType);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
    public sealed virtual IEnumerator GetEnumerator();
    public static ICredentials get_DefaultCredentials();
    public static NetworkCredential get_DefaultNetworkCredentials();
}
[IsReadOnlyAttribute]
internal class System.Net.CredentialHostKey : ValueType {
    public string Host;
    public string AuthenticationType;
    public int Port;
    internal CredentialHostKey(string host, int port, string authenticationType);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CredentialHostKey other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal class System.Net.CredentialKey : object {
    public Uri UriPrefix;
    public int UriPrefixLength;
    public string AuthenticationType;
    internal CredentialKey(Uri uriPrefix, string authenticationType);
    internal bool Match(Uri uri, string authenticationType);
    private static bool IsPrefix(Uri uri, Uri prefixUri);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CredentialKey other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Net.DecompressionMethods : Enum {
    public int value__;
    public static DecompressionMethods None;
    public static DecompressionMethods GZip;
    public static DecompressionMethods Deflate;
}
public class System.Net.DnsEndPoint : EndPoint {
    private string _host;
    private int _port;
    private AddressFamily _family;
    public string Host { get; }
    public AddressFamily AddressFamily { get; }
    public int Port { get; }
    public DnsEndPoint(string host, int port);
    public DnsEndPoint(string host, int port, AddressFamily addressFamily);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_Host();
    public virtual AddressFamily get_AddressFamily();
    public int get_Port();
}
public abstract class System.Net.EndPoint : object {
    public AddressFamily AddressFamily { get; }
    public virtual AddressFamily get_AddressFamily();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
}
[IsReadOnlyAttribute]
internal class System.Net.HeaderVariantInfo : ValueType {
    private string _name;
    private CookieVariant _variant;
    internal string Name { get; }
    internal CookieVariant Variant { get; }
    internal HeaderVariantInfo(string name, CookieVariant variant);
    internal string get_Name();
    internal CookieVariant get_Variant();
}
internal static class System.Net.HttpKnownHeaderNames : object {
    public static string Accept;
    public static string AcceptCharset;
    public static string AcceptEncoding;
    public static string AcceptLanguage;
    public static string AcceptPatch;
    public static string AcceptRanges;
    public static string AccessControlAllowCredentials;
    public static string AccessControlAllowHeaders;
    public static string AccessControlAllowMethods;
    public static string AccessControlAllowOrigin;
    public static string AccessControlExposeHeaders;
    public static string AccessControlMaxAge;
    public static string Age;
    public static string Allow;
    public static string AltSvc;
    public static string Authorization;
    public static string CacheControl;
    public static string Connection;
    public static string ContentDisposition;
    public static string ContentEncoding;
    public static string ContentLanguage;
    public static string ContentLength;
    public static string ContentLocation;
    public static string ContentMD5;
    public static string ContentRange;
    public static string ContentSecurityPolicy;
    public static string ContentType;
    public static string Cookie;
    public static string Cookie2;
    public static string Date;
    public static string ETag;
    public static string Expect;
    public static string Expires;
    public static string From;
    public static string Host;
    public static string IfMatch;
    public static string IfModifiedSince;
    public static string IfNoneMatch;
    public static string IfRange;
    public static string IfUnmodifiedSince;
    public static string KeepAlive;
    public static string LastModified;
    public static string Link;
    public static string Location;
    public static string MaxForwards;
    public static string Origin;
    public static string P3P;
    public static string Pragma;
    public static string ProxyAuthenticate;
    public static string ProxyAuthorization;
    public static string ProxyConnection;
    public static string PublicKeyPins;
    public static string Range;
    public static string Referer;
    public static string RetryAfter;
    public static string SecWebSocketAccept;
    public static string SecWebSocketExtensions;
    public static string SecWebSocketKey;
    public static string SecWebSocketProtocol;
    public static string SecWebSocketVersion;
    public static string Server;
    public static string SetCookie;
    public static string SetCookie2;
    public static string StrictTransportSecurity;
    public static string TE;
    public static string TSV;
    public static string Trailer;
    public static string TransferEncoding;
    public static string Upgrade;
    public static string UpgradeInsecureRequests;
    public static string UserAgent;
    public static string Vary;
    public static string Via;
    public static string WWWAuthenticate;
    public static string Warning;
    public static string XAspNetVersion;
    public static string XContentDuration;
    public static string XContentTypeOptions;
    public static string XFrameOptions;
    public static string XMSEdgeRef;
    public static string XPoweredBy;
    public static string XRequestID;
    public static string XUACompatible;
}
public enum System.Net.HttpStatusCode : Enum {
    public int value__;
    public static HttpStatusCode Continue;
    public static HttpStatusCode SwitchingProtocols;
    public static HttpStatusCode Processing;
    public static HttpStatusCode EarlyHints;
    public static HttpStatusCode OK;
    public static HttpStatusCode Created;
    public static HttpStatusCode Accepted;
    public static HttpStatusCode NonAuthoritativeInformation;
    public static HttpStatusCode NoContent;
    public static HttpStatusCode ResetContent;
    public static HttpStatusCode PartialContent;
    public static HttpStatusCode MultiStatus;
    public static HttpStatusCode AlreadyReported;
    public static HttpStatusCode IMUsed;
    public static HttpStatusCode MultipleChoices;
    public static HttpStatusCode Ambiguous;
    public static HttpStatusCode MovedPermanently;
    public static HttpStatusCode Moved;
    public static HttpStatusCode Found;
    public static HttpStatusCode Redirect;
    public static HttpStatusCode SeeOther;
    public static HttpStatusCode RedirectMethod;
    public static HttpStatusCode NotModified;
    public static HttpStatusCode UseProxy;
    public static HttpStatusCode Unused;
    public static HttpStatusCode TemporaryRedirect;
    public static HttpStatusCode RedirectKeepVerb;
    public static HttpStatusCode PermanentRedirect;
    public static HttpStatusCode BadRequest;
    public static HttpStatusCode Unauthorized;
    public static HttpStatusCode PaymentRequired;
    public static HttpStatusCode Forbidden;
    public static HttpStatusCode NotFound;
    public static HttpStatusCode MethodNotAllowed;
    public static HttpStatusCode NotAcceptable;
    public static HttpStatusCode ProxyAuthenticationRequired;
    public static HttpStatusCode RequestTimeout;
    public static HttpStatusCode Conflict;
    public static HttpStatusCode Gone;
    public static HttpStatusCode LengthRequired;
    public static HttpStatusCode PreconditionFailed;
    public static HttpStatusCode RequestEntityTooLarge;
    public static HttpStatusCode RequestUriTooLong;
    public static HttpStatusCode UnsupportedMediaType;
    public static HttpStatusCode RequestedRangeNotSatisfiable;
    public static HttpStatusCode ExpectationFailed;
    public static HttpStatusCode MisdirectedRequest;
    public static HttpStatusCode UnprocessableEntity;
    public static HttpStatusCode Locked;
    public static HttpStatusCode FailedDependency;
    public static HttpStatusCode UpgradeRequired;
    public static HttpStatusCode PreconditionRequired;
    public static HttpStatusCode TooManyRequests;
    public static HttpStatusCode RequestHeaderFieldsTooLarge;
    public static HttpStatusCode UnavailableForLegalReasons;
    public static HttpStatusCode InternalServerError;
    public static HttpStatusCode NotImplemented;
    public static HttpStatusCode BadGateway;
    public static HttpStatusCode ServiceUnavailable;
    public static HttpStatusCode GatewayTimeout;
    public static HttpStatusCode HttpVersionNotSupported;
    public static HttpStatusCode VariantAlsoNegotiates;
    public static HttpStatusCode InsufficientStorage;
    public static HttpStatusCode LoopDetected;
    public static HttpStatusCode NotExtended;
    public static HttpStatusCode NetworkAuthenticationRequired;
}
public static class System.Net.HttpVersion : object {
    public static Version Unknown;
    public static Version Version10;
    public static Version Version11;
    public static Version Version20;
    private static HttpVersion();
}
public interface System.Net.ICredentials {
    public abstract virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public interface System.Net.ICredentialsByHost {
    public abstract virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
}
internal class System.Net.InternalException : Exception {
}
public class System.Net.IPAddress : object {
    public static IPAddress Any;
    public static IPAddress Loopback;
    public static IPAddress Broadcast;
    public static IPAddress None;
    internal static long LoopbackMask;
    public static IPAddress IPv6Any;
    public static IPAddress IPv6Loopback;
    public static IPAddress IPv6None;
    private UInt32 _addressOrScopeId;
    private UInt16[] _numbers;
    private string _toString;
    private int _hashCode;
    internal static int NumberOfLabels;
    private bool IsIPv4 { get; }
    private bool IsIPv6 { get; }
    private UInt32 PrivateAddress { get; private set; }
    private UInt32 PrivateScopeId { get; private set; }
    public AddressFamily AddressFamily { get; }
    public long ScopeId { get; public set; }
    public bool IsIPv6Multicast { get; }
    public bool IsIPv6LinkLocal { get; }
    public bool IsIPv6SiteLocal { get; }
    public bool IsIPv6Teredo { get; }
    public bool IsIPv4MappedToIPv6 { get; }
    [ObsoleteAttribute("This property has been deprecated. It is address family dependent. Please use IPAddress.Equals method to perform comparisons. http://go.microsoft.com/fwlink/?linkid=14202")]
public long Address { get; public set; }
    public IPAddress(long newAddress);
    public IPAddress(Byte[] address, long scopeid);
    public IPAddress(ReadOnlySpan`1<byte> address, long scopeid);
    internal IPAddress(ReadOnlySpan`1<ushort> numbers, UInt32 scopeid);
    private IPAddress(UInt16[] numbers, UInt32 scopeid);
    public IPAddress(Byte[] address);
    public IPAddress(ReadOnlySpan`1<byte> address);
    internal IPAddress(int newAddress);
    private static IPAddress();
    private bool get_IsIPv4();
    private bool get_IsIPv6();
    private UInt32 get_PrivateAddress();
    private void set_PrivateAddress(UInt32 value);
    private UInt32 get_PrivateScopeId();
    private void set_PrivateScopeId(UInt32 value);
    public static bool TryParse(string ipString, IPAddress& address);
    public static bool TryParse(ReadOnlySpan`1<char> ipSpan, IPAddress& address);
    public static IPAddress Parse(string ipString);
    public static IPAddress Parse(ReadOnlySpan`1<char> ipSpan);
    public bool TryWriteBytes(Span`1<byte> destination, Int32& bytesWritten);
    private void WriteIPv6Bytes(Span`1<byte> destination);
    private void WriteIPv4Bytes(Span`1<byte> destination);
    public Byte[] GetAddressBytes();
    public AddressFamily get_AddressFamily();
    public long get_ScopeId();
    public void set_ScopeId(long value);
    public virtual string ToString();
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public static long HostToNetworkOrder(long host);
    public static int HostToNetworkOrder(int host);
    public static short HostToNetworkOrder(short host);
    public static long NetworkToHostOrder(long network);
    public static int NetworkToHostOrder(int network);
    public static short NetworkToHostOrder(short network);
    public static bool IsLoopback(IPAddress address);
    public bool get_IsIPv6Multicast();
    public bool get_IsIPv6LinkLocal();
    public bool get_IsIPv6SiteLocal();
    public bool get_IsIPv6Teredo();
    public bool get_IsIPv4MappedToIPv6();
    public long get_Address();
    public void set_Address(long value);
    internal bool Equals(object comparandObj, bool compareScopeId);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public IPAddress MapToIPv6();
    public IPAddress MapToIPv4();
    private static Byte[] ThrowAddressNullException();
}
internal class System.Net.IPAddressParser : object {
    private static int MaxIPv4StringLength;
    internal static IPAddress Parse(ReadOnlySpan`1<char> ipSpan, bool tryParse);
    internal static string IPv4AddressToString(UInt32 address);
    internal static bool IPv4AddressToString(UInt32 address, Span`1<char> formatted, Int32& charsWritten);
    private static int IPv4AddressToStringHelper(UInt32 address, Char* addressString);
    internal static string IPv6AddressToString(UInt16[] address, UInt32 scopeId);
    internal static bool IPv6AddressToString(UInt16[] address, UInt32 scopeId, Span`1<char> destination, Int32& charsWritten);
    internal static StringBuilder IPv6AddressToStringHelper(UInt16[] address, UInt32 scopeId);
    private static void FormatIPv4AddressNumber(int number, Char* addressString, Int32& offset);
    public static bool Ipv4StringToAddress(ReadOnlySpan`1<char> ipSpan, Int64& address);
    public static bool Ipv6StringToAddress(ReadOnlySpan`1<char> ipSpan, Span`1<ushort> numbers, int numbersLength, UInt32& scope);
    private static void AppendSections(UInt16[] address, int fromInclusive, int toExclusive, StringBuilder buffer);
    private static void AppendHex(ushort value, StringBuilder buffer);
    private static UInt32 ExtractIPv4Address(UInt16[] address);
    private static ushort Reverse(ushort number);
}
internal static class System.Net.IPAddressParserStatics : object {
    public static int IPv4AddressBytes;
    public static int IPv6AddressBytes;
    public static int IPv6AddressShorts;
}
public class System.Net.IPEndPoint : EndPoint {
    public static int MinPort;
    public static int MaxPort;
    private IPAddress _address;
    private int _port;
    internal static int AnyPort;
    internal static IPEndPoint Any;
    internal static IPEndPoint IPv6Any;
    public AddressFamily AddressFamily { get; }
    public IPAddress Address { get; public set; }
    public int Port { get; public set; }
    public IPEndPoint(long address, int port);
    public IPEndPoint(IPAddress address, int port);
    private static IPEndPoint();
    public virtual AddressFamily get_AddressFamily();
    public IPAddress get_Address();
    public void set_Address(IPAddress value);
    public int get_Port();
    public void set_Port(int value);
    public virtual string ToString();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
}
public interface System.Net.IWebProxy {
    public ICredentials Credentials { get; public set; }
    public abstract virtual Uri GetProxy(Uri destination);
    public abstract virtual bool IsBypassed(Uri host);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
}
internal class System.Net.NegotiationInfoClass : object {
    internal static string NTLM;
    internal static string Kerberos;
    internal static string Negotiate;
    internal static string Basic;
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static string MissingMember;
    private static string NullInstance;
    private static string StaticMethodObject;
    private static string NoParameters;
    private static int MaxDumpSize;
    private static int EnterEventId;
    private static int ExitEventId;
    private static int AssociateEventId;
    private static int InfoEventId;
    private static int ErrorEventId;
    private static int CriticalFailureEventId;
    private static int DumpArrayEventId;
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int NextAvailableEventId;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, object arg1, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(object arg);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(FormattableString arg);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
}
public class System.Net.NetworkCredential : object {
    private string _domain;
    private string _userName;
    private object _password;
    public string UserName { get; public set; }
    public string Password { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString SecurePassword { get; public set; }
    public string Domain { get; public set; }
    public NetworkCredential(string userName, string password);
    public NetworkCredential(string userName, string password, string domain);
    [CLSCompliantAttribute("False")]
public NetworkCredential(string userName, SecureString password);
    [CLSCompliantAttribute("False")]
public NetworkCredential(string userName, SecureString password, string domain);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Password();
    public void set_Password(string value);
    public SecureString get_SecurePassword();
    public void set_SecurePassword(SecureString value);
    public string get_Domain();
    public void set_Domain(string value);
    internal string InternalGetDomainUserName();
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authenticationType);
    public sealed virtual NetworkCredential GetCredential(string host, int port, string authenticationType);
    private string MarshalToString(SecureString sstr);
    private SecureString MarshalToSecureString(string str);
}
internal class System.Net.NetworkInformation.HostInformation : object {
    internal static string HostName { get; }
    internal static string DomainName { get; }
    internal static string get_HostName();
    internal static string get_DomainName();
}
internal static class System.Net.NetworkInformation.HostInformationPal : object {
    private static FIXED_INFO s_fixedInfo;
    private static bool s_fixedInfoInitialized;
    private static object s_syncObject;
    private static HostInformationPal();
    public static string GetHostName();
    public static string GetDomainName();
    public static FIXED_INFO GetFixedInfo();
    private static void EnsureFixedInfo();
}
[DefaultMemberAttribute("Item")]
public class System.Net.NetworkInformation.IPAddressCollection : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public IPAddress Item { get; }
    public virtual void CopyTo(IPAddress[] array, int offset);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual void Add(IPAddress address);
    public virtual bool Contains(IPAddress address);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<IPAddress> GetEnumerator();
    public virtual IPAddress get_Item(int index);
    public virtual bool Remove(IPAddress address);
    public virtual void Clear();
}
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.PathList : object {
    private SortedList m_list;
    internal int Count { get; }
    internal ICollection Values { get; }
    internal object Item { get; internal set; }
    internal object SyncRoot { get; }
    internal int get_Count();
    internal int GetCookiesCount();
    internal ICollection get_Values();
    internal object get_Item(string s);
    internal void set_Item(string s, object value);
    internal IDictionaryEnumerator GetEnumerator();
    internal object get_SyncRoot();
}
public enum System.Net.Security.AuthenticationLevel : Enum {
    public int value__;
    public static AuthenticationLevel None;
    public static AuthenticationLevel MutualAuthRequested;
    public static AuthenticationLevel MutualAuthRequired;
}
[FlagsAttribute]
public enum System.Net.Security.SslPolicyErrors : Enum {
    public int value__;
    public static SslPolicyErrors None;
    public static SslPolicyErrors RemoteCertificateNotAvailable;
    public static SslPolicyErrors RemoteCertificateNameMismatch;
    public static SslPolicyErrors RemoteCertificateChainErrors;
}
[DefaultMemberAttribute("Item")]
public class System.Net.SocketAddress : object {
    internal static int IPv6AddressSize;
    internal static int IPv4AddressSize;
    internal int InternalSize;
    internal Byte[] Buffer;
    private static int MinSize;
    private static int MaxSize;
    private bool _changed;
    private int _hash;
    public AddressFamily Family { get; }
    public int Size { get; }
    public byte Item { get; public set; }
    public SocketAddress(AddressFamily family);
    public SocketAddress(AddressFamily family, int size);
    internal SocketAddress(IPAddress ipAddress);
    internal SocketAddress(IPAddress ipaddress, int port);
    private static SocketAddress();
    public AddressFamily get_Family();
    public int get_Size();
    public byte get_Item(int offset);
    public void set_Item(int offset, byte value);
    internal IPAddress GetIPAddress();
    internal IPEndPoint GetIPEndPoint();
    internal void CopyAddressSizeIntoBuffer();
    internal int GetAddressSizeOffset();
    public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class System.Net.SocketAddressPal : object {
    public static int IPv6AddressSize;
    public static int IPv4AddressSize;
    public static int DataOffset;
    public static AddressFamily GetAddressFamily(Byte[] buffer);
    public static void SetAddressFamily(Byte[] buffer, AddressFamily family);
    public static ushort GetPort(Byte[] buffer);
    public static void SetPort(Byte[] buffer, ushort port);
    public static UInt32 GetIPv4Address(ReadOnlySpan`1<byte> buffer);
    public static void GetIPv6Address(ReadOnlySpan`1<byte> buffer, Span`1<byte> address, UInt32& scope);
    public static void SetIPv4Address(Byte[] buffer, UInt32 address);
    public static void SetIPv6Address(Byte[] buffer, Span`1<byte> address, UInt32 scope);
}
public enum System.Net.Sockets.AddressFamily : Enum {
    public int value__;
    public static AddressFamily Unknown;
    public static AddressFamily Unspecified;
    public static AddressFamily Unix;
    public static AddressFamily InterNetwork;
    public static AddressFamily ImpLink;
    public static AddressFamily Pup;
    public static AddressFamily Chaos;
    public static AddressFamily NS;
    public static AddressFamily Ipx;
    public static AddressFamily Iso;
    public static AddressFamily Osi;
    public static AddressFamily Ecma;
    public static AddressFamily DataKit;
    public static AddressFamily Ccitt;
    public static AddressFamily Sna;
    public static AddressFamily DecNet;
    public static AddressFamily DataLink;
    public static AddressFamily Lat;
    public static AddressFamily HyperChannel;
    public static AddressFamily AppleTalk;
    public static AddressFamily NetBios;
    public static AddressFamily VoiceView;
    public static AddressFamily FireFox;
    public static AddressFamily Banyan;
    public static AddressFamily Atm;
    public static AddressFamily InterNetworkV6;
    public static AddressFamily Cluster;
    public static AddressFamily Ieee12844;
    public static AddressFamily Irda;
    public static AddressFamily NetworkDesigners;
    public static AddressFamily Max;
}
public enum System.Net.Sockets.SocketError : Enum {
    public int value__;
    public static SocketError Success;
    public static SocketError SocketError;
    public static SocketError Interrupted;
    public static SocketError AccessDenied;
    public static SocketError Fault;
    public static SocketError InvalidArgument;
    public static SocketError TooManyOpenSockets;
    public static SocketError WouldBlock;
    public static SocketError InProgress;
    public static SocketError AlreadyInProgress;
    public static SocketError NotSocket;
    public static SocketError DestinationAddressRequired;
    public static SocketError MessageSize;
    public static SocketError ProtocolType;
    public static SocketError ProtocolOption;
    public static SocketError ProtocolNotSupported;
    public static SocketError SocketNotSupported;
    public static SocketError OperationNotSupported;
    public static SocketError ProtocolFamilyNotSupported;
    public static SocketError AddressFamilyNotSupported;
    public static SocketError AddressAlreadyInUse;
    public static SocketError AddressNotAvailable;
    public static SocketError NetworkDown;
    public static SocketError NetworkUnreachable;
    public static SocketError NetworkReset;
    public static SocketError ConnectionAborted;
    public static SocketError ConnectionReset;
    public static SocketError NoBufferSpaceAvailable;
    public static SocketError IsConnected;
    public static SocketError NotConnected;
    public static SocketError Shutdown;
    public static SocketError TimedOut;
    public static SocketError ConnectionRefused;
    public static SocketError HostDown;
    public static SocketError HostUnreachable;
    public static SocketError ProcessLimit;
    public static SocketError SystemNotReady;
    public static SocketError VersionNotSupported;
    public static SocketError NotInitialized;
    public static SocketError Disconnecting;
    public static SocketError TypeNotFound;
    public static SocketError HostNotFound;
    public static SocketError TryAgain;
    public static SocketError NoRecovery;
    public static SocketError NoData;
    public static SocketError IOPending;
    public static SocketError OperationAborted;
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Sockets.SocketException : Win32Exception {
    private SocketError _errorCode;
    public string Message { get; }
    public SocketError SocketErrorCode { get; }
    public int ErrorCode { get; }
    public SocketException(int errorCode);
    internal SocketException(SocketError socketError);
    protected SocketException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal SocketException(SocketError errorCode, UInt32 platformError);
    public virtual string get_Message();
    public SocketError get_SocketErrorCode();
    public virtual int get_ErrorCode();
    private static int GetNativeErrorForSocketError(SocketError error);
}
internal class System.Net.SystemNetworkCredential : NetworkCredential {
    internal static SystemNetworkCredential s_defaultCredential;
    private static SystemNetworkCredential();
}
internal static class System.Net.TcpValidationHelpers : object {
    public static bool ValidatePortNumber(int port);
}
public abstract class System.Net.TransportContext : object {
    public abstract virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal static class System.Net.UriScheme : object {
    public static string File;
    public static string Ftp;
    public static string Gopher;
    public static string Http;
    public static string Https;
    public static string News;
    public static string NetPipe;
    public static string NetTcp;
    public static string Nntp;
    public static string Mailto;
    public static string Ws;
    public static string Wss;
    public static string SchemeDelimiter;
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
public enum System.Security.Authentication.CipherAlgorithmType : Enum {
    public int value__;
    public static CipherAlgorithmType None;
    public static CipherAlgorithmType Rc2;
    public static CipherAlgorithmType Rc4;
    public static CipherAlgorithmType Des;
    public static CipherAlgorithmType TripleDes;
    public static CipherAlgorithmType Aes;
    public static CipherAlgorithmType Aes128;
    public static CipherAlgorithmType Aes192;
    public static CipherAlgorithmType Aes256;
    public static CipherAlgorithmType Null;
}
public enum System.Security.Authentication.ExchangeAlgorithmType : Enum {
    public int value__;
    public static ExchangeAlgorithmType None;
    public static ExchangeAlgorithmType RsaSign;
    public static ExchangeAlgorithmType RsaKeyX;
    public static ExchangeAlgorithmType DiffieHellman;
}
public abstract class System.Security.Authentication.ExtendedProtection.ChannelBinding : SafeHandleZeroOrMinusOneIsInvalid {
    public int Size { get; }
    protected ChannelBinding(bool ownsHandle);
    public abstract virtual int get_Size();
}
public enum System.Security.Authentication.ExtendedProtection.ChannelBindingKind : Enum {
    public int value__;
    public static ChannelBindingKind Unknown;
    public static ChannelBindingKind Unique;
    public static ChannelBindingKind Endpoint;
}
public enum System.Security.Authentication.HashAlgorithmType : Enum {
    public int value__;
    public static HashAlgorithmType None;
    public static HashAlgorithmType Md5;
    public static HashAlgorithmType Sha1;
    public static HashAlgorithmType Sha256;
    public static HashAlgorithmType Sha384;
    public static HashAlgorithmType Sha512;
}
[FlagsAttribute]
public enum System.Security.Authentication.SslProtocols : Enum {
    public int value__;
    public static SslProtocols None;
    public static SslProtocols Ssl2;
    public static SslProtocols Ssl3;
    public static SslProtocols Tls;
    public static SslProtocols Tls11;
    public static SslProtocols Tls12;
    public static SslProtocols Default;
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string net_toosmall { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string net_PropertyNotImplementedException { get; }
    internal static string net_InvalidAddressFamily { get; }
    internal static string net_InvalidSocketAddressSize { get; }
    internal static string net_sockets_invalid_optionValue_all { get; }
    internal static string net_emptystringcall { get; }
    internal static string dns_bad_ip_address { get; }
    internal static string net_container_add_cookie { get; }
    internal static string net_cookie_size { get; }
    internal static string net_cookie_parse_header { get; }
    internal static string net_cookie_attribute { get; }
    internal static string net_cookie_format { get; }
    internal static string net_cookie_capacity_range { get; }
    internal static string net_collection_readonly { get; }
    internal static string net_nodefaultcreds { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_net_toosmall();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_net_PropertyNotImplementedException();
    internal static string get_net_InvalidAddressFamily();
    internal static string get_net_InvalidSocketAddressSize();
    internal static string get_net_sockets_invalid_optionValue_all();
    internal static string get_net_emptystringcall();
    internal static string get_dns_bad_ip_address();
    internal static string get_net_container_add_cookie();
    internal static string get_net_cookie_size();
    internal static string get_net_cookie_parse_header();
    internal static string get_net_cookie_attribute();
    internal static string get_net_cookie_format();
    internal static string get_net_cookie_capacity_range();
    internal static string get_net_collection_readonly();
    internal static string get_net_nodefaultcreds();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumOpCantHappen();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex);
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
