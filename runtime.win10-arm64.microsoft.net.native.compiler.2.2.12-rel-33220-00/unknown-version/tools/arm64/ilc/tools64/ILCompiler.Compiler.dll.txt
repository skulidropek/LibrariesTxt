public class ILCompiler.AnalysisBasedMetadataManager : GeneratingMetadataManager {
    private List`1<ModuleDesc> _modulesWithMetadata;
    private Dictionary`2<TypeDesc, MetadataCategory> _reflectableTypes;
    private Dictionary`2<MethodDesc, MetadataCategory> _reflectableMethods;
    private Dictionary`2<FieldDesc, MetadataCategory> _reflectableFields;
    public AnalysisBasedMetadataManager(CompilerTypeSystemContext typeSystemContext, MetadataBlockingPolicy blockingPolicy, ManifestResourceBlockingPolicy resourceBlockingPolicy, string logFile, StackTraceEmissionPolicy stackTracePolicy, DynamicInvokeThunkGenerationPolicy invokeThunkGenerationPolicy, IEnumerable`1<ModuleDesc> modulesWithMetadata, IEnumerable`1<ReflectableEntity`1<TypeDesc>> reflectableTypes, IEnumerable`1<ReflectableEntity`1<MethodDesc>> reflectableMethods, IEnumerable`1<ReflectableEntity`1<FieldDesc>> reflectableFields);
    public virtual IEnumerable`1<ModuleDesc> GetCompilationModulesWithMetadata();
    protected virtual void ComputeMetadata(NodeFactory factory, Byte[]& metadataBlob, List`1& typeMappings, List`1& methodMappings, List`1& fieldMappings, List`1& stackTraceMapping);
    protected sealed virtual MetadataCategory GetMetadataCategory(MethodDesc method);
    protected sealed virtual MetadataCategory GetMetadataCategory(TypeDesc type);
    protected sealed virtual MetadataCategory GetMetadataCategory(FieldDesc field);
    [IteratorStateMachineAttribute("ILCompiler.AnalysisBasedMetadataManager/<GetFieldsWithRuntimeMapping>d__10")]
protected virtual IEnumerable`1<FieldDesc> GetFieldsWithRuntimeMapping();
    private sealed virtual override void ILCompiler.ICompilationRootProvider.AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public class ILCompiler.AttributeDrivenLazyGenericsPolicy : LazyGenericsPolicy {
    public sealed virtual bool UsesLazyGenerics(MethodDesc method);
    public sealed virtual bool UsesLazyGenerics(TypeDesc type);
    public sealed virtual bool UsesLazyGenerics(MetadataType type);
}
public class ILCompiler.BlockedInternalsBlockingPolicy : MetadataBlockingPolicy {
    private BlockedModulesHashtable _blockedModules;
    private BlockedTypeHashtable _blockedTypes;
    private MetadataType _arrayOfTType;
    private MetadataType InitializeArrayOfTType(TypeSystemEntity contextEntity);
    private MetadataType GetArrayOfTType(TypeSystemEntity contextEntity);
    public virtual bool IsBlocked(MetadataType type);
    public virtual bool IsBlocked(MethodDesc method);
    public virtual bool IsBlocked(FieldDesc field);
}
public class ILCompiler.CodeGenerationFailedException : InternalCompilerErrorException {
    private static string MessageText;
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    public MethodDesc Method { get; }
    public CodeGenerationFailedException(MethodDesc method);
    public CodeGenerationFailedException(MethodDesc method, Exception inner);
    [CompilerGeneratedAttribute]
public MethodDesc get_Method();
}
public class ILCompiler.ComparerCompilationRootProvider : object {
    private TypeSystemContext _context;
    public ComparerCompilationRootProvider(TypeSystemContext context);
    private Instantiation GetUniformInstantiation(int numArgs, TypeDesc uniformInstanitationType);
    private MethodDesc InstantiateMethodOverUniformType(MethodDesc method, TypeDesc uniformInstanitationType);
    private void AddUniformInstantiationForMethod(IRootingServiceProvider rootProvider, MethodDesc method, TypeDesc uniformInstanitationType);
    private void AddCanonInstantiationsForMethod(IRootingServiceProvider rootProvider, MethodDesc method, bool normalCanonSupported);
    private void AddCanonInstantiationsForMethod(IRootingServiceProvider rootProvider, MetadataType type, string methodName, bool normalCanonSupported);
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public abstract class ILCompiler.Compilation : object {
    protected DependencyAnalyzerBase`1<NodeFactory> _dependencyGraph;
    protected NodeFactory _nodeFactory;
    protected Logger _logger;
    private DebugInformationProvider _debugInformationProvider;
    private DevirtualizationManager _devirtualizationManager;
    [CompilerGeneratedAttribute]
private PInvokeILProvider <PInvokeILProvider>k__BackingField;
    private TypeGetTypeMethodThunkCache _typeGetTypeMethodThunks;
    private AssemblyGetExecutingAssemblyMethodThunkCache _assemblyGetExecutingAssemblyMethodThunks;
    private MethodBaseGetCurrentMethodThunkCache _methodBaseGetCurrentMethodThunks;
    private ILProvider _methodILCache;
    public NameMangler NameMangler { get; }
    public NodeFactory NodeFactory { get; }
    public CompilerTypeSystemContext TypeSystemContext { get; }
    public Logger Logger { get; }
    internal PInvokeILProvider PInvokeILProvider { get; }
    protected Compilation(DependencyAnalyzerBase`1<NodeFactory> dependencyGraph, NodeFactory nodeFactory, IEnumerable`1<ICompilationRootProvider> compilationRoots, DebugInformationProvider debugInformationProvider, DevirtualizationManager devirtualizationManager, Logger logger);
    public NameMangler get_NameMangler();
    public NodeFactory get_NodeFactory();
    public CompilerTypeSystemContext get_TypeSystemContext();
    public Logger get_Logger();
    [CompilerGeneratedAttribute]
internal PInvokeILProvider get_PInvokeILProvider();
    public MethodIL GetMethodIL(MethodDesc method);
    protected abstract virtual void ComputeDependencyNodeDependencies(List`1<DependencyNodeCore`1<NodeFactory>> obj);
    protected abstract virtual void CompileInternal(string outputFile, ObjectDumper dumper);
    public DelegateCreationInfo GetDelegateCtor(TypeDesc delegateType, MethodDesc target, bool followVirtualDispatch);
    public ObjectNode GetFieldRvaData(FieldDesc field);
    public bool HasLazyStaticConstructor(TypeDesc type);
    public MethodDebugInformation GetDebugInfo(MethodIL methodIL);
    public MethodDesc ExpandIntrinsicForCallsite(MethodDesc intrinsicMethod, MethodDesc callsiteMethod);
    public bool HasFixedSlotVTable(TypeDesc type);
    public bool IsEffectivelySealed(TypeDesc type);
    public bool IsEffectivelySealed(MethodDesc method);
    public MethodDesc ResolveVirtualMethod(MethodDesc declMethod, TypeDesc implType);
    public bool NeedsRuntimeLookup(ReadyToRunHelperId lookupKind, object targetOfLookup);
    public ISymbolNode ComputeConstantLookup(ReadyToRunHelperId lookupKind, object targetOfLookup);
    public GenericDictionaryLookup ComputeGenericLookup(MethodDesc contextMethod, ReadyToRunHelperId lookupKind, object targetOfLookup);
    private sealed virtual override CompilationResults ILCompiler.ICompilation.Compile(string outputFile, ObjectDumper dumper);
}
public abstract class ILCompiler.CompilationBuilder : object {
    protected CompilerTypeSystemContext _context;
    protected CompilationModuleGroup _compilationGroup;
    protected NameMangler _nameMangler;
    protected Logger _logger;
    private DependencyTrackingLevel _dependencyTrackingLevel;
    protected IEnumerable`1<ICompilationRootProvider> _compilationRoots;
    protected OptimizationMode _optimizationMode;
    protected MetadataManager _metadataManager;
    protected VTableSliceProvider _vtableSliceProvider;
    protected DictionaryLayoutProvider _dictionaryLayoutProvider;
    protected DebugInformationProvider _debugInformationProvider;
    protected DevirtualizationManager _devirtualizationManager;
    public CompilationBuilder(CompilerTypeSystemContext context, CompilationModuleGroup compilationGroup, NameMangler nameMangler);
    public CompilationBuilder UseLogger(Logger logger);
    public CompilationBuilder UseDependencyTracking(DependencyTrackingLevel trackingLevel);
    public CompilationBuilder UseMetadataManager(MetadataManager metadataManager);
    public CompilationBuilder UseCompilationRoots(IEnumerable`1<ICompilationRootProvider> compilationRoots);
    public CompilationBuilder UseOptimizationMode(OptimizationMode mode);
    public CompilationBuilder UseVTableSliceProvider(VTableSliceProvider provider);
    public CompilationBuilder UseGenericDictionaryLayoutProvider(DictionaryLayoutProvider provider);
    public CompilationBuilder UseDevirtualizationManager(DevirtualizationManager manager);
    public CompilationBuilder UseDebugInfoProvider(DebugInformationProvider provider);
    public abstract virtual CompilationBuilder UseBackendOptions(IEnumerable`1<string> options);
    protected DependencyAnalyzerBase`1<NodeFactory> CreateDependencyGraph(NodeFactory factory, IComparer`1<DependencyNodeCore`1<NodeFactory>> comparer);
    public ILScannerBuilder GetILScannerBuilder(CompilationModuleGroup compilationGroup);
    public abstract virtual ICompilation ToCompilation();
}
public abstract class ILCompiler.CompilationModuleGroup : object {
    public bool IsSingleFileCompilation { get; }
    public bool CanHaveReferenceThroughImportTable { get; }
    public abstract virtual bool ContainsType(TypeDesc type);
    public abstract virtual bool ContainsTypeDictionary(TypeDesc type);
    public abstract virtual bool ContainsMethodBody(MethodDesc method, bool unboxingStub);
    public abstract virtual bool ContainsMethodDictionary(MethodDesc method);
    public abstract virtual bool ImportsMethod(MethodDesc method, bool unboxingStub);
    public abstract virtual ExportForm GetExportTypeForm(TypeDesc type);
    public abstract virtual ExportForm GetExportTypeFormDictionary(TypeDesc type);
    public abstract virtual ExportForm GetExportMethodForm(MethodDesc method, bool unboxingStub);
    public abstract virtual ExportForm GetExportMethodDictionaryForm(MethodDesc method);
    public abstract virtual bool get_IsSingleFileCompilation();
    public abstract virtual bool ShouldProduceFullVTable(TypeDesc type);
    public abstract virtual bool ShouldPromoteToFullType(TypeDesc type);
    public abstract virtual bool PresenceOfEETypeImpliesAllMethodsOnType(TypeDesc type);
    public abstract virtual bool ShouldReferenceThroughImportTable(TypeDesc type);
    public abstract virtual bool get_CanHaveReferenceThroughImportTable();
}
public class ILCompiler.CompilationResults : object {
    private DependencyAnalyzerBase`1<NodeFactory> _graph;
    private NodeFactory _factory;
    protected ImmutableArray`1<DependencyNodeCore`1<NodeFactory>> MarkedNodes { get; }
    public IEnumerable`1<MethodDesc> CompiledMethodBodies { get; }
    public IEnumerable`1<TypeDesc> ConstructedEETypes { get; }
    internal CompilationResults(DependencyAnalyzerBase`1<NodeFactory> graph, NodeFactory factory);
    protected ImmutableArray`1<DependencyNodeCore`1<NodeFactory>> get_MarkedNodes();
    public void WriteDependencyLog(string fileName);
    [IteratorStateMachineAttribute("ILCompiler.CompilationResults/<get_CompiledMethodBodies>d__7")]
public IEnumerable`1<MethodDesc> get_CompiledMethodBodies();
    [IteratorStateMachineAttribute("ILCompiler.CompilationResults/<get_ConstructedEETypes>d__9")]
public IEnumerable`1<TypeDesc> get_ConstructedEETypes();
}
public class ILCompiler.CompilerGeneratedInteropStubManager : InteropStubManager {
    internal HashSet`1<TypeDesc> _delegateMarshalingTypes;
    private HashSet`1<TypeDesc> _structMarshallingTypes;
    public CompilerGeneratedInteropStubManager(CompilationModuleGroup compilationModuleGroup, CompilerTypeSystemContext typeSystemContext, InteropStateManager interopStateManager);
    private MethodDesc GetOpenStaticDelegateMarshallingStub(TypeDesc delegateType);
    private MethodDesc GetClosedDelegateMarshallingStub(TypeDesc delegateType);
    private MethodDesc GetForwardDelegateCreationStub(TypeDesc delegateType);
    private MethodDesc GetStructMarshallingManagedToNativeStub(TypeDesc structType);
    private MethodDesc GetStructMarshallingNativeToManagedStub(TypeDesc structType);
    private MethodDesc GetStructMarshallingCleanupStub(TypeDesc structType);
    private TypeDesc GetInlineArrayType(InlineArrayCandidate candidate);
    [IteratorStateMachineAttribute("ILCompiler.CompilerGeneratedInteropStubManager/<GetDelegateMarshallingThunks>d__11")]
internal IEnumerable`1<DelegateMarshallingThunks> GetDelegateMarshallingThunks();
    [IteratorStateMachineAttribute("ILCompiler.CompilerGeneratedInteropStubManager/<GetStructMarshallingTypes>d__13")]
internal IEnumerable`1<StructMarshallingThunks> GetStructMarshallingTypes();
    private void AddDependenciesDueToPInvokeStructDelegateField(DependencyList& dependencies, NodeFactory factory, TypeDesc typeDesc);
    public virtual void AddDependeciesDueToPInvoke(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public virtual void AddInterestingInteropConstructedTypeDependencies(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public virtual void AddMarshalAPIsGenericDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    private void AddDependenciesDueToPInvokeDelegate(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    private void AddDependenciesDueToPInvokeStruct(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public virtual void AddToReadyToRunHeader(ReadyToRunHeaderNode header, NodeFactory nodeFactory, ExternalReferencesTableNode commonFixupsTableNode);
}
internal class ILCompiler.CompilerMetadataFieldLayoutAlgorithm : MetadataFieldLayoutAlgorithm {
    protected virtual void PrepareRuntimeSpecificStaticFieldLayout(TypeSystemContext context, ComputedStaticFieldLayout& layout);
    protected virtual void FinalizeRuntimeSpecificStaticFieldLayout(TypeSystemContext context, ComputedStaticFieldLayout& layout);
}
public class ILCompiler.CompilerTypeSystemContext : MetadataTypeSystemContext {
    private BoxedValuetypeHashtable _boxedValuetypeHashtable;
    private UnboxingThunkHashtable _unboxingThunkHashtable;
    private NonGenericUnboxingThunkHashtable _nonGenericUnboxingThunkHashtable;
    private MetadataFieldLayoutAlgorithm _metadataFieldLayoutAlgorithm;
    private RuntimeDeterminedFieldLayoutAlgorithm _runtimeDeterminedFieldLayoutAlgorithm;
    private VectorOfTFieldLayoutAlgorithm _vectorOfTFieldLayoutAlgorithm;
    private MetadataRuntimeInterfacesAlgorithm _metadataRuntimeInterfacesAlgorithm;
    private ArrayOfTRuntimeInterfacesAlgorithm _arrayOfTRuntimeInterfacesAlgorithm;
    private MetadataVirtualMethodAlgorithm _virtualMethodAlgorithm;
    private SimdHelper _simdHelper;
    private TypeDesc[] _arrayOfTInterfaces;
    private MetadataStringDecoder _metadataStringDecoder;
    private ModuleHashtable _moduleHashtable;
    private SimpleNameHashtable _simpleNameHashtable;
    private SharedGenericsMode _genericsMode;
    [CompilerGeneratedAttribute]
private SharedGenericsConfiguration <GenericsConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <InputFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <ReferenceFilePaths>k__BackingField;
    private bool _supportsLazyCctors;
    public SharedGenericsConfiguration GenericsConfig { get; }
    public IReadOnlyDictionary`2<string, string> InputFilePaths { get; public set; }
    public IReadOnlyDictionary`2<string, string> ReferenceFilePaths { get; public set; }
    public bool SupportsUniversalCanon { get; }
    public bool SupportsCanon { get; }
    public CompilerTypeSystemContext(TargetDetails details, SharedGenericsMode genericsMode);
    public MethodDesc GetSpecialUnboxingThunk(MethodDesc targetMethod, ModuleDesc ownerModuleOfThunk);
    public MethodDesc GetUnboxingThunk(MethodDesc targetMethod, ModuleDesc ownerModuleOfThunk);
    public bool IsSpecialUnboxingThunkTargetMethod(MethodDesc method);
    public MethodDesc GetRealSpecialUnboxingThunkTargetMethod(MethodDesc method);
    public bool IsSpecialUnboxingThunk(MethodDesc method);
    public MethodDesc GetTargetOfSpecialUnboxingThunk(MethodDesc method);
    [CompilerGeneratedAttribute]
public SharedGenericsConfiguration get_GenericsConfig();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_InputFilePaths();
    [CompilerGeneratedAttribute]
public void set_InputFilePaths(IReadOnlyDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_ReferenceFilePaths();
    [CompilerGeneratedAttribute]
public void set_ReferenceFilePaths(IReadOnlyDictionary`2<string, string> value);
    public virtual void SetSystemModule(ModuleDesc systemModule);
    public virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwIfNotFound);
    public ModuleDesc GetModuleForSimpleName(string simpleName, bool throwIfNotFound);
    public EcmaModule GetModuleFromPath(string filePath);
    public EcmaModule GetMetadataOnlyModuleFromPath(string filePath);
    private EcmaModule GetOrAddModuleFromPath(string filePath, bool useForBinding);
    public static PEReader OpenPEFile(string filePath, MemoryMappedViewAccessor& mappedViewAccessor);
    private EcmaModule AddModule(string filePath, string expectedSimpleName, bool useForBinding);
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    public bool IsGenericArrayInterfaceType(TypeDesc type);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected virtual IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    [IteratorStateMachineAttribute("ILCompiler.CompilerTypeSystemContext/<GetAllMethodsForDelegate>d__60")]
protected virtual IEnumerable`1<MethodDesc> GetAllMethodsForDelegate(TypeDesc type);
    protected virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    protected virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
    public virtual bool get_SupportsUniversalCanon();
    public virtual bool get_SupportsCanon();
    public sealed virtual MetadataStringDecoder GetMetadataStringDecoder();
    protected virtual bool ComputeHasGCStaticBase(FieldDesc field);
    private PdbSymbolReader OpenAssociatedSymbolFile(string peFilePath, PEReader peReader);
    public bool HasLazyStaticConstructor(TypeDesc type);
    public bool HasEagerStaticConstructor(TypeDesc type);
    private static bool HasEagerConstructorAttribute(TypeDesc type);
}
public class ILCompiler.CoreRTNameMangler : NameMangler {
    private SHA256 _sha256;
    private bool _mangleForCplusPlus;
    private string _compilationUnitPrefix;
    private ImmutableDictionary`2<TypeDesc, string> _mangledTypeNames;
    private ImmutableDictionary`2<MethodDesc, Utf8String> _mangledMethodNames;
    private ImmutableDictionary`2<MethodDesc, Utf8String> _unqualifiedMangledMethodNames;
    private ImmutableDictionary`2<FieldDesc, Utf8String> _mangledFieldNames;
    private ImmutableDictionary`2<string, string> _mangledStringLiterals;
    public string CompilationUnitPrefix { get; public set; }
    private string EnterNameScopeSequence { get; }
    private string ExitNameScopeSequence { get; }
    private string DelimitNameScopeSequence { get; }
    public CoreRTNameMangler(NodeMangler nodeMangler, bool mangleForCplusPlus);
    public virtual void set_CompilationUnitPrefix(string value);
    public virtual string get_CompilationUnitPrefix();
    public virtual string SanitizeName(string s, bool typeName);
    private static Byte[] GetBytesFromString(string literal);
    private string SanitizeNameWithHash(string literal);
    private string DisambiguateName(string origName, ISet`1<string> set);
    public virtual string GetMangledTypeName(TypeDesc type);
    private string get_EnterNameScopeSequence();
    private string get_ExitNameScopeSequence();
    private string get_DelimitNameScopeSequence();
    protected string NestMangledName(string name);
    private string ComputeMangledTypeName(TypeDesc type);
    public virtual Utf8String GetMangledMethodName(MethodDesc method);
    private Utf8String GetUnqualifiedMangledMethodName(MethodDesc method);
    private Utf8String GetPrefixMangledTypeName(IPrefixMangledType prefixMangledType);
    private Utf8String GetPrefixMangledSignatureName(IPrefixMangledSignature prefixMangledSignature);
    private Utf8String GetPrefixMangledMethodName(IPrefixMangledMethod prefixMangledMetod);
    private Utf8String ComputeUnqualifiedMangledMethodName(MethodDesc method);
    public virtual Utf8String GetMangledFieldName(FieldDesc field);
    private Utf8String ComputeMangledFieldName(FieldDesc field);
    public virtual string GetMangledStringName(string literal);
}
public class ILCompiler.DebugInformationProvider : object {
    public virtual MethodDebugInformation GetDebugInfo(MethodIL methodIL);
}
public class ILCompiler.DefaultDynamicInvokeThunkGenerationPolicy : DynamicInvokeThunkGenerationPolicy {
    public virtual bool HasStaticInvokeThunk(MethodDesc targetMethod);
}
public class ILCompiler.DelegateCreationInfo : object {
    private TargetKind _targetKind;
    [CompilerGeneratedAttribute]
private IMethodNode <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDesc <TargetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodNode <Thunk>k__BackingField;
    public IMethodNode Constructor { get; }
    public MethodDesc TargetMethod { get; }
    private bool TargetMethodIsUnboxingThunk { get; }
    public bool TargetNeedsVTableLookup { get; }
    public bool NeedsVirtualMethodUseTracking { get; }
    public bool NeedsRuntimeLookup { get; }
    public IMethodNode Thunk { get; }
    private DelegateCreationInfo(IMethodNode constructor, MethodDesc targetMethod, TargetKind targetKind, IMethodNode thunk);
    [CompilerGeneratedAttribute]
public IMethodNode get_Constructor();
    [CompilerGeneratedAttribute]
public MethodDesc get_TargetMethod();
    private bool get_TargetMethodIsUnboxingThunk();
    public bool get_TargetNeedsVTableLookup();
    public bool get_NeedsVirtualMethodUseTracking();
    public bool get_NeedsRuntimeLookup();
    public GenericLookupResult GetLookupKind(NodeFactory factory);
    public ISymbolNode GetTargetNode(NodeFactory factory);
    [CompilerGeneratedAttribute]
public IMethodNode get_Thunk();
    public static DelegateCreationInfo Create(TypeDesc delegateType, MethodDesc targetMethod, NodeFactory factory, bool followVirtualDispatch);
    public void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int CompareTo(DelegateCreationInfo other, TypeSystemComparer comparer);
}
public class ILCompiler.DependencyAnalysis.ARM.ARMEmitter : ValueType {
    public ObjectDataBuilder Builder;
    public TargetRegisterMap TargetRegister;
    public ARMEmitter(NodeFactory factory, bool relocsOnly);
    private static bool IsBitNumOverflow(int value, byte numBits);
    private static bool IsLowReg(Register reg);
    private static bool IsValidReg(Register reg);
    public void EmitMOV(Register reg, int immediate);
    public void EmitCMP(Register reg, int immediate);
    public void EmitADD(Register reg, int immediate);
    public void EmitSUB(Register reg, int immediate);
    public void EmitNOP();
    public void EmitDebugBreak();
    public void EmitPUSH(Register reg);
    public void EmitPOP(Register reg);
    public void EmitMOV(Register destination, Register source);
    public void EmitLDR(Register destination, Register source);
    public void EmitLDR(Register destination, Register source, int offset);
    public void EmitMOV(Register destination, ISymbolNode symbol);
    public void EmitJMP(ISymbolNode symbol);
    public void EmitJMP(Register destination);
    public void EmitRET();
    public void EmitBNE(int immediate);
    public void EmitBEQ(int immediate);
    public void EmitRETIfEqual();
}
public enum ILCompiler.DependencyAnalysis.ARM.Register : Enum {
    public int value__;
    public static Register R0;
    public static Register R1;
    public static Register R2;
    public static Register R3;
    public static Register R4;
    public static Register R5;
    public static Register R6;
    public static Register R7;
    public static Register R8;
    public static Register R9;
    public static Register R10;
    public static Register R11;
    public static Register R12;
    public static Register R13;
    public static Register R14;
    public static Register R15;
    public static Register None;
    public static Register RegDirect;
    public static Register NoIndex;
}
public class ILCompiler.DependencyAnalysis.ARM.TargetRegisterMap : ValueType {
    public Register Arg0;
    public Register Arg1;
    public Register Arg2;
    public Register Arg3;
    public Register Result;
    public Register InterproceduralScratch;
    public Register SP;
    public Register LR;
    public Register PC;
    public TargetRegisterMap(TargetOS os);
}
public class ILCompiler.DependencyAnalysis.ARM64.AddrMode : ValueType {
    public Register BaseReg;
    public Nullable`1<Register> IndexReg;
    public int Offset;
    public byte Scale;
    public AddrModeSize Size;
    public AddrMode(Register baseRegister, Nullable`1<Register> indexRegister, int offset, byte scale, AddrModeSize size);
}
public enum ILCompiler.DependencyAnalysis.ARM64.AddrModeSize : Enum {
    public int value__;
    public static AddrModeSize Int8;
    public static AddrModeSize Int16;
    public static AddrModeSize Int32;
    public static AddrModeSize Int64;
    public static AddrModeSize Int128;
}
public class ILCompiler.DependencyAnalysis.ARM64.ARM64Emitter : ValueType {
    public ObjectDataBuilder Builder;
    public TargetRegisterMap TargetRegister;
    public ARM64Emitter(NodeFactory factory, bool relocsOnly);
    public void EmitMOV(Register regDst, AddrMode& memory);
    public void EmitMOV(Register regDst, Register regSrc);
    public void EmitMOV(Register regDst, int imm32);
    public void EmitLEAQ(Register reg, ISymbolNode symbol, int delta);
    public void EmitLEA(Register reg, AddrMode& addrMode);
    public void EmitCMP(AddrMode& addrMode, sbyte immediate);
    public void EmitADD(Register reg, byte immediate);
    public void EmitJMP(ISymbolNode symbol);
    public void EmitINT3();
    public void EmitJmpToAddrMode(AddrMode& addrMode);
    public void EmitRET();
    public void EmitRETIfEqual();
    private bool InSignedByteRange(int i);
}
public enum ILCompiler.DependencyAnalysis.ARM64.Register : Enum {
    public int value__;
    public static Register X0;
    public static Register X1;
    public static Register X2;
    public static Register X3;
    public static Register X4;
    public static Register X5;
    public static Register X6;
    public static Register X7;
    public static Register X8;
    public static Register X9;
    public static Register X10;
    public static Register X11;
    public static Register X12;
    public static Register X13;
    public static Register X14;
    public static Register X15;
    public static Register X16;
    public static Register X17;
    public static Register X18;
    public static Register X19;
    public static Register X20;
    public static Register X21;
    public static Register X22;
    public static Register X23;
    public static Register X24;
    public static Register X25;
    public static Register X26;
    public static Register X27;
    public static Register X28;
    public static Register X29;
    public static Register X30;
    public static Register X31;
    public static Register None;
    public static Register NoIndex;
}
public class ILCompiler.DependencyAnalysis.ARM64.TargetRegisterMap : ValueType {
    public Register Arg0;
    public Register Arg1;
    public Register Arg2;
    public Register Arg3;
    public Register Arg4;
    public Register Arg5;
    public Register Arg6;
    public Register Arg7;
    public Register Result;
    public TargetRegisterMap(TargetOS os);
}
public static class ILCompiler.DependencyAnalysis.ARMDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void EmitNYIAssert(NodeFactory factory, ARMEmitter& encoder, string message, string sourceFilePath, string memberName, int sourceLineNumber);
    [ConditionalAttribute("DEBUG")]
public static void EmitHelperNYIAssert(NodeFactory factory, ARMEmitter& encoder, ReadyToRunHelperId hId, string sourceFilePath, string memberName, int sourceLineNumber);
}
internal class ILCompiler.DependencyAnalysis.ArrayAllocatorGenericLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public ArrayAllocatorGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.ArrayMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ArrayMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ArrayOfEmbeddedDataNode`1 : EmbeddedDataContainerNode {
    private HashSet`1<TEmbedded> _nestedNodes;
    private List`1<TEmbedded> _nestedNodesList;
    private IComparer`1<TEmbedded> _sorter;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected IEnumerable`1<TEmbedded> NodesList { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ArrayOfEmbeddedDataNode`1(string startSymbolMangledName, string endSymbolMangledName, IComparer`1<TEmbedded> nodeSorter);
    public void AddEmbeddedObject(TEmbedded symbol);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    protected IEnumerable`1<TEmbedded> get_NodesList();
    protected virtual void GetElementDataForNodes(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ArrayOfEmbeddedPointersNode`1 : ArrayOfEmbeddedDataNode`1<EmbeddedPointerIndirectionNode`1<TTarget>> {
    private int _nextId;
    private string _startSymbolMangledName;
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ArrayOfEmbeddedPointersNode`1(string startSymbolMangledName, string endSymbolMangledName, IComparer`1<TTarget> nodeSorter);
    public EmbeddedObjectNode NewNode(TTarget target);
    public EmbeddedObjectNode NewNodeWithSymbol(TTarget target);
    private int GetNextId();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ArrayOfFrozenObjectsNode`1 : ArrayOfEmbeddedDataNode`1<TEmbedded> {
    public int ClassCode { get; }
    public ArrayOfFrozenObjectsNode`1(string startSymbolMangledName, string endSymbolMangledName, IComparer`1<TEmbedded> nodeSorter);
    private void AlignNextObject(ObjectDataBuilder& builder, NodeFactory factory);
    protected virtual void GetElementDataForNodes(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
}
public abstract class ILCompiler.DependencyAnalysis.AssemblyStubNode : ObjectNode {
    protected bool IsVisibleFromManagedCode { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    protected virtual bool get_IsVisibleFromManagedCode();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public abstract virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected abstract virtual void EmitCode(NodeFactory factory, X64Emitter& instructionEncoder, bool relocsOnly);
    protected abstract virtual void EmitCode(NodeFactory factory, X86Emitter& instructionEncoder, bool relocsOnly);
    protected abstract virtual void EmitCode(NodeFactory factory, ARMEmitter& instructionEncoder, bool relocsOnly);
    protected abstract virtual void EmitCode(NodeFactory factory, ARM64Emitter& instructionEncoder, bool relocsOnly);
}
[FlagsAttribute]
public enum ILCompiler.DependencyAnalysis.AssociatedDataFlags : Enum {
    public byte value__;
    public static AssociatedDataFlags None;
    public static AssociatedDataFlags HasUnboxingStubTarget;
}
public class ILCompiler.DependencyAnalysis.BlobNode : ObjectNode {
    private Utf8String _name;
    private ObjectNodeSection _section;
    private Byte[] _data;
    private int _alignment;
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public BlobNode(Utf8String name, ObjectNodeSection section, Byte[] data, int alignment);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.BlockReflectionTypeMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public BlockReflectionTypeMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.CallingConventionConverterKey : ValueType {
    [CompilerGeneratedAttribute]
private CallingConventionConverterKind <ConverterKind>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSignature <Signature>k__BackingField;
    public CallingConventionConverterKind ConverterKind { get; }
    public MethodSignature Signature { get; }
    public CallingConventionConverterKey(CallingConventionConverterKind converterKind, MethodSignature signature);
    [CompilerGeneratedAttribute]
public CallingConventionConverterKind get_ConverterKind();
    [CompilerGeneratedAttribute]
public MethodSignature get_Signature();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CallingConventionConverterKey other);
    public virtual int GetHashCode();
    public string GetName();
}
internal class ILCompiler.DependencyAnalysis.CallingConventionConverterLookupResult : GenericLookupResult {
    private CallingConventionConverterKey _callingConventionConverter;
    protected int ClassCode { get; }
    public CallingConventionConverterLookupResult(CallingConventionConverterKey callingConventionConverter);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.CanonicalDefinitionEETypeNode : EETypeNode {
    public bool StaticDependenciesAreComputed { get; }
    public bool IsShareable { get; }
    protected int GCDescSize { get; }
    protected int BaseSize { get; }
    public int ClassCode { get; }
    public CanonicalDefinitionEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual bool get_IsShareable();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    protected virtual int get_GCDescSize();
    protected internal virtual void ComputeOptionalEETypeFields(NodeFactory factory, bool relocsOnly);
    protected virtual int get_BaseSize();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.CanonicalEETypeNode : EETypeNode {
    public bool StaticDependenciesAreComputed { get; }
    public bool IsShareable { get; }
    protected bool EmitVirtualSlotsAndInterfaces { get; }
    protected int GCDescSize { get; }
    protected int BaseSize { get; }
    public int ClassCode { get; }
    public CanonicalEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual bool get_IsShareable();
    protected virtual bool get_EmitVirtualSlotsAndInterfaces();
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    protected virtual ISymbolNode GetBaseTypeNode(NodeFactory factory);
    protected virtual int get_GCDescSize();
    protected virtual void OutputGCDesc(ObjectDataBuilder& builder);
    protected virtual void OutputInterfaceMap(NodeFactory factory, ObjectDataBuilder& objData);
    protected virtual int get_BaseSize();
    protected virtual void ComputeValueTypeFieldPadding();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.CastClassGenericLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public CastClassGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.ClassConstructorContextMap : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ClassConstructorContextMap(ExternalReferencesTableNode externalReferences);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.ClonedConstructedEETypeNode : ConstructedEETypeNode {
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public ClonedConstructedEETypeNode(NodeFactory factory, TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    public virtual ISymbolNode NodeForLinkage(NodeFactory factory);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual bool get_IsShareable();
    protected virtual void OutputRelatedType(NodeFactory factory, ObjectDataBuilder& objData);
    public virtual int get_ClassCode();
}
public static class ILCompiler.DependencyAnalysis.CodeBasedDependencyAlgorithm : object {
    public static void AddDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public static void AddDependenciesDueToMethodCodePresence(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
}
public class ILCompiler.DependencyAnalysis.CompilerComparer : TypeSystemComparer {
    public sealed virtual int Compare(ISortableNode x, ISortableNode y);
}
internal class ILCompiler.DependencyAnalysis.ConstrainedMethodUseLookupResult : GenericLookupResult {
    private MethodDesc _constrainedMethod;
    private TypeDesc _constraintType;
    private bool _directCall;
    protected int ClassCode { get; }
    public ConstrainedMethodUseLookupResult(MethodDesc constrainedMethod, TypeDesc constraintType, bool directCall);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.ConstructedEETypeNode : EETypeNode {
    protected bool EmitVirtualSlotsAndInterfaces { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    protected int GCDescSize { get; }
    public int ClassCode { get; }
    public ConstructedEETypeNode(NodeFactory factory, TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    protected virtual bool get_EmitVirtualSlotsAndInterfaces();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    protected virtual ISymbolNode GetBaseTypeNode(NodeFactory factory);
    protected virtual IEETypeNode GetInterfaceTypeNode(NodeFactory factory, TypeDesc interfaceType);
    protected virtual int get_GCDescSize();
    protected virtual void OutputGCDesc(ObjectDataBuilder& builder);
    public static bool CreationAllowed(TypeDesc type);
    public static void CheckCanGenerateConstructedEEType(NodeFactory factory, TypeDesc type);
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.CustomAttributeBasedDependencyAlgorithm : object {
    public static void AddDependenciesDueToCustomAttributes(DependencyList& dependencies, NodeFactory factory, EcmaMethod method);
    public static void AddDependenciesDueToCustomAttributes(DependencyList& dependencies, NodeFactory factory, EcmaType type);
    public static void AddDependenciesDueToCustomAttributes(DependencyList& dependencies, NodeFactory factory, EcmaField field);
    public static void AddDependenciesDueToCustomAttributes(DependencyList& dependencies, NodeFactory factory, EcmaAssembly assembly);
    private static void AddDependenciesDueToCustomAttributes(DependencyList& dependencies, NodeFactory factory, EcmaModule module, CustomAttributeHandleCollection attributeHandles);
    private static bool AddDependenciesFromCustomAttributeBlob(DependencyList<NodeFactory> dependencies, NodeFactory factory, TypeDesc attributeType, CustomAttributeValue`1<TypeDesc> value);
    private static bool AddDependenciesFromPropertySetter(DependencyList<NodeFactory> dependencies, NodeFactory factory, TypeDesc attributeType, string propertyName);
    private static bool AddDependenciesFromCustomAttributeArgument(DependencyList<NodeFactory> dependencies, NodeFactory factory, TypeDesc type, object value);
}
public class ILCompiler.DependencyAnalysis.DebugEHClauseInfo : ValueType {
    public UInt32 TryOffset;
    public UInt32 TryLength;
    public UInt32 HandlerOffset;
    public UInt32 HandlerLength;
    public DebugEHClauseInfo(UInt32 tryOffset, UInt32 tryLength, UInt32 handlerOffset, UInt32 handlerLength);
}
public class ILCompiler.DependencyAnalysis.DebugLocInfo : ValueType {
    public int NativeOffset;
    public string FileName;
    public int LineNumber;
    public int ColNumber;
    public DebugLocInfo(int nativeOffset, string fileName, int lineNumber, int colNumber);
}
public class ILCompiler.DependencyAnalysis.DebugVarInfo : ValueType {
    public string Name;
    public bool IsParam;
    public TypeDesc Type;
    public List`1<NativeVarInfo> Ranges;
    public DebugVarInfo(string name, bool isParam, TypeDesc type);
}
internal class ILCompiler.DependencyAnalysis.DefaultConstructorLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public DefaultConstructorLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.DefaultConstructorMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public DefaultConstructorMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
}
internal class ILCompiler.DependencyAnalysis.DelegateMarshallingStubMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public DelegateMarshallingStubMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public abstract class ILCompiler.DependencyAnalysis.DictionaryLayoutNode : DependencyNodeCore`1<NodeFactory> {
    private TypeSystemEntity _owningMethodOrType;
    public IEnumerable`1<GenericLookupResult> Entries { get; }
    public IEnumerable`1<GenericLookupResult> FixedEntries { get; }
    public TypeSystemEntity OwningMethodOrType { get; }
    public bool HasFixedSlots { get; }
    public bool HasUnfixedSlots { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    public DictionaryLayoutNode(TypeSystemEntity owningMethodOrType);
    [ConditionalAttribute("DEBUG")]
private void Validate();
    public virtual ObjectNodeSection DictionarySection(NodeFactory factory);
    public abstract virtual void EnsureEntry(GenericLookupResult entry);
    public abstract virtual int GetSlotForEntry(GenericLookupResult entry);
    public virtual int GetSlotForFixedEntry(GenericLookupResult entry);
    public abstract virtual IEnumerable`1<GenericLookupResult> get_Entries();
    public virtual IEnumerable`1<GenericLookupResult> get_FixedEntries();
    public TypeSystemEntity get_OwningMethodOrType();
    public abstract virtual bool get_HasFixedSlots();
    public virtual bool get_HasUnfixedSlots();
    public virtual ICollection`1<NativeLayoutVertexNode> GetTemplateEntries(NodeFactory factory);
    public virtual void EmitDictionaryData(ObjectDataBuilder& builder, NodeFactory factory, GenericDictionaryNode dictionary, bool fixedLayoutOnly);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.DictionaryLayoutNode/<GetStaticDependencies>d__19")]
public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.DynamicInvokeTemplateDataNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    private Dictionary`2<MethodDesc, int> _methodToTemplateIndex;
    private TypeDesc _dynamicInvokeMethodContainerType;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public DynamicInvokeTemplateDataNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    public int GetIdForMethod(MethodDesc dynamicInvokeMethod);
    public void AddDependenciesDueToInvokeTemplatePresence(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.EagerlyBuiltVTableSliceNode : PrecomputedVTableSliceNode {
    public EagerlyBuiltVTableSliceNode(TypeDesc type);
    private static IReadOnlyList`1<MethodDesc> ComputeSlots(TypeDesc type);
}
public class ILCompiler.DependencyAnalysis.EETypeNode : ObjectNode {
    protected TypeDesc _type;
    internal EETypeOptionalFieldsBuilder _optionalFieldsBuilder;
    internal EETypeOptionalFieldsNode _optionalFieldsNode;
    public TypeDesc Type { get; }
    public ObjectNodeSection Section { get; }
    public int MinimumObjectSize { get; }
    protected bool EmitVirtualSlotsAndInterfaces { get; }
    internal bool HasOptionalFields { get; }
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool IsShareable { get; }
    private bool CanonFormTypeMayExist { get; }
    public bool HasConditionalStaticDependencies { get; }
    protected int GCDescSize { get; }
    protected int BaseSize { get; }
    public int ClassCode { get; }
    public EETypeNode(NodeFactory factory, TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    public virtual ISymbolNode NodeForLinkage(NodeFactory factory);
    public sealed virtual ExportForm GetExportForm(NodeFactory factory);
    public sealed virtual TypeDesc get_Type();
    public virtual ObjectNodeSection get_Section();
    public int get_MinimumObjectSize();
    protected virtual bool get_EmitVirtualSlotsAndInterfaces();
    internal bool get_HasOptionalFields();
    internal Byte[] GetOptionalFieldsData();
    public virtual bool get_StaticDependenciesAreComputed();
    public static string GetMangledName(TypeDesc type, NameMangler nameMangler);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public virtual bool get_IsShareable();
    private bool get_CanonFormTypeMayExist();
    public sealed virtual bool get_HasConditionalStaticDependencies();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.EETypeNode/<GetConditionalStaticDependencies>d__33")]
public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public static bool IsTypeNodeShareable(TypeDesc type);
    private void AddVirtualMethodUseDependencies(DependencyList<NodeFactory> dependencyList, NodeFactory factory);
    internal static bool MethodHasNonGenericILMethodBody(MethodDesc method);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public static int GetVTableOffset(int pointerSize);
    protected virtual int get_GCDescSize();
    protected virtual void OutputGCDesc(ObjectDataBuilder& builder);
    private void OutputComponentSize(ObjectDataBuilder& objData);
    private void OutputFlags(NodeFactory factory, ObjectDataBuilder& objData);
    protected virtual int get_BaseSize();
    protected static TypeDesc GetFullCanonicalTypeForCanonicalType(TypeDesc type);
    protected virtual ISymbolNode GetBaseTypeNode(NodeFactory factory);
    private ISymbolNode GetRelatedTypeNode(NodeFactory factory);
    protected virtual void OutputRelatedType(NodeFactory factory, ObjectDataBuilder& objData);
    private void OutputVirtualSlots(NodeFactory factory, ObjectDataBuilder& objData, TypeDesc implType, TypeDesc declType, TypeDesc templateType, bool relocsOnly);
    protected virtual IEETypeNode GetInterfaceTypeNode(NodeFactory factory, TypeDesc interfaceType);
    protected virtual void OutputInterfaceMap(NodeFactory factory, ObjectDataBuilder& objData);
    private void OutputFinalizerMethod(NodeFactory factory, ObjectDataBuilder& objData);
    private void OutputOptionalFields(NodeFactory factory, ObjectDataBuilder& objData);
    private void OutputNullableTypeParameter(NodeFactory factory, ObjectDataBuilder& objData);
    private void OutputSealedVTable(NodeFactory factory, bool relocsOnly, ObjectDataBuilder& objData);
    private void OutputGenericInstantiationDetails(NodeFactory factory, ObjectDataBuilder& objData);
    protected internal virtual void ComputeOptionalEETypeFields(NodeFactory factory, bool relocsOnly);
    private void ComputeRareFlags(NodeFactory factory, bool relocsOnly);
    private void ComputeNullableValueOffset();
    protected virtual void ComputeICastableVirtualMethodSlots(NodeFactory factory);
    protected virtual void ComputeValueTypeFieldPadding();
    protected virtual void OnMarked(NodeFactory context);
    public static void CheckCanGenerateEEType(NodeFactory factory, TypeDesc type);
    public static void AddDependenciesForStaticsNode(NodeFactory factory, TypeDesc type, DependencyList& dependencies);
    protected static void AddDependenciesForUniversalGVMSupport(NodeFactory factory, TypeDesc type, DependencyList& dependencies);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.EETypeOptionalFieldsNode : ObjectNode {
    private EETypeNode _owner;
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public EETypeOptionalFieldsNode(EETypeNode owner);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public abstract class ILCompiler.DependencyAnalysis.EmbeddedDataContainerNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _startSymbol;
    private ObjectAndOffsetSymbolNode _endSymbol;
    private string _startSymbolMangledName;
    public ObjectAndOffsetSymbolNode StartSymbol { get; }
    public ObjectAndOffsetSymbolNode EndSymbol { get; }
    public int ClassCode { get; }
    protected EmbeddedDataContainerNode(string startSymbolMangledName, string endSymbolMangledName);
    public sealed virtual ObjectAndOffsetSymbolNode get_StartSymbol();
    public ObjectAndOffsetSymbolNode get_EndSymbol();
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public abstract class ILCompiler.DependencyAnalysis.EmbeddedObjectNode : SortableDependencyNode {
    private static int InvalidOffset;
    private int _offset;
    private int _index;
    [CompilerGeneratedAttribute]
private IHasStartSymbol <ContainingNode>k__BackingField;
    public IHasStartSymbol ContainingNode { get; public set; }
    public int OffsetFromBeginningOfArray { get; }
    public int IndexFromBeginningOfArray { get; }
    public bool IsShareable { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    [CompilerGeneratedAttribute]
public IHasStartSymbol get_ContainingNode();
    [CompilerGeneratedAttribute]
public void set_ContainingNode(IHasStartSymbol value);
    public int get_OffsetFromBeginningOfArray();
    public int get_IndexFromBeginningOfArray();
    internal void InitializeOffsetFromBeginningOfArray(int offset);
    internal void InitializeIndexFromBeginningOfArray(int index);
    public virtual bool get_IsShareable();
    public virtual bool get_RepresentsIndirectionCell();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public abstract virtual void EncodeData(ObjectDataBuilder& dataBuilder, NodeFactory factory, bool relocsOnly);
}
public abstract class ILCompiler.DependencyAnalysis.EmbeddedPointerIndirectionNode`1 : EmbeddedObjectNode {
    private TTarget _targetNode;
    public TTarget Target { get; }
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    public int ClassCode { get; }
    internal EmbeddedPointerIndirectionNode`1(TTarget target);
    public TTarget get_Target();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual void EncodeData(ObjectDataBuilder& dataBuilder, NodeFactory factory, bool relocsOnly);
    public abstract virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.ExactMethodInstantiationsNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ExactMethodInstantiationsNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public static void GetExactMethodInstantiationDependenciesForMethod(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    private static bool IsMethodEligibleForTracking(MethodDesc method);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ExternalReferencesTableNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private string _blobName;
    private NodeFactory _nodeFactory;
    private Dictionary`2<SymbolAndDelta, UInt32> _insertedSymbolsDictionary;
    private List`1<SymbolAndDelta> _insertedSymbols;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ExternalReferencesTableNode(string blobName, NodeFactory nodeFactory);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public UInt32 GetIndex(ISymbolNode symbol, int delta);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.ExternEETypeSymbolNode : ExternSymbolNode {
    private TypeDesc _type;
    public TypeDesc Type { get; }
    public ExternEETypeSymbolNode(NodeFactory factory, TypeDesc type);
    public sealed virtual TypeDesc get_Type();
}
public class ILCompiler.DependencyAnalysis.ExternMethodSymbolNode : ExternSymbolNode {
    private MethodDesc _method;
    public MethodDesc Method { get; }
    public int ClassCode { get; }
    public ExternMethodSymbolNode(NodeFactory factory, MethodDesc method, bool isUnboxing);
    public sealed virtual MethodDesc get_Method();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ExternSymbolNode : SortableDependencyNode {
    private Utf8String _name;
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public ExternSymbolNode(Utf8String name);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_RepresentsIndirectionCell();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.ExternSymbolsImportedNodeProvider : ImportedNodeProvider {
    public virtual IEETypeNode ImportedEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedNonGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticOffsetNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticIndexNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedTypeDictionaryNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedMethodDictionaryNode(NodeFactory factory, MethodDesc method);
    public virtual IMethodNode ImportedMethodCodeNode(NodeFactory factory, MethodDesc method, bool unboxingStub);
}
public class ILCompiler.DependencyAnalysis.ExternSymbolsWithIndirectionImportedNodeProvider : ImportedNodeProvider {
    public virtual IEETypeNode ImportedEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedNonGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticOffsetNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticIndexNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedTypeDictionaryNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedMethodDictionaryNode(NodeFactory factory, MethodDesc method);
    public virtual IMethodNode ImportedMethodCodeNode(NodeFactory factory, MethodDesc method, bool unboxingStub);
}
public class ILCompiler.DependencyAnalysis.FatFunctionPointerNode : ObjectNode {
    private bool _isUnboxingStub;
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    public bool IsShareable { get; }
    public MethodDesc Method { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public FatFunctionPointerNode(MethodDesc methodRepresented, bool isUnboxingStub);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    public virtual bool get_IsShareable();
    [CompilerGeneratedAttribute]
public sealed virtual MethodDesc get_Method();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.FieldHandleGenericLookupResult : GenericLookupResult {
    private FieldDesc _field;
    protected int ClassCode { get; }
    public FieldHandleGenericLookupResult(FieldDesc field);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.FieldMetadataNode : DependencyNodeCore`1<NodeFactory> {
    private FieldDesc _field;
    public FieldDesc Field { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool StaticDependenciesAreComputed { get; }
    public FieldMetadataNode(FieldDesc field);
    public FieldDesc get_Field();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.FieldOffsetGenericLookupResult : GenericLookupResult {
    private FieldDesc _field;
    protected int ClassCode { get; }
    public FieldOffsetGenericLookupResult(FieldDesc field);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.FrameInfo : ValueType {
    public FrameInfoFlags Flags;
    public int StartOffset;
    public int EndOffset;
    public Byte[] BlobData;
    public FrameInfo(FrameInfoFlags flags, int startOffset, int endOffset, Byte[] blobData);
}
[FlagsAttribute]
public enum ILCompiler.DependencyAnalysis.FrameInfoFlags : Enum {
    public int value__;
    public static FrameInfoFlags Handler;
    public static FrameInfoFlags Filter;
    public static FrameInfoFlags HasEHInfo;
    public static FrameInfoFlags ReversePInvoke;
    public static FrameInfoFlags HasAssociatedData;
}
public class ILCompiler.DependencyAnalysis.FrozenArrayNode : EmbeddedObjectNode {
    private PreInitFieldInfo _preInitFieldInfo;
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public int ClassCode { get; }
    public FrozenArrayNode(PreInitFieldInfo preInitFieldInfo);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual bool get_StaticDependenciesAreComputed();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    private IEETypeNode GetEETypeNode(NodeFactory factory);
    public virtual void EncodeData(ObjectDataBuilder& dataBuilder, NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.FrozenStringNode : EmbeddedObjectNode {
    private string _data;
    private int _syncBlockSize;
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public int ClassCode { get; }
    public FrozenStringNode(string data, TargetDetails target);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual bool get_StaticDependenciesAreComputed();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    private static IEETypeNode GetEETypeNode(NodeFactory factory);
    public virtual void EncodeData(ObjectDataBuilder& dataBuilder, NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.GCStaticDescNode : EmbeddedObjectNode {
    private MetadataType _type;
    private GCPointerMap _gcMap;
    private bool _isThreadStatic;
    public int NumSeries { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public GCStaticDescNode(MetadataType type, bool isThreadStatic);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public static string GetMangledName(NameMangler nameMangler, MetadataType type, bool isThreadStatic);
    public int get_NumSeries();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    private GCStaticDescRegionNode Region(NodeFactory factory);
    private ISymbolNode GCStaticsSymbol(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual void EncodeData(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    internal int CompareTo(GCStaticDescNode other, TypeSystemComparer comparer);
    public sealed virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.GCStaticDescRegionNode : ArrayOfEmbeddedDataNode`1<GCStaticDescNode> {
    public int ClassCode { get; }
    public GCStaticDescRegionNode(string startSymbolMangledName, string endSymbolMangledName, IComparer`1<GCStaticDescNode> nodeSorter);
    public virtual int get_ClassCode();
    protected virtual void GetElementDataForNodes(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
}
internal class ILCompiler.DependencyAnalysis.GCStaticEETypeNode : ObjectNode {
    private GCPointerMap _gcMap;
    private TargetDetails _target;
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public GCStaticEETypeNode(TargetDetails target, GCPointerMap gcMap);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.GCStaticsNode : ObjectNode {
    private MetadataType _type;
    private List`1<PreInitFieldInfo> _preInitFieldInfos;
    public int Offset { get; }
    public MetadataType Type { get; }
    public IDebugInfo DebugInfo { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public GCStaticsNode(MetadataType type);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public MetadataType get_Type();
    public sealed virtual IDebugInfo get_DebugInfo();
    public static string GetMangledName(TypeDesc type, NameMangler nameMangler);
    public virtual ExportForm GetExportForm(NodeFactory factory);
    private ISymbolNode GetGCStaticEETypeNode(NodeFactory factory);
    public GCStaticsPreInitDataNode NewPreInitDataNode();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.GCStaticsPreInitDataNode : ObjectNode {
    private MetadataType _type;
    private List`1<PreInitFieldInfo> _sortedPreInitFields;
    public int Offset { get; }
    public MetadataType Type { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public GCStaticsPreInitDataNode(MetadataType type, List`1<PreInitFieldInfo> preInitFields);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public MetadataType get_Type();
    public static string GetMangledName(TypeDesc type, NameMangler nameMangler);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public static ObjectData GetDataForPreInitDataField(ISymbolDefinitionNode node, MetadataType _type, List`1<PreInitFieldInfo> sortedPreInitFields, int startOffset, NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.GenericCompositionDetails : ValueType {
    public Instantiation Instantiation;
    public GenericVariance[] Variance;
    public GenericCompositionDetails(TypeDesc genericTypeInstance, bool forceVarianceInfo);
    public GenericCompositionDetails(Instantiation instantiation, GenericVariance[] variance);
    public sealed virtual bool Equals(GenericCompositionDetails other);
    public int CompareToImpl(GenericCompositionDetails other, TypeSystemComparer comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ILCompiler.DependencyAnalysis.GenericCompositionNode : ObjectNode {
    private GenericCompositionDetails _details;
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    internal GenericCompositionNode(GenericCompositionDetails details);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.GenericDefinitionEETypeNode : EETypeNode {
    public int ClassCode { get; }
    public GenericDefinitionEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    protected internal virtual void ComputeOptionalEETypeFields(NodeFactory factory, bool relocsOnly);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
}
public abstract class ILCompiler.DependencyAnalysis.GenericDictionaryNode : ObjectNode {
    private NodeFactory _factory;
    protected TypeSystemContext Context { get; }
    public TypeSystemEntity OwningEntity { get; }
    public Instantiation TypeInstantiation { get; }
    public Instantiation MethodInstantiation { get; }
    public bool StaticDependenciesAreComputed { get; }
    public bool IsShareable { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    protected int HeaderSize { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public ObjectNodeSection Section { get; }
    public int ClassCode { get; }
    public GenericDictionaryNode(NodeFactory factory);
    protected abstract virtual TypeSystemContext get_Context();
    public abstract virtual TypeSystemEntity get_OwningEntity();
    public abstract virtual Instantiation get_TypeInstantiation();
    public abstract virtual Instantiation get_MethodInstantiation();
    public abstract virtual DictionaryLayoutNode GetDictionaryLayout(NodeFactory factory);
    public sealed virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual bool get_IsShareable();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    public abstract virtual ExportForm GetExportForm(NodeFactory factory);
    public abstract virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected abstract virtual int get_HeaderSize();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public virtual ObjectNodeSection get_Section();
    public sealed virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual void EmitDataInternal(ObjectDataBuilder& builder, NodeFactory factory, bool fixedLayoutOnly);
    protected sealed virtual string GetName(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public abstract class ILCompiler.DependencyAnalysis.GenericLookupResult : object {
    protected int ClassCode { get; }
    protected abstract virtual int get_ClassCode();
    public abstract virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public abstract virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public abstract virtual string ToString();
    protected abstract virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected abstract virtual bool EqualsImpl(GenericLookupResult obj);
    protected abstract virtual int GetHashCodeImpl();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public abstract virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public abstract virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    public virtual IEnumerable`1<DependencyNodeCore`1<NodeFactory>> NonRelocDependenciesFromUsage(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.GenericLookupResultContext : ValueType {
    private TypeSystemEntity _canonicalOwner;
    public Instantiation TypeInstantiation;
    public Instantiation MethodInstantiation;
    public TypeSystemEntity Context { get; }
    public GenericLookupResultContext(TypeSystemEntity canonicalOwner, Instantiation typeInst, Instantiation methodInst);
    public TypeSystemEntity get_Context();
}
public enum ILCompiler.DependencyAnalysis.GenericLookupResultReferenceType : Enum {
    public int value__;
    public static GenericLookupResultReferenceType Direct;
    public static GenericLookupResultReferenceType Indirect;
    public static GenericLookupResultReferenceType ConditionalIndirect;
}
internal class ILCompiler.DependencyAnalysis.GenericMethodsHashtableNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public GenericMethodsHashtableNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public static void GetGenericMethodsHashtableDependenciesForMethod(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.GenericMethodsTemplateMap : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public GenericMethodsTemplateMap(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public static void GetTemplateMethodDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    private static bool IsEligibleToBeATemplate(MethodDesc method);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.GenericTypesHashtableNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public GenericTypesHashtableNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.GenericTypesTemplateMap : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public GenericTypesTemplateMap(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public static void GetTemplateTypeDependencies(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public static TypeDesc ConvertArrayOfTToRegularArray(NodeFactory factory, TypeDesc type);
    public static bool IsArrayTypeEligibleForTemplate(TypeDesc type);
    public static bool IsEligibleToHaveATemplate(TypeDesc type);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.GenericVirtualMethodTableNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    private Dictionary`2<MethodDesc, Dictionary`2<TypeDesc, MethodDesc>> _gvmImplemenations;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public GenericVirtualMethodTableNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public static void GetGenericVirtualMethodImplementationDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc callingMethod, MethodDesc implementationMethod);
    private void AddGenericVirtualMethodImplementation(NodeFactory factory, MethodDesc callingMethod, MethodDesc implementationMethod);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.GVMDependenciesNode : DependencyNodeCore`1<NodeFactory> {
    private static int UniversalCanonGVMDepthHeuristic_NonCanonDepth;
    private static int UniversalCanonGVMDepthHeuristic_CanonDepth;
    private MethodDesc _method;
    public MethodDesc Method { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    public bool HasDynamicDependencies { get; }
    public GVMDependenciesNode(MethodDesc method);
    public MethodDesc get_Method();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory context);
    public virtual bool get_HasDynamicDependencies();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
public enum ILCompiler.DependencyAnalysis.HelperEntrypoint : Enum {
    public int value__;
    public static HelperEntrypoint EnsureClassConstructorRunAndReturnGCStaticBase;
    public static HelperEntrypoint EnsureClassConstructorRunAndReturnNonGCStaticBase;
    public static HelperEntrypoint EnsureClassConstructorRunAndReturnThreadStaticBase;
    public static HelperEntrypoint GetThreadStaticBaseForType;
}
public interface ILCompiler.DependencyAnalysis.IDebugInfo {
}
public interface ILCompiler.DependencyAnalysis.IEETypeNode {
    public TypeDesc Type { get; }
    public abstract virtual TypeDesc get_Type();
}
public interface ILCompiler.DependencyAnalysis.IExportableSymbolNode {
    public abstract virtual ExportForm GetExportForm(NodeFactory factory);
}
public interface ILCompiler.DependencyAnalysis.IGenericLookupResultTocWriter {
    public abstract virtual void WriteData(GenericLookupResultReferenceType referenceType, LookupResultType slotType, TypeSystemEntity context);
    public abstract virtual void WriteIntegerSlot(int value);
}
public interface ILCompiler.DependencyAnalysis.IHasStartSymbol {
    public ObjectAndOffsetSymbolNode StartSymbol { get; }
    public abstract virtual ObjectAndOffsetSymbolNode get_StartSymbol();
}
public class ILCompiler.DependencyAnalysis.ILScanNodeFactory : NodeFactory {
    public ILScanNodeFactory(CompilerTypeSystemContext context, CompilationModuleGroup compilationModuleGroup, MetadataManager metadataManager, InteropStubManager interopStubManager, NameMangler nameMangler);
    protected virtual IMethodNode CreateMethodEntrypointNode(MethodDesc method);
    protected virtual IMethodNode CreateUnboxingStubNode(MethodDesc method);
    protected virtual ISymbolNode CreateReadyToRunHelperNode(ReadyToRunHelperKey helperCall);
}
public interface ILCompiler.DependencyAnalysis.IMethodBodyNode {
}
public interface ILCompiler.DependencyAnalysis.IMethodBodyNodeWithFuncletSymbols {
    public ISymbolNode[] FuncletSymbols { get; }
    public abstract virtual ISymbolNode[] get_FuncletSymbols();
}
internal interface ILCompiler.DependencyAnalysis.IMethodCodeNode {
    public abstract virtual void SetCode(ObjectData data);
    public abstract virtual void InitializeFrameInfos(FrameInfo[] frameInfos);
    public abstract virtual void InitializeGCInfo(Byte[] gcInfo);
    public abstract virtual void InitializeEHInfo(ObjectData ehInfo);
    public abstract virtual void InitializeDebugLocInfos(DebugLocInfo[] debugLocInfos);
    public abstract virtual void InitializeDebugVarInfos(DebugVarInfo[] debugVarInfos);
    public abstract virtual void InitializeDebugEHClauseInfos(DebugEHClauseInfo[] debugEHClauseInfos);
}
public interface ILCompiler.DependencyAnalysis.IMethodNode {
    public MethodDesc Method { get; }
    public abstract virtual MethodDesc get_Method();
}
public class ILCompiler.DependencyAnalysis.ImportedEETypeSymbolNode : ExternSymbolNode {
    private TypeDesc _type;
    public bool RepresentsIndirectionCell { get; }
    public TypeDesc Type { get; }
    public int ClassCode { get; }
    public ImportedEETypeSymbolNode(NodeFactory factory, TypeDesc type);
    public virtual bool get_RepresentsIndirectionCell();
    public sealed virtual TypeDesc get_Type();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ImportedGCStaticsNode : ExternSymbolNode {
    public bool RepresentsIndirectionCell { get; }
    public ImportedGCStaticsNode(NodeFactory factory, MetadataType type);
    public virtual bool get_RepresentsIndirectionCell();
}
public class ILCompiler.DependencyAnalysis.ImportedMethodGenericDictionaryNode : ExternSymbolNode {
    private MethodDesc _owningMethod;
    public bool RepresentsIndirectionCell { get; }
    public ImportedMethodGenericDictionaryNode(NodeFactory factory, MethodDesc owningMethod);
    public virtual bool get_RepresentsIndirectionCell();
}
public abstract class ILCompiler.DependencyAnalysis.ImportedNodeProvider : object {
    public abstract virtual IEETypeNode ImportedEETypeNode(NodeFactory factory, TypeDesc type);
    public abstract virtual ISortableSymbolNode ImportedGCStaticNode(NodeFactory factory, MetadataType type);
    public abstract virtual ISortableSymbolNode ImportedNonGCStaticNode(NodeFactory factory, MetadataType type);
    public abstract virtual ISortableSymbolNode ImportedThreadStaticOffsetNode(NodeFactory factory, MetadataType type);
    public abstract virtual ISortableSymbolNode ImportedThreadStaticIndexNode(NodeFactory factory, MetadataType type);
    public abstract virtual ISortableSymbolNode ImportedTypeDictionaryNode(NodeFactory factory, TypeDesc type);
    public abstract virtual ISortableSymbolNode ImportedMethodDictionaryNode(NodeFactory factory, MethodDesc method);
    public abstract virtual IMethodNode ImportedMethodCodeNode(NodeFactory factory, MethodDesc method, bool unboxingStub);
}
public class ILCompiler.DependencyAnalysis.ImportedNodeProviderThrowing : ImportedNodeProvider {
    public virtual IEETypeNode ImportedEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedNonGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticOffsetNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticIndexNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedTypeDictionaryNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedMethodDictionaryNode(NodeFactory factory, MethodDesc method);
    public virtual IMethodNode ImportedMethodCodeNode(NodeFactory factory, MethodDesc method, bool unboxingStub);
}
public class ILCompiler.DependencyAnalysis.ImportedNonGCStaticsNode : ExternSymbolNode {
    public bool RepresentsIndirectionCell { get; }
    public ImportedNonGCStaticsNode(NodeFactory factory, MetadataType type);
    public virtual bool get_RepresentsIndirectionCell();
}
public class ILCompiler.DependencyAnalysis.ImportedThreadStaticsIndexNode : ExternSymbolNode {
    public bool RepresentsIndirectionCell { get; }
    public ImportedThreadStaticsIndexNode(NodeFactory factory);
    public virtual bool get_RepresentsIndirectionCell();
}
public class ILCompiler.DependencyAnalysis.ImportedThreadStaticsOffsetNode : ExternSymbolNode {
    public bool RepresentsIndirectionCell { get; }
    public ImportedThreadStaticsOffsetNode(MetadataType type, NodeFactory factory);
    public virtual bool get_RepresentsIndirectionCell();
}
public class ILCompiler.DependencyAnalysis.ImportedTypeGenericDictionaryNode : ExternSymbolNode {
    private TypeDesc _owningType;
    public bool RepresentsIndirectionCell { get; }
    public ImportedTypeGenericDictionaryNode(NodeFactory factory, TypeDesc owningType);
    public virtual bool get_RepresentsIndirectionCell();
}
[ExtensionAttribute]
internal static class ILCompiler.DependencyAnalysis.IndirectionExtensions : object {
    [ExtensionAttribute]
public static void EmitPointerRelocOrIndirectionReference(ObjectDataBuilder& builder, ISymbolNode symbol, int delta, int indirectionBit);
    [ExtensionAttribute]
public static void EmitRelativeRelocOrIndirectionReference(ObjectDataBuilder& builder, ISymbolNode symbol, int delta, int indirectionBit);
}
public class ILCompiler.DependencyAnalysis.IndirectionNode : ObjectNode {
    private ISortableSymbolNode _indirectedNode;
    private int _offsetDelta;
    private TargetDetails _target;
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public IndirectionNode(TargetDetails target, ISortableSymbolNode indirectedNode, int offsetDelta);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.InitialInterfaceDispatchStubNode : AssemblyStubNode {
    public bool IsShareable { get; }
    public int ClassCode { get; }
    protected virtual string GetName(NodeFactory factory);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual bool get_IsShareable();
    protected virtual void EmitCode(NodeFactory factory, ARMEmitter& instructionEncoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, X86Emitter& instructionEncoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, X64Emitter& instructionEncoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARM64Emitter& instructionEncoder, bool relocsOnly);
    public virtual int get_ClassCode();
}
public interface ILCompiler.DependencyAnalysis.INodeWithCodeInfo {
    public FrameInfo[] FrameInfos { get; }
    public Byte[] GCInfo { get; }
    public DebugEHClauseInfo[] DebugEHClauseInfos { get; }
    public ObjectData EHInfo { get; }
    public abstract virtual FrameInfo[] get_FrameInfos();
    public abstract virtual Byte[] get_GCInfo();
    public abstract virtual DebugEHClauseInfo[] get_DebugEHClauseInfos();
    public abstract virtual ObjectData get_EHInfo();
    public abstract virtual ISymbolNode GetAssociatedDataNode(NodeFactory factory);
}
public interface ILCompiler.DependencyAnalysis.INodeWithDebugInfo {
    public DebugLocInfo[] DebugLocInfos { get; }
    public DebugVarInfo[] DebugVarInfos { get; }
    public abstract virtual DebugLocInfo[] get_DebugLocInfos();
    public abstract virtual DebugVarInfo[] get_DebugVarInfos();
}
public interface ILCompiler.DependencyAnalysis.INodeWithRuntimeDeterminedDependencies {
    public abstract virtual IEnumerable`1<DependencyListEntry<NodeFactory>> InstantiateDependencies(NodeFactory factory, Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class ILCompiler.DependencyAnalysis.IntegerLookupResult : GenericLookupResult {
    private int _integerValue;
    public int IntegerValue { get; }
    protected int ClassCode { get; }
    public IntegerLookupResult(int integer);
    public int get_IntegerValue();
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual bool EqualsImpl(GenericLookupResult other);
    protected virtual int GetHashCodeImpl();
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
}
public class ILCompiler.DependencyAnalysis.InterfaceDispatchCellNode : EmbeddedObjectNode {
    private MethodDesc _targetMethod;
    private string _callSiteIdentifier;
    internal MethodDesc TargetMethod { get; }
    internal string CallSiteIdentifier { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public InterfaceDispatchCellNode(MethodDesc targetMethod, string callSiteIdentifier);
    internal MethodDesc get_TargetMethod();
    internal string get_CallSiteIdentifier();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    public virtual bool get_IsShareable();
    public static string GetMangledName(NameMangler nameMangler, MethodDesc method, string callSiteIdentifier);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual void EncodeData(ObjectDataBuilder& objData, NodeFactory factory, bool relocsOnly);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.InterfaceDispatchCellSectionNode : ArrayOfEmbeddedDataNode`1<InterfaceDispatchCellNode> {
    public int ClassCode { get; }
    public InterfaceDispatchCellSectionNode(NodeFactory factory);
    protected virtual void GetElementDataForNodes(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.InterfaceDispatchMapNode : ObjectNode {
    private TypeDesc _type;
    public int Offset { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public int ClassCode { get; }
    public InterfaceDispatchMapNode(NodeFactory factory, TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public static bool MightHaveInterfaceDispatchMap(TypeDesc type, NodeFactory factory);
    private void EmitDispatchMap(ObjectDataBuilder& builder, NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.InterfaceGenericVirtualMethodTableNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    private Dictionary`2<MethodDesc, HashSet`1<MethodDesc>> _interfaceGvmSlots;
    private Dictionary`2<MethodDesc, Dictionary`2<TypeDesc, HashSet`1<int>>> _interfaceImpls;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public InterfaceGenericVirtualMethodTableNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public static void GetGenericVirtualMethodImplementationDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc callingMethod, TypeDesc implementationType, MethodDesc implementationMethod);
    private void AddGenericVirtualMethodImplementation(NodeFactory factory, MethodDesc callingMethod, TypeDesc implementationType, MethodDesc implementationMethod);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public interface ILCompiler.DependencyAnalysis.IObjectDumper {
    public abstract virtual void DumpObjectNode(NameMangler mangler, ObjectNode node, ObjectData objectData);
}
internal class ILCompiler.DependencyAnalysis.IsInstGenericLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public IsInstGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public interface ILCompiler.DependencyAnalysis.ISortableNode {
    public int ClassCode { get; }
    public abstract virtual int get_ClassCode();
    public abstract virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public interface ILCompiler.DependencyAnalysis.ISortableSymbolNode {
}
public interface ILCompiler.DependencyAnalysis.ISpecialUnboxThunkNode {
    public bool IsSpecialUnboxingThunk { get; }
    public abstract virtual bool get_IsSpecialUnboxingThunk();
    public abstract virtual ISymbolNode GetUnboxingThunkTarget(NodeFactory factory);
}
public interface ILCompiler.DependencyAnalysis.ISymbolDefinitionNode {
    public int Offset { get; }
    public abstract virtual int get_Offset();
}
public interface ILCompiler.DependencyAnalysis.ISymbolNode {
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public abstract virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public abstract virtual int get_Offset();
    public abstract virtual bool get_RepresentsIndirectionCell();
}
[ExtensionAttribute]
public static class ILCompiler.DependencyAnalysis.ISymbolNodeExtensions : object {
    [ThreadStaticAttribute]
private static Utf8StringBuilder s_cachedUtf8StringBuilder;
    [ExtensionAttribute]
public static string GetMangledName(ISymbolNode symbolNode, NameMangler nameMangler);
}
public interface ILCompiler.DependencyAnalysis.ISymbolNodeWithDebugInfo {
    public IDebugInfo DebugInfo { get; }
    public abstract virtual IDebugInfo get_DebugInfo();
}
public interface ILCompiler.DependencyAnalysis.ISymbolNodeWithFuncletId {
    public ISymbolNode AssociatedMethodSymbol { get; }
    public int FuncletId { get; }
    public abstract virtual ISymbolNode get_AssociatedMethodSymbol();
    public abstract virtual int get_FuncletId();
}
public interface ILCompiler.DependencyAnalysis.ISymbolNodeWithLinkage {
    public abstract virtual ISymbolNode NodeForLinkage(NodeFactory factory);
}
public interface ILCompiler.DependencyAnalysis.ITypeIndexDebugInfo {
    public int TypeIndex { get; }
    public abstract virtual int get_TypeIndex();
}
public abstract class ILCompiler.DependencyAnalysis.JumpStubNode : AssemblyStubNode {
    private ISymbolNode _target;
    public ISymbolNode Target { get; }
    public int ClassCode { get; }
    public JumpStubNode(ISymbolNode target);
    public ISymbolNode get_Target();
    protected virtual string GetName(NodeFactory factory);
    public virtual int get_ClassCode();
    protected virtual void EmitCode(NodeFactory factory, X64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, X86Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARM64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARMEmitter& encoder, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.LazilyBuiltDictionaryLayoutNode : DictionaryLayoutNode {
    private EntryHashTable _entries;
    private GenericLookupResult[] modreq(System.Runtime.CompilerServices.IsVolatile) _layout;
    public bool HasFixedSlots { get; }
    public IEnumerable`1<GenericLookupResult> Entries { get; }
    public LazilyBuiltDictionaryLayoutNode(TypeSystemEntity owningMethodOrType);
    public virtual bool get_HasFixedSlots();
    public virtual void EnsureEntry(GenericLookupResult entry);
    private void ComputeLayout();
    public virtual int GetSlotForEntry(GenericLookupResult entry);
    public virtual IEnumerable`1<GenericLookupResult> get_Entries();
}
internal class ILCompiler.DependencyAnalysis.LazilyBuiltVTableSliceNode : VTableSliceNode {
    private HashSet`1<MethodDesc> _usedMethods;
    private MethodDesc[] _slots;
    public IReadOnlyList`1<MethodDesc> Slots { get; }
    public bool HasFixedSlots { get; }
    public bool HasConditionalStaticDependencies { get; }
    public LazilyBuiltVTableSliceNode(TypeDesc type);
    public virtual IReadOnlyList`1<MethodDesc> get_Slots();
    public virtual bool get_HasFixedSlots();
    public void AddEntry(NodeFactory factory, MethodDesc virtualMethod);
    public virtual bool get_HasConditionalStaticDependencies();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.LazilyBuiltVTableSliceNode/<GetConditionalStaticDependencies>d__10")]
public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
}
public enum ILCompiler.DependencyAnalysis.LookupResultType : Enum {
    public int value__;
    public static LookupResultType Invalid;
    public static LookupResultType EEType;
    public static LookupResultType UnwrapNullable;
    public static LookupResultType NonGcStatic;
    public static LookupResultType GcStatic;
    public static LookupResultType Method;
    public static LookupResultType InterfaceDispatchCell;
    public static LookupResultType MethodDictionary;
    public static LookupResultType UnboxingStub;
    public static LookupResultType ArrayType;
    public static LookupResultType DefaultCtor;
    public static LookupResultType TlsIndex;
    public static LookupResultType TlsOffset;
    public static LookupResultType AllocObject;
    public static LookupResultType GvmVtableOffset;
    public static LookupResultType ProfileCounter;
    public static LookupResultType MethodLdToken;
    public static LookupResultType FieldLdToken;
    public static LookupResultType Field;
    public static LookupResultType IsInst;
    public static LookupResultType CastClass;
    public static LookupResultType AllocArray;
    public static LookupResultType CheckArrayElementType;
    public static LookupResultType TypeSize;
    public static LookupResultType FieldOffset;
    public static LookupResultType CallingConvention_NoInstParam;
    public static LookupResultType CallingConvention_HasInstParam;
    public static LookupResultType CallingConvention_MaybeInstParam;
    public static LookupResultType VtableOffset;
    public static LookupResultType Constrained;
    public static LookupResultType ConstrainedDirect;
    public static LookupResultType Integer;
    public static LookupResultType UnboxingMethod;
}
public class ILCompiler.DependencyAnalysis.LoopHijackFlagNode : ObjectNode {
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual int get_ClassCode();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
}
internal class ILCompiler.DependencyAnalysis.MetadataNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ISymbolNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MethodAssociatedDataNode : ObjectNode {
    private IMethodNode _methodNode;
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public MethodAssociatedDataNode(IMethodNode methodNode);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public static bool MethodHasAssociatedData(NodeFactory factory, IMethodNode methodNode);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.MethodCodeNode : ObjectNode {
    public static ObjectNodeSection StartSection;
    public static ObjectNodeSection WindowsContentSection;
    public static ObjectNodeSection UnixContentSection;
    public static ObjectNodeSection EndSection;
    private MethodDesc _method;
    private ObjectData _methodCode;
    private FrameInfo[] _frameInfos;
    private Byte[] _gcInfo;
    private ObjectData _ehInfo;
    private DebugLocInfo[] _debugLocInfos;
    private DebugVarInfo[] _debugVarInfos;
    private DebugEHClauseInfo[] _debugEHClauseInfos;
    public MethodDesc Method { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public bool IsSpecialUnboxingThunk { get; }
    public FrameInfo[] FrameInfos { get; }
    public Byte[] GCInfo { get; }
    public ObjectData EHInfo { get; }
    public DebugLocInfo[] DebugLocInfos { get; }
    public DebugVarInfo[] DebugVarInfos { get; }
    public DebugEHClauseInfo[] DebugEHClauseInfos { get; }
    public int ClassCode { get; }
    public MethodCodeNode(MethodDesc method);
    private static MethodCodeNode();
    public sealed virtual void SetCode(ObjectData data);
    public sealed virtual MethodDesc get_Method();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public sealed virtual bool get_IsSpecialUnboxingThunk();
    public sealed virtual ISymbolNode GetUnboxingThunkTarget(NodeFactory factory);
    public sealed virtual FrameInfo[] get_FrameInfos();
    public sealed virtual Byte[] get_GCInfo();
    public sealed virtual ObjectData get_EHInfo();
    public sealed virtual ISymbolNode GetAssociatedDataNode(NodeFactory factory);
    public sealed virtual void InitializeFrameInfos(FrameInfo[] frameInfos);
    public sealed virtual void InitializeGCInfo(Byte[] gcInfo);
    public sealed virtual void InitializeEHInfo(ObjectData ehInfo);
    public sealed virtual DebugLocInfo[] get_DebugLocInfos();
    public sealed virtual DebugVarInfo[] get_DebugVarInfos();
    public sealed virtual DebugEHClauseInfo[] get_DebugEHClauseInfos();
    public sealed virtual void InitializeDebugLocInfos(DebugLocInfo[] debugLocInfos);
    public sealed virtual void InitializeDebugVarInfos(DebugVarInfo[] debugVarInfos);
    public sealed virtual void InitializeDebugEHClauseInfos(DebugEHClauseInfo[] debugEHClauseInfos);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.MethodDictionaryGenericLookupResult : GenericLookupResult {
    private MethodDesc _method;
    protected int ClassCode { get; }
    public MethodDesc Method { get; }
    public MethodDictionaryGenericLookupResult(MethodDesc method);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public MethodDesc get_Method();
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.MethodEntryGenericLookupResult : GenericLookupResult {
    private MethodDesc _method;
    private bool _isUnboxingThunk;
    protected int ClassCode { get; }
    public MethodEntryGenericLookupResult(MethodDesc method, bool isUnboxingThunk);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.MethodGenericDictionaryNode : GenericDictionaryNode {
    private MethodDesc _owningMethod;
    protected int HeaderSize { get; }
    public Instantiation TypeInstantiation { get; }
    public Instantiation MethodInstantiation { get; }
    protected TypeSystemContext Context { get; }
    public TypeSystemEntity OwningEntity { get; }
    public MethodDesc OwningMethod { get; }
    public int ClassCode { get; }
    public MethodGenericDictionaryNode(MethodDesc owningMethod, NodeFactory factory);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual int get_HeaderSize();
    public virtual Instantiation get_TypeInstantiation();
    public virtual Instantiation get_MethodInstantiation();
    protected virtual TypeSystemContext get_Context();
    public virtual TypeSystemEntity get_OwningEntity();
    public virtual ExportForm GetExportForm(NodeFactory factory);
    public MethodDesc get_OwningMethod();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual DictionaryLayoutNode GetDictionaryLayout(NodeFactory factory);
    protected virtual void EmitDataInternal(ObjectDataBuilder& builder, NodeFactory factory, bool fixedLayoutOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.MethodHandleGenericLookupResult : GenericLookupResult {
    private MethodDesc _method;
    protected int ClassCode { get; }
    public MethodHandleGenericLookupResult(MethodDesc method);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.MethodMetadataNode : DependencyNodeCore`1<NodeFactory> {
    private MethodDesc _method;
    public MethodDesc Method { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool StaticDependenciesAreComputed { get; }
    public MethodMetadataNode(MethodDesc method);
    public MethodDesc get_Method();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
[ExtensionAttribute]
public static class ILCompiler.DependencyAnalysis.MethodSignatureExtensions : object {
    [ExtensionAttribute]
public static void AppendName(MethodSignature signature, StringBuilder nameBuilder, UniqueTypeNameFormatter typeNameFormatter);
    [ExtensionAttribute]
public static string GetName(MethodSignature signature);
}
internal class ILCompiler.DependencyAnalysis.ModuleMetadataNode : DependencyNodeCore`1<NodeFactory> {
    private ModuleDesc _module;
    public ModuleDesc Module { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ModuleMetadataNode(ModuleDesc module);
    public ModuleDesc get_Module();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.ModulesSectionNode : ObjectNode {
    public static string WindowsSectionName;
    public static string UnixSectionName;
    private TargetDetails _target;
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public ModulesSectionNode(TargetDetails target);
    private static ModulesSectionNode();
    public virtual ObjectNodeSection get_Section();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedEETypeSymbolNode : MrtImportWithTypeSymbol {
    public int ClassCode { get; }
    public MrtImportedEETypeSymbolNode(TypeDesc type);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedGCStaticSymbolNode : MrtImportWithTypeSymbol {
    public int ClassCode { get; }
    public MrtImportedGCStaticSymbolNode(TypeDesc type);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedMethodCodeSymbolNode : MrtImportWithMethodSymbol {
    public int ClassCode { get; }
    public MrtImportedMethodCodeSymbolNode(MethodDesc method);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedMethodDictionarySymbolNode : MrtImportWithMethodSymbol {
    public int ClassCode { get; }
    public MrtImportedMethodDictionarySymbolNode(MethodDesc method);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedNonGCStaticSymbolNode : MrtImportWithTypeSymbol {
    public int ClassCode { get; }
    public MrtImportedNonGCStaticSymbolNode(TypeDesc type);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedThreadStaticOffsetSymbolNode : MrtImportWithTypeSymbol {
    public int ClassCode { get; }
    public MrtImportedThreadStaticOffsetSymbolNode(TypeDesc type);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportedUnboxingMethodCodeSymbolNode : MrtImportWithMethodSymbol {
    public int ClassCode { get; }
    public MrtImportedUnboxingMethodCodeSymbolNode(MethodDesc method);
    protected sealed virtual string GetNonImportedName(NameMangler nameMangler);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.MrtImportImportedNodeProvider : ImportedNodeProvider {
    private KeyValuePair`2[] _importOrdinals;
    public MrtImportImportedNodeProvider(TypeSystemContext context, KeyValuePair`2[] ordinals);
    private bool LookupInImportExportOrdinals(Func`2<ImportExportOrdinals, ReadOnlyDictionary`2<TType, UInt32>> getOrdinalDictionary, TType lookup, MrtImportNode node);
    public virtual IEETypeNode ImportedEETypeNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedNonGCStaticNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticOffsetNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedThreadStaticIndexNode(NodeFactory factory, MetadataType type);
    public virtual ISortableSymbolNode ImportedTypeDictionaryNode(NodeFactory factory, TypeDesc type);
    public virtual ISortableSymbolNode ImportedMethodDictionaryNode(NodeFactory factory, MethodDesc method);
    public virtual IMethodNode ImportedMethodCodeNode(NodeFactory factory, MethodDesc method, bool unboxingStub);
}
public abstract class ILCompiler.DependencyAnalysis.MrtImportNode : SortableDependencyNode {
    private static int InvalidOffset;
    private int _offset;
    private MrtProcessedImportAddressTableNode _importTable;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    public int Ordinal { get; private set; }
    public IHasStartSymbol ContainingNode { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public int OffsetFromBeginningOfArray { get; }
    public bool IsShareable { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public int ClassCode { get; }
    public bool StaticDependenciesAreComputed { get; }
    [CompilerGeneratedAttribute]
public int get_Ordinal();
    [CompilerGeneratedAttribute]
private void set_Ordinal(int value);
    public IHasStartSymbol get_ContainingNode();
    public void InitializeImport(MrtProcessedImportAddressTableNode importTable, int ordinal);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    protected sealed virtual string GetName(NodeFactory factory);
    protected abstract virtual string GetNonImportedName(NameMangler nameMangler);
    public void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual bool get_RepresentsIndirectionCell();
    public int get_OffsetFromBeginningOfArray();
    internal void InitializeOffsetFromBeginningOfArray(int offset);
    public bool get_IsShareable();
    public sealed virtual bool get_InterestingForDynamicDependencyAnalysis();
    public sealed virtual bool get_HasDynamicDependencies();
    public sealed virtual bool get_HasConditionalStaticDependencies();
    public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
    public virtual int get_ClassCode();
    public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual void OnMarked(NodeFactory factory);
    private sealed virtual override void ILCompiler.DependencyAnalysis.ISymbolNode.AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
}
public abstract class ILCompiler.DependencyAnalysis.MrtImportWithMethodSymbol : MrtImportNode {
    private MethodDesc _method;
    public MethodDesc Method { get; }
    public MrtImportWithMethodSymbol(MethodDesc method);
    public sealed virtual MethodDesc get_Method();
}
public abstract class ILCompiler.DependencyAnalysis.MrtImportWithTypeSymbol : MrtImportNode {
    private TypeDesc _type;
    public TypeDesc Type { get; }
    public MrtImportWithTypeSymbol(TypeDesc type);
    public sealed virtual TypeDesc get_Type();
}
public class ILCompiler.DependencyAnalysis.MrtProcessedExportAddressTableNode : ObjectNode {
    private HashSet`1<ISortableSymbolNode> _exportableSymbols;
    private string _symbolName;
    private NodeFactory _factory;
    [CompilerGeneratedAttribute]
private Func`3<UInt32, IExportableSymbolNode, UInt32> ReportExportedItem;
    [CompilerGeneratedAttribute]
private Func`1<UInt32> GetInitialExportOrdinal;
    public int Offset { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public MrtProcessedExportAddressTableNode(string symbolName, NodeFactory factory);
    [CompilerGeneratedAttribute]
public void add_ReportExportedItem(Func`3<UInt32, IExportableSymbolNode, UInt32> value);
    [CompilerGeneratedAttribute]
public void remove_ReportExportedItem(Func`3<UInt32, IExportableSymbolNode, UInt32> value);
    [CompilerGeneratedAttribute]
public void add_GetInitialExportOrdinal(Func`1<UInt32> value);
    [CompilerGeneratedAttribute]
public void remove_GetInitialExportOrdinal(Func`1<UInt32> value);
    public void AddExportableSymbol(IExportableSymbolNode exportableSymbol);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual ExportForm GetExportForm(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.MrtProcessedImportAddressTableNode : EmbeddedDataContainerNode {
    private List`1<MrtImportNode> _importNodes;
    private bool _nodeListComplete;
    private int _pointerSize;
    private EmbeddedObjectNode _pointerFromImportTablesTable;
    public string ExportTableToImportSymbol;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public MrtProcessedImportAddressTableNode(string exportTableToImportSymbol, TypeSystemContext context);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public void AddNode(MrtImportNode node);
    public void FinalizeOffsets();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual int get_ClassCode();
    private sealed virtual override void ILCompiler.DependencyAnalysis.ISymbolNode.AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
}
internal class ILCompiler.DependencyAnalysis.NamedJumpStubNode : JumpStubNode {
    private Utf8String _name;
    public NamedJumpStubNode(string name, ISymbolNode target);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutAllocateArrayGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutAllocateArrayGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutAllocateObjectGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutAllocateObjectGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutCallingConventionConverterGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private MethodSignature _signature;
    private CallingConventionConverterKind _converterKind;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutCallingConventionConverterGenericDictionarySlotNode(MethodSignature signature, CallingConventionConverterKind converterKind);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutCallingConventionConverterGenericDictionarySlotNode/<GetStaticDependencies>d__6")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutCastClassGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutCastClassGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutConstrainedMethodDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private MethodDesc _constrainedMethod;
    private TypeDesc _constraintType;
    private bool _directCall;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutConstrainedMethodDictionarySlotNode(MethodDesc constrainedMethod, TypeDesc constraintType, bool directCall);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutConstrainedMethodDictionarySlotNode/<GetStaticDependencies>d__7")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutDefaultConstructorGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutDefaultConstructorGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutDictionarySignatureNode : NativeLayoutSavedVertexNode {
    private TypeSystemEntity _owningMethodOrType;
    public NativeLayoutDictionarySignatureNode(NodeFactory nodeFactory, TypeSystemEntity owningMethodOrType);
    private GenericContextKind ContextKind(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutExternalReferenceVertexNode : NativeLayoutVertexNode {
    private ISymbolNode _symbol;
    public NativeLayoutExternalReferenceVertexNode(NodeFactory factory, ISymbolNode symbol);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutFieldLdTokenGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private FieldDesc _field;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutFieldLdTokenGenericDictionarySlotNode(FieldDesc field);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutFieldLdTokenGenericDictionarySlotNode/<GetStaticDependencies>d__5")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutFieldLdTokenVertexNode : NativeLayoutSavedVertexNode {
    private FieldDesc _field;
    private NativeLayoutTypeSignatureVertexNode _containingTypeSig;
    public NativeLayoutFieldLdTokenVertexNode(NodeFactory factory, FieldDesc field);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutFieldOffsetGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private FieldDesc _field;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutFieldOffsetGenericDictionarySlotNode(FieldDesc field);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutFieldOffsetGenericDictionarySlotNode/<GetStaticDependencies>d__5")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutGcStaticsGenericDictionarySlotNode : NativeLayoutStaticsGenericDictionarySlotNode {
    protected StaticDataKind StaticDataKindFlag { get; }
    protected string NodeTypeName { get; }
    public NativeLayoutGcStaticsGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual StaticDataKind get_StaticDataKindFlag();
    protected virtual string get_NodeTypeName();
}
public abstract class ILCompiler.DependencyAnalysis.NativeLayoutGenericDictionarySlotNode : NativeLayoutVertexNode {
    protected FixupSignatureKind SignatureKind { get; }
    public abstract virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    protected abstract virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
    protected abstract virtual FixupSignatureKind get_SignatureKind();
    public virtual Vertex WriteVertex(NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutInfoNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    private ExternalReferencesTableNode _staticsReferences;
    private NativeWriter _writer;
    private Byte[] _writerSavedBytes;
    private Section _signaturesSection;
    private Section _ldTokenInfoSection;
    private Section _templatesSection;
    private List`1<NativeLayoutVertexNode> _vertexNodesToWrite;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public Section LdTokenInfoSection { get; }
    public Section SignaturesSection { get; }
    public Section TemplatesSection { get; }
    public ExternalReferencesTableNode ExternalReferences { get; }
    public ExternalReferencesTableNode StaticsReferences { get; }
    public NativeWriter Writer { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public NativeLayoutInfoNode(ExternalReferencesTableNode externalReferences, ExternalReferencesTableNode staticsReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public Section get_LdTokenInfoSection();
    public Section get_SignaturesSection();
    public Section get_TemplatesSection();
    public ExternalReferencesTableNode get_ExternalReferences();
    public ExternalReferencesTableNode get_StaticsReferences();
    public NativeWriter get_Writer();
    public void AddVertexNodeToNativeLayout(NativeLayoutVertexNode vertexNode);
    public void SaveNativeLayoutInfoWriter(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutIntegerDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private int _value;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutIntegerDictionarySlotNode(int value);
    protected virtual FixupSignatureKind get_SignatureKind();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    protected virtual string GetName(NodeFactory context);
    protected virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
    public virtual void CheckIfMarkedEnoughToWrite();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutInterfaceDispatchGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private NativeLayoutTypeSignatureVertexNode _signature;
    private MethodDesc _method;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutInterfaceDispatchGenericDictionarySlotNode(NodeFactory factory, MethodDesc method);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutInterfaceDispatchGenericDictionarySlotNode/<GetStaticDependencies>d__6")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutIsInstGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutIsInstGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutMethodDictionaryGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private MethodDesc _method;
    private WrappedMethodDictionaryVertexNode _wrappedNode;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutMethodDictionaryGenericDictionarySlotNode(NodeFactory factory, MethodDesc method);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutMethodDictionaryGenericDictionarySlotNode/<GetStaticDependencies>d__7")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutMethodEntrypointGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private MethodDesc _method;
    private WrappedMethodEntryVertexNode _wrappedNode;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutMethodEntrypointGenericDictionarySlotNode(NodeFactory factory, MethodDesc method, IMethodNode functionPointerNode, bool unboxingStub);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutMethodEntrypointGenericDictionarySlotNode/<GetStaticDependencies>d__7")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
internal abstract class ILCompiler.DependencyAnalysis.NativeLayoutMethodEntryVertexNode : NativeLayoutSavedVertexNode {
    protected MethodDesc _method;
    private MethodEntryFlags _flags;
    private NativeLayoutTypeSignatureVertexNode _containingTypeSig;
    private NativeLayoutMethodSignatureVertexNode _methodSig;
    private NativeLayoutTypeSignatureVertexNode[] _instantiationArgsSig;
    public NativeLayoutMethodEntryVertexNode(NodeFactory factory, MethodDesc method, MethodEntryFlags flags);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
    private Vertex GetContainingTypeVertex(NodeFactory factory);
    protected virtual IMethodNode GetMethodEntrypointNode(NodeFactory factory, Boolean& unboxingStub);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutMethodLdTokenGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private MethodDesc _method;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutMethodLdTokenGenericDictionarySlotNode(MethodDesc method);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutMethodLdTokenGenericDictionarySlotNode/<GetStaticDependencies>d__5")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutMethodLdTokenVertexNode : NativeLayoutMethodEntryVertexNode {
    public NativeLayoutMethodLdTokenVertexNode(NodeFactory factory, MethodDesc method);
    protected virtual string GetName(NodeFactory factory);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutMethodNameAndSignatureVertexNode : NativeLayoutVertexNode {
    private MethodDesc _method;
    private NativeLayoutMethodSignatureVertexNode _methodSig;
    public NativeLayoutMethodNameAndSignatureVertexNode(NodeFactory factory, MethodDesc method);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutMethodSignatureVertexNode : NativeLayoutVertexNode {
    private MethodSignature _signature;
    private NativeLayoutTypeSignatureVertexNode _returnTypeSig;
    private NativeLayoutTypeSignatureVertexNode[] _parametersSig;
    public NativeLayoutMethodSignatureVertexNode(NodeFactory factory, MethodSignature signature);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutNonGcStaticsGenericDictionarySlotNode : NativeLayoutStaticsGenericDictionarySlotNode {
    protected StaticDataKind StaticDataKindFlag { get; }
    protected string NodeTypeName { get; }
    public NativeLayoutNonGcStaticsGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual StaticDataKind get_StaticDataKindFlag();
    protected virtual string get_NodeTypeName();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutNotSupportedDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    protected FixupSignatureKind SignatureKind { get; }
    protected virtual FixupSignatureKind get_SignatureKind();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    protected virtual string GetName(NodeFactory context);
    protected virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutPlacedSignatureVertexNode : NativeLayoutSavedVertexNode {
    private NativeLayoutVertexNode _signatureToBePlaced;
    public NativeLayoutPlacedSignatureVertexNode(NativeLayoutVertexNode signatureToBePlaced);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutPlacedVertexSequenceOfUIntVertexNode : NativeLayoutSavedVertexNode {
    private List`1<UInt32> _uints;
    public NativeLayoutPlacedVertexSequenceOfUIntVertexNode(List`1<UInt32> uints);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutPlacedVertexSequenceVertexNode : NativeLayoutSavedVertexNode {
    private List`1<NativeLayoutVertexNode> _vertices;
    public NativeLayoutPlacedVertexSequenceVertexNode(List`1<NativeLayoutVertexNode> vertices);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutPointerToOtherSlotDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private int _otherSlotIndex;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutPointerToOtherSlotDictionarySlotNode(int otherSlotIndex);
    protected virtual FixupSignatureKind get_SignatureKind();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    protected virtual string GetName(NodeFactory context);
    protected virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
    public virtual void CheckIfMarkedEnoughToWrite();
}
public abstract class ILCompiler.DependencyAnalysis.NativeLayoutSavedVertexNode : NativeLayoutVertexNode {
    [CompilerGeneratedAttribute]
private Vertex <SavedVertex>k__BackingField;
    public Vertex SavedVertex { get; private set; }
    [CompilerGeneratedAttribute]
public Vertex get_SavedVertex();
    [CompilerGeneratedAttribute]
private void set_SavedVertex(Vertex value);
    protected Vertex SetSavedVertex(Vertex value);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutSignatureNode : ObjectNode {
    private TypeSystemEntity _identity;
    private Utf8String _identityPrefix;
    private NativeLayoutSavedVertexNode _nativeSignature;
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public NativeLayoutSignatureNode(NativeLayoutSavedVertexNode nativeSignature, TypeSystemEntity identity, Utf8String identityPrefix);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public abstract class ILCompiler.DependencyAnalysis.NativeLayoutStaticsGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private NativeLayoutTypeSignatureVertexNode _signature;
    private TypeDesc _type;
    protected StaticDataKind StaticDataKindFlag { get; }
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutStaticsGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected abstract virtual StaticDataKind get_StaticDataKindFlag();
    protected abstract virtual string get_NodeTypeName();
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutStaticsGenericDictionarySlotNode/<GetStaticDependencies>d__10")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutTemplateMethodLayoutVertexNode : NativeLayoutSavedVertexNode {
    private MethodDesc _method;
    public NativeLayoutTemplateMethodLayoutVertexNode(NodeFactory factory, MethodDesc method);
    protected virtual string GetName(NodeFactory factory);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutTemplateMethodLayoutVertexNode/<GetStaticDependencies>d__3")]
public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    private int CompareDictionaryEntries(KeyValuePair`2<int, NativeLayoutVertexNode> left, KeyValuePair`2<int, NativeLayoutVertexNode> right);
    public virtual Vertex WriteVertex(NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NativeLayoutTemplateMethodSignatureVertexNode : NativeLayoutMethodEntryVertexNode {
    public NativeLayoutTemplateMethodSignatureVertexNode(NodeFactory factory, MethodDesc method);
    protected virtual string GetName(NodeFactory factory);
    public virtual Vertex WriteVertex(NodeFactory factory);
    protected virtual IMethodNode GetMethodEntrypointNode(NodeFactory factory, Boolean& unboxingStub);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutTemplateTypeLayoutVertexNode : NativeLayoutSavedVertexNode {
    private TypeDesc _type;
    private bool _isUniversalCanon;
    public bool HasConditionalStaticDependencies { get; }
    public NativeLayoutTemplateTypeLayoutVertexNode(NodeFactory factory, TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    private static TypeDesc GetActualTemplateTypeForType(NodeFactory factory, TypeDesc type);
    private ISymbolNode GetStaticsNode(NodeFactory context, BagElementKind& staticsBagKind);
    private ISymbolNode GetThreadStaticsNode(NodeFactory context, BagElementKind& staticsBagKind);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutTemplateTypeLayoutVertexNode/<GetStaticDependencies>d__7")]
public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory context);
    private int CompareDictionaryEntries(KeyValuePair`2<int, NativeLayoutVertexNode> left, KeyValuePair`2<int, NativeLayoutVertexNode> right);
    private bool HasInstantiationDeterminedSize();
    public virtual Vertex WriteVertex(NodeFactory factory);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutTemplateTypeLayoutVertexNode/<EnumVirtualSlotsDeclaredOnType>d__15")]
private static IEnumerable`1<MethodDesc> EnumVirtualSlotsDeclaredOnType(TypeDesc declType);
    private void ProcessVTableEntriesForCallingConventionSignatureGeneration(NodeFactory factory, VTableEntriesToProcess whichEntries, Int32& currentVTableIndex, Action`4<int, bool, MethodDesc, MethodDesc> operation, TypeDesc implType, TypeDesc declType, TypeDesc templateType);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutTlsIndexGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutTlsIndexGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutTlsOffsetGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutTlsOffsetGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutTypeHandleGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutTypeHandleGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public abstract class ILCompiler.DependencyAnalysis.NativeLayoutTypeSignatureBasedGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private NativeLayoutTypeSignatureVertexNode _signature;
    private TypeDesc _type;
    protected string NodeTypeName { get; }
    public NativeLayoutTypeSignatureBasedGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected abstract virtual string get_NodeTypeName();
    protected sealed virtual string GetName(NodeFactory factory);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutTypeSignatureBasedGenericDictionarySlotNode/<GetStaticDependencies>d__6")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
internal abstract class ILCompiler.DependencyAnalysis.NativeLayoutTypeSignatureVertexNode : NativeLayoutVertexNode {
    protected TypeDesc _type;
    protected NativeLayoutTypeSignatureVertexNode(TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    public static NativeLayoutTypeSignatureVertexNode NewTypeSignatureVertexNode(NodeFactory factory, TypeDesc type);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutTypeSizeGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutTypeSizeGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public class ILCompiler.DependencyAnalysis.NativeLayoutUnwrapNullableGenericDictionarySlotNode : NativeLayoutTypeSignatureBasedGenericDictionarySlotNode {
    protected string NodeTypeName { get; }
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutUnwrapNullableGenericDictionarySlotNode(NodeFactory factory, TypeDesc type);
    protected virtual string get_NodeTypeName();
    protected virtual FixupSignatureKind get_SignatureKind();
}
public abstract class ILCompiler.DependencyAnalysis.NativeLayoutVertexNode : DependencyNodeCore`1<NodeFactory> {
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    [ConditionalAttribute("DEBUG")]
public virtual void CheckIfMarkedEnoughToWrite();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory context);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory context);
    protected virtual void OnMarked(NodeFactory context);
    public abstract virtual Vertex WriteVertex(NodeFactory factory);
    protected NativeWriter GetNativeWriter(NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.NativeLayoutVTableOffsetGenericDictionarySlotNode : NativeLayoutGenericDictionarySlotNode {
    private MethodDesc _method;
    private MethodDesc _slotDefiningMethod;
    protected FixupSignatureKind SignatureKind { get; }
    public NativeLayoutVTableOffsetGenericDictionarySlotNode(MethodDesc method);
    protected sealed virtual string GetName(NodeFactory factory);
    protected sealed virtual FixupSignatureKind get_SignatureKind();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.NativeLayoutVTableOffsetGenericDictionarySlotNode/<GetStaticDependencies>d__6")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected sealed virtual Vertex WriteSignatureVertex(NativeWriter writer, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.NecessaryCanonicalEETypeNode : EETypeNode {
    public int ClassCode { get; }
    public NecessaryCanonicalEETypeNode(NodeFactory factory, TypeDesc type);
    protected virtual ISymbolNode GetBaseTypeNode(NodeFactory factory);
    public virtual int get_ClassCode();
}
public abstract class ILCompiler.DependencyAnalysis.NodeFactory : object {
    private InitialInterfaceDispatchStubNode _initialInterfaceDispatchStubNode;
    private TargetDetails _target;
    private CompilerTypeSystemContext _context;
    private CompilationModuleGroup _compilationModuleGroup;
    private VTableSliceProvider _vtableSliceProvider;
    private DictionaryLayoutProvider _dictionaryLayoutProvider;
    protected ImportedNodeProvider _importedNodeProvider;
    private bool _markingComplete;
    [CompilerGeneratedAttribute]
private LazyGenericsPolicy <LazyGenericsPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataManager <MetadataManager>k__BackingField;
    [CompilerGeneratedAttribute]
private NameMangler <NameMangler>k__BackingField;
    [CompilerGeneratedAttribute]
private InteropStubManager <InteropStubManager>k__BackingField;
    private NodeCache`2<TypeDesc, IEETypeNode> _typeSymbols;
    private NodeCache`2<TypeDesc, IEETypeNode> _constructedTypeSymbols;
    private NodeCache`2<TypeDesc, IEETypeNode> _clonedTypeSymbols;
    private NodeCache`2<TypeDesc, IEETypeNode> _importedTypeSymbols;
    private NodeCache`2<MetadataType, ISortableSymbolNode> _nonGCStatics;
    private NodeCache`2<MetadataType, ISortableSymbolNode> _GCStatics;
    private NodeCache`2<MetadataType, GCStaticsPreInitDataNode> _GCStaticsPreInitDataNodes;
    private NodeCache`2<MetadataType, EmbeddedObjectNode> _GCStaticIndirectionNodes;
    private NodeCache`2<MetadataType, ISymbolDefinitionNode> _threadStatics;
    private NodeCache`2<MetadataType, TypeThreadStaticIndexNode> _typeThreadStaticIndices;
    private NodeCache`2<DispatchCellKey, InterfaceDispatchCellNode> _interfaceDispatchCells;
    private NodeCache`2<MethodDesc, RuntimeMethodHandleNode> _runtimeMethodHandles;
    private NodeCache`2<FieldDesc, RuntimeFieldHandleNode> _runtimeFieldHandles;
    private NodeCache`2<GCPointerMap, GCStaticEETypeNode> _GCStaticEETypes;
    private NodeCache`2<ReadOnlyDataBlobKey, BlobNode> _readOnlyDataBlobs;
    private NodeCache`2<TypeDesc, SealedVTableNode> _sealedVtableNodes;
    private NodeCache`2<TypeDesc, InterfaceDispatchMapNode> _interfaceDispatchMaps;
    private NodeCache`2<TypeDesc, EmbeddedObjectNode> _interfaceDispatchMapIndirectionNodes;
    private NodeCache`2<GenericCompositionDetails, GenericCompositionNode> _genericCompositions;
    private NodeCache`2<string, ExternSymbolNode> _externSymbols;
    private NodeCache`2<string, PInvokeModuleFixupNode> _pInvokeModuleFixups;
    private NodeCache`2<Tuple`3<string, string, PInvokeFlags>, PInvokeMethodFixupNode> _pInvokeMethodFixups;
    private NodeCache`2<TypeDesc, VTableSliceNode> _vTableNodes;
    private NodeCache`2<MethodDesc, ISortableSymbolNode> _methodGenericDictionaries;
    private NodeCache`2<TypeDesc, ISortableSymbolNode> _typeGenericDictionaries;
    private NodeCache`2<TypeSystemEntity, DictionaryLayoutNode> _genericDictionaryLayouts;
    private NodeCache`2<MethodDesc, IMethodNode> _stringAllocators;
    private NodeCache`2<MethodDesc, IMethodNode> _methodEntrypoints;
    private NodeCache`2<MethodDesc, IMethodNode> _unboxingStubs;
    private NodeCache`2<IMethodNode, MethodAssociatedDataNode> _methodAssociatedData;
    private NodeCache`2<MethodKey, FatFunctionPointerNode> _fatFunctionPointers;
    private NodeCache`2<MethodDesc, GVMDependenciesNode> _gvmDependenciesNode;
    private NodeCache`2<TypeDesc, TypeGVMEntriesNode> _gvmTableEntries;
    private NodeCache`2<MethodDesc, ReflectableMethodNode> _reflectableMethods;
    private NodeCache`2<MethodKey, IMethodNode> _shadowConcreteMethods;
    private NodeCache`2<MethodDesc, IMethodNode> _runtimeDeterminedMethods;
    private static String[][] s_helperEntrypointNames;
    private ISymbolNode[] _helperEntrypointSymbols;
    private MetadataType _systemArrayOfTClass;
    private TypeDesc _systemArrayOfTEnumeratorType;
    private TypeDesc _systemICastableType;
    private NodeCache`2<MethodDesc, VirtualMethodUseNode> _virtMethods;
    private NodeCache`2<ReadyToRunHelperKey, ISymbolNode> _readyToRunHelpers;
    private NodeCache`2<ReadyToRunGenericHelperKey, ISymbolNode> _genericReadyToRunHelpersFromDict;
    private NodeCache`2<ReadyToRunGenericHelperKey, ISymbolNode> _genericReadyToRunHelpersFromType;
    private NodeCache`2<ISortableSymbolNode, ISymbolNode> _indirectionNodes;
    private NodeCache`2<MetadataType, TypeMetadataNode> _typesWithMetadata;
    private NodeCache`2<MethodDesc, MethodMetadataNode> _methodsWithMetadata;
    private NodeCache`2<FieldDesc, FieldMetadataNode> _fieldsWithMetadata;
    private NodeCache`2<ModuleDesc, ModuleMetadataNode> _modulesWithMetadata;
    private NodeCache`2<string, FrozenStringNode> _frozenStringNodes;
    private NodeCache`2<PreInitFieldInfo, FrozenArrayNode> _frozenArrayNodes;
    private NodeCache`2<MethodDesc, EmbeddedObjectNode> _eagerCctorIndirectionNodes;
    private NodeCache`2<Tuple`2<string, ISymbolNode>, NamedJumpStubNode> _namedJumpStubNodes;
    public ArrayOfEmbeddedPointersNode`1<GCStaticsNode> GCStaticsRegion;
    public ArrayOfEmbeddedDataNode`1<ThreadStaticsNode> ThreadStaticsRegion;
    public ArrayOfEmbeddedPointersNode`1<IMethodNode> EagerCctorTable;
    public ArrayOfEmbeddedPointersNode`1<InterfaceDispatchMapNode> DispatchMapTable;
    public ArrayOfEmbeddedDataNode`1<EmbeddedObjectNode> FrozenSegmentRegion;
    public ArrayOfEmbeddedPointersNode`1<MrtProcessedImportAddressTableNode> ImportAddressTablesTable;
    [CompilerGeneratedAttribute]
private InterfaceDispatchCellSectionNode <InterfaceDispatchCellSection>k__BackingField;
    public ReadyToRunHeaderNode ReadyToRunHeader;
    public Dictionary`2<ISymbolNode, string> NodeAliases;
    protected internal TypeManagerIndirectionNode TypeManagerIndirection;
    public GenericLookupResults GenericLookup;
    public NativeLayoutHelper NativeLayout;
    [CompilerGeneratedAttribute]
private WindowsDebugDataHelper <WindowsDebugData>k__BackingField;
    public InitialInterfaceDispatchStubNode InitialInterfaceDispatchStub { get; }
    public bool MarkingComplete { get; }
    public TargetDetails Target { get; }
    public LazyGenericsPolicy LazyGenericsPolicy { get; }
    public CompilationModuleGroup CompilationModuleGroup { get; }
    public CompilerTypeSystemContext TypeSystemContext { get; }
    public MetadataManager MetadataManager { get; }
    public NameMangler NameMangler { get; }
    public InteropStubManager InteropStubManager { get; }
    public bool IsCppCodegenTemporaryWorkaround { get; }
    public MetadataType ArrayOfTClass { get; }
    public TypeDesc ArrayOfTEnumeratorType { get; }
    public TypeDesc ICastableInterface { get; }
    public InterfaceDispatchCellSectionNode InterfaceDispatchCellSection { get; }
    public WindowsDebugDataHelper WindowsDebugData { get; private set; }
    public NodeFactory(CompilerTypeSystemContext context, CompilationModuleGroup compilationModuleGroup, MetadataManager metadataManager, InteropStubManager interoptStubManager, NameMangler nameMangler, LazyGenericsPolicy lazyGenericsPolicy, VTableSliceProvider vtableSliceProvider, DictionaryLayoutProvider dictionaryLayoutProvider, ImportedNodeProvider importedNodeProvider);
    private static NodeFactory();
    public InitialInterfaceDispatchStubNode get_InitialInterfaceDispatchStub();
    public void SetMarkingComplete();
    public bool get_MarkingComplete();
    public TargetDetails get_Target();
    [CompilerGeneratedAttribute]
public LazyGenericsPolicy get_LazyGenericsPolicy();
    public CompilationModuleGroup get_CompilationModuleGroup();
    public CompilerTypeSystemContext get_TypeSystemContext();
    [CompilerGeneratedAttribute]
public MetadataManager get_MetadataManager();
    [CompilerGeneratedAttribute]
public NameMangler get_NameMangler();
    [CompilerGeneratedAttribute]
public InteropStubManager get_InteropStubManager();
    public virtual bool get_IsCppCodegenTemporaryWorkaround();
    private static bool TypeCannotHaveEEType(TypeDesc type);
    private void CreateNodeCaches();
    protected abstract virtual IMethodNode CreateMethodEntrypointNode(MethodDesc method);
    protected abstract virtual IMethodNode CreateUnboxingStubNode(MethodDesc method);
    protected abstract virtual ISymbolNode CreateReadyToRunHelperNode(ReadyToRunHelperKey helperCall);
    protected virtual ISymbolDefinitionNode CreateThreadStaticsNode(MetadataType type);
    public IEETypeNode NecessaryTypeSymbol(TypeDesc type);
    public IEETypeNode ConstructedTypeSymbol(TypeDesc type);
    public IEETypeNode MaximallyConstructableType(TypeDesc type);
    public IEETypeNode ConstructedClonedTypeSymbol(TypeDesc type);
    private IEETypeNode ImportedEETypeSymbol(TypeDesc type);
    public ISortableSymbolNode TypeNonGCStaticsSymbol(MetadataType type);
    public ISortableSymbolNode TypeGCStaticsSymbol(MetadataType type);
    public GCStaticsPreInitDataNode GCStaticsPreInitDataNode(MetadataType type);
    public EmbeddedObjectNode GCStaticIndirection(MetadataType type);
    public ISymbolDefinitionNode TypeThreadStaticsSymbol(MetadataType type);
    public ISymbolNode TypeThreadStaticIndex(MetadataType type);
    public InterfaceDispatchCellNode InterfaceDispatchCell(MethodDesc method, string callSite);
    public RuntimeMethodHandleNode RuntimeMethodHandle(MethodDesc method);
    public RuntimeFieldHandleNode RuntimeFieldHandle(FieldDesc field);
    public ISymbolNode GCStaticEEType(GCPointerMap gcMap);
    public BlobNode ReadOnlyDataBlob(Utf8String name, Byte[] blobData, int alignment);
    internal SealedVTableNode SealedVTable(TypeDesc type);
    internal InterfaceDispatchMapNode InterfaceDispatchMap(TypeDesc type);
    public EmbeddedObjectNode InterfaceDispatchMapIndirection(TypeDesc type);
    internal ISymbolNode GenericComposition(GenericCompositionDetails details);
    public ISortableSymbolNode ExternSymbol(string name);
    public ISymbolNode PInvokeModuleFixup(string moduleName);
    public PInvokeMethodFixupNode PInvokeMethodFixup(string moduleName, string entryPointName, PInvokeFlags flags);
    public VTableSliceNode VTable(TypeDesc type);
    public ISortableSymbolNode MethodGenericDictionary(MethodDesc method);
    public ISortableSymbolNode TypeGenericDictionary(TypeDesc type);
    public DictionaryLayoutNode GenericDictionaryLayout(TypeSystemEntity methodOrType);
    public IMethodNode StringAllocator(MethodDesc stringConstructor);
    public IMethodNode MethodEntrypoint(MethodDesc method, bool unboxingStub);
    public MethodAssociatedDataNode MethodAssociatedData(IMethodNode methodNode);
    public IMethodNode FatFunctionPointer(MethodDesc method, bool isUnboxingStub);
    public IMethodNode ExactCallableAddress(MethodDesc method, bool isUnboxingStub);
    public IMethodNode CanonicalEntrypoint(MethodDesc method, bool isUnboxingStub);
    public GVMDependenciesNode GVMDependencies(MethodDesc method);
    internal TypeGVMEntriesNode TypeGVMEntries(TypeDesc type);
    public ReflectableMethodNode ReflectableMethod(MethodDesc method);
    public IMethodNode ShadowConcreteMethod(MethodDesc method, bool isUnboxingStub);
    public IMethodNode RuntimeDeterminedMethod(MethodDesc method);
    public ISymbolNode HelperEntrypoint(HelperEntrypoint entrypoint);
    public MetadataType get_ArrayOfTClass();
    public TypeDesc get_ArrayOfTEnumeratorType();
    public TypeDesc get_ICastableInterface();
    public DependencyNodeCore`1<NodeFactory> VirtualMethodUse(MethodDesc decl);
    public ISymbolNode ReadyToRunHelper(ReadyToRunHelperId id, object target);
    public ISymbolNode ReadyToRunHelperFromDictionaryLookup(ReadyToRunHelperId id, object target, TypeSystemEntity dictionaryOwner);
    public ISymbolNode ReadyToRunHelperFromTypeLookup(ReadyToRunHelperId id, object target, TypeSystemEntity dictionaryOwner);
    public ISymbolNode Indirection(ISortableSymbolNode symbol);
    internal TypeMetadataNode TypeMetadata(MetadataType type);
    internal MethodMetadataNode MethodMetadata(MethodDesc method);
    internal FieldMetadataNode FieldMetadata(FieldDesc field);
    internal ModuleMetadataNode ModuleMetadata(ModuleDesc module);
    public FrozenStringNode SerializedStringObject(string data);
    public FrozenArrayNode SerializedFrozenArray(PreInitFieldInfo preInitFieldInfo);
    public EmbeddedObjectNode EagerCctorIndirection(MethodDesc cctorMethod);
    public ISymbolNode ConstantUtf8String(string str);
    public ISymbolNode NamedJumpStub(string name, ISymbolNode target);
    public string GetSymbolAlternateName(ISymbolNode node);
    [CompilerGeneratedAttribute]
public InterfaceDispatchCellSectionNode get_InterfaceDispatchCellSection();
    public virtual void AttachToDependencyGraph(DependencyAnalyzerBase`1<NodeFactory> graph);
    [CompilerGeneratedAttribute]
public WindowsDebugDataHelper get_WindowsDebugData();
    [CompilerGeneratedAttribute]
private void set_WindowsDebugData(WindowsDebugDataHelper value);
    [CompilerGeneratedAttribute]
private IEETypeNode <CreateNodeCaches>b__36_0(TypeDesc type);
    [CompilerGeneratedAttribute]
private IEETypeNode <CreateNodeCaches>b__36_1(TypeDesc type);
    [CompilerGeneratedAttribute]
private IEETypeNode <CreateNodeCaches>b__36_2(TypeDesc type);
    [CompilerGeneratedAttribute]
private IEETypeNode <CreateNodeCaches>b__36_3(TypeDesc type);
    [CompilerGeneratedAttribute]
private ISortableSymbolNode <CreateNodeCaches>b__36_4(MetadataType type);
    [CompilerGeneratedAttribute]
private ISortableSymbolNode <CreateNodeCaches>b__36_5(MetadataType type);
    [CompilerGeneratedAttribute]
private GCStaticsPreInitDataNode <CreateNodeCaches>b__36_6(MetadataType type);
    [CompilerGeneratedAttribute]
private EmbeddedObjectNode <CreateNodeCaches>b__36_7(MetadataType type);
    [CompilerGeneratedAttribute]
private GCStaticEETypeNode <CreateNodeCaches>b__36_9(GCPointerMap gcMap);
    [CompilerGeneratedAttribute]
private IMethodNode <CreateNodeCaches>b__36_19(MethodKey methodKey);
    [CompilerGeneratedAttribute]
private IMethodNode <CreateNodeCaches>b__36_20(MethodDesc method);
    [CompilerGeneratedAttribute]
private ISymbolNode <CreateNodeCaches>b__36_22(ReadyToRunGenericHelperKey data);
    [CompilerGeneratedAttribute]
private ISymbolNode <CreateNodeCaches>b__36_23(ReadyToRunGenericHelperKey data);
    [CompilerGeneratedAttribute]
private ISymbolNode <CreateNodeCaches>b__36_24(ISortableSymbolNode indirectedNode);
    [CompilerGeneratedAttribute]
private FrozenStringNode <CreateNodeCaches>b__36_25(string data);
    [CompilerGeneratedAttribute]
private InterfaceDispatchMapNode <CreateNodeCaches>b__36_28(TypeDesc type);
    [CompilerGeneratedAttribute]
private EmbeddedObjectNode <CreateNodeCaches>b__36_32(TypeDesc type);
    [CompilerGeneratedAttribute]
private EmbeddedObjectNode <CreateNodeCaches>b__36_34(MethodDesc method);
    [CompilerGeneratedAttribute]
private VTableSliceNode <CreateNodeCaches>b__36_36(TypeDesc type);
    [CompilerGeneratedAttribute]
private ISortableSymbolNode <CreateNodeCaches>b__36_37(MethodDesc method);
    [CompilerGeneratedAttribute]
private ISortableSymbolNode <CreateNodeCaches>b__36_38(TypeDesc type);
}
public class ILCompiler.DependencyAnalysis.NonExternMethodSymbolNode : ExternSymbolNode {
    private MethodDesc _method;
    private bool _isUnboxing;
    private List`1<DependencyListEntry<NodeFactory>> _compilationDiscoveredDependencies;
    private ISymbolNode[] _funcletSymbols;
    private bool _dependenciesQueried;
    private bool _hasCompiledBody;
    private HashSet`1<GenericLookupResult> _floatingGenericLookupResults;
    public MethodDesc Method { get; }
    public bool IsSpecialUnboxingThunk { get; }
    public bool HasCompiledBody { get; }
    public bool StaticDependenciesAreComputed { get; }
    private ISymbolNode[] ILCompiler.DependencyAnalysis.IMethodBodyNodeWithFuncletSymbols.FuncletSymbols { get; }
    public int ClassCode { get; }
    public NonExternMethodSymbolNode(NodeFactory factory, MethodDesc method, bool isUnboxing);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual ExportForm GetExportForm(NodeFactory factory);
    public sealed virtual MethodDesc get_Method();
    public sealed virtual bool get_IsSpecialUnboxingThunk();
    public sealed virtual ISymbolNode GetUnboxingThunkTarget(NodeFactory factory);
    public bool get_HasCompiledBody();
    public void SetHasCompiledBody();
    public void SetFuncletCount(int funcletCount);
    public void DeferFloatingGenericLookup(GenericLookupResult lookupResult);
    protected virtual void OnMarked(NodeFactory factory);
    public void AddCompilationDiscoveredDependency(IDependencyNode`1<NodeFactory> node, string reason);
    public virtual bool get_StaticDependenciesAreComputed();
    private sealed virtual override ISymbolNode[] ILCompiler.DependencyAnalysis.IMethodBodyNodeWithFuncletSymbols.get_FuncletSymbols();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.NonGCStaticsNode : ObjectNode {
    private MetadataType _type;
    private NodeFactory _factory;
    private List`1<PreInitFieldInfo> _sortedPreInitFields;
    public ObjectNodeSection Section { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public IDebugInfo DebugInfo { get; }
    public bool IsShareable { get; }
    public MetadataType Type { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public NonGCStaticsNode(MetadataType type, NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public static string GetMangledName(TypeDesc type, NameMangler nameMangler);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public sealed virtual IDebugInfo get_DebugInfo();
    public virtual bool get_IsShareable();
    public MetadataType get_Type();
    public virtual ExportForm GetExportForm(NodeFactory factory);
    private static int GetClassConstructorContextSize(TargetDetails target);
    public static int GetClassConstructorContextStorageSize(TargetDetails target, MetadataType type);
    private static int GetClassConstructorContextAlignment(TargetDetails target);
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.NullTypeIndexDebugInfo : object {
    public int TypeIndex { get; }
    public static IDebugInfo Instance { get; }
    public sealed virtual int get_TypeIndex();
    public static IDebugInfo get_Instance();
}
internal class ILCompiler.DependencyAnalysis.ObjectAllocatorGenericLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public ObjectAllocatorGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.ObjectAndOffsetSymbolNode : DependencyNodeCore`1<NodeFactory> {
    private ObjectNode _object;
    private int _offset;
    private Utf8String _name;
    private bool _includeCompilationUnitPrefix;
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public ObjectNode Target { get; }
    public ObjectAndOffsetSymbolNode(ObjectNode obj, int offset, Utf8String name, bool includeCompilationUnitPrefix);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public sealed virtual bool get_RepresentsIndirectionCell();
    public void SetSymbolOffset(int offset);
    public ObjectNode get_Target();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.ObjectDataBuilder : ValueType {
    private TargetDetails _target;
    private ArrayBuilder`1<Relocation> _relocs;
    private ArrayBuilder`1<byte> _data;
    [CompilerGeneratedAttribute]
private int <Alignment>k__BackingField;
    private ArrayBuilder`1<ISymbolDefinitionNode> _definedSymbols;
    public int Alignment { get; private set; }
    public int CountBytes { get; }
    public int TargetPointerSize { get; }
    public ObjectDataBuilder(NodeFactory factory, bool relocsOnly);
    [CompilerGeneratedAttribute]
public int get_Alignment();
    [CompilerGeneratedAttribute]
private void set_Alignment(int value);
    public sealed virtual int get_CountBytes();
    public sealed virtual int get_TargetPointerSize();
    public void RequireInitialAlignment(int align);
    public void RequireInitialPointerAlignment();
    public void EmitByte(byte emit);
    public void EmitShort(short emit);
    public void EmitInt(int emit);
    public void EmitUInt(UInt32 emit);
    public void EmitLong(long emit);
    public sealed virtual void EmitNaturalInt(int emit);
    public sealed virtual void EmitHalfNaturalInt(short emit);
    public void EmitCompressedUInt(UInt32 emit);
    public void EmitBytes(Byte[] bytes);
    public void EmitBytes(Byte[] bytes, int offset, int length);
    internal void EmitBytes(ArrayBuilder`1<byte> bytes);
    public void EmitZeroPointer();
    public void EmitZeros(int numBytes);
    private Reservation GetReservationTicket(int size);
    private int ReturnReservationTicket(Reservation reservation);
    public Reservation ReserveByte();
    public void EmitByte(Reservation reservation, byte emit);
    public Reservation ReserveShort();
    public void EmitShort(Reservation reservation, short emit);
    public Reservation ReserveInt();
    public void EmitInt(Reservation reservation, int emit);
    public void EmitReloc(ISymbolNode symbol, RelocType relocType, int delta);
    public void EmitPointerReloc(ISymbolNode symbol, int delta);
    public ObjectData ToObjectData();
    public void AddSymbol(ISymbolDefinitionNode node);
}
public abstract class ILCompiler.DependencyAnalysis.ObjectNode : SortableDependencyNode {
    public bool RepresentsIndirectionCell { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public virtual bool get_RepresentsIndirectionCell();
    public abstract virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public abstract virtual ObjectNodeSection get_Section();
    public abstract virtual bool get_IsShareable();
    public virtual bool ShouldSkipEmittingObjectNode(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
public class ILCompiler.DependencyAnalysis.ObjectNodeSection : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SectionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComdatName>k__BackingField;
    public static ObjectNodeSection XDataSection;
    public static ObjectNodeSection DataSection;
    public static ObjectNodeSection ReadOnlyDataSection;
    public static ObjectNodeSection FoldableReadOnlyDataSection;
    public static ObjectNodeSection TextSection;
    public static ObjectNodeSection TLSSection;
    public string Name { get; }
    public SectionType Type { get; }
    public string ComdatName { get; }
    public bool IsStandardSection { get; }
    public ObjectNodeSection(string name, SectionType type, string comdatName);
    public ObjectNodeSection(string name, SectionType type);
    private static ObjectNodeSection();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public SectionType get_Type();
    [CompilerGeneratedAttribute]
public string get_ComdatName();
    public bool get_IsStandardSection();
}
internal class ILCompiler.DependencyAnalysis.ObjectWriter : object {
    private Utf8StringBuilder _sb;
    private Dictionary`2<string, int> _debugFileToId;
    private SortedSet`1<int> _byteInterruptionOffsets;
    private Dictionary`2<int, DebugLocInfo> _offsetToDebugLoc;
    private Dictionary`2<int, List`1<ISymbolDefinitionNode>> _offsetToDefName;
    private Dictionary`2<int, List`1<Byte[]>> _offsetToCfis;
    private Dictionary`2<int, Byte[]> _offsetToCfiLsdaBlobName;
    private HashSet`1<int> _offsetToCfiStart;
    private HashSet`1<int> _offsetToCfiEnd;
    private bool _frameOpened;
    private static int CfiCodeSize;
    private ObjectNodeSection _currentSection;
    private Utf8String _currentNodeZeroTerminatedName;
    private static string NativeObjectWriterFileName;
    private TargetDetails _targetPlatform;
    private NodeFactory _nodeFactory;
    public static ObjectNodeSection LsdaSection;
    private UserDefinedTypeDescriptor _userDefinedTypeDescriptor;
    private IntPtr _nativeObjectWriter;
    public ObjectWriter(string objectFilePath, NodeFactory factory);
    private static ObjectWriter();
    private static IntPtr InitObjWriter(string objectFilePath);
    private static void FinishObjWriter(IntPtr objWriter);
    private static void SwitchSection(IntPtr objWriter, string sectionName, CustomSectionAttributes attributes, string comdatName);
    public void SetSection(ObjectNodeSection section);
    private static void SetCodeSectionAttribute(IntPtr objWriter, string sectionName, CustomSectionAttributes attributes, string comdatName);
    public void SetCodeSectionAttribute(ObjectNodeSection section);
    public void EnsureCurrentSection();
    private CustomSectionAttributes GetCustomSectionAttributes(ObjectNodeSection section);
    private static void EmitAlignment(IntPtr objWriter, int byteAlignment);
    public void EmitAlignment(int byteAlignment);
    private static void EmitBlob(IntPtr objWriter, int blobSize, Byte[] blob);
    public void EmitBlob(Byte[] blob);
    private static void EmitIntValue(IntPtr objWriter, ulong value, int size);
    public void EmitIntValue(ulong value, int size);
    private static void EmitBlob(IntPtr objWriter, int blobSize, IntPtr blob);
    public void EmitBytes(IntPtr pArray, int length);
    private static void EmitSymbolDef(IntPtr objWriter, Byte[] symbolName);
    public void EmitSymbolDef(Byte[] symbolName);
    public void EmitSymbolDef(Utf8StringBuilder symbolName);
    private static int EmitSymbolRef(IntPtr objWriter, Byte[] symbolName, RelocType relocType, int delta);
    public int EmitSymbolRef(Utf8StringBuilder symbolName, RelocType relocType, int delta);
    private static void EmitWinFrameInfo(IntPtr objWriter, Byte[] methodName, int startOffset, int endOffset, Byte[] blobSymbolName);
    public void EmitWinFrameInfo(int startOffset, int endOffset, int blobSize, Byte[] blobSymbolName);
    private static void EmitCFIStart(IntPtr objWriter, int nativeOffset);
    public void EmitCFIStart(int nativeOffset);
    private static void EmitCFIEnd(IntPtr objWriter, int nativeOffset);
    public void EmitCFIEnd(int nativeOffset);
    private static void EmitCFILsda(IntPtr objWriter, Byte[] blobSymbolName);
    public void EmitCFILsda(Byte[] blobSymbolName);
    private static void EmitCFICode(IntPtr objWriter, int nativeOffset, Byte[] blob);
    public void EmitCFICode(int nativeOffset, Byte[] blob);
    private static void EmitDebugFileInfo(IntPtr objWriter, int fileId, string fileName);
    public void EmitDebugFileInfo(int fileId, string fileName);
    private static void EmitDebugLoc(IntPtr objWriter, int nativeOffset, int fileId, int linueNumber, int colNumber);
    public void EmitDebugLoc(int nativeOffset, int fileId, int linueNumber, int colNumber);
    private static UInt32 GetEnumTypeIndex(IntPtr objWriter, EnumTypeDescriptor enumTypeDescriptor, EnumRecordTypeDescriptor[] typeRecords);
    public sealed virtual UInt32 GetEnumTypeIndex(EnumTypeDescriptor enumTypeDescriptor, EnumRecordTypeDescriptor[] typeRecords);
    private static UInt32 GetClassTypeIndex(IntPtr objWriter, ClassTypeDescriptor classTypeDescriptor);
    private static UInt32 GetCompleteClassTypeIndex(IntPtr objWriter, ClassTypeDescriptor classTypeDescriptor, ClassFieldsTypeDescriptor classFieldsTypeDescriptior, DataFieldDescriptor[] fields, StaticDataFieldDescriptor[] statics);
    private static UInt32 GetPrimitiveTypeIndex(IntPtr objWriter, int type);
    private static void EmitARMFnStart(IntPtr objWriter);
    public void EmitARMFnStart();
    private static void EmitARMFnEnd(IntPtr objWriter);
    public void EmitARMFnEnd();
    private static void EmitARMExIdxCode(IntPtr objWriter, int nativeOffset, Byte[] blob);
    public void EmitARMExIdxCode(int nativeOffset, Byte[] blob);
    private static void EmitARMExIdxLsda(IntPtr objWriter, Byte[] blob);
    public void EmitARMExIdxLsda(Byte[] blob);
    public sealed virtual UInt32 GetClassTypeIndex(ClassTypeDescriptor classTypeDescriptor);
    public sealed virtual UInt32 GetCompleteClassTypeIndex(ClassTypeDescriptor classTypeDescriptor, ClassFieldsTypeDescriptor classFieldsTypeDescriptior, DataFieldDescriptor[] fields, StaticDataFieldDescriptor[] statics);
    public sealed virtual UInt32 GetPrimitiveTypeIndex(TypeDesc type);
    private static UInt32 GetArrayTypeIndex(IntPtr objWriter, ClassTypeDescriptor classDescriptor, ArrayTypeDescriptor arrayTypeDescriptor);
    public sealed virtual UInt32 GetArrayTypeIndex(ClassTypeDescriptor classDescriptor, ArrayTypeDescriptor arrayTypeDescriptor);
    public sealed virtual string GetMangledName(TypeDesc type);
    private static void EmitDebugVar(IntPtr objWriter, string name, UInt32 typeIndex, bool isParam, int rangeCount, NativeVarInfo[] range);
    public void EmitDebugVar(DebugVarInfo debugVar);
    public void EmitDebugVarInfo(ObjectNode node);
    private static void EmitDebugEHClause(IntPtr objWriter, UInt32 TryOffset, UInt32 TryLength, UInt32 HandlerOffset, UInt32 HandlerLength);
    public void EmitDebugEHClause(DebugEHClauseInfo ehClause);
    public void EmitDebugEHClauseInfo(ObjectNode node);
    private static void EmitDebugFunctionInfo(IntPtr objWriter, Byte[] methodName, int methodSize, UInt32 methodTypeIndex);
    public void EmitDebugFunctionInfo(ObjectNode node, int methodSize);
    private static void EmitDebugModuleInfo(IntPtr objWriter);
    public void EmitDebugModuleInfo();
    public bool HasModuleDebugInfo();
    public bool HasFunctionDebugInfo();
    public void BuildFileInfoMap(IEnumerable`1<DependencyNode> nodes);
    public void BuildDebugLocInfoMap(ObjectNode node);
    public void PublishUnwindInfo(ObjectNode node);
    public void BuildCFIMap(NodeFactory factory, ObjectNode node);
    public void EmitCFICodes(int offset);
    public void EmitDebugLocInfo(int offset);
    public void BuildSymbolDefinitionMap(ObjectNode node, ISymbolDefinitionNode[] definedSymbols);
    private void AppendExternCPrefix(Utf8StringBuilder sb);
    public int EmitSymbolReference(ISymbolNode target, int delta, RelocType relocType);
    public void EmitBlobWithRelocs(Byte[] blob, Relocation[] relocs);
    public void EmitSymbolDefinition(int currentOffset);
    public sealed virtual void Dispose();
    public virtual void Dispose(bool bDisposing);
    protected virtual override void Finalize();
    private bool ShouldShareSymbol(ObjectNode node);
    private ObjectNodeSection GetSharedSection(ObjectNodeSection section, string key);
    public void ResetByteRunInterruptionOffsets(Relocation[] relocs);
    public static void EmitObject(string objectFilePath, IEnumerable`1<DependencyNode> nodes, NodeFactory factory, IObjectDumper dumper);
    private static UInt32 GetPointerTypeIndex(IntPtr objWriter, PointerTypeDescriptor pointerDescriptor);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetPointerTypeIndex(PointerTypeDescriptor pointerDescriptor);
    private static UInt32 GetMemberFunctionTypeIndex(IntPtr objWriter, MemberFunctionTypeDescriptor memberDescriptor, UInt32[] argumentTypes);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetMemberFunctionTypeIndex(MemberFunctionTypeDescriptor memberDescriptor, UInt32[] argumentTypes);
    private static UInt32 GetMemberFunctionIdTypeIndex(IntPtr objWriter, MemberFunctionIdTypeDescriptor memberIdDescriptor);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetMemberFunctionId(MemberFunctionIdTypeDescriptor memberIdDescriptor);
}
public class ILCompiler.DependencyAnalysis.PInvokeMethodFixupNode : ObjectNode {
    private string _moduleName;
    private string _entryPointName;
    private PInvokeFlags _flags;
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public PInvokeMethodFixupNode(string moduleName, string entryPointName, PInvokeFlags flags);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.PInvokeModuleFixupNode : ObjectNode {
    public string _moduleName;
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public PInvokeModuleFixupNode(string moduleName);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.PointerToSlotLookupResult : GenericLookupResult {
    private int _slotIndex;
    public int SlotIndex { get; }
    protected int ClassCode { get; }
    public PointerToSlotLookupResult(int slotIndex);
    public int get_SlotIndex();
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual bool EqualsImpl(GenericLookupResult other);
    protected virtual int GetHashCodeImpl();
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
}
public class ILCompiler.DependencyAnalysis.PrecomputedDictionaryLayoutNode : DictionaryLayoutNode {
    private GenericLookupResult[] _layout;
    public bool HasFixedSlots { get; }
    public IEnumerable`1<GenericLookupResult> Entries { get; }
    public PrecomputedDictionaryLayoutNode(TypeSystemEntity owningMethodOrType, IEnumerable`1<GenericLookupResult> layout);
    public virtual bool get_HasFixedSlots();
    public virtual void EnsureEntry(GenericLookupResult entry);
    public virtual int GetSlotForEntry(GenericLookupResult entry);
    public virtual IEnumerable`1<GenericLookupResult> get_Entries();
}
internal class ILCompiler.DependencyAnalysis.PrecomputedVTableSliceNode : VTableSliceNode {
    private IReadOnlyList`1<MethodDesc> _slots;
    public IReadOnlyList`1<MethodDesc> Slots { get; }
    public bool HasFixedSlots { get; }
    public PrecomputedVTableSliceNode(TypeDesc type, IReadOnlyList`1<MethodDesc> slots);
    public virtual IReadOnlyList`1<MethodDesc> get_Slots();
    public virtual bool get_HasFixedSlots();
}
public static class ILCompiler.DependencyAnalysis.ProjectNDependencyBehavior : object {
    public static bool EnableFullAnalysis;
    private static ProjectNDependencyBehavior();
}
public abstract class ILCompiler.DependencyAnalysis.ReadyToRunGenericHelperNode : AssemblyStubNode {
    private ReadyToRunHelperId _id;
    private object _target;
    protected TypeSystemEntity _dictionaryOwner;
    protected GenericLookupResult _lookupSignature;
    protected bool IsVisibleFromManagedCode { get; }
    public bool IsShareable { get; }
    public bool HasConditionalStaticDependencies { get; }
    public ReadyToRunGenericHelperNode(NodeFactory factory, ReadyToRunHelperId helperId, object target, TypeSystemEntity dictionaryOwner);
    public static GenericLookupResult GetLookupSignature(NodeFactory factory, ReadyToRunHelperId id, object target);
    protected virtual bool get_IsVisibleFromManagedCode();
    protected sealed virtual string GetName(NodeFactory factory);
    public virtual bool get_IsShareable();
    protected sealed virtual void OnMarked(NodeFactory factory);
    public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> InstantiateDependencies(NodeFactory factory, Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected void AppendLookupSignatureMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
    protected Register GetContextRegister(X64Emitter& encoder);
    protected void EmitDictionaryLookup(NodeFactory factory, X64Emitter& encoder, Register context, Register result, GenericLookupResult lookup, bool relocsOnly);
    protected sealed virtual void EmitCode(NodeFactory factory, X64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitLoadGenericContext(NodeFactory factory, X64Emitter& encoder, bool relocsOnly);
    protected sealed virtual void EmitCode(NodeFactory factory, X86Emitter& encoder, bool relocsOnly);
    protected Register GetContextRegister(ARM64Emitter& encoder);
    protected void EmitDictionaryLookup(NodeFactory factory, ARM64Emitter& encoder, Register context, Register result, GenericLookupResult lookup, bool relocsOnly);
    protected sealed virtual void EmitCode(NodeFactory factory, ARM64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitLoadGenericContext(NodeFactory factory, ARM64Emitter& encoder, bool relocsOnly);
    protected Register GetContextRegister(ARMEmitter& encoder);
    protected void EmitDictionaryLookup(NodeFactory factory, ARMEmitter& encoder, Register context, Register result, GenericLookupResult lookup, bool relocsOnly);
    protected sealed virtual void EmitCode(NodeFactory factory, ARMEmitter& encoder, bool relocsOnly);
    protected virtual void EmitLoadGenericContext(NodeFactory factory, ARMEmitter& encoder, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.ReadyToRunGenericLookupFromDictionaryNode : ReadyToRunGenericHelperNode {
    public int ClassCode { get; }
    public ReadyToRunGenericLookupFromDictionaryNode(NodeFactory factory, ReadyToRunHelperId helperId, object target, TypeSystemEntity dictionaryOwner);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.ReadyToRunGenericLookupFromTypeNode : ReadyToRunGenericHelperNode {
    public int ClassCode { get; }
    public ReadyToRunGenericLookupFromTypeNode(NodeFactory factory, ReadyToRunHelperId helperId, object target, TypeSystemEntity dictionaryOwner);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual int get_ClassCode();
    protected virtual void EmitLoadGenericContext(NodeFactory factory, X64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitLoadGenericContext(NodeFactory factory, ARM64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitLoadGenericContext(NodeFactory factory, ARMEmitter& encoder, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.ReadyToRunHeaderNode : ObjectNode {
    private List`1<HeaderItem> _items;
    private TargetDetails _target;
    public int Offset { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public int ClassCode { get; }
    public ReadyToRunHeaderNode(TargetDetails target);
    public void Add(ReadyToRunSectionType id, ObjectNode node, ISymbolNode startSymbol, ISymbolNode endSymbol);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
}
public enum ILCompiler.DependencyAnalysis.ReadyToRunHelperId : Enum {
    public int value__;
    public static ReadyToRunHelperId Invalid;
    public static ReadyToRunHelperId NewHelper;
    public static ReadyToRunHelperId NewArr1;
    public static ReadyToRunHelperId VirtualCall;
    public static ReadyToRunHelperId IsInstanceOf;
    public static ReadyToRunHelperId CastClass;
    public static ReadyToRunHelperId GetNonGCStaticBase;
    public static ReadyToRunHelperId GetGCStaticBase;
    public static ReadyToRunHelperId GetThreadStaticBase;
    public static ReadyToRunHelperId DelegateCtor;
    public static ReadyToRunHelperId ResolveVirtualFunction;
    public static ReadyToRunHelperId TypeHandle;
    public static ReadyToRunHelperId NecessaryTypeHandle;
    public static ReadyToRunHelperId MethodHandle;
    public static ReadyToRunHelperId FieldHandle;
    public static ReadyToRunHelperId MethodDictionary;
    public static ReadyToRunHelperId MethodEntry;
    public static ReadyToRunHelperId VirtualDispatchCell;
    public static ReadyToRunHelperId DefaultConstructor;
}
public class ILCompiler.DependencyAnalysis.ReadyToRunHelperNode : AssemblyStubNode {
    private ReadyToRunHelperId _id;
    private object _target;
    protected bool IsVisibleFromManagedCode { get; }
    public ReadyToRunHelperId Id { get; }
    public object Target { get; }
    public bool IsShareable { get; }
    private DebugLocInfo[] ILCompiler.DependencyAnalysis.INodeWithDebugInfo.DebugLocInfos { get; }
    private DebugVarInfo[] ILCompiler.DependencyAnalysis.INodeWithDebugInfo.DebugVarInfos { get; }
    public int ClassCode { get; }
    public ReadyToRunHelperNode(NodeFactory factory, ReadyToRunHelperId id, object target);
    protected virtual bool get_IsVisibleFromManagedCode();
    protected virtual string GetName(NodeFactory factory);
    public ReadyToRunHelperId get_Id();
    public object get_Target();
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual bool get_IsShareable();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    private sealed virtual override DebugLocInfo[] ILCompiler.DependencyAnalysis.INodeWithDebugInfo.get_DebugLocInfos();
    private sealed virtual override DebugVarInfo[] ILCompiler.DependencyAnalysis.INodeWithDebugInfo.get_DebugVarInfos();
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
    protected virtual void EmitCode(NodeFactory factory, X64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, X86Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARM64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARMEmitter& encoder, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.ReflectableMethodNode : DependencyNodeCore`1<NodeFactory> {
    private MethodDesc _method;
    public MethodDesc Method { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ReflectableMethodNode(MethodDesc method);
    public MethodDesc get_Method();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.ReflectionFieldMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ReflectionFieldMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.ReflectionInvokeMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ReflectionInvokeMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    private bool MethodRequiresInstArg(MethodDesc method, bool isUnboxingStub);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.ReflectionVirtualInvokeMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ReflectionVirtualInvokeMapNode(ExternalReferencesTableNode externalReferences);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public ISymbolNode get_EndSymbol();
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public static bool NeedsVirtualInvokeInfo(MethodDesc method);
    public static MethodDesc GetDeclaringVirtualMethodAndHierarchyDistance(MethodDesc method, Int32& parentHierarchyDistance);
    public static void GetVirtualInvokeMapDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.Relocation : ValueType {
    public RelocType RelocType;
    public int Offset;
    public ISymbolNode Target;
    public Relocation(RelocType relocType, int offset, ISymbolNode target);
    private static ushort GetThumb2Imm16(UInt16* p);
    private static void PutThumb2Imm16(UInt16* p, ushort imm16);
    private static int GetThumb2Mov32(UInt16* p);
    private static void PutThumb2Mov32(UInt16* p, UInt32 imm32);
    private static int GetThumb2BlRel24(UInt16* p);
    private static bool FitsInThumb2BlRel24(UInt32 imm24);
    private static void PutThumb2BlRel24(UInt16* p, UInt32 imm24);
    public static void WriteValue(RelocType relocType, Void* location, long value);
    public static long ReadValue(RelocType relocType, Void* location);
    public virtual string ToString();
}
public enum ILCompiler.DependencyAnalysis.RelocType : Enum {
    public int value__;
    public static RelocType IMAGE_REL_BASED_ABSOLUTE;
    public static RelocType IMAGE_REL_BASED_ADDR32NB;
    public static RelocType IMAGE_REL_BASED_HIGHLOW;
    public static RelocType IMAGE_REL_BASED_THUMB_MOV32;
    public static RelocType IMAGE_REL_BASED_DIR64;
    public static RelocType IMAGE_REL_BASED_REL32;
    public static RelocType IMAGE_REL_BASED_THUMB_BRANCH24;
    public static RelocType IMAGE_REL_BASED_ARM64_BRANCH26;
    public static RelocType IMAGE_REL_BASED_RELPTR32;
    public static RelocType IMAGE_REL_SECREL;
    public static RelocType IMAGE_REL_BASED_ARM64_PAGEBASE_REL21;
    public static RelocType IMAGE_REL_BASED_ARM64_PAGEOFFSET_12A;
    public static RelocType IMAGE_REL_BASED_ARM64_PAGEOFFSET_12L;
}
internal class ILCompiler.DependencyAnalysis.ResourceDataNode : ObjectNode {
    private List`1<ResourceIndexData> _indexData;
    private int _totalLength;
    private ObjectAndOffsetSymbolNode _endSymbol;
    public ISymbolDefinitionNode EndSymbol { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ISymbolDefinitionNode get_EndSymbol();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public IReadOnlyList`1<ResourceIndexData> GetOrCreateIndexData(NodeFactory factory);
    private Byte[] GenerateResourceBlob(NodeFactory factory);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.ResourceIndexData : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NativeOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EcmaOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private EcmaModule <EcmaModule>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public string AssemblyName { get; }
    public string ResourceName { get; }
    public int NativeOffset { get; }
    public int EcmaOffset { get; }
    public EcmaModule EcmaModule { get; }
    public int Length { get; }
    public ResourceIndexData(string assemblyName, string resourceName, int nativeOffset, int ecmaOffset, EcmaModule ecmaModule, int length);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_ResourceName();
    [CompilerGeneratedAttribute]
public int get_NativeOffset();
    [CompilerGeneratedAttribute]
public int get_EcmaOffset();
    [CompilerGeneratedAttribute]
public EcmaModule get_EcmaModule();
    [CompilerGeneratedAttribute]
public int get_Length();
}
internal class ILCompiler.DependencyAnalysis.ResourceIndexNode : ObjectNode {
    private ResourceDataNode _resourceDataNode;
    private ObjectAndOffsetSymbolNode _endSymbol;
    public ISymbolDefinitionNode EndSymbol { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ResourceIndexNode(ResourceDataNode resourceDataNode);
    public ISymbolDefinitionNode get_EndSymbol();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    private Byte[] GenerateIndexBlob(NodeFactory factory);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
public class ILCompiler.DependencyAnalysis.RuntimeDecodableJumpStubNode : JumpStubNode {
    private IMethodNode WrappedMethodIndirectionCellNode { get; }
    public MethodDesc Method { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public RuntimeDecodableJumpStubNode(IMethodNode target);
    private IMethodNode get_WrappedMethodIndirectionCellNode();
    public sealed virtual MethodDesc get_Method();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual string GetName(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.RuntimeDeterminedMethodNode : DependencyNodeCore`1<NodeFactory> {
    private IMethodNode _canonicalMethodNode;
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    public MethodDesc Method { get; }
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISortableNode.ClassCode { get; }
    public RuntimeDeterminedMethodNode(MethodDesc method, IMethodNode canonicalMethod);
    [CompilerGeneratedAttribute]
public sealed virtual MethodDesc get_Method();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public sealed virtual bool get_RepresentsIndirectionCell();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.RuntimeDeterminedMethodNode/<GetStaticDependencies>d__10")]
public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.RuntimeDeterminedMethodNode/<InstantiateDependencies>d__12")]
public sealed virtual IEnumerable`1<DependencyListEntry<NodeFactory>> InstantiateDependencies(NodeFactory factory, Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.get_ClassCode();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.RuntimeFieldHandleNode : ObjectNode {
    private FieldDesc _targetField;
    private static Utf8String s_NativeLayoutSignaturePrefix;
    public int Offset { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public int ClassCode { get; }
    public RuntimeFieldHandleNode(FieldDesc targetField);
    private static RuntimeFieldHandleNode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.RuntimeImportMethodNode : ExternSymbolNode {
    private MethodDesc _method;
    public MethodDesc Method { get; }
    public int ClassCode { get; }
    public RuntimeImportMethodNode(MethodDesc method);
    public sealed virtual MethodDesc get_Method();
    public sealed virtual ExportForm GetExportForm(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.RuntimeMethodHandleNode : ObjectNode {
    private MethodDesc _targetMethod;
    private static Utf8String s_NativeLayoutSignaturePrefix;
    public MethodDesc Method { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public int ClassCode { get; }
    public RuntimeMethodHandleNode(MethodDesc targetMethod);
    private static RuntimeMethodHandleNode();
    public MethodDesc get_Method();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.RyuJitNodeFactory : NodeFactory {
    public RyuJitNodeFactory(CompilerTypeSystemContext context, CompilationModuleGroup compilationModuleGroup, MetadataManager metadataManager, InteropStubManager interopStubManager, NameMangler nameMangler, VTableSliceProvider vtableSliceProvider, DictionaryLayoutProvider dictionaryLayoutProvider);
    protected virtual IMethodNode CreateMethodEntrypointNode(MethodDesc method);
    protected virtual IMethodNode CreateUnboxingStubNode(MethodDesc method);
    protected virtual ISymbolNode CreateReadyToRunHelperNode(ReadyToRunHelperKey helperCall);
}
public class ILCompiler.DependencyAnalysis.ScannedMethodNode : DependencyNodeCore`1<NodeFactory> {
    private MethodDesc _method;
    private DependencyList<NodeFactory> _dependencies;
    public MethodDesc Method { get; }
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool StaticDependenciesAreComputed { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    private int ILCompiler.DependencyAnalysis.ISortableNode.ClassCode { get; }
    public ScannedMethodNode(MethodDesc method);
    public sealed virtual MethodDesc get_Method();
    public sealed virtual int get_Offset();
    public sealed virtual bool get_RepresentsIndirectionCell();
    public virtual bool get_StaticDependenciesAreComputed();
    public void InitializeDependencies(NodeFactory factory, IEnumerable`1<DependencyListEntry<NodeFactory>> dependencies);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.get_ClassCode();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.SealedVTableNode : ObjectNode {
    private TypeDesc _type;
    private List`1<MethodDesc> _sealedVTableEntries;
    public ObjectNodeSection Section { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int NumSealedVTableEntries { get; }
    public int ClassCode { get; }
    public SealedVTableNode(TypeDesc type);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public int get_NumSealedVTableEntries();
    public int ComputeSealedVTableSlot(MethodDesc method);
    public bool BuildSealedVTableSlots(NodeFactory factory, bool relocsOnly);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public enum ILCompiler.DependencyAnalysis.SectionType : Enum {
    public int value__;
    public static SectionType ReadOnly;
    public static SectionType Writeable;
    public static SectionType Executable;
}
public class ILCompiler.DependencyAnalysis.ShadowConcreteMethodNode : DependencyNodeCore`1<NodeFactory> {
    [CompilerGeneratedAttribute]
private IMethodNode <CanonicalMethodNode>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    public IMethodNode CanonicalMethodNode { get; }
    public MethodDesc Method { get; }
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool StaticDependenciesAreComputed { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    private int ILCompiler.DependencyAnalysis.ISortableNode.ClassCode { get; }
    public ShadowConcreteMethodNode(MethodDesc method, IMethodNode canonicalMethod);
    [CompilerGeneratedAttribute]
public IMethodNode get_CanonicalMethodNode();
    [CompilerGeneratedAttribute]
public sealed virtual MethodDesc get_Method();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public sealed virtual bool get_RepresentsIndirectionCell();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual ISymbolNode NodeForLinkage(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual bool get_HasConditionalStaticDependencies();
    public sealed virtual bool get_HasDynamicDependencies();
    public sealed virtual bool get_InterestingForDynamicDependencyAnalysis();
    public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.get_ClassCode();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.ShadowConcreteUnboxingThunkNode : DependencyNodeCore`1<NodeFactory> {
    private IMethodNode _canonicalThunk;
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    public MethodDesc Method { get; }
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool StaticDependenciesAreComputed { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    private int ILCompiler.DependencyAnalysis.ISortableNode.ClassCode { get; }
    public ShadowConcreteUnboxingThunkNode(MethodDesc method, IMethodNode canonicalMethod);
    [CompilerGeneratedAttribute]
public sealed virtual MethodDesc get_Method();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public sealed virtual bool get_RepresentsIndirectionCell();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual bool get_HasConditionalStaticDependencies();
    public sealed virtual bool get_HasDynamicDependencies();
    public sealed virtual bool get_InterestingForDynamicDependencyAnalysis();
    public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public sealed virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.get_ClassCode();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public abstract class ILCompiler.DependencyAnalysis.SortableDependencyNode : DependencyNodeCore`1<NodeFactory> {
    protected internal int Phase { get; }
    public int ClassCode { get; }
    protected internal virtual int get_Phase();
    public abstract virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
    public static int CompareImpl(SortableDependencyNode x, SortableDependencyNode y, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.StackTraceEmbeddedMetadataNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    public ISymbolDefinitionNode EndSymbol { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ISymbolDefinitionNode get_EndSymbol();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.StackTraceMethodMappingNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    public ISymbolDefinitionNode EndSymbol { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public ISymbolDefinitionNode get_EndSymbol();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.StandaloneGCStaticDescRegionNode : ObjectNode {
    private GCStaticDescNode _standaloneGCStaticDesc;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public StandaloneGCStaticDescRegionNode(GCStaticDescNode standaloneGCStaticDesc);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.StaticsInfoHashtableNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    private ExternalReferencesTableNode _nativeStaticsReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public StaticsInfoHashtableNode(ExternalReferencesTableNode externalReferences, ExternalReferencesTableNode nativeStaticsReferences);
    public ISymbolNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public static void AddStaticsInfoDependencies(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.StringAllocatorMethodNode : DependencyNodeCore`1<NodeFactory> {
    private MethodDesc _allocationMethod;
    private MethodDesc _constructorMethod;
    public MethodDesc Method { get; }
    public int Offset { get; }
    public bool RepresentsIndirectionCell { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    private int ILCompiler.DependencyAnalysis.ISortableNode.ClassCode { get; }
    public StringAllocatorMethodNode(MethodDesc constructorMethod);
    public sealed virtual MethodDesc get_Method();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public sealed virtual bool get_RepresentsIndirectionCell();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory context);
    protected virtual string GetName(NodeFactory factory);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.get_ClassCode();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISortableNode.CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.StructMarshallingStubMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolDefinitionNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public StructMarshallingStubMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolDefinitionNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.ThreadStaticIndexLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public ThreadStaticIndexLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.ThreadStaticOffsetLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public TypeDesc Type { get; }
    public ThreadStaticOffsetLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public TypeDesc get_Type();
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.ThreadStaticsDirectoryNode : ObjectNode {
    private string _prefix;
    public string MangledName { get; }
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public ThreadStaticsDirectoryNode(string prefix);
    public string get_MangledName();
    public static string GetMangledName(string prefix);
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.ThreadStaticsIndexNode : ObjectNode {
    private string _prefix;
    public string MangledName { get; }
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public ThreadStaticsIndexNode(string prefix);
    public string get_MangledName();
    public static string GetMangledName(string prefix);
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectNodeSection get_Section();
    public sealed virtual ExportForm GetExportForm(NodeFactory factory);
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.ThreadStaticsNode : EmbeddedObjectNode {
    private MetadataType _type;
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public ThreadStaticsNode(MetadataType type, NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public static string GetMangledName(TypeDesc type, NameMangler nameMangler);
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private ISymbolNode GetGCStaticEETypeNode(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual void EncodeData(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.ThreadStaticsOffsetNode : EmbeddedObjectNode {
    private MetadataType _type;
    public MetadataType Type { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolNode.Offset { get; }
    private int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.Offset { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public ThreadStaticsOffsetNode(MetadataType type, NodeFactory factory);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public static string GetMangledName(NameMangler nameMangler, TypeDesc type);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public sealed virtual ExportForm GetExportForm(NodeFactory factory);
    public MetadataType get_Type();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolNode.get_Offset();
    private sealed virtual override int ILCompiler.DependencyAnalysis.ISymbolDefinitionNode.get_Offset();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual void EncodeData(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    public sealed virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.TypeGCStaticBaseGenericLookupResult : GenericLookupResult {
    private MetadataType _type;
    protected int ClassCode { get; }
    public MetadataType Type { get; }
    public TypeGCStaticBaseGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public MetadataType get_Type();
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.TypeGenericDictionaryNode : GenericDictionaryNode {
    private TypeDesc _owningType;
    protected int HeaderSize { get; }
    public Instantiation TypeInstantiation { get; }
    public Instantiation MethodInstantiation { get; }
    protected TypeSystemContext Context { get; }
    public TypeSystemEntity OwningEntity { get; }
    public TypeDesc OwningType { get; }
    public bool HasConditionalStaticDependencies { get; }
    public int ClassCode { get; }
    public TypeGenericDictionaryNode(TypeDesc owningType, NodeFactory factory);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual int get_HeaderSize();
    public virtual Instantiation get_TypeInstantiation();
    public virtual Instantiation get_MethodInstantiation();
    protected virtual TypeSystemContext get_Context();
    public virtual TypeSystemEntity get_OwningEntity();
    public virtual ExportForm GetExportForm(NodeFactory factory);
    public TypeDesc get_OwningType();
    public virtual DictionaryLayoutNode GetDictionaryLayout(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.TypeGenericDictionaryNode/<GetConditionalStaticDependencies>d__19")]
public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.TypeGVMEntriesNode : DependencyNodeCore`1<NodeFactory> {
    private TypeDesc _associatedType;
    private DependencyList<NodeFactory> _staticDependencies;
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    public TypeGVMEntriesNode(TypeDesc associatedType);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory context);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory context);
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory context);
    public static bool TypeNeedsGVMTableEntries(TypeDesc type);
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.TypeGVMEntriesNode/<ScanForGenericVirtualMethodEntries>d__17")]
public IEnumerable`1<TypeGVMEntryInfo> ScanForGenericVirtualMethodEntries();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.TypeGVMEntriesNode/<ScanForInterfaceGenericVirtualMethodEntries>d__18")]
public IEnumerable`1<TypeGVMEntryInfo> ScanForInterfaceGenericVirtualMethodEntries();
}
public class ILCompiler.DependencyAnalysis.TypeHandleGenericLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public TypeDesc Type { get; }
    public TypeHandleGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public TypeDesc get_Type();
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.TypeManagerIndirectionNode : ObjectNode {
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.TypeMetadataMapNode : ObjectNode {
    private ObjectAndOffsetSymbolNode _endSymbol;
    private ExternalReferencesTableNode _externalReferences;
    public ISymbolNode EndSymbol { get; }
    public int Offset { get; }
    public bool IsShareable { get; }
    public ObjectNodeSection Section { get; }
    public bool StaticDependenciesAreComputed { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public TypeMetadataMapNode(ExternalReferencesTableNode externalReferences);
    public ISymbolNode get_EndSymbol();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public virtual bool get_IsShareable();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.TypeMetadataNode : DependencyNodeCore`1<NodeFactory> {
    private MetadataType _type;
    public MetadataType Type { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool StaticDependenciesAreComputed { get; }
    public TypeMetadataNode(MetadataType type);
    public MetadataType get_Type();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public static void GetMetadataDependencies(DependencyList& dependencies, NodeFactory nodeFactory, TypeDesc type, string reason);
    protected virtual string GetName(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.TypeNonGCStaticBaseGenericLookupResult : GenericLookupResult {
    private MetadataType _type;
    protected int ClassCode { get; }
    public TypeNonGCStaticBaseGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.TypeSizeLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public TypeSizeLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.TypeThreadStaticBaseIndexGenericLookupResult : GenericLookupResult {
    private MetadataType _type;
    protected int ClassCode { get; }
    public TypeThreadStaticBaseIndexGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.TypeThreadStaticIndexNode : ObjectNode {
    private MetadataType _type;
    public int Offset { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int ClassCode { get; }
    public TypeThreadStaticIndexNode(MetadataType type);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.UnboxingStubNode : AssemblyStubNode {
    internal static string WindowsSectionName;
    internal static string UnixSectionName;
    private TargetDetails _targetDetails;
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    public MethodDesc Method { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public UnboxingStubNode(MethodDesc target, TargetDetails targetDetails);
    private static UnboxingStubNode();
    protected virtual void EmitCode(NodeFactory factory, X64Emitter& encoder, bool relocsOnly);
    [CompilerGeneratedAttribute]
public sealed virtual MethodDesc get_Method();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public sealed virtual ExportForm GetExportForm(NodeFactory factory);
    private ISymbolNode GetUnderlyingMethodEntrypoint(NodeFactory factory);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public static string GetMangledName(NameMangler nameMangler, MethodDesc method);
    protected virtual string GetName(NodeFactory factory);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
    protected virtual void EmitCode(NodeFactory factory, X86Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARM64Emitter& encoder, bool relocsOnly);
    protected virtual void EmitCode(NodeFactory factory, ARMEmitter& encoder, bool relocsOnly);
}
public class ILCompiler.DependencyAnalysis.UnwrapNullableTypeHandleGenericLookupResult : GenericLookupResult {
    private TypeDesc _type;
    protected int ClassCode { get; }
    public TypeDesc Type { get; }
    public UnwrapNullableTypeHandleGenericLookupResult(TypeDesc type);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public TypeDesc get_Type();
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual GenericLookupResultReferenceType LookupResultReferenceType(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public class ILCompiler.DependencyAnalysis.UtcThreadStaticsNode : ObjectNode {
    private MetadataType _type;
    public int Offset { get; }
    public MetadataType Type { get; }
    public IDebugInfo DebugInfo { get; }
    public bool StaticDependenciesAreComputed { get; }
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public int ClassCode { get; }
    public UtcThreadStaticsNode(MetadataType type);
    protected virtual string GetName(NodeFactory factory);
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public sealed virtual int get_Offset();
    public MetadataType get_Type();
    public sealed virtual IDebugInfo get_DebugInfo();
    public static string GetMangledName(TypeDesc type, NameMangler nameMangler);
    public virtual ExportForm GetExportForm(NodeFactory factory);
    protected virtual DependencyList<NodeFactory> ComputeNonRelocationBasedDependencies(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public sealed virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
internal class ILCompiler.DependencyAnalysis.VirtualDispatchCellGenericLookupResult : GenericLookupResult {
    private MethodDesc _method;
    protected int ClassCode { get; }
    public VirtualDispatchCellGenericLookupResult(MethodDesc method);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext context);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
internal class ILCompiler.DependencyAnalysis.VirtualMethodUseNode : DependencyNodeCore`1<NodeFactory> {
    private MethodDesc _decl;
    public MethodDesc Method { get; }
    public bool HasConditionalStaticDependencies { get; }
    public bool HasDynamicDependencies { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool StaticDependenciesAreComputed { get; }
    public VirtualMethodUseNode(MethodDesc decl);
    public MethodDesc get_Method();
    protected virtual string GetName(NodeFactory factory);
    protected virtual void OnMarked(NodeFactory factory);
    public virtual bool get_HasConditionalStaticDependencies();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
}
internal class ILCompiler.DependencyAnalysis.VTableOffsetGenericLookupResult : GenericLookupResult {
    private MethodDesc _method;
    protected int ClassCode { get; }
    public VTableOffsetGenericLookupResult(MethodDesc method);
    protected virtual int get_ClassCode();
    public virtual ISymbolNode GetTarget(NodeFactory factory, GenericLookupResultContext dictionary);
    public virtual void EmitDictionaryEntry(ObjectDataBuilder& builder, NodeFactory factory, GenericLookupResultContext dictionary, GenericDictionaryNode dictionaryNode);
    public virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual string ToString();
    public virtual NativeLayoutVertexNode TemplateDictionaryNode(NodeFactory factory);
    public virtual IEnumerable`1<DependencyNodeCore`1<NodeFactory>> NonRelocDependenciesFromUsage(NodeFactory factory);
    public virtual void WriteDictionaryTocData(NodeFactory factory, IGenericLookupResultTocWriter writer);
    protected virtual int CompareToImpl(GenericLookupResult other, TypeSystemComparer comparer);
    protected virtual int GetHashCodeImpl();
    protected virtual bool EqualsImpl(GenericLookupResult obj);
}
public abstract class ILCompiler.DependencyAnalysis.VTableSliceNode : DependencyNodeCore`1<NodeFactory> {
    protected TypeDesc _type;
    public IReadOnlyList`1<MethodDesc> Slots { get; }
    public TypeDesc Type { get; }
    public bool HasFixedSlots { get; }
    public bool StaticDependenciesAreComputed { get; }
    public bool InterestingForDynamicDependencyAnalysis { get; }
    public bool HasDynamicDependencies { get; }
    public bool HasConditionalStaticDependencies { get; }
    public VTableSliceNode(TypeDesc type);
    public abstract virtual IReadOnlyList`1<MethodDesc> get_Slots();
    public TypeDesc get_Type();
    public abstract virtual bool get_HasFixedSlots();
    protected virtual string GetName(NodeFactory factory);
    public virtual bool get_StaticDependenciesAreComputed();
    public virtual IEnumerable`1<DependencyListEntry<NodeFactory>> GetStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> GetConditionalStaticDependencies(NodeFactory factory);
    public virtual IEnumerable`1<CombinedDependencyListEntry<NodeFactory>> SearchDynamicDependencies(List`1<DependencyNodeCore`1<NodeFactory>> markedNodes, int firstNode, NodeFactory factory);
    public virtual bool get_InterestingForDynamicDependencyAnalysis();
    public virtual bool get_HasDynamicDependencies();
    public virtual bool get_HasConditionalStaticDependencies();
    [IteratorStateMachineAttribute("ILCompiler.DependencyAnalysis.VTableSliceNode/<GetAllVirtualMethods>d__20")]
protected static IEnumerable`1<MethodDesc> GetAllVirtualMethods(TypeDesc type);
}
public static class ILCompiler.DependencyAnalysis.WellKnownLineNumber : object {
    public static int DebuggerStepThrough;
    public static int DebuggerStepIn;
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugILImagesSection : ObjectNode {
    private MergedAssemblyRecords _mergedAssemblies;
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public int ClassCode { get; }
    public WindowsDebugILImagesSection(MergedAssemblyRecords mergedAssemblies);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugManagedNativeDictionaryInfoSection : ObjectNode {
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugMergedAssembliesSection : ObjectNode {
    private MergedAssemblyRecords _mergedAssemblies;
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public int ClassCode { get; }
    public WindowsDebugMergedAssembliesSection(MergedAssemblyRecords mergedAssemblies);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugMethodInfoSection : ObjectNode {
    private MergedAssemblyRecords _mergedAssemblies;
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public int ClassCode { get; }
    public WindowsDebugMethodInfoSection(MergedAssemblyRecords mergedAssemblies);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private UInt32 AdjustIndex(UInt32 assemblyIndex, UInt32 corLibIndex);
    internal DebugInfoBlob GetDebugMethodInfoMap(NodeFactory factory);
    private DebugInfoBlob ConvertToDebugInfoBlob(List`1<SortedDictionary`2<UInt32, int>> assemblyMethods);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
    public virtual int get_ClassCode();
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugMethodSignatureMapSection : ObjectNode {
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    internal DebugInfoBlob GetDebugMethodRVAToTokenMap(ManagedBinaryEmitter pseudoAssembly, IEnumerable`1<IMethodBodyNode> emittedMethods, List`1& debugRelocations);
    private void Add_DEBUG_S_FUNC_MDTOKEN_MAP_Entry(DebugInfoBlob methodRVAToTokenMap, List`1<Relocation> debugRelocations, IMethodBodyNode method, UInt32 methodDataOrOffsetToMethodData, UInt32& entryCount);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
public class ILCompiler.DependencyAnalysis.WindowsDebugNeedTypeIndicesStoreNode : ObjectNode {
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
public class ILCompiler.DependencyAnalysis.WindowsDebugPseudoAssemblySection : ObjectNode {
    private ManagedBinaryEmitter _pseudoAssembly;
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public ManagedBinaryEmitter PseudoAssembly { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public WindowsDebugPseudoAssemblySection(TypeSystemContext typeSystemContext);
    public virtual ObjectNodeSection get_Section();
    public ManagedBinaryEmitter get_PseudoAssembly();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugTypeRecordsSection : ObjectNode {
    private DebugInfoWriter _dbgInfo;
    private DebugInfoWriter _dbgInfoWriter;
    private NodeFactory _nodeFactory;
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public WindowsDebugTypeRecordsSection(DebugInfoWriter dbgInfo, NodeFactory factory);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
    public void Neuter();
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetEnumTypeIndex(EnumTypeDescriptor enumTypeDescriptor, EnumRecordTypeDescriptor[] typeRecords);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetClassTypeIndex(ClassTypeDescriptor classTypeDescriptor);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetCompleteClassTypeIndex(ClassTypeDescriptor classTypeDescriptor, ClassFieldsTypeDescriptor classFieldsTypeDescriptior, DataFieldDescriptor[] fields, StaticDataFieldDescriptor[] statics);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetArrayTypeIndex(ClassTypeDescriptor classDescriptor, ArrayTypeDescriptor arrayTypeDescriptor);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetPointerTypeIndex(PointerTypeDescriptor pointerDescriptor);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetMemberFunctionTypeIndex(MemberFunctionTypeDescriptor memberDescriptor, UInt32[] argumentTypes);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetMemberFunctionId(MemberFunctionIdTypeDescriptor memberIdDescriptor);
    private sealed virtual override UInt32 Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetPrimitiveTypeIndex(TypeDesc type);
    private sealed virtual override string Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter.GetMangledName(TypeDesc type);
}
internal class ILCompiler.DependencyAnalysis.WindowsDebugTypeSignatureMapSection : ObjectNode {
    private UserDefinedTypeDescriptor _userDefinedTypeDescriptor;
    private ObjectNodeSection _section;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    protected internal int Phase { get; }
    public int ClassCode { get; }
    public WindowsDebugTypeSignatureMapSection(UserDefinedTypeDescriptor userDefinedTypeDescriptor);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    protected internal virtual int get_Phase();
    public virtual int get_ClassCode();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    private DebugInfoBlob GetDebugTypeIndexToTokenMap(ManagedBinaryEmitter pseudoAssembly, ICollection`1<KeyValuePair`2<TypeDesc, UInt32>> completeKnownTypes);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    protected virtual string GetName(NodeFactory context);
}
public class ILCompiler.DependencyAnalysis.WindowsUnboxingStubsRegionNode : ObjectNode {
    private bool _isEndSymbol;
    public ObjectNodeSection Section { get; }
    public bool IsShareable { get; }
    public bool StaticDependenciesAreComputed { get; }
    public int Offset { get; }
    public int ClassCode { get; }
    public WindowsUnboxingStubsRegionNode(bool isEndSymbol);
    public virtual ObjectNodeSection get_Section();
    public virtual bool get_IsShareable();
    public virtual bool get_StaticDependenciesAreComputed();
    public sealed virtual int get_Offset();
    public sealed virtual void AppendMangledName(NameMangler nameMangler, Utf8StringBuilder sb);
    protected virtual string GetName(NodeFactory factory);
    public virtual ObjectData GetData(NodeFactory factory, bool relocsOnly);
    public virtual int get_ClassCode();
    public virtual int CompareToImpl(ISortableNode other, CompilerComparer comparer);
}
public class ILCompiler.DependencyAnalysis.X64.AddrMode : ValueType {
    public Register BaseReg;
    public Nullable`1<Register> IndexReg;
    public int Offset;
    public byte Scale;
    public AddrModeSize Size;
    public AddrMode(Register baseRegister, Nullable`1<Register> indexRegister, int offset, byte scale, AddrModeSize size);
}
public enum ILCompiler.DependencyAnalysis.X64.AddrModeSize : Enum {
    public int value__;
    public static AddrModeSize Int8;
    public static AddrModeSize Int16;
    public static AddrModeSize Int32;
    public static AddrModeSize Int64;
    public static AddrModeSize Int128;
}
public enum ILCompiler.DependencyAnalysis.X64.Register : Enum {
    public int value__;
    public static Register RAX;
    public static Register RCX;
    public static Register RDX;
    public static Register RBX;
    public static Register RSP;
    public static Register RBP;
    public static Register RSI;
    public static Register RDI;
    public static Register R8;
    public static Register R9;
    public static Register R10;
    public static Register R11;
    public static Register R12;
    public static Register R13;
    public static Register R14;
    public static Register R15;
    public static Register None;
    public static Register RegDirect;
    public static Register NoIndex;
}
public class ILCompiler.DependencyAnalysis.X64.TargetRegisterMap : ValueType {
    public Register Arg0;
    public Register Arg1;
    public Register Arg2;
    public Register Arg3;
    public Register Result;
    public TargetRegisterMap(TargetOS os);
}
public class ILCompiler.DependencyAnalysis.X64.X64Emitter : ValueType {
    public ObjectDataBuilder Builder;
    public TargetRegisterMap TargetRegister;
    public X64Emitter(NodeFactory factory, bool relocsOnly);
    public void EmitMOV(Register regDst, AddrMode& memory);
    public void EmitMOV(Register regDst, Register regSrc);
    public void EmitMOV(Register regDst, int imm32);
    public void EmitLEAQ(Register reg, ISymbolNode symbol, int delta);
    public void EmitLEA(Register reg, AddrMode& addrMode);
    public void EmitCMP(AddrMode& addrMode, sbyte immediate);
    public void EmitADD(AddrMode& addrMode, sbyte immediate);
    public void EmitJMP(ISymbolNode symbol);
    public void EmitJE(ISymbolNode symbol);
    public void EmitINT3();
    public void EmitJmpToAddrMode(AddrMode& addrMode);
    public void EmitRET();
    public void EmitRETIfEqual();
    private bool InSignedByteRange(int i);
    private void EmitImmediate(int immediate, int size);
    private void EmitModRM(byte subOpcode, AddrMode& addrMode);
    private void EmitExtendedOpcode(int opcode);
    private void EmitRexPrefix(Register reg, AddrMode& addrMode);
    private void EmitIndirInstruction(int opcode, byte subOpcode, AddrMode& addrMode);
    private void EmitIndirInstruction(int opcode, Register dstReg, AddrMode& addrMode);
    private void EmitIndirInstructionSize(int opcode, Register dstReg, AddrMode& addrMode);
}
public class ILCompiler.DependencyAnalysis.X86.AddrMode : ValueType {
    public Register BaseReg;
    public Nullable`1<Register> IndexReg;
    public int Offset;
    public byte Scale;
    public AddrModeSize Size;
    public AddrMode(Register baseRegister, Nullable`1<Register> indexRegister, int offset, byte scale, AddrModeSize size);
}
public enum ILCompiler.DependencyAnalysis.X86.AddrModeSize : Enum {
    public int value__;
    public static AddrModeSize Int8;
    public static AddrModeSize Int16;
    public static AddrModeSize Int32;
}
public enum ILCompiler.DependencyAnalysis.X86.Register : Enum {
    public int value__;
    public static Register EAX;
    public static Register ECX;
    public static Register EDX;
    public static Register EBX;
    public static Register ESP;
    public static Register EBP;
    public static Register ESI;
    public static Register EDI;
    public static Register None;
    public static Register RegDirect;
    public static Register NoIndex;
}
public class ILCompiler.DependencyAnalysis.X86.TargetRegisterMap : ValueType {
    public Register Arg0;
    public Register Arg1;
    public Register Result;
    public TargetRegisterMap(TargetOS os);
}
public class ILCompiler.DependencyAnalysis.X86.X86Emitter : ValueType {
    public ObjectDataBuilder Builder;
    public TargetRegisterMap TargetRegister;
    public X86Emitter(NodeFactory factory, bool relocsOnly);
    public void EmitADD(AddrMode& addrMode, sbyte immediate);
    public void EmitJMP(ISymbolNode symbol);
    public void EmitINT3();
    private bool InSignedByteRange(int i);
    private void EmitImmediate(int immediate, int size);
    private void EmitModRM(byte subOpcode, AddrMode& addrMode);
    private void EmitExtendedOpcode(int opcode);
    private void EmitIndirInstruction(int opcode, byte subOpcode, AddrMode& addrMode);
}
public enum ILCompiler.DependencyTrackingLevel : Enum {
    public int value__;
    public static DependencyTrackingLevel None;
    public static DependencyTrackingLevel First;
    public static DependencyTrackingLevel All;
}
[ExtensionAttribute]
internal static class ILCompiler.DependencyTrackingLevelExtensions : object {
    [ExtensionAttribute]
public static DependencyAnalyzerBase`1<NodeFactory> CreateDependencyGraph(DependencyTrackingLevel trackingLevel, NodeFactory factory, IComparer`1<DependencyNodeCore`1<NodeFactory>> comparer);
}
public class ILCompiler.DevirtualizationManager : object {
    public virtual bool IsEffectivelySealed(TypeDesc type);
    public virtual bool IsEffectivelySealed(MethodDesc method);
    public MethodDesc ResolveVirtualMethod(MethodDesc declMethod, TypeDesc implType);
    protected virtual MethodDesc ResolveVirtualMethod(MethodDesc declMethod, DefType implType);
}
public abstract class ILCompiler.DictionaryLayoutProvider : object {
    public abstract virtual DictionaryLayoutNode GetLayout(TypeSystemEntity methodOrType);
}
public abstract class ILCompiler.DynamicInvokeThunkGenerationPolicy : object {
    public abstract virtual bool HasStaticInvokeThunk(MethodDesc targetMethod);
}
public class ILCompiler.EcmaMethodStackTraceEmissionPolicy : StackTraceEmissionPolicy {
    public virtual bool ShouldIncludeMethod(MethodDesc method);
}
public class ILCompiler.EmptyInteropStubManager : InteropStubManager {
    public EmptyInteropStubManager(CompilationModuleGroup compilationModuleGroup, CompilerTypeSystemContext typeSystemContext, InteropStateManager interopStateManager);
    public virtual void AddDependeciesDueToPInvoke(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public virtual void AddInterestingInteropConstructedTypeDependencies(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public virtual void AddMarshalAPIsGenericDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public virtual void AddToReadyToRunHeader(ReadyToRunHeaderNode header, NodeFactory nodeFactory, ExternalReferencesTableNode commonFixupsTableNode);
}
public class ILCompiler.EmptyMetadataManager : MetadataManager {
    public bool SupportsReflection { get; }
    public EmptyMetadataManager(CompilerTypeSystemContext typeSystemContext);
    public virtual bool get_SupportsReflection();
    public virtual void AddToReadyToRunHeader(ReadyToRunHeaderNode header, NodeFactory nodeFactory, ExternalReferencesTableNode commonFixupsTableNode);
    public virtual IEnumerable`1<ModuleDesc> GetCompilationModulesWithMetadata();
    protected virtual MetadataCategory GetMetadataCategory(FieldDesc field);
    protected virtual MetadataCategory GetMetadataCategory(MethodDesc method);
    protected virtual MetadataCategory GetMetadataCategory(TypeDesc type);
    protected virtual void ComputeMetadata(NodeFactory factory, Byte[]& metadataBlob, List`1& typeMappings, List`1& methodMappings, List`1& fieldMappings, List`1& stackTraceMapping);
    public virtual MethodDesc GetCanonicalReflectionInvokeStub(MethodDesc method);
    public virtual bool WillUseMetadataTokenToReferenceMethod(MethodDesc method);
    public virtual bool WillUseMetadataTokenToReferenceField(FieldDesc field);
}
public class ILCompiler.ExportedMethodsRootProvider : object {
    private EcmaModule _module;
    public IEnumerable`1<EcmaMethod> ExportedMethods { get; }
    public ExportedMethodsRootProvider(EcmaModule module);
    [IteratorStateMachineAttribute("ILCompiler.ExportedMethodsRootProvider/<get_ExportedMethods>d__3")]
public IEnumerable`1<EcmaMethod> get_ExportedMethods();
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public enum ILCompiler.ExportForm : Enum {
    public int value__;
    public static ExportForm None;
    public static ExportForm ByName;
    public static ExportForm ByOrdinal;
}
public class ILCompiler.ExportsFileWriter : object {
    private string _exportsFile;
    private List`1<EcmaMethod> _methods;
    private TypeSystemContext _context;
    public ExportsFileWriter(TypeSystemContext context, string exportsFile);
    public void AddExportedMethods(IEnumerable`1<EcmaMethod> methods);
    public void EmitExportedMethods();
    [CompilerGeneratedAttribute]
private bool <AddExportedMethods>b__4_0(EcmaMethod m);
}
public class ILCompiler.FrameworkStringResourceBlockingPolicy : ManifestResourceBlockingPolicy {
    public virtual bool IsManifestResourceBlocked(ModuleDesc module, string resourceName);
    private static bool IsFrameworkAssembly(EcmaModule module);
}
public abstract class ILCompiler.GeneratingMetadataManager : MetadataManager {
    protected string _metadataLogFile;
    protected StackTraceEmissionPolicy _stackTraceEmissionPolicy;
    private ModuleDesc _generatedAssembly;
    public GeneratingMetadataManager(CompilerTypeSystemContext typeSystemContext, MetadataBlockingPolicy blockingPolicy, ManifestResourceBlockingPolicy resourceBlockingPolicy, string logFile, StackTraceEmissionPolicy stackTracePolicy, DynamicInvokeThunkGenerationPolicy invokeThunkGenerationPolicy);
    public sealed virtual bool WillUseMetadataTokenToReferenceMethod(MethodDesc method);
    public sealed virtual bool WillUseMetadataTokenToReferenceField(FieldDesc field);
    protected void ComputeMetadata(TPolicy policy, NodeFactory factory, Byte[]& metadataBlob, List`1& typeMappings, List`1& methodMappings, List`1& fieldMappings, List`1& stackTraceMapping);
    protected abstract virtual IEnumerable`1<FieldDesc> GetFieldsWithRuntimeMapping();
    public sealed virtual MethodDesc GetCanonicalReflectionInvokeStub(MethodDesc method);
}
public enum ILCompiler.GenericContextSource : Enum {
    public int value__;
    public static GenericContextSource MethodParameter;
    public static GenericContextSource TypeParameter;
    public static GenericContextSource ThisObject;
}
[DefaultMemberAttribute("Item")]
public class ILCompiler.GenericDictionaryLookup : ValueType {
    private static short UseHelperOffset;
    private short _offset1;
    private short _offset2;
    public GenericContextSource ContextSource;
    public bool UseHelper { get; }
    public int NumberOfIndirections { get; }
    public int Item { get; }
    private GenericDictionaryLookup(GenericContextSource contextSource, int offset1, int offset2);
    public bool get_UseHelper();
    public int get_NumberOfIndirections();
    public int get_Item(int index);
    public static GenericDictionaryLookup CreateFixedLookup(GenericContextSource contextSource, int offset1, int offset2);
    public static GenericDictionaryLookup CreateHelperLookup(GenericContextSource contextSource);
}
public interface ILCompiler.ICompilation {
    public abstract virtual CompilationResults Compile(string outputFileName, ObjectDumper dumper);
}
public interface ILCompiler.ICompilationRootProvider {
    public abstract virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public interface ILCompiler.IILScanner {
    public abstract virtual ILScanResults Scan();
}
public class ILCompiler.ILAssemblyGeneratingMethodDebugInfoProvider : DebugInformationProvider {
    private DebugInformationProvider _wrappedProvider;
    private string _fileName;
    private TextWriter _tw;
    private Dictionary`2<MethodDesc, MethodDebugInformation> _generatedInfos;
    private int _currentLine;
    public ILAssemblyGeneratingMethodDebugInfoProvider(string fileName, DebugInformationProvider wrappedProvider);
    public virtual MethodDebugInformation GetDebugInfo(MethodIL methodIL);
    private MethodDebugInformation GetDebugInformation(MethodIL methodIL);
    public sealed virtual void Dispose();
}
internal class ILCompiler.ILScanner : Compilation {
    internal ILScanner(DependencyAnalyzerBase`1<NodeFactory> dependencyGraph, ILScanNodeFactory nodeFactory, IEnumerable`1<ICompilationRootProvider> roots, DebugInformationProvider debugInformationProvider, Logger logger);
    protected virtual void CompileInternal(string outputFile, ObjectDumper dumper);
    protected virtual void ComputeDependencyNodeDependencies(List`1<DependencyNodeCore`1<NodeFactory>> obj);
    private sealed virtual override ILScanResults ILCompiler.IILScanner.Scan();
}
public class ILCompiler.ILScannerBuilder : object {
    private CompilerTypeSystemContext _context;
    private CompilationModuleGroup _compilationGroup;
    private NameMangler _nameMangler;
    private Logger _logger;
    private DependencyTrackingLevel _dependencyTrackingLevel;
    private IEnumerable`1<ICompilationRootProvider> _compilationRoots;
    private MetadataManager _metadataManager;
    internal ILScannerBuilder(CompilerTypeSystemContext context, CompilationModuleGroup compilationGroup, NameMangler mangler);
    public ILScannerBuilder UseDependencyTracking(DependencyTrackingLevel trackingLevel);
    public ILScannerBuilder UseCompilationRoots(IEnumerable`1<ICompilationRootProvider> compilationRoots);
    public ILScannerBuilder UseMetadataManager(MetadataManager metadataManager);
    public IILScanner ToILScanner();
}
public class ILCompiler.ILScanResults : CompilationResults {
    internal ILScanResults(DependencyAnalyzerBase`1<NodeFactory> graph, NodeFactory factory);
    public VTableSliceProvider GetVTableLayoutInfo();
    public DictionaryLayoutProvider GetDictionaryLayoutInfo();
    public DevirtualizationManager GetDevirtualizationManager();
}
public class ILCompiler.ImportExportOrdinals : object {
    public bool isImport;
    public UInt32 tlsIndexOrdinal;
    public ReadOnlyDictionary`2<TypeDesc, UInt32> typeOrdinals;
    public ReadOnlyDictionary`2<TypeDesc, UInt32> nonGcStaticOrdinals;
    public ReadOnlyDictionary`2<TypeDesc, UInt32> gcStaticOrdinals;
    public ReadOnlyDictionary`2<TypeDesc, UInt32> tlsStaticOrdinals;
    public ReadOnlyDictionary`2<MethodDesc, UInt32> methodOrdinals;
    public ReadOnlyDictionary`2<MethodDesc, UInt32> unboxingStubMethodOrdinals;
    public ReadOnlyDictionary`2<MethodDesc, UInt32> methodDictionaryOrdinals;
}
[ExtensionAttribute]
public static class ILCompiler.InstructionEncoderExtensions : object {
    [ExtensionAttribute]
public static void EmitLdToken(InstructionEncoder code, TypeSystemEntity typeSystemEntity, ManagedBinaryEmitter emitter);
    [ExtensionAttribute]
public static void EmitI4Constant(InstructionEncoder code, int value);
}
public class ILCompiler.InternalCompilerErrorException : Exception {
    public InternalCompilerErrorException(string message);
    public InternalCompilerErrorException(string message, Exception innerException);
}
public abstract class ILCompiler.InteropStubManager : object {
    private CompilationModuleGroup _compilationModuleGroup;
    private CompilerTypeSystemContext _typeSystemContext;
    protected ModuleDesc _interopModule;
    private static string _interopModuleName;
    [CompilerGeneratedAttribute]
private InteropStateManager <InteropStateManager>k__BackingField;
    public InteropStateManager InteropStateManager { get; }
    public InteropStubManager(CompilationModuleGroup compilationModuleGroup, CompilerTypeSystemContext typeSystemContext, InteropStateManager interopStateManager);
    [CompilerGeneratedAttribute]
public InteropStateManager get_InteropStateManager();
    public abstract virtual void AddDependeciesDueToPInvoke(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public abstract virtual void AddInterestingInteropConstructedTypeDependencies(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public abstract virtual void AddMarshalAPIsGenericDependencies(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public abstract virtual void AddToReadyToRunHeader(ReadyToRunHeaderNode header, NodeFactory nodeFactory, ExternalReferencesTableNode commonFixupsTableNode);
}
public interface ILCompiler.IRootingServiceProvider {
    public abstract virtual void AddCompilationRoot(MethodDesc method, string reason, string exportName);
    public abstract virtual void AddCompilationRoot(TypeDesc type, string reason);
    public abstract virtual void RootThreadStaticBaseForType(TypeDesc type, string reason);
    public abstract virtual void RootGCStaticBaseForType(TypeDesc type, string reason);
    public abstract virtual void RootNonGCStaticBaseForType(TypeDesc type, string reason);
    public abstract virtual void RootVirtualMethodForReflection(MethodDesc method, string reason);
    public abstract virtual void RootModuleMetadata(ModuleDesc module, string reason);
    public abstract virtual void RootReadOnlyDataBlob(Byte[] data, int alignment, string reason, string exportName);
}
internal class ILCompiler.JitHelper : object {
    public static void GetEntryPoint(TypeSystemContext context, ReadyToRunHelper id, String& mangledName, MethodDesc& methodDesc);
    public static string GetNewObjectHelperForType(TypeDesc type);
    public static string GetNewArrayHelperForType(TypeDesc type);
    public static string GetCastingHelperNameForType(TypeDesc type, bool throwing);
}
public class ILCompiler.LazyDictionaryLayoutProvider : DictionaryLayoutProvider {
    public virtual DictionaryLayoutNode GetLayout(TypeSystemEntity methodOrType);
}
public class ILCompiler.LazyGenericsDisabledPolicy : LazyGenericsPolicy {
    public sealed virtual bool UsesLazyGenerics(MethodDesc method);
    public sealed virtual bool UsesLazyGenerics(TypeDesc type);
    public sealed virtual bool UsesLazyGenerics(MetadataType type);
}
public abstract class ILCompiler.LazyGenericsPolicy : object {
    public abstract virtual bool UsesLazyGenerics(MethodDesc method);
    public abstract virtual bool UsesLazyGenerics(TypeDesc type);
    public abstract virtual bool UsesLazyGenerics(MetadataType type);
}
public class ILCompiler.LazyVTableSliceProvider : VTableSliceProvider {
    internal virtual VTableSliceNode GetSlice(TypeDesc type);
}
public class ILCompiler.LibraryInitializers : object {
    private static string LibraryInitializerContainerNamespaceName;
    private static string LibraryInitializerContainerTypeName;
    private static string LibraryInitializerMethodName;
    private List`1<MethodDesc> _libraryInitializerMethods;
    private TypeSystemContext _context;
    private IReadOnlyCollection`1<ModuleDesc> _librariesWithInitializers;
    public IReadOnlyCollection`1<MethodDesc> LibraryInitializerMethods { get; }
    public LibraryInitializers(TypeSystemContext context, IEnumerable`1<ModuleDesc> librariesWithInitalizers);
    public IReadOnlyCollection`1<MethodDesc> get_LibraryInitializerMethods();
    private void InitLibraryInitializers();
}
public class ILCompiler.LibraryRootProvider : object {
    private EcmaModule _module;
    public LibraryRootProvider(EcmaModule module);
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
    private void RootMethods(TypeDesc type, string reason, IRootingServiceProvider rootProvider);
    public static void CheckCanGenerateMethod(MethodDesc method);
    private static void CheckTypeCanBeUsedInSignature(TypeDesc type);
}
public class ILCompiler.Logger : object {
    public static Logger Null;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVerbose>k__BackingField;
    public TextWriter Writer { get; }
    public bool IsVerbose { get; }
    public Logger(TextWriter writer, bool isVerbose);
    private static Logger();
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    [CompilerGeneratedAttribute]
public bool get_IsVerbose();
}
public class ILCompiler.MainMethodRootProvider : object {
    public static string ManagedEntryPointMethodName;
    private EcmaModule _module;
    private IReadOnlyCollection`1<MethodDesc> _libraryInitializers;
    public MainMethodRootProvider(EcmaModule module, IReadOnlyCollection`1<MethodDesc> libraryInitializers);
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public class ILCompiler.ManagedBinaryEmitter : object {
    private TypeSystemContext _typeSystemContext;
    private MetadataBuilder _metadataBuilder;
    private MethodBodyStreamEncoder _methodBodyStream;
    private List`1<EmittedTypeDefinition> _emittedTypes;
    private Dictionary`2<IAssemblyDesc, AssemblyReferenceHandle> _assemblyRefHandles;
    private Dictionary`2<TypeDesc, EntityHandle> _typeRefOrSpecHandles;
    private Dictionary`2<TypeSystemEntity, EntityHandle> _memberRefOrSpecHandles;
    private Dictionary`2<MethodSignature, BlobHandle> _methodSignatureHandles;
    private Dictionary`2<FieldDesc, BlobHandle> _fieldSignatureHandles;
    private EcmaSignatureEncoder`1<EntityProviderForEcmaSignature> _signatureEmitter;
    protected MetadataBuilder Builder { get; }
    public ManagedBinaryEmitter(TypeSystemContext typeSystemContext, string assemblyName);
    protected MetadataBuilder get_Builder();
    public EmittedTypeDefinition EmitTypeDefinition(string typeName, bool isValueType);
    public EntityHandle EmitMetadataHandleForTypeSystemEntity(TypeSystemEntity entity);
    public BlobHandle EmitSignatureBlobForMethodSignature(MethodSignature signature);
    public void EncodeSignatureForType(TypeDesc type, BlobBuilder blobBuilder);
    public void EmitOutputFile(string outputPath);
    public void EmitToStream(Stream stream);
    private BlobHandle MakeSignatureHandle(MethodSignature signature);
    private BlobHandle MakeSignatureHandle(TypeSystemEntity methodOrField);
    private AssemblyReferenceHandle MakeAssemblyReferenceHandle(IAssemblyDesc assemblyRef);
    private EntityHandle MakeTypeRefHandle(TypeDesc type);
    private EntityHandle MakeTypeRefOrSpecHandle(TypeDesc type);
    private EntityHandle MakeMemberReferenceHandle(TypeSystemEntity methodOrField);
}
public abstract class ILCompiler.ManifestResourceBlockingPolicy : object {
    public abstract virtual bool IsManifestResourceBlocked(ModuleDesc module, string resourceName);
}
internal static class ILCompiler.MemoryHelper : object {
    public static void FillMemory(Byte* dest, byte fill, int count);
}
public class ILCompiler.MergedAssemblyRecord : object {
    [CompilerGeneratedAttribute]
private EcmaAssembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <AssemblyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPDB>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <VersionInfo>k__BackingField;
    public EcmaAssembly Assembly { get; }
    public string Name { get; }
    public UInt32 AssemblyIndex { get; }
    public UInt32 Timestamp { get; }
    public bool HasPDB { get; }
    public Byte[] PublicKey { get; }
    public Byte[] VersionInfo { get; }
    public int VersionInfoLength { get; }
    public MergedAssemblyRecord(EcmaAssembly assembly, string name, UInt32 assemblyIndex, UInt32 timestamp, bool hasPDB, Byte[] publicKey, Byte[] versionInfo);
    [CompilerGeneratedAttribute]
public EcmaAssembly get_Assembly();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public UInt32 get_AssemblyIndex();
    [CompilerGeneratedAttribute]
public UInt32 get_Timestamp();
    [CompilerGeneratedAttribute]
public bool get_HasPDB();
    [CompilerGeneratedAttribute]
public Byte[] get_PublicKey();
    [CompilerGeneratedAttribute]
public Byte[] get_VersionInfo();
    public int get_VersionInfoLength();
    internal void Encode(DebugInfoBlob blob);
}
public class ILCompiler.MergedAssemblyRecords : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<MergedAssemblyRecord> <MergedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CorLibIndex>k__BackingField;
    public IReadOnlyCollection`1<MergedAssemblyRecord> MergedAssemblies { get; }
    public UInt32 CorLibIndex { get; }
    public MergedAssemblyRecords(IReadOnlyCollection`1<MergedAssemblyRecord> mergedAssemblies, UInt32 corLibIndex);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<MergedAssemblyRecord> get_MergedAssemblies();
    [CompilerGeneratedAttribute]
public UInt32 get_CorLibIndex();
}
public abstract class ILCompiler.MetadataBlockingPolicy : object {
    public abstract virtual bool IsBlocked(MetadataType type);
    public abstract virtual bool IsBlocked(MethodDesc method);
    public abstract virtual bool IsBlocked(FieldDesc field);
}
[FlagsAttribute]
public enum ILCompiler.MetadataCategory : Enum {
    public int value__;
    public static MetadataCategory None;
    public static MetadataCategory Description;
    public static MetadataCategory RuntimeMapping;
}
public abstract class ILCompiler.MetadataManager : object {
    internal static int MetadataOffsetMask;
    private Byte[] _metadataBlob;
    private List`1<MetadataMapping`1<MetadataType>> _typeMappings;
    private List`1<MetadataMapping`1<FieldDesc>> _fieldMappings;
    private List`1<MetadataMapping`1<MethodDesc>> _methodMappings;
    private List`1<MetadataMapping`1<MethodDesc>> _stackTraceMappings;
    protected CompilerTypeSystemContext _typeSystemContext;
    protected MetadataBlockingPolicy _blockingPolicy;
    protected ManifestResourceBlockingPolicy _resourceBlockingPolicy;
    protected DynamicInvokeThunkGenerationPolicy _dynamicInvokeThunkGenerationPolicy;
    private List`1<NonGCStaticsNode> _cctorContextsGenerated;
    private HashSet`1<TypeDesc> _typesWithEETypesGenerated;
    private HashSet`1<TypeDesc> _typesWithConstructedEETypesGenerated;
    private HashSet`1<MethodDesc> _methodsGenerated;
    private HashSet`1<GenericDictionaryNode> _genericDictionariesGenerated;
    private HashSet`1<IMethodBodyNode> _methodBodiesGenerated;
    private List`1<TypeGVMEntriesNode> _typeGVMEntries;
    [CompilerGeneratedAttribute]
private NativeLayoutInfoNode <NativeLayoutInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicInvokeTemplateDataNode <DynamicInvokeTemplateData>k__BackingField;
    internal NativeLayoutInfoNode NativeLayoutInfo { get; private set; }
    internal DynamicInvokeTemplateDataNode DynamicInvokeTemplateData { get; private set; }
    public bool SupportsReflection { get; }
    public MetadataManager(CompilerTypeSystemContext typeSystemContext, MetadataBlockingPolicy blockingPolicy, ManifestResourceBlockingPolicy resourceBlockingPolicy, DynamicInvokeThunkGenerationPolicy dynamicInvokeThunkGenerationPolicy);
    [CompilerGeneratedAttribute]
internal NativeLayoutInfoNode get_NativeLayoutInfo();
    [CompilerGeneratedAttribute]
private void set_NativeLayoutInfo(NativeLayoutInfoNode value);
    [CompilerGeneratedAttribute]
internal DynamicInvokeTemplateDataNode get_DynamicInvokeTemplateData();
    [CompilerGeneratedAttribute]
private void set_DynamicInvokeTemplateData(DynamicInvokeTemplateDataNode value);
    public virtual bool get_SupportsReflection();
    public void AttachToDependencyGraph(DependencyAnalyzerBase`1<NodeFactory> graph);
    internal static ReadyToRunSectionType BlobIdToReadyToRunSection(ReflectionMapBlob blobId);
    public virtual void AddToReadyToRunHeader(ReadyToRunHeaderNode header, NodeFactory nodeFactory, ExternalReferencesTableNode commonFixupsTableNode);
    protected virtual void Graph_NewMarkedNode(DependencyNodeCore`1<NodeFactory> obj);
    public virtual bool IsReflectionInvokable(MethodDesc method);
    protected bool IsMethodSupportedInReflectionInvoke(MethodDesc method);
    public bool HasReflectionInvokeStub(MethodDesc method);
    public bool ShouldMethodBeInInvokeMap(MethodDesc method);
    public void GetDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public void GetDependenciesDueToVirtualMethodReflectability(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    protected virtual void GetMetadataDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public void GetDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    protected virtual void GetMetadataDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    protected virtual void GetRuntimeMappingDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public virtual void GetDependenciesDueToLdToken(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    public virtual void GetDependenciesDueToLdToken(DependencyList& dependencies, NodeFactory factory, FieldDesc field);
    public bool HasReflectionInvokeStubForInvokableMethod(MethodDesc method);
    public abstract virtual bool WillUseMetadataTokenToReferenceMethod(MethodDesc method);
    public abstract virtual bool WillUseMetadataTokenToReferenceField(FieldDesc field);
    public abstract virtual MethodDesc GetCanonicalReflectionInvokeStub(MethodDesc method);
    protected MethodDesc InstantiateCanonicalDynamicInvokeMethodForMethod(MethodDesc thunk, MethodDesc method);
    protected void EnsureMetadataGenerated(NodeFactory factory);
    private sealed virtual override void ILCompiler.ICompilationRootProvider.AddCompilationRoots(IRootingServiceProvider rootProvider);
    protected abstract virtual void ComputeMetadata(NodeFactory factory, Byte[]& metadataBlob, List`1& typeMappings, List`1& methodMappings, List`1& fieldMappings, List`1& stackTraceMapping);
    protected MetadataRecord CreateStackTraceRecord(MetadataTransform transform, MethodDesc method);
    public abstract virtual IEnumerable`1<ModuleDesc> GetCompilationModulesWithMetadata();
    public Byte[] GetMetadataBlob(NodeFactory factory);
    public IEnumerable`1<MetadataMapping`1<MetadataType>> GetTypeDefinitionMapping(NodeFactory factory);
    public IEnumerable`1<MetadataMapping`1<MethodDesc>> GetMethodMapping(NodeFactory factory);
    public IEnumerable`1<MetadataMapping`1<FieldDesc>> GetFieldMapping(NodeFactory factory);
    public IEnumerable`1<MetadataMapping`1<MethodDesc>> GetStackTraceMapping(NodeFactory factory);
    internal IEnumerable`1<NonGCStaticsNode> GetCctorContextMapping();
    internal IEnumerable`1<TypeGVMEntriesNode> GetTypeGVMEntries();
    internal IReadOnlyCollection`1<GenericDictionaryNode> GetCompiledGenericDictionaries();
    internal IEnumerable`1<MethodDesc> GetCompiledMethods();
    internal IEnumerable`1<IMethodBodyNode> GetCompiledMethodBodies();
    internal bool TypeGeneratesEEType(TypeDesc type);
    internal IEnumerable`1<TypeDesc> GetTypesWithEETypes();
    internal IEnumerable`1<TypeDesc> GetTypesWithConstructedEETypes();
    public bool IsReflectionBlocked(TypeDesc type);
    protected bool IsReflectionBlocked(Instantiation instantiation);
    public bool IsReflectionBlocked(FieldDesc field);
    public bool IsReflectionBlocked(MethodDesc method);
    public bool IsManifestResourceBlocked(ModuleDesc module, string resourceName);
    public bool CanGenerateMetadata(MetadataType type);
    public bool CanGenerateMetadata(MethodDesc method);
    public bool CanGenerateMetadata(FieldDesc field);
    protected abstract virtual MetadataCategory GetMetadataCategory(MethodDesc method);
    protected abstract virtual MetadataCategory GetMetadataCategory(TypeDesc type);
    protected abstract virtual MetadataCategory GetMetadataCategory(FieldDesc field);
}
public class ILCompiler.MetadataMapping`1 : ValueType {
    public TEntity Entity;
    public int MetadataHandle;
    public MetadataMapping`1(TEntity entity, int metadataHandle);
}
[ExtensionAttribute]
public static class ILCompiler.MethodExtensions : object {
    [ExtensionAttribute]
public static string GetRuntimeImportName(EcmaMethod This);
    [ExtensionAttribute]
public static string GetRuntimeImportDllName(EcmaMethod This);
    [ExtensionAttribute]
public static string GetRuntimeExportName(EcmaMethod This);
    [ExtensionAttribute]
public static string GetNativeCallableExportName(EcmaMethod This);
    [ExtensionAttribute]
public static bool IsRawPInvoke(MethodDesc method);
    [ExtensionAttribute]
public static int GetGenericDepth(MethodDesc method);
    [ExtensionAttribute]
public static bool IsGenericDepthGreaterThan(MethodDesc method, int depth);
    [ExtensionAttribute]
public static bool CanMethodBeInSealedVTable(MethodDesc method);
}
public abstract class ILCompiler.MultiFileCompilationModuleGroup : CompilationModuleGroup {
    private HashSet`1<ModuleDesc> _compilationModuleSet;
    public bool IsSingleFileCompilation { get; }
    public bool CanHaveReferenceThroughImportTable { get; }
    public MultiFileCompilationModuleGroup(TypeSystemContext context, IEnumerable`1<ModuleDesc> compilationModuleSet);
    public sealed virtual bool ContainsType(TypeDesc type);
    public sealed virtual bool ContainsTypeDictionary(TypeDesc type);
    public sealed virtual bool ContainsMethodBody(MethodDesc method, bool unboxingStub);
    public sealed virtual bool ContainsMethodDictionary(MethodDesc method);
    public sealed virtual bool ImportsMethod(MethodDesc method, bool unboxingStub);
    public sealed virtual ExportForm GetExportTypeForm(TypeDesc type);
    public sealed virtual ExportForm GetExportTypeFormDictionary(TypeDesc type);
    public sealed virtual ExportForm GetExportMethodForm(MethodDesc method, bool unboxingStub);
    public virtual ExportForm GetExportMethodDictionaryForm(MethodDesc method);
    private bool IsModuleInCompilationGroup(EcmaModule module);
    public sealed virtual bool get_IsSingleFileCompilation();
    public sealed virtual bool ShouldReferenceThroughImportTable(TypeDesc type);
    public virtual bool get_CanHaveReferenceThroughImportTable();
}
public class ILCompiler.MultiFileSharedCompilationModuleGroup : MultiFileCompilationModuleGroup {
    public MultiFileSharedCompilationModuleGroup(TypeSystemContext context, IEnumerable`1<ModuleDesc> compilationModuleSet);
    public virtual bool ShouldProduceFullVTable(TypeDesc type);
    public virtual bool ShouldPromoteToFullType(TypeDesc type);
    public virtual bool PresenceOfEETypeImpliesAllMethodsOnType(TypeDesc type);
}
public abstract class ILCompiler.NameMangler : object {
    [CompilerGeneratedAttribute]
private NodeMangler <NodeMangler>k__BackingField;
    public NodeMangler NodeMangler { get; private set; }
    public string CompilationUnitPrefix { get; public set; }
    public NameMangler(NodeMangler nodeMangler);
    [CompilerGeneratedAttribute]
public NodeMangler get_NodeMangler();
    [CompilerGeneratedAttribute]
private void set_NodeMangler(NodeMangler value);
    public abstract virtual string get_CompilationUnitPrefix();
    public abstract virtual void set_CompilationUnitPrefix(string value);
    public abstract virtual string SanitizeName(string s, bool typeName);
    public abstract virtual string GetMangledTypeName(TypeDesc type);
    public abstract virtual Utf8String GetMangledMethodName(MethodDesc method);
    public abstract virtual Utf8String GetMangledFieldName(FieldDesc field);
    public abstract virtual string GetMangledStringName(string literal);
}
public class ILCompiler.NativeLibraryInitializerRootProvider : object {
    public static string ManagedEntryPointMethodName;
    private ModuleDesc _module;
    private IReadOnlyCollection`1<MethodDesc> _libraryInitializers;
    public NativeLibraryInitializerRootProvider(ModuleDesc module, IReadOnlyCollection`1<MethodDesc> libraryInitializers);
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public abstract class ILCompiler.NodeMangler : object {
    public NameMangler NameMangler;
    protected static string GenericDictionaryNamePrefix;
    public abstract virtual string MangledBoxedTypeName(TypeDesc type);
    public abstract virtual string EEType(TypeDesc type);
    public abstract virtual string GCStatics(TypeDesc type);
    public abstract virtual string NonGCStatics(TypeDesc type);
    public abstract virtual string ThreadStatics(TypeDesc type);
    public abstract virtual string TypeGenericDictionary(TypeDesc type);
    public abstract virtual string MethodGenericDictionary(MethodDesc method);
}
public class ILCompiler.NoDynamicInvokeThunkGenerationPolicy : DynamicInvokeThunkGenerationPolicy {
    public virtual bool HasStaticInvokeThunk(MethodDesc targetMethod);
}
public class ILCompiler.NoManifestResourceBlockingPolicy : ManifestResourceBlockingPolicy {
    public virtual bool IsManifestResourceBlocked(ModuleDesc module, string resourceName);
}
public class ILCompiler.NoMetadataBlockingPolicy : MetadataBlockingPolicy {
    private MetadataType _arrayOfTType;
    public virtual bool IsBlocked(MetadataType type);
    public virtual bool IsBlocked(FieldDesc field);
    private MetadataType InitializeArrayOfTType(TypeSystemEntity contextEntity);
    private MetadataType GetArrayOfTType(TypeSystemEntity contextEntity);
    public virtual bool IsBlocked(MethodDesc method);
}
public class ILCompiler.NoStackTraceEmissionPolicy : StackTraceEmissionPolicy {
    public virtual bool ShouldIncludeMethod(MethodDesc method);
}
public class ILCompiler.NullDebugInformationProvider : DebugInformationProvider {
    public virtual MethodDebugInformation GetDebugInfo(MethodIL methodIL);
}
public class ILCompiler.ObjectDumper : object {
    private string _fileName;
    private SHA256 _sha256;
    private XmlWriter _writer;
    public ObjectDumper(string fileName);
    internal void Begin();
    private static string GetObjectNodeName(ObjectNode node);
    private sealed virtual override void ILCompiler.DependencyAnalysis.IObjectDumper.DumpObjectNode(NameMangler mangler, ObjectNode node, ObjectData objectData);
    private string HashData(Byte[] data);
    internal void End();
}
public enum ILCompiler.OptimizationMode : Enum {
    public int value__;
    public static OptimizationMode None;
    public static OptimizationMode PreferSize;
    public static OptimizationMode Blended;
    public static OptimizationMode PreferSpeed;
}
internal class ILCompiler.PrecomputedMetadataManager : MetadataManager {
    private static string MetadataMappingTypeName;
    private ModuleDesc _metadataDescribingModule;
    private HashSet`1<ModuleDesc> _compilationModules;
    private HashSet`1<ModuleDesc> _metadataOnlyAssemblies;
    private Lazy`1<MetadataLoadedInfo> _loadedMetadata;
    private Lazy`1<Dictionary`2<MethodDesc, MethodDesc>> _dynamicInvokeStubs;
    private Byte[] _metadataBlob;
    private StackTraceEmissionPolicy _stackTraceEmissionPolicy;
    private Byte[] _stackTraceBlob;
    private CompilationModuleGroup _compilationModuleGroup;
    public PrecomputedMetadataManager(CompilationModuleGroup group, CompilerTypeSystemContext typeSystemContext, ModuleDesc metadataDescribingModule, IEnumerable`1<ModuleDesc> compilationModules, IEnumerable`1<ModuleDesc> inputMetadataOnlyAssemblies, Byte[] metadataBlob, StackTraceEmissionPolicy stackTraceEmissionPolicy, ManifestResourceBlockingPolicy resourceBlockingPolicy, bool disableInvokeThunks);
    public virtual void AddToReadyToRunHeader(ReadyToRunHeaderNode header, NodeFactory nodeFactory, ExternalReferencesTableNode commonFixupsTableNode);
    private void ReadMetadataMethod(MethodIL methodOfMappings, Dictionary`2<MetadataType, int> typeMappings, Dictionary`2<MethodDesc, int> methodMappings, Dictionary`2<FieldDesc, int> fieldMappings, HashSet`1<ModuleDesc> metadataModules);
    [IteratorStateMachineAttribute("ILCompiler.PrecomputedMetadataManager/<ReadRequiredGenericsEntities>d__14")]
private IEnumerable`1<TypeSystemEntity> ReadRequiredGenericsEntities(MethodIL method);
    private Instantiation GetUniversalCanonicalInstantiation(int numArgs);
    private void ReadRequiredTemplates(MethodIL methodIL, HashSet`1<TypeDesc> typeTemplates, HashSet`1<MethodDesc> methodTemplates, HashSet`1<FieldDesc> fieldTemplates);
    public static bool ModuleHasMetadataMappings(ModuleDesc metadataDescribingModule);
    private MetadataLoadedInfo LoadMetadata();
    public virtual IEnumerable`1<ModuleDesc> GetCompilationModulesWithMetadata();
    public virtual bool WillUseMetadataTokenToReferenceMethod(MethodDesc method);
    public virtual bool WillUseMetadataTokenToReferenceField(FieldDesc field);
    protected virtual MetadataCategory GetMetadataCategory(FieldDesc field);
    protected virtual MetadataCategory GetMetadataCategory(MethodDesc method);
    protected virtual MetadataCategory GetMetadataCategory(TypeDesc type);
    protected virtual void GetRuntimeMappingDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    private bool IsMethodSupportedInPrecomputedReflection(MethodDesc method);
    private sealed virtual override void ILCompiler.ICompilationRootProvider.AddCompilationRoots(IRootingServiceProvider rootProvider);
    protected virtual void ComputeMetadata(NodeFactory factory, Byte[]& metadataBlob, List`1& typeMappings, List`1& methodMappings, List`1& fieldMappings, List`1& stackTraceMapping);
    private void AddFieldMapping(FieldDesc field, HashSet`1<FieldDesc> canonicalFieldsAddedToMap, List`1<MetadataMapping`1<FieldDesc>> fieldMappings);
    private void AddMethodMapping(NodeFactory factory, MethodDesc method, HashSet`1<MethodDesc> canonicalMethodsAddedToMap, Dictionary`2<MethodDesc, MethodDesc> canonicalToSpecificMethods, List`1<MetadataMapping`1<MethodDesc>> methodMappings);
    private bool MethodCanBeInvokedViaReflection(NodeFactory factory, MethodDesc method);
    private MethodDesc GetInvokeMapMethodForMethod(Dictionary`2<MethodDesc, MethodDesc> canonicalToSpecificMethods, MethodDesc method);
    private Dictionary`2<MethodDesc, MethodDesc> LoadDynamicInvokeStubs();
    public virtual MethodDesc GetCanonicalReflectionInvokeStub(MethodDesc method);
    private List`1<MetadataMapping`1<MethodDesc>> GenerateStackTraceMetadata(NodeFactory factory);
    public Byte[] GetStackTraceBlob(NodeFactory factory);
}
public class ILCompiler.PreInitFieldFixupInfo : PreInitFixupInfo {
    [CompilerGeneratedAttribute]
private FieldDesc <FieldFixup>k__BackingField;
    public FieldDesc FieldFixup { get; }
    public PreInitFieldFixupInfo(int offset, FieldDesc field);
    [CompilerGeneratedAttribute]
public FieldDesc get_FieldFixup();
    public virtual void WriteData(ObjectDataBuilder& builder, NodeFactory factory);
}
public class ILCompiler.PreInitFieldInfo : object {
    [CompilerGeneratedAttribute]
private FieldDesc <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDesc <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    private List`1<PreInitFixupInfo> FixupInfos;
    public FieldDesc Field { get; }
    public TypeDesc Type { get; }
    public Byte[] Data { get; }
    public int Offset { get; }
    public int Length { get; }
    public PreInitFieldInfo(FieldDesc field, TypeDesc type, Byte[] data, int offset, int length, List`1<PreInitFixupInfo> fixups);
    [CompilerGeneratedAttribute]
public FieldDesc get_Field();
    [CompilerGeneratedAttribute]
public TypeDesc get_Type();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_Length();
    public void WriteData(ObjectDataBuilder& builder, NodeFactory factory, bool relocsOnly);
    public static List`1<PreInitFieldInfo> GetPreInitFieldInfos(TypeDesc type, bool hasGCStaticBase);
    private static FieldDesc GetPreInitDataField(FieldDesc thisField);
    private static PreInitFieldInfo ConstructPreInitFieldInfo(FieldDesc field, FieldDesc dataField);
    public static int FieldDescCompare(PreInitFieldInfo fieldInfo1, PreInitFieldInfo fieldInfo2);
    public int CompareTo(PreInitFieldInfo other, TypeSystemComparer comparer);
}
public abstract class ILCompiler.PreInitFixupInfo : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Offset { get; }
    public PreInitFixupInfo(int offset);
    [CompilerGeneratedAttribute]
public int get_Offset();
    private sealed virtual override int System.IComparable<ILCompiler.PreInitFixupInfo>.CompareTo(PreInitFixupInfo other);
    public abstract virtual void WriteData(ObjectDataBuilder& builder, NodeFactory factory);
}
public class ILCompiler.PreInitMethodFixupInfo : PreInitFixupInfo {
    [CompilerGeneratedAttribute]
private MethodDesc <MethodFixup>k__BackingField;
    public MethodDesc MethodFixup { get; }
    public PreInitMethodFixupInfo(int offset, MethodDesc method);
    [CompilerGeneratedAttribute]
public MethodDesc get_MethodFixup();
    public virtual void WriteData(ObjectDataBuilder& builder, NodeFactory factory);
}
public class ILCompiler.PreInitTypeFixupInfo : PreInitFixupInfo {
    [CompilerGeneratedAttribute]
private TypeDesc <TypeFixup>k__BackingField;
    public TypeDesc TypeFixup { get; }
    public PreInitTypeFixupInfo(int offset, TypeDesc type);
    [CompilerGeneratedAttribute]
public TypeDesc get_TypeFixup();
    public virtual void WriteData(ObjectDataBuilder& builder, NodeFactory factory);
}
public enum ILCompiler.ReadyToRunHelper : Enum {
    public int value__;
    public static ReadyToRunHelper Throw;
    public static ReadyToRunHelper Rethrow;
    public static ReadyToRunHelper Overflow;
    public static ReadyToRunHelper RngChkFail;
    public static ReadyToRunHelper FailFast;
    public static ReadyToRunHelper ThrowNullRef;
    public static ReadyToRunHelper ThrowDivZero;
    public static ReadyToRunHelper ThrowArgumentOutOfRange;
    public static ReadyToRunHelper ThrowArgument;
    public static ReadyToRunHelper ThrowPlatformNotSupported;
    public static ReadyToRunHelper DebugBreak;
    public static ReadyToRunHelper WriteBarrier;
    public static ReadyToRunHelper CheckedWriteBarrier;
    public static ReadyToRunHelper ByRefWriteBarrier;
    public static ReadyToRunHelper Stelem_Ref;
    public static ReadyToRunHelper Ldelema_Ref;
    public static ReadyToRunHelper MemSet;
    public static ReadyToRunHelper MemCpy;
    public static ReadyToRunHelper GetString;
    public static ReadyToRunHelper GetRuntimeTypeHandle;
    public static ReadyToRunHelper GetRuntimeMethodHandle;
    public static ReadyToRunHelper GetRuntimeFieldHandle;
    public static ReadyToRunHelper Box;
    public static ReadyToRunHelper Box_Nullable;
    public static ReadyToRunHelper Unbox;
    public static ReadyToRunHelper Unbox_Nullable;
    public static ReadyToRunHelper NewMultiDimArr;
    public static ReadyToRunHelper NewMultiDimArr_NonVarArg;
    public static ReadyToRunHelper NewObject;
    public static ReadyToRunHelper NewArray;
    public static ReadyToRunHelper CheckCastAny;
    public static ReadyToRunHelper CheckInstanceAny;
    public static ReadyToRunHelper GenericGcStaticBase;
    public static ReadyToRunHelper GenericNonGcStaticBase;
    public static ReadyToRunHelper GenericGcTlsBase;
    public static ReadyToRunHelper GenericNonGcTlsBase;
    public static ReadyToRunHelper VirtualFuncPtr;
    public static ReadyToRunHelper LMul;
    public static ReadyToRunHelper LMulOfv;
    public static ReadyToRunHelper ULMulOvf;
    public static ReadyToRunHelper LDiv;
    public static ReadyToRunHelper LMod;
    public static ReadyToRunHelper ULDiv;
    public static ReadyToRunHelper ULMod;
    public static ReadyToRunHelper LLsh;
    public static ReadyToRunHelper LRsh;
    public static ReadyToRunHelper LRsz;
    public static ReadyToRunHelper Lng2Dbl;
    public static ReadyToRunHelper ULng2Dbl;
    public static ReadyToRunHelper Div;
    public static ReadyToRunHelper Mod;
    public static ReadyToRunHelper UDiv;
    public static ReadyToRunHelper UMod;
    public static ReadyToRunHelper Dbl2Int;
    public static ReadyToRunHelper Dbl2IntOvf;
    public static ReadyToRunHelper Dbl2Lng;
    public static ReadyToRunHelper Dbl2LngOvf;
    public static ReadyToRunHelper Dbl2UInt;
    public static ReadyToRunHelper Dbl2UIntOvf;
    public static ReadyToRunHelper Dbl2ULng;
    public static ReadyToRunHelper Dbl2ULngOvf;
    public static ReadyToRunHelper DblRem;
    public static ReadyToRunHelper FltRem;
    public static ReadyToRunHelper DblRound;
    public static ReadyToRunHelper FltRound;
    public static ReadyToRunHelper PInvokeBegin;
    public static ReadyToRunHelper PInvokeEnd;
    public static ReadyToRunHelper ReversePInvokeEnter;
    public static ReadyToRunHelper ReversePInvokeExit;
    public static ReadyToRunHelper MonitorEnter;
    public static ReadyToRunHelper MonitorExit;
    public static ReadyToRunHelper MonitorEnterStatic;
    public static ReadyToRunHelper MonitorExitStatic;
    public static ReadyToRunHelper GVMLookupForSlot;
    public static ReadyToRunHelper TypeHandleToRuntimeType;
    public static ReadyToRunHelper GetRefAny;
}
public class ILCompiler.ReflectableEntity`1 : ValueType {
    public TEntity Entity;
    public MetadataCategory Category;
    public ReflectableEntity`1(TEntity entity, MetadataCategory category);
}
public class ILCompiler.RuntimeConfigurationRootProvider : object {
    private IEnumerable`1<string> _runtimeOptions;
    public RuntimeConfigurationRootProvider(IEnumerable`1<string> runtimeOptions);
    private sealed virtual override void ILCompiler.ICompilationRootProvider.AddCompilationRoots(IRootingServiceProvider rootProvider);
    protected Byte[] GetRuntimeOptionsBlob();
}
public class ILCompiler.RyuJitCompilation : Compilation {
    private CorInfoImpl _corInfo;
    private JitConfigProvider _jitConfigProvider;
    internal RyuJitCompilation(DependencyAnalyzerBase`1<NodeFactory> dependencyGraph, NodeFactory nodeFactory, IEnumerable`1<ICompilationRootProvider> roots, DebugInformationProvider debugInformationProvider, Logger logger, DevirtualizationManager devirtualizationManager, JitConfigProvider configProvider);
    protected virtual void CompileInternal(string outputFile, ObjectDumper dumper);
    protected virtual void ComputeDependencyNodeDependencies(List`1<DependencyNodeCore`1<NodeFactory>> obj);
}
public class ILCompiler.RyuJitCompilationBuilder : CompilationBuilder {
    private KeyValuePair`2[] _ryujitOptions;
    public RyuJitCompilationBuilder(CompilerTypeSystemContext context, CompilationModuleGroup group);
    public virtual CompilationBuilder UseBackendOptions(IEnumerable`1<string> options);
    public virtual ICompilation ToCompilation();
}
internal class ILCompiler.ScannerFailedException : InternalCompilerErrorException {
    public ScannerFailedException(string message);
}
public class ILCompiler.SharedGenericsConfiguration : object {
    [CompilerGeneratedAttribute]
private long <UniversalCanonGVMReflectionRootHeuristic_InstantiationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UniversalCanonGVMDepthHeuristic_NonCanonDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UniversalCanonGVMDepthHeuristic_CanonDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UniversalCanonReflectionMethodRootHeuristic_InstantiationCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxGenericDepthOfDebugRecord>k__BackingField;
    public long UniversalCanonGVMReflectionRootHeuristic_InstantiationCount { get; }
    public long UniversalCanonGVMDepthHeuristic_NonCanonDepth { get; }
    public long UniversalCanonGVMDepthHeuristic_CanonDepth { get; }
    public long UniversalCanonReflectionMethodRootHeuristic_InstantiationCount { get; }
    public long MaxGenericDepthOfDebugRecord { get; }
    [CompilerGeneratedAttribute]
public long get_UniversalCanonGVMReflectionRootHeuristic_InstantiationCount();
    [CompilerGeneratedAttribute]
public long get_UniversalCanonGVMDepthHeuristic_NonCanonDepth();
    [CompilerGeneratedAttribute]
public long get_UniversalCanonGVMDepthHeuristic_CanonDepth();
    [CompilerGeneratedAttribute]
public long get_UniversalCanonReflectionMethodRootHeuristic_InstantiationCount();
    [CompilerGeneratedAttribute]
public long get_MaxGenericDepthOfDebugRecord();
}
public enum ILCompiler.SharedGenericsMode : Enum {
    public int value__;
    public static SharedGenericsMode Disabled;
    public static SharedGenericsMode CanonicalReferenceTypes;
}
public class ILCompiler.SimdHelper : ValueType {
    private ModuleDesc[] _simdModulesCached;
    public bool IsSimdType(TypeDesc type);
    private void InitializeSimdModules(TypeDesc type);
    public bool IsVectorOfT(TypeDesc type);
}
public class ILCompiler.SingleFileCompilationModuleGroup : CompilationModuleGroup {
    public bool IsSingleFileCompilation { get; }
    public bool CanHaveReferenceThroughImportTable { get; }
    public virtual bool ContainsType(TypeDesc type);
    public virtual bool ContainsTypeDictionary(TypeDesc type);
    public virtual bool ContainsMethodBody(MethodDesc method, bool unboxingStub);
    public virtual bool ContainsMethodDictionary(MethodDesc method);
    public virtual bool ImportsMethod(MethodDesc method, bool unboxingStub);
    public virtual ExportForm GetExportTypeForm(TypeDesc type);
    public virtual ExportForm GetExportTypeFormDictionary(TypeDesc type);
    public virtual ExportForm GetExportMethodForm(MethodDesc method, bool unboxingStub);
    public virtual ExportForm GetExportMethodDictionaryForm(MethodDesc method);
    public virtual bool get_IsSingleFileCompilation();
    public virtual bool ShouldProduceFullVTable(TypeDesc type);
    public virtual bool ShouldPromoteToFullType(TypeDesc type);
    public virtual bool PresenceOfEETypeImpliesAllMethodsOnType(TypeDesc type);
    public virtual bool ShouldReferenceThroughImportTable(TypeDesc type);
    public virtual bool get_CanHaveReferenceThroughImportTable();
}
public class ILCompiler.SingleMethodCompilationModuleGroup : CompilationModuleGroup {
    private MethodDesc _method;
    public bool IsSingleFileCompilation { get; }
    public bool CanHaveReferenceThroughImportTable { get; }
    public SingleMethodCompilationModuleGroup(MethodDesc method);
    public virtual bool get_IsSingleFileCompilation();
    public virtual bool ContainsMethodBody(MethodDesc method, bool unboxingStub);
    public sealed virtual bool ContainsMethodDictionary(MethodDesc method);
    public virtual bool ContainsType(TypeDesc type);
    public virtual bool ContainsTypeDictionary(TypeDesc type);
    public virtual bool ImportsMethod(MethodDesc method, bool unboxingStub);
    public virtual ExportForm GetExportTypeForm(TypeDesc type);
    public virtual ExportForm GetExportTypeFormDictionary(TypeDesc type);
    public virtual ExportForm GetExportMethodForm(MethodDesc method, bool unboxingStub);
    public virtual ExportForm GetExportMethodDictionaryForm(MethodDesc method);
    public virtual bool ShouldProduceFullVTable(TypeDesc type);
    public virtual bool ShouldPromoteToFullType(TypeDesc type);
    public virtual bool PresenceOfEETypeImpliesAllMethodsOnType(TypeDesc type);
    public virtual bool ShouldReferenceThroughImportTable(TypeDesc type);
    public virtual bool get_CanHaveReferenceThroughImportTable();
}
public class ILCompiler.SingleMethodRootProvider : object {
    private MethodDesc _method;
    public SingleMethodRootProvider(MethodDesc method);
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public abstract class ILCompiler.StackTraceEmissionPolicy : object {
    public abstract virtual bool ShouldIncludeMethod(MethodDesc method);
}
[ExtensionAttribute]
public static class ILCompiler.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsSealed(TypeDesc type);
    [ExtensionAttribute]
public static DefType GetClosestDefType(TypeDesc type);
    [ExtensionAttribute]
public static bool RequiresInstArg(MethodDesc method);
    [ExtensionAttribute]
public static bool RequiresInstMethodDescArg(MethodDesc method);
    [ExtensionAttribute]
public static bool RequiresInstMethodTableArg(MethodDesc method);
    [ExtensionAttribute]
public static bool AcquiresInstMethodTableFromThis(MethodDesc method);
    [ExtensionAttribute]
public static bool IsArrayAddressMethod(MethodDesc method);
    [ExtensionAttribute]
public static bool HasGenericVirtualMethods(TypeDesc type);
    [ExtensionAttribute]
public static bool IsCanonicalDefinitionType(TypeDesc type, CanonicalFormKind kind);
    [ExtensionAttribute]
public static int GetFieldOrdinal(FieldDesc inputField);
    [ExtensionAttribute]
public static int GetGenericDepth(TypeDesc type);
    [ExtensionAttribute]
public static bool IsGenericDepthGreaterThan(TypeDesc type, int depth);
    [ExtensionAttribute]
public static bool IsArrayTypeWithoutGenericInterfaces(TypeDesc type);
}
public class ILCompiler.UniversalGenericsRootProvider : object {
    private TypeSystemContext _context;
    public UniversalGenericsRootProvider(TypeSystemContext context);
    public sealed virtual void AddCompilationRoots(IRootingServiceProvider rootProvider);
}
public class ILCompiler.UnixNodeMangler : NodeMangler {
    public sealed virtual string MangledBoxedTypeName(TypeDesc type);
    public sealed virtual string EEType(TypeDesc type);
    public sealed virtual string GCStatics(TypeDesc type);
    public sealed virtual string NonGCStatics(TypeDesc type);
    public sealed virtual string ThreadStatics(TypeDesc type);
    public sealed virtual string TypeGenericDictionary(TypeDesc type);
    public sealed virtual string MethodGenericDictionary(MethodDesc method);
}
[FlagsAttribute]
public enum ILCompiler.UsageBasedMetadataGenerationOptions : Enum {
    public int value__;
    public static UsageBasedMetadataGenerationOptions None;
    public static UsageBasedMetadataGenerationOptions CompleteTypesOnly;
}
public class ILCompiler.UsageBasedMetadataManager : GeneratingMetadataManager {
    private CompilationModuleGroup _compilationModuleGroup;
    internal UsageBasedMetadataGenerationOptions _generationOptions;
    private bool _hasPreciseFieldUsageInformation;
    private List`1<ModuleDesc> _modulesWithMetadata;
    private List`1<FieldDesc> _fieldsWithMetadata;
    private List`1<MethodDesc> _methodsWithMetadata;
    private List`1<MetadataType> _typesWithMetadata;
    public UsageBasedMetadataManager(CompilationModuleGroup group, CompilerTypeSystemContext typeSystemContext, MetadataBlockingPolicy blockingPolicy, ManifestResourceBlockingPolicy resourceBlockingPolicy, string logFile, StackTraceEmissionPolicy stackTracePolicy, DynamicInvokeThunkGenerationPolicy invokeThunkGenerationPolicy, UsageBasedMetadataGenerationOptions generationOptions);
    protected virtual void Graph_NewMarkedNode(DependencyNodeCore`1<NodeFactory> obj);
    protected virtual MetadataCategory GetMetadataCategory(FieldDesc field);
    protected virtual MetadataCategory GetMetadataCategory(MethodDesc method);
    protected virtual MetadataCategory GetMetadataCategory(TypeDesc type);
    protected virtual void ComputeMetadata(NodeFactory factory, Byte[]& metadataBlob, List`1& typeMappings, List`1& methodMappings, List`1& fieldMappings, List`1& stackTraceMapping);
    protected virtual void GetMetadataDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    protected virtual void GetMetadataDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    protected virtual void GetRuntimeMappingDependenciesDueToReflectability(DependencyList& dependencies, NodeFactory factory, TypeDesc type);
    public virtual void GetDependenciesDueToLdToken(DependencyList& dependencies, NodeFactory factory, FieldDesc field);
    public virtual void GetDependenciesDueToLdToken(DependencyList& dependencies, NodeFactory factory, MethodDesc method);
    [IteratorStateMachineAttribute("ILCompiler.UsageBasedMetadataManager/<GetFieldsWithRuntimeMapping>d__18")]
protected virtual IEnumerable`1<FieldDesc> GetFieldsWithRuntimeMapping();
    public virtual IEnumerable`1<ModuleDesc> GetCompilationModulesWithMetadata();
    [IteratorStateMachineAttribute("ILCompiler.UsageBasedMetadataManager/<GetTypesWithRuntimeMapping>d__20")]
private IEnumerable`1<TypeDesc> GetTypesWithRuntimeMapping();
    public MetadataManager ToAnalysisBasedMetadataManager();
}
public class ILCompiler.UserDefinedTypeDescriptor : object {
    private object _lock;
    private NodeFactory _nodeFactory;
    private ITypesDebugInfoWriter _objectWriter;
    private Dictionary`2<TypeDesc, UInt32> _knownTypes;
    private Dictionary`2<TypeDesc, UInt32> _completeKnownTypes;
    private Dictionary`2<TypeDesc, UInt32> _knownReferenceWrappedTypes;
    private Dictionary`2<TypeDesc, UInt32> _pointerTypes;
    private Dictionary`2<TypeDesc, UInt32> _enumTypes;
    private Dictionary`2<TypeDesc, UInt32> _byRefTypes;
    private Dictionary`2<TypeDesc, UInt32> _thisTypes;
    private Dictionary`2<TypeDesc, UInt32> _primitiveTypes;
    private Dictionary`2<MethodDesc, UInt32> _methodIndices;
    private Dictionary`2<MethodDesc, UInt32> _methodIdIndices;
    private NodeFactory NodeFactory { get; }
    private bool Is64Bit { get; }
    private TargetAbi Abi { get; }
    public ICollection`1<KeyValuePair`2<TypeDesc, UInt32>> CompleteKnownTypes { get; }
    public UserDefinedTypeDescriptor(ITypesDebugInfoWriter objectWriter, NodeFactory nodeFactory);
    private NodeFactory get_NodeFactory();
    private bool get_Is64Bit();
    private TargetAbi get_Abi();
    public UInt32 GetVariableTypeIndex(TypeDesc type);
    public UInt32 GetThisTypeIndex(TypeDesc type);
    public UInt32 GetMethodTypeIndex(MethodDesc method);
    public UInt32 GetMethodFunctionIdTypeIndex(MethodDesc method);
    private TypeDesc DebuggerCanonicalize(TypeDesc type);
    private UInt32 GetVariableTypeIndex(TypeDesc type, bool needsCompleteIndex);
    private UInt32 GetTypeIndex(TypeDesc type, bool needsCompleteType);
    private UInt32 GetNewTypeIndex(TypeDesc type, bool needsCompleteType);
    private UInt32 GetPointerTypeIndex(TypeDesc pointeeType);
    private UInt32 GetByRefTypeIndex(TypeDesc pointeeType);
    private UInt32 GetEnumTypeIndex(TypeDesc type);
    private UInt32 GetArrayTypeIndex(TypeDesc type);
    private ulong GetEnumRecordValue(FieldDesc field);
    private ulong HandleConstant(EcmaModule module, ConstantHandle constantHandle);
    private bool ShouldUseCanonicalTypeRecord(TypeDesc type);
    private TypeDesc GetDebugType(TypeDesc type);
    private TypeDesc GetFieldDebugType(FieldDesc field);
    private UInt32 GetClassTypeIndex(TypeDesc type, bool needsCompleteType);
    private void InsertStaticFieldRegionMember(List`1<DataFieldDescriptor> fieldDescs, DefType defType, List`1<DataFieldDescriptor> staticFields, string staticFieldForm, string staticFieldFormTypePrefix, bool staticDataInObject);
    private UInt32 GetPrimitiveTypeIndex(TypeDesc type);
    public ICollection`1<KeyValuePair`2<TypeDesc, UInt32>> get_CompleteKnownTypes();
}
public class ILCompiler.UTCNameMangler : NameMangler {
    private SHA256 _sha256;
    private string _compilationUnitPrefix;
    private ImportExportOrdinals _importOrdinals;
    private ImportExportOrdinals _exportOrdinals;
    private Dictionary`2<EcmaModule, int> _inputModuleIndices;
    [CompilerGeneratedAttribute]
private bool <HasImport>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExport>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildingClassLib>k__BackingField;
    private ImmutableDictionary`2<TypeDesc, string> _mangledTypeNames;
    protected ImmutableDictionary`2<MethodDesc, Utf8String> _mangledMethodNames;
    protected ImmutableDictionary`2<MethodDesc, Utf8String> _mangledMethodDictNames;
    private ImmutableDictionary`2<FieldDesc, Utf8String> _mangledFieldNames;
    private ImmutableDictionary`2<string, string> _mangledStringLiterals;
    private string OrdinalPrefix { get; }
    private string deDuplicatePrefix { get; }
    private bool HasImport { get; private set; }
    private bool HasExport { get; private set; }
    private bool BuildingClassLib { get; }
    public string CompilationUnitPrefix { get; public set; }
    private string EnterNameScopeSequence { get; }
    private string ExitNameScopeSequence { get; }
    public UTCNameMangler(bool hasImport, bool hasExport, ImportExportOrdinals ordinals, TypeSystemContext context, List`1<EcmaModule> inputModules, bool buildingClassLib);
    private string get_OrdinalPrefix();
    private string get_deDuplicatePrefix();
    [CompilerGeneratedAttribute]
private bool get_HasImport();
    [CompilerGeneratedAttribute]
private void set_HasImport(bool value);
    [CompilerGeneratedAttribute]
private bool get_HasExport();
    [CompilerGeneratedAttribute]
private void set_HasExport(bool value);
    [CompilerGeneratedAttribute]
private bool get_BuildingClassLib();
    private bool GetMethodOrdinal(MethodDesc method, UInt32& ordinal);
    private bool GetMethodDictionaryOrdinal(MethodDesc method, UInt32& ordinal);
    private bool GetTlsIndexOrdinal(UInt32& ordinal);
    public virtual void set_CompilationUnitPrefix(string value);
    public virtual string get_CompilationUnitPrefix();
    public virtual string SanitizeName(string s, bool typeName);
    private static Byte[] GetBytesFromString(string literal);
    private string SanitizeNameWithHash(string literal);
    private string DisambiguateName(string origName, ISet`1<string> set);
    public virtual string GetMangledTypeName(TypeDesc type);
    private string get_EnterNameScopeSequence();
    private string get_ExitNameScopeSequence();
    protected string NestMangledName(string name);
    private string ComputeMangledModuleName(EcmaAssembly module);
    private string ComputeMangledTypeName(TypeDesc type);
    public virtual Utf8String GetMangledMethodName(MethodDesc method);
    private string RemoveDeduplicatePrefix(string name);
    public string GetLinkageNameForPInvokeMethod(MethodDesc method, Int32& ordinal);
    private Utf8String ComputeMangledNameMethodWithoutInstantiation(MethodDesc method);
    private Utf8String ComputeMangledMethodName(MethodDesc method);
    public Utf8String GetMangledMethodNameForDictionary(MethodDesc method);
    private Utf8String ComputeMangledMethodDictonaryName(MethodDesc method);
    public virtual Utf8String GetMangledFieldName(FieldDesc field);
    private Utf8String ComputeMangledFieldName(FieldDesc field);
    public virtual string GetMangledStringName(string literal);
    public string GetMangledDataBlobName(FieldDesc field);
    public string GetImportedTlsIndexPrefix();
    public string GetCurrentModuleTlsIndexPrefix();
    public string GetTlsIndexPrefix(MetadataType type);
}
public class ILCompiler.UtcNodeFactory : NodeFactory {
    public static string CompilationUnitPrefix;
    public string targetPrefix;
    private bool buildMRT;
    public GCStaticDescRegionNode GCStaticDescRegion;
    public GCStaticDescRegionNode ThreadStaticGCDescRegion;
    public ArrayOfEmbeddedDataNode`1<ThreadStaticsOffsetNode> ThreadStaticsOffsetRegion;
    public ThreadStaticsIndexNode ThreadStaticsIndex;
    public ThreadStaticsDirectoryNode TLSDirectory;
    public ExternSymbolNode TlsStart;
    public ExternSymbolNode TlsEnd;
    public LoopHijackFlagNode LoopHijackFlag;
    private NodeCache`2<MetadataType, GCStaticDescNode> _GCStaticDescs;
    private NodeCache`2<MetadataType, GCStaticDescNode> _threadStaticGCStaticDescs;
    private NodeCache`2<MetadataType, ISortableSymbolNode> _threadStaticsOffset;
    private NodeCache`2<MetadataType, ImportedThreadStaticsIndexNode> _importedThreadStaticsIndices;
    private NodeCache`2<MethodKey, NonExternMethodSymbolNode> _nonExternMethodSymbols;
    private NodeCache`2<GCStaticDescNode, StandaloneGCStaticDescRegionNode> _standaloneGCStaticDescs;
    public UtcNodeFactory(CompilerTypeSystemContext context, CompilationModuleGroup compilationModuleGroup, IEnumerable`1<ModuleDesc> inputModules, IEnumerable`1<ModuleDesc> inputMetadataOnlyAssemblies, string metadataFile, string outputFile, UTCNameMangler nameMangler, bool buildMRT, bool emitStackTraceMetadata, bool disableExceptionMessages, bool allowInvokeThunks, DictionaryLayoutProvider dictionaryLayoutProvider, ImportedNodeProvider importedNodeProvider);
    private static UtcNodeFactory();
    private static Byte[] ReadBytesFromFile(string filename);
    private static ModuleDesc FindMetadataDescribingModuleInInputSet(IEnumerable`1<ModuleDesc> inputModules);
    private static MetadataManager PickMetadataManager(CompilerTypeSystemContext context, CompilationModuleGroup compilationModuleGroup, IEnumerable`1<ModuleDesc> inputModules, IEnumerable`1<ModuleDesc> inputMetadataOnlyAssemblies, string metadataFile, bool emitStackTraceMetadata, bool disableExceptionMessages, bool disableInvokeThunks);
    private static InteropStubManager NewEmptyInteropStubManager(CompilerTypeSystemContext context, CompilationModuleGroup compilationModuleGroup);
    private void CreateHostedNodeCaches();
    public virtual void AttachToDependencyGraph(DependencyAnalyzerBase`1<NodeFactory> graph);
    protected virtual IMethodNode CreateMethodEntrypointNode(MethodDesc method);
    protected virtual IMethodNode CreateUnboxingStubNode(MethodDesc method);
    protected virtual ISymbolNode CreateReadyToRunHelperNode(ReadyToRunHelperKey helperCall);
    protected virtual ISymbolDefinitionNode CreateThreadStaticsNode(MetadataType type);
    public ISymbolNode TypeGCStaticDescSymbol(MetadataType type);
    public ISymbolNode TypeThreadStaticGCDescNode(MetadataType type);
    public ISortableSymbolNode TypeThreadStaticsOffsetSymbol(MetadataType type);
    public ISortableSymbolNode TypeThreadStaticsIndexSymbol(MetadataType type);
    public NonExternMethodSymbolNode NonExternMethodSymbol(MethodDesc method, bool isUnboxingStub);
    public StandaloneGCStaticDescRegionNode StandaloneGCStaticDescRegion(GCStaticDescNode staticDesc);
    public BlobNode FieldRvaDataBlob(FieldDesc field);
    public ISymbolNode LoopHijackFlagSymbol();
    [CompilerGeneratedAttribute]
private ISortableSymbolNode <CreateHostedNodeCaches>b__8_2(MetadataType type);
    [CompilerGeneratedAttribute]
private ImportedThreadStaticsIndexNode <CreateHostedNodeCaches>b__8_3(MetadataType type);
    [CompilerGeneratedAttribute]
private NonExternMethodSymbolNode <CreateHostedNodeCaches>b__8_4(MethodKey method);
}
public class ILCompiler.UtcNodeMangler : WindowsNodeMangler {
    public virtual string MethodGenericDictionary(MethodDesc method);
}
public class ILCompiler.UtcStackTraceEmissionPolicy : StackTraceEmissionPolicy {
    private List`1<string> _stackTraceExceptionFiles;
    private HashSet`1<string> _namespaceBlacklist;
    private HashSet`1<string> _namespaceWhitelist;
    private HashSet`1<string> _typeBlacklist;
    private HashSet`1<string> _typeWhitelist;
    private Dictionary`2<TypeDesc, bool> _cachedTypeEligibility;
    public virtual bool ShouldIncludeMethod(MethodDesc method);
    private bool IsTypeExplicitlyDisabled(DefType type);
    private bool IsTypeExplicitlyDisabledInner(DefType type, String& outputTypeName);
    private string GetAppExeDirectory();
    private void LoadExceptionFile(string exceptionFileName);
}
internal class ILCompiler.VectorOfTFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    private FieldLayoutAlgorithm _fallbackAlgorithm;
    public VectorOfTFieldLayoutAlgorithm(FieldLayoutAlgorithm fallbackAlgorithm);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType defType, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType defType, StaticLayoutKind layoutKind);
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
}
[ExtensionAttribute]
public static class ILCompiler.VirtualMethodSlotHelper : object {
    public static int GetVirtualMethodSlot(NodeFactory factory, MethodDesc method, TypeDesc implType, bool countDictionarySlots);
    private static int GetNumberOfBaseSlots(NodeFactory factory, TypeDesc owningType, bool countDictionarySlots);
    public static int GetGenericDictionarySlot(NodeFactory factory, TypeDesc type);
    [ExtensionAttribute]
public static bool HasGenericDictionarySlot(TypeDesc type);
}
public abstract class ILCompiler.VTableSliceProvider : object {
    internal abstract virtual VTableSliceNode GetSlice(TypeDesc type);
}
public class ILCompiler.WindowsNodeMangler : NodeMangler {
    public static string NonGCStaticMemberName;
    public static string GCStaticMemberName;
    public static string ThreadStaticMemberName;
    public sealed virtual string MangledBoxedTypeName(TypeDesc type);
    public sealed virtual string EEType(TypeDesc type);
    public sealed virtual string GCStatics(TypeDesc type);
    public sealed virtual string NonGCStatics(TypeDesc type);
    public sealed virtual string ThreadStatics(TypeDesc type);
    public sealed virtual string TypeGenericDictionary(TypeDesc type);
    public virtual string MethodGenericDictionary(MethodDesc method);
}
public class Internal.Compiler.ILStreamReader : ValueType {
    private Byte[] _ilBytes;
    private MethodIL _methodIL;
    private int _currentOffset;
    public bool HasNextInstruction { get; }
    public int CodeSize { get; }
    public ILStreamReader(MethodIL methodIL);
    private byte ReadILByte();
    private ILOpcode ReadILOpcode();
    private byte PeekILByte();
    private ILOpcode PeekILOpcode();
    private bool TryReadILByte(Byte& ilbyte);
    private ushort ReadILUInt16();
    private bool TryReadILUInt16(UInt16& ilUint16);
    private UInt32 ReadILUInt32();
    private bool TryReadILUInt32(UInt32& ilUint32);
    private int ReadILToken();
    private bool TryReadILToken(Int32& ilToken);
    private ulong ReadILUInt64();
    private float ReadILFloat();
    private double ReadILDouble();
    private void SkipIL(int bytes);
    public bool get_HasNextInstruction();
    public int get_CodeSize();
    public bool TryReadLdtoken(Int32& token);
    public int ReadLdtoken();
    public bool TryReadLdtokenAsTypeSystemEntity(TypeSystemEntity& entity);
    public TypeSystemEntity ReadLdtokenAsTypeSystemEntity();
    public bool TryReadLdcI4(Int32& value);
    public int ReadLdcI4();
    public bool TryReadRet();
    public void ReadRet();
    public bool TryReadPop();
    public void ReadPop();
    public bool TryReadLdstr(String& ldstrString);
    public string ReadLdstr();
}
[ExtensionAttribute]
internal static class Internal.IL.HelperExtensions : object {
    [ExtensionAttribute]
public static MetadataType GetHelperType(TypeSystemContext context, string name);
    [ExtensionAttribute]
public static MethodDesc GetHelperEntryPoint(TypeSystemContext context, string typeName, string methodName);
    [ExtensionAttribute]
public static void EmitCallThrowHelper(ILCodeStream codeStream, ILEmitter emitter, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc GetKnownMethod(TypeDesc type, string name, MethodSignature signature);
    [ExtensionAttribute]
public static FieldDesc GetKnownField(TypeDesc type, string name);
    [ExtensionAttribute]
public static MetadataType GetKnownNestedType(MetadataType type, string name);
    [ExtensionAttribute]
public static MetadataType GetKnownType(ModuleDesc module, string namespace, string name);
}
internal class Internal.IL.ILImporter : object {
    private BasicBlock[] _basicBlocks;
    private BasicBlock _currentBasicBlock;
    private int _currentOffset;
    private BasicBlock _pendingBasicBlocks;
    private MethodIL _methodIL;
    private MethodIL _canonMethodIL;
    private ILScanner _compilation;
    private ILScanNodeFactory _factory;
    private bool _isFallbackBodyCompilation;
    private MethodDesc _canonMethod;
    private DependencyList<NodeFactory> _dependencies;
    private Byte[] _ilBytes;
    private bool _isReadOnly;
    private TypeDesc _constrained;
    private int _currentInstructionOffset;
    private int _previousInstructionOffset;
    private ExceptionRegion[] _exceptionRegions;
    public ILImporter(ILScanner compilation, MethodDesc method, MethodIL methodIL);
    private byte ReadILByte();
    private ushort ReadILUInt16();
    private UInt32 ReadILUInt32();
    private int ReadILToken();
    private ulong ReadILUInt64();
    private float ReadILFloat();
    private double ReadILDouble();
    private void SkipIL(int bytes);
    private void FindBasicBlocks();
    private BasicBlock CreateBasicBlock(int offset);
    private void FindJumpTargets();
    private void FindEHTargets();
    private void ImportBasicBlocks();
    private void MarkBasicBlock(BasicBlock basicBlock);
    private void ImportBasicBlock(BasicBlock basicBlock);
    private void ImportLoadIndirect(WellKnownType wellKnownType);
    private void ImportStoreIndirect(WellKnownType wellKnownType);
    private void ImportLoadElement(WellKnownType wellKnownType);
    private void ImportStoreElement(WellKnownType wellKnownType);
    public DependencyList<NodeFactory> Import();
    private ISymbolNode GetGenericLookupHelper(ReadyToRunHelperId helperId, object helperArgument);
    private ISymbolNode GetHelperEntrypoint(ReadyToRunHelper helper);
    private void MarkInstructionBoundary();
    private void EndImportingBasicBlock(BasicBlock basicBlock);
    private void StartImportingBasicBlock(BasicBlock basicBlock);
    private void StartImportingInstruction();
    private void EndImportingInstruction();
    private void ImportJmp(int token);
    private void ImportCasting(ILOpcode opcode, int token);
    private void ImportCall(ILOpcode opcode, int token);
    private void ImportLdFtn(int token, ILOpcode opCode);
    private void ImportBranch(ILOpcode opcode, BasicBlock target, BasicBlock fallthrough);
    private void ImportSwitchJump(int jmpBase, Int32[] jmpDelta, BasicBlock fallthrough);
    private void ImportUnbox(int token, ILOpcode opCode);
    private void ImportRefAnyVal(int token);
    private void ImportMkRefAny(int token);
    private void ImportLdToken(int token);
    private void ImportRefAnyType();
    private void ImportArgList();
    private void ImportConstrainedPrefix(int token);
    private void ImportReadOnlyPrefix();
    private void ImportFieldAccess(int token, bool isStatic, string reason);
    private void ImportLoadField(int token, bool isStatic);
    private void ImportAddressOfField(int token, bool isStatic);
    private void ImportStoreField(int token, bool isStatic);
    private void ImportLoadString(int token);
    private void ImportBox(int token);
    private void AddBoxingDependencies(TypeDesc type, string reason);
    private void ImportLeave(BasicBlock target);
    private void ImportNewArray(int token);
    private void ImportLoadElement(int token);
    private void ImportLoadElement(TypeDesc elementType);
    private void ImportStoreElement(int token);
    private void ImportStoreElement(TypeDesc elementType);
    private void ImportAddressOfElement(int token);
    private void ImportBinaryOperation(ILOpcode opcode);
    private void ImportFallthrough(BasicBlock next);
    private int ReadILTokenAt(int ilOffset);
    private void ReportInvalidBranchTarget(int targetOffset);
    private void ReportFallthroughAtEndOfMethod();
    private void ReportMethodEndInsideInstruction();
    private void ReportInvalidInstruction(ILOpcode opcode);
    private bool IsRuntimeHelpersInitializeArray(MethodDesc method);
    private bool IsRuntimeTypeHandleGetValueInternal(MethodDesc method);
    private bool IsActivatorDefaultConstructorOf(MethodDesc method);
    private bool IsEETypePtrOf(MethodDesc method);
    private TypeDesc GetWellKnownType(WellKnownType wellKnownType);
    private void ImportNop();
    private void ImportBreak();
    private void ImportLoadVar(int index, bool argument);
    private void ImportStoreVar(int index, bool argument);
    private void ImportAddressOfVar(int index, bool argument);
    private void ImportDup();
    private void ImportPop();
    private void ImportCalli(int token);
    private void ImportLoadNull();
    private void ImportReturn();
    private void ImportLoadInt(long value, StackValueKind kind);
    private void ImportLoadFloat(double value);
    private void ImportLoadIndirect(int token);
    private void ImportLoadIndirect(TypeDesc type);
    private void ImportStoreIndirect(int token);
    private void ImportStoreIndirect(TypeDesc type);
    private void ImportShiftOperation(ILOpcode opcode);
    private void ImportCompareOperation(ILOpcode opcode);
    private void ImportConvert(WellKnownType wellKnownType, bool checkOverflow, bool unsigned);
    private void ImportUnaryOperation(ILOpcode opCode);
    private void ImportCpOpj(int token);
    private void ImportCkFinite();
    private void ImportLocalAlloc();
    private void ImportEndFilter();
    private void ImportCpBlk();
    private void ImportInitBlk();
    private void ImportRethrow();
    private void ImportSizeOf(int token);
    private void ImportUnalignedPrefix(byte alignment);
    private void ImportVolatilePrefix();
    private void ImportTailPrefix();
    private void ImportNoPrefix(byte mask);
    private void ImportThrow();
    private void ImportInitObj(int token);
    private void ImportLoadLength();
    private void ImportEndFinally();
}
internal class Internal.IL.ILProvider : LockFreeReaderHashtable`2<MethodDesc, MethodILData> {
    private PInvokeILProvider _pinvokeILProvider;
    public ILProvider(PInvokeILProvider pinvokeILProvider);
    private MethodIL TryGetRuntimeImplementedMethodIL(MethodDesc method);
    private MethodIL TryGetIntrinsicMethodIL(MethodDesc method);
    private MethodIL TryGetPerInstantiationIntrinsicMethodIL(MethodDesc method);
    private MethodIL CreateMethodIL(MethodDesc method);
    protected virtual int GetKeyHashCode(MethodDesc key);
    protected virtual int GetValueHashCode(MethodILData value);
    protected virtual bool CompareKeyToValue(MethodDesc key, MethodILData value);
    protected virtual bool CompareValueToValue(MethodILData value1, MethodILData value2);
    protected virtual MethodILData CreateValueFromKey(MethodDesc key);
    public MethodIL GetMethodIL(MethodDesc method);
}
public static class Internal.IL.McgInteropSupport : object {
    private static string AssemblyNameSuffix;
    private static string PInvokeContainerTypeNS;
    private static string PInvokeMethodContainerType;
    public static bool IsPregeneratedInterop(MethodDesc method);
    public static MethodDesc TryGetPregeneratedPInvoke(MethodDesc method);
    private static MethodDesc GetMatchingMethod(ModuleDesc module, MethodDesc method);
    private static TypeDesc GetMatchingType(ModuleDesc module, TypeDesc type);
    private static TypeDesc TryGetMcgGeneratedType(ModuleDesc module);
}
internal class Internal.IL.PInvokeILProvider : object {
    private PInvokeILEmitterConfiguration _pInvokeILEmitterConfiguration;
    private InteropStateManager _interopStateManager;
    public PInvokeILProvider(PInvokeILEmitterConfiguration pInvokeILEmitterConfiguration, InteropStateManager interopStateManager);
    public MethodIL EmitIL(MethodDesc method);
    public MethodDesc GetCalliStub(MethodSignature signature);
}
internal enum Internal.IL.StackValueKind : Enum {
    public int value__;
    public static StackValueKind Unknown;
    public static StackValueKind Int32;
    public static StackValueKind Int64;
    public static StackValueKind NativeInt;
    public static StackValueKind Float;
    public static StackValueKind ByRef;
    public static StackValueKind ObjRef;
    public static StackValueKind ValueType;
}
public static class Internal.IL.Stubs.AddrOfIntrinsic : object {
    public static MethodIL EmitIL(MethodDesc target);
}
internal class Internal.IL.Stubs.ArrayMethodILEmitter : ValueType {
    private ArrayMethod _method;
    private TypeDesc _elementType;
    private int _rank;
    private ILToken _helperFieldToken;
    private ILEmitter _emitter;
    private ArrayMethodILEmitter(ArrayMethod method);
    private void EmitLoadInteriorAddress(ILCodeStream codeStream, int offset);
    private MethodIL EmitIL();
    public static MethodIL EmitIL(ArrayMethod arrayMethod);
    private void EmitILForAccessor();
}
internal class Internal.IL.Stubs.AssemblyGetExecutingAssemblyMethodThunk : ILStubMethod {
    [CompilerGeneratedAttribute]
private IAssemblyDesc <ExecutingAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDesc <OwningType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSignature <Signature>k__BackingField;
    public TypeSystemContext Context { get; }
    public IAssemblyDesc ExecutingAssembly { get; }
    public string Name { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    protected int ClassCode { get; }
    public AssemblyGetExecutingAssemblyMethodThunk(TypeDesc owningType, IAssemblyDesc executingAssembly);
    public virtual TypeSystemContext get_Context();
    [CompilerGeneratedAttribute]
public IAssemblyDesc get_ExecutingAssembly();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual TypeDesc get_OwningType();
    [CompilerGeneratedAttribute]
public virtual MethodSignature get_Signature();
    public virtual MethodIL EmitIL();
    protected virtual int get_ClassCode();
    protected virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
internal class Internal.IL.Stubs.AssemblyGetExecutingAssemblyMethodThunkCache : object {
    private TypeDesc _owningTypeForThunks;
    private Unifier _cache;
    public AssemblyGetExecutingAssemblyMethodThunkCache(TypeDesc owningTypeForThunks);
    public MethodDesc GetHelper(IAssemblyDesc executingAssembly);
}
public static class Internal.IL.Stubs.CalliIntrinsic : object {
    public static MethodIL EmitIL(MethodDesc target);
}
public static class Internal.IL.Stubs.ComparerIntrinsics : object {
    public static MethodIL EmitComparerCreate(MethodDesc target);
    public static MethodIL EmitEqualityComparerCreate(MethodDesc target);
    public static TypeDesc GetEqualityComparerForType(TypeDesc comparand);
    private static MethodIL EmitComparerAndEqualityComparerCreateCommon(MethodDesc methodBeingGenerated, string flavor, string interfaceName);
    private static TypeDesc GetComparerForType(TypeDesc type, string flavor, string interfaceName);
    public static TypeDesc[] GetPotentialComparersForType(TypeDesc type);
    public static TypeDesc[] GetPotentialEqualityComparersForType(TypeDesc type);
    private static TypeDesc[] GetPotentialComparersForTypeCommon(TypeDesc type, string flavor, string interfaceName);
    public static bool ImplementsIEquatable(TypeDesc type);
    private static bool ImplementsInterfaceOfSelf(TypeDesc type, string interfaceName);
}
public static class Internal.IL.Stubs.DelegateMethodILEmitter : object {
    public static MethodIL EmitIL(MethodDesc method);
}
public static class Internal.IL.Stubs.EETypePtrOfIntrinsic : object {
    public static MethodIL EmitIL(MethodDesc target);
}
public static class Internal.IL.Stubs.GetCanonTypeIntrinsic : object {
    public static MethodIL EmitIL(MethodDesc target);
}
internal class Internal.IL.Stubs.MethodBaseGetCurrentMethodThunk : ILStubMethod {
    [CompilerGeneratedAttribute]
private MethodDesc <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSignature <Signature>k__BackingField;
    public TypeSystemContext Context { get; }
    public MethodDesc Method { get; }
    public string Name { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    private MethodDesc Internal.TypeSystem.IPrefixMangledMethod.BaseMethod { get; }
    private string Internal.TypeSystem.IPrefixMangledMethod.Prefix { get; }
    protected int ClassCode { get; }
    public MethodBaseGetCurrentMethodThunk(MethodDesc method);
    public virtual TypeSystemContext get_Context();
    [CompilerGeneratedAttribute]
public MethodDesc get_Method();
    public virtual string get_Name();
    public virtual TypeDesc get_OwningType();
    [CompilerGeneratedAttribute]
public virtual MethodSignature get_Signature();
    public virtual MethodIL EmitIL();
    private sealed virtual override MethodDesc Internal.TypeSystem.IPrefixMangledMethod.get_BaseMethod();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledMethod.get_Prefix();
    protected virtual int get_ClassCode();
    protected virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
internal class Internal.IL.Stubs.MethodBaseGetCurrentMethodThunkCache : object {
    private Unifier _cache;
    public MethodDesc GetHelper(MethodDesc currentMethod);
}
public class Internal.IL.Stubs.StartupCode.AppContextInitializerMethod : ILStubMethod {
    private TypeDesc _owningType;
    private MethodSignature _signature;
    private IReadOnlyCollection`1<string> _switches;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public string Name { get; }
    public MethodSignature Signature { get; }
    protected int ClassCode { get; }
    public AppContextInitializerMethod(TypeDesc owningType, IEnumerable`1<string> switches);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual string get_Name();
    public virtual MethodIL EmitIL();
    public virtual MethodSignature get_Signature();
    protected virtual int get_ClassCode();
    protected virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public class Internal.IL.Stubs.StartupCode.NativeLibraryStartupMethod : ILStubMethod {
    private TypeDesc _owningType;
    private MethodSignature _signature;
    private IReadOnlyCollection`1<MethodDesc> _libraryInitializers;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public string Name { get; }
    public MethodSignature Signature { get; }
    public bool IsNativeCallable { get; }
    protected int ClassCode { get; }
    public NativeLibraryStartupMethod(TypeDesc owningType, IReadOnlyCollection`1<MethodDesc> libraryInitializers);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual string get_Name();
    public virtual MethodIL EmitIL();
    public virtual MethodSignature get_Signature();
    public virtual bool get_IsNativeCallable();
    protected virtual int get_ClassCode();
    protected virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public class Internal.IL.Stubs.StartupCode.StartupCodeMainMethod : ILStubMethod {
    private TypeDesc _owningType;
    private MainMethodWrapper _mainMethod;
    private MethodSignature _signature;
    private IReadOnlyCollection`1<MethodDesc> _libraryInitializers;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public string Name { get; }
    public MethodSignature Signature { get; }
    public bool IsNativeCallable { get; }
    protected int ClassCode { get; }
    public StartupCodeMainMethod(TypeDesc owningType, MethodDesc mainMethod, IReadOnlyCollection`1<MethodDesc> libraryInitializers);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual string get_Name();
    public virtual MethodIL EmitIL();
    public virtual MethodSignature get_Signature();
    public virtual bool get_IsNativeCallable();
    protected virtual int get_ClassCode();
    protected virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
internal class Internal.IL.Stubs.TypeGetTypeMethodThunk : ILStubMethod {
    private MethodDesc _helperMethod;
    [CompilerGeneratedAttribute]
private TypeDesc <OwningType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSignature <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultAssemblyName>k__BackingField;
    public TypeSystemContext Context { get; }
    public string Name { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public string DefaultAssemblyName { get; }
    protected int ClassCode { get; }
    public TypeGetTypeMethodThunk(TypeDesc owningType, MethodSignature signature, MethodDesc helperMethod, string defaultAssemblyName);
    public virtual TypeSystemContext get_Context();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual TypeDesc get_OwningType();
    [CompilerGeneratedAttribute]
public virtual MethodSignature get_Signature();
    [CompilerGeneratedAttribute]
public string get_DefaultAssemblyName();
    public virtual MethodIL EmitIL();
    protected virtual int get_ClassCode();
    protected virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
internal class Internal.IL.Stubs.TypeGetTypeMethodThunkCache : object {
    private TypeDesc _owningTypeForThunks;
    private Unifier _cache;
    public TypeGetTypeMethodThunkCache(TypeDesc owningTypeForThunks);
    public MethodDesc GetHelper(MethodDesc getTypeOverload, string defaultAssemblyName);
}
internal static class Internal.IL.Stubs.TypeSystemThrowingILEmitter : object {
    public static MethodIL EmitIL(MethodDesc methodThatShouldThrow, TypeSystemException exception);
}
public static class Internal.IL.Stubs.UnsafeIntrinsics : object {
    public static MethodIL EmitIL(MethodDesc method);
    private static MethodIL EmitSizeOf(MethodDesc method);
    private static MethodIL EmitAdd(MethodDesc method);
    private static MethodIL EmitReadWrite(MethodDesc method, bool write, bool unaligned);
}
public enum Internal.JitInterface._EXCEPTION_POINTERS : Enum {
    public int value__;
}
public enum Internal.JitInterface.BoundaryTypes : Enum {
    public int value__;
    public static BoundaryTypes NO_BOUNDARIES;
    public static BoundaryTypes STACK_EMPTY_BOUNDARIES;
    public static BoundaryTypes NOP_BOUNDARIES;
    public static BoundaryTypes CALL_SITE_BOUNDARIES;
    public static BoundaryTypes DEFAULT_BOUNDARIES;
}
public static class Internal.JitInterface.CORINFO : object {
    public static UInt32 MAXINDIRECTIONS;
    public static ushort USEHELPER;
}
public enum Internal.JitInterface.CORINFO_ACCESS_FLAGS : Enum {
    public int value__;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_ANY;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_THIS;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_UNWRAP;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_NONNULL;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_LDFTN;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_GET;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_SET;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_ADDRESS;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_INIT_ARRAY;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_ATYPICAL_CALLSITE;
    public static CORINFO_ACCESS_FLAGS CORINFO_ACCESS_INLINECHECK;
}
public class Internal.JitInterface.CORINFO_ARG_LIST_STRUCT_ : ValueType {
}
public class Internal.JitInterface.CORINFO_ASSEMBLY_STRUCT_ : ValueType {
}
public class Internal.JitInterface.CORINFO_CALL_INFO : ValueType {
    public CORINFO_METHOD_STRUCT_* hMethod;
    public UInt32 methodFlags;
    public UInt32 classFlags;
    public CORINFO_SIG_INFO sig;
    public UInt32 verMethodFlags;
    public CORINFO_SIG_INFO verSig;
    public CorInfoIsAccessAllowedResult accessAllowed;
    public CORINFO_HELPER_DESC callsiteCalloutHelper;
    public CORINFO_THIS_TRANSFORM thisTransform;
    public CORINFO_CALL_KIND kind;
    public UInt32 _nullInstanceCheck;
    public CORINFO_CONTEXT_STRUCT* contextHandle;
    public UInt32 _exactContextNeedsRuntimeLookup;
    public CORINFO_LOOKUP codePointerOrStubLookup;
    public CORINFO_CONST_LOOKUP instParamLookup;
    public UInt32 _secureDelegateInvoke;
    public bool nullInstanceCheck { get; public set; }
    public bool exactContextNeedsRuntimeLookup { get; public set; }
    public bool secureDelegateInvoke { get; public set; }
    public bool get_nullInstanceCheck();
    public void set_nullInstanceCheck(bool value);
    public bool get_exactContextNeedsRuntimeLookup();
    public void set_exactContextNeedsRuntimeLookup(bool value);
    public bool get_secureDelegateInvoke();
    public void set_secureDelegateInvoke(bool value);
}
public enum Internal.JitInterface.CORINFO_CALL_KIND : Enum {
    public int value__;
    public static CORINFO_CALL_KIND CORINFO_CALL;
    public static CORINFO_CALL_KIND CORINFO_CALL_CODE_POINTER;
    public static CORINFO_CALL_KIND CORINFO_VIRTUALCALL_STUB;
    public static CORINFO_CALL_KIND CORINFO_VIRTUALCALL_LDVIRTFTN;
    public static CORINFO_CALL_KIND CORINFO_VIRTUALCALL_VTABLE;
}
public enum Internal.JitInterface.CORINFO_CALLINFO_FLAGS : Enum {
    public int value__;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_NONE;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_ALLOWINSTPARAM;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_CALLVIRT;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_KINDONLY;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_VERIFICATION;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_SECURITYCHECKS;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_LDFTN;
    public static CORINFO_CALLINFO_FLAGS CORINFO_CALLINFO_ATYPICAL_CALLSITE;
}
public class Internal.JitInterface.CORINFO_CLASS_STRUCT_ : ValueType {
    internal static CORINFO_CLASS_STRUCT_* Construct(int i);
    internal static int GetValue(CORINFO_CLASS_STRUCT_* val);
}
public class Internal.JitInterface.CORINFO_CONST_LOOKUP : ValueType {
    public InfoAccessType accessType;
    private IntPtr _value;
    public CORINFO_GENERIC_STRUCT_* handle { get; public set; }
    public Void* addr { get; public set; }
    public CORINFO_GENERIC_STRUCT_* get_handle();
    public void set_handle(CORINFO_GENERIC_STRUCT_* value);
    public Void* get_addr();
    public void set_addr(Void* value);
}
public class Internal.JitInterface.CORINFO_CONTEXT_STRUCT : ValueType {
}
public class Internal.JitInterface.CORINFO_EE_INFO : ValueType {
    public InlinedCallFrameInfo inlinedCallFrameInfo;
    public UInt32 offsetOfThreadFrame;
    public UInt32 offsetOfGCState;
    public UInt32 offsetOfDelegateInstance;
    public UInt32 offsetOfDelegateFirstTarget;
    public UInt32 offsetOfSecureDelegateIndirectCell;
    public UInt32 offsetOfTransparentProxyRP;
    public UInt32 offsetOfRealProxyServer;
    public UInt32 offsetOfObjArrayData;
    public UInt32 sizeOfReversePInvokeFrame;
    public UIntPtr osPageSize;
    public UIntPtr maxUncheckedOffsetForNullObject;
    public CORINFO_RUNTIME_ABI targetAbi;
    public CORINFO_OS osType;
    public UInt32 osMajor;
    public UInt32 osMinor;
    public UInt32 osBuild;
}
public class Internal.JitInterface.CORINFO_EH_CLAUSE : ValueType {
    public CORINFO_EH_CLAUSE_FLAGS Flags;
    public UInt32 TryOffset;
    public UInt32 TryLength;
    public UInt32 HandlerOffset;
    public UInt32 HandlerLength;
    public UInt32 ClassTokenOrOffset;
}
public enum Internal.JitInterface.CORINFO_EH_CLAUSE_FLAGS : Enum {
    public int value__;
    public static CORINFO_EH_CLAUSE_FLAGS CORINFO_EH_CLAUSE_NONE;
    public static CORINFO_EH_CLAUSE_FLAGS CORINFO_EH_CLAUSE_FILTER;
    public static CORINFO_EH_CLAUSE_FLAGS CORINFO_EH_CLAUSE_FINALLY;
    public static CORINFO_EH_CLAUSE_FLAGS CORINFO_EH_CLAUSE_FAULT;
    public static CORINFO_EH_CLAUSE_FLAGS CORINFO_EH_CLAUSE_DUPLICATED;
    public static CORINFO_EH_CLAUSE_FLAGS CORINFO_EH_CLAUSE_SAMETRY;
}
public enum Internal.JitInterface.CORINFO_FIELD_ACCESSOR : Enum {
    public int value__;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_INSTANCE;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_INSTANCE_WITH_BASE;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_INSTANCE_HELPER;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_INSTANCE_ADDR_HELPER;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_ADDRESS;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_RVA_ADDRESS;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_SHARED_STATIC_HELPER;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_GENERICS_STATIC_HELPER;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_ADDR_HELPER;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_TLS;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_STATIC_READYTORUN_HELPER;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_INTRINSIC_ZERO;
    public static CORINFO_FIELD_ACCESSOR CORINFO_FIELD_INTRINSIC_EMPTY_STRING;
}
public enum Internal.JitInterface.CORINFO_FIELD_FLAGS : Enum {
    public int value__;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_STATIC;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_UNMANAGED;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_FINAL;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_STATIC_IN_HEAP;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_SAFESTATIC_BYREF_RETURN;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_INITCLASS;
    public static CORINFO_FIELD_FLAGS CORINFO_FLG_FIELD_PROTECTED;
}
public class Internal.JitInterface.CORINFO_FIELD_INFO : ValueType {
    public CORINFO_FIELD_ACCESSOR fieldAccessor;
    public CORINFO_FIELD_FLAGS fieldFlags;
    public CorInfoHelpFunc helper;
    public UInt32 offset;
    public CorInfoType fieldType;
    public CORINFO_CLASS_STRUCT_* structType;
    public CorInfoIsAccessAllowedResult accessAllowed;
    public CORINFO_HELPER_DESC accessCalloutHelper;
    public CORINFO_CONST_LOOKUP fieldLookup;
}
public class Internal.JitInterface.CORINFO_FIELD_STRUCT_ : ValueType {
    internal static CORINFO_FIELD_STRUCT_* Construct(int i);
    internal static int GetValue(CORINFO_FIELD_STRUCT_* val);
}
public class Internal.JitInterface.CORINFO_GENERIC_STRUCT_ : ValueType {
}
public class Internal.JitInterface.CORINFO_GENERICHANDLE_RESULT : ValueType {
    public CORINFO_LOOKUP lookup;
    public CORINFO_GENERIC_STRUCT_* compileTimeHandle;
    public CorInfoGenericHandleType handleType;
}
public class Internal.JitInterface.CORINFO_HELPER_ARG : ValueType {
    public IntPtr argHandle;
    public CorInfoAccessAllowedHelperArgType argType;
}
public class Internal.JitInterface.CORINFO_HELPER_DESC : ValueType {
    public CorInfoHelpFunc helperNum;
    public UInt32 numArgs;
    public CORINFO_HELPER_ARG args0;
    public CORINFO_HELPER_ARG args1;
    public CORINFO_HELPER_ARG args2;
    public CORINFO_HELPER_ARG args3;
}
public class Internal.JitInterface.CORINFO_JUST_MY_CODE_HANDLE_ : ValueType {
}
public class Internal.JitInterface.CORINFO_LOOKUP : ValueType {
    public CORINFO_LOOKUP_KIND lookupKind;
    public CORINFO_RUNTIME_LOOKUP runtimeLookup;
    public CORINFO_CONST_LOOKUP& constLookup { get; }
    public CORINFO_CONST_LOOKUP& get_constLookup();
}
public class Internal.JitInterface.CORINFO_LOOKUP_KIND : ValueType {
    private byte _needsRuntimeLookup;
    public CORINFO_RUNTIME_LOOKUP_KIND runtimeLookupKind;
    public ushort runtimeLookupFlags;
    public Void* runtimeLookupArgs;
    public bool needsRuntimeLookup { get; public set; }
    public bool get_needsRuntimeLookup();
    public void set_needsRuntimeLookup(bool value);
}
public class Internal.JitInterface.CORINFO_METHOD_INFO : ValueType {
    public CORINFO_METHOD_STRUCT_* ftn;
    public CORINFO_MODULE_STRUCT_* scope;
    public Byte* ILCode;
    public UInt32 ILCodeSize;
    public UInt32 maxStack;
    public UInt32 EHcount;
    public CorInfoOptions options;
    public CorInfoRegionKind regionKind;
    public CORINFO_SIG_INFO args;
    public CORINFO_SIG_INFO locals;
}
public class Internal.JitInterface.CORINFO_METHOD_STRUCT_ : ValueType {
    internal static CORINFO_METHOD_STRUCT_* Construct(int i);
    internal static int GetValue(CORINFO_METHOD_STRUCT_* val);
}
public class Internal.JitInterface.CORINFO_MODULE_STRUCT_ : ValueType {
    internal static CORINFO_MODULE_STRUCT_* Construct(int i);
    internal static int GetValue(CORINFO_MODULE_STRUCT_* val);
}
public enum Internal.JitInterface.CORINFO_OS : Enum {
    public int value__;
    public static CORINFO_OS CORINFO_WINNT;
    public static CORINFO_OS CORINFO_PAL;
}
public class Internal.JitInterface.CORINFO_RESOLVED_TOKEN : ValueType {
    public CORINFO_CONTEXT_STRUCT* tokenContext;
    public CORINFO_MODULE_STRUCT_* tokenScope;
    public mdToken token;
    public CorInfoTokenKind tokenType;
    public CORINFO_CLASS_STRUCT_* hClass;
    public CORINFO_METHOD_STRUCT_* hMethod;
    public CORINFO_FIELD_STRUCT_* hField;
    public Byte* pTypeSpec;
    public UInt32 cbTypeSpec;
    public Byte* pMethodSpec;
    public UInt32 cbMethodSpec;
}
public enum Internal.JitInterface.CORINFO_RUNTIME_ABI : Enum {
    public int value__;
    public static CORINFO_RUNTIME_ABI CORINFO_DESKTOP_ABI;
    public static CORINFO_RUNTIME_ABI CORINFO_CORECLR_ABI;
    public static CORINFO_RUNTIME_ABI CORINFO_CORERT_ABI;
}
public class Internal.JitInterface.CORINFO_RUNTIME_LOOKUP : ValueType {
    public Void* signature;
    public CorInfoHelpFunc helper;
    public ushort indirections;
    public byte _testForNull;
    public byte _testForFixup;
    public IntPtr offset0;
    public IntPtr offset1;
    public IntPtr offset2;
    public IntPtr offset3;
    public byte _indirectFirstOffset;
    public byte _indirectSecondOffset;
    public bool testForNull { get; public set; }
    public bool testForFixup { get; public set; }
    public bool indirectFirstOffset { get; public set; }
    public bool indirectSecondOffset { get; public set; }
    public bool get_testForNull();
    public void set_testForNull(bool value);
    public bool get_testForFixup();
    public void set_testForFixup(bool value);
    public bool get_indirectFirstOffset();
    public void set_indirectFirstOffset(bool value);
    public bool get_indirectSecondOffset();
    public void set_indirectSecondOffset(bool value);
}
public enum Internal.JitInterface.CORINFO_RUNTIME_LOOKUP_KIND : Enum {
    public int value__;
    public static CORINFO_RUNTIME_LOOKUP_KIND CORINFO_LOOKUP_THISOBJ;
    public static CORINFO_RUNTIME_LOOKUP_KIND CORINFO_LOOKUP_METHODPARAM;
    public static CORINFO_RUNTIME_LOOKUP_KIND CORINFO_LOOKUP_CLASSPARAM;
}
public class Internal.JitInterface.CORINFO_SIG_INFO : ValueType {
    public CorInfoCallConv callConv;
    public CORINFO_CLASS_STRUCT_* retTypeClass;
    public CORINFO_CLASS_STRUCT_* retTypeSigClass;
    public byte _retType;
    public byte flags;
    public ushort numArgs;
    public CORINFO_SIG_INST sigInst;
    public CORINFO_ARG_LIST_STRUCT_* args;
    public Byte* pSig;
    public UInt32 cbSig;
    public CORINFO_MODULE_STRUCT_* scope;
    public mdToken token;
    public CorInfoType retType { get; public set; }
    public CorInfoType get_retType();
    public void set_retType(CorInfoType value);
    private CorInfoCallConv getCallConv();
    private bool hasThis();
    private bool hasExplicitThis();
    private UInt32 totalILArgs();
    private bool isVarArg();
    private bool hasTypeArg();
}
public class Internal.JitInterface.CORINFO_SIG_INST : ValueType {
    public UInt32 classInstCount;
    public CORINFO_CLASS_STRUCT_** classInst;
    public UInt32 methInstCount;
    public CORINFO_CLASS_STRUCT_** methInst;
}
public enum Internal.JitInterface.CORINFO_THIS_TRANSFORM : Enum {
    public int value__;
    public static CORINFO_THIS_TRANSFORM CORINFO_NO_THIS_TRANSFORM;
    public static CORINFO_THIS_TRANSFORM CORINFO_BOX_THIS;
    public static CORINFO_THIS_TRANSFORM CORINFO_DEREF_THIS;
}
public class Internal.JitInterface.CORINFO_VarArgInfo : ValueType {
}
public enum Internal.JitInterface.CORINFO_VIRTUALCALL_NO_CHUNK : Enum {
    public UInt32 value__;
    public static CORINFO_VIRTUALCALL_NO_CHUNK Value;
}
public enum Internal.JitInterface.CorInfoAccessAllowedHelperArgType : Enum {
    public int value__;
    public static CorInfoAccessAllowedHelperArgType CORINFO_HELPER_ARG_TYPE_Invalid;
    public static CorInfoAccessAllowedHelperArgType CORINFO_HELPER_ARG_TYPE_Field;
    public static CorInfoAccessAllowedHelperArgType CORINFO_HELPER_ARG_TYPE_Method;
    public static CorInfoAccessAllowedHelperArgType CORINFO_HELPER_ARG_TYPE_Class;
    public static CorInfoAccessAllowedHelperArgType CORINFO_HELPER_ARG_TYPE_Module;
    public static CorInfoAccessAllowedHelperArgType CORINFO_HELPER_ARG_TYPE_Const;
}
public enum Internal.JitInterface.CorInfoCallConv : Enum {
    public int value__;
    public static CorInfoCallConv CORINFO_CALLCONV_DEFAULT;
    public static CorInfoCallConv CORINFO_CALLCONV_C;
    public static CorInfoCallConv CORINFO_CALLCONV_STDCALL;
    public static CorInfoCallConv CORINFO_CALLCONV_THISCALL;
    public static CorInfoCallConv CORINFO_CALLCONV_FASTCALL;
    public static CorInfoCallConv CORINFO_CALLCONV_VARARG;
    public static CorInfoCallConv CORINFO_CALLCONV_FIELD;
    public static CorInfoCallConv CORINFO_CALLCONV_LOCAL_SIG;
    public static CorInfoCallConv CORINFO_CALLCONV_PROPERTY;
    public static CorInfoCallConv CORINFO_CALLCONV_NATIVEVARARG;
    public static CorInfoCallConv CORINFO_CALLCONV_MASK;
    public static CorInfoCallConv CORINFO_CALLCONV_GENERIC;
    public static CorInfoCallConv CORINFO_CALLCONV_HASTHIS;
    public static CorInfoCallConv CORINFO_CALLCONV_EXPLICITTHIS;
    public static CorInfoCallConv CORINFO_CALLCONV_PARAMTYPE;
}
public enum Internal.JitInterface.CorInfoCanSkipVerificationResult : Enum {
    public int value__;
    public static CorInfoCanSkipVerificationResult CORINFO_VERIFICATION_CANNOT_SKIP;
    public static CorInfoCanSkipVerificationResult CORINFO_VERIFICATION_CAN_SKIP;
    public static CorInfoCanSkipVerificationResult CORINFO_VERIFICATION_RUNTIME_CHECK;
    public static CorInfoCanSkipVerificationResult CORINFO_VERIFICATION_DONT_JIT;
}
public enum Internal.JitInterface.CorInfoClassId : Enum {
    public int value__;
    public static CorInfoClassId CLASSID_SYSTEM_OBJECT;
    public static CorInfoClassId CLASSID_TYPED_BYREF;
    public static CorInfoClassId CLASSID_TYPE_HANDLE;
    public static CorInfoClassId CLASSID_FIELD_HANDLE;
    public static CorInfoClassId CLASSID_METHOD_HANDLE;
    public static CorInfoClassId CLASSID_STRING;
    public static CorInfoClassId CLASSID_ARGUMENT_HANDLE;
    public static CorInfoClassId CLASSID_RUNTIME_TYPE;
}
public enum Internal.JitInterface.CorInfoContextFlags : Enum {
    public int value__;
    public static CorInfoContextFlags CORINFO_CONTEXTFLAGS_METHOD;
    public static CorInfoContextFlags CORINFO_CONTEXTFLAGS_CLASS;
    public static CorInfoContextFlags CORINFO_CONTEXTFLAGS_MASK;
}
[FlagsAttribute]
internal enum Internal.JitInterface.CorInfoFlag : Enum {
    public UInt32 value__;
    public static CorInfoFlag CORINFO_FLG_PROTECTED;
    public static CorInfoFlag CORINFO_FLG_STATIC;
    public static CorInfoFlag CORINFO_FLG_FINAL;
    public static CorInfoFlag CORINFO_FLG_SYNCH;
    public static CorInfoFlag CORINFO_FLG_VIRTUAL;
    public static CorInfoFlag CORINFO_FLG_NATIVE;
    public static CorInfoFlag CORINFO_FLG_INTRINSIC_TYPE;
    public static CorInfoFlag CORINFO_FLG_ABSTRACT;
    public static CorInfoFlag CORINFO_FLG_EnC;
    public static CorInfoFlag CORINFO_FLG_FORCEINLINE;
    public static CorInfoFlag CORINFO_FLG_SHAREDINST;
    public static CorInfoFlag CORINFO_FLG_DELEGATE_INVOKE;
    public static CorInfoFlag CORINFO_FLG_PINVOKE;
    public static CorInfoFlag CORINFO_FLG_SECURITYCHECK;
    public static CorInfoFlag CORINFO_FLG_NOGCCHECK;
    public static CorInfoFlag CORINFO_FLG_INTRINSIC;
    public static CorInfoFlag CORINFO_FLG_CONSTRUCTOR;
    public static CorInfoFlag CORINFO_FLG_NOSECURITYWRAP;
    public static CorInfoFlag CORINFO_FLG_DONT_INLINE;
    public static CorInfoFlag CORINFO_FLG_DONT_INLINE_CALLER;
    public static CorInfoFlag CORINFO_FLG_JIT_INTRINSIC;
    public static CorInfoFlag CORINFO_FLG_VALUECLASS;
    public static CorInfoFlag CORINFO_FLG_VAROBJSIZE;
    public static CorInfoFlag CORINFO_FLG_ARRAY;
    public static CorInfoFlag CORINFO_FLG_OVERLAPPING_FIELDS;
    public static CorInfoFlag CORINFO_FLG_INTERFACE;
    public static CorInfoFlag CORINFO_FLG_CONTEXTFUL;
    public static CorInfoFlag CORINFO_FLG_CUSTOMLAYOUT;
    public static CorInfoFlag CORINFO_FLG_CONTAINS_GC_PTR;
    public static CorInfoFlag CORINFO_FLG_DELEGATE;
    public static CorInfoFlag CORINFO_FLG_MARSHAL_BYREF;
    public static CorInfoFlag CORINFO_FLG_CONTAINS_STACK_PTR;
    public static CorInfoFlag CORINFO_FLG_VARIANCE;
    public static CorInfoFlag CORINFO_FLG_BEFOREFIELDINIT;
    public static CorInfoFlag CORINFO_FLG_GENERIC_TYPE_VARIABLE;
    public static CorInfoFlag CORINFO_FLG_UNSAFE_VALUECLASS;
}
public enum Internal.JitInterface.CorInfoGCType : Enum {
    public int value__;
    public static CorInfoGCType TYPE_GC_NONE;
    public static CorInfoGCType TYPE_GC_REF;
    public static CorInfoGCType TYPE_GC_BYREF;
    public static CorInfoGCType TYPE_GC_OTHER;
}
public enum Internal.JitInterface.CorInfoGenericHandleType : Enum {
    public int value__;
    public static CorInfoGenericHandleType CORINFO_HANDLETYPE_UNKNOWN;
    public static CorInfoGenericHandleType CORINFO_HANDLETYPE_CLASS;
    public static CorInfoGenericHandleType CORINFO_HANDLETYPE_METHOD;
    public static CorInfoGenericHandleType CORINFO_HANDLETYPE_FIELD;
}
public enum Internal.JitInterface.CorInfoHelperTailCallSpecialHandling : Enum {
    public int value__;
    public static CorInfoHelperTailCallSpecialHandling CORINFO_TAILCALL_NORMAL;
    public static CorInfoHelperTailCallSpecialHandling CORINFO_TAILCALL_STUB_DISPATCH_ARG;
}
public enum Internal.JitInterface.CorInfoHelpFunc : Enum {
    public int value__;
    public static CorInfoHelpFunc CORINFO_HELP_UNDEF;
    public static CorInfoHelpFunc CORINFO_HELP_DIV;
    public static CorInfoHelpFunc CORINFO_HELP_MOD;
    public static CorInfoHelpFunc CORINFO_HELP_UDIV;
    public static CorInfoHelpFunc CORINFO_HELP_UMOD;
    public static CorInfoHelpFunc CORINFO_HELP_LLSH;
    public static CorInfoHelpFunc CORINFO_HELP_LRSH;
    public static CorInfoHelpFunc CORINFO_HELP_LRSZ;
    public static CorInfoHelpFunc CORINFO_HELP_LMUL;
    public static CorInfoHelpFunc CORINFO_HELP_LMUL_OVF;
    public static CorInfoHelpFunc CORINFO_HELP_ULMUL_OVF;
    public static CorInfoHelpFunc CORINFO_HELP_LDIV;
    public static CorInfoHelpFunc CORINFO_HELP_LMOD;
    public static CorInfoHelpFunc CORINFO_HELP_ULDIV;
    public static CorInfoHelpFunc CORINFO_HELP_ULMOD;
    public static CorInfoHelpFunc CORINFO_HELP_LNG2DBL;
    public static CorInfoHelpFunc CORINFO_HELP_ULNG2DBL;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2INT;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2INT_OVF;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2LNG;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2LNG_OVF;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2UINT;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2UINT_OVF;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2ULNG;
    public static CorInfoHelpFunc CORINFO_HELP_DBL2ULNG_OVF;
    public static CorInfoHelpFunc CORINFO_HELP_FLTREM;
    public static CorInfoHelpFunc CORINFO_HELP_DBLREM;
    public static CorInfoHelpFunc CORINFO_HELP_FLTROUND;
    public static CorInfoHelpFunc CORINFO_HELP_DBLROUND;
    public static CorInfoHelpFunc CORINFO_HELP_NEW_CROSSCONTEXT;
    public static CorInfoHelpFunc CORINFO_HELP_NEWFAST;
    public static CorInfoHelpFunc CORINFO_HELP_NEWSFAST;
    public static CorInfoHelpFunc CORINFO_HELP_NEWSFAST_ALIGN8;
    public static CorInfoHelpFunc CORINFO_HELP_NEW_MDARR;
    public static CorInfoHelpFunc CORINFO_HELP_NEW_MDARR_NONVARARG;
    public static CorInfoHelpFunc CORINFO_HELP_NEWARR_1_DIRECT;
    public static CorInfoHelpFunc CORINFO_HELP_NEWARR_1_R2R_DIRECT;
    public static CorInfoHelpFunc CORINFO_HELP_NEWARR_1_OBJ;
    public static CorInfoHelpFunc CORINFO_HELP_NEWARR_1_VC;
    public static CorInfoHelpFunc CORINFO_HELP_NEWARR_1_ALIGN8;
    public static CorInfoHelpFunc CORINFO_HELP_STRCNS;
    public static CorInfoHelpFunc CORINFO_HELP_STRCNS_CURRENT_MODULE;
    public static CorInfoHelpFunc CORINFO_HELP_INITCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_INITINSTCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_ISINSTANCEOFINTERFACE;
    public static CorInfoHelpFunc CORINFO_HELP_ISINSTANCEOFARRAY;
    public static CorInfoHelpFunc CORINFO_HELP_ISINSTANCEOFCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_ISINSTANCEOFANY;
    public static CorInfoHelpFunc CORINFO_HELP_CHKCASTINTERFACE;
    public static CorInfoHelpFunc CORINFO_HELP_CHKCASTARRAY;
    public static CorInfoHelpFunc CORINFO_HELP_CHKCASTCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_CHKCASTANY;
    public static CorInfoHelpFunc CORINFO_HELP_CHKCASTCLASS_SPECIAL;
    public static CorInfoHelpFunc CORINFO_HELP_BOX;
    public static CorInfoHelpFunc CORINFO_HELP_BOX_NULLABLE;
    public static CorInfoHelpFunc CORINFO_HELP_UNBOX;
    public static CorInfoHelpFunc CORINFO_HELP_UNBOX_NULLABLE;
    public static CorInfoHelpFunc CORINFO_HELP_GETREFANY;
    public static CorInfoHelpFunc CORINFO_HELP_ARRADDR_ST;
    public static CorInfoHelpFunc CORINFO_HELP_LDELEMA_REF;
    public static CorInfoHelpFunc CORINFO_HELP_THROW;
    public static CorInfoHelpFunc CORINFO_HELP_RETHROW;
    public static CorInfoHelpFunc CORINFO_HELP_USER_BREAKPOINT;
    public static CorInfoHelpFunc CORINFO_HELP_RNGCHKFAIL;
    public static CorInfoHelpFunc CORINFO_HELP_OVERFLOW;
    public static CorInfoHelpFunc CORINFO_HELP_THROWDIVZERO;
    public static CorInfoHelpFunc CORINFO_HELP_THROWNULLREF;
    public static CorInfoHelpFunc CORINFO_HELP_INTERNALTHROW;
    public static CorInfoHelpFunc CORINFO_HELP_VERIFICATION;
    public static CorInfoHelpFunc CORINFO_HELP_SEC_UNMGDCODE_EXCPT;
    public static CorInfoHelpFunc CORINFO_HELP_FAIL_FAST;
    public static CorInfoHelpFunc CORINFO_HELP_METHOD_ACCESS_EXCEPTION;
    public static CorInfoHelpFunc CORINFO_HELP_FIELD_ACCESS_EXCEPTION;
    public static CorInfoHelpFunc CORINFO_HELP_CLASS_ACCESS_EXCEPTION;
    public static CorInfoHelpFunc CORINFO_HELP_ENDCATCH;
    public static CorInfoHelpFunc CORINFO_HELP_MON_ENTER;
    public static CorInfoHelpFunc CORINFO_HELP_MON_EXIT;
    public static CorInfoHelpFunc CORINFO_HELP_MON_ENTER_STATIC;
    public static CorInfoHelpFunc CORINFO_HELP_MON_EXIT_STATIC;
    public static CorInfoHelpFunc CORINFO_HELP_GETCLASSFROMMETHODPARAM;
    public static CorInfoHelpFunc CORINFO_HELP_GETSYNCFROMCLASSHANDLE;
    public static CorInfoHelpFunc CORINFO_HELP_SECURITY_PROLOG;
    public static CorInfoHelpFunc CORINFO_HELP_SECURITY_PROLOG_FRAMED;
    public static CorInfoHelpFunc CORINFO_HELP_METHOD_ACCESS_CHECK;
    public static CorInfoHelpFunc CORINFO_HELP_FIELD_ACCESS_CHECK;
    public static CorInfoHelpFunc CORINFO_HELP_CLASS_ACCESS_CHECK;
    public static CorInfoHelpFunc CORINFO_HELP_DELEGATE_SECURITY_CHECK;
    public static CorInfoHelpFunc CORINFO_HELP_VERIFICATION_RUNTIME_CHECK;
    public static CorInfoHelpFunc CORINFO_HELP_STOP_FOR_GC;
    public static CorInfoHelpFunc CORINFO_HELP_POLL_GC;
    public static CorInfoHelpFunc CORINFO_HELP_STRESS_GC;
    public static CorInfoHelpFunc CORINFO_HELP_CHECK_OBJ;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_ENSURE_NONHEAP;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_BYREF;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_STRUCT;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELD8;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELD8;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELD16;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELD16;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELD32;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELD32;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELD64;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELD64;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELDOBJ;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELDOBJ;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELDSTRUCT;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELDSTRUCT;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELDFLOAT;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELDFLOAT;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELDDOUBLE;
    public static CorInfoHelpFunc CORINFO_HELP_SETFIELDDOUBLE;
    public static CorInfoHelpFunc CORINFO_HELP_GETFIELDADDR;
    public static CorInfoHelpFunc CORINFO_HELP_GETSTATICFIELDADDR_CONTEXT;
    public static CorInfoHelpFunc CORINFO_HELP_GETSTATICFIELDADDR_TLS;
    public static CorInfoHelpFunc CORINFO_HELP_GETGENERICS_GCSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETGENERICS_NONGCSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_GCSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_GCSTATIC_BASE_NOCTOR;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE_NOCTOR;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_GCSTATIC_BASE_DYNAMICCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_NONGCSTATIC_BASE_DYNAMICCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_CLASSINIT_SHARED_DYNAMICCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_GETGENERICS_GCTHREADSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETGENERICS_NONGCTHREADSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_GCTHREADSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_NONGCTHREADSTATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_GCTHREADSTATIC_BASE_NOCTOR;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_NONGCTHREADSTATIC_BASE_NOCTOR;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_GCTHREADSTATIC_BASE_DYNAMICCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_GETSHARED_NONGCTHREADSTATIC_BASE_DYNAMICCLASS;
    public static CorInfoHelpFunc CORINFO_HELP_DBG_IS_JUST_MY_CODE;
    public static CorInfoHelpFunc CORINFO_HELP_PROF_FCN_ENTER;
    public static CorInfoHelpFunc CORINFO_HELP_PROF_FCN_LEAVE;
    public static CorInfoHelpFunc CORINFO_HELP_PROF_FCN_TAILCALL;
    public static CorInfoHelpFunc CORINFO_HELP_BBT_FCN_ENTER;
    public static CorInfoHelpFunc CORINFO_HELP_PINVOKE_CALLI;
    public static CorInfoHelpFunc CORINFO_HELP_TAILCALL;
    public static CorInfoHelpFunc CORINFO_HELP_GETCURRENTMANAGEDTHREADID;
    public static CorInfoHelpFunc CORINFO_HELP_INIT_PINVOKE_FRAME;
    public static CorInfoHelpFunc CORINFO_HELP_MEMSET;
    public static CorInfoHelpFunc CORINFO_HELP_MEMCPY;
    public static CorInfoHelpFunc CORINFO_HELP_RUNTIMEHANDLE_METHOD;
    public static CorInfoHelpFunc CORINFO_HELP_RUNTIMEHANDLE_METHOD_LOG;
    public static CorInfoHelpFunc CORINFO_HELP_RUNTIMEHANDLE_CLASS;
    public static CorInfoHelpFunc CORINFO_HELP_RUNTIMEHANDLE_CLASS_LOG;
    public static CorInfoHelpFunc CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPEHANDLE_OBSOLETE;
    public static CorInfoHelpFunc CORINFO_HELP_METHODDESC_TO_RUNTIMEMETHODHANDLE_OBSOLETE;
    public static CorInfoHelpFunc CORINFO_HELP_FIELDDESC_TO_RUNTIMEFIELDHANDLE_OBSOLETE;
    public static CorInfoHelpFunc CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE;
    public static CorInfoHelpFunc CORINFO_HELP_TYPEHANDLE_TO_RUNTIMETYPE_MAYBENULL;
    public static CorInfoHelpFunc CORINFO_HELP_METHODDESC_TO_STUBRUNTIMEMETHOD;
    public static CorInfoHelpFunc CORINFO_HELP_FIELDDESC_TO_STUBRUNTIMEFIELD;
    public static CorInfoHelpFunc CORINFO_HELP_VIRTUAL_FUNC_PTR;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_NEW;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_NEWARR_1;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_ISINSTANCEOF;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_CHKCAST;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_STATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_VIRTUAL_FUNC_PTR;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_GENERIC_HANDLE;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_DELEGATE_CTOR;
    public static CorInfoHelpFunc CORINFO_HELP_READYTORUN_GENERIC_STATIC_BASE;
    public static CorInfoHelpFunc CORINFO_HELP_EE_PRESTUB;
    public static CorInfoHelpFunc CORINFO_HELP_EE_PRECODE_FIXUP;
    public static CorInfoHelpFunc CORINFO_HELP_EE_PINVOKE_FIXUP;
    public static CorInfoHelpFunc CORINFO_HELP_EE_VSD_FIXUP;
    public static CorInfoHelpFunc CORINFO_HELP_EE_EXTERNAL_FIXUP;
    public static CorInfoHelpFunc CORINFO_HELP_EE_VTABLE_FIXUP;
    public static CorInfoHelpFunc CORINFO_HELP_EE_REMOTING_THUNK;
    public static CorInfoHelpFunc CORINFO_HELP_EE_PERSONALITY_ROUTINE;
    public static CorInfoHelpFunc CORINFO_HELP_EE_PERSONALITY_ROUTINE_FILTER_FUNCLET;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_EAX;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_EBX;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_ECX;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_ESI;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_EDI;
    public static CorInfoHelpFunc CORINFO_HELP_ASSIGN_REF_EBP;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF_EAX;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF_EBX;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF_ECX;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF_ESI;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF_EDI;
    public static CorInfoHelpFunc CORINFO_HELP_CHECKED_ASSIGN_REF_EBP;
    public static CorInfoHelpFunc CORINFO_HELP_LOOP_CLONE_CHOICE_ADDR;
    public static CorInfoHelpFunc CORINFO_HELP_DEBUG_LOG_LOOP_CLONING;
    public static CorInfoHelpFunc CORINFO_HELP_THROW_ARGUMENTEXCEPTION;
    public static CorInfoHelpFunc CORINFO_HELP_THROW_ARGUMENTOUTOFRANGEEXCEPTION;
    public static CorInfoHelpFunc CORINFO_HELP_THROW_PLATFORM_NOT_SUPPORTED;
    public static CorInfoHelpFunc CORINFO_HELP_THROW_TYPE_NOT_SUPPORTED;
    public static CorInfoHelpFunc CORINFO_HELP_JIT_PINVOKE_BEGIN;
    public static CorInfoHelpFunc CORINFO_HELP_JIT_PINVOKE_END;
    public static CorInfoHelpFunc CORINFO_HELP_JIT_REVERSE_PINVOKE_ENTER;
    public static CorInfoHelpFunc CORINFO_HELP_JIT_REVERSE_PINVOKE_EXIT;
    public static CorInfoHelpFunc CORINFO_HELP_GVMLOOKUP_FOR_SLOT;
    public static CorInfoHelpFunc CORINFO_HELP_COUNT;
}
internal class Internal.JitInterface.CorInfoImpl : object {
    private IntPtr _jit;
    private IntPtr _unmanagedCallbacks;
    private object _keepAlive;
    private ExceptionDispatchInfo _lastException;
    private Compilation _compilation;
    private JitConfigProvider _jitConfig;
    private IMethodCodeNode _methodCodeNode;
    private CORINFO_MODULE_STRUCT_* _methodScope;
    private bool _isFallbackBodyCompilation;
    private Dictionary`2<object, GCHandle> _pins;
    private List`1<IntPtr> _nativeExceptions;
    private Dictionary`2<object, IntPtr> _objectToHandle;
    private List`1<object> _handleToObject;
    private static int handleMultipler;
    private static int handleBase;
    private SimdHelper _simdHelper;
    private Dictionary`2<CorInfoHelpFunc, ISymbolNode> _helperCache;
    private Byte[] _code;
    private Byte[] _coldCode;
    private Byte[] _roData;
    private BlobNode _roDataBlob;
    private int _numFrameInfos;
    private int _usedFrameInfos;
    private FrameInfo[] _frameInfos;
    private Byte[] _gcInfo;
    private CORINFO_EH_CLAUSE[] _ehClauses;
    private Dictionary`2<int, SequencePoint> _sequencePoints;
    private Dictionary`2<UInt32, ILLocalVariable> _localSlotToInfoMap;
    private Dictionary`2<UInt32, string> _parameterIndexToNameMap;
    private DebugLocInfo[] _debugLocInfos;
    private DebugVarInfo[] _debugVarInfos;
    private TypeDesc[] _variableToTypeDesc;
    private ArrayBuilder`1<Relocation> _relocs;
    private static IntrinsicHashtable s_IntrinsicHashtable;
    public TextWriter Log { get; }
    private MethodDesc MethodBeingCompiled { get; }
    private int PointerSize { get; }
    private UInt32 SizeOfPInvokeTransitionFrame { get; }
    public CorInfoImpl(Compilation compilation, JitConfigProvider jitConfig);
    private static CorInfoImpl();
    private static UInt32 _getMethodAttribs(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn);
    private static void _setMethodAttribs(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, CorInfoMethodRuntimeFlags attribs);
    private static void _getMethodSig(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, CORINFO_SIG_INFO* sig, CORINFO_CLASS_STRUCT_* memberParent);
    private static bool _getMethodInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, CORINFO_METHOD_INFO& info);
    private static CorInfoInline _canInline(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* callerHnd, CORINFO_METHOD_STRUCT_* calleeHnd, UInt32& pRestrictions);
    private static void _reportInliningDecision(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* inlinerHnd, CORINFO_METHOD_STRUCT_* inlineeHnd, CorInfoInline inlineResult, Byte* reason);
    private static bool _canTailCall(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* callerHnd, CORINFO_METHOD_STRUCT_* declaredCalleeHnd, CORINFO_METHOD_STRUCT_* exactCalleeHnd, bool fIsTailPrefix);
    private static void _reportTailCallDecision(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* callerHnd, CORINFO_METHOD_STRUCT_* calleeHnd, bool fIsTailPrefix, CorInfoTailCall tailCallResult, Byte* reason);
    private static void _getEHinfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, UInt32 EHnumber, CORINFO_EH_CLAUSE& clause);
    private static CORINFO_CLASS_STRUCT_* _getMethodClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method);
    private static CORINFO_MODULE_STRUCT_* _getMethodModule(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method);
    private static void _getMethodVTableOffset(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, UInt32& offsetOfIndirection, UInt32& offsetAfterIndirection, Boolean& isRelative);
    private static CORINFO_METHOD_STRUCT_* _resolveVirtualMethod(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* virtualMethod, CORINFO_CLASS_STRUCT_* implementingClass, CORINFO_CONTEXT_STRUCT* ownerType);
    private static CORINFO_METHOD_STRUCT_* _getUnboxedEntry(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, Byte* requiresInstMethodTableArg);
    private static CORINFO_CLASS_STRUCT_* _getDefaultEqualityComparerClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* elemType);
    private static void _expandRawHandleIntrinsic(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_GENERICHANDLE_RESULT& pResult);
    private static CorInfoIntrinsics _getIntrinsicID(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, Byte* pMustExpand);
    private static bool _isInSIMDModule(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* classHnd);
    private static CorInfoUnmanagedCallConv _getUnmanagedCallConv(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method);
    private static bool _pInvokeMarshalingRequired(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, CORINFO_SIG_INFO* callSiteSig);
    private static bool _satisfiesMethodConstraints(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* parent, CORINFO_METHOD_STRUCT_* method);
    private static bool _isCompatibleDelegate(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* objCls, CORINFO_CLASS_STRUCT_* methodParentCls, CORINFO_METHOD_STRUCT_* method, CORINFO_CLASS_STRUCT_* delegateCls, Boolean& pfIsOpenDelegate);
    private static CorInfoInstantiationVerification _isInstantiationOfVerifiedGeneric(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method);
    private static void _initConstraintsForVerification(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, Boolean& pfHasCircularClassConstraints, Boolean& pfHasCircularMethodConstraint);
    private static CorInfoCanSkipVerificationResult _canSkipMethodVerification(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftnHandle);
    private static void _methodMustBeLoadedBeforeCodeIsRun(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method);
    private static CORINFO_METHOD_STRUCT_* _mapMethodDeclToMethodImpl(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method);
    private static void _getGSCookie(IntPtr thisHandle, IntPtr* ppException, IntPtr* pCookieVal, IntPtr** ppCookieVal);
    private static void _resolveToken(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private static void _tryResolveToken(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private static void _findSig(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* module, UInt32 sigTOK, CORINFO_CONTEXT_STRUCT* context, CORINFO_SIG_INFO* sig);
    private static void _findCallSiteSig(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* module, UInt32 methTOK, CORINFO_CONTEXT_STRUCT* context, CORINFO_SIG_INFO* sig);
    private static CORINFO_CLASS_STRUCT_* _getTokenTypeAsHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private static CorInfoCanSkipVerificationResult _canSkipVerification(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* module);
    private static bool _isValidToken(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* module, UInt32 metaTOK);
    private static bool _isValidStringRef(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* module, UInt32 metaTOK);
    private static bool _shouldEnforceCallvirtRestriction(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* scope);
    private static CorInfoType _asCorInfoType(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static Byte* _getClassName(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static Byte* _getClassNameFromMetadata(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls, Byte** namespaceName);
    private static CORINFO_CLASS_STRUCT_* _getTypeInstantiationArgument(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls, UInt32 index);
    private static int _appendClassName(IntPtr thisHandle, IntPtr* ppException, Int16** ppBuf, Int32& pnBufLen, CORINFO_CLASS_STRUCT_* cls, bool fNamespace, bool fFullInst, bool fAssembly);
    private static bool _isValueClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static bool _canInlineTypeCheckWithObjectVTable(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static UInt32 _getClassAttribs(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static bool _isStructRequiringStackAllocRetBuf(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CORINFO_MODULE_STRUCT_* _getClassModule(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CORINFO_ASSEMBLY_STRUCT_* _getModuleAssembly(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* mod);
    private static Byte* _getAssemblyName(IntPtr thisHandle, IntPtr* ppException, CORINFO_ASSEMBLY_STRUCT_* assem);
    private static Void* _LongLifetimeMalloc(IntPtr thisHandle, IntPtr* ppException, UIntPtr sz);
    private static void _LongLifetimeFree(IntPtr thisHandle, IntPtr* ppException, Void* obj);
    private static Byte* _getClassModuleIdForStatics(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls, CORINFO_MODULE_STRUCT_** pModule, Void** ppIndirection);
    private static UInt32 _getClassSize(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static UInt32 _getClassAlignmentRequirement(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls, bool fDoubleAlignHint);
    private static UInt32 _getClassGClayout(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls, Byte* gcPtrs);
    private static UInt32 _getClassNumInstanceFields(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CORINFO_FIELD_STRUCT_* _getFieldInClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* clsHnd, int num);
    private static bool _checkMethodModifier(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* hMethod, Byte* modifier, bool fOptional);
    private static CorInfoHelpFunc _getNewHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle);
    private static CorInfoHelpFunc _getNewArrHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* arrayCls);
    private static CorInfoHelpFunc _getCastingHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, bool fThrowing);
    private static CorInfoHelpFunc _getSharedCCtorHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* clsHnd);
    private static CorInfoHelpFunc _getSecurityPrologHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn);
    private static CORINFO_CLASS_STRUCT_* _getTypeForBox(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CorInfoHelpFunc _getBoxHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CorInfoHelpFunc _getUnBoxHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static bool _getReadyToRunHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_LOOKUP_KIND& pGenericLookupKind, CorInfoHelpFunc id, CORINFO_CONST_LOOKUP& pLookup);
    private static void _getReadyToRunDelegateCtorHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pTargetMethod, CORINFO_CLASS_STRUCT_* delegateType, CORINFO_LOOKUP& pLookup);
    private static Byte* _getHelperName(IntPtr thisHandle, IntPtr* ppException, CorInfoHelpFunc helpFunc);
    private static CorInfoInitClassResult _initClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field, CORINFO_METHOD_STRUCT_* method, CORINFO_CONTEXT_STRUCT* context, bool speculative);
    private static void _classMustBeLoadedBeforeCodeIsRun(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CORINFO_CLASS_STRUCT_* _getBuiltinClass(IntPtr thisHandle, IntPtr* ppException, CorInfoClassId classId);
    private static CorInfoType _getTypeForPrimitiveValueClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CorInfoType _getTypeForPrimitiveNumericClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static bool _canCast(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* child, CORINFO_CLASS_STRUCT_* parent);
    private static bool _areTypesEquivalent(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls1, CORINFO_CLASS_STRUCT_* cls2);
    private static TypeCompareState _compareTypesForCast(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* fromClass, CORINFO_CLASS_STRUCT_* toClass);
    private static TypeCompareState _compareTypesForEquality(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls1, CORINFO_CLASS_STRUCT_* cls2);
    private static CORINFO_CLASS_STRUCT_* _mergeClasses(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls1, CORINFO_CLASS_STRUCT_* cls2);
    private static CORINFO_CLASS_STRUCT_* _getParentType(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static CorInfoType _getChildType(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* clsHnd, CORINFO_CLASS_STRUCT_*& clsRet);
    private static bool _satisfiesClassConstraints(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static bool _isSDArray(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static UInt32 _getArrayRank(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static Void* _getArrayInitializationData(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field, UInt32 size);
    private static CorInfoIsAccessAllowedResult _canAccessClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_HELPER_DESC& pAccessHelper);
    private static Byte* _getFieldName(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* ftn, Byte** moduleName);
    private static CORINFO_CLASS_STRUCT_* _getFieldClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field);
    private static CorInfoType _getFieldType(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field, CORINFO_CLASS_STRUCT_*& structType, CORINFO_CLASS_STRUCT_* memberParent);
    private static UInt32 _getFieldOffset(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field);
    private static bool _isWriteBarrierHelperRequired(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field);
    private static void _getFieldInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_ACCESS_FLAGS flags, CORINFO_FIELD_INFO& pResult);
    private static bool _isFieldStatic(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* fldHnd);
    private static void _getBoundaries(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, UInt32& cILOffsets, UInt32*& pILOffsets, BoundaryTypes* implictBoundaries);
    private static void _setBoundaries(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, UInt32 cMap, OffsetMapping* pMap);
    private static void _getVars(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, UInt32& cVars, ILVarInfo** vars, Boolean& extendOthers);
    private static void _setVars(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, UInt32 cVars, NativeVarInfo* vars);
    private static Void* _allocateArray(IntPtr thisHandle, IntPtr* ppException, UInt32 cBytes);
    private static void _freeArray(IntPtr thisHandle, IntPtr* ppException, Void* array);
    private static CORINFO_ARG_LIST_STRUCT_* _getArgNext(IntPtr thisHandle, IntPtr* ppException, CORINFO_ARG_LIST_STRUCT_* args);
    private static CorInfoTypeWithMod _getArgType(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* sig, CORINFO_ARG_LIST_STRUCT_* args, CORINFO_CLASS_STRUCT_*& vcTypeRet);
    private static CORINFO_CLASS_STRUCT_* _getArgClass(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* sig, CORINFO_ARG_LIST_STRUCT_* args);
    private static CorInfoType _getHFAType(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* hClass);
    private static HRESULT _GetErrorHRESULT(IntPtr thisHandle, IntPtr* ppException, _EXCEPTION_POINTERS* pExceptionPointers);
    private static UInt32 _GetErrorMessage(IntPtr thisHandle, IntPtr* ppException, Int16* buffer, UInt32 bufferLength);
    private static int _FilterException(IntPtr thisHandle, IntPtr* ppException, _EXCEPTION_POINTERS* pExceptionPointers);
    private static void _HandleException(IntPtr thisHandle, IntPtr* ppException, _EXCEPTION_POINTERS* pExceptionPointers);
    private static void _ThrowExceptionForJitResult(IntPtr thisHandle, IntPtr* ppException, HRESULT result);
    private static void _ThrowExceptionForHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_HELPER_DESC& throwHelper);
    private static bool _runWithErrorTrap(IntPtr thisHandle, IntPtr* ppException, Void* function, Void* parameter);
    private static void _getEEInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_EE_INFO& pEEInfoOut);
    private static string _getJitTimeLogFilename(IntPtr thisHandle, IntPtr* ppException);
    private static mdToken _getMethodDefFromMethod(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* hMethod);
    private static Byte* _getMethodName(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, Byte** moduleName);
    private static Byte* _getMethodNameFromMetadata(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, Byte** className, Byte** namespaceName);
    private static UInt32 _getMethodHash(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn);
    private static Byte* _findNameOfToken(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* moduleHandle, mdToken token, Byte* szFQName, UIntPtr FQNameCapacity);
    private static bool _getSystemVAmd64PassStructInRegisterDescriptor(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* structHnd, SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR* structPassInRegDescPtr);
    private static UInt32 _getThreadTLSIndex(IntPtr thisHandle, IntPtr* ppException, Void*& ppIndirection);
    private static Void* _getInlinedCallFrameVptr(IntPtr thisHandle, IntPtr* ppException, Void*& ppIndirection);
    private static Int32* _getAddrOfCaptureThreadGlobal(IntPtr thisHandle, IntPtr* ppException, Void*& ppIndirection);
    private static Void* _getHelperFtn(IntPtr thisHandle, IntPtr* ppException, CorInfoHelpFunc ftnNum, Void*& ppIndirection);
    private static void _getFunctionEntryPoint(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, CORINFO_CONST_LOOKUP& pResult, CORINFO_ACCESS_FLAGS accessFlags);
    private static void _getFunctionFixedEntryPoint(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, CORINFO_CONST_LOOKUP& pResult);
    private static Void* _getMethodSync(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftn, Void*& ppIndirection);
    private static CorInfoHelpFunc _getLazyStringLiteralHelper(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* handle);
    private static CORINFO_MODULE_STRUCT_* _embedModuleHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* handle, Void*& ppIndirection);
    private static CORINFO_CLASS_STRUCT_* _embedClassHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* handle, Void*& ppIndirection);
    private static CORINFO_METHOD_STRUCT_* _embedMethodHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* handle, Void*& ppIndirection);
    private static CORINFO_FIELD_STRUCT_* _embedFieldHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* handle, Void*& ppIndirection);
    private static void _embedGenericHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, bool fEmbedParent, CORINFO_GENERICHANDLE_RESULT& pResult);
    private static void _getLocationOfThisType(IntPtr thisHandle, IntPtr* ppException, CORINFO_LOOKUP_KIND& _return, CORINFO_METHOD_STRUCT_* context);
    private static Void* _getPInvokeUnmanagedTarget(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, Void*& ppIndirection);
    private static Void* _getAddressOfPInvokeFixup(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, Void*& ppIndirection);
    private static void _getAddressOfPInvokeTarget(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, CORINFO_CONST_LOOKUP& pLookup);
    private static Void* _GetCookieForPInvokeCalliSig(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* szMetaSig, Void*& ppIndirection);
    private static bool _canGetCookieForPInvokeCalliSig(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* szMetaSig);
    private static CORINFO_JUST_MY_CODE_HANDLE_* _getJustMyCodeHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* method, CORINFO_JUST_MY_CODE_HANDLE_*& ppIndirection);
    private static void _GetProfilingHandle(IntPtr thisHandle, IntPtr* ppException, Boolean& pbHookFunction, Void*& pProfilerHandle, Boolean& pbIndirectedHandles);
    private static void _getCallInfo(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult);
    private static bool _canAccessFamily(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* hCaller, CORINFO_CLASS_STRUCT_* hInstanceType);
    private static bool _isRIDClassDomainID(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls);
    private static UInt32 _getClassDomainID(IntPtr thisHandle, IntPtr* ppException, CORINFO_CLASS_STRUCT_* cls, Void*& ppIndirection);
    private static Void* _getFieldAddress(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field, Void*& ppIndirection);
    private static IntPtr _getVarArgsHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* pSig, Void*& ppIndirection);
    private static bool _canGetVarArgsHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* pSig);
    private static InfoAccessType _constructStringLiteral(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* module, mdToken metaTok, Void*& ppValue);
    private static InfoAccessType _emptyStringLiteral(IntPtr thisHandle, IntPtr* ppException, Void*& ppValue);
    private static UInt32 _getFieldThreadLocalStoreID(IntPtr thisHandle, IntPtr* ppException, CORINFO_FIELD_STRUCT_* field, Void*& ppIndirection);
    private static void _setOverride(IntPtr thisHandle, IntPtr* ppException, IntPtr pOverride, CORINFO_METHOD_STRUCT_* currentMethod);
    private static void _addActiveDependency(IntPtr thisHandle, IntPtr* ppException, CORINFO_MODULE_STRUCT_* moduleFrom, CORINFO_MODULE_STRUCT_* moduleTo);
    private static CORINFO_METHOD_STRUCT_* _GetDelegateCtor(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* methHnd, CORINFO_CLASS_STRUCT_* clsHnd, CORINFO_METHOD_STRUCT_* targetMethodHnd, DelegateCtorArgs& pCtorData);
    private static void _MethodCompileComplete(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* methHnd);
    private static Void* _getTailCallCopyArgsThunk(IntPtr thisHandle, IntPtr* ppException, CORINFO_SIG_INFO* pSig, CorInfoHelperTailCallSpecialHandling flags);
    private static bool _convertPInvokeCalliToCall(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN& pResolvedToken, bool mustConvert);
    private static Void* _getMemoryManager(IntPtr thisHandle, IntPtr* ppException);
    private static void _allocMem(IntPtr thisHandle, IntPtr* ppException, UInt32 hotCodeSize, UInt32 coldCodeSize, UInt32 roDataSize, UInt32 xcptnsCount, CorJitAllocMemFlag flag, Void*& hotCodeBlock, Void*& coldCodeBlock, Void*& roDataBlock);
    private static void _reserveUnwindInfo(IntPtr thisHandle, IntPtr* ppException, bool isFunclet, bool isColdCode, UInt32 unwindSize);
    private static void _allocUnwindInfo(IntPtr thisHandle, IntPtr* ppException, Byte* pHotCode, Byte* pColdCode, UInt32 startOffset, UInt32 endOffset, UInt32 unwindSize, Byte* pUnwindBlock, CorJitFuncKind funcKind);
    private static Void* _allocGCInfo(IntPtr thisHandle, IntPtr* ppException, UIntPtr size);
    private static void _yieldExecution(IntPtr thisHandle, IntPtr* ppException);
    private static void _setEHcount(IntPtr thisHandle, IntPtr* ppException, UInt32 cEH);
    private static void _setEHinfo(IntPtr thisHandle, IntPtr* ppException, UInt32 EHnumber, CORINFO_EH_CLAUSE& clause);
    private static bool _logMsg(IntPtr thisHandle, IntPtr* ppException, UInt32 level, Byte* fmt, IntPtr args);
    private static int _doAssert(IntPtr thisHandle, IntPtr* ppException, Byte* szFile, int iLine, Byte* szExpr);
    private static void _reportFatalError(IntPtr thisHandle, IntPtr* ppException, CorJitResult result);
    private static HRESULT _allocBBProfileBuffer(IntPtr thisHandle, IntPtr* ppException, UInt32 count, ProfileBuffer*& profileBuffer);
    private static HRESULT _getBBProfileData(IntPtr thisHandle, IntPtr* ppException, CORINFO_METHOD_STRUCT_* ftnHnd, UInt32& count, ProfileBuffer*& profileBuffer, UInt32& numRuns);
    private static void _recordCallSite(IntPtr thisHandle, IntPtr* ppException, UInt32 instrOffset, CORINFO_SIG_INFO* callSig, CORINFO_METHOD_STRUCT_* methodHandle);
    private static void _recordRelocation(IntPtr thisHandle, IntPtr* ppException, Void* location, Void* target, ushort fRelocType, ushort slotNum, int addlDelta);
    private static ushort _getRelocTypeHint(IntPtr thisHandle, IntPtr* ppException, Void* target);
    private static void _getModuleNativeEntryPointRange(IntPtr thisHandle, IntPtr* ppException, Void*& pStart, Void*& pEnd);
    private static UInt32 _getExpectedTargetArchitecture(IntPtr thisHandle, IntPtr* ppException);
    private static UInt32 _getJitFlags(IntPtr thisHandle, IntPtr* ppException, CORJIT_FLAGS& flags, UInt32 sizeInBytes);
    private static IntPtr GetUnmanagedCallbacks(Object& keepAlive);
    private static IntPtr jitStartup(IntPtr host);
    private static IntPtr getJit();
    private static IntPtr GetJitHost(IntPtr configProvider);
    private static CorInfoImpl GetThis(IntPtr thisHandle);
    private static CorJitResult JitCompileMethod(IntPtr& exception, IntPtr jit, IntPtr thisHandle, IntPtr callbacks, CORINFO_METHOD_INFO& info, UInt32 flags, IntPtr& nativeEntry, UInt32& codeSize);
    private static UInt32 GetMaxIntrinsicSIMDVectorLength(IntPtr jit, CORJIT_FLAGS* flags);
    private static IntPtr AllocException(string message, int messageLength);
    private IntPtr AllocException(Exception ex);
    private static void FreeException(IntPtr obj);
    private static Char* GetExceptionMessage(IntPtr obj);
    public TextWriter get_Log();
    public void CompileMethod(IMethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL);
    private void SetDebugInformation(IMethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL);
    private ObjectData EncodeEHInfo();
    private void PublishCode();
    private MethodDesc get_MethodBeingCompiled();
    private int get_PointerSize();
    private IntPtr GetPin(object obj);
    private void CompileMethodCleanup();
    private IntPtr ObjectToHandle(object obj);
    private object HandleToObject(IntPtr handle);
    private MethodDesc HandleToObject(CORINFO_METHOD_STRUCT_* method);
    private CORINFO_METHOD_STRUCT_* ObjectToHandle(MethodDesc method);
    private TypeDesc HandleToObject(CORINFO_CLASS_STRUCT_* type);
    private CORINFO_CLASS_STRUCT_* ObjectToHandle(TypeDesc type);
    private FieldDesc HandleToObject(CORINFO_FIELD_STRUCT_* field);
    private CORINFO_FIELD_STRUCT_* ObjectToHandle(FieldDesc field);
    private MethodIL Get_CORINFO_METHOD_INFO(MethodDesc method, MethodIL methodIL, CORINFO_METHOD_INFO& methodInfo);
    private void Get_CORINFO_SIG_INFO(MethodDesc method, CORINFO_SIG_INFO& sig, bool isFatFunctionPointer);
    private void Get_CORINFO_SIG_INFO(MethodSignature signature, CORINFO_SIG_INFO& sig);
    private void Get_CORINFO_SIG_INFO(LocalVariableDefinition[] locals, CORINFO_SIG_INFO& sig);
    private CorInfoType asCorInfoType(TypeDesc type);
    private CorInfoType asCorInfoType(TypeDesc type, CORINFO_CLASS_STRUCT_*& structType);
    private CORINFO_CONTEXT_STRUCT* contextFromMethod(MethodDesc method);
    private CORINFO_CONTEXT_STRUCT* contextFromType(TypeDesc type);
    private MethodDesc methodFromContext(CORINFO_CONTEXT_STRUCT* contextStruct);
    private TypeDesc typeFromContext(CORINFO_CONTEXT_STRUCT* contextStruct);
    private UInt32 getMethodAttribsInternal(MethodDesc method);
    private UInt32 getMethodAttribs(CORINFO_METHOD_STRUCT_* ftn);
    private void setMethodAttribs(CORINFO_METHOD_STRUCT_* ftn, CorInfoMethodRuntimeFlags attribs);
    private void getMethodSig(CORINFO_METHOD_STRUCT_* ftn, CORINFO_SIG_INFO* sig, CORINFO_CLASS_STRUCT_* memberParent);
    private bool getMethodInfo(CORINFO_METHOD_STRUCT_* ftn, CORINFO_METHOD_INFO& info);
    private CorInfoInline canInline(CORINFO_METHOD_STRUCT_* callerHnd, CORINFO_METHOD_STRUCT_* calleeHnd, UInt32& pRestrictions);
    private void reportInliningDecision(CORINFO_METHOD_STRUCT_* inlinerHnd, CORINFO_METHOD_STRUCT_* inlineeHnd, CorInfoInline inlineResult, Byte* reason);
    private bool canTailCall(CORINFO_METHOD_STRUCT_* callerHnd, CORINFO_METHOD_STRUCT_* declaredCalleeHnd, CORINFO_METHOD_STRUCT_* exactCalleeHnd, bool fIsTailPrefix);
    private void reportTailCallDecision(CORINFO_METHOD_STRUCT_* callerHnd, CORINFO_METHOD_STRUCT_* calleeHnd, bool fIsTailPrefix, CorInfoTailCall tailCallResult, Byte* reason);
    private void getEHinfo(CORINFO_METHOD_STRUCT_* ftn, UInt32 EHnumber, CORINFO_EH_CLAUSE& clause);
    private CORINFO_CLASS_STRUCT_* getMethodClass(CORINFO_METHOD_STRUCT_* method);
    private CORINFO_MODULE_STRUCT_* getMethodModule(CORINFO_METHOD_STRUCT_* method);
    private void getMethodVTableOffset(CORINFO_METHOD_STRUCT_* method, UInt32& offsetOfIndirection, UInt32& offsetAfterIndirection, Boolean& isRelative);
    private CORINFO_METHOD_STRUCT_* resolveVirtualMethod(CORINFO_METHOD_STRUCT_* baseMethod, CORINFO_CLASS_STRUCT_* derivedClass, CORINFO_CONTEXT_STRUCT* ownerType);
    private void ComputeLookup(CORINFO_CONTEXT_STRUCT* pContextMethod, object entity, ReadyToRunHelperId helperId, CORINFO_LOOKUP& lookup);
    private CORINFO_METHOD_STRUCT_* getUnboxedEntry(CORINFO_METHOD_STRUCT_* ftn, Byte* requiresInstMethodTableArg);
    private CORINFO_CLASS_STRUCT_* getDefaultEqualityComparerClass(CORINFO_CLASS_STRUCT_* elemType);
    private void expandRawHandleIntrinsic(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_GENERICHANDLE_RESULT& pResult);
    private bool isInSIMDModule(CORINFO_CLASS_STRUCT_* classHnd);
    private CorInfoUnmanagedCallConv getUnmanagedCallConv(CORINFO_METHOD_STRUCT_* method);
    private bool IsPInvokeStubRequired(MethodDesc method);
    private bool pInvokeMarshalingRequired(CORINFO_METHOD_STRUCT_* handle, CORINFO_SIG_INFO* callSiteSig);
    private bool satisfiesMethodConstraints(CORINFO_CLASS_STRUCT_* parent, CORINFO_METHOD_STRUCT_* method);
    private bool isCompatibleDelegate(CORINFO_CLASS_STRUCT_* objCls, CORINFO_CLASS_STRUCT_* methodParentCls, CORINFO_METHOD_STRUCT_* method, CORINFO_CLASS_STRUCT_* delegateCls, Boolean& pfIsOpenDelegate);
    private CorInfoInstantiationVerification isInstantiationOfVerifiedGeneric(CORINFO_METHOD_STRUCT_* method);
    private void initConstraintsForVerification(CORINFO_METHOD_STRUCT_* method, Boolean& pfHasCircularClassConstraints, Boolean& pfHasCircularMethodConstraint);
    private CorInfoCanSkipVerificationResult canSkipMethodVerification(CORINFO_METHOD_STRUCT_* ftnHandle);
    private void methodMustBeLoadedBeforeCodeIsRun(CORINFO_METHOD_STRUCT_* method);
    private CORINFO_METHOD_STRUCT_* mapMethodDeclToMethodImpl(CORINFO_METHOD_STRUCT_* method);
    private void getGSCookie(IntPtr* pCookieVal, IntPtr** ppCookieVal);
    private object GetRuntimeDeterminedObjectForToken(CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private void resolveToken(CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private bool tryResolveToken(CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private void findSig(CORINFO_MODULE_STRUCT_* module, UInt32 sigTOK, CORINFO_CONTEXT_STRUCT* context, CORINFO_SIG_INFO* sig);
    private void findCallSiteSig(CORINFO_MODULE_STRUCT_* module, UInt32 methTOK, CORINFO_CONTEXT_STRUCT* context, CORINFO_SIG_INFO* sig);
    private CORINFO_CLASS_STRUCT_* getTokenTypeAsHandle(CORINFO_RESOLVED_TOKEN& pResolvedToken);
    private CorInfoCanSkipVerificationResult canSkipVerification(CORINFO_MODULE_STRUCT_* module);
    private bool isValidToken(CORINFO_MODULE_STRUCT_* module, UInt32 metaTOK);
    private bool isValidStringRef(CORINFO_MODULE_STRUCT_* module, UInt32 metaTOK);
    private bool shouldEnforceCallvirtRestriction(CORINFO_MODULE_STRUCT_* scope);
    private CorInfoType asCorInfoType(CORINFO_CLASS_STRUCT_* cls);
    private Byte* getClassName(CORINFO_CLASS_STRUCT_* cls);
    private Byte* getClassNameFromMetadata(CORINFO_CLASS_STRUCT_* cls, Byte** namespaceName);
    private CORINFO_CLASS_STRUCT_* getTypeInstantiationArgument(CORINFO_CLASS_STRUCT_* cls, UInt32 index);
    private int appendClassName(Int16** ppBuf, Int32& pnBufLen, CORINFO_CLASS_STRUCT_* cls, bool fNamespace, bool fFullInst, bool fAssembly);
    private bool isValueClass(CORINFO_CLASS_STRUCT_* cls);
    private bool canInlineTypeCheckWithObjectVTable(CORINFO_CLASS_STRUCT_* cls);
    private UInt32 getClassAttribs(CORINFO_CLASS_STRUCT_* cls);
    private UInt32 getClassAttribsInternal(TypeDesc type);
    private bool isStructRequiringStackAllocRetBuf(CORINFO_CLASS_STRUCT_* cls);
    private CORINFO_MODULE_STRUCT_* getClassModule(CORINFO_CLASS_STRUCT_* cls);
    private CORINFO_ASSEMBLY_STRUCT_* getModuleAssembly(CORINFO_MODULE_STRUCT_* mod);
    private Byte* getAssemblyName(CORINFO_ASSEMBLY_STRUCT_* assem);
    private Void* LongLifetimeMalloc(UIntPtr sz);
    private void LongLifetimeFree(Void* obj);
    private Byte* getClassModuleIdForStatics(CORINFO_CLASS_STRUCT_* cls, CORINFO_MODULE_STRUCT_** pModule, Void** ppIndirection);
    private UInt32 getClassSize(CORINFO_CLASS_STRUCT_* cls);
    private UInt32 getClassAlignmentRequirement(CORINFO_CLASS_STRUCT_* cls, bool fDoubleAlignHint);
    private int GatherClassGCLayout(TypeDesc type, Byte* gcPtrs);
    private UInt32 getClassGClayout(CORINFO_CLASS_STRUCT_* cls, Byte* gcPtrs);
    private UInt32 getClassNumInstanceFields(CORINFO_CLASS_STRUCT_* cls);
    private CORINFO_FIELD_STRUCT_* getFieldInClass(CORINFO_CLASS_STRUCT_* clsHnd, int num);
    private bool checkMethodModifier(CORINFO_METHOD_STRUCT_* hMethod, Byte* modifier, bool fOptional);
    private CorInfoHelpFunc getNewHelper(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle);
    private CorInfoHelpFunc getNewArrHelper(CORINFO_CLASS_STRUCT_* arrayCls);
    private CorInfoHelpFunc getCastingHelper(CORINFO_RESOLVED_TOKEN& pResolvedToken, bool fThrowing);
    private CorInfoHelpFunc getSharedCCtorHelper(CORINFO_CLASS_STRUCT_* clsHnd);
    private CorInfoHelpFunc getSecurityPrologHelper(CORINFO_METHOD_STRUCT_* ftn);
    private CORINFO_CLASS_STRUCT_* getTypeForBox(CORINFO_CLASS_STRUCT_* cls);
    private CorInfoHelpFunc getBoxHelper(CORINFO_CLASS_STRUCT_* cls);
    private CorInfoHelpFunc getUnBoxHelper(CORINFO_CLASS_STRUCT_* cls);
    private ISymbolNode GetGenericLookupHelper(CORINFO_RUNTIME_LOOKUP_KIND runtimeLookupKind, ReadyToRunHelperId helperId, object helperArgument);
    private bool getReadyToRunHelper(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_LOOKUP_KIND& pGenericLookupKind, CorInfoHelpFunc id, CORINFO_CONST_LOOKUP& pLookup);
    private void getReadyToRunDelegateCtorHelper(CORINFO_RESOLVED_TOKEN& pTargetMethod, CORINFO_CLASS_STRUCT_* delegateType, CORINFO_LOOKUP& pLookup);
    private Byte* getHelperName(CorInfoHelpFunc helpFunc);
    private CorInfoInitClassResult initClass(CORINFO_FIELD_STRUCT_* field, CORINFO_METHOD_STRUCT_* method, CORINFO_CONTEXT_STRUCT* context, bool speculative);
    private void classMustBeLoadedBeforeCodeIsRun(CORINFO_CLASS_STRUCT_* cls);
    private CORINFO_CLASS_STRUCT_* getBuiltinClass(CorInfoClassId classId);
    private CorInfoType getTypeForPrimitiveValueClass(CORINFO_CLASS_STRUCT_* cls);
    private CorInfoType getTypeForPrimitiveNumericClass(CORINFO_CLASS_STRUCT_* cls);
    private bool canCast(CORINFO_CLASS_STRUCT_* child, CORINFO_CLASS_STRUCT_* parent);
    private bool areTypesEquivalent(CORINFO_CLASS_STRUCT_* cls1, CORINFO_CLASS_STRUCT_* cls2);
    private TypeCompareState compareTypesForCast(CORINFO_CLASS_STRUCT_* fromClass, CORINFO_CLASS_STRUCT_* toClass);
    private TypeCompareState compareTypesForEquality(CORINFO_CLASS_STRUCT_* cls1, CORINFO_CLASS_STRUCT_* cls2);
    private CORINFO_CLASS_STRUCT_* mergeClasses(CORINFO_CLASS_STRUCT_* cls1, CORINFO_CLASS_STRUCT_* cls2);
    private CORINFO_CLASS_STRUCT_* getParentType(CORINFO_CLASS_STRUCT_* cls);
    private CorInfoType getChildType(CORINFO_CLASS_STRUCT_* clsHnd, CORINFO_CLASS_STRUCT_*& clsRet);
    private bool satisfiesClassConstraints(CORINFO_CLASS_STRUCT_* cls);
    private bool isSDArray(CORINFO_CLASS_STRUCT_* cls);
    private UInt32 getArrayRank(CORINFO_CLASS_STRUCT_* cls);
    private Void* getArrayInitializationData(CORINFO_FIELD_STRUCT_* field, UInt32 size);
    private CorInfoIsAccessAllowedResult canAccessClass(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_HELPER_DESC& pAccessHelper);
    private Byte* getFieldName(CORINFO_FIELD_STRUCT_* ftn, Byte** moduleName);
    private CORINFO_CLASS_STRUCT_* getFieldClass(CORINFO_FIELD_STRUCT_* field);
    private CorInfoType getFieldType(CORINFO_FIELD_STRUCT_* field, CORINFO_CLASS_STRUCT_*& structType, CORINFO_CLASS_STRUCT_* memberParent);
    private UInt32 getFieldOffset(CORINFO_FIELD_STRUCT_* field);
    private bool isWriteBarrierHelperRequired(CORINFO_FIELD_STRUCT_* field);
    private void getFieldInfo(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_ACCESS_FLAGS flags, CORINFO_FIELD_INFO& pResult);
    private bool isFieldStatic(CORINFO_FIELD_STRUCT_* fldHnd);
    public void SetSequencePoints(IEnumerable`1<ILSequencePoint> ilSequencePoints);
    public void SetLocalVariables(IEnumerable`1<ILLocalVariable> localVariables);
    public void SetParameterNames(IEnumerable`1<string> parameters);
    private void getBoundaries(CORINFO_METHOD_STRUCT_* ftn, UInt32& cILOffsets, UInt32*& pILOffsets, BoundaryTypes* implicitBoundaries);
    private void setBoundaries(CORINFO_METHOD_STRUCT_* ftn, UInt32 cMap, OffsetMapping* pMap);
    private void getVars(CORINFO_METHOD_STRUCT_* ftn, UInt32& cVars, ILVarInfo** vars, Boolean& extendOthers);
    private void setVars(CORINFO_METHOD_STRUCT_* ftn, UInt32 cVars, NativeVarInfo* vars);
    private void updateDebugVarInfo(Dictionary`2<UInt32, DebugVarInfo> debugVars, string name, bool isParam, NativeVarInfo nativeVarInfo);
    private Void* allocateArray(UInt32 cBytes);
    private void freeArray(Void* array);
    private CORINFO_ARG_LIST_STRUCT_* getArgNext(CORINFO_ARG_LIST_STRUCT_* args);
    private CorInfoTypeWithMod getArgType(CORINFO_SIG_INFO* sig, CORINFO_ARG_LIST_STRUCT_* args, CORINFO_CLASS_STRUCT_*& vcTypeRet);
    private CORINFO_CLASS_STRUCT_* getArgClass(CORINFO_SIG_INFO* sig, CORINFO_ARG_LIST_STRUCT_* args);
    private CorInfoType getHFAType(CORINFO_CLASS_STRUCT_* hClass);
    private HRESULT GetErrorHRESULT(_EXCEPTION_POINTERS* pExceptionPointers);
    private UInt32 GetErrorMessage(Int16* buffer, UInt32 bufferLength);
    private int FilterException(_EXCEPTION_POINTERS* pExceptionPointers);
    private void HandleException(_EXCEPTION_POINTERS* pExceptionPointers);
    private bool runWithErrorTrap(Void* function, Void* parameter);
    private void ThrowExceptionForJitResult(HRESULT result);
    private void ThrowExceptionForHelper(CORINFO_HELPER_DESC& throwHelper);
    private UInt32 get_SizeOfPInvokeTransitionFrame();
    private void getEEInfo(CORINFO_EE_INFO& pEEInfoOut);
    private string getJitTimeLogFilename();
    private mdToken getMethodDefFromMethod(CORINFO_METHOD_STRUCT_* hMethod);
    private static Byte[] StringToUTF8(string s);
    private Byte* getMethodName(CORINFO_METHOD_STRUCT_* ftn, Byte** moduleName);
    private Byte* getMethodNameFromMetadata(CORINFO_METHOD_STRUCT_* ftn, Byte** className, Byte** namespaceName);
    private UInt32 getMethodHash(CORINFO_METHOD_STRUCT_* ftn);
    private Byte* findNameOfToken(CORINFO_MODULE_STRUCT_* moduleHandle, mdToken token, Byte* szFQName, UIntPtr FQNameCapacity);
    private bool getSystemVAmd64PassStructInRegisterDescriptor(CORINFO_CLASS_STRUCT_* structHnd, SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR* structPassInRegDescPtr);
    private UInt32 getThreadTLSIndex(Void*& ppIndirection);
    private Void* getInlinedCallFrameVptr(Void*& ppIndirection);
    private Int32* getAddrOfCaptureThreadGlobal(Void*& ppIndirection);
    private ISymbolNode GetHelperFtnUncached(CorInfoHelpFunc ftnNum);
    private Void* getHelperFtn(CorInfoHelpFunc ftnNum, Void*& ppIndirection);
    private void getFunctionEntryPoint(CORINFO_METHOD_STRUCT_* ftn, CORINFO_CONST_LOOKUP& pResult, CORINFO_ACCESS_FLAGS accessFlags);
    private void getFunctionFixedEntryPoint(CORINFO_METHOD_STRUCT_* ftn, CORINFO_CONST_LOOKUP& pResult);
    private Void* getMethodSync(CORINFO_METHOD_STRUCT_* ftn, Void*& ppIndirection);
    private CorInfoHelpFunc getLazyStringLiteralHelper(CORINFO_MODULE_STRUCT_* handle);
    private CORINFO_MODULE_STRUCT_* embedModuleHandle(CORINFO_MODULE_STRUCT_* handle, Void*& ppIndirection);
    private CORINFO_CLASS_STRUCT_* embedClassHandle(CORINFO_CLASS_STRUCT_* handle, Void*& ppIndirection);
    private CORINFO_METHOD_STRUCT_* embedMethodHandle(CORINFO_METHOD_STRUCT_* handle, Void*& ppIndirection);
    private CORINFO_FIELD_STRUCT_* embedFieldHandle(CORINFO_FIELD_STRUCT_* handle, Void*& ppIndirection);
    private void embedGenericHandle(CORINFO_RESOLVED_TOKEN& pResolvedToken, bool fEmbedParent, CORINFO_GENERICHANDLE_RESULT& pResult);
    private CORINFO_RUNTIME_LOOKUP_KIND GetGenericRuntimeLookupKind(MethodDesc method);
    private CORINFO_RUNTIME_LOOKUP_KIND GetLookupKindFromContextSource(GenericContextSource contextSource);
    private void getLocationOfThisType(CORINFO_LOOKUP_KIND& result, CORINFO_METHOD_STRUCT_* context);
    private Void* getPInvokeUnmanagedTarget(CORINFO_METHOD_STRUCT_* method, Void*& ppIndirection);
    private Void* getAddressOfPInvokeFixup(CORINFO_METHOD_STRUCT_* method, Void*& ppIndirection);
    private void getAddressOfPInvokeTarget(CORINFO_METHOD_STRUCT_* method, CORINFO_CONST_LOOKUP& pLookup);
    private Void* GetCookieForPInvokeCalliSig(CORINFO_SIG_INFO* szMetaSig, Void*& ppIndirection);
    private bool canGetCookieForPInvokeCalliSig(CORINFO_SIG_INFO* szMetaSig);
    private CORINFO_JUST_MY_CODE_HANDLE_* getJustMyCodeHandle(CORINFO_METHOD_STRUCT_* method, CORINFO_JUST_MY_CODE_HANDLE_*& ppIndirection);
    private void GetProfilingHandle(Boolean& pbHookFunction, Void*& pProfilerHandle, Boolean& pbIndirectedHandles);
    private CORINFO_CONST_LOOKUP CreateConstLookupToSymbol(ISymbolNode symbol);
    private void getCallInfo(CORINFO_RESOLVED_TOKEN& pResolvedToken, CORINFO_RESOLVED_TOKEN* pConstrainedResolvedToken, CORINFO_METHOD_STRUCT_* callerHandle, CORINFO_CALLINFO_FLAGS flags, CORINFO_CALL_INFO& pResult);
    private bool canAccessFamily(CORINFO_METHOD_STRUCT_* hCaller, CORINFO_CLASS_STRUCT_* hInstanceType);
    private bool isRIDClassDomainID(CORINFO_CLASS_STRUCT_* cls);
    private UInt32 getClassDomainID(CORINFO_CLASS_STRUCT_* cls, Void*& ppIndirection);
    private Void* getFieldAddress(CORINFO_FIELD_STRUCT_* field, Void*& ppIndirection);
    private IntPtr getVarArgsHandle(CORINFO_SIG_INFO* pSig, Void*& ppIndirection);
    private bool canGetVarArgsHandle(CORINFO_SIG_INFO* pSig);
    private InfoAccessType constructStringLiteral(CORINFO_MODULE_STRUCT_* module, mdToken metaTok, Void*& ppValue);
    private InfoAccessType emptyStringLiteral(Void*& ppValue);
    private UInt32 getFieldThreadLocalStoreID(CORINFO_FIELD_STRUCT_* field, Void*& ppIndirection);
    private void setOverride(IntPtr pOverride, CORINFO_METHOD_STRUCT_* currentMethod);
    private void addActiveDependency(CORINFO_MODULE_STRUCT_* moduleFrom, CORINFO_MODULE_STRUCT_* moduleTo);
    private CORINFO_METHOD_STRUCT_* GetDelegateCtor(CORINFO_METHOD_STRUCT_* methHnd, CORINFO_CLASS_STRUCT_* clsHnd, CORINFO_METHOD_STRUCT_* targetMethodHnd, DelegateCtorArgs& pCtorData);
    private void MethodCompileComplete(CORINFO_METHOD_STRUCT_* methHnd);
    private Void* getTailCallCopyArgsThunk(CORINFO_SIG_INFO* pSig, CorInfoHelperTailCallSpecialHandling flags);
    private bool convertPInvokeCalliToCall(CORINFO_RESOLVED_TOKEN& pResolvedToken, bool mustConvert);
    private Void* getMemoryManager();
    private void allocMem(UInt32 hotCodeSize, UInt32 coldCodeSize, UInt32 roDataSize, UInt32 xcptnsCount, CorJitAllocMemFlag flag, Void*& hotCodeBlock, Void*& coldCodeBlock, Void*& roDataBlock);
    private void reserveUnwindInfo(bool isFunclet, bool isColdCode, UInt32 unwindSize);
    private void allocUnwindInfo(Byte* pHotCode, Byte* pColdCode, UInt32 startOffset, UInt32 endOffset, UInt32 unwindSize, Byte* pUnwindBlock, CorJitFuncKind funcKind);
    private Void* allocGCInfo(UIntPtr size);
    private void yieldExecution();
    private void setEHcount(UInt32 cEH);
    private void setEHinfo(UInt32 EHnumber, CORINFO_EH_CLAUSE& clause);
    private bool logMsg(UInt32 level, Byte* fmt, IntPtr args);
    private int doAssert(Byte* szFile, int iLine, Byte* szExpr);
    private void reportFatalError(CorJitResult result);
    private HRESULT allocBBProfileBuffer(UInt32 count, ProfileBuffer*& profileBuffer);
    private HRESULT getBBProfileData(CORINFO_METHOD_STRUCT_* ftnHnd, UInt32& count, ProfileBuffer*& profileBuffer, UInt32& numRuns);
    private void recordCallSite(UInt32 instrOffset, CORINFO_SIG_INFO* callSig, CORINFO_METHOD_STRUCT_* methodHandle);
    private BlockType findKnownBlock(Void* location, Int32& offset);
    private void recordRelocation(Void* location, Void* target, ushort fRelocType, ushort slotNum, int addlDelta);
    private ushort getRelocTypeHint(Void* target);
    private void getModuleNativeEntryPointRange(Void*& pStart, Void*& pEnd);
    private UInt32 getExpectedTargetArchitecture();
    private UInt32 getJitFlags(CORJIT_FLAGS& flags, UInt32 sizeInBytes);
    private static IntrinsicHashtable InitializeIntrinsicHashtable();
    private CorInfoIntrinsics getIntrinsicID(CORINFO_METHOD_STRUCT_* ftn, Byte* pMustExpand);
    private CorInfoIntrinsics getIntrinsicID(MethodDesc method, Byte* pMustExpand);
}
public enum Internal.JitInterface.CorInfoInitClassResult : Enum {
    public int value__;
    public static CorInfoInitClassResult CORINFO_INITCLASS_NOT_REQUIRED;
    public static CorInfoInitClassResult CORINFO_INITCLASS_INITIALIZED;
    public static CorInfoInitClassResult CORINFO_INITCLASS_SPECULATIVE;
    public static CorInfoInitClassResult CORINFO_INITCLASS_USE_HELPER;
    public static CorInfoInitClassResult CORINFO_INITCLASS_DONT_INLINE;
}
public enum Internal.JitInterface.CorInfoInline : Enum {
    public int value__;
    public static CorInfoInline INLINE_PASS;
    public static CorInfoInline INLINE_FAIL;
    public static CorInfoInline INLINE_NEVER;
}
public enum Internal.JitInterface.CorInfoInlineRestrictions : Enum {
    public int value__;
    public static CorInfoInlineRestrictions INLINE_RESPECT_BOUNDARY;
    public static CorInfoInlineRestrictions INLINE_NO_CALLEE_LDSTR;
    public static CorInfoInlineRestrictions INLINE_SAME_THIS;
}
public enum Internal.JitInterface.CorInfoInstantiationVerification : Enum {
    public int value__;
    public static CorInfoInstantiationVerification INSTVER_NOT_INSTANTIATION;
    public static CorInfoInstantiationVerification INSTVER_GENERIC_PASSED_VERIFICATION;
    public static CorInfoInstantiationVerification INSTVER_GENERIC_FAILED_VERIFICATION;
}
internal enum Internal.JitInterface.CorInfoIntrinsics : Enum {
    public int value__;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Sin;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Cos;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Cbrt;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Sqrt;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Abs;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Round;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Cosh;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Sinh;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Tan;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Tanh;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Asin;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Asinh;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Acos;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Acosh;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Atan;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Atan2;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Atanh;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Log10;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Pow;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Exp;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Ceiling;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Floor;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_GetChar;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Array_GetDimLength;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Array_Get;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Array_Address;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Array_Set;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_StringGetChar;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_StringLength;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InitializeArray;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_GetTypeFromHandle;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_RTH_GetValueInternal;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_TypeEQ;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_TypeNEQ;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Object_GetType;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_StubHelpers_GetStubContext;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_StubHelpers_GetStubContextAddr;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_StubHelpers_GetNDirectTarget;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedAdd32;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedAdd64;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedXAdd32;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedXAdd64;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedXchg32;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedXchg64;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedCmpXchg32;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_InterlockedCmpXchg64;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_MemoryBarrier;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_GetCurrentManagedThread;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_GetManagedThreadId;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_ByReference_Ctor;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_ByReference_Value;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Span_GetItem;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_ReadOnlySpan_GetItem;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_GetRawHandle;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Count;
    public static CorInfoIntrinsics CORINFO_INTRINSIC_Illegal;
}
public enum Internal.JitInterface.CorInfoIsAccessAllowedResult : Enum {
    public int value__;
    public static CorInfoIsAccessAllowedResult CORINFO_ACCESS_ALLOWED;
    public static CorInfoIsAccessAllowedResult CORINFO_ACCESS_ILLEGAL;
    public static CorInfoIsAccessAllowedResult CORINFO_ACCESS_RUNTIME_CHECK;
}
public enum Internal.JitInterface.CorInfoMethodRuntimeFlags : Enum {
    public int value__;
    public static CorInfoMethodRuntimeFlags CORINFO_FLG_BAD_INLINEE;
    public static CorInfoMethodRuntimeFlags CORINFO_FLG_VERIFIABLE;
    public static CorInfoMethodRuntimeFlags CORINFO_FLG_UNVERIFIABLE;
}
public enum Internal.JitInterface.CorInfoOptions : Enum {
    public int value__;
    public static CorInfoOptions CORINFO_OPT_INIT_LOCALS;
    public static CorInfoOptions CORINFO_GENERICS_CTXT_FROM_THIS;
    public static CorInfoOptions CORINFO_GENERICS_CTXT_FROM_METHODDESC;
    public static CorInfoOptions CORINFO_GENERICS_CTXT_FROM_METHODTABLE;
    public static CorInfoOptions CORINFO_GENERICS_CTXT_MASK;
    public static CorInfoOptions CORINFO_GENERICS_CTXT_KEEP_ALIVE;
}
public enum Internal.JitInterface.CorInfoRegionKind : Enum {
    public int value__;
    public static CorInfoRegionKind CORINFO_REGION_NONE;
    public static CorInfoRegionKind CORINFO_REGION_HOT;
    public static CorInfoRegionKind CORINFO_REGION_COLD;
    public static CorInfoRegionKind CORINFO_REGION_JIT;
}
public enum Internal.JitInterface.CorInfoSigInfoFlags : Enum {
    public int value__;
    public static CorInfoSigInfoFlags CORINFO_SIGFLAG_IS_LOCAL_SIG;
    public static CorInfoSigInfoFlags CORINFO_SIGFLAG_IL_STUB;
}
public enum Internal.JitInterface.CorInfoTailCall : Enum {
    public int value__;
    public static CorInfoTailCall TAILCALL_OPTIMIZED;
    public static CorInfoTailCall TAILCALL_RECURSIVE;
    public static CorInfoTailCall TAILCALL_HELPER;
    public static CorInfoTailCall TAILCALL_FAIL;
}
public enum Internal.JitInterface.CorInfoTokenKind : Enum {
    public int value__;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Class;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Method;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Field;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Mask;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Ldtoken;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Casting;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Newarr;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Box;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Constrained;
    public static CorInfoTokenKind CORINFO_TOKENKIND_NewObj;
    public static CorInfoTokenKind CORINFO_TOKENKIND_Ldvirtftn;
}
public enum Internal.JitInterface.CorInfoType : Enum {
    public int value__;
    public static CorInfoType CORINFO_TYPE_UNDEF;
    public static CorInfoType CORINFO_TYPE_VOID;
    public static CorInfoType CORINFO_TYPE_BOOL;
    public static CorInfoType CORINFO_TYPE_CHAR;
    public static CorInfoType CORINFO_TYPE_BYTE;
    public static CorInfoType CORINFO_TYPE_UBYTE;
    public static CorInfoType CORINFO_TYPE_SHORT;
    public static CorInfoType CORINFO_TYPE_USHORT;
    public static CorInfoType CORINFO_TYPE_INT;
    public static CorInfoType CORINFO_TYPE_UINT;
    public static CorInfoType CORINFO_TYPE_LONG;
    public static CorInfoType CORINFO_TYPE_ULONG;
    public static CorInfoType CORINFO_TYPE_NATIVEINT;
    public static CorInfoType CORINFO_TYPE_NATIVEUINT;
    public static CorInfoType CORINFO_TYPE_FLOAT;
    public static CorInfoType CORINFO_TYPE_DOUBLE;
    public static CorInfoType CORINFO_TYPE_STRING;
    public static CorInfoType CORINFO_TYPE_PTR;
    public static CorInfoType CORINFO_TYPE_BYREF;
    public static CorInfoType CORINFO_TYPE_VALUECLASS;
    public static CorInfoType CORINFO_TYPE_CLASS;
    public static CorInfoType CORINFO_TYPE_REFANY;
    public static CorInfoType CORINFO_TYPE_VAR;
    public static CorInfoType CORINFO_TYPE_COUNT;
}
public enum Internal.JitInterface.CorInfoTypeWithMod : Enum {
    public int value__;
    public static CorInfoTypeWithMod CORINFO_TYPE_MASK;
    public static CorInfoTypeWithMod CORINFO_TYPE_MOD_PINNED;
}
public enum Internal.JitInterface.CorInfoUnmanagedCallConv : Enum {
    public int value__;
    public static CorInfoUnmanagedCallConv CORINFO_UNMANAGED_CALLCONV_UNKNOWN;
    public static CorInfoUnmanagedCallConv CORINFO_UNMANAGED_CALLCONV_C;
    public static CorInfoUnmanagedCallConv CORINFO_UNMANAGED_CALLCONV_STDCALL;
    public static CorInfoUnmanagedCallConv CORINFO_UNMANAGED_CALLCONV_THISCALL;
    public static CorInfoUnmanagedCallConv CORINFO_UNMANAGED_CALLCONV_FASTCALL;
}
public class Internal.JitInterface.CORJIT_FLAGS : ValueType {
    private ulong _corJitFlags;
    public void Reset();
    public void Set(CorJitFlag flag);
    public void Clear(CorJitFlag flag);
    public bool IsSet(CorJitFlag flag);
    public void Add(CORJIT_FLAGS& other);
    public void Remove(CORJIT_FLAGS& other);
    public bool IsEmpty();
}
public enum Internal.JitInterface.CorJitAllocMemFlag : Enum {
    public int value__;
    public static CorJitAllocMemFlag CORJIT_ALLOCMEM_DEFAULT_CODE_ALIGN;
    public static CorJitAllocMemFlag CORJIT_ALLOCMEM_FLG_16BYTE_ALIGN;
    public static CorJitAllocMemFlag CORJIT_ALLOCMEM_FLG_RODATA_16BYTE_ALIGN;
}
public enum Internal.JitInterface.CorJitFlag : Enum {
    public UInt32 value__;
    public static CorJitFlag CORJIT_FLAG_CALL_GETJITFLAGS;
    public static CorJitFlag CORJIT_FLAG_SPEED_OPT;
    public static CorJitFlag CORJIT_FLAG_SIZE_OPT;
    public static CorJitFlag CORJIT_FLAG_DEBUG_CODE;
    public static CorJitFlag CORJIT_FLAG_DEBUG_EnC;
    public static CorJitFlag CORJIT_FLAG_DEBUG_INFO;
    public static CorJitFlag CORJIT_FLAG_MIN_OPT;
    public static CorJitFlag CORJIT_FLAG_GCPOLL_CALLS;
    public static CorJitFlag CORJIT_FLAG_MCJIT_BACKGROUND;
    public static CorJitFlag CORJIT_FLAG_UNUSED1;
    public static CorJitFlag CORJIT_FLAG_UNUSED2;
    public static CorJitFlag CORJIT_FLAG_UNUSED3;
    public static CorJitFlag CORJIT_FLAG_UNUSED4;
    public static CorJitFlag CORJIT_FLAG_UNUSED5;
    public static CorJitFlag CORJIT_FLAG_UNUSED6;
    public static CorJitFlag CORJIT_FLAG_USE_AVX;
    public static CorJitFlag CORJIT_FLAG_USE_AVX2;
    public static CorJitFlag CORJIT_FLAG_USE_AVX_512;
    public static CorJitFlag CORJIT_FLAG_FEATURE_SIMD;
    public static CorJitFlag CORJIT_FLAG_MAKEFINALCODE;
    public static CorJitFlag CORJIT_FLAG_READYTORUN;
    public static CorJitFlag CORJIT_FLAG_PROF_ENTERLEAVE;
    public static CorJitFlag CORJIT_FLAG_PROF_REJIT_NOPS;
    public static CorJitFlag CORJIT_FLAG_PROF_NO_PINVOKE_INLINE;
    public static CorJitFlag CORJIT_FLAG_SKIP_VERIFICATION;
    public static CorJitFlag CORJIT_FLAG_PREJIT;
    public static CorJitFlag CORJIT_FLAG_RELOC;
    public static CorJitFlag CORJIT_FLAG_IMPORT_ONLY;
    public static CorJitFlag CORJIT_FLAG_IL_STUB;
    public static CorJitFlag CORJIT_FLAG_PROCSPLIT;
    public static CorJitFlag CORJIT_FLAG_BBINSTR;
    public static CorJitFlag CORJIT_FLAG_BBOPT;
    public static CorJitFlag CORJIT_FLAG_FRAMED;
    public static CorJitFlag CORJIT_FLAG_ALIGN_LOOPS;
    public static CorJitFlag CORJIT_FLAG_PUBLISH_SECRET_PARAM;
    public static CorJitFlag CORJIT_FLAG_GCPOLL_INLINE;
    public static CorJitFlag CORJIT_FLAG_SAMPLING_JIT_BACKGROUND;
    public static CorJitFlag CORJIT_FLAG_USE_PINVOKE_HELPERS;
    public static CorJitFlag CORJIT_FLAG_REVERSE_PINVOKE;
    public static CorJitFlag CORJIT_FLAG_DESKTOP_QUIRKS;
    public static CorJitFlag CORJIT_FLAG_TIER0;
    public static CorJitFlag CORJIT_FLAG_TIER1;
    public static CorJitFlag CORJIT_FLAG_RELATIVE_CODE_RELOCS;
    public static CorJitFlag CORJIT_FLAG_NO_INLINING;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_AES;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_ATOMICS;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_CRC32;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_DCPOP;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_DP;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_FCMA;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_FP;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_FP16;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_JSCVT;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_LRCPC;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_PMULL;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SHA1;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SHA256;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SHA512;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SHA3;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SIMD;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SIMD_V81;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SIMD_FP16;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SM3;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SM4;
    public static CorJitFlag CORJIT_FLAG_HAS_ARM64_SVE;
    public static CorJitFlag CORJIT_FLAG_USE_SSE3;
    public static CorJitFlag CORJIT_FLAG_USE_SSSE3;
    public static CorJitFlag CORJIT_FLAG_USE_SSE41;
    public static CorJitFlag CORJIT_FLAG_USE_SSE42;
    public static CorJitFlag CORJIT_FLAG_USE_AES;
    public static CorJitFlag CORJIT_FLAG_USE_BMI1;
    public static CorJitFlag CORJIT_FLAG_USE_BMI2;
    public static CorJitFlag CORJIT_FLAG_USE_FMA;
    public static CorJitFlag CORJIT_FLAG_USE_LZCNT;
    public static CorJitFlag CORJIT_FLAG_USE_PCLMULQDQ;
    public static CorJitFlag CORJIT_FLAG_USE_POPCNT;
}
public enum Internal.JitInterface.CorJitFuncKind : Enum {
    public int value__;
    public static CorJitFuncKind CORJIT_FUNC_ROOT;
    public static CorJitFuncKind CORJIT_FUNC_HANDLER;
    public static CorJitFuncKind CORJIT_FUNC_FILTER;
}
public enum Internal.JitInterface.CorJitResult : Enum {
    public int value__;
    public static CorJitResult CORJIT_OK;
    public static CorJitResult CORJIT_BADCODE;
    public static CorJitResult CORJIT_OUTOFMEM;
    public static CorJitResult CORJIT_INTERNALERROR;
    public static CorJitResult CORJIT_SKIPPED;
    public static CorJitResult CORJIT_RECOVERABLEERROR;
}
public enum Internal.JitInterface.CorTokenType : Enum {
    public int value__;
    public static CorTokenType mdtModule;
    public static CorTokenType mdtTypeRef;
    public static CorTokenType mdtTypeDef;
    public static CorTokenType mdtFieldDef;
    public static CorTokenType mdtMethodDef;
    public static CorTokenType mdtParamDef;
    public static CorTokenType mdtInterfaceImpl;
    public static CorTokenType mdtMemberRef;
    public static CorTokenType mdtCustomAttribute;
    public static CorTokenType mdtPermission;
    public static CorTokenType mdtSignature;
    public static CorTokenType mdtEvent;
    public static CorTokenType mdtProperty;
    public static CorTokenType mdtMethodImpl;
    public static CorTokenType mdtModuleRef;
    public static CorTokenType mdtTypeSpec;
    public static CorTokenType mdtAssembly;
    public static CorTokenType mdtAssemblyRef;
    public static CorTokenType mdtFile;
    public static CorTokenType mdtExportedType;
    public static CorTokenType mdtManifestResource;
    public static CorTokenType mdtGenericParam;
    public static CorTokenType mdtMethodSpec;
    public static CorTokenType mdtGenericParamConstraint;
    public static CorTokenType mdtString;
    public static CorTokenType mdtName;
    public static CorTokenType mdtBaseType;
}
public class Internal.JitInterface.DelegateCtorArgs : ValueType {
    public Void* pMethod;
    public Void* pArg3;
    public Void* pArg4;
    public Void* pArg5;
}
public enum Internal.JitInterface.HRESULT : Enum {
    public int value__;
}
public enum Internal.JitInterface.ILNum : Enum {
    public int value__;
    public static ILNum VARARGS_HND_ILNUM;
    public static ILNum RETBUF_ILNUM;
    public static ILNum TYPECTXT_ILNUM;
    public static ILNum UNKNOWN_ILNUM;
    public static ILNum MAX_ILNUM;
}
public class Internal.JitInterface.ILVarInfo : ValueType {
    public UInt32 startOffset;
    public UInt32 endOffset;
    public UInt32 varNumber;
}
public enum Internal.JitInterface.InfoAccessType : Enum {
    public int value__;
    public static InfoAccessType IAT_VALUE;
    public static InfoAccessType IAT_PVALUE;
    public static InfoAccessType IAT_PPVALUE;
    public static InfoAccessType IAT_RELPVALUE;
}
internal class Internal.JitInterface.JitConfigProvider : object {
    private CorJitFlag[] _jitFlags;
    private Dictionary`2<string, string> _config;
    private object _keepAlive;
    [CompilerGeneratedAttribute]
private IntPtr <UnmanagedInstance>k__BackingField;
    public IntPtr UnmanagedInstance { get; }
    public IEnumerable`1<CorJitFlag> Flags { get; }
    public JitConfigProvider(IEnumerable`1<CorJitFlag> jitFlags, IEnumerable`1<KeyValuePair`2<string, string>> parameters);
    [CompilerGeneratedAttribute]
public IntPtr get_UnmanagedInstance();
    public IEnumerable`1<CorJitFlag> get_Flags();
    public bool HasFlag(CorJitFlag flag);
    public int GetIntConfigValue(string name, int defaultValue);
    public string GetStringConfigValue(string name);
    private IntPtr CreateUnmanagedInstance();
    private int getIntConfigValue(IntPtr thisHandle, string name, int defaultValue);
    private int getStringConfigValue(IntPtr thisHandle, string name, Char* retBuffer, int retBufferLength);
}
public enum Internal.JitInterface.MappingTypes : Enum {
    public int value__;
    public static MappingTypes NO_MAPPING;
    public static MappingTypes PROLOG;
    public static MappingTypes EPILOG;
}
public enum Internal.JitInterface.mdToken : Enum {
    public UInt32 value__;
}
public class Internal.JitInterface.NativeVarInfo : ValueType {
    public UInt32 startOffset;
    public UInt32 endOffset;
    public UInt32 varNumber;
    public VarLoc varLoc;
}
public class Internal.JitInterface.OffsetMapping : ValueType {
    public UInt32 nativeOffset;
    public UInt32 ilOffset;
    public SourceTypes source;
}
public class Internal.JitInterface.ProfileBuffer : ValueType {
    public UInt32 ILOffset;
    public UInt32 ExecutionCount;
}
[FlagsAttribute]
public enum Internal.JitInterface.SourceTypes : Enum {
    public int value__;
    public static SourceTypes SOURCE_TYPE_INVALID;
    public static SourceTypes SEQUENCE_POINT;
    public static SourceTypes STACK_EMPTY;
    public static SourceTypes CALL_SITE;
    public static SourceTypes NATIVE_END_OFFSET_UNKNOWN;
    public static SourceTypes CALL_INSTRUCTION;
}
public class Internal.JitInterface.SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR : ValueType {
    public byte _passedInRegisters;
    public byte eightByteCount;
    public SystemVClassificationType eightByteClassifications0;
    public SystemVClassificationType eightByteClassifications1;
    public byte eightByteSizes0;
    public byte eightByteSizes1;
    public byte eightByteOffsets0;
    public byte eightByteOffsets1;
    public bool passedInRegisters { get; public set; }
    public bool get_passedInRegisters();
    public void set_passedInRegisters(bool value);
}
public enum Internal.JitInterface.SystemVClassificationType : Enum {
    public byte value__;
    public static SystemVClassificationType SystemVClassificationTypeUnknown;
    public static SystemVClassificationType SystemVClassificationTypeStruct;
    public static SystemVClassificationType SystemVClassificationTypeNoClass;
    public static SystemVClassificationType SystemVClassificationTypeMemory;
    public static SystemVClassificationType SystemVClassificationTypeInteger;
    public static SystemVClassificationType SystemVClassificationTypeIntegerReference;
    public static SystemVClassificationType SystemVClassificationTypeIntegerByRef;
    public static SystemVClassificationType SystemVClassificationTypeSSE;
    public static SystemVClassificationType SystemVClassificationTypeMAX;
}
public enum Internal.JitInterface.TypeCompareState : Enum {
    public int value__;
    public static TypeCompareState MustNot;
    public static TypeCompareState May;
    public static TypeCompareState Must;
}
internal class Internal.JitInterface.TypeString : TypeNameFormatter {
    [CompilerGeneratedAttribute]
private static TypeString <Instance>k__BackingField;
    public static TypeString Instance { get; }
    private static TypeString();
    [CompilerGeneratedAttribute]
public static TypeString get_Instance();
    public virtual void AppendName(StringBuilder sb, PointerType type);
    public virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    public virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public virtual void AppendName(StringBuilder sb, ByRefType type);
    public virtual void AppendName(StringBuilder sb, ArrayType type);
    protected virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
}
public class Internal.JitInterface.VarLoc : ValueType {
    private IntPtr A;
    private int B;
    private int C;
    private int D;
}
internal class Internal.NativeFormat.NativePrimitiveEncoder : ValueType {
    private Byte[] _buffer;
    private int _size;
    public int Size { get; }
    public void Init();
    public int get_Size();
    public void Clear();
    public void RollbackTo(int offset);
    public void WriteByte(byte b);
    public void WriteUInt8(byte value);
    public void WriteUInt16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteFloat(float value);
    public void WriteDouble(double value);
    public void WriteUnsigned(UInt32 d);
    public static int GetUnsignedEncodingSize(UInt32 d);
    public void WriteSigned(int i);
    public void WriteUnsignedLong(ulong i);
    public void WriteSignedLong(long i);
    public void PatchByteAt(int offset, byte value);
    public void Save(Stream stream);
    public bool Save(Byte* stream, int streamLength);
    public Byte[] GetBytes();
}
internal static class Internal.Runtime.ArrayTypesConstants : object {
    public static int MaxSizeForValueClassInArray;
}
public enum Internal.Runtime.CanonTypeKind : Enum {
    public int value__;
    public static CanonTypeKind NormalCanon;
    public static CanonTypeKind UniversalCanon;
}
internal enum Internal.Runtime.CorElementType : Enum {
    public int value__;
    public static CorElementType ELEMENT_TYPE_END;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
}
internal class Internal.Runtime.DynamicInvokeMapEntry : ValueType {
    public static UInt32 IsImportMethodFlag;
    public static UInt32 InstantiationDetailIndexMask;
}
internal static class Internal.Runtime.EETypeBuilderHelpers : object {
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    private static CorElementType ComputeRhCorElementType(TypeDesc type);
    public static ushort ComputeFlags(TypeDesc type);
    public static bool ComputeRequiresAlign8(TypeDesc type);
    internal static UInt32 ComputeValueTypeFieldPaddingFieldValue(UInt32 padding, UInt32 alignment, int targetPointerSize);
}
internal enum Internal.Runtime.EETypeField : Enum {
    public int value__;
    public static EETypeField ETF_InterfaceMap;
    public static EETypeField ETF_Finalizer;
    public static EETypeField ETF_OptionalFieldsPtr;
    public static EETypeField ETF_NullableType;
    public static EETypeField ETF_SealedVirtualSlots;
    public static EETypeField ETF_DynamicTemplateType;
    public static EETypeField ETF_DynamicDispatchMap;
    public static EETypeField ETF_DynamicModule;
    public static EETypeField ETF_GenericDefinition;
    public static EETypeField ETF_GenericComposition;
    public static EETypeField ETF_DynamicGcStatics;
    public static EETypeField ETF_DynamicNonGcStatics;
    public static EETypeField ETF_DynamicThreadStaticOffset;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeFlags : Enum {
    public ushort value__;
    public static EETypeFlags EETypeKindMask;
    public static EETypeFlags RelatedTypeViaIATFlag;
    public static EETypeFlags ValueTypeFlag;
    public static EETypeFlags HasFinalizerFlag;
    public static EETypeFlags HasPointersFlag;
    public static EETypeFlags ICastableFlag;
    public static EETypeFlags GenericVarianceFlag;
    public static EETypeFlags OptionalFieldsFlag;
    public static EETypeFlags IsInterfaceFlag;
    public static EETypeFlags IsGenericFlag;
    public static EETypeFlags CorElementTypeMask;
    public static EETypeFlags CorElementTypeShift;
    public static EETypeFlags ComplexCastingMask;
}
internal enum Internal.Runtime.EETypeKind : Enum {
    public ushort value__;
    public static EETypeKind CanonicalEEType;
    public static EETypeKind ClonedEEType;
    public static EETypeKind ParameterizedEEType;
    public static EETypeKind GenericTypeDefEEType;
}
internal class Internal.Runtime.EETypeOptionalFieldsBuilder : object {
    private NativePrimitiveEncoder _encoder;
    private OptionalField[] _rgFields;
    internal UInt32 GetFieldValue(EETypeOptionalFieldTag eTag, UInt32 defaultValueIfNotFound);
    internal void SetFieldValue(EETypeOptionalFieldTag eTag, UInt32 value);
    internal void ClearField(EETypeOptionalFieldTag eTag);
    private int Encode();
    public Byte[] GetBytes();
    public bool IsAtLeastOneFieldUsed();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum Internal.Runtime.EETypeOptionalFieldTag : Enum {
    public byte value__;
    public static EETypeOptionalFieldTag RareFlags;
    public static EETypeOptionalFieldTag ICastableIsInstSlot;
    public static EETypeOptionalFieldTag DispatchMap;
    public static EETypeOptionalFieldTag ValueTypeFieldPadding;
    public static EETypeOptionalFieldTag ICastableGetImplTypeSlot;
    public static EETypeOptionalFieldTag NullableValueOffset;
    public static EETypeOptionalFieldTag Count;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeRareFlags : Enum {
    public int value__;
    public static EETypeRareFlags RequiresAlign8Flag;
    public static EETypeRareFlags UNUSED1;
    public static EETypeRareFlags IsNullableFlag;
    public static EETypeRareFlags NullableTypeViaIATFlag;
    public static EETypeRareFlags IsDynamicTypeFlag;
    public static EETypeRareFlags HasCctorFlag;
    public static EETypeRareFlags UNUSED2;
    public static EETypeRareFlags HasDynamicallyAllocatedDispatchMapFlag;
    public static EETypeRareFlags IsHFAFlag;
    public static EETypeRareFlags HasSealedVTableEntriesFlag;
    public static EETypeRareFlags IsDynamicTypeWithGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithNonGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithThreadStatics;
    public static EETypeRareFlags HasDynamicModuleFlag;
    public static EETypeRareFlags IsAbstractClassFlag;
    public static EETypeRareFlags IsByRefLikeFlag;
}
internal static class Internal.Runtime.FatFunctionPointerConstants : object {
    public static int Offset;
}
[FlagsAttribute]
public enum Internal.Runtime.FieldTableFlags : Enum {
    public UInt32 value__;
    public static FieldTableFlags Instance;
    public static FieldTableFlags Static;
    public static FieldTableFlags ThreadStatic;
    public static FieldTableFlags StorageClass;
    public static FieldTableFlags IsUniversalCanonicalEntry;
    public static FieldTableFlags HasMetadataHandle;
    public static FieldTableFlags IsGcSection;
    public static FieldTableFlags FieldOffsetEncodedDirectly;
    public static FieldTableFlags IsAnyCanonicalEntry;
}
public class Internal.Runtime.GCDescEncoder : ValueType {
    public static int GetGCDescSize(TypeDesc type);
    public static void EncodeGCDesc(T& builder, TypeDesc type);
    public static void EncodeStandardGCDesc(T& builder, GCPointerMap map, int size, int delta);
    private static void EncodeAllGCPointersArrayGCDesc(T& builder, int baseSize);
    private static void EncodeArrayGCDesc(T& builder, GCPointerMap map, int baseSize);
}
internal static class Internal.Runtime.GCStaticRegionConstants : object {
    public static int Uninitialized;
    public static int HasPreInitializedData;
    public static int Mask;
}
internal enum Internal.Runtime.GenericVariance : Enum {
    public byte value__;
    public static GenericVariance NonVariant;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
    public static GenericVariance ArrayCovariant;
}
internal static class Internal.Runtime.IndirectionConstants : object {
    public static int IndirectionCellPointer;
    public static UInt32 RVAPointsToIndirection;
}
public enum Internal.Runtime.InterfaceDispatchCellCachePointerFlags : Enum {
    public int value__;
    public static InterfaceDispatchCellCachePointerFlags CachePointerPointsAtCache;
    public static InterfaceDispatchCellCachePointerFlags CachePointerIsInterfacePointerOrMetadataToken;
    public static InterfaceDispatchCellCachePointerFlags CachePointerIsIndirectedInterfaceRelativePointer;
    public static InterfaceDispatchCellCachePointerFlags CachePointerIsInterfaceRelativePointer;
    public static InterfaceDispatchCellCachePointerFlags CachePointerMask;
    public static InterfaceDispatchCellCachePointerFlags CachePointerMaskShift;
    public static InterfaceDispatchCellCachePointerFlags MaxVTableOffsetPlusOne;
}
[FlagsAttribute]
public enum Internal.Runtime.InvokeTableFlags : Enum {
    public UInt32 value__;
    public static InvokeTableFlags HasVirtualInvoke;
    public static InvokeTableFlags IsGenericMethod;
    public static InvokeTableFlags HasMetadataHandle;
    public static InvokeTableFlags IsDefaultConstructor;
    public static InvokeTableFlags RequiresInstArg;
    public static InvokeTableFlags HasEntrypoint;
    public static InvokeTableFlags IsUniversalCanonicalEntry;
    public static InvokeTableFlags NeedsParameterInterpretation;
    public static InvokeTableFlags CallingConventionDefault;
    public static InvokeTableFlags Cdecl;
    public static InvokeTableFlags Winapi;
    public static InvokeTableFlags StdCall;
    public static InvokeTableFlags ThisCall;
    public static InvokeTableFlags FastCall;
    public static InvokeTableFlags CallingConventionMask;
}
public interface Internal.Runtime.ITargetBinaryWriter {
    public int CountBytes { get; }
    public int TargetPointerSize { get; }
    public abstract virtual int get_CountBytes();
    public abstract virtual int get_TargetPointerSize();
    public abstract virtual void EmitNaturalInt(int emit);
    public abstract virtual void EmitHalfNaturalInt(short emit);
}
[FlagsAttribute]
internal enum Internal.Runtime.ModuleInfoFlags : Enum {
    public int value__;
    public static ModuleInfoFlags HasEndPointer;
}
internal static class Internal.Runtime.ParameterizedTypeShapeConstants : object {
    public static int Pointer;
    public static int ByRef;
}
internal class Internal.Runtime.ReadyToRunHeader : ValueType {
    private UInt32 Signature;
    private ushort MajorVersion;
    private ushort MinorVersion;
    private UInt32 Flags;
    private ushort NumberOfSections;
    private byte EntrySize;
    private byte EntryType;
}
internal class Internal.Runtime.ReadyToRunHeaderConstants : ValueType {
    public static UInt32 Signature;
    public static ushort CurrentMajorVersion;
    public static ushort CurrentMinorVersion;
}
public enum Internal.Runtime.ReadyToRunSectionType : Enum {
    public int value__;
    public static ReadyToRunSectionType StringTable;
    public static ReadyToRunSectionType GCStaticRegion;
    public static ReadyToRunSectionType ThreadStaticRegion;
    public static ReadyToRunSectionType InterfaceDispatchTable;
    public static ReadyToRunSectionType TypeManagerIndirection;
    public static ReadyToRunSectionType EagerCctor;
    public static ReadyToRunSectionType FrozenObjectRegion;
    public static ReadyToRunSectionType GCStaticDesc;
    public static ReadyToRunSectionType ThreadStaticOffsetRegion;
    public static ReadyToRunSectionType ThreadStaticGCDescRegion;
    public static ReadyToRunSectionType ThreadStaticIndex;
    public static ReadyToRunSectionType LoopHijackFlag;
    public static ReadyToRunSectionType ImportAddressTables;
    public static ReadyToRunSectionType ReadonlyBlobRegionStart;
    public static ReadyToRunSectionType ReadonlyBlobRegionEnd;
}
internal enum Internal.Runtime.ReflectionMapBlob : Enum {
    public int value__;
    public static ReflectionMapBlob TypeMap;
    public static ReflectionMapBlob ArrayMap;
    public static ReflectionMapBlob GenericInstanceMap;
    public static ReflectionMapBlob GenericParameterMap;
    public static ReflectionMapBlob BlockReflectionTypeMap;
    public static ReflectionMapBlob InvokeMap;
    public static ReflectionMapBlob VirtualInvokeMap;
    public static ReflectionMapBlob CommonFixupsTable;
    public static ReflectionMapBlob FieldAccessMap;
    public static ReflectionMapBlob CCtorContextMap;
    public static ReflectionMapBlob DiagGenericInstanceMap;
    public static ReflectionMapBlob DiagGenericParameterMap;
    public static ReflectionMapBlob EmbeddedMetadata;
    public static ReflectionMapBlob DefaultConstructorMap;
    public static ReflectionMapBlob UnboxingAndInstantiatingStubMap;
    public static ReflectionMapBlob StructMarshallingStubMap;
    public static ReflectionMapBlob DelegateMarshallingStubMap;
    public static ReflectionMapBlob GenericVirtualMethodTable;
    public static ReflectionMapBlob InterfaceGenericVirtualMethodTable;
    public static ReflectionMapBlob TypeTemplateMap;
    public static ReflectionMapBlob GenericMethodsTemplateMap;
    public static ReflectionMapBlob DynamicInvokeTemplateData;
    public static ReflectionMapBlob BlobIdResourceIndex;
    public static ReflectionMapBlob BlobIdResourceData;
    public static ReflectionMapBlob BlobIdStackTraceEmbeddedMetadata;
    public static ReflectionMapBlob BlobIdStackTraceMethodRvaToTokenMapping;
    public static ReflectionMapBlob NativeLayoutInfo;
    public static ReflectionMapBlob NativeReferences;
    public static ReflectionMapBlob GenericsHashtable;
    public static ReflectionMapBlob NativeStatics;
    public static ReflectionMapBlob StaticsInfoHashtable;
    public static ReflectionMapBlob GenericMethodsHashtable;
    public static ReflectionMapBlob ExactMethodInstantiationsHashtable;
}
internal static class Internal.Runtime.StringComponentSize : object {
    public static int Value;
}
internal static class Internal.Runtime.UniversalGenericParameterLayout : object {
    public static bool IsLayoutDependentOnGenericInstantiation(TypeDesc type);
    private static bool IsLayoutDependentOnGenericInstantiation(TypeDesc type, HasVarsInvestigationLevel investigationLevel);
    public static bool MethodSignatureHasVarsNeedingCallingConventionConverter(MethodSignature methodSignature);
    public static bool VTableMethodRequiresCallingConventionConverter(MethodDesc method);
}
internal class Internal.Runtime.VirtualInvokeTableEntry : ValueType {
    public static int GenericVirtualMethod;
    public static int FlagsMask;
}
public class Internal.Text.Utf8String : ValueType {
    private Byte[] _value;
    public Byte[] UnderlyingArray { get; }
    public int Length { get; }
    public Utf8String(Byte[] underlyingArray);
    public Utf8String(string s);
    public Byte[] get_UnderlyingArray();
    public int get_Length();
    public static Utf8String op_Implicit(string s);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    private static int _rotl(int value, int shift);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Utf8String other);
    private static int Compare(Utf8String strA, Utf8String strB);
    public sealed virtual int CompareTo(Utf8String other);
}
public class Internal.Text.Utf8StringBuilder : object {
    private Byte[] _buffer;
    private int _length;
    public Byte[] UnderlyingArray { get; }
    public int Length { get; }
    public Byte[] get_UnderlyingArray();
    public int get_Length();
    public Utf8StringBuilder Clear();
    public Utf8StringBuilder Truncate(int newLength);
    public Utf8StringBuilder Append(Utf8String value);
    public Utf8StringBuilder Append(Byte[] value);
    public Utf8StringBuilder Append(char value);
    public Utf8StringBuilder Append(string value);
    public virtual string ToString();
    public string ToString(int start);
    public Utf8String ToUtf8String();
    private void Ensure(int extraSpace);
    private void Grow(int extraSpace);
    public int LastCharBoundary(int pos);
}
public class Internal.TypeSystem.Ecma.EcmaSignatureEncoder`1 : object {
    private TEntityHandleProvider _entityHandleProvider;
    public EcmaSignatureEncoder`1(TEntityHandleProvider entityHandleProvider);
    public void EncodeMethodSignature(BlobBuilder methodSignatureBlob, MethodSignature signature);
    public void EncodeTypeSignature(SignatureTypeEncoder encoder, TypeDesc type);
}
public interface Internal.TypeSystem.Ecma.IEntityHandleProvider {
    public abstract virtual EntityHandle GetTypeDefOrRefHandleForTypeDesc(TypeDesc type);
}
public class Internal.TypeSystem.TypesDebugInfo.ArrayTypeDescriptor : ValueType {
    public UInt32 Rank;
    public UInt32 ElementType;
    public UInt32 Size;
    public int IsMultiDimensional;
}
public class Internal.TypeSystem.TypesDebugInfo.ClassFieldsTypeDescriptor : ValueType {
    public ulong Size;
    public int FieldsCount;
}
public class Internal.TypeSystem.TypesDebugInfo.ClassTypeDescriptor : ValueType {
    public int IsStruct;
    public string Name;
    public UInt32 BaseClassId;
    public ulong InstanceSize;
}
public class Internal.TypeSystem.TypesDebugInfo.DataFieldDescriptor : ValueType {
    public UInt32 FieldTypeIndex;
    public ulong Offset;
    public string Name;
}
internal class Internal.TypeSystem.TypesDebugInfo.DebugInfoBlob : object {
    private ArrayBuilder`1<byte> _data;
    public Byte[] ToArray();
    public UInt32 Size();
    public UInt32 DWORDAlignedSize(UInt32 size);
    public void AlignToDWORD();
    public void SetWORDAtBlobIndex(UInt32 blobIndex, ushort src);
    public void SetDWORDAtBlobIndex(UInt32 blobIndex, UInt32 src);
    public void WriteBYTE(byte src);
    public void WriteWORD(ushort src);
    public void WriteDWORD(UInt32 src);
    public void WriteString(Utf8String utf8String);
    public void WriteString(string str);
    public void WriteBuffer(Byte[] data);
    public void WriteBuffer(DebugInfoBlob debugInfoBlob);
    public void WriteBuffer(BlobBuilder blobBuilder);
    public void WriteBuffer(Byte[] data, int index, int length);
    public void WriteQWORD(ulong src);
    public static UInt32 StringLengthEncoded(Utf8String str);
}
internal class Internal.TypeSystem.TypesDebugInfo.DebugInfoWriter : object {
    private TypeRecordsBlob _blob;
    private UInt32 _tiVTShapePointer;
    public void VerifyBlobEligibleToBeBetweenRecords();
    private FieldListInProgress StartFieldList();
    private void FinalizeFieldList(FieldListInProgress fieldListInProgress);
    private void ExtendFieldList(FieldListInProgress& fieldListInProgress, UInt32 newDataLength, Boolean& mustSkipEmission);
    private void EmitBaseClass(FieldListInProgress& fieldListInProgress, UInt32 baseClassIndex);
    private void EmitDataMember(FieldListInProgress& fieldListInProgress, UInt32 type, int offset, Utf8String name);
    private void EmitEnumerate(FieldListInProgress& fieldListInProgress, ulong value, Utf8String name);
    private UInt32 EmitVFuncTableShapeDebugType();
    private void EmitVFuncTab(FieldListInProgress& fieldListInProgress);
    public UInt32 GetClassTypeIndex(ClassTypeDescriptor classTypeDescriptor);
    public UInt32 GetCompleteClassTypeIndex(ClassTypeDescriptor classTypeDescriptor, ClassFieldsTypeDescriptor classFieldsTypeDescriptior, DataFieldDescriptor[] fields, StaticDataFieldDescriptor[] statics);
    public UInt32 GetEnumTypeIndex(EnumTypeDescriptor enumTypeDescriptor, EnumRecordTypeDescriptor[] enumerates);
    public UInt32 GetArgListTypeDescriptor(UInt32[] arguments);
    public UInt32 GetMemberFunctionTypeIndex(MemberFunctionTypeDescriptor memberDescriptor, UInt32[] arguments);
    public UInt32 GetMemberFunctionId(MemberFunctionIdTypeDescriptor memberIdDescriptor);
    public UInt32 GetPointerTypeIndex(PointerTypeDescriptor pointerTypeDescriptor);
    public UInt32 GetSimpleArrayTypeIndex(UInt32 elementType, UInt32 elementSize);
    public UInt32 GetArrayTypeIndex(ClassTypeDescriptor classDescriptor, ArrayTypeDescriptor arrayTypeDescriptor, int targetPointerSize);
    public DebugInfoBlob GetRawBlob();
}
public class Internal.TypeSystem.TypesDebugInfo.EnumRecordTypeDescriptor : ValueType {
    public ulong Value;
    public string Name;
}
public class Internal.TypeSystem.TypesDebugInfo.EnumTypeDescriptor : ValueType {
    public UInt32 ElementType;
    public ulong ElementCount;
    public string Name;
}
public interface Internal.TypeSystem.TypesDebugInfo.ITypesDebugInfoWriter {
    public abstract virtual UInt32 GetEnumTypeIndex(EnumTypeDescriptor enumTypeDescriptor, EnumRecordTypeDescriptor[] typeRecords);
    public abstract virtual UInt32 GetClassTypeIndex(ClassTypeDescriptor classTypeDescriptor);
    public abstract virtual UInt32 GetCompleteClassTypeIndex(ClassTypeDescriptor classTypeDescriptor, ClassFieldsTypeDescriptor classFieldsTypeDescriptor, DataFieldDescriptor[] fields, StaticDataFieldDescriptor[] statics);
    public abstract virtual UInt32 GetArrayTypeIndex(ClassTypeDescriptor classDescriptor, ArrayTypeDescriptor arrayTypeDescriprtor);
    public abstract virtual UInt32 GetPointerTypeIndex(PointerTypeDescriptor pointerDescriptor);
    public abstract virtual UInt32 GetMemberFunctionTypeIndex(MemberFunctionTypeDescriptor memberDescriptor, UInt32[] argumentTypes);
    public abstract virtual UInt32 GetMemberFunctionId(MemberFunctionIdTypeDescriptor memberIdDescriptor);
    public abstract virtual UInt32 GetPrimitiveTypeIndex(TypeDesc type);
    public abstract virtual string GetMangledName(TypeDesc type);
}
public class Internal.TypeSystem.TypesDebugInfo.MemberFunctionIdTypeDescriptor : ValueType {
    public UInt32 MemberFunction;
    public UInt32 ParentClass;
    public string Name;
}
public class Internal.TypeSystem.TypesDebugInfo.MemberFunctionTypeDescriptor : ValueType {
    public UInt32 ReturnType;
    public UInt32 ContainingClass;
    public UInt32 TypeIndexOfThisPointer;
    public UInt32 ThisAdjust;
    public UInt32 CallingConvention;
    public ushort NumberOfArguments;
}
public class Internal.TypeSystem.TypesDebugInfo.PointerTypeDescriptor : ValueType {
    public UInt32 ElementType;
    public int IsReference;
    public int IsConst;
    public int Is64Bit;
}
public class Internal.TypeSystem.TypesDebugInfo.PrimitiveTypeDescriptor : object {
    public static UInt32 GetPrimitiveTypeIndex(TypeDesc type);
}
public class Internal.TypeSystem.TypesDebugInfo.StaticDataFieldDescriptor : ValueType {
    public string StaticDataName;
    public ulong StaticOffset;
    public int IsStaticDataInObject;
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _items;
    private int _count;
    public int Count { get; }
    public T Item { get; public set; }
    public T[] ToArray();
    public void Add(T item);
    public void Append(T[] newItems);
    public void Append(T[] newItems, int offset, int length);
    public void Append(ArrayBuilder`1<T> newItems);
    public void ZeroExtend(int numItems);
    public void EnsureCapacity(int requestedCapacity);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public bool Contains(T t);
}
[ExtensionAttribute]
internal static class System.FormattingHelpers : object {
    [ExtensionAttribute]
public static string ToStringInvariant(T value);
    [ExtensionAttribute]
public static string ToStringInvariant(T value, string format);
}
