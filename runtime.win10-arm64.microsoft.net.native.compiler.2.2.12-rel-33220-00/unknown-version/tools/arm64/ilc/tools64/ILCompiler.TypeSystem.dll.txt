[FlagsAttribute]
public enum Internal.IL.DelegateFeature : Enum {
    public int value__;
    public static DelegateFeature DynamicInvoke;
    public static DelegateFeature ObjectArrayThunk;
}
public class Internal.IL.DelegateInfo : object {
    private TypeDesc _delegateType;
    private DelegateFeature _supportedFeatures;
    private MethodSignature _signature;
    private MethodDesc _getThunkMethod;
    private DelegateThunkCollection _thunks;
    public IEnumerable`1<MethodDesc> Methods { get; }
    public DelegateThunkCollection Thunks { get; }
    public MethodSignature Signature { get; }
    public DelegateFeature SupportedFeatures { get; }
    public TypeDesc Type { get; }
    public DelegateInfo(TypeDesc delegateType, DelegateFeature features);
    public static bool SupportsDynamicInvoke(TypeSystemContext context);
    [IteratorStateMachineAttribute("Internal.IL.DelegateInfo/<get_Methods>d__7")]
public IEnumerable`1<MethodDesc> get_Methods();
    public DelegateThunkCollection get_Thunks();
    public MethodSignature get_Signature();
    public DelegateFeature get_SupportedFeatures();
    public TypeDesc get_Type();
}
[DefaultMemberAttribute("Item")]
public class Internal.IL.DelegateThunkCollection : object {
    public static DelegateThunkKind MaxThunkKind;
    private MethodDesc _openStaticThunk;
    private MethodDesc _multicastThunk;
    private MethodDesc _closedStaticThunk;
    private MethodDesc _invokeThunk;
    private MethodDesc _closedInstanceOverGeneric;
    private MethodDesc _reversePInvokeThunk;
    private MethodDesc _invokeObjectArrayThunk;
    private MethodDesc _openInstanceThunk;
    public MethodDesc Item { get; }
    internal DelegateThunkCollection(DelegateInfo owningDelegate);
    private static bool IsNativeCallingConventionCompatible(MethodSignature delegateSignature);
    private static bool IsNativeCallingConventionCompatible(TypeDesc type);
    public MethodDesc get_Item(DelegateThunkKind kind);
}
public enum Internal.IL.DelegateThunkKind : Enum {
    public int value__;
    public static DelegateThunkKind MulticastThunk;
    public static DelegateThunkKind ClosedStaticThunk;
    public static DelegateThunkKind OpenStaticThunk;
    public static DelegateThunkKind ClosedInstanceThunkOverGenericMethod;
    public static DelegateThunkKind DelegateInvokeThunk;
    public static DelegateThunkKind OpenInstanceThunk;
    public static DelegateThunkKind ReversePinvokeThunk;
    public static DelegateThunkKind ObjectArrayThunk;
}
public class Internal.IL.EcmaMethodDebugInformation : MethodDebugInformation {
    private EcmaMethod _method;
    public EcmaMethodDebugInformation(EcmaMethod method);
    public virtual IEnumerable`1<ILSequencePoint> GetSequencePoints();
    public virtual IEnumerable`1<ILLocalVariable> GetLocalVariables();
    [IteratorStateMachineAttribute("Internal.IL.EcmaMethodDebugInformation/<GetParameterNames>d__4")]
public virtual IEnumerable`1<string> GetParameterNames();
}
public class Internal.IL.EcmaMethodIL : MethodIL {
    private EcmaModule _module;
    private EcmaMethod _method;
    private MethodBodyBlock _methodBody;
    private Byte[] _ilBytes;
    private LocalVariableDefinition[] _locals;
    private ILExceptionRegion[] _ilExceptionRegions;
    public MethodDesc OwningMethod { get; }
    public bool IsInitLocals { get; }
    public int MaxStack { get; }
    private EcmaMethodIL(EcmaMethod method, int rva);
    public static EcmaMethodIL Create(EcmaMethod method);
    public virtual MethodDesc get_OwningMethod();
    public virtual Byte[] GetILBytes();
    public virtual bool get_IsInitLocals();
    public virtual int get_MaxStack();
    public virtual LocalVariableDefinition[] GetLocals();
    public virtual ILExceptionRegion[] GetExceptionRegions();
    public virtual object GetObject(int token);
    public virtual MethodDebugInformation GetDebugInfo();
}
[ExtensionAttribute]
internal static class Internal.IL.HelperExtensions : object {
    [ExtensionAttribute]
public static MetadataType GetHelperType(TypeSystemContext context, string name);
    [ExtensionAttribute]
public static MethodDesc GetHelperEntryPoint(TypeSystemContext context, string typeName, string methodName);
    [ExtensionAttribute]
public static void EmitCallThrowHelper(ILCodeStream codeStream, ILEmitter emitter, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc GetKnownMethod(TypeDesc type, string name, MethodSignature signature);
    [ExtensionAttribute]
public static FieldDesc GetKnownField(TypeDesc type, string name);
    [ExtensionAttribute]
public static MetadataType GetKnownNestedType(MetadataType type, string name);
    [ExtensionAttribute]
public static MetadataType GetKnownType(ModuleDesc module, string namespace, string name);
}
public class Internal.IL.ILDisassembler : ValueType {
    private Byte[] _ilBytes;
    private MethodIL _methodIL;
    private ILTypeNameFormatter _typeNameFormatter;
    private int _currentOffset;
    private ILTypeNameFormatter TypeNameFormatter { get; }
    public bool HasNextInstruction { get; }
    public int Offset { get; }
    public int CodeSize { get; }
    public ILDisassembler(MethodIL methodIL);
    private ILTypeNameFormatter get_TypeNameFormatter();
    public void AppendType(StringBuilder sb, TypeDesc type, bool forceValueClassPrefix);
    private void AppendOwningType(StringBuilder sb, TypeDesc type);
    private void AppendMethodSignature(StringBuilder sb, MethodDesc method);
    private void AppendMethodSignature(StringBuilder sb, MethodSignature signature);
    private void AppendSignaturePrefix(StringBuilder sb, MethodSignature signature);
    private void AppendSignatureArgumentList(StringBuilder sb, MethodSignature signature);
    private void AppendFieldSignature(StringBuilder sb, FieldDesc field);
    private void AppendStringLiteral(StringBuilder sb, string s);
    private void AppendToken(StringBuilder sb, int token);
    private byte ReadILByte();
    private ushort ReadILUInt16();
    private UInt32 ReadILUInt32();
    private int ReadILToken();
    private ulong ReadILUInt64();
    private float ReadILFloat();
    private double ReadILDouble();
    public static void AppendOffset(StringBuilder sb, int offset);
    private static void PadForInstructionArgument(StringBuilder sb);
    public bool get_HasNextInstruction();
    public int get_Offset();
    public int get_CodeSize();
    public string GetNextInstruction();
}
public class Internal.IL.ILExceptionRegion : ValueType {
    public ILExceptionRegionKind Kind;
    public int TryOffset;
    public int TryLength;
    public int HandlerOffset;
    public int HandlerLength;
    public int ClassToken;
    public int FilterOffset;
    public ILExceptionRegion(ILExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int classToken, int filterOffset);
}
public enum Internal.IL.ILExceptionRegionKind : Enum {
    public int value__;
    public static ILExceptionRegionKind Catch;
    public static ILExceptionRegionKind Filter;
    public static ILExceptionRegionKind Finally;
    public static ILExceptionRegionKind Fault;
}
public class Internal.IL.ILLocalVariable : ValueType {
    public int Slot;
    public string Name;
    public bool CompilerGenerated;
    public ILLocalVariable(int slot, string name, bool compilerGenerated);
}
public enum Internal.IL.ILOpcode : Enum {
    public int value__;
    public static ILOpcode nop;
    public static ILOpcode break_;
    public static ILOpcode ldarg_0;
    public static ILOpcode ldarg_1;
    public static ILOpcode ldarg_2;
    public static ILOpcode ldarg_3;
    public static ILOpcode ldloc_0;
    public static ILOpcode ldloc_1;
    public static ILOpcode ldloc_2;
    public static ILOpcode ldloc_3;
    public static ILOpcode stloc_0;
    public static ILOpcode stloc_1;
    public static ILOpcode stloc_2;
    public static ILOpcode stloc_3;
    public static ILOpcode ldarg_s;
    public static ILOpcode ldarga_s;
    public static ILOpcode starg_s;
    public static ILOpcode ldloc_s;
    public static ILOpcode ldloca_s;
    public static ILOpcode stloc_s;
    public static ILOpcode ldnull;
    public static ILOpcode ldc_i4_m1;
    public static ILOpcode ldc_i4_0;
    public static ILOpcode ldc_i4_1;
    public static ILOpcode ldc_i4_2;
    public static ILOpcode ldc_i4_3;
    public static ILOpcode ldc_i4_4;
    public static ILOpcode ldc_i4_5;
    public static ILOpcode ldc_i4_6;
    public static ILOpcode ldc_i4_7;
    public static ILOpcode ldc_i4_8;
    public static ILOpcode ldc_i4_s;
    public static ILOpcode ldc_i4;
    public static ILOpcode ldc_i8;
    public static ILOpcode ldc_r4;
    public static ILOpcode ldc_r8;
    public static ILOpcode dup;
    public static ILOpcode pop;
    public static ILOpcode jmp;
    public static ILOpcode call;
    public static ILOpcode calli;
    public static ILOpcode ret;
    public static ILOpcode br_s;
    public static ILOpcode brfalse_s;
    public static ILOpcode brtrue_s;
    public static ILOpcode beq_s;
    public static ILOpcode bge_s;
    public static ILOpcode bgt_s;
    public static ILOpcode ble_s;
    public static ILOpcode blt_s;
    public static ILOpcode bne_un_s;
    public static ILOpcode bge_un_s;
    public static ILOpcode bgt_un_s;
    public static ILOpcode ble_un_s;
    public static ILOpcode blt_un_s;
    public static ILOpcode br;
    public static ILOpcode brfalse;
    public static ILOpcode brtrue;
    public static ILOpcode beq;
    public static ILOpcode bge;
    public static ILOpcode bgt;
    public static ILOpcode ble;
    public static ILOpcode blt;
    public static ILOpcode bne_un;
    public static ILOpcode bge_un;
    public static ILOpcode bgt_un;
    public static ILOpcode ble_un;
    public static ILOpcode blt_un;
    public static ILOpcode switch_;
    public static ILOpcode ldind_i1;
    public static ILOpcode ldind_u1;
    public static ILOpcode ldind_i2;
    public static ILOpcode ldind_u2;
    public static ILOpcode ldind_i4;
    public static ILOpcode ldind_u4;
    public static ILOpcode ldind_i8;
    public static ILOpcode ldind_i;
    public static ILOpcode ldind_r4;
    public static ILOpcode ldind_r8;
    public static ILOpcode ldind_ref;
    public static ILOpcode stind_ref;
    public static ILOpcode stind_i1;
    public static ILOpcode stind_i2;
    public static ILOpcode stind_i4;
    public static ILOpcode stind_i8;
    public static ILOpcode stind_r4;
    public static ILOpcode stind_r8;
    public static ILOpcode add;
    public static ILOpcode sub;
    public static ILOpcode mul;
    public static ILOpcode div;
    public static ILOpcode div_un;
    public static ILOpcode rem;
    public static ILOpcode rem_un;
    public static ILOpcode and;
    public static ILOpcode or;
    public static ILOpcode xor;
    public static ILOpcode shl;
    public static ILOpcode shr;
    public static ILOpcode shr_un;
    public static ILOpcode neg;
    public static ILOpcode not;
    public static ILOpcode conv_i1;
    public static ILOpcode conv_i2;
    public static ILOpcode conv_i4;
    public static ILOpcode conv_i8;
    public static ILOpcode conv_r4;
    public static ILOpcode conv_r8;
    public static ILOpcode conv_u4;
    public static ILOpcode conv_u8;
    public static ILOpcode callvirt;
    public static ILOpcode cpobj;
    public static ILOpcode ldobj;
    public static ILOpcode ldstr;
    public static ILOpcode newobj;
    public static ILOpcode castclass;
    public static ILOpcode isinst;
    public static ILOpcode conv_r_un;
    public static ILOpcode unbox;
    public static ILOpcode throw_;
    public static ILOpcode ldfld;
    public static ILOpcode ldflda;
    public static ILOpcode stfld;
    public static ILOpcode ldsfld;
    public static ILOpcode ldsflda;
    public static ILOpcode stsfld;
    public static ILOpcode stobj;
    public static ILOpcode conv_ovf_i1_un;
    public static ILOpcode conv_ovf_i2_un;
    public static ILOpcode conv_ovf_i4_un;
    public static ILOpcode conv_ovf_i8_un;
    public static ILOpcode conv_ovf_u1_un;
    public static ILOpcode conv_ovf_u2_un;
    public static ILOpcode conv_ovf_u4_un;
    public static ILOpcode conv_ovf_u8_un;
    public static ILOpcode conv_ovf_i_un;
    public static ILOpcode conv_ovf_u_un;
    public static ILOpcode box;
    public static ILOpcode newarr;
    public static ILOpcode ldlen;
    public static ILOpcode ldelema;
    public static ILOpcode ldelem_i1;
    public static ILOpcode ldelem_u1;
    public static ILOpcode ldelem_i2;
    public static ILOpcode ldelem_u2;
    public static ILOpcode ldelem_i4;
    public static ILOpcode ldelem_u4;
    public static ILOpcode ldelem_i8;
    public static ILOpcode ldelem_i;
    public static ILOpcode ldelem_r4;
    public static ILOpcode ldelem_r8;
    public static ILOpcode ldelem_ref;
    public static ILOpcode stelem_i;
    public static ILOpcode stelem_i1;
    public static ILOpcode stelem_i2;
    public static ILOpcode stelem_i4;
    public static ILOpcode stelem_i8;
    public static ILOpcode stelem_r4;
    public static ILOpcode stelem_r8;
    public static ILOpcode stelem_ref;
    public static ILOpcode ldelem;
    public static ILOpcode stelem;
    public static ILOpcode unbox_any;
    public static ILOpcode conv_ovf_i1;
    public static ILOpcode conv_ovf_u1;
    public static ILOpcode conv_ovf_i2;
    public static ILOpcode conv_ovf_u2;
    public static ILOpcode conv_ovf_i4;
    public static ILOpcode conv_ovf_u4;
    public static ILOpcode conv_ovf_i8;
    public static ILOpcode conv_ovf_u8;
    public static ILOpcode refanyval;
    public static ILOpcode ckfinite;
    public static ILOpcode mkrefany;
    public static ILOpcode ldtoken;
    public static ILOpcode conv_u2;
    public static ILOpcode conv_u1;
    public static ILOpcode conv_i;
    public static ILOpcode conv_ovf_i;
    public static ILOpcode conv_ovf_u;
    public static ILOpcode add_ovf;
    public static ILOpcode add_ovf_un;
    public static ILOpcode mul_ovf;
    public static ILOpcode mul_ovf_un;
    public static ILOpcode sub_ovf;
    public static ILOpcode sub_ovf_un;
    public static ILOpcode endfinally;
    public static ILOpcode leave;
    public static ILOpcode leave_s;
    public static ILOpcode stind_i;
    public static ILOpcode conv_u;
    public static ILOpcode prefix1;
    public static ILOpcode arglist;
    public static ILOpcode ceq;
    public static ILOpcode cgt;
    public static ILOpcode cgt_un;
    public static ILOpcode clt;
    public static ILOpcode clt_un;
    public static ILOpcode ldftn;
    public static ILOpcode ldvirtftn;
    public static ILOpcode ldarg;
    public static ILOpcode ldarga;
    public static ILOpcode starg;
    public static ILOpcode ldloc;
    public static ILOpcode ldloca;
    public static ILOpcode stloc;
    public static ILOpcode localloc;
    public static ILOpcode endfilter;
    public static ILOpcode unaligned;
    public static ILOpcode volatile_;
    public static ILOpcode tail;
    public static ILOpcode initobj;
    public static ILOpcode constrained;
    public static ILOpcode cpblk;
    public static ILOpcode initblk;
    public static ILOpcode no;
    public static ILOpcode rethrow;
    public static ILOpcode sizeof_;
    public static ILOpcode refanytype;
    public static ILOpcode readonly_;
}
[ExtensionAttribute]
public static class Internal.IL.ILOpcodeHelper : object {
    private static byte VariableSize;
    private static byte Invalid;
    private static Byte[] s_opcodeSizes;
    private static ILOpcodeHelper();
    [ExtensionAttribute]
public static int GetSize(ILOpcode opcode);
    [ExtensionAttribute]
public static bool IsValid(ILOpcode opcode);
}
public class Internal.IL.ILSequencePoint : ValueType {
    public int Offset;
    public string Document;
    public int LineNumber;
    public ILSequencePoint(int offset, string document, int lineNumber);
}
[ExtensionAttribute]
public static class Internal.IL.ILStackHelper : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void CheckStackBalance(MethodIL methodIL);
    [ExtensionAttribute]
public static int ComputeMaxStack(MethodIL methodIL);
    private static int ReadInt32(Byte[] ilBytes, int offset);
    private static int ReadILToken(Byte[] ilBytes, int offset);
}
public class Internal.IL.InstantiatedMethodIL : MethodIL {
    private MethodDesc _method;
    private MethodIL _methodIL;
    private Instantiation _typeInstantiation;
    private Instantiation _methodInstantiation;
    public MethodDesc OwningMethod { get; }
    public int MaxStack { get; }
    public bool IsInitLocals { get; }
    public InstantiatedMethodIL(MethodDesc owningMethod, MethodIL methodIL);
    public virtual MethodDebugInformation GetDebugInfo();
    public virtual MethodDesc get_OwningMethod();
    public virtual Byte[] GetILBytes();
    public virtual int get_MaxStack();
    public virtual ILExceptionRegion[] GetExceptionRegions();
    public virtual bool get_IsInitLocals();
    public virtual LocalVariableDefinition[] GetLocals();
    public virtual object GetObject(int token);
    public virtual MethodIL GetMethodILDefinition();
}
public class Internal.IL.MethodDebugInformation : object {
    public static MethodDebugInformation None;
    private static MethodDebugInformation();
    public virtual IEnumerable`1<ILSequencePoint> GetSequencePoints();
    public virtual IEnumerable`1<ILLocalVariable> GetLocalVariables();
    public virtual IEnumerable`1<string> GetParameterNames();
}
[DebuggerTypeProxyAttribute("Internal.IL.MethodILDebugView")]
public abstract class Internal.IL.MethodIL : object {
    public MethodDesc OwningMethod { get; }
    public int MaxStack { get; }
    public bool IsInitLocals { get; }
    public abstract virtual MethodDesc get_OwningMethod();
    public abstract virtual int get_MaxStack();
    public abstract virtual bool get_IsInitLocals();
    public abstract virtual Byte[] GetILBytes();
    public abstract virtual LocalVariableDefinition[] GetLocals();
    public abstract virtual object GetObject(int token);
    public abstract virtual ILExceptionRegion[] GetExceptionRegions();
    public virtual MethodIL GetMethodILDefinition();
    public virtual string ToString();
    public virtual MethodDebugInformation GetDebugInfo();
}
internal class Internal.IL.MethodILDebugView : object {
    private MethodIL _methodIL;
    public string Disassembly { get; }
    public MethodILDebugView(MethodIL methodIL);
    public string get_Disassembly();
}
public class Internal.IL.PInvokeILEmitterConfiguration : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ForceLazyResolution>k__BackingField;
    public Nullable`1<bool> ForceLazyResolution { get; private set; }
    public PInvokeILEmitterConfiguration(Nullable`1<bool> forceLazyResolution);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ForceLazyResolution();
    [CompilerGeneratedAttribute]
private void set_ForceLazyResolution(Nullable`1<bool> value);
}
public class Internal.IL.Stubs.CalliMarshallingMethodThunk : ILStubMethod {
    private MethodSignature _targetSignature;
    private InteropStateManager _interopStateManager;
    private TypeDesc _owningType;
    private MethodSignature _signature;
    public MethodSignature TargetSignature { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public bool IsPInvoke { get; }
    private MethodSignature Internal.TypeSystem.IPrefixMangledSignature.BaseSignature { get; }
    private string Internal.TypeSystem.IPrefixMangledSignature.Prefix { get; }
    protected internal int ClassCode { get; }
    public CalliMarshallingMethodThunk(MethodSignature targetSignature, TypeDesc owningType, InteropStateManager interopStateManager);
    public MethodSignature get_TargetSignature();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool get_IsPInvoke();
    public virtual MethodIL EmitIL();
    private sealed virtual override MethodSignature Internal.TypeSystem.IPrefixMangledSignature.get_BaseSignature();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledSignature.get_Prefix();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
[ExtensionAttribute]
public static class Internal.IL.Stubs.DebuggerSteppingHelpers : object {
    [ExtensionAttribute]
public static void MarkDebuggerStepThroughPoint(ILCodeStream codeStream);
    [ExtensionAttribute]
public static void MarkDebuggerStepInPoint(ILCodeStream codeStream);
}
public class Internal.IL.Stubs.DelegateGetThunkMethodOverride : ILStubMethod {
    private DelegateInfo _delegateInfo;
    private MethodSignature _signature;
    protected internal int ClassCode { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public string Name { get; }
    internal DelegateGetThunkMethodOverride(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual MethodIL EmitIL();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateInvokeClosedStaticThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateInvokeClosedStaticThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateInvokeInstanceClosedOverGenericMethodThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateInvokeInstanceClosedOverGenericMethodThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateInvokeMulticastThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateInvokeMulticastThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateInvokeObjectArrayThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateInvokeObjectArrayThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateInvokeOpenInstanceThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateInvokeOpenInstanceThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateInvokeOpenStaticThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateInvokeOpenStaticThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public class Internal.IL.Stubs.DelegateMarshallingMethodThunk : ILStubMethod {
    private TypeDesc _owningType;
    private MetadataType _delegateType;
    private InteropStateManager _interopStateManager;
    private MethodDesc _invokeMethod;
    private MethodSignature _signature;
    [CompilerGeneratedAttribute]
private DelegateMarshallingMethodThunkKind <Kind>k__BackingField;
    public DelegateMarshallingMethodThunkKind Kind { get; }
    public bool IsPInvoke { get; }
    public MarshalDirection Direction { get; }
    public TypeSystemContext Context { get; }
    public bool IsNativeCallable { get; }
    public TypeDesc OwningType { get; }
    public MetadataType DelegateType { get; }
    public MethodSignature Signature { get; }
    public MethodSignature DelegateSignature { get; }
    private string NamePrefix { get; }
    public string Name { get; }
    private TypeDesc Internal.TypeSystem.IPrefixMangledType.BaseType { get; }
    private string Internal.TypeSystem.IPrefixMangledType.Prefix { get; }
    protected internal int ClassCode { get; }
    public DelegateMarshallingMethodThunk(MetadataType delegateType, TypeDesc owningType, InteropStateManager interopStateManager, DelegateMarshallingMethodThunkKind kind);
    [CompilerGeneratedAttribute]
public DelegateMarshallingMethodThunkKind get_Kind();
    public virtual bool get_IsPInvoke();
    public MarshalDirection get_Direction();
    public virtual TypeSystemContext get_Context();
    public virtual bool get_IsNativeCallable();
    public virtual TypeDesc get_OwningType();
    public MetadataType get_DelegateType();
    private TypeDesc GetNativeMethodParameterType(TypeDesc managedType, MarshalAsDescriptor marshalAs, InteropStateManager interopStateManager, bool isReturn, bool isAnsi);
    public virtual MethodSignature get_Signature();
    public virtual ParameterMetadata[] GetParameterMetadata();
    public virtual PInvokeMetadata GetPInvokeMethodMetadata();
    public MethodSignature get_DelegateSignature();
    private string get_NamePrefix();
    public virtual string get_Name();
    public virtual MethodIL EmitIL();
    private sealed virtual override TypeDesc Internal.TypeSystem.IPrefixMangledType.get_BaseType();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledType.get_Prefix();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public enum Internal.IL.Stubs.DelegateMarshallingMethodThunkKind : Enum {
    public byte value__;
    public static DelegateMarshallingMethodThunkKind ReverseOpenStatic;
    public static DelegateMarshallingMethodThunkKind ReverseClosed;
    public static DelegateMarshallingMethodThunkKind ForwardNativeFunctionWrapper;
}
public class Internal.IL.Stubs.DelegateReversePInvokeThunk : DelegateThunk {
    protected internal int ClassCode { get; }
    public string Name { get; }
    internal DelegateReversePInvokeThunk(DelegateInfo delegateInfo);
    protected internal virtual int get_ClassCode();
    public virtual MethodIL EmitIL();
    public virtual string get_Name();
}
public abstract class Internal.IL.Stubs.DelegateThunk : ILStubMethod {
    private DelegateInfo _delegateInfo;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    protected TypeDesc SystemDelegateType { get; }
    protected FieldDesc ExtraFunctionPointerOrDataField { get; }
    protected FieldDesc HelperObjectField { get; }
    protected FieldDesc FirstParameterField { get; }
    protected FieldDesc FunctionPointerField { get; }
    public DelegateThunk(DelegateInfo delegateInfo);
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public sealed virtual TypeSystemContext get_Context();
    public sealed virtual TypeDesc get_OwningType();
    public sealed virtual MethodSignature get_Signature();
    public sealed virtual Instantiation get_Instantiation();
    protected TypeDesc get_SystemDelegateType();
    protected FieldDesc get_ExtraFunctionPointerOrDataField();
    protected FieldDesc get_HelperObjectField();
    protected FieldDesc get_FirstParameterField();
    protected FieldDesc get_FunctionPointerField();
}
internal enum Internal.IL.Stubs.DynamicInvokeMethodParameterKind : Enum {
    public int value__;
    public static DynamicInvokeMethodParameterKind None;
    public static DynamicInvokeMethodParameterKind Value;
    public static DynamicInvokeMethodParameterKind Reference;
    public static DynamicInvokeMethodParameterKind Pointer;
}
[DefaultMemberAttribute("Item")]
public class Internal.IL.Stubs.DynamicInvokeMethodSignature : ValueType {
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public bool HasReturnValue { get; }
    public int Length { get; }
    internal DynamicInvokeMethodParameterKind Item { get; }
    internal DynamicInvokeMethodParameterKind ReturnType { get; }
    public DynamicInvokeMethodSignature(MethodSignature concreteSignature);
    public TypeSystemContext get_Context();
    public bool get_HasReturnValue();
    public int get_Length();
    internal DynamicInvokeMethodParameterKind get_Item(int index);
    public static int GetNumberOfIndirections(TypeDesc type);
    public int GetNumberOfParameterPointerIndirections(int paramIndex);
    public int GetNumerOfReturnTypePointerIndirections();
    internal DynamicInvokeMethodParameterKind get_ReturnType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(DynamicInvokeMethodSignature other);
}
public class Internal.IL.Stubs.DynamicInvokeMethodThunk : ILStubMethod {
    private TypeDesc _owningType;
    private DynamicInvokeMethodSignature _targetSignature;
    private TypeDesc[] _instantiation;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    private MetadataType InvokeUtilsType { get; }
    private MetadataType ArgSetupStateType { get; }
    public DynamicInvokeMethodSignature TargetSignature { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public string Name { get; }
    protected internal int ClassCode { get; }
    public DynamicInvokeMethodThunk(TypeDesc owningType, DynamicInvokeMethodSignature signature);
    internal static bool SupportsDynamicInvoke(TypeSystemContext context);
    private static TypeDesc UnwrapByRef(TypeDesc type);
    public static bool SupportsSignature(MethodSignature signature);
    public static TypeDesc[] GetThunkInstantiationForMethod(MethodDesc method);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private MetadataType get_InvokeUtilsType();
    private MetadataType get_ArgSetupStateType();
    public DynamicInvokeMethodSignature get_TargetSignature();
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual string get_Name();
    public virtual MethodIL EmitIL();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    private int CompareTo(DynamicInvokeMethodThunk otherMethod);
}
internal class Internal.IL.Stubs.EnumEqualsThunk : ILStubMethod {
    private TypeDesc _owningType;
    private MethodSignature _signature;
    private MethodDesc ObjectEqualsMethod { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public bool IsVirtual { get; }
    protected internal int ClassCode { get; }
    public EnumEqualsThunk(TypeDesc owningType);
    private MethodDesc get_ObjectEqualsMethod();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool get_IsVirtual();
    public virtual MethodIL EmitIL();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
internal class Internal.IL.Stubs.EnumGetHashCodeThunk : ILStubMethod {
    private TypeDesc _owningType;
    private MethodSignature _signature;
    private MethodDesc ObjectGetHashCodeMethod { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public bool IsVirtual { get; }
    protected internal int ClassCode { get; }
    public EnumGetHashCodeThunk(TypeDesc owningType);
    private MethodDesc get_ObjectGetHashCodeMethod();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool get_IsVirtual();
    public virtual MethodIL EmitIL();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public class Internal.IL.Stubs.ForwardDelegateCreationThunk : ILStubMethod {
    private TypeDesc _owningType;
    private MetadataType _delegateType;
    private InteropStateManager _interopStateManager;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public bool IsNativeCallable { get; }
    public TypeDesc OwningType { get; }
    public MetadataType DelegateType { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    private TypeDesc Internal.TypeSystem.IPrefixMangledType.BaseType { get; }
    private string Internal.TypeSystem.IPrefixMangledType.Prefix { get; }
    protected internal int ClassCode { get; }
    public ForwardDelegateCreationThunk(MetadataType delegateType, TypeDesc owningType, InteropStateManager interopStateManager);
    public virtual TypeSystemContext get_Context();
    public virtual bool get_IsNativeCallable();
    public virtual TypeDesc get_OwningType();
    public MetadataType get_DelegateType();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual MethodIL EmitIL();
    private sealed virtual override TypeDesc Internal.TypeSystem.IPrefixMangledType.get_BaseType();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledType.get_Prefix();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public class Internal.IL.Stubs.ILCodeLabel : object {
    private ILCodeStream _codeStream;
    private int _offsetWithinCodeStream;
    internal bool IsPlaced { get; }
    internal int AbsoluteOffset { get; }
    internal bool get_IsPlaced();
    internal int get_AbsoluteOffset();
    internal void Place(ILCodeStream codeStream, int offsetWithinCodeStream);
}
public class Internal.IL.Stubs.ILCodeStream : object {
    internal Byte[] _instructions;
    internal int _length;
    internal int _startOffsetForLinking;
    internal ArrayBuilder`1<ILSequencePoint> _sequencePoints;
    private ArrayBuilder`1<LabelAndOffset> _offsetsNeedingPatching;
    private ILEmitter _emitter;
    internal ILCodeStream(ILEmitter emitter);
    private void EmitByte(byte b);
    private void EmitUInt16(ushort value);
    private void EmitUInt32(int value);
    public void Emit(ILOpcode opcode);
    public void Emit(ILOpcode opcode, ILToken token);
    public void EmitLdc(int value);
    public void EmitLdArg(int index);
    public void EmitLdArga(int index);
    public void EmitLdLoc(ILLocalVariable variable);
    public void EmitLdLoca(ILLocalVariable variable);
    public void EmitStLoc(ILLocalVariable variable);
    public void Emit(ILOpcode opcode, ILCodeLabel label);
    public void EmitSwitch(ILCodeLabel[] labels);
    public void EmitUnaligned();
    public void EmitLdInd(TypeDesc type);
    public void EmitStInd(TypeDesc type);
    public void EmitStElem(TypeDesc type);
    public void EmitLdElem(TypeDesc type);
    public void EmitLabel(ILCodeLabel label);
    internal void PatchLabels();
    public void DefineSequencePoint(string document, int lineNumber);
}
public class Internal.IL.Stubs.ILEmitter : object {
    private ArrayBuilder`1<ILCodeStream> _codeStreams;
    private ArrayBuilder`1<LocalVariableDefinition> _locals;
    private ArrayBuilder`1<object> _tokens;
    public ILCodeStream NewCodeStream();
    private ILToken NewToken(object value, int tokenType);
    public ILToken NewToken(TypeDesc value);
    public ILToken NewToken(MethodDesc value);
    public ILToken NewToken(FieldDesc value);
    public ILToken NewToken(string value);
    public ILToken NewToken(MethodSignature value);
    public ILLocalVariable NewLocal(TypeDesc localType, bool isPinned);
    public ILCodeLabel NewCodeLabel();
    public MethodIL Link(MethodDesc owningMethod);
}
public enum Internal.IL.Stubs.ILLocalVariable : Enum {
    public int value__;
}
public abstract class Internal.IL.Stubs.ILStubMethod : MethodDesc {
    public abstract virtual MethodIL EmitIL();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
public class Internal.IL.Stubs.ILStubMethodIL : MethodIL {
    private Byte[] _ilBytes;
    private LocalVariableDefinition[] _locals;
    private Object[] _tokens;
    private MethodDesc _method;
    private MethodDebugInformation _debugInformation;
    private static int MaxStackNotSet;
    private int _maxStack;
    public MethodDesc OwningMethod { get; }
    public int MaxStack { get; }
    public bool IsInitLocals { get; }
    public ILStubMethodIL(MethodDesc owningMethod, Byte[] ilBytes, LocalVariableDefinition[] locals, Object[] tokens, MethodDebugInformation debugInfo);
    public ILStubMethodIL(ILStubMethodIL methodIL);
    public virtual MethodDesc get_OwningMethod();
    public virtual Byte[] GetILBytes();
    public virtual MethodDebugInformation GetDebugInfo();
    public virtual int get_MaxStack();
    public virtual ILExceptionRegion[] GetExceptionRegions();
    public virtual bool get_IsInitLocals();
    public virtual LocalVariableDefinition[] GetLocals();
    public virtual object GetObject(int token);
}
public enum Internal.IL.Stubs.ILToken : Enum {
    public int value__;
}
public class Internal.IL.Stubs.InlineArrayCandidate : ValueType {
    public MetadataType ElementType;
    public UInt32 Length;
    public InlineArrayCandidate(MetadataType type, UInt32 length);
}
internal class Internal.IL.Stubs.PInvokeILCodeStreams : object {
    [CompilerGeneratedAttribute]
private ILEmitter <Emitter>k__BackingField;
    [CompilerGeneratedAttribute]
private ILCodeStream <FunctionPointerLoadStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ILCodeStream <MarshallingCodeStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ILCodeStream <CallsiteSetupCodeStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ILCodeStream <ReturnValueMarshallingCodeStream>k__BackingField;
    [CompilerGeneratedAttribute]
private ILCodeStream <UnmarshallingCodestream>k__BackingField;
    public ILEmitter Emitter { get; }
    public ILCodeStream FunctionPointerLoadStream { get; }
    public ILCodeStream MarshallingCodeStream { get; }
    public ILCodeStream CallsiteSetupCodeStream { get; }
    public ILCodeStream ReturnValueMarshallingCodeStream { get; }
    public ILCodeStream UnmarshallingCodestream { get; }
    public PInvokeILCodeStreams(ILEmitter emitter, ILCodeStream codeStream);
    [CompilerGeneratedAttribute]
public ILEmitter get_Emitter();
    [CompilerGeneratedAttribute]
public ILCodeStream get_FunctionPointerLoadStream();
    [CompilerGeneratedAttribute]
public ILCodeStream get_MarshallingCodeStream();
    [CompilerGeneratedAttribute]
public ILCodeStream get_CallsiteSetupCodeStream();
    [CompilerGeneratedAttribute]
public ILCodeStream get_ReturnValueMarshallingCodeStream();
    [CompilerGeneratedAttribute]
public ILCodeStream get_UnmarshallingCodestream();
}
public class Internal.IL.Stubs.PInvokeILEmitter : ValueType {
    private MethodDesc _targetMethod;
    private Marshaller[] _marshallers;
    private PInvokeILEmitterConfiguration _pInvokeILEmitterConfiguration;
    private PInvokeMetadata _importMetadata;
    private PInvokeFlags _flags;
    private InteropStateManager _interopStateManager;
    private PInvokeILEmitter(MethodDesc targetMethod, PInvokeILEmitterConfiguration pinvokeILEmitterConfiguration, InteropStateManager interopStateManager);
    private static Marshaller[] InitializeMarshallers(MethodDesc targetMethod, InteropStateManager interopStateManager, PInvokeFlags flags);
    private void EmitDelegateCall(DelegateMarshallingMethodThunk delegateMethod, PInvokeILCodeStreams ilCodeStreams);
    private void EmitPInvokeCall(PInvokeILCodeStreams ilCodeStreams);
    private void EmitCalli(PInvokeILCodeStreams ilCodeStreams, CalliMarshallingMethodThunk calliThunk);
    private MethodIL EmitIL();
    public static MethodIL EmitIL(MethodDesc method, PInvokeILEmitterConfiguration pinvokeILEmitterConfiguration, InteropStateManager interopStateManager);
    private bool IsStubRequired();
}
public class Internal.IL.Stubs.PInvokeILStubMethodIL : ILStubMethodIL {
    [CompilerGeneratedAttribute]
private bool <IsStubRequired>k__BackingField;
    public bool IsStubRequired { get; }
    public PInvokeILStubMethodIL(ILStubMethodIL methodIL, bool isStubRequired);
    [CompilerGeneratedAttribute]
public bool get_IsStubRequired();
}
public class Internal.IL.Stubs.PInvokeLazyFixupField : FieldDesc {
    private DefType _owningType;
    private MethodDesc _targetMethod;
    public MethodDesc TargetMethod { get; }
    public PInvokeMetadata PInvokeMetadata { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc FieldType { get; }
    public bool HasRva { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsStatic { get; }
    public bool IsThreadStatic { get; }
    public DefType OwningType { get; }
    public string Name { get; }
    protected internal int ClassCode { get; }
    public PInvokeLazyFixupField(DefType owningType, MethodDesc targetMethod);
    public MethodDesc get_TargetMethod();
    public PInvokeMetadata get_PInvokeMetadata();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_FieldType();
    public virtual bool get_HasRva();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsLiteral();
    public virtual bool get_IsStatic();
    public virtual bool get_IsThreadStatic();
    public virtual DefType get_OwningType();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual string get_Name();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(FieldDesc other, TypeSystemComparer comparer);
}
public class Internal.IL.Stubs.PInvokeTargetNativeMethod : MethodDesc {
    private MethodDesc _declMethod;
    private MethodSignature _signature;
    protected internal int ClassCode { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public bool IsPInvoke { get; }
    public bool IsNoInlining { get; }
    private MethodDesc Internal.TypeSystem.IPrefixMangledMethod.BaseMethod { get; }
    private string Internal.TypeSystem.IPrefixMangledMethod.Prefix { get; }
    public PInvokeTargetNativeMethod(MethodDesc declMethod, MethodSignature signature);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool get_IsPInvoke();
    public virtual bool get_IsNoInlining();
    public virtual PInvokeMetadata GetPInvokeMethodMetadata();
    private sealed virtual override MethodDesc Internal.TypeSystem.IPrefixMangledMethod.get_BaseMethod();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledMethod.get_Prefix();
}
public class Internal.IL.Stubs.StructMarshallingThunk : ILStubMethod {
    internal MetadataType ManagedType;
    internal NativeStructType NativeType;
    internal StructMarshallingThunkType ThunkType;
    private InteropStateManager _interopStateManager;
    private TypeDesc _owningType;
    private Marshaller[] _marshallers;
    private MethodSignature _signature;
    protected internal int ClassCode { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    private string NamePrefix { get; }
    public string Name { get; }
    private TypeDesc Internal.TypeSystem.IPrefixMangledType.BaseType { get; }
    private string Internal.TypeSystem.IPrefixMangledType.Prefix { get; }
    public StructMarshallingThunk(TypeDesc owningType, MetadataType managedType, StructMarshallingThunkType thunkType, InteropStateManager interopStateManager);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    private string get_NamePrefix();
    public virtual string get_Name();
    private Marshaller[] InitializeMarshallers();
    private MethodIL EmitMarshallingIL(PInvokeILCodeStreams pInvokeILCodeStreams);
    private MethodIL EmitCleanupIL(PInvokeILCodeStreams pInvokeILCodeStreams);
    public virtual MethodIL EmitIL();
    private void LoadFieldValueFromArg(int argIndex, FieldDesc field, PInvokeILCodeStreams pInvokeILCodeStreams);
    private void StoreFieldValueFromArg(int argIndex, FieldDesc field, PInvokeILCodeStreams pInvokeILCodeStreams);
    private sealed virtual override TypeDesc Internal.TypeSystem.IPrefixMangledType.get_BaseType();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledType.get_Prefix();
}
public enum Internal.IL.Stubs.StructMarshallingThunkType : Enum {
    public byte value__;
    public static StructMarshallingThunkType ManagedToNative;
    public static StructMarshallingThunkType NativeToManaged;
    public static StructMarshallingThunkType Cleanup;
}
public class Internal.IL.Stubs.ValueTypeGetFieldHelperMethodOverride : ILStubMethod {
    private DefType _owningType;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public string Name { get; }
    protected internal int ClassCode { get; }
    internal ValueTypeGetFieldHelperMethodOverride(DefType owningType);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual MethodIL EmitIL();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual string get_Name();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public static class Internal.NativeFormat.TypeHashingAlgorithms : object {
    private static int _rotl(int value, int shift);
    public static int ComputeNameHashCode(string src);
    public static int ComputeASCIINameHashCode(Byte* data, int length, Boolean& isAscii);
    private static string IntToString(int arg);
    public static int ComputeArrayTypeHashCode(int elementTypeHashCode, int rank);
    public static int ComputeArrayTypeHashCode(T elementType, int rank);
    public static int ComputePointerTypeHashCode(int pointeeTypeHashCode);
    public static int ComputePointerTypeHashCode(T pointeeType);
    public static int ComputeByrefTypeHashCode(int parameterTypeHashCode);
    public static int ComputeByrefTypeHashCode(T parameterType);
    public static int ComputeNestedTypeHashCode(int enclosingTypeHashCode, int nestedTypeNameHash);
    public static int ComputeGenericInstanceHashCode(int genericDefinitionHashCode, ARG[] genericTypeArguments);
    public static int ComputeMethodSignatureHashCode(int returnTypeHashCode, ARG[] parameters);
    public static int ComputeMethodHashCode(int typeHashCode, int nameOrNameAndGenericArgumentsHashCode);
    public static int ComputeSignatureVariableHashCode(int index, bool method);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.AlignmentHelper : object {
    [ExtensionAttribute]
public static int AlignUp(int val, int alignment);
}
public class Internal.TypeSystem.ArrayMethod : MethodDesc {
    private ArrayType _owningType;
    private ArrayMethodKind _kind;
    private MethodSignature _signature;
    public bool IsIntrinsic { get; }
    public bool IsNoInlining { get; }
    public bool IsInternalCall { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public ArrayType OwningArray { get; }
    public ArrayMethodKind Kind { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    protected internal int ClassCode { get; }
    internal ArrayMethod(ArrayType owningType, ArrayMethodKind kind);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual bool get_IsIntrinsic();
    public virtual bool get_IsNoInlining();
    public virtual bool get_IsInternalCall();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public ArrayType get_OwningArray();
    public ArrayMethodKind get_Kind();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual MethodDesc GetNonRuntimeDeterminedMethodFromRuntimeDeterminedMethodViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public enum Internal.TypeSystem.ArrayMethodKind : Enum {
    public int value__;
    public static ArrayMethodKind Get;
    public static ArrayMethodKind Set;
    public static ArrayMethodKind Address;
    public static ArrayMethodKind AddressWithHiddenArg;
    public static ArrayMethodKind Ctor;
}
public class Internal.TypeSystem.ArrayOfTRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private MetadataType _arrayOfTType;
    public ArrayOfTRuntimeInterfacesAlgorithm(MetadataType arrayOfTType);
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
public class Internal.TypeSystem.ArrayType : ParameterizedType {
    private int _rank;
    internal MethodDesc[] _methods;
    public DefType BaseType { get; }
    public TypeDesc ElementType { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public int Rank { get; }
    protected internal int ClassCode { get; }
    internal ArrayType(TypeDesc elementType, int rank);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual DefType get_BaseType();
    public TypeDesc get_ElementType();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public int get_Rank();
    private void InitializeMethods();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public MethodDesc GetArrayMethod(ArrayMethodKind kind);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
public class Internal.TypeSystem.BaseTypeRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private static RuntimeInterfacesAlgorithm _singleton;
    public static RuntimeInterfacesAlgorithm Instance { get; }
    private static BaseTypeRuntimeInterfacesAlgorithm();
    public static RuntimeInterfacesAlgorithm get_Instance();
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
public class Internal.TypeSystem.BitEnumerator : ValueType {
    private Int32[] _buffer;
    private int _limitBit;
    private int _currentBit;
    public bool Current { get; }
    public BitEnumerator(Int32[] buffer, int startBit, int numBits);
    public bool get_Current();
    public bool MoveNext();
}
public class Internal.TypeSystem.ByRefType : ParameterizedType {
    protected internal int ClassCode { get; }
    internal ByRefType(TypeDesc parameter);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
public abstract class Internal.TypeSystem.CanonBaseType : MetadataType {
    private TypeSystemContext _context;
    public TypeSystemContext Context { get; }
    public MetadataType MetadataBaseType { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsSequentialLayout { get; }
    public bool IsExplicitLayout { get; }
    public ModuleDesc Module { get; }
    public bool IsModuleType { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public CanonBaseType(TypeSystemContext context);
    public sealed virtual TypeSystemContext get_Context();
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MetadataType get_MetadataBaseType();
    public virtual DefType get_ContainingType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsExplicitLayout();
    public virtual ModuleDesc get_Module();
    public virtual bool get_IsModuleType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual MetadataType GetNestedType(string name);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
    protected internal sealed virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
public enum Internal.TypeSystem.CanonicalFormKind : Enum {
    public int value__;
    public static CanonicalFormKind Specific;
    public static CanonicalFormKind Universal;
    public static CanonicalFormKind Any;
}
internal class Internal.TypeSystem.CanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public bool IsSealed { get; }
    public DefType BaseType { get; }
    protected internal int ClassCode { get; }
    public CanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual bool get_IsSealed();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
    protected internal virtual int get_ClassCode();
}
[ExtensionAttribute]
public static class Internal.TypeSystem.CastingHelper : object {
    [ExtensionAttribute]
public static bool CanCastTo(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
private static bool CanCastToInternal(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastGenericParameterTo(GenericParameterDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastArrayTo(ArrayType thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastParamTo(ParameterizedType thisType, TypeDesc paramType, StackOverflowProtect protect);
    private static bool ArePrimitveTypesEquivalentSize(TypeDesc type1, TypeDesc type2);
    [ExtensionAttribute]
private static int GetIntegralTypeMatchSize(TypeDesc type);
    public static bool IsArrayElementTypeCastableBySize(TypeDesc elementType);
    [ExtensionAttribute]
private static bool CanCastToClassOrInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToNonVariantInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastByVarianceToInterfaceOrDelegate(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protectInput);
    [ExtensionAttribute]
private static bool CanCastToClass(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool IsBoxedAndCanCastTo(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
}
public class Internal.TypeSystem.ClassLayoutMetadata : ValueType {
    public int PackingSize;
    public int Size;
    public FieldAndOffset[] Offsets;
}
public class Internal.TypeSystem.ComputedInstanceFieldLayout : ValueType {
    public LayoutInt FieldSize;
    public LayoutInt FieldAlignment;
    public LayoutInt ByteCountUnaligned;
    public LayoutInt ByteCountAlignment;
    public FieldAndOffset[] Offsets;
}
public class Internal.TypeSystem.ComputedStaticFieldLayout : ValueType {
    public StaticsBlock NonGcStatics;
    public StaticsBlock GcStatics;
    public StaticsBlock ThreadNonGcStatics;
    public StaticsBlock ThreadGcStatics;
    public FieldAndOffset[] Offsets;
}
[ExtensionAttribute]
public static class Internal.TypeSystem.ConstructedTypeRewritingHelpers : object {
    [ExtensionAttribute]
public static bool IsConstructedOverType(TypeDesc type, TypeDesc[] typesToFind);
    [ExtensionAttribute]
public static TypeDesc ReplaceTypesInConstructionOfType(TypeDesc type, TypeDesc[] typesToReplace, TypeDesc[] replacementTypes);
    [ExtensionAttribute]
public static MethodDesc ReplaceTypesInConstructionOfMethod(MethodDesc method, TypeDesc[] typesToReplace, TypeDesc[] replacementTypes);
}
public class Internal.TypeSystem.CustomAttributeTypeNameFormatter : TypeNameFormatter`2<IAssemblyDesc, bool> {
    private IAssemblyDesc _relativeHomeAssembly;
    private static Char[] s_escapedChars;
    public CustomAttributeTypeNameFormatter(IAssemblyDesc relativeHomeAssembly);
    private static CustomAttributeTypeNameFormatter();
    private void AppendAssemblyName(StringBuilder sb, IAssemblyDesc assembly);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, ArrayType type, bool assemblyQualify);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, ByRefType type, bool assemblyQualify);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, PointerType type, bool assemblyQualify);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, FunctionPointerType type, bool assemblyQualify);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, GenericParameterDesc type, bool assemblyQualify);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, SignatureMethodVariable type, bool assemblyQualify);
    public virtual IAssemblyDesc AppendName(StringBuilder sb, SignatureTypeVariable type, bool assemblyQualify);
    protected virtual IAssemblyDesc AppendNameForInstantiatedType(StringBuilder sb, DefType type, bool assemblyQualify);
    protected virtual IAssemblyDesc AppendNameForNamespaceType(StringBuilder sb, DefType type, bool assemblyQualify);
    protected virtual IAssemblyDesc AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType, bool assemblyQualify);
    private void AppendEscapedIdentifier(StringBuilder sb, string identifier);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.CustomAttributeTypeNameParser : object {
    [ExtensionAttribute]
public static TypeDesc GetTypeByCustomAttributeTypeName(ModuleDesc module, string name, bool throwIfNotFound, Func`4<string, ModuleDesc, bool, MetadataType> resolver);
    public static MetadataType ResolveCustomAttributeTypeDefinitionName(string name, ModuleDesc module, bool throwIfNotFound);
    [ExtensionAttribute]
private static MetadataType GetType(ModuleDesc module, string fullName, bool throwIfNotFound);
    private static AssemblyName FindAssemblyIfNamePresent(string name);
    private static int ReadTypeArgument(StringIterator strBegin, StringIterator strEnd, bool ignoreComma);
    [ExtensionAttribute]
private static StringIterator Begin(string s);
    [ExtensionAttribute]
private static StringIterator End(string s);
}
public class Internal.TypeSystem.DebugNameFormatter : TypeNameFormatter`2<Void, FormatOptions> {
    public static DebugNameFormatter Instance;
    private static DebugNameFormatter();
    public virtual Void AppendName(StringBuilder sb, ArrayType type, FormatOptions options);
    public virtual Void AppendName(StringBuilder sb, ByRefType type, FormatOptions options);
    public virtual Void AppendName(StringBuilder sb, PointerType type, FormatOptions options);
    public virtual Void AppendName(StringBuilder sb, FunctionPointerType type, FormatOptions options);
    public virtual Void AppendName(StringBuilder sb, GenericParameterDesc type, FormatOptions options);
    public virtual Void AppendName(StringBuilder sb, SignatureMethodVariable type, FormatOptions options);
    public virtual Void AppendName(StringBuilder sb, SignatureTypeVariable type, FormatOptions options);
    protected virtual Void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType, FormatOptions options);
    protected virtual Void AppendNameForNamespaceType(StringBuilder sb, DefType type, FormatOptions options);
    protected virtual Void AppendNameForInstantiatedType(StringBuilder sb, DefType type, FormatOptions options);
}
public abstract class Internal.TypeSystem.DefType : TypeDesc {
    private ThreadSafeFlags _fieldLayoutFlags;
    private LayoutInt _instanceFieldSize;
    private LayoutInt _instanceFieldAlignment;
    private LayoutInt _instanceByteCountUnaligned;
    private LayoutInt _instanceByteAlignment;
    private StaticBlockInfo _staticBlockInfo;
    private ValueTypeShapeCharacteristics _valueTypeShapeCharacteristics;
    public string Namespace { get; }
    public string Name { get; }
    public DefType ContainingType { get; }
    public bool ContainsGCPointers { get; }
    public LayoutInt InstanceFieldSize { get; }
    public LayoutInt InstanceFieldAlignment { get; }
    public LayoutInt InstanceByteCount { get; }
    public LayoutInt InstanceByteCountUnaligned { get; }
    public LayoutInt InstanceByteAlignment { get; }
    public LayoutInt NonGCStaticFieldSize { get; }
    public LayoutInt NonGCStaticFieldAlignment { get; }
    public LayoutInt GCStaticFieldSize { get; }
    public LayoutInt GCStaticFieldAlignment { get; }
    public LayoutInt ThreadNonGcStaticFieldSize { get; }
    public LayoutInt ThreadNonGcStaticFieldAlignment { get; }
    public LayoutInt ThreadGcStaticFieldSize { get; }
    public LayoutInt ThreadGcStaticFieldAlignment { get; }
    public bool IsHfa { get; }
    internal ValueTypeShapeCharacteristics ValueTypeShapeCharacteristics { get; }
    public DefType HfaElementType { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual DefType get_ContainingType();
    public bool get_ContainsGCPointers();
    public LayoutInt get_InstanceFieldSize();
    public LayoutInt get_InstanceFieldAlignment();
    public LayoutInt get_InstanceByteCount();
    public LayoutInt get_InstanceByteCountUnaligned();
    public LayoutInt get_InstanceByteAlignment();
    public LayoutInt get_NonGCStaticFieldSize();
    public LayoutInt get_NonGCStaticFieldAlignment();
    public LayoutInt get_GCStaticFieldSize();
    public LayoutInt get_GCStaticFieldAlignment();
    public LayoutInt get_ThreadNonGcStaticFieldSize();
    public LayoutInt get_ThreadNonGcStaticFieldAlignment();
    public LayoutInt get_ThreadGcStaticFieldSize();
    public LayoutInt get_ThreadGcStaticFieldAlignment();
    public bool get_IsHfa();
    internal ValueTypeShapeCharacteristics get_ValueTypeShapeCharacteristics();
    public DefType get_HfaElementType();
    private void ComputeValueTypeShapeCharacteristics();
    public void ComputeInstanceLayout(InstanceLayoutKind layoutKind);
    public void ComputeStaticFieldLayout(StaticLayoutKind layoutKind);
    public void ComputeTypeContainsGCPointers();
    public virtual bool get_IsRuntimeDeterminedSubtype();
    public DefType ConvertToSharedRuntimeDeterminedForm();
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class Internal.TypeSystem.Ecma.CachingMetadataStringDecoder : MetadataStringDecoder {
    private static int BucketSize;
    private Entry[] _table;
    private int _evictionHint;
    public CachingMetadataStringDecoder(int size);
    private string Find(int hashCode, string s);
    private string FindASCII(int hashCode, Byte* bytes, int byteCount);
    private static bool TextEqualsASCII(string text, Byte* ascii, int length);
    private string Add(int hashCode, string s);
    public string Lookup(string s);
    public virtual string GetString(Byte* bytes, int byteCount);
}
public class Internal.TypeSystem.Ecma.CustomAttributeTypeProvider : ValueType {
    private EcmaModule _module;
    public CustomAttributeTypeProvider(EcmaModule module);
    public sealed virtual TypeDesc GetPrimitiveType(PrimitiveTypeCode typeCode);
    public sealed virtual TypeDesc GetSystemType();
    public sealed virtual TypeDesc GetSZArrayType(TypeDesc elementType);
    public sealed virtual TypeDesc GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual TypeDesc GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public TypeDesc GetTypeFromSpecification(MetadataReader reader, TypeSpecificationHandle handle, byte rawTypeKind);
    public sealed virtual TypeDesc GetTypeFromSerializedName(string name);
    public sealed virtual PrimitiveTypeCode GetUnderlyingEnumType(TypeDesc type);
    public sealed virtual bool IsSystemType(TypeDesc type);
}
public class Internal.TypeSystem.Ecma.EcmaAssembly : EcmaModule {
    private AssemblyName _assemblyName;
    private AssemblyDefinition _assemblyDefinition;
    public AssemblyDefinition AssemblyDefinition { get; }
    public EcmaAssembly(TypeSystemContext context, PEReader peReader, MetadataReader metadataReader);
    internal EcmaAssembly(TypeSystemContext context, PEReader peReader, MetadataReader metadataReader, PdbSymbolReader pdbReader);
    public AssemblyDefinition get_AssemblyDefinition();
    public sealed virtual AssemblyName GetName();
    public virtual string ToString();
    public bool HasAssemblyCustomAttribute(string attributeNamespace, string attributeName);
}
public class Internal.TypeSystem.Ecma.EcmaField : FieldDesc {
    private EcmaType _type;
    private FieldDefinitionHandle _handle;
    private ThreadSafeFlags _fieldFlags;
    private TypeDesc _fieldType;
    private string _name;
    protected internal int ClassCode { get; }
    private EntityHandle Internal.TypeSystem.Ecma.EcmaModule.IEntityHandleObject.Handle { get; }
    public TypeSystemContext Context { get; }
    public DefType OwningType { get; }
    public EcmaModule Module { get; }
    public MetadataReader MetadataReader { get; }
    public FieldDefinitionHandle Handle { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsThreadStatic { get; }
    public bool IsInitOnly { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    public FieldAttributes Attributes { get; }
    public string Name { get; }
    internal EcmaField(EcmaType type, FieldDefinitionHandle handle);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(FieldDesc other, TypeSystemComparer comparer);
    private sealed virtual override EntityHandle Internal.TypeSystem.Ecma.EcmaModule.IEntityHandleObject.get_Handle();
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_OwningType();
    public EcmaModule get_Module();
    public MetadataReader get_MetadataReader();
    public FieldDefinitionHandle get_Handle();
    private TypeDesc InitializeFieldType();
    public virtual TypeDesc get_FieldType();
    private int InitializeFieldFlags(int mask);
    private int GetFieldFlags(int mask);
    public virtual bool get_IsStatic();
    public virtual bool get_IsThreadStatic();
    public virtual bool get_IsInitOnly();
    public virtual bool get_HasRva();
    public virtual bool get_IsLiteral();
    public FieldAttributes get_Attributes();
    private string InitializeName();
    public virtual string get_Name();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.Ecma.EcmaFieldExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetFieldRvaData(EcmaField field);
}
public class Internal.TypeSystem.Ecma.EcmaGenericParameter : GenericParameterDesc {
    private EcmaModule _module;
    private GenericParameterHandle _handle;
    protected internal int ClassCode { get; }
    public GenericParameterHandle Handle { get; }
    public MetadataReader MetadataReader { get; }
    public EcmaModule Module { get; }
    public TypeSystemContext Context { get; }
    public string Name { get; }
    public GenericParameterKind Kind { get; }
    public int Index { get; }
    public GenericVariance Variance { get; }
    public GenericConstraints Constraints { get; }
    public IEnumerable`1<TypeDesc> TypeConstraints { get; }
    internal EcmaGenericParameter(EcmaModule module, GenericParameterHandle handle);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
    public GenericParameterHandle get_Handle();
    public MetadataReader get_MetadataReader();
    public EcmaModule get_Module();
    public virtual TypeSystemContext get_Context();
    public virtual string get_Name();
    public virtual GenericParameterKind get_Kind();
    public virtual int get_Index();
    public virtual GenericVariance get_Variance();
    public virtual GenericConstraints get_Constraints();
    public virtual IEnumerable`1<TypeDesc> get_TypeConstraints();
}
public class Internal.TypeSystem.Ecma.EcmaMethod : MethodDesc {
    private EcmaType _type;
    private MethodDefinitionHandle _handle;
    private ThreadSafeFlags _methodFlags;
    private MethodSignature _signature;
    private string _name;
    private TypeDesc[] _genericParameters;
    protected internal int ClassCode { get; }
    private EntityHandle Internal.TypeSystem.Ecma.EcmaModule.IEntityHandleObject.Handle { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public EcmaModule Module { get; }
    public MetadataReader MetadataReader { get; }
    public MethodDefinitionHandle Handle { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsNoInlining { get; }
    public bool IsAggressiveInlining { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsIntrinsic { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool IsNativeCallable { get; }
    public bool IsRuntimeExport { get; }
    public bool IsDefaultConstructor { get; }
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes ImplAttributes { get; }
    public string Name { get; }
    public Instantiation Instantiation { get; }
    public bool IsPInvoke { get; }
    internal EcmaMethod(EcmaType type, MethodDefinitionHandle handle);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    private sealed virtual override EntityHandle Internal.TypeSystem.Ecma.EcmaModule.IEntityHandleObject.get_Handle();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private MethodSignature InitializeSignature();
    public virtual MethodSignature get_Signature();
    public EcmaModule get_Module();
    public MetadataReader get_MetadataReader();
    public MethodDefinitionHandle get_Handle();
    private int InitializeMethodFlags(int mask);
    private int GetMethodFlags(int mask);
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool get_IsNoInlining();
    public virtual bool get_IsAggressiveInlining();
    public virtual bool get_IsRuntimeImplemented();
    public virtual bool get_IsIntrinsic();
    public virtual bool get_IsInternalCall();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsNativeCallable();
    public virtual bool get_IsRuntimeExport();
    public virtual bool get_IsDefaultConstructor();
    public MethodAttributes get_Attributes();
    public MethodImplAttributes get_ImplAttributes();
    private string InitializeName();
    public virtual string get_Name();
    private void ComputeGenericParameters();
    public virtual Instantiation get_Instantiation();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool get_IsPInvoke();
    public virtual PInvokeMetadata GetPInvokeMethodMetadata();
    public virtual ParameterMetadata[] GetParameterMetadata();
    private MarshalAsDescriptor GetMarshalAsDescriptor(Parameter parameter);
}
public class Internal.TypeSystem.Ecma.EcmaModule : ModuleDesc {
    [CompilerGeneratedAttribute]
private PdbSymbolReader <PdbReader>k__BackingField;
    private PEReader _peReader;
    protected MetadataReader _metadataReader;
    private LockFreeReaderHashtable`2<EntityHandle, IEntityHandleObject> _resolvedTokens;
    public PdbSymbolReader PdbReader { get; }
    public PEReader PEReader { get; }
    public MetadataReader MetadataReader { get; }
    public MethodDesc EntryPoint { get; }
    internal EcmaModule(TypeSystemContext context, PEReader peReader, MetadataReader metadataReader, PdbSymbolReader pdbReader);
    internal EcmaModule(TypeSystemContext context, PEReader peReader, MetadataReader metadataReader);
    internal int CompareTo(EcmaModule other);
    [CompilerGeneratedAttribute]
public PdbSymbolReader get_PdbReader();
    public static EcmaModule Create(TypeSystemContext context, PEReader peReader, PdbSymbolReader pdbReader);
    private object ResolveModuleReference(ModuleReferenceHandle handle);
    public static EcmaModule Create(TypeSystemContext context, PEReader peReader);
    private static MetadataReader CreateMetadataReader(TypeSystemContext context, PEReader peReader);
    public PEReader get_PEReader();
    public MetadataReader get_MetadataReader();
    public MethodDesc get_EntryPoint();
    public sealed virtual MetadataType GetType(string nameSpace, string name, bool throwIfNotFound);
    public TypeDesc GetType(EntityHandle handle);
    public MethodDesc GetMethod(EntityHandle handle);
    public FieldDesc GetField(EntityHandle handle);
    public object GetObject(EntityHandle handle);
    private object ResolveMethodSpecification(MethodSpecificationHandle handle);
    private object ResolveStandaloneSignature(StandaloneSignatureHandle handle);
    private object ResolveTypeSpecification(TypeSpecificationHandle handle);
    private object ResolveMemberReference(MemberReferenceHandle handle);
    private object ResolveTypeReference(TypeReferenceHandle handle);
    private object ResolveAssemblyReference(AssemblyReferenceHandle handle);
    private object ResolveExportedType(ExportedTypeHandle handle);
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.EcmaModule/<GetAllTypes>d__34")]
public sealed virtual IEnumerable`1<MetadataType> GetAllTypes();
    public sealed virtual MetadataType GetGlobalModuleType();
    protected static AssemblyContentType GetContentTypeFromAssemblyFlags(AssemblyFlags flags);
    public string GetUserString(UserStringHandle userStringHandle);
    public virtual string ToString();
}
public class Internal.TypeSystem.Ecma.EcmaSignatureParser : ValueType {
    private EcmaModule _module;
    private BlobReader _reader;
    public bool IsFieldSignature { get; }
    public EcmaSignatureParser(EcmaModule module, BlobReader reader);
    private TypeDesc GetWellKnownType(WellKnownType wellKnownType);
    private TypeDesc ParseType(SignatureTypeCode typeCode);
    private SignatureTypeCode ParseTypeCode(bool skipPinned);
    public TypeDesc ParseType();
    public bool get_IsFieldSignature();
    public MethodSignature ParseMethodSignature();
    public PropertySignature ParsePropertySignature();
    public TypeDesc ParseFieldSignature();
    public LocalVariableDefinition[] ParseLocalsSignature();
    public TypeDesc[] ParseMethodSpecSignature();
    public MarshalAsDescriptor ParseMarshalAsDescriptor();
}
public class Internal.TypeSystem.Ecma.EcmaType : MetadataType {
    private EcmaModule _module;
    private TypeDefinitionHandle _handle;
    private TypeDefinition _typeDefinition;
    private string _typeName;
    private string _typeNamespace;
    private TypeDesc[] _genericParameters;
    private MetadataType _baseType;
    private int _hashcode;
    private DefType[] _implementedInterfaces;
    protected internal int ClassCode { get; }
    private EntityHandle Internal.TypeSystem.Ecma.EcmaModule.IEntityHandleObject.Handle { get; }
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public ModuleDesc Module { get; }
    public EcmaModule EcmaModule { get; }
    public MetadataReader MetadataReader { get; }
    public TypeDefinitionHandle Handle { get; }
    public DefType BaseType { get; }
    public MetadataType MetadataBaseType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public TypeAttributes Attributes { get; }
    public DefType ContainingType { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    internal EcmaType(EcmaModule module, TypeDefinitionHandle handle);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
    public virtual int GetHashCode();
    private int InitializeHashCode();
    private sealed virtual override EntityHandle Internal.TypeSystem.Ecma.EcmaModule.IEntityHandleObject.get_Handle();
    public virtual TypeSystemContext get_Context();
    private void ComputeGenericParameters();
    public virtual Instantiation get_Instantiation();
    public virtual ModuleDesc get_Module();
    public EcmaModule get_EcmaModule();
    public MetadataReader get_MetadataReader();
    public TypeDefinitionHandle get_Handle();
    private MetadataType InitializeBaseType();
    public virtual DefType get_BaseType();
    public virtual MetadataType get_MetadataBaseType();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private string InitializeName();
    public virtual string get_Name();
    private string InitializeNamespace();
    public virtual string get_Namespace();
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.EcmaType/<GetMethods>d__41")]
public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual MethodDesc GetFinalizer();
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.EcmaType/<GetFields>d__46")]
public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.EcmaType/<GetNestedTypes>d__48")]
public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual MetadataType GetNestedType(string name);
    public TypeAttributes get_Attributes();
    public virtual DefType get_ContainingType();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual MarshalAsDescriptor[] GetFieldMarshalAsDescriptors();
    private MarshalAsDescriptor GetMarshalAsDescriptor(FieldDefinition fieldDefinition);
    public virtual bool get_IsExplicitLayout();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string declName);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    private DefType[] InitializeImplementedInterfaces();
}
public interface Internal.TypeSystem.Ecma.IMetadataStringDecoderProvider {
    public abstract virtual MetadataStringDecoder GetMetadataStringDecoder();
}
[ExtensionAttribute]
public static class Internal.TypeSystem.Ecma.MetadataExtensions : object {
    private static TypeAttributes NestedMask;
    [ExtensionAttribute]
public static Nullable`1<CustomAttributeValue`1<TypeDesc>> GetDecodedCustomAttribute(EcmaType This, string attributeNamespace, string attributeName);
    [ExtensionAttribute]
public static Nullable`1<CustomAttributeValue`1<TypeDesc>> GetDecodedCustomAttribute(EcmaMethod This, string attributeNamespace, string attributeName);
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.MetadataExtensions/<GetDecodedCustomAttributes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttributeValue`1<TypeDesc>> GetDecodedCustomAttributes(EcmaMethod This, string attributeNamespace, string attributeName);
    [ExtensionAttribute]
public static Nullable`1<CustomAttributeValue`1<TypeDesc>> GetDecodedCustomAttribute(EcmaField This, string attributeNamespace, string attributeName);
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.MetadataExtensions/<GetDecodedCustomAttributes>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttributeValue`1<TypeDesc>> GetDecodedCustomAttributes(EcmaField This, string attributeNamespace, string attributeName);
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.MetadataExtensions/<GetDecodedCustomAttributes>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttributeValue`1<TypeDesc>> GetDecodedCustomAttributes(EcmaAssembly This, string attributeNamespace, string attributeName);
    [ExtensionAttribute]
public static CustomAttributeHandle GetCustomAttributeHandle(MetadataReader metadataReader, CustomAttributeHandleCollection customAttributes, string attributeNamespace, string attributeName);
    private static bool IsEqualCustomAttributeName(CustomAttributeHandle attributeHandle, MetadataReader metadataReader, string attributeNamespace, string attributeName);
    [ExtensionAttribute]
public static bool GetAttributeNamespaceAndName(MetadataReader metadataReader, CustomAttributeHandle attributeHandle, StringHandle& namespaceHandle, StringHandle& nameHandle);
    [ExtensionAttribute]
public static bool GetAttributeTypeAndConstructor(MetadataReader metadataReader, CustomAttributeHandle attributeHandle, EntityHandle& attributeType, EntityHandle& attributeCtor);
    [ExtensionAttribute]
public static bool GetAttributeTypeNamespaceAndName(MetadataReader metadataReader, EntityHandle attributeType, StringHandle& namespaceHandle, StringHandle& nameHandle);
    [ExtensionAttribute]
public static PInvokeFlags GetDelegatePInvokeFlags(EcmaType type);
    [ExtensionAttribute]
public static bool IsNested(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsRuntimeSpecialName(MethodAttributes flags);
    [ExtensionAttribute]
public static bool IsPublic(MethodAttributes flags);
}
public abstract class Internal.TypeSystem.Ecma.PdbSymbolReader : object {
    public abstract virtual IEnumerable`1<ILSequencePoint> GetSequencePointsForMethod(int methodToken);
    public abstract virtual IEnumerable`1<ILLocalVariable> GetLocalVariableNamesForMethod(int methodToken);
    public abstract virtual void Dispose();
}
public class Internal.TypeSystem.Ecma.PortablePdbSymbolReader : PdbSymbolReader {
    private MetadataReader _reader;
    private MemoryMappedViewAccessor _mappedViewAccessor;
    private PortablePdbSymbolReader(MetadataReader reader, MemoryMappedViewAccessor mappedViewAccessor);
    private static MetadataReader TryOpenMetadataFile(string filePath, MetadataStringDecoder stringDecoder, MemoryMappedViewAccessor& mappedViewAccessor);
    public static PdbSymbolReader TryOpen(string pdbFilename, MetadataStringDecoder stringDecoder);
    public virtual void Dispose();
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.PortablePdbSymbolReader/<GetSequencePointsForMethod>d__6")]
public virtual IEnumerable`1<ILSequencePoint> GetSequencePointsForMethod(int methodToken);
    private void ProbeScopeForLocals(List`1<ILLocalVariable> variables, LocalScopeHandle localScopeHandle);
    public virtual IEnumerable`1<ILLocalVariable> GetLocalVariableNamesForMethod(int methodToken);
}
public static class Internal.TypeSystem.Ecma.PrimitiveTypeProvider : object {
    public static TypeDesc GetPrimitiveType(TypeSystemContext context, PrimitiveTypeCode typeCode);
}
public class Internal.TypeSystem.Ecma.UnmanagedPdbSymbolReader : PdbSymbolReader {
    private static IMetaDataDispenser s_metadataDispenser;
    private static ISymUnmanagedBinder s_symBinder;
    private ISymUnmanagedReader _symUnmanagedReader;
    private Dictionary`2<ISymUnmanagedDocument, string> _urlCache;
    private static UnmanagedPdbSymbolReader();
    private UnmanagedPdbSymbolReader(ISymUnmanagedReader symUnmanagedReader);
    private static int CLRCreateInstance(Guid& clsid, Guid& riid, ICLRMetaHost& ppInterface);
    private static int CoCreateInstance(Guid& rclsid, IntPtr pUnkOuter, int dwClsContext, Guid& riid, Object& ppv);
    private void ThrowExceptionForHR(int hr);
    public static PdbSymbolReader TryOpenSymbolReaderForMetadataFile(string metadataFileName, string searchPath);
    public virtual void Dispose();
    private string GetUrl(ISymUnmanagedDocument doc);
    [IteratorStateMachineAttribute("Internal.TypeSystem.Ecma.UnmanagedPdbSymbolReader/<GetSequencePointsForMethod>d__15")]
public virtual IEnumerable`1<ILSequencePoint> GetSequencePointsForMethod(int methodToken);
    private void ProbeScopeForLocals(List`1<ILLocalVariable> variables, ISymUnmanagedScope scope);
    public virtual IEnumerable`1<ILLocalVariable> GetLocalVariableNamesForMethod(int methodToken);
}
public enum Internal.TypeSystem.ExceptionStringID : Enum {
    public int value__;
    public static ExceptionStringID ClassLoadGeneral;
    public static ExceptionStringID ClassLoadExplicitGeneric;
    public static ExceptionStringID ClassLoadBadFormat;
    public static ExceptionStringID ClassLoadExplicitLayout;
    public static ExceptionStringID ClassLoadValueClassTooLarge;
    public static ExceptionStringID ClassLoadRankTooLarge;
    public static ExceptionStringID MissingMethod;
    public static ExceptionStringID MissingField;
    public static ExceptionStringID FileLoadErrorGeneric;
    public static ExceptionStringID InvalidProgramDefault;
    public static ExceptionStringID InvalidProgramSpecific;
    public static ExceptionStringID InvalidProgramVararg;
    public static ExceptionStringID InvalidProgramCallVirtFinalize;
    public static ExceptionStringID InvalidProgramNativeCallable;
    public static ExceptionStringID BadImageFormatGeneric;
}
public class Internal.TypeSystem.ExceptionTypeNameFormatter : TypeNameFormatter {
    [CompilerGeneratedAttribute]
private static ExceptionTypeNameFormatter <Instance>k__BackingField;
    public static ExceptionTypeNameFormatter Instance { get; }
    private static ExceptionTypeNameFormatter();
    [CompilerGeneratedAttribute]
public static ExceptionTypeNameFormatter get_Instance();
    public virtual void AppendName(StringBuilder sb, PointerType type);
    public virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    public virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public virtual void AppendName(StringBuilder sb, ByRefType type);
    public virtual void AppendName(StringBuilder sb, ArrayType type);
    protected virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    private string GetTypeName(DefType type);
    private string GetTypeNamespace(DefType type);
}
public class Internal.TypeSystem.FieldAndOffset : ValueType {
    public static LayoutInt InvalidOffset;
    public FieldDesc Field;
    public LayoutInt Offset;
    public FieldAndOffset(FieldDesc field, LayoutInt offset);
    private static FieldAndOffset();
}
public abstract class Internal.TypeSystem.FieldDesc : TypeSystemEntity {
    public static FieldDesc[] EmptyFields;
    private LayoutInt _offset;
    public string Name { get; }
    public DefType OwningType { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    public bool IsTypicalFieldDefinition { get; }
    public LayoutInt Offset { get; }
    public bool HasGCStaticBase { get; }
    protected internal int ClassCode { get; }
    private static FieldDesc();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string get_Name();
    public abstract virtual DefType get_OwningType();
    public abstract virtual TypeDesc get_FieldType();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsThreadStatic();
    public abstract virtual bool get_HasRva();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
    public bool get_IsTypicalFieldDefinition();
    public virtual FieldDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual string ToString();
    public LayoutInt get_Offset();
    public bool get_HasGCStaticBase();
    internal void InitializeOffset(LayoutInt offset);
    protected internal abstract virtual int get_ClassCode();
    protected internal abstract virtual int CompareToImpl(FieldDesc other, TypeSystemComparer comparer);
    public FieldDesc GetNonRuntimeDeterminedFieldFromRuntimeDeterminedFieldViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class Internal.TypeSystem.FieldForInstantiatedType : FieldDesc {
    private FieldDesc _fieldDef;
    private InstantiatedType _instantiatedType;
    public TypeSystemContext Context { get; }
    public DefType OwningType { get; }
    public string Name { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    protected internal int ClassCode { get; }
    internal FieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_OwningType();
    public virtual string get_Name();
    public virtual TypeDesc get_FieldType();
    public virtual bool get_IsStatic();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsThreadStatic();
    public virtual bool get_HasRva();
    public virtual bool get_IsLiteral();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(FieldDesc other, TypeSystemComparer comparer);
}
public abstract class Internal.TypeSystem.FieldLayoutAlgorithm : object {
    public abstract virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public abstract virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public abstract virtual bool ComputeContainsGCPointers(DefType type);
    public abstract virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    public abstract virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
}
public class Internal.TypeSystem.FunctionPointerType : TypeDesc {
    private MethodSignature _signature;
    private int _hashCode;
    public MethodSignature Signature { get; }
    public TypeSystemContext Context { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    protected internal int ClassCode { get; }
    internal FunctionPointerType(MethodSignature signature);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public MethodSignature get_Signature();
    public virtual TypeSystemContext get_Context();
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual bool get_IsRuntimeDeterminedSubtype();
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
    protected internal sealed virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
[DefaultMemberAttribute("Item")]
public class Internal.TypeSystem.GCPointerMap : ValueType {
    private Int32[] _gcFlags;
    private int _numCells;
    public bool IsInitialized { get; }
    public int Size { get; }
    public int NumSeries { get; }
    public bool IsAllGCPointers { get; }
    public bool Item { get; }
    public GCPointerMap(Int32[] gcFlags, int numCells);
    public static GCPointerMap FromInstanceLayout(DefType type);
    public static GCPointerMap FromStaticLayout(DefType type);
    public static GCPointerMap FromThreadStaticLayout(DefType type);
    private static void FromInstanceLayoutHelper(GCPointerMapBuilder& builder, DefType type);
    public bool get_IsInitialized();
    public int get_Size();
    public int get_NumSeries();
    public bool get_IsAllGCPointers();
    public bool get_Item(int index);
    public BitEnumerator GetEnumerator();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GCPointerMap other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(GCPointerMap other);
}
public class Internal.TypeSystem.GCPointerMapBuilder : ValueType {
    private Int32[] _gcFlags;
    private int _pointerSize;
    private int _delta;
    private int _limit;
    public GCPointerMapBuilder(int numBytes, int pointerSize);
    public void MarkGCPointer(int offset);
    public GCPointerMapBuilder GetInnerBuilder(int offset, int size);
    public GCPointerMap ToGCMap();
    public BitEnumerator GetEnumerator();
    public virtual string ToString();
}
[FlagsAttribute]
public enum Internal.TypeSystem.GenericConstraints : Enum {
    public int value__;
    public static GenericConstraints None;
    public static GenericConstraints ReferenceTypeConstraint;
    public static GenericConstraints NotNullableValueTypeConstraint;
    public static GenericConstraints DefaultConstructorConstraint;
}
public abstract class Internal.TypeSystem.GenericParameterDesc : TypeDesc {
    public string Name { get; }
    public GenericParameterKind Kind { get; }
    public int Index { get; }
    public GenericVariance Variance { get; }
    public GenericConstraints Constraints { get; }
    public IEnumerable`1<TypeDesc> TypeConstraints { get; }
    public bool HasNotNullableValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected sealed virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Name();
    public abstract virtual GenericParameterKind get_Kind();
    public abstract virtual int get_Index();
    public virtual GenericVariance get_Variance();
    public virtual GenericConstraints get_Constraints();
    public virtual IEnumerable`1<TypeDesc> get_TypeConstraints();
    public bool get_HasNotNullableValueTypeConstraint();
    public bool get_HasReferenceTypeConstraint();
    public bool get_HasDefaultConstructorConstraint();
    public bool get_IsCovariant();
    public bool get_IsContravariant();
    protected sealed virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public sealed virtual int GetHashCode();
    public sealed virtual bool get_IsRuntimeDeterminedSubtype();
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public enum Internal.TypeSystem.GenericParameterKind : Enum {
    public int value__;
    public static GenericParameterKind Type;
    public static GenericParameterKind Method;
}
public enum Internal.TypeSystem.GenericVariance : Enum {
    public int value__;
    public static GenericVariance None;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
}
public interface Internal.TypeSystem.IAssemblyDesc {
    public abstract virtual AssemblyName GetName();
}
public interface Internal.TypeSystem.INonEmittableType {
}
public enum Internal.TypeSystem.InstanceLayoutKind : Enum {
    public int value__;
    public static InstanceLayoutKind TypeOnly;
    public static InstanceLayoutKind TypeAndFields;
}
public class Internal.TypeSystem.InstantiatedMethod : MethodDesc {
    private InstantiatedMethod _specificCanonCache;
    private InstantiatedMethod _universalCanonCache;
    private MethodDesc _methodDef;
    private Instantiation _instantiation;
    private MethodSignature _signature;
    public bool IsIntrinsic { get; }
    public bool IsNoInlining { get; }
    public bool IsAggressiveInlining { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool IsNativeCallable { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    protected internal int ClassCode { get; }
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation, int hashcode);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    private InstantiatedMethod GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, InstantiatedMethod value);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual bool get_IsIntrinsic();
    public virtual bool get_IsNoInlining();
    public virtual bool get_IsAggressiveInlining();
    public virtual bool get_IsRuntimeImplemented();
    public virtual bool get_IsInternalCall();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsNativeCallable();
    protected virtual int ComputeHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool get_IsDefaultConstructor();
    public virtual MethodDesc GetMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual string get_Name();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public virtual ParameterMetadata[] GetParameterMetadata();
}
public class Internal.TypeSystem.InstantiatedType : MetadataType {
    private MetadataType _typeDef;
    private Instantiation _instantiation;
    private int _hashCode;
    private MetadataType _baseType;
    private DefType[] _implementedInterfaces;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public DefType BaseType { get; }
    public MetadataType MetadataBaseType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public ModuleDesc Module { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    protected internal int ClassCode { get; }
    internal InstantiatedType(MetadataType typeDef, Instantiation instantiation);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    private MetadataType InitializeBaseType();
    public virtual DefType get_BaseType();
    public virtual MetadataType get_MetadataBaseType();
    private void AddComputedIntrinsicFlag(TypeFlags& flags);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual string get_Name();
    public virtual string get_Namespace();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetMethods>d__23")]
public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual MethodDesc GetFinalizer();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetFields>d__28")]
public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public static T[] InstantiateTypeArray(T[] uninstantiatedTypes, Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual bool get_IsExplicitLayout();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual ModuleDesc get_Module();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual DefType get_ContainingType();
    public virtual MetadataType GetNestedType(string name);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    private DefType[] InitializeImplementedInterfaces();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    private MethodImplRecord[] InstantiateMethodImpls(MethodImplRecord[] uninstMethodImpls);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
[DefaultMemberAttribute("GenericParameters")]
public class Internal.TypeSystem.Instantiation : ValueType {
    private TypeDesc[] _genericParameters;
    public static Instantiation Empty;
    public TypeDesc GenericParameters { get; }
    public int Length { get; }
    public bool IsNull { get; }
    public Instantiation(TypeDesc[] genericParameters);
    private static Instantiation();
    public TypeDesc get_GenericParameters(int index);
    public int get_Length();
    public bool get_IsNull();
    public int ComputeGenericInstanceHashCode(int genericDefinitionHashCode);
    public Enumerator GetEnumerator();
    public virtual string ToString();
}
public class Internal.TypeSystem.InstantiationContext : object {
    public Instantiation TypeInstantiation;
    public Instantiation MethodInstantiation;
    public InstantiationContext(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
internal class Internal.TypeSystem.Interop.AnsiCharArrayMarshaller : ArrayMarshaller {
    protected virtual void AllocManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.AnsiCharMarshaller : Marshaller {
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.AnsiStringMarshaller : Marshaller {
    internal bool CleanupRequired { get; }
    internal virtual bool get_CleanupRequired();
    internal virtual void EmitElementCleanup(ILCodeStream codeStream, ILEmitter emitter);
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.ArrayMarshaller : Marshaller {
    private Marshaller _elementMarshaller;
    protected TypeDesc ManagedElementType { get; }
    protected TypeDesc NativeElementType { get; }
    protected TypeDesc get_ManagedElementType();
    protected TypeDesc get_NativeElementType();
    protected Marshaller GetElementMarshaller(MarshalDirection direction);
    protected virtual void EmitElementCount(ILCodeStream codeStream, MarshalDirection direction);
    protected virtual void AllocManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void AllocNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.BlittableArrayMarshaller : ArrayMarshaller {
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void ReInitNativeTransform(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.BlittableStructPtrMarshaller : Marshaller {
    protected virtual void TransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.BlittableValueMarshaller : Marshaller {
    protected virtual void EmitMarshalArgumentManagedToNative();
    protected virtual void EmitMarshalArgumentNativeToManaged();
}
internal class Internal.TypeSystem.Interop.BooleanMarshaller : Marshaller {
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void AllocAndTransformNativeToManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.ByValAnsiStringMarshaller : ByValStringMarshaller {
    protected bool IsAnsi { get; }
    protected virtual bool get_IsAnsi();
    protected virtual MethodDesc GetManagedToNativeHelper();
    protected virtual MethodDesc GetNativeToManagedHelper();
}
internal class Internal.TypeSystem.Interop.ByValArrayMarshaller : ArrayMarshaller {
    protected FieldDesc _managedField;
    protected FieldDesc _nativeField;
    public void EmitMarshallingIL(PInvokeILCodeStreams codeStreams, FieldDesc managedField, FieldDesc nativeField);
    protected virtual void EmitElementCount(ILCodeStream codeStream, MarshalDirection direction);
    protected virtual void EmitMarshalFieldManagedToNative();
    protected virtual void EmitMarshalFieldNativeToManaged();
}
internal abstract class Internal.TypeSystem.Interop.ByValStringMarshaller : ByValArrayMarshaller {
    [CompilerGeneratedAttribute]
private bool <IsAnsi>k__BackingField;
    protected bool IsAnsi { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_IsAnsi();
    protected virtual MethodDesc GetManagedToNativeHelper();
    protected virtual MethodDesc GetNativeToManagedHelper();
    protected virtual void EmitMarshalFieldManagedToNative();
    protected virtual void EmitMarshalFieldNativeToManaged();
}
internal class Internal.TypeSystem.Interop.ByValUnicodeStringMarshaller : ByValStringMarshaller {
    protected bool IsAnsi { get; }
    protected virtual bool get_IsAnsi();
    protected virtual MethodDesc GetManagedToNativeHelper();
    protected virtual MethodDesc GetNativeToManagedHelper();
}
internal class Internal.TypeSystem.Interop.DelegateMarshaller : Marshaller {
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
public enum Internal.TypeSystem.Interop.InlineArrayMethodKind : Enum {
    public byte value__;
    public static InlineArrayMethodKind Getter;
    public static InlineArrayMethodKind Setter;
}
internal class Internal.TypeSystem.Interop.InlineArrayType : MetadataType {
    [CompilerGeneratedAttribute]
private MetadataType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleDesc <Module>k__BackingField;
    private InteropStateManager _interopStateManager;
    private MethodDesc[] _methods;
    private int _hashCode;
    protected internal int ClassCode { get; }
    public MetadataType ElementType { get; }
    public UInt32 Length { get; }
    public ModuleDesc Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Instantiation Instantiation { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public MetadataType MetadataBaseType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public TypeSystemContext Context { get; }
    public InlineArrayType(ModuleDesc owningModule, MetadataType elementType, UInt32 length, InteropStateManager interopStateManager);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
    [CompilerGeneratedAttribute]
public MetadataType get_ElementType();
    [CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
public virtual ModuleDesc get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Instantiation get_Instantiation();
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
    public virtual bool get_IsExplicitLayout();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual MetadataType get_MetadataBaseType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual DefType get_ContainingType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    public virtual TypeSystemContext get_Context();
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual MetadataType GetNestedType(string name);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    private void InitializeHashCode();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private void InitializeMethods();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public MethodDesc GetInlineArrayMethod(InlineArrayMethodKind kind);
    public virtual IEnumerable`1<FieldDesc> GetFields();
}
public static class Internal.TypeSystem.Interop.InteropTypes : object {
    public static MetadataType GetGC(TypeSystemContext context);
    public static MetadataType GetSafeHandle(TypeSystemContext context);
    public static MetadataType GetCriticalHandle(TypeSystemContext context);
    public static MetadataType GetMissingMemberException(TypeSystemContext context);
    public static MetadataType GetPInvokeMarshal(TypeSystemContext context);
    public static MetadataType GetNativeFunctionPointerWrapper(TypeSystemContext context);
    public static bool IsSafeHandle(TypeSystemContext context, TypeDesc type);
    public static bool IsCriticalHandle(TypeSystemContext context, TypeDesc type);
    private static bool IsCoreNamedType(TypeSystemContext context, TypeDesc type, string namespace, string name);
    public static bool IsHandleRef(TypeSystemContext context, TypeDesc type);
    public static bool IsSystemDateTime(TypeSystemContext context, TypeDesc type);
    public static bool IsStringBuilder(TypeSystemContext context, TypeDesc type);
    public static bool IsSystemDecimal(TypeSystemContext context, TypeDesc type);
    public static bool IsSystemGuid(TypeSystemContext context, TypeDesc type);
    private static bool IsOrDerivesFromType(TypeDesc type, MetadataType targetType);
}
public enum Internal.TypeSystem.Interop.MarshalDirection : Enum {
    public int value__;
    public static MarshalDirection Forward;
    public static MarshalDirection Reverse;
}
public static class Internal.TypeSystem.Interop.MarshalHelpers : object {
    public static bool IsBlittableType(TypeDesc type);
    public static bool IsStructMarshallingRequired(TypeDesc typeDesc);
    public static bool UseLazyResolution(MethodDesc method, string importModule, PInvokeILEmitterConfiguration configuration);
    internal static TypeDesc GetNativeMethodParameterType(TypeDesc type, MarshalAsDescriptor marshalAs, InteropStateManager interopStateManager, bool isReturn, bool isAnsi);
    internal static TypeDesc GetNativeStructFieldType(TypeDesc type, MarshalAsDescriptor marshalAs, InteropStateManager interopStateManager, bool isAnsi);
    internal static TypeDesc GetNativeTypeFromMarshallerKind(TypeDesc type, MarshallerKind kind, MarshallerKind elementMarshallerKind, InteropStateManager interopStateManager, MarshalAsDescriptor marshalAs, bool isArrayElement);
    internal static InlineArrayCandidate GetInlineArrayCandidate(TypeDesc managedElementType, MarshallerKind elementMarshallerKind, InteropStateManager interopStateManager, MarshalAsDescriptor marshalAs);
    internal static MarshallerKind GetMarshallerKind(TypeDesc type, MarshalAsDescriptor marshalAs, bool isReturn, bool isAnsi, MarshallerType marshallerType, MarshallerKind& elementMarshallerKind);
    private static MarshallerKind GetArrayElementMarshallerKind(ArrayType arrayType, MarshalAsDescriptor marshalAs, bool isAnsi);
    public static MethodIL EmitExceptionBody(string message, MethodDesc method);
}
internal abstract class Internal.TypeSystem.Interop.Marshaller : object {
    public TypeSystemContext Context;
    public InteropStateManager InteropStateManager;
    public MarshallerKind MarshallerKind;
    public MarshallerType MarshallerType;
    public MarshalAsDescriptor MarshalAsDescriptor;
    public MarshallerKind ElementMarshallerKind;
    public int Index;
    public TypeDesc ManagedType;
    public TypeDesc ManagedParameterType;
    public PInvokeFlags PInvokeFlags;
    protected Marshaller[] Marshallers;
    private TypeDesc _nativeType;
    private TypeDesc _nativeParamType;
    public bool In;
    public bool Out;
    public bool Return;
    public bool IsManagedByRef;
    public bool IsNativeByRef;
    public MarshalDirection MarshalDirection;
    protected PInvokeILCodeStreams _ilCodeStreams;
    protected Home _managedHome;
    protected Home _nativeHome;
    public TypeDesc NativeType { get; }
    public TypeDesc NativeParameterType { get; }
    internal bool CleanupRequired { get; }
    public TypeDesc get_NativeType();
    public TypeDesc get_NativeParameterType();
    internal virtual bool get_CleanupRequired();
    public static Marshaller CreateMarshaller(TypeDesc parameterType, MarshallerType marshallerType, MarshalAsDescriptor marshalAs, MarshalDirection direction, Marshaller[] marshallers, InteropStateManager interopStateManager, int index, PInvokeFlags flags, bool isIn, bool isOut, bool isReturn);
    protected static Marshaller CreateMarshaller(MarshallerKind kind);
    public bool IsMarshallingRequired();
    public virtual void EmitMarshallingIL(PInvokeILCodeStreams pInvokeILCodeStreams);
    private void EmitArgumentMarshallingIL();
    private void EmitElementMarshallingIL();
    private void EmitFieldMarshallingIL();
    protected virtual void EmitForwardArgumentMarshallingIL();
    protected virtual void EmitReverseArgumentMarshallingIL();
    protected virtual void EmitForwardElementMarshallingIL();
    protected virtual void EmitReverseElementMarshallingIL();
    protected virtual void EmitForwardFieldMarshallingIL();
    protected virtual void EmitReverseFieldMarshallingIL();
    protected virtual void EmitMarshalReturnValueManagedToNative();
    public virtual void LoadReturnValue(ILCodeStream codeStream);
    protected virtual void SetupArguments();
    protected virtual void SetupArgumentsForElementMarshalling();
    protected virtual void SetupArgumentsForFieldMarshalling();
    protected virtual void SetupArgumentsForReturnValueMarshalling();
    protected void LoadManagedValue(ILCodeStream stream);
    protected void LoadManagedAddr(ILCodeStream stream);
    protected void LoadManagedArg(ILCodeStream stream);
    protected void StoreManagedValue(ILCodeStream stream);
    protected void LoadNativeValue(ILCodeStream stream);
    protected void LoadNativeArg(ILCodeStream stream);
    protected void LoadNativeAddr(ILCodeStream stream);
    protected void StoreNativeValue(ILCodeStream stream);
    protected void PropagateFromByRefArg(ILCodeStream stream, Home home);
    protected void PropagateToByRefArg(ILCodeStream stream, Home home);
    protected virtual void EmitMarshalArgumentManagedToNative();
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void AllocAndTransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void AllocManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformManagedToNative(ILCodeStream codeStream);
    protected virtual void ClearManagedTransform(ILCodeStream codeStream);
    protected virtual void AllocNativeToManaged(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
    protected virtual void EmitMarshalReturnValueNativeToManaged();
    protected virtual void EmitMarshalArgumentNativeToManaged();
    protected virtual void EmitMarshalElementManagedToNative();
    protected virtual void EmitMarshalElementNativeToManaged();
    protected virtual void EmitMarshalFieldManagedToNative();
    protected virtual void EmitMarshalFieldNativeToManaged();
    protected virtual void ReInitManagedTransform(ILCodeStream codeStream);
    protected virtual void ReInitNativeTransform(ILCodeStream codeStream);
    internal virtual void EmitElementCleanup(ILCodeStream codestream, ILEmitter emitter);
}
internal enum Internal.TypeSystem.Interop.MarshallerKind : Enum {
    public int value__;
    public static MarshallerKind Unknown;
    public static MarshallerKind BlittableValue;
    public static MarshallerKind Array;
    public static MarshallerKind BlittableArray;
    public static MarshallerKind Bool;
    public static MarshallerKind CBool;
    public static MarshallerKind Enum;
    public static MarshallerKind AnsiChar;
    public static MarshallerKind UnicodeChar;
    public static MarshallerKind AnsiCharArray;
    public static MarshallerKind ByValArray;
    public static MarshallerKind ByValAnsiCharArray;
    public static MarshallerKind AnsiString;
    public static MarshallerKind UnicodeString;
    public static MarshallerKind ByValAnsiString;
    public static MarshallerKind ByValUnicodeString;
    public static MarshallerKind AnsiStringBuilder;
    public static MarshallerKind UnicodeStringBuilder;
    public static MarshallerKind FunctionPointer;
    public static MarshallerKind SafeHandle;
    public static MarshallerKind CriticalHandle;
    public static MarshallerKind HandleRef;
    public static MarshallerKind VoidReturn;
    public static MarshallerKind Variant;
    public static MarshallerKind Object;
    public static MarshallerKind OleDateTime;
    public static MarshallerKind Decimal;
    public static MarshallerKind Guid;
    public static MarshallerKind Struct;
    public static MarshallerKind BlittableStruct;
    public static MarshallerKind BlittableStructPtr;
    public static MarshallerKind Invalid;
}
public enum Internal.TypeSystem.Interop.MarshallerType : Enum {
    public int value__;
    public static MarshallerType Argument;
    public static MarshallerType Element;
    public static MarshallerType Field;
}
public class Internal.TypeSystem.Interop.NativeStructType : MetadataType {
    [CompilerGeneratedAttribute]
private MetadataType <ManagedStructType>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleDesc <Module>k__BackingField;
    private NativeStructField[] _fields;
    private InteropStateManager _interopStateManager;
    private bool _hasInvalidLayout;
    private int _hashCode;
    protected internal int ClassCode { get; }
    public MetadataType ManagedStructType { get; }
    public ModuleDesc Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Instantiation Instantiation { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public MetadataType MetadataBaseType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public TypeSystemContext Context { get; }
    public bool HasInvalidLayout { get; }
    public FieldDesc[] Fields { get; }
    private TypeDesc Internal.TypeSystem.IPrefixMangledType.BaseType { get; }
    private string Internal.TypeSystem.IPrefixMangledType.Prefix { get; }
    public NativeStructType(ModuleDesc owningModule, MetadataType managedStructType, InteropStateManager interopStateManager);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
    [CompilerGeneratedAttribute]
public MetadataType get_ManagedStructType();
    [CompilerGeneratedAttribute]
public virtual ModuleDesc get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Instantiation get_Instantiation();
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
    public virtual bool get_IsExplicitLayout();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual MetadataType get_MetadataBaseType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual DefType get_ContainingType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    public virtual TypeSystemContext get_Context();
    public bool get_HasInvalidLayout();
    public FieldDesc[] get_Fields();
    private void CalculateFields();
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual MetadataType GetNestedType(string name);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    private void InitializeHashCode();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual IEnumerable`1<FieldDesc> GetFields();
    private sealed virtual override TypeDesc Internal.TypeSystem.IPrefixMangledType.get_BaseType();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledType.get_Prefix();
}
internal class Internal.TypeSystem.Interop.NotSupportedMarshaller : Marshaller {
    public virtual void EmitMarshallingIL(PInvokeILCodeStreams pInvokeILCodeStreams);
}
public class Internal.TypeSystem.Interop.PInvokeDelegateWrapper : MetadataType {
    [CompilerGeneratedAttribute]
private MetadataType <DelegateType>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleDesc <Module>k__BackingField;
    private InteropStateManager _interopStateManager;
    private int _hashCode;
    private MethodDesc[] _methods;
    public MetadataType DelegateType { get; }
    public ModuleDesc Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public MetadataType MetadataBaseType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public TypeSystemContext Context { get; }
    private TypeDesc Internal.TypeSystem.IPrefixMangledType.BaseType { get; }
    private string Internal.TypeSystem.IPrefixMangledType.Prefix { get; }
    protected internal int ClassCode { get; }
    public PInvokeDelegateWrapper(ModuleDesc owningModule, MetadataType delegateType, InteropStateManager interopStateManager);
    [CompilerGeneratedAttribute]
public MetadataType get_DelegateType();
    [CompilerGeneratedAttribute]
public virtual ModuleDesc get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual bool get_IsExplicitLayout();
    public virtual PInvokeStringFormat get_PInvokeStringFormat();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual MetadataType get_MetadataBaseType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual DefType get_ContainingType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    public virtual TypeSystemContext get_Context();
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual MetadataType GetNestedType(string name);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    private void InitializeHashCode();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private void InitializeMethods();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public MethodDesc GetPInvokeDelegateWrapperMethod(PInvokeDelegateWrapperMethodKind kind);
    private sealed virtual override TypeDesc Internal.TypeSystem.IPrefixMangledType.get_BaseType();
    private sealed virtual override string Internal.TypeSystem.IPrefixMangledType.get_Prefix();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
public class Internal.TypeSystem.Interop.PInvokeDelegateWrapperConstructor : ILStubMethod {
    [CompilerGeneratedAttribute]
private TypeDesc <OwningType>k__BackingField;
    private MethodSignature _signature;
    public TypeDesc OwningType { get; }
    public string Name { get; }
    public MethodSignature Signature { get; }
    public TypeSystemContext Context { get; }
    protected internal int ClassCode { get; }
    public PInvokeDelegateWrapperConstructor(PInvokeDelegateWrapper owningType);
    [CompilerGeneratedAttribute]
public virtual TypeDesc get_OwningType();
    public virtual string get_Name();
    public virtual MethodSignature get_Signature();
    public virtual TypeSystemContext get_Context();
    public virtual MethodIL EmitIL();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public enum Internal.TypeSystem.Interop.PInvokeDelegateWrapperMethodKind : Enum {
    public byte value__;
    public static PInvokeDelegateWrapperMethodKind Constructor;
    public static PInvokeDelegateWrapperMethodKind Invoke;
}
internal class Internal.TypeSystem.Interop.SafeHandleMarshaller : Marshaller {
    private void AllocSafeHandle(ILCodeStream codeStream);
    protected virtual void EmitMarshalReturnValueManagedToNative();
    protected virtual void EmitMarshalArgumentManagedToNative();
}
internal class Internal.TypeSystem.Interop.StringBuilderMarshaller : Marshaller {
    private bool _isAnsi;
    internal bool CleanupRequired { get; }
    public StringBuilderMarshaller(bool isAnsi);
    internal virtual bool get_CleanupRequired();
    internal virtual void EmitElementCleanup(ILCodeStream codeStream, ILEmitter emitter);
    protected virtual void AllocNativeToManaged(ILCodeStream codeStream);
    protected virtual void AllocManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.StructMarshaller : Marshaller {
    protected virtual void AllocManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.UnicodeStringMarshaller : Marshaller {
    private bool ShouldBePinned { get; }
    internal bool CleanupRequired { get; }
    private bool get_ShouldBePinned();
    internal virtual bool get_CleanupRequired();
    internal virtual void EmitElementCleanup(ILCodeStream codeStream, ILEmitter emitter);
    protected virtual void AllocAndTransformManagedToNative(ILCodeStream codeStream);
    protected virtual void TransformNativeToManaged(ILCodeStream codeStream);
    protected virtual void EmitCleanupManaged(ILCodeStream codeStream);
}
internal class Internal.TypeSystem.Interop.VoidReturnMarshaller : Marshaller {
    protected virtual void EmitMarshalReturnValueManagedToNative();
    protected virtual void EmitMarshalReturnValueNativeToManaged();
    public virtual void LoadReturnValue(ILCodeStream codeStream);
}
public class Internal.TypeSystem.InteropStateManager : object {
    private ModuleDesc _generatedAssembly;
    private NativeStructTypeHashtable _nativeStructHashtable;
    private StructMarshallingThunkHashTable _structMarshallingThunkHashtable;
    private DelegateMarshallingStubHashtable _delegateMarshallingThunkHashtable;
    private ForwardDelegateCreationStubHashtable _forwardDelegateCreationStubHashtable;
    private PInvokeDelegateWrapperHashtable _pInvokeDelegateWrapperHashtable;
    private InlineArrayHashTable _inlineArrayHashtable;
    private PInvokeLazyFixupFieldHashtable _pInvokeLazyFixupFieldHashtable;
    private PInvokeCalliHashtable _pInvokeCalliHashtable;
    public InteropStateManager(ModuleDesc generatedAssembly);
    public DelegateMarshallingMethodThunk GetOpenStaticDelegateMarshallingThunk(TypeDesc delegateType);
    public DelegateMarshallingMethodThunk GetClosedDelegateMarshallingThunk(TypeDesc delegateType);
    public ForwardDelegateCreationThunk GetForwardDelegateCreationThunk(TypeDesc delegateType);
    public PInvokeDelegateWrapper GetPInvokeDelegateWrapper(TypeDesc delegateType);
    public NativeStructType GetStructMarshallingNativeType(TypeDesc managedType);
    public MethodDesc GetStructMarshallingManagedToNativeThunk(TypeDesc managedType);
    public MethodDesc GetStructMarshallingNativeToManagedThunk(TypeDesc managedType);
    public MethodDesc GetStructMarshallingCleanupThunk(TypeDesc managedType);
    public TypeDesc GetInlineArrayType(InlineArrayCandidate candidate);
    public FieldDesc GetPInvokeLazyFixupField(MethodDesc method);
    public MethodDesc GetPInvokeCalliStub(MethodSignature signature);
}
public interface Internal.TypeSystem.IPrefixMangledMethod {
    public MethodDesc BaseMethod { get; }
    public string Prefix { get; }
    public abstract virtual MethodDesc get_BaseMethod();
    public abstract virtual string get_Prefix();
}
public interface Internal.TypeSystem.IPrefixMangledSignature {
    public MethodSignature BaseSignature { get; }
    public string Prefix { get; }
    public abstract virtual MethodSignature get_BaseSignature();
    public abstract virtual string get_Prefix();
}
public interface Internal.TypeSystem.IPrefixMangledType {
    public TypeDesc BaseType { get; }
    public string Prefix { get; }
    public abstract virtual TypeDesc get_BaseType();
    public abstract virtual string get_Prefix();
}
public class Internal.TypeSystem.LayoutInt : ValueType {
    private int _value;
    public static LayoutInt Indeterminate;
    public static LayoutInt Zero;
    public static LayoutInt One;
    public bool IsIndeterminate { get; }
    public int AsInt { get; }
    public LayoutInt(int input);
    private static LayoutInt();
    private static LayoutInt CreateIndeterminateLayoutInt();
    public bool get_IsIndeterminate();
    public int get_AsInt();
    public virtual string ToString();
    public string ToStringInvariant();
    public static bool op_Equality(LayoutInt left, LayoutInt right);
    public static bool op_Inequality(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Addition(LayoutInt left, LayoutInt right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LayoutInt Max(LayoutInt left, LayoutInt right);
    public static LayoutInt Min(LayoutInt left, LayoutInt right);
    public static LayoutInt AlignUp(LayoutInt value, LayoutInt alignment);
}
public class Internal.TypeSystem.LocalVariableDefinition : ValueType {
    public bool IsPinned;
    public TypeDesc Type;
    public LocalVariableDefinition(TypeDesc type, bool isPinned);
    public virtual string ToString();
}
public abstract class Internal.TypeSystem.LockFreeReaderHashtable`2 : object {
    private static int _initialSize;
    private static int _fillPercentageBeforeResize;
    private TValue[] modreq(System.Runtime.CompilerServices.IsVolatile) _hashtable;
    private TValue[] modreq(System.Runtime.CompilerServices.IsVolatile) _newHashTable;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _count;
    private int _reserve;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _resizeCount;
    public int Count { get; }
    private TValue[] GetCurrentHashtable();
    private void SetCurrentHashtable(TValue[] hashtable);
    public static int HashInt1(int key);
    public static int HashInt2(int key);
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    private void Expand(TValue[] oldHashtable);
    public bool TryAdd(TValue value);
    public TValue AddOrGetExisting(TValue value);
    private TValue AddOrGetExistingInner(TValue value, Boolean& addedValue);
    private TValue TryAddOrGetExisting(TValue value, Boolean& addedValue);
    private bool TryWriteValueToLocation(TValue value, TValue[] hashTableLocal, int tableIndex);
    private TValue CreateValueAndEnsureValueIsInTable(TKey key);
    public TValue GetOrCreateValue(TKey key);
    public bool Contains(TKey key);
    public TValue GetValueIfExists(TValue value);
    protected abstract virtual int GetKeyHashCode(TKey key);
    protected abstract virtual int GetValueHashCode(TValue value);
    protected abstract virtual bool CompareKeyToValue(TKey key, TValue value);
    protected abstract virtual bool CompareValueToValue(TValue value1, TValue value2);
    protected abstract virtual TValue CreateValueFromKey(TKey key);
}
public class Internal.TypeSystem.MarshalAsDescriptor : object {
    [CompilerGeneratedAttribute]
private NativeTypeKind <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NativeTypeKind <ArraySubType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <SizeParamIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <SizeConst>k__BackingField;
    public NativeTypeKind Type { get; }
    public NativeTypeKind ArraySubType { get; }
    public Nullable`1<UInt32> SizeParamIndex { get; }
    public Nullable`1<UInt32> SizeConst { get; }
    public MarshalAsDescriptor(NativeTypeKind type, NativeTypeKind arraySubType, Nullable`1<UInt32> sizeParamIndex, Nullable`1<UInt32> sizeConst);
    [CompilerGeneratedAttribute]
public NativeTypeKind get_Type();
    [CompilerGeneratedAttribute]
public NativeTypeKind get_ArraySubType();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_SizeParamIndex();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_SizeConst();
}
public class Internal.TypeSystem.MetadataFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType defType, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType defType, StaticLayoutKind layoutKind);
    private StaticsBlock& GetStaticsBlockForField(ComputedStaticFieldLayout& layout, FieldDesc field);
    public virtual bool ComputeContainsGCPointers(DefType type);
    protected virtual void PrepareRuntimeSpecificStaticFieldLayout(TypeSystemContext context, ComputedStaticFieldLayout& layout);
    protected virtual void FinalizeRuntimeSpecificStaticFieldLayout(TypeSystemContext context, ComputedStaticFieldLayout& layout);
    private static ComputedInstanceFieldLayout ComputeExplicitFieldLayout(MetadataType type, int numInstanceFields);
    private static ComputedInstanceFieldLayout ComputeSequentialFieldLayout(MetadataType type, int numInstanceFields);
    private static LayoutInt ComputeBytesUsedInParentType(DefType type);
    private static SizeAndAlignment ComputeFieldSizeAndAlignment(TypeDesc fieldType, int packingSize);
    private static int ComputePackingSize(MetadataType type, ClassLayoutMetadata layoutMetadata);
    private static SizeAndAlignment ComputeInstanceSize(MetadataType type, LayoutInt instanceSize, LayoutInt alignment, SizeAndAlignment& byteCount);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    private ValueTypeShapeCharacteristics ComputeHomogeneousFloatAggregateCharacteristic(DefType type);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
}
public class Internal.TypeSystem.MetadataRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
    private DefType[] ComputeRuntimeInterfacesForInstantiatedType(InstantiatedType instantiatedType);
    private DefType[] ComputeRuntimeInterfacesForNonInstantiatedMetadataType(MetadataType type);
    private void BuildPostOrderInterfaceList(DefType iface, ArrayBuilder`1& interfacesArray);
}
public abstract class Internal.TypeSystem.MetadataType : DefType {
    private MethodImplRecord[] _allVirtualMethodImplsForType;
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public ModuleDesc Module { get; }
    public MetadataType MetadataBaseType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public MethodImplRecord[] VirtualMethodImplsForType { get; }
    public PInvokeStringFormat PInvokeStringFormat { get; }
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public abstract virtual ClassLayoutMetadata GetClassLayout();
    public abstract virtual bool get_IsExplicitLayout();
    public abstract virtual bool get_IsSequentialLayout();
    public abstract virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public abstract virtual ModuleDesc get_Module();
    public abstract virtual MetadataType get_MetadataBaseType();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public abstract virtual DefType get_ContainingType();
    public abstract virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public abstract virtual MetadataType GetNestedType(string name);
    public abstract virtual DefType[] get_ExplicitlyImplementedInterfaces();
    protected abstract virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public MethodImplRecord[] get_VirtualMethodImplsForType();
    public abstract virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public abstract virtual PInvokeStringFormat get_PInvokeStringFormat();
    public virtual MarshalAsDescriptor[] GetFieldMarshalAsDescriptors();
}
public abstract class Internal.TypeSystem.MetadataTypeSystemContext : TypeSystemContext {
    private static String[] s_wellKnownTypeNames;
    private MetadataType[] _wellKnownTypes;
    public MetadataTypeSystemContext(TargetDetails details);
    private static MetadataTypeSystemContext();
    public virtual void SetSystemModule(ModuleDesc systemModule);
    public virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    protected internal sealed virtual bool ComputeHasStaticConstructor(TypeDesc type);
}
public class Internal.TypeSystem.MetadataVirtualMethodAlgorithm : VirtualMethodAlgorithm {
    private static Func`3<MethodDesc, MethodDesc, bool> s_VerifyMethodsHaveTheSameVirtualSlot;
    private static MetadataVirtualMethodAlgorithm();
    public virtual MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, TypeDesc objectType);
    private static MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, MetadataType objectType);
    private static bool IsInterfaceImplementedOnType(MetadataType type, MetadataType interfaceType);
    private static MethodDesc FindImplFromDeclFromMethodImpls(MetadataType type, MethodDesc decl);
    private static bool IsInterfaceExplicitlyImplementedOnType(MetadataType type, MetadataType interfaceType);
    private static MethodDesc FindMatchingVirtualMethodOnTypeByNameAndSig(MethodDesc targetMethod, DefType currentType, bool reverseMethodSearch, Func`3<MethodDesc, MethodDesc, bool> nameSigMatchMethodIsValidCandidate);
    private static MethodDesc FindNameSigOverrideForVirtualMethod(MethodDesc targetMethod, MetadataType currentType);
    public static MethodDesc FindSlotDefiningMethodForVirtualMethod(MethodDesc method);
    private static MethodDesc FindMatchingVirtualMethodOnTypeByNameAndSigWithSlotCheck(MethodDesc method, DefType currentType, bool reverseMethodSearch);
    private static bool VerifyMethodsHaveTheSameVirtualSlot(MethodDesc slotDefiningMethod, MethodDesc methodToVerify);
    private static void FindBaseUnificationGroup(MetadataType currentType, UnificationGroup unificationGroup);
    public virtual MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public virtual MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    private static MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, MetadataType currentType);
    public static MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, MetadataType currentType);
    private static MethodDesc ResolveInterfaceMethodToVirtualMethodOnTypeRecursive(MethodDesc interfaceMethod, MetadataType currentType);
    private static MethodDesc FindNameSigOverrideForInterfaceMethodRecursive(MethodDesc interfaceMethod, MetadataType currentType);
    public virtual IEnumerable`1<MethodDesc> ComputeAllVirtualSlots(TypeDesc type);
    [IteratorStateMachineAttribute("Internal.TypeSystem.MetadataVirtualMethodAlgorithm/<EnumAllVirtualSlots>d__21")]
public static IEnumerable`1<MethodDesc> EnumAllVirtualSlots(MetadataType type);
}
public abstract class Internal.TypeSystem.MethodDesc : TypeSystemEntity {
    public static MethodDesc[] EmptyMethods;
    private int _hashcode;
    public bool IsIntrinsic { get; }
    public bool IsNoInlining { get; }
    public bool IsAggressiveInlining { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool IsNativeCallable { get; }
    public bool IsRuntimeExport { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public bool IsConstructor { get; }
    public bool IsDefaultConstructor { get; }
    public bool IsStaticConstructor { get; }
    public string Name { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsMethodDefinition { get; }
    public bool IsTypicalMethodDefinition { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsFinalizer { get; }
    protected internal int ClassCode { get; }
    public bool IsPInvoke { get; }
    public TypeDesc ImplementationType { get; }
    public bool IsSharedByGenericInstantiations { get; }
    public bool IsRuntimeDeterminedExactMethod { get; }
    private static MethodDesc();
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual bool get_IsIntrinsic();
    public virtual bool get_IsNoInlining();
    public virtual bool get_IsAggressiveInlining();
    public virtual bool get_IsRuntimeImplemented();
    public virtual bool get_IsInternalCall();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsNativeCallable();
    public virtual bool get_IsRuntimeExport();
    protected void SetHashCode(int hashcode);
    public sealed virtual int GetHashCode();
    private int AcquireHashCode();
    protected virtual int ComputeHashCode();
    public virtual bool Equals(object o);
    public abstract virtual TypeDesc get_OwningType();
    public abstract virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    public bool get_IsConstructor();
    public virtual bool get_IsDefaultConstructor();
    public bool get_IsStaticConstructor();
    public virtual string get_Name();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetMethodDefinition();
    public bool get_IsMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public bool get_IsTypicalMethodDefinition();
    public bool get_IsGenericMethodDefinition();
    public bool get_IsFinalizer();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual string ToString();
    protected internal abstract virtual int get_ClassCode();
    protected internal abstract virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public virtual bool get_IsPInvoke();
    public virtual PInvokeMetadata GetPInvokeMethodMetadata();
    public virtual ParameterMetadata[] GetParameterMetadata();
    public MethodDesc GetSharedRuntimeFormMethodTarget();
    public TypeDesc get_ImplementationType();
    public bool get_IsSharedByGenericInstantiations();
    public bool get_IsRuntimeDeterminedExactMethod();
    public virtual MethodDesc GetNonRuntimeDeterminedMethodFromRuntimeDeterminedMethodViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
public class Internal.TypeSystem.MethodForInstantiatedType : MethodDesc {
    private MethodDesc _typicalMethodDef;
    private InstantiatedType _instantiatedType;
    private MethodSignature _signature;
    public bool IsIntrinsic { get; }
    public bool IsNoInlining { get; }
    public bool IsAggressiveInlining { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsInternalCall { get; }
    public bool IsSynchronized { get; }
    public bool IsNativeCallable { get; }
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    protected internal int ClassCode { get; }
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual bool get_IsIntrinsic();
    public virtual bool get_IsNoInlining();
    public virtual bool get_IsAggressiveInlining();
    public virtual bool get_IsRuntimeImplemented();
    public virtual bool get_IsInternalCall();
    public virtual bool get_IsSynchronized();
    public virtual bool get_IsNativeCallable();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual bool get_IsDefaultConstructor();
    public virtual string get_Name();
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
    public virtual ParameterMetadata[] GetParameterMetadata();
}
public class Internal.TypeSystem.MethodForRuntimeDeterminedType : MethodDesc {
    private MethodDesc _typicalMethodDef;
    private RuntimeDeterminedType _rdType;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    public Instantiation Instantiation { get; }
    protected internal int ClassCode { get; }
    internal MethodForRuntimeDeterminedType(MethodDesc typicalMethodDef, RuntimeDeterminedType rdType);
    internal MethodForRuntimeDeterminedType(MethodDesc typicalMethodDef, RuntimeDeterminedType rdType, int hashcode);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool get_IsDefaultConstructor();
    public virtual string get_Name();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual Instantiation get_Instantiation();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(MethodDesc other, TypeSystemComparer comparer);
}
public class Internal.TypeSystem.MethodImplRecord : ValueType {
    public MethodDesc Decl;
    public MethodDesc Body;
    public MethodImplRecord(MethodDesc decl, MethodDesc body);
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.MethodSignature : TypeSystemEntity {
    internal MethodSignatureFlags _flags;
    internal int _genericParameterCount;
    internal TypeDesc _returnType;
    internal TypeDesc[] _parameters;
    public MethodSignatureFlags Flags { get; }
    public bool IsStatic { get; }
    public int GenericParameterCount { get; }
    public TypeDesc ReturnType { get; }
    public TypeDesc Parameter { get; }
    public int Length { get; }
    public TypeSystemContext Context { get; }
    public MethodSignature(MethodSignatureFlags flags, int genericParameterCount, TypeDesc returnType, TypeDesc[] parameters);
    public MethodSignatureFlags get_Flags();
    public bool get_IsStatic();
    public int get_GenericParameterCount();
    public TypeDesc get_ReturnType();
    public TypeDesc get_Parameter(int index);
    public int get_Length();
    public bool Equals(MethodSignature otherSignature);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SignatureEnumerator GetEnumerator();
    public virtual TypeSystemContext get_Context();
    public virtual string ToString();
    public string ToString(bool includeReturnType);
    internal int CompareTo(MethodSignature other, TypeSystemComparer comparer);
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.MethodSignatureBuilder : ValueType {
    private MethodSignature _template;
    private MethodSignatureFlags _flags;
    private int _genericParameterCount;
    private TypeDesc _returnType;
    private TypeDesc[] _parameters;
    unknown MethodSignatureFlags Flags {public set; }
    unknown TypeDesc ReturnType {public set; }
    unknown TypeDesc Parameter {public set; }
    unknown int Length {public set; }
    public MethodSignatureBuilder(MethodSignature template);
    public void set_Flags(MethodSignatureFlags value);
    public void set_ReturnType(TypeDesc value);
    public void set_Parameter(int index, TypeDesc value);
    public void set_Length(int value);
    public MethodSignature ToSignature();
}
[FlagsAttribute]
public enum Internal.TypeSystem.MethodSignatureFlags : Enum {
    public int value__;
    public static MethodSignatureFlags None;
    public static MethodSignatureFlags UnmanagedCallingConventionMask;
    public static MethodSignatureFlags UnmanagedCallingConventionCdecl;
    public static MethodSignatureFlags UnmanagedCallingConventionStdCall;
    public static MethodSignatureFlags UnmanagedCallingConventionThisCall;
    public static MethodSignatureFlags CallingConventionVarargs;
    public static MethodSignatureFlags Static;
}
public abstract class Internal.TypeSystem.ModuleDesc : TypeSystemEntity {
    [CompilerGeneratedAttribute]
private TypeSystemContext <Context>k__BackingField;
    public TypeSystemContext Context { get; }
    public ModuleDesc(TypeSystemContext context);
    [CompilerGeneratedAttribute]
public virtual TypeSystemContext get_Context();
    public abstract virtual MetadataType GetType(string nameSpace, string name, bool throwIfNotFound);
    public abstract virtual MetadataType GetGlobalModuleType();
    public abstract virtual IEnumerable`1<MetadataType> GetAllTypes();
}
[FlagsAttribute]
public enum Internal.TypeSystem.NativeTypeKind : Enum {
    public byte value__;
    public static NativeTypeKind Boolean;
    public static NativeTypeKind I1;
    public static NativeTypeKind U1;
    public static NativeTypeKind I2;
    public static NativeTypeKind U2;
    public static NativeTypeKind I4;
    public static NativeTypeKind U4;
    public static NativeTypeKind I8;
    public static NativeTypeKind U8;
    public static NativeTypeKind R4;
    public static NativeTypeKind R8;
    public static NativeTypeKind LPStr;
    public static NativeTypeKind LPWStr;
    public static NativeTypeKind LPTStr;
    public static NativeTypeKind ByValTStr;
    public static NativeTypeKind Struct;
    public static NativeTypeKind ByValArray;
    public static NativeTypeKind SysInt;
    public static NativeTypeKind SysUInt;
    public static NativeTypeKind Int;
    public static NativeTypeKind UInt;
    public static NativeTypeKind Func;
    public static NativeTypeKind Array;
    public static NativeTypeKind LPStruct;
    public static NativeTypeKind Invalid;
    public static NativeTypeKind Variant;
}
public abstract class Internal.TypeSystem.ParameterizedType : TypeDesc {
    private TypeDesc _parameterType;
    public TypeDesc ParameterType { get; }
    public TypeSystemContext Context { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    internal ParameterizedType(TypeDesc parameterType);
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public TypeDesc get_ParameterType();
    public virtual TypeSystemContext get_Context();
    public sealed virtual bool get_IsRuntimeDeterminedSubtype();
}
public class Internal.TypeSystem.ParameterMetadata : ValueType {
    private ParameterMetadataAttributes _attributes;
    public MarshalAsDescriptor MarshalAsDescriptor;
    public int Index;
    public bool In { get; }
    public bool Out { get; }
    public bool Return { get; }
    public bool Optional { get; }
    public bool HasDefault { get; }
    public bool HasFieldMarshal { get; }
    public ParameterMetadata(int index, ParameterMetadataAttributes attributes, MarshalAsDescriptor marshalAsDescriptor);
    public bool get_In();
    public bool get_Out();
    public bool get_Return();
    public bool get_Optional();
    public bool get_HasDefault();
    public bool get_HasFieldMarshal();
}
[FlagsAttribute]
public enum Internal.TypeSystem.ParameterMetadataAttributes : Enum {
    public int value__;
    public static ParameterMetadataAttributes None;
    public static ParameterMetadataAttributes In;
    public static ParameterMetadataAttributes Out;
    public static ParameterMetadataAttributes Optional;
    public static ParameterMetadataAttributes HasDefault;
    public static ParameterMetadataAttributes HasFieldMarshal;
}
[FlagsAttribute]
public enum Internal.TypeSystem.PInvokeAttributes : Enum {
    public short value__;
    public static PInvokeAttributes None;
    public static PInvokeAttributes ExactSpelling;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes BestFitMappingEnable;
    public static PInvokeAttributes BestFitMappingDisable;
    public static PInvokeAttributes BestFitMappingMask;
    public static PInvokeAttributes SetLastError;
    public static PInvokeAttributes CallingConventionWinApi;
    public static PInvokeAttributes CallingConventionCDecl;
    public static PInvokeAttributes CallingConventionStdCall;
    public static PInvokeAttributes CallingConventionThisCall;
    public static PInvokeAttributes CallingConventionFastCall;
    public static PInvokeAttributes CallingConventionMask;
    public static PInvokeAttributes ThrowOnUnmappableCharEnable;
    public static PInvokeAttributes ThrowOnUnmappableCharDisable;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
}
public class Internal.TypeSystem.PInvokeFlags : ValueType {
    private PInvokeAttributes _attributes;
    public PInvokeAttributes Attributes { get; }
    public CharSet CharSet { get; public set; }
    public MethodSignatureFlags UnmanagedCallingConvention { get; public set; }
    public bool SetLastError { get; public set; }
    public bool ExactSpelling { get; public set; }
    public bool BestFitMapping { get; public set; }
    public bool ThrowOnUnmappableChar { get; public set; }
    public PInvokeFlags(PInvokeAttributes attributes);
    public PInvokeAttributes get_Attributes();
    public CharSet get_CharSet();
    public void set_CharSet(CharSet value);
    public MethodSignatureFlags get_UnmanagedCallingConvention();
    public void set_UnmanagedCallingConvention(MethodSignatureFlags value);
    public bool get_SetLastError();
    public void set_SetLastError(bool value);
    public bool get_ExactSpelling();
    public void set_ExactSpelling(bool value);
    public bool get_BestFitMapping();
    public void set_BestFitMapping(bool value);
    public bool get_ThrowOnUnmappableChar();
    public void set_ThrowOnUnmappableChar(bool value);
    public sealed virtual int CompareTo(PInvokeFlags other);
    public sealed virtual bool Equals(PInvokeFlags other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Internal.TypeSystem.PInvokeMetadata : ValueType {
    public string Name;
    public string Module;
    public PInvokeFlags Flags;
    public PInvokeMetadata(string module, string entrypoint, PInvokeAttributes attributes);
    public PInvokeMetadata(string module, string entrypoint, PInvokeFlags flags);
}
public enum Internal.TypeSystem.PInvokeStringFormat : Enum {
    public int value__;
    public static PInvokeStringFormat AnsiClass;
    public static PInvokeStringFormat UnicodeClass;
    public static PInvokeStringFormat AutoClass;
}
public class Internal.TypeSystem.PointerType : ParameterizedType {
    protected internal int ClassCode { get; }
    internal PointerType(TypeDesc parameterType);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
    protected internal virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
[DefaultMemberAttribute("Parameter")]
public class Internal.TypeSystem.PropertySignature : ValueType {
    private TypeDesc[] _parameters;
    public bool IsStatic;
    public TypeDesc ReturnType;
    public TypeDesc Parameter { get; }
    public int Length { get; }
    public PropertySignature(bool isStatic, TypeDesc[] parameters, TypeDesc returnType);
    public TypeDesc get_Parameter(int index);
    public int get_Length();
}
public static class Internal.TypeSystem.RuntimeDeterminedCanonicalizationAlgorithm : object {
    public static Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    public static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    public static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
}
public class Internal.TypeSystem.RuntimeDeterminedFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType defType, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType defType, StaticLayoutKind layoutKind);
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
}
public class Internal.TypeSystem.RuntimeDeterminedType : DefType {
    private DefType _rawCanonType;
    private GenericParameterDesc _runtimeDeterminedDetailsType;
    public GenericParameterDesc RuntimeDeterminedDetailsType { get; }
    public DefType CanonicalType { get; }
    public TypeSystemContext Context { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    public DefType BaseType { get; }
    public Instantiation Instantiation { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected internal int ClassCode { get; }
    public RuntimeDeterminedType(DefType rawCanonType, GenericParameterDesc runtimeDeterminedDetailsType);
    public GenericParameterDesc get_RuntimeDeterminedDetailsType();
    public DefType get_CanonicalType();
    public virtual TypeSystemContext get_Context();
    public virtual bool get_IsRuntimeDeterminedSubtype();
    public virtual DefType get_BaseType();
    public virtual Instantiation get_Instantiation();
    public virtual string get_Name();
    public virtual string get_Namespace();
    [IteratorStateMachineAttribute("Internal.TypeSystem.RuntimeDeterminedType/<GetMethods>d__19")]
public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc GetTypeDefinition();
    public virtual int GetHashCode();
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
    protected internal sealed virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
internal static class Internal.TypeSystem.RuntimeDeterminedTypeUtilities : object {
    public static Instantiation ConvertInstantiationToSharedRuntimeForm(Instantiation instantiation, Instantiation openInstantiation, Boolean& changed);
}
public abstract class Internal.TypeSystem.RuntimeInterfacesAlgorithm : object {
    public abstract virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
public class Internal.TypeSystem.SignatureMethodVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    protected internal int ClassCode { get; }
    internal SignatureMethodVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
}
public class Internal.TypeSystem.SignatureTypeVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    protected internal int ClassCode { get; }
    internal SignatureTypeVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal virtual int get_ClassCode();
}
public abstract class Internal.TypeSystem.SignatureVariable : TypeDesc {
    private TypeSystemContext _context;
    private int _index;
    public int Index { get; }
    public TypeSystemContext Context { get; }
    public bool IsMethodSignatureVariable { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    internal SignatureVariable(TypeSystemContext context, int index);
    public int get_Index();
    public virtual TypeSystemContext get_Context();
    public abstract virtual bool get_IsMethodSignatureVariable();
    public sealed virtual bool get_IsRuntimeDeterminedSubtype();
    public virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal sealed virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
public enum Internal.TypeSystem.SimdVectorLength : Enum {
    public int value__;
    public static SimdVectorLength None;
    public static SimdVectorLength Vector128Bit;
    public static SimdVectorLength Vector256Bit;
}
public static class Internal.TypeSystem.StandardCanonicalizationAlgorithm : object {
    public static Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    public static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    private static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
}
public enum Internal.TypeSystem.StaticLayoutKind : Enum {
    public int value__;
    public static StaticLayoutKind StaticRegionSizes;
    public static StaticLayoutKind StaticRegionSizesAndFields;
}
public class Internal.TypeSystem.StaticsBlock : ValueType {
    public LayoutInt Size;
    public LayoutInt LargestAlignment;
}
public enum Internal.TypeSystem.TargetAbi : Enum {
    public int value__;
    public static TargetAbi Unknown;
    public static TargetAbi CoreRT;
    public static TargetAbi ProjectN;
    public static TargetAbi Jit;
    public static TargetAbi CppCodegen;
}
public enum Internal.TypeSystem.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture Unknown;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARMEL;
    public static TargetArchitecture ARM64;
    public static TargetArchitecture X64;
    public static TargetArchitecture X86;
    public static TargetArchitecture Wasm32;
}
public class Internal.TypeSystem.TargetDetails : object {
    [CompilerGeneratedAttribute]
private SimdVectorLength <MaximumSimdVectorLength>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetOS <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetAbi <Abi>k__BackingField;
    public SimdVectorLength MaximumSimdVectorLength { get; }
    public TargetArchitecture Architecture { get; }
    public TargetOS OperatingSystem { get; }
    public TargetAbi Abi { get; }
    public int PointerSize { get; }
    public bool SupportsRelativePointers { get; }
    public static int MaximumAlignment { get; }
    public LayoutInt LayoutPointerSize { get; }
    public int DefaultPackingSize { get; }
    public int MinimumFunctionAlignment { get; }
    public int MinimumCodeAlignment { get; }
    public bool IsWindows { get; }
    public int MaximumHfaElementCount { get; }
    public TargetDetails(TargetArchitecture architecture, TargetOS targetOS, TargetAbi abi, SimdVectorLength simdVectorLength);
    public TargetDetails(TargetArchitecture architecture, TargetOS targetOS, TargetAbi abi);
    [CompilerGeneratedAttribute]
public SimdVectorLength get_MaximumSimdVectorLength();
    [CompilerGeneratedAttribute]
public TargetArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public TargetOS get_OperatingSystem();
    [CompilerGeneratedAttribute]
public TargetAbi get_Abi();
    public int get_PointerSize();
    public bool get_SupportsRelativePointers();
    public static int get_MaximumAlignment();
    public LayoutInt get_LayoutPointerSize();
    public int get_DefaultPackingSize();
    public int get_MinimumFunctionAlignment();
    public int get_MinimumCodeAlignment();
    public LayoutInt GetWellKnownTypeSize(DefType type);
    public LayoutInt GetWellKnownTypeAlignment(DefType type);
    public LayoutInt GetObjectAlignment(LayoutInt fieldAlignment);
    public bool get_IsWindows();
    public int get_MaximumHfaElementCount();
}
public enum Internal.TypeSystem.TargetOS : Enum {
    public int value__;
    public static TargetOS Unknown;
    public static TargetOS Windows;
    public static TargetOS Linux;
    public static TargetOS OSX;
    public static TargetOS FreeBSD;
    public static TargetOS NetBSD;
    public static TargetOS WebAssembly;
}
public class Internal.TypeSystem.ThreadSafeFlags : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public int Value { get; }
    public int get_Value();
    public bool HasFlags(int value);
    public void AddFlags(int flagsToAdd);
}
public static class Internal.TypeSystem.ThrowHelper : object {
    [DebuggerHiddenAttribute]
private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName, string messageArg);
    [DebuggerHiddenAttribute]
private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName);
    [DebuggerHiddenAttribute]
public static void ThrowMissingMethodException(TypeDesc owningType, string methodName, MethodSignature signature);
    [DebuggerHiddenAttribute]
public static void ThrowMissingFieldException(TypeDesc owningType, string fieldName);
    [DebuggerHiddenAttribute]
public static void ThrowFileNotFoundException(ExceptionStringID id, string fileName);
    [DebuggerHiddenAttribute]
public static void ThrowInvalidProgramException();
    [DebuggerHiddenAttribute]
public static void ThrowInvalidProgramException(ExceptionStringID id, MethodDesc method);
    [DebuggerHiddenAttribute]
public static void ThrowBadImageFormatException();
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string nestedTypeName, ModuleDesc module);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string namespace, string name, ModuleDesc module);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(TypeDesc type);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, MethodDesc method);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type, string messageArg);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type);
}
public abstract class Internal.TypeSystem.TypeDesc : TypeSystemEntity {
    private TypeDesc _specificCanonCache;
    private TypeDesc _universalCanonCache;
    public static TypeDesc[] EmptyTypes;
    private TypeFlags _typeFlags;
    private DefType[] _runtimeInterfaces;
    internal bool IsCanonicalType { get; }
    public bool IsIntrinsic { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public TypeFlags Category { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsPrimitive { get; }
    public bool IsEnum { get; }
    public bool IsDelegate { get; }
    public bool IsVoid { get; }
    public bool IsString { get; }
    public bool IsObject { get; }
    public bool IsNullable { get; }
    public bool IsByReferenceOfT { get; }
    public bool IsArray { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsFunctionPointer { get; }
    public bool IsSignatureVariable { get; }
    public bool IsGenericParameter { get; }
    public bool IsParameterizedType { get; }
    public bool IsDefType { get; }
    public bool IsGCPointer { get; }
    public DefType BaseType { get; }
    public bool HasBaseType { get; }
    public TypeDesc UnderlyingType { get; }
    public bool HasStaticConstructor { get; }
    public bool IsTypeDefinition { get; }
    public bool HasFinalizer { get; }
    public bool HasVariance { get; }
    public bool IsGenericDefinition { get; }
    public bool IsByRefLike { get; }
    public DefType[] RuntimeInterfaces { get; }
    public bool IsRuntimeDeterminedSubtype { get; }
    public bool IsRuntimeDeterminedType { get; }
    protected internal int ClassCode { get; }
    private static TypeDesc();
    private TypeDesc GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, TypeDesc value);
    public TypeDesc ConvertToCanonForm(CanonicalFormKind kind);
    protected abstract virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public abstract virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    internal bool get_IsCanonicalType();
    public bool get_IsIntrinsic();
    public abstract virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    internal void SetWellKnownType(WellKnownType wellKnownType);
    protected abstract virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private TypeFlags InitializeTypeFlags(TypeFlags mask);
    protected internal TypeFlags GetTypeFlags(TypeFlags mask);
    public TypeFlags get_Category();
    public bool get_IsInterface();
    public bool get_IsValueType();
    public bool get_IsPrimitive();
    public bool get_IsEnum();
    public bool get_IsDelegate();
    public bool get_IsVoid();
    public bool get_IsString();
    public bool get_IsObject();
    public bool get_IsNullable();
    public bool get_IsByReferenceOfT();
    public bool get_IsArray();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public bool get_IsByRef();
    public bool get_IsPointer();
    public bool get_IsFunctionPointer();
    public bool get_IsSignatureVariable();
    public bool get_IsGenericParameter();
    public bool get_IsParameterizedType();
    public bool get_IsDefType();
    public bool get_IsGCPointer();
    public virtual DefType get_BaseType();
    public bool get_HasBaseType();
    public virtual TypeDesc get_UnderlyingType();
    public bool get_HasStaticConstructor();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public bool get_IsTypeDefinition();
    public bool HasSameTypeDefinition(TypeDesc otherType);
    public bool get_HasFinalizer();
    public virtual MethodDesc GetFinalizer();
    public bool get_HasVariance();
    public bool get_IsGenericDefinition();
    public bool get_IsByRefLike();
    public virtual string ToString();
    public DefType[] get_RuntimeInterfaces();
    private DefType[] InitializeRuntimeInterfaces();
    public abstract virtual bool get_IsRuntimeDeterminedSubtype();
    public bool get_IsRuntimeDeterminedType();
    public abstract virtual TypeDesc GetNonRuntimeDeterminedTypeFromRuntimeDeterminedSubtypeViaSubstitution(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected internal abstract virtual int get_ClassCode();
    protected internal abstract virtual int CompareToImpl(TypeDesc other, TypeSystemComparer comparer);
}
[FlagsAttribute]
public enum Internal.TypeSystem.TypeFlags : Enum {
    public int value__;
    public static TypeFlags CategoryMask;
    public static TypeFlags Unknown;
    public static TypeFlags Void;
    public static TypeFlags Boolean;
    public static TypeFlags Char;
    public static TypeFlags SByte;
    public static TypeFlags Byte;
    public static TypeFlags Int16;
    public static TypeFlags UInt16;
    public static TypeFlags Int32;
    public static TypeFlags UInt32;
    public static TypeFlags Int64;
    public static TypeFlags UInt64;
    public static TypeFlags IntPtr;
    public static TypeFlags UIntPtr;
    public static TypeFlags Single;
    public static TypeFlags Double;
    public static TypeFlags ValueType;
    public static TypeFlags Enum;
    public static TypeFlags Nullable;
    public static TypeFlags Class;
    public static TypeFlags Interface;
    public static TypeFlags Array;
    public static TypeFlags SzArray;
    public static TypeFlags ByRef;
    public static TypeFlags Pointer;
    public static TypeFlags FunctionPointer;
    public static TypeFlags GenericParameter;
    public static TypeFlags SignatureTypeVariable;
    public static TypeFlags SignatureMethodVariable;
    public static TypeFlags HasGenericVariance;
    public static TypeFlags HasGenericVarianceComputed;
    public static TypeFlags HasStaticConstructor;
    public static TypeFlags HasStaticConstructorComputed;
    public static TypeFlags HasFinalizerComputed;
    public static TypeFlags HasFinalizer;
    public static TypeFlags IsByRefLike;
    public static TypeFlags AttributeCacheComputed;
    public static TypeFlags IsIntrinsic;
}
public abstract class Internal.TypeSystem.TypeNameFormatter : object {
    public void AppendName(StringBuilder sb, TypeDesc type);
    public void AppendName(StringBuilder sb, DefType type);
    public abstract virtual void AppendName(StringBuilder sb, ArrayType type);
    public abstract virtual void AppendName(StringBuilder sb, ByRefType type);
    public abstract virtual void AppendName(StringBuilder sb, PointerType type);
    public abstract virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public abstract virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    protected abstract virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    protected abstract virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected abstract virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    public string FormatName(TypeDesc type);
}
public abstract class Internal.TypeSystem.TypeNameFormatter`2 : object {
    public TState AppendName(StringBuilder sb, TypeDesc type, TOptions options);
    public TState AppendName(StringBuilder sb, DefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ArrayType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ByRefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, PointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, FunctionPointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, GenericParameterDesc type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureMethodVariable type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureTypeVariable type, TOptions options);
    protected abstract virtual TState AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType, TOptions options);
    protected abstract virtual TState AppendNameForNamespaceType(StringBuilder sb, DefType type, TOptions options);
    protected abstract virtual TState AppendNameForInstantiatedType(StringBuilder sb, DefType type, TOptions options);
    public string FormatName(TypeDesc type, TOptions options);
}
public class Internal.TypeSystem.TypeSystemComparer : object {
    public int Compare(TypeDesc x, TypeDesc y);
    internal int CompareWithinClass(T x, T y);
    public int Compare(MethodDesc x, MethodDesc y);
    public int Compare(FieldDesc x, FieldDesc y);
    public int Compare(MethodSignature x, MethodSignature y);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.TypeSystemConstraintsHelpers : object {
    private static bool VerifyGenericParamConstraint(InstantiationContext genericParamContext, GenericParameterDesc genericParam, InstantiationContext instantiationParamContext, TypeDesc instantiationParam);
    private static bool CheckGenericSpecialConstraint(TypeDesc type, GenericConstraints specialConstraint);
    private static void GetInstantiatedConstraintsRecursive(InstantiationContext typeContext, TypeDesc type, ArrayBuilder`1& instantiatedConstraints);
    private static bool CanCastConstraint(ArrayBuilder`1& instantiatedConstraints, TypeDesc instantiatedType);
    [ExtensionAttribute]
public static bool CheckValidInstantiationArguments(Instantiation instantiation);
    [ExtensionAttribute]
public static bool CheckConstraints(TypeDesc type, InstantiationContext context);
    [ExtensionAttribute]
public static bool CheckConstraints(MethodDesc method, InstantiationContext context);
}
public abstract class Internal.TypeSystem.TypeSystemContext : object {
    private CanonType _canonType;
    private UniversalCanonType _universalCanonType;
    [CompilerGeneratedAttribute]
private TargetDetails <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleDesc <SystemModule>k__BackingField;
    private ArrayTypeKeyHashtable _arrayTypes;
    private ByRefHashtable _byRefTypes;
    private PointerHashtable _pointerTypes;
    private FunctionPointerHashtable _functionPointerTypes;
    private InstantiatedTypeKeyHashtable _instantiatedTypes;
    private InstantiatedMethodKeyHashtable _instantiatedMethods;
    private MethodForInstantiatedTypeKeyHashtable _methodForInstantiatedTypes;
    private FieldForInstantiatedTypeKeyHashtable _fieldForInstantiatedTypes;
    private SignatureVariableHashtable _signatureVariables;
    private DelegateInfoHashtable _delegateInfoHashtable;
    private DynamicInvokeThunkHashtable _dynamicInvokeThunks;
    private ModuleDesc _generatedAssembly;
    private EnumInfoHashtable _enumInfoHashtable;
    private MethodDesc _objectEqualsMethod;
    private ValueTypeMethodHashtable _valueTypeMethodHashtable;
    private TypeStateHashtable _typeStateHashtable;
    private RuntimeDeterminedTypeKeyHashtable _runtimeDeterminedTypes;
    private MethodForRuntimeDeterminedTypeKeyHashtable _methodForRDTypes;
    public CanonBaseType CanonType { get; }
    public CanonBaseType UniversalCanonType { get; }
    protected internal ModuleDesc CanonTypesModule { get; }
    public bool SupportsCanon { get; }
    public bool SupportsUniversalCanon { get; }
    public TargetDetails Target { get; }
    public ModuleDesc SystemModule { get; private set; }
    public ModuleDesc GeneratedAssembly { get; }
    public TypeSystemContext(TargetDetails target);
    public CanonBaseType get_CanonType();
    public CanonBaseType get_UniversalCanonType();
    protected internal virtual ModuleDesc get_CanonTypesModule();
    public bool IsCanonicalDefinitionType(TypeDesc type, CanonicalFormKind kind);
    public Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    public abstract virtual bool get_SupportsCanon();
    public abstract virtual bool get_SupportsUniversalCanon();
    public MetadataType GetCanonType(string name);
    [CompilerGeneratedAttribute]
public TargetDetails get_Target();
    [CompilerGeneratedAttribute]
public ModuleDesc get_SystemModule();
    [CompilerGeneratedAttribute]
private void set_SystemModule(ModuleDesc value);
    protected void InitializeSystemModule(ModuleDesc systemModule);
    public abstract virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    public virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwIfNotFound);
    internal virtual ModuleDesc ResolveModule(ModuleDesc referencingModule, string fileName, bool throwIfNotFound);
    public ArrayType GetArrayType(TypeDesc elementType);
    public ArrayType GetArrayType(TypeDesc elementType, int rank);
    public ByRefType GetByRefType(TypeDesc parameterType);
    public PointerType GetPointerType(TypeDesc parameterType);
    public FunctionPointerType GetFunctionPointerType(MethodSignature signature);
    public InstantiatedType GetInstantiatedType(MetadataType typeDef, Instantiation instantiation);
    public InstantiatedMethod GetInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    public MethodDesc GetMethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    public FieldDesc GetFieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public TypeDesc GetSignatureVariable(int index, bool method);
    protected internal virtual IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(DefType type);
    public RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForType(TypeDesc type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected internal virtual bool ComputeHasGCStaticBase(FieldDesc field);
    internal TypeFlags ComputeTypeFlags(TypeDesc type, TypeFlags flags, TypeFlags mask);
    protected internal abstract virtual bool ComputeHasStaticConstructor(TypeDesc type);
    public DelegateInfo GetDelegateInfo(TypeDesc delegateType);
    public MethodDesc GetDynamicInvokeThunk(DynamicInvokeMethodSignature signature);
    public ModuleDesc get_GeneratedAssembly();
    public MethodDesc TryResolveConstrainedEnumMethod(TypeDesc enumType, MethodDesc virtualMethod);
    [IteratorStateMachineAttribute("Internal.TypeSystem.TypeSystemContext/<GetAllMethodsForEnum>d__82")]
protected virtual IEnumerable`1<MethodDesc> GetAllMethodsForEnum(TypeDesc enumType);
    [IteratorStateMachineAttribute("Internal.TypeSystem.TypeSystemContext/<GetAllMethodsForValueType>d__86")]
protected virtual IEnumerable`1<MethodDesc> GetAllMethodsForValueType(TypeDesc valueType);
    private bool RequiresGetFieldHelperMethod(MetadataType valueType);
    public RuntimeDeterminedType GetRuntimeDeterminedType(DefType plainCanonType, GenericParameterDesc detailsType);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
    public MethodDesc GetMethodForRuntimeDeterminedType(MethodDesc typicalMethodDef, RuntimeDeterminedType rdType);
}
public abstract class Internal.TypeSystem.TypeSystemEntity : object {
    public TypeSystemContext Context { get; }
    public abstract virtual TypeSystemContext get_Context();
}
public abstract class Internal.TypeSystem.TypeSystemException : Exception {
    private String[] _arguments;
    [CompilerGeneratedAttribute]
private ExceptionStringID <StringID>k__BackingField;
    public ExceptionStringID StringID { get; }
    public IReadOnlyList`1<string> Arguments { get; }
    public string Message { get; }
    internal TypeSystemException(ExceptionStringID id, String[] args);
    [CompilerGeneratedAttribute]
public ExceptionStringID get_StringID();
    public IReadOnlyList`1<string> get_Arguments();
    public virtual string get_Message();
    private static string GetExceptionString(ExceptionStringID id, String[] args);
}
[ExtensionAttribute]
public static class Internal.TypeSystem.TypeSystemHelpers : object {
    [ExtensionAttribute]
public static bool IsWellKnownType(TypeDesc type, WellKnownType wellKnownType);
    [ExtensionAttribute]
public static InstantiatedType MakeInstantiatedType(MetadataType typeDef, Instantiation instantiation);
    [ExtensionAttribute]
public static InstantiatedType MakeInstantiatedType(MetadataType typeDef, TypeDesc[] genericParameters);
    [ExtensionAttribute]
public static InstantiatedMethod MakeInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    [ExtensionAttribute]
public static InstantiatedMethod MakeInstantiatedMethod(MethodDesc methodDef, TypeDesc[] genericParameters);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeDesc type);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeDesc type, int rank);
    [ExtensionAttribute]
public static ByRefType MakeByRefType(TypeDesc type);
    [ExtensionAttribute]
public static PointerType MakePointerType(TypeDesc type);
    [ExtensionAttribute]
public static TypeDesc GetParameterType(TypeDesc type);
    [ExtensionAttribute]
public static LayoutInt GetElementSize(TypeDesc type);
    [ExtensionAttribute]
public static MethodDesc GetParameterlessConstructor(TypeDesc type);
    [ExtensionAttribute]
public static bool HasExplicitOrImplicitDefaultConstructor(TypeDesc type);
    [ExtensionAttribute]
internal static MethodDesc FindMethodOnExactTypeWithMatchingTypicalMethod(TypeDesc type, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc FindMethodOnTypeWithMatchingTypicalMethod(TypeDesc targetType, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc TryResolveConstraintMethodApprox(TypeDesc constrainedType, TypeDesc interfaceType, MethodDesc interfaceMethod, Boolean& forceRuntimeLookup);
    [ExtensionAttribute]
public static string GetFullName(DefType metadataType);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> EnumAllVirtualSlots(TypeDesc type);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc FindVirtualFunctionTargetMethodOnObjectType(TypeDesc type, MethodDesc targetMethod);
    [ExtensionAttribute]
public static TypeDesc InstantiateAsOpen(TypeDesc type);
    [ExtensionAttribute]
public static FieldDesc InstantiateAsOpen(FieldDesc field);
    [ExtensionAttribute]
public static MethodDesc InstantiateAsOpen(MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodTarget(TypeDesc thisType, MethodDesc interfaceMethodToResolve);
}
public class Internal.TypeSystem.UniqueTypeNameFormatter : TypeNameFormatter {
    [CompilerGeneratedAttribute]
private static UniqueTypeNameFormatter <Instance>k__BackingField;
    private static Char[] s_escapedChars;
    public static UniqueTypeNameFormatter Instance { get; }
    private static UniqueTypeNameFormatter();
    [CompilerGeneratedAttribute]
public static UniqueTypeNameFormatter get_Instance();
    public virtual void AppendName(StringBuilder sb, PointerType type);
    public virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    public virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public virtual void AppendName(StringBuilder sb, ByRefType type);
    public virtual void AppendName(StringBuilder sb, ArrayType type);
    protected virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    private void AppendAssemblyName(StringBuilder sb, IAssemblyDesc assembly);
    protected virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    private string GetTypeName(DefType type);
    private string GetTypeNamespace(DefType type);
    private void AppendEscapedIdentifier(StringBuilder sb, string identifier);
}
public class Internal.TypeSystem.UniversalCanonLayoutAlgorithm : FieldLayoutAlgorithm {
    public static UniversalCanonLayoutAlgorithm Instance;
    private static UniversalCanonLayoutAlgorithm();
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
}
internal class Internal.TypeSystem.UniversalCanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public bool IsSealed { get; }
    public DefType BaseType { get; }
    protected internal int ClassCode { get; }
    public UniversalCanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual bool get_IsSealed();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
    protected internal virtual int get_ClassCode();
}
public enum Internal.TypeSystem.ValueTypeShapeCharacteristics : Enum {
    public int value__;
    public static ValueTypeShapeCharacteristics None;
    public static ValueTypeShapeCharacteristics HomogenousFloatAggregate;
}
public abstract class Internal.TypeSystem.VirtualMethodAlgorithm : object {
    public abstract virtual MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, TypeDesc objectType);
    public abstract virtual IEnumerable`1<MethodDesc> ComputeAllVirtualSlots(TypeDesc type);
}
public enum Internal.TypeSystem.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Unknown;
    public static WellKnownType Void;
    public static WellKnownType Boolean;
    public static WellKnownType Char;
    public static WellKnownType SByte;
    public static WellKnownType Byte;
    public static WellKnownType Int16;
    public static WellKnownType UInt16;
    public static WellKnownType Int32;
    public static WellKnownType UInt32;
    public static WellKnownType Int64;
    public static WellKnownType UInt64;
    public static WellKnownType IntPtr;
    public static WellKnownType UIntPtr;
    public static WellKnownType Single;
    public static WellKnownType Double;
    public static WellKnownType ValueType;
    public static WellKnownType Enum;
    public static WellKnownType Nullable;
    public static WellKnownType Object;
    public static WellKnownType String;
    public static WellKnownType Array;
    public static WellKnownType MulticastDelegate;
    public static WellKnownType RuntimeTypeHandle;
    public static WellKnownType RuntimeMethodHandle;
    public static WellKnownType RuntimeFieldHandle;
    public static WellKnownType Exception;
    public static WellKnownType TypedReference;
    public static WellKnownType ByReferenceOfT;
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _items;
    private int _count;
    public int Count { get; }
    public T Item { get; public set; }
    public T[] ToArray();
    public void Add(T item);
    public void Append(T[] newItems);
    public void Append(T[] newItems, int offset, int length);
    public void Append(ArrayBuilder`1<T> newItems);
    public void ZeroExtend(int numItems);
    public void EnsureCapacity(int requestedCapacity);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public bool Contains(T t);
}
[ExtensionAttribute]
internal static class System.FormattingHelpers : object {
    [ExtensionAttribute]
public static string ToStringInvariant(T value);
    [ExtensionAttribute]
public static string ToStringInvariant(T value, string format);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
