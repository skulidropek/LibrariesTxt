internal static class FxResources.System.Security.Cryptography.Encoding.SR : object {
}
internal abstract class Internal.Cryptography.AsnFormatter : object {
    private static Char[] s_hexValues;
    private static AsnFormatter s_instance;
    internal static AsnFormatter Instance { get; }
    private static AsnFormatter();
    internal static AsnFormatter get_Instance();
    public string Format(Oid oid, Byte[] rawData, bool multiLine);
    protected abstract virtual string FormatNative(Oid oid, Byte[] rawData, bool multiLine);
    protected static string EncodeHexString(Byte[] sArray, bool spaceSeparated);
    private static string EncodeHexString(Byte[] sArray, UInt32 start, UInt32 end, bool spaceSeparated);
}
internal class Internal.Cryptography.CngAsnFormatter : AsnFormatter {
    protected virtual string FormatNative(Oid oid, Byte[] rawData, bool multiLine);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
}
internal static class Internal.Cryptography.OidLookup : object {
    private static ConcurrentDictionary`2<string, string> s_lateBoundOidToFriendlyName;
    private static ConcurrentDictionary`2<string, string> s_lateBoundFriendlyNameToOid;
    private static Dictionary`2<string, string> s_friendlyNameToOid;
    private static Dictionary`2<string, string> s_oidToFriendlyName;
    private static Dictionary`2<string, string> s_compatOids;
    private static OidLookup();
    public static string ToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    public static string ToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
    private static bool ShouldUseCache(OidGroup oidGroup);
    private static string NativeOidToFriendlyName(string oid, OidGroup oidGroup, bool fallBackToAllGroups);
    private static string NativeFriendlyNameToOid(string friendlyName, OidGroup oidGroup, bool fallBackToAllGroups);
}
internal static class Internal.NativeCrypto.BCryptNative : object {
}
[ExtensionAttribute]
internal static class Internal.NativeCrypto.Cng : object {
    public static string BCRYPT_3DES_ALGORITHM;
    public static string BCRYPT_AES_ALGORITHM;
    public static string BCRYPT_DES_ALGORITHM;
    public static string BCRYPT_RC2_ALGORITHM;
    public static string BCRYPT_CHAIN_MODE_CBC;
    public static string BCRYPT_CHAIN_MODE_ECB;
    public static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, OpenAlgorithmProviderFlags dwFlags);
    [ExtensionAttribute]
public static SafeKeyHandle BCryptImportKey(SafeAlgorithmHandle hAlg, Byte[] key);
    [ExtensionAttribute]
public static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode);
    [ExtensionAttribute]
public static void SetEffectiveKeyLength(SafeAlgorithmHandle hAlg, int effectiveKeyLength);
    [ExtensionAttribute]
public static int BCryptEncrypt(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] iv, Byte[] output, int outputOffset, int outputCount);
    [ExtensionAttribute]
public static int BCryptDecrypt(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] iv, Byte[] output, int outputOffset, int outputCount);
    public static string CryptFormatObject(string oidValue, Byte[] rawData, bool multiLine);
    private static Exception CreateCryptographicException(NTSTATUS ntStatus);
}
internal class Internal.NativeCrypto.SafeAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
}
internal abstract class Internal.NativeCrypto.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
}
internal class Internal.NativeCrypto.SafeKeyHandle : SafeBCryptHandle {
    private SafeAlgorithmHandle _parentHandle;
    public void SetParentHandle(SafeAlgorithmHandle parentHandle);
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptDestroyKey(IntPtr hKey);
}
internal static class Interop : object {
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
public class System.Security.Cryptography.AsnEncodedData : object {
    private Oid _oid;
    private Byte[] _rawData;
    public Oid Oid { get; public set; }
    public Byte[] RawData { get; public set; }
    public AsnEncodedData(Byte[] rawData);
    public AsnEncodedData(AsnEncodedData asnEncodedData);
    public AsnEncodedData(Oid oid, Byte[] rawData);
    public AsnEncodedData(string oid, Byte[] rawData);
    public Oid get_Oid();
    public void set_Oid(Oid value);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    public virtual string Format(bool multiLine);
    private void Reset(Oid oid, Byte[] rawData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.AsnEncodedDataCollection : object {
    private List`1<AsnEncodedData> _list;
    public AsnEncodedData Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
    public int Add(AsnEncodedData asnEncodedData);
    public void Remove(AsnEncodedData asnEncodedData);
    public AsnEncodedData get_Item(int index);
    public sealed virtual int get_Count();
    public AsnEncodedDataEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(AsnEncodedData[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.AsnEncodedDataEnumerator : object {
    private AsnEncodedDataCollection _asnEncodedDatas;
    private int _current;
    public AsnEncodedData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal AsnEncodedDataEnumerator(AsnEncodedDataCollection asnEncodedDatas);
    public AsnEncodedData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.FromBase64Transform : object {
    private Byte[] _inputBuffer;
    private int _inputIndex;
    private FromBase64TransformMode _whitespaces;
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public FromBase64Transform(FromBase64TransformMode whitespaces);
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Byte[] GetTempBuffer(Byte[] inputBuffer, int inputOffset, int inputCount, Int32& effectiveCount);
    private Byte[] ConvertFromBase64(Byte[] temp, int effectiveCount);
    private Byte[] DiscardWhiteSpaces(Byte[] inputBuffer, int inputOffset, int inputCount);
    private static void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    private void Reset();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public enum System.Security.Cryptography.FromBase64TransformMode : Enum {
    public int value__;
    public static FromBase64TransformMode IgnoreWhiteSpaces;
    public static FromBase64TransformMode DoNotIgnoreWhiteSpaces;
}
public class System.Security.Cryptography.Oid : object {
    private string _value;
    private string _friendlyName;
    private OidGroup _group;
    public string Value { get; public set; }
    public string FriendlyName { get; public set; }
    public Oid(string oid);
    public Oid(string value, string friendlyName);
    public Oid(Oid oid);
    private Oid(string value, string friendlyName, OidGroup group);
    public static Oid FromFriendlyName(string friendlyName, OidGroup group);
    public static Oid FromOidValue(string oidValue, OidGroup group);
    public string get_Value();
    public void set_Value(string value);
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.OidCollection : object {
    private List`1<Oid> _list;
    public Oid Item { get; }
    public Oid Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Add(Oid oid);
    public Oid get_Item(int index);
    public Oid get_Item(string oid);
    public sealed virtual int get_Count();
    public OidEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Oid[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.OidEnumerator : object {
    private OidCollection _oids;
    private int _current;
    public Oid Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OidEnumerator(OidCollection oids);
    public Oid get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.OidGroup : Enum {
    public int value__;
    public static OidGroup All;
    public static OidGroup HashAlgorithm;
    public static OidGroup EncryptionAlgorithm;
    public static OidGroup PublicKeyAlgorithm;
    public static OidGroup SignatureAlgorithm;
    public static OidGroup Attribute;
    public static OidGroup ExtensionOrAttribute;
    public static OidGroup EnhancedKeyUsage;
    public static OidGroup Policy;
    public static OidGroup Template;
    public static OidGroup KeyDerivationFunction;
}
public class System.Security.Cryptography.ToBase64Transform : object {
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    public bool CanTransformMultipleBlocks { get; }
    public bool CanReuseTransform { get; }
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public virtual bool get_CanReuseTransform();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Byte[] ConvertToBase64(Byte[] inputBuffer, int inputOffset, int inputCount);
    private static void ValidateTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    public sealed virtual void Dispose();
    public void Clear();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Cryptography_Oid_InvalidValue { get; }
    internal static string Cryptography_Oid_InvalidName { get; }
    internal static string Cryptography_SSE_InvalidDataSize { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string ObjectDisposed_Generic { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Cryptography_Oid_InvalidValue();
    internal static string get_Cryptography_Oid_InvalidName();
    internal static string get_Cryptography_SSE_InvalidDataSize();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidValue();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_ObjectDisposed_Generic();
}
