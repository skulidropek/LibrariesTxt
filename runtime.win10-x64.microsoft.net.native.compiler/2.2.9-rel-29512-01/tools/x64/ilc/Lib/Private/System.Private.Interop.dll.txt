internal static class FxResources.System.Private.Interop.SR : object {
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Interop.InteropCallbacks : object {
    [ExtensionAttribute]
public static bool ReportUnhandledError(Exception ex);
    [ExtensionAttribute]
public static Exception AttachRestrictedErrorInfo(Exception ex);
    public static object GetCOMWeakReferenceTarget(object weakReference);
    public static void SetCOMWeakReferenceTarget(object weakReference, object target);
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
internal class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string p0);
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
internal class Internal.Runtime.CompilerHelpers.RuntimeInteropData : InteropCallbacks {
    private static RuntimeInteropData s_interopData;
    public static RuntimeInteropData Instance { get; }
    public static RuntimeInteropData get_Instance();
    public virtual IntPtr GetForwardDelegateCreationStub(RuntimeTypeHandle delegateTypeHandle);
    public virtual IntPtr GetDelegateMarshallingStub(RuntimeTypeHandle delegateTypeHandle, bool openStaticDelegate);
    public virtual bool TryGetStructUnmarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& unmarshalStub);
    public virtual bool TryGetStructMarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& marshalStub);
    public virtual bool TryGetDestroyStructureStub(RuntimeTypeHandle structureTypeHandle, IntPtr& destroyStructureStub, Boolean& hasInvalidLayout);
    public virtual bool TryGetStructFieldOffset(RuntimeTypeHandle structureTypeHandle, string fieldName, Boolean& structExists, UInt32& offset);
    public virtual bool TryGetStructUnsafeStructSize(RuntimeTypeHandle structureTypeHandle, Int32& size);
}
[ExtensionAttribute]
internal static class Internal.Runtime.LowLevelStringConverter : object {
    private static string HexDigits;
    [ExtensionAttribute]
public static string LowLevelToString(int arg);
    [ExtensionAttribute]
public static string LowLevelToString(UInt32 arg);
    [ExtensionAttribute]
public static string LowLevelToString(IntPtr arg);
}
internal static class Interop : object {
    internal static string CORE_SYNCH_L2;
    internal static IntPtr MemAlloc(UIntPtr sizeInBytes);
    internal static void MemFree(IntPtr allocatedMemory);
    internal static IntPtr MemReAlloc(IntPtr ptr, UIntPtr newSize);
    internal static IntPtr MemAllocWithZeroInitializeNoThrow(UIntPtr sizeInBytes);
    internal static IntPtr MemReAllocWithZeroInitializeNoThrow(IntPtr ptr, UIntPtr oldSize, UIntPtr newSize);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.__ComGenericInterfaceDispatcher : object {
    public __ComObject m_comObject;
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.__ComObject : CastableObject {
    [DebuggerBrowsableAttribute("0")]
private ContextBoundInterfacePointer m_baseIUnknown;
    [DebuggerBrowsableAttribute("0")]
private int m_refCount;
    [DebuggerBrowsableAttribute("0")]
private ComObjectFlags m_flags;
    [DebuggerBrowsableAttribute("0")]
private ComCallableObject m_outer;
    [DebuggerBrowsableAttribute("0")]
private IntPtr m_savedIUnknownVtbl;
    [DebuggerBrowsableAttribute("0")]
internal SimpleComInterfaceCacheItem[] m_cachedInterfaces;
    internal static int FIXED_CACHE_SIZE;
    [DebuggerBrowsableAttribute("0")]
private AdditionalComInterfaceCacheContext[] m_additionalCachedInterfaces_dontAccessDirectly;
    [DebuggerBrowsableAttribute("0")]
private static AdditionalComInterfaceCacheContext[] CacheLocked;
    [DebuggerBrowsableAttribute("0")]
private RCWFinalizer m_finalizer;
    [DebuggerBrowsableAttribute("0")]
private static Dictionary`2<RuntimeTypeHandle, RuntimeTypeHandle> s_DynamicRCWAdapters;
    [DebuggerBrowsableAttribute("0")]
internal IntPtr BaseIUnknown_UnsafeNoAddRef { get; }
    [DebuggerBrowsableAttribute("0")]
internal IntPtr SavedIUnknownVtbl { get; }
    [DebuggerBrowsableAttribute("0")]
public UInt32 AllocationId { get; }
    [DebuggerBrowsableAttribute("0")]
internal ComCallableObject Outer { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
private ComMarshalingType MarshalingType { get; }
    [DebuggerBrowsableAttribute("0")]
private bool IsGCPressureSet { get; }
    [DebuggerBrowsableAttribute("0")]
private int GCMemoryPressure { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsJupiterObject { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool ExtendsComObject { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsAggregated { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsFreeThreaded { get; }
    [DebuggerBrowsableAttribute("0")]
internal bool IsDuplicate { get; }
    [DebuggerBrowsableAttribute("0")]
internal ContextCookie ContextCookie { get; }
    [DebuggerBrowsableAttribute("0")]
internal ComObjectFlags Flags { get; }
    private static __ComObject();
    internal __ComObject(IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    internal IntPtr get_BaseIUnknown_UnsafeNoAddRef();
    internal IntPtr get_SavedIUnknownVtbl();
    public UInt32 get_AllocationId();
    internal ComCallableObject get_Outer();
    internal void set_Outer(ComCallableObject value);
    private AdditionalComInterfaceCacheContext[] AcquireAdditionalCacheExclusive();
    private void ReleaseAdditionalCacheExclusive(AdditionalComInterfaceCacheContext[] contexts);
    private AdditionalComInterfaceCacheContext[] AcquireAdditionalCacheForRead();
    private bool AddToAdditionalCache(ContextCookie contextCookie, RuntimeTypeHandle interfaceType, IntPtr pComPtr, object adapter, bool checkDup);
    internal static int AttachingCtor(__ComObject comObject, IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    private void __AttachingCtor(IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    private void AddGCMemoryPressure(GCPressureRange gcMemoryPressureRange);
    private void UpdateComMarshalingType(ComMarshalingType marshallingType);
    private ComMarshalingType get_MarshalingType();
    private bool get_IsGCPressureSet();
    private int get_GCMemoryPressure();
    private void __InitToDefaultState();
    private IntPtr GetVtbl(IntPtr pUnk);
    private void __Attach(IntPtr pBaseIUnknown);
    private void __Attach(IntPtr pBaseIUnknown, RuntimeTypeHandle classType);
    [CLSCompliantAttribute("False")]
public void __AttachAndRelease(IntPtr pBaseIUnknown);
    [GCCallbackAttribute]
internal bool get_IsJupiterObject();
    internal bool get_ExtendsComObject();
    internal void set_ExtendsComObject(bool value);
    internal bool get_IsAggregated();
    [GCCallbackAttribute]
internal __com_IJupiterObject* GetIJupiterObject_NoAddRef();
    internal int AddRef();
    internal int Release();
    internal void FinalReleaseSelf();
    internal int PeekRefCount();
    internal void Cleanup(bool disposing);
    internal void RemoveInterfacesForContext(ContextCookie currentContext);
    internal bool get_IsFreeThreaded();
    internal bool get_IsDuplicate();
    internal ContextCookie get_ContextCookie();
    internal ComObjectFlags get_Flags();
    private int QueryInterface_NoAddRef(RuntimeTypeHandle interfaceType, bool cacheOnly, IntPtr& pComPtr);
    internal IntPtr QueryInterface_NoAddRef_Internal(RuntimeTypeHandle interfaceType, bool cacheOnly, bool throwOnQueryInterfaceFailure);
    private int QueryInterface_NoAddRef_SlowNoCacheLookup(RuntimeTypeHandle interfaceType, ContextCookie currentCookie, IntPtr& pComPtr);
    private int QueryInterface_NoAddRef_Slow(RuntimeTypeHandle interfaceType, ContextCookie& currentCookie, bool cacheOnly, IntPtr& pComPtr);
    private int QueryInterfaceAndInsertToCache_NoAddRef(IntPtr pIUnknown, RuntimeTypeHandle interfaceType, ContextCookie currentCookie, IntPtr& pComPtr);
    internal RuntimeTypeHandle FindCastableGenericInterfaceInCache(RuntimeTypeHandle interfaceType, IntPtr& pComPtr);
    private InvalidCastException CreateInvalidCastExceptionForFailedQI(RuntimeTypeHandle interfaceType, int hr);
    internal void InsertIntoCache(RuntimeTypeHandle interfaceType, ContextCookie cookie, IntPtr& pComPtr, bool checkDup);
    private bool TryGetInterfacePointerFromAdditionalCache_NoAddRef(RuntimeTypeHandle interfaceType, IntPtr& pComPtr, ContextCookie currentCookie);
    private object CastToICollectionHelper(RuntimeTypeHandle genericTypeDef, RuntimeTypeHandle[] genericArguments, bool testForIDictionary);
    protected virtual object CastToInterface(RuntimeTypeHandle interfaceType, bool produceCastErrorException, Exception& castError);
    private sealed virtual override bool System.Runtime.CompilerServices.ICastable.IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    private sealed virtual override RuntimeTypeHandle System.Runtime.CompilerServices.ICastable.GetImplType(RuntimeTypeHandle interfaceType);
    internal object GetDynamicAdapter(RuntimeTypeHandle requestedType, RuntimeTypeHandle targetType);
    private bool TryQITypeForICollection(RuntimeTypeHandle firstTypeHandle, RuntimeTypeHandle secondaryTypeHandle, RuntimeTypeHandle& resolvedTypeHandle);
    private object GetDynamicAdapterUsingQICache(RuntimeTypeHandle requestedType, AdditionalComInterfaceCacheContext[] cacheContext);
    private object GetDynamicAdapterUsingVariance(RuntimeTypeHandle requestedType, AdditionalComInterfaceCacheContext[] cacheContext);
    private object GetDynamicAdapterInternal(RuntimeTypeHandle requestedType, RuntimeTypeHandle targetType);
    private object FindDynamicAdapterForInterface(RuntimeTypeHandle requestedType, RuntimeTypeHandle existingType);
    internal PropertyInfo GetMatchingProperty(Func`2<PropertyInfo, bool> matchingDelegate);
    public virtual string ToString();
}
internal static class System.__HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.Internal.Dictionary`2 : DictionaryBase {
    private TKey[] keyArray;
    private TValue[] valueArray;
    private IEqualityComparer`1<TKey> comparer;
    private Lock m_lock;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public TValue Item { get; public set; }
    public Dictionary`2(bool sync);
    public Dictionary`2(int capacity);
    public Dictionary`2(int capacity, bool sync);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer, bool sync);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer, bool sync);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public void LockAcquire();
    public void LockRelease();
    public IEqualityComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public Enumerator<TKey, TValue> GetEnumerator();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public void Add(TKey key, TValue value);
    public void Add(TKey key, TValue value, int hashCode);
    public void Clear();
    public bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [GCCallbackAttribute]
public int GetMaxCount();
    public bool GetKey(int index, TKey& key);
    [GCCallbackAttribute]
public bool GetValue(int index, TValue& value);
    private int FindEntry(TKey key);
    private int FindEntry(TKey key, int hashCode);
    public int FindFirstKey(TKey& key);
    public int FindNextKey(TKey& key, int entry);
    private void Initialize(int capacity);
    private bool Insert(TKey key, TValue value, bool add);
    private bool Insert(TKey key, TValue value, bool add, int hashCode);
    private void Resize();
    private void Resize(int newSize);
    public bool Remove(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
    public bool TryGetValue(TKey key, int hashCode, TValue& value);
    public bool TryGetKey(TKey& key);
}
internal class System.Collections.Generic.Internal.DictionaryBase : object {
    protected int count;
    protected int version;
    protected int freeList;
    protected int freeCount;
    protected Entry[] entries;
    public int Count { get; }
    public int get_Count();
    protected int InitializeBase(int capacity);
    protected void ClearBase();
    protected Entry[] ResizeBase1(int newSize);
    protected void ResizeBase2(Entry[] newEntries, int newSize);
    protected int ModLength(int hashCode);
    protected int FindFirstEntry(int hashCode);
    protected int FindNextEntry(int entry);
}
internal class System.Collections.Generic.Internal.HashHelpers : object {
    public static Int32[] primes;
    public static int MaxPrimeArrayLength;
    private static HashHelpers();
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
}
internal class System.Collections.Generic.Internal.HashSet`1 : DictionaryBase {
    private static int MinimalSize;
    private TKey[] keyArray;
    private Lock m_lock;
    public KeyCollection<TKey> Keys { get; }
    public HashSet`1(int capacity);
    public HashSet`1(int capacity, bool sync);
    public void LockAcquire();
    public void LockRelease();
    public void Clear();
    public bool ContainsKey(TKey key, int hashCode);
    private int FindEntry(TKey key, int hashCode);
    public int FindFirstKey(TKey& key, int hashCode);
    public int FindNextKey(TKey& key, int entry);
    [GCCallbackAttribute]
internal bool GetNext(TKey& key, Int32& index);
    private void Initialize(int capacity);
    public KeyCollection<TKey> get_Keys();
    public bool Add(TKey key, int hashCode);
    private void Resize();
    private void Resize(int newSize);
    public bool Remove(TKey key, int hashCode);
}
[DefaultMemberAttribute("Item")]
[__BlockReflectionAttribute]
public class System.Collections.Generic.Internal.List`1 : object {
    private T[] _items;
    private int _size;
    private int _version;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public void Clear();
    public bool Contains(T item);
    public void CopyTo(T[] array);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public int IndexOf(T item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public void Insert(int index, T item);
    public bool Remove(T item);
    public void RemoveAt(int index);
    public T[] ToArray();
    public void TrimExcess();
}
internal class System.Collections.Generic.Internal.SR : object {
    internal static string ArgumentOutOfRange_NeedNonNegNum;
    internal static string Arg_WrongType;
    internal static string Arg_ArrayPlusOffTooSmall;
    internal static string Arg_RankMultiDimNotSupported;
    internal static string Arg_NonZeroLowerBound;
    internal static string Argument_InvalidArrayType;
    internal static string Argument_AddingDuplicate;
    internal static string InvalidOperation_EnumFailedVersion;
    internal static string InvalidOperation_EnumOpCantHappen;
    internal static string NotSupported_KeyCollectionSet;
    internal static string NotSupported_ValueCollectionSet;
    internal static string ArgumentOutOfRange_SmallCapacity;
    internal static string Argument_InvalidOffLen;
    private static SR();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
internal class System.RCWFinalizer : object {
    private __ComObject m_comObject;
    internal RCWFinalizer(__ComObject comObject);
    protected virtual override void Finalize();
}
public abstract class System.Reflection.DispatchProxy : object {
    protected abstract virtual object Invoke(MethodInfo targetMethod, Object[] args);
    public static T Create();
}
[__BlockReflectionAttribute]
public class System.Reflection.DispatchProxyEntry : ValueType {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <ProxyClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <InterfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <ImplementationClassType>k__BackingField;
    public RuntimeTypeHandle ProxyClassType { get; public set; }
    public RuntimeTypeHandle InterfaceType { get; public set; }
    public RuntimeTypeHandle ImplementationClassType { get; public set; }
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_ProxyClassType();
    [CompilerGeneratedAttribute]
public void set_ProxyClassType(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_InterfaceType();
    [CompilerGeneratedAttribute]
public void set_InterfaceType(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_ImplementationClassType();
    [CompilerGeneratedAttribute]
public void set_ImplementationClassType(RuntimeTypeHandle value);
}
[__BlockReflectionAttribute]
public static class System.Reflection.DispatchProxyHelpers : object {
    private static DispatchProxyEntry[] s_entryTable;
    public static void RegisterImplementations(DispatchProxyEntry[] entryTable);
    public static RuntimeTypeHandle GetConcreteProxyType(RuntimeTypeHandle proxyClassTypeHandle, RuntimeTypeHandle interfaceTypeHandle);
    public static RuntimeMethodHandle GetCorrespondingInterfaceMethodFromMethodImpl();
}
[__BlockReflectionAttribute]
public class System.Reflection.DispatchProxyInstanceNotFoundException : Exception {
    public DispatchProxyInstanceNotFoundException(string message);
    public DispatchProxyInstanceNotFoundException(string message, Exception inner);
}
internal class System.Runtime.CompilerServices.__BlockReflectionActivateAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionInvokeAttribute : Attribute {
}
[__BlockReflectionAttribute]
public static class System.Runtime.CompilerServices.FunctionPointerHelpers : object {
    public static Delegate UnsafeDelegateFromStaticMethodFunctionPointer(Type delegateType, IntPtr pfnStaticManagedMethod);
}
[AttributeUsageAttribute("1")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute : Attribute {
    private string _assemblyName;
    public string AssemblyName { get; }
    public IgnoresAccessChecksToAttribute(string assemblyName);
    public string get_AssemblyName();
}
[__BlockReflectionAttribute]
public static class System.Runtime.CompilerServices.McgResource : object {
    public static string GetResourceString(string resourceKey, string defaultString);
}
[AttributeUsageAttribute("4")]
[__BlockReflectionAttribute]
public class System.Runtime.CompilerServices.ModuleConstructorAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.UnmanagedValueTypeConstraintAttribute : Attribute {
}
internal class System.Runtime.InteropServices.__com_IActivationFactoryInternal : ValueType {
    internal __vtable_IActivationFactoryInternal* pVtable;
}
internal class System.Runtime.InteropServices.__com_ICCW : ValueType {
    internal __vtable_ICCW* pVtable;
}
internal class System.Runtime.InteropServices.__com_ICLRServices : ValueType {
    public __vtable_ICLRServices* pVtable;
}
internal class System.Runtime.InteropServices.__com_ICustomPropertyProvider : ValueType {
    public __vtable_ICustomPropertyProvider* pVtable;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.__com_IDispatch : ValueType {
    internal __vtable_IDispatch* pVtable;
}
internal class System.Runtime.InteropServices.__com_IFindDependentWrappers : ValueType {
    internal __vtable_IFindDependentWrappers* pVtable;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.__com_IInspectable : ValueType {
    public __vtable_IInspectable* pVtable;
}
internal class System.Runtime.InteropServices.__com_IJupiterGCManager : ValueType {
    internal __vtable_IJupiterGCManager* pVTable;
}
internal class System.Runtime.InteropServices.__com_IJupiterObject : ValueType {
    public __vtable_IJupiterObject* pVtable;
}
internal class System.Runtime.InteropServices.__com_IManagedActivationFactory : ValueType {
    internal __vtable_IManagedActivationFactory* pVtable;
}
internal class System.Runtime.InteropServices.__com_IMarshal : ValueType {
    internal __vtable_IMarshal* pVtable;
}
internal class System.Runtime.InteropServices.__com_IStream : ValueType {
    internal __vtable_IStream* pVtable;
    public Byte* m_pMem;
    public int m_cbSize;
    public int m_cbCurrent;
    public int m_cRef;
    internal static IntPtr CreateMemStm(ulong lSize);
    internal static void DestroyMemStm(__com_IStream* pIStream);
}
internal class System.Runtime.InteropServices.__com_IStringable : ValueType {
    internal __vtable_IStringable* pVtable;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.__com_IUnknown : ValueType {
    internal __vtable_IUnknown* pVtable;
}
internal class System.Runtime.InteropServices.__com_IWeakReference : ValueType {
    internal __vtable_IWeakReference* pVtable;
}
internal class System.Runtime.InteropServices.__com_IWeakReferenceSource : ValueType {
    internal __vtable_IWeakReferenceSource* pVtable;
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.__interface_ccw : ValueType {
    private Void* m_pVtable;
    private __native_ccw* m_pNativeCCW;
    private __interface_ccw* m_pNext;
    private RuntimeTypeHandle m_interfaceType;
    private int m_dynamicMethodStart;
    private int m_dynamicMethodEnd;
    private static IntPtr s_cached_interface_ccw;
    internal __interface_ccw* Next { get; internal set; }
    internal ComCallableObject ComCallableObject { get; }
    internal __native_ccw* NativeCCW { get; }
    internal RuntimeTypeHandle InterfaceType { get; }
    internal static __interface_ccw* Allocate(ComCallableObject managedCCW, RuntimeTypeHandle typeHandle);
    internal static void Destroy(__interface_ccw* pInterfaceCCW);
    internal __interface_ccw* get_Next();
    internal void set_Next(__interface_ccw* value);
    internal ComCallableObject get_ComCallableObject();
    [GCCallbackAttribute]
internal __native_ccw* get_NativeCCW();
    internal RuntimeTypeHandle get_InterfaceType();
    internal static int DirectRelease(IntPtr __IntPtr__pComThis);
}
internal class System.Runtime.InteropServices.__native_ccw : ValueType {
    private long m_lRefCount;
    private GCHandle m_hCCW;
    private IntPtr m_pFirstInterfaceCCW;
    private int m_flags;
    private int m_hashCode;
    private static IntPtr s_cached_native_ccw;
    internal static long COM_REFCOUNT_MASK;
    internal static long JUPITER_REFCOUNT_MASK;
    internal static int JUPITER_REFCOUNT_SHIFT;
    internal static long JUPITER_REFCOUNT_INC;
    internal static long ALL_REFCOUNT_MASK;
    internal ComCallableObject ComCallableObject { get; }
    internal ComCallableObject ComCallableObjectUnsafe { get; }
    internal GCHandle CCWHandle { get; }
    internal bool IsAggregatingRCW { get; }
    internal bool IsCleanupPending { get; }
    private long CombinedRefCount { get; }
    internal int JupiterRefCount { get; }
    internal int COMRefCount { get; }
    internal bool IsNeutered { get; }
    internal bool IsPegged { get; internal set; }
    internal static __native_ccw* Allocate(ComCallableObject managedCCW, object targetObject);
    private IntPtr GetObjectID();
    private void Init(ComCallableObject ccw, object targetObject);
    internal void Cleanup();
    internal void Link(__interface_ccw* pInterfaceCCW);
    internal ComCallableObject get_ComCallableObject();
    internal void AccessNeuteredCCW_FailFast();
    internal ComCallableObject get_ComCallableObjectUnsafe();
    internal GCHandle get_CCWHandle();
    internal bool get_IsAggregatingRCW();
    internal bool get_IsCleanupPending();
    internal bool IsAlive();
    private bool IsAlive(long lRefCount);
    private long get_CombinedRefCount();
    private int JupiterRefCountFrom(long lRefCount);
    private int COMRefCountFrom(long lRefCount);
    internal int get_JupiterRefCount();
    internal int get_COMRefCount();
    internal int AddJupiterRef();
    internal int ReleaseJupiterRef();
    internal int AddCOMRef();
    internal bool TryAddCOMRefIfNotCleanupPending();
    internal int ReleaseCOMRef();
    internal bool get_IsNeutered();
    internal bool get_IsPegged();
    internal void set_IsPegged(bool value);
    private void SetFlag(ComCallableObjectFlags newFlag, bool isSet);
    private bool IsFlagSet(ComCallableObjectFlags flag);
    internal int GetFlags();
    internal int GetHashCodeForLookup();
}
internal class System.Runtime.InteropServices.__vtable_IActivationFactoryInternal : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    internal IntPtr pfnActivateInstance;
    private static IntPtr pNativeVtable;
    private static __vtable_IActivationFactoryInternal s_theCcwVtable;
    private static __vtable_IActivationFactoryInternal();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IActivationFactoryInternal();
    [NativeCallableAttribute]
internal static int ActivateInstance(IntPtr pComThis, IntPtr ppResult);
}
internal class System.Runtime.InteropServices.__vtable_ICCW : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnAddRefFromJupiter;
    private IntPtr pfnReleaseFromJupiter;
    private IntPtr pfnPeg;
    private IntPtr pfnUnpeg;
    public static IntPtr pNativeVtable;
    private static __vtable_ICCW s_theCcwVtable;
    private static __vtable_ICCW();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_ICCW();
    [NativeCallableAttribute]
private static int QueryInterface__STUB(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    [NativeCallableAttribute]
private static int AddRef__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
private static int Release__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
private static int AddRefFromJupiter__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
private static int ReleaseFromJupiter__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
private static int Peg__STUB(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
private static int Unpeg__STUB(IntPtr __IntPtr__pComThis);
}
internal class System.Runtime.InteropServices.__vtable_ICLRServices : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnGarbageCollect;
    internal IntPtr pfnFinalizerThreadWait;
    internal IntPtr pfnDisconnectRCWsInCurrentApartment;
    internal IntPtr pfnCreateManagedReference;
    internal IntPtr pfnAddMemoryPressure;
    internal IntPtr pfnRemoveMemoryPressure;
    private static __vtable_ICLRServices s_theCcwVtable;
    internal static __vtable_ICLRServices* GetVtable();
    private void InitVtable();
    [NativeCallableAttribute]
private static int AddRef__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
private static int Release__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
private static int QueryInterface__STUB(IntPtr IntPtr__pComThis, IntPtr IntPtr__pIID, IntPtr IntPtr__ppvObject);
    [NativeCallableAttribute]
private static int GarbageCollect__STUB(IntPtr pComThis, int dwFlags);
    [NativeCallableAttribute]
private static int FinalizerThreadWait__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
private static int DisconnectRCWsInCurrentApartment__STUB(IntPtr pComThis);
    [NativeCallableAttribute]
private static int CreateManagedReference__STUB(IntPtr pComThis, IntPtr __IntPtr__pUnknown, IntPtr __IntPtr__ppNewReference);
    [NativeCallableAttribute]
private static int AddMemoryPressure__STUB(IntPtr pComThis, ulong bytesAllocated);
    [NativeCallableAttribute]
private static int RemoveMemoryPressure__STUB(IntPtr pComThis, ulong bytesAllocated);
}
internal class System.Runtime.InteropServices.__vtable_ICustomPropertyProvider : ValueType {
    private static Guid ICustomPropertyIID;
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnGetCustomProperty;
    private IntPtr pfnGetIndexedProperty;
    private IntPtr pfnGetStringRepresentation;
    private IntPtr pfnget_Type;
    public static IntPtr pNativeVtable;
    private static __vtable_ICustomPropertyProvider s_theCcwVtable;
    private static __vtable_ICustomPropertyProvider();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_ICustomPropertyProvider();
    [NativeCallableAttribute]
private static int GetCustomProperty__STUB(IntPtr pComThis, HSTRING unsafe_name, IntPtr __IntPtr__unsafe_customProperty);
    private static ICustomProperty ManagedGetCustomProperty(object target, string propertyName);
    [NativeCallableAttribute]
private static int GetIndexedProperty__STUB(IntPtr pComThis, HSTRING unsafe_name, TypeName unsafe_type, IntPtr __IntPtr__unsafe_customProperty);
    private static bool IsMatchingIndexedProperty(PropertyInfo property, string propertyName, Type indexerType);
    private static ICustomProperty ManagedGetIndexedProperty(object target, string propertyName, Type indexerType);
    [NativeCallableAttribute]
private static int GetStringRepresentation__STUB(IntPtr pComThis, IntPtr __IntPtr__unsafe_stringRepresentation);
    private static string ManagedGetStringRepresentation(object target);
    [NativeCallableAttribute]
private static int get_Type__STUB(IntPtr pComThis, IntPtr __IntPtr__unsafe_value);
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.__vtable_IDispatch : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnGetTypeInfoCount;
    internal IntPtr pfnGetTypeInfo;
    internal IntPtr pfnGetIDsOfNames;
    internal IntPtr pfnInvoke;
    public static IntPtr pNativeVtable;
    private static __vtable_IDispatch s_theCcwVtable;
    private static int E_NOTIMPL;
    private static __vtable_IDispatch();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IDispatch();
    [NativeCallableAttribute]
public static int GetTypeInfoCount(IntPtr pComThis, IntPtr pctinfo);
    [NativeCallableAttribute]
public static int GetTypeInfo(IntPtr pComThis, UInt32 iTInfo, UInt32 lcid, IntPtr ppTInfo);
    [NativeCallableAttribute]
public static int GetIDsOfNames(IntPtr pComThis, IntPtr riid, IntPtr rgszNames, UInt32 cNames, UInt32 lcid, IntPtr rgDispId);
    [NativeCallableAttribute]
public static int Invoke(IntPtr pComThis, int dispIdMember, IntPtr riid, UInt32 lcid, ushort wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Runtime.InteropServices.__vtable_IFindDependentWrappers : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnOnFoundDependentWrapper;
    private static __vtable_IFindDependentWrappers s_theVtable;
    internal static __vtable_IFindDependentWrappers* GetVtable();
    private void InitVtable();
    [GCCallbackAttribute]
[NativeCallableAttribute]
private static int AddRef__STUB(IntPtr pComThis);
    [GCCallbackAttribute]
[NativeCallableAttribute]
private static int Release__STUB(IntPtr pComThis);
    [GCCallbackAttribute]
[NativeCallableAttribute]
private static int QueryInterface__STUB(IntPtr IntPtr__pComThis, IntPtr IntPtr__pIID, IntPtr IntPtr__ppvObject);
    [GCCallbackAttribute]
[NativeCallableAttribute]
private static int OnFoundDependentWrapper__STUB(IntPtr pComThis, IntPtr IntPtr__pCCW);
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.__vtable_IInspectable : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnGetIids;
    internal IntPtr pfnGetRuntimeClassName;
    internal IntPtr pfnGetTrustLevel;
    public static IntPtr pNativeVtable;
    private static __vtable_IInspectable s_theCcwVtable;
    private static int S_OK;
    private static int E_NOTIMPL;
    private static int BaseTrust;
    private static __vtable_IInspectable();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IInspectable();
    [NativeCallableAttribute]
public static int GetIIDs(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__iidCount, IntPtr __IntPtr__iids);
    [NativeCallableAttribute]
public static int GetRuntimeClassName(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__className);
    [NativeCallableAttribute]
public static int GetTrustLevel(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pTrustLevel);
}
internal class System.Runtime.InteropServices.__vtable_IJupiterGCManager : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnOnGCStarted;
    internal IntPtr pfnOnRCWWalkFinished;
    internal IntPtr pfnOnGCFinished;
    internal IntPtr pfnSetCLRServices;
}
internal class System.Runtime.InteropServices.__vtable_IJupiterObject : ValueType {
    private __vtable_IUnknown rgIIUnknown;
    internal IntPtr pfnConnect;
    internal IntPtr pfnDisconnect;
    internal IntPtr pfnFindDependentWrappers;
    internal IntPtr pfnGetJupiterGCManager;
    internal IntPtr pfnAfterAddRef;
    internal IntPtr pfnBeforeRelease;
    internal IntPtr pfnPeg;
}
internal class System.Runtime.InteropServices.__vtable_IManagedActivationFactory : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnRunClassConstructor;
    public static IntPtr pNativeVtable;
    private static __vtable_IManagedActivationFactory s_theCcwVtable;
    private static __vtable_IManagedActivationFactory();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IManagedActivationFactory();
    [NativeCallableAttribute]
private static int RunClassConstructor(IntPtr pComThis);
}
internal class System.Runtime.InteropServices.__vtable_IMarshal : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetUnmarshalClass;
    private IntPtr pfnGetMarshalSizeMax;
    private IntPtr pfnMarshalInterface;
    private IntPtr pfnUnmarshalInterface;
    private IntPtr pfnReleaseMarshalData;
    private IntPtr pfnDisconnectObject;
    public static IntPtr pNativeVtable;
    private static __vtable_IMarshal s_theCcwVtable;
    private static __vtable_IMarshal();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IMarshal();
    private static int GetIMarshal(Void** ppIMarshal);
    [NativeCallableAttribute]
private static int GetUnmarshalClass(IntPtr pComThis, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr pclsid);
    [NativeCallableAttribute]
private static int GetMarshalSizeMax(IntPtr pComThis, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr pSize);
    [NativeCallableAttribute]
private static int MarshalInterface(IntPtr pComThis, IntPtr pStm, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags);
    [NativeCallableAttribute]
private static int UnmarshalInterface(IntPtr pComThis, IntPtr pStm, IntPtr piid, IntPtr ppvObj);
    [NativeCallableAttribute]
private static int ReleaseMarshalData(IntPtr pComThis, IntPtr pStm);
    [NativeCallableAttribute]
private static int DisconnectObject(IntPtr pComThis, int dwReserved);
}
internal class System.Runtime.InteropServices.__vtable_IStream : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnRead;
    internal IntPtr pfnWrite;
    internal IntPtr pfnSeek;
    internal IntPtr pfnSetSize;
    internal IntPtr pfnCopyTo;
    internal IntPtr pfnCommit;
    internal IntPtr pfnRevert;
    internal IntPtr pfnLockRegion;
    internal IntPtr pfnUnlockRegion;
    internal IntPtr pfnStat;
    internal IntPtr pfnClone;
    public static IntPtr pNativeVtable;
    private static __vtable_IStream s_theCcwVtable;
    private static int STG_E_INVALIDPOINTER;
    private static __vtable_IStream();
    internal static IntPtr GetVtable();
    [NativeCallableAttribute]
internal static int QueryInterface(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    [NativeCallableAttribute]
internal static int AddRef(IntPtr pComThis);
    [NativeCallableAttribute]
internal static int Release(IntPtr pComThis);
    [NativeCallableAttribute]
internal static int CopyTo(IntPtr pComThis, IntPtr pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    [NativeCallableAttribute]
internal static int Read(IntPtr pComThis, IntPtr pv, int cb, IntPtr pcb);
    [NativeCallableAttribute]
internal static int Write(IntPtr pComThis, IntPtr pv, int cb, IntPtr pcbWritten);
    [NativeCallableAttribute]
internal static int Seek(IntPtr pComThis, long dlibMove, int dwOrigin, IntPtr plib);
    [NativeCallableAttribute]
internal static int Stat(IntPtr pComThis, IntPtr pstatstg, int grfStatFlag);
    [NativeCallableAttribute]
internal static int Clone(IntPtr pComThis, IntPtr ppstm);
    [NativeCallableAttribute]
internal static int Commit(IntPtr pComThis, int grfCommitFlags);
    [NativeCallableAttribute]
internal static int LockRegion(IntPtr pComThis, long libOffset, long cb, int dwLockType);
    [NativeCallableAttribute]
internal static int Revert(IntPtr pComThis);
    [NativeCallableAttribute]
internal static int SetSize(IntPtr pComThis, long libNewSize);
    [NativeCallableAttribute]
internal static int UnlockRegion(IntPtr pComThis, long libOffset, long cb, int dwLockType);
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.__vtable_IStringable : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    internal IntPtr pfnToString;
    public static IntPtr pNativeVtable;
    private static __vtable_IStringable s_theCcwVtable;
    private static __vtable_IStringable();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IStringable();
    [NativeCallableAttribute]
private static int ToString(IntPtr pComThis, IntPtr __IntPtr__pResult);
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.__vtable_IUnknown : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    public static IntPtr pNativeVtable;
    private static __vtable_IUnknown s_theCcwVtable;
    private static __vtable_IUnknown();
    internal static void Initialize();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IUnknown();
    [NativeCallableAttribute]
public static int QueryInterface(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    [McgGeneratedNativeCallCodeAttribute]
public static int AddRef(IntPtr __IntPtr__pComThis);
    [NativeCallableAttribute]
public static int Release(IntPtr __IntPtr__pComThis);
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.__vtable_IWeakReference : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    internal IntPtr pfnResolve;
    public static IntPtr pNativeVtable;
    private static __vtable_IWeakReference s_theCcwVtable;
    private static __vtable_IWeakReference();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IWeakReference();
    [NativeCallableAttribute]
private static int Resolve(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__piid, IntPtr __IntPtr__ppWeakReference);
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.__vtable_IWeakReferenceSource : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    internal IntPtr pfnGetWeakReference;
    public static IntPtr pNativeVtable;
    private static __vtable_IWeakReferenceSource s_theCcwVtable;
    private static __vtable_IWeakReferenceSource();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IWeakReferenceSource();
    [NativeCallableAttribute]
private static int GetWeakReference(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__ppWeakReference);
}
internal class System.Runtime.InteropServices.AdditionalComInterfaceCacheContext : object {
    internal ContextEntry context;
    internal WithInlineStorage<AdditionalComInterfaceCacheItem> items;
    internal AdditionalComInterfaceCacheContext(ContextCookie contextCookie);
    internal bool Add(RuntimeTypeHandle interfaceType, IntPtr pComPtr, object adapter, bool checkDup);
}
internal class System.Runtime.InteropServices.AdditionalComInterfaceCacheItem : ValueType {
    internal RuntimeTypeHandle typeHandle;
    internal IntPtr ptr;
    internal object dynamicAdapter;
    internal AdditionalComInterfaceCacheItem(RuntimeTypeHandle interfaceType, IntPtr pComPtr, object adapter);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.AddrOfAddRef : MulticastDelegate {
    public AddrOfAddRef(object object, IntPtr method);
    public virtual int Invoke(IntPtr pComThis);
    public virtual IAsyncResult BeginInvoke(IntPtr pComThis, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.AddrOfGetCCWVtable : MulticastDelegate {
    public AddrOfGetCCWVtable(object object, IntPtr method);
    public virtual IntPtr Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[McgIntrinsicsAttribute]
internal static class System.Runtime.InteropServices.AddrOfIntrinsics : object {
    internal static IntPtr AddrOf(T ftn);
    internal static IntPtr StaticFieldAddr(T& field);
    internal static IntPtr VirtualAddrOf(object o, int methodIndex);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.AddrOfQueryInterface : MulticastDelegate {
    public AddrOfQueryInterface(object object, IntPtr method);
    public virtual int Invoke(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject);
    public virtual IAsyncResult BeginInvoke(IntPtr __IntPtr__pComThis, IntPtr __IntPtr__pIID, IntPtr __IntPtr__ppvObject, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.AddrOfRelease : MulticastDelegate {
    public AddrOfRelease(object object, IntPtr method);
    public virtual int Invoke(IntPtr pComThis);
    public virtual IAsyncResult BeginInvoke(IntPtr pComThis, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private static int MaxSizeForInterop;
    private object m_array;
    private int m_offset;
    private int m_count;
    public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
    private int CalculateCount();
}
internal static class System.Runtime.InteropServices.BCryptInterop : object {
}
[__BlockReflectionAttribute]
public abstract class System.Runtime.InteropServices.BoxedKeyValuePair : object {
    public abstract virtual object Initialize(object val);
    public abstract virtual object GetTarget();
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.BoxedValue : object {
    protected object m_data;
    protected short m_type;
    protected bool m_unboxed;
    public BoxedValue(object val, int type);
    public virtual void Initialize(object val, int type);
    public sealed virtual object GetTarget();
    public virtual string ToString();
}
internal enum System.Runtime.InteropServices.BoxingInterfaceKind : Enum {
    public int value__;
    public static BoxingInterfaceKind None;
    public static BoxingInterfaceKind IReference;
    public static BoxingInterfaceKind IReferenceArray;
    public static BoxingInterfaceKind IKeyValuePair;
    public static BoxingInterfaceKind IKeyValuePairArray;
}
public class System.Runtime.InteropServices.BStrWrapper : object {
    private string m_WrappedObject;
    public string WrappedObject { get; }
    public BStrWrapper(string value);
    public BStrWrapper(object value);
    public string get_WrappedObject();
}
[McgIntrinsicsAttribute]
internal static class System.Runtime.InteropServices.CalliIntrinsics : object {
    private static MethodImplOptions InternalCall;
    internal static int StdCall__QueryInterface(IntPtr pfn, IntPtr pComThis, IntPtr arg0, IntPtr arg1);
    internal static int StdCall__AddRef(IntPtr pfn, IntPtr pComThis);
    internal static int StdCall__Release(IntPtr pfn, IntPtr pComThis);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, UInt32 arg0);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0, Void* arg1);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0, int arg1, IntPtr arg2);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Void* arg0, IntPtr arg1, UInt32 arg2, IntPtr arg3, UInt32 arg4, Void* arg5);
    public static int StdCall__int(IntPtr pfn, Void* pthis, HSTRING arg0, Void* arg1);
    public static int StdCall__int(IntPtr pfn, Void* pthis, Void* arg0);
    public static int StdCall__int(IntPtr pfn, IntPtr pthis, HSTRING arg0, IntPtr arg1, Void* arg2, Void* arg3);
    public static int StdCall__int(IntPtr pfn, IntPtr pthis, int arg0, IntPtr arg1, IntPtr arg2, int arg3, int arg4, IntPtr arg5, Void* arg6, Void* arg7);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, ulong arg0, UInt32 arg1, Void* arg2);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr arg0, Void* arg1, Void* arg2, int arg3, IntPtr arg4);
    internal static int StdCall__int(IntPtr pfn, UInt32 arg0);
    internal static int StdCall__int(IntPtr pfn, Void* arg0);
    internal static int StdCall__int(IntPtr pfn, Void* arg0, UInt32 arg1, Void* arg2);
    internal static int StdCall__int(IntPtr pfn, Void* arg0, Void* arg1, Void* arg2);
    internal static int StdCall__int(IntPtr pfn, Void* arg0, UInt32 arg1, Void* arg2, Void* arg3);
    internal static int StdCall__int(IntPtr pfn, int hr, Void* errorMsg, IntPtr pUnk);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, IntPtr& arg1, Int32& arg2, IntPtr& arg3, IntPtr& arg4);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, IntPtr& arg);
    internal static int StdCall__int(IntPtr pfn, IntPtr pComThis, Guid arg1, IntPtr& arg2);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags, IntPtr pclsid);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr pStm, IntPtr piid, IntPtr pv, int dwDestContext, IntPtr pvDestContext, int mshlflags);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr pStm, IntPtr piid, IntPtr ppvObj);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, IntPtr pStm);
    internal static int StdCall__int(IntPtr pfn, Void* pComThis, int dwReserved);
    [RuntimeImportAttribute("*", "StdCallCOOP0")]
internal static int StdCallCOOP(IntPtr pfn, Void* pComThis);
    [RuntimeImportAttribute("*", "StdCallCOOPV")]
internal static int StdCallCOOP(IntPtr pfn, Void* pComThis, Void* arg0);
    [RuntimeImportAttribute("*", "StdCallCOOPI")]
internal static int StdCallCOOP(IntPtr pfn, Void* pComThis, int arg0);
    internal static IntPtr Call__GetCcwVtable(IntPtr pfn);
    internal static T Call(IntPtr pfn, Void* arg0);
    internal static T Call(IntPtr pfn, object arg0);
    internal static T Call(IntPtr pfn, object arg0, object arg1, int arg2);
    internal static T Call(IntPtr pfn, object arg0, int arg1);
    internal static T Call(IntPtr pfn, Void* arg0, Void* arg1);
    internal static T Call(IntPtr pfn, Void* arg0, int arg1);
    internal static T Call(IntPtr pfn, IntPtr arg0, UInt32 arg1, IntPtr arg2);
    internal static T Call(IntPtr pfn, IntPtr arg0, UInt32 arg1, Void* arg2, IntPtr arg3);
    internal static T Call(IntPtr pfn, __ComObject arg0, IntPtr arg1);
    internal static T Call(IntPtr pfn, __ComObject arg0, IntPtr arg1, RuntimeTypeHandle arg2);
    internal static T Call(IntPtr pfn, object list, IList_Oper oper, int index, Object& item);
    internal static T Call(IntPtr pfn, object iterator, IIterator_Oper oper, Object& data, int len);
    internal static T Call(IntPtr pfn, object iterator, IIterator_Oper oper, IntPtr pData, Int32& len);
    internal static T Call(IntPtr pfn, object handler, object asyncInfo, AsyncStatus status);
    internal static T Call(IntPtr pfn, object list, IList_Oper oper, Int32& index, IntPtr pData);
    internal static Delegate Call__Delegate(IntPtr pfn, IntPtr pStub);
}
internal class System.Runtime.InteropServices.CCWCacheEntry : ValueType {
    internal RuntimeTypeHandle TypeHandle;
    internal IntPtr CCW;
    internal Guid InterfaceGuid;
    internal CCWCacheEntry(RuntimeTypeHandle typeHandle, IntPtr pCCW, Guid& guid);
}
internal class System.Runtime.InteropServices.CCWLookupMap : object {
    private static HashSet`1<EquatableIntPtr> s_ccwLookupMap;
    private static Lock s_ccwLookupMapLock;
    internal static void InitializeStatics();
    internal static ComCallableObject GetOrCreateCCW(object target, RuntimeTypeHandle typeHandle, IntPtr& interfaceCCW);
    internal static void Register(__native_ccw* pNativeCCW);
    internal static void RegisterLocked(__native_ccw* pNativeCCW);
    internal static void Unregister(__native_ccw* pNativeCCW);
    [GCCallbackAttribute]
internal static void LogCCWs();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.CCWTemplateData : ValueType {
    public FixupRuntimeTypeHandle FixupClassType;
    public FixupRuntimeTypeHandle FixupBaseType;
    public int ParentCCWTemplateIndex;
    public int SupportedInterfaceListBeginIndex;
    public int NumberOfSupportedInterface;
    public bool IsWinRTType;
    public Guid Clsid;
    public RuntimeTypeHandle ClassType { get; }
    public RuntimeTypeHandle BaseType { get; }
    public RuntimeTypeHandle get_ClassType();
    public RuntimeTypeHandle get_BaseType();
}
[GuidAttribute("4ffdd514-7dec-47cf-a0ad-4971868d8455")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.ClassFactory : object {
    private McgModule parent;
    private RuntimeTypeHandle classType;
    public ClassFactory(McgModule parent, RuntimeTypeHandle classType);
    public sealed virtual int CreateInstance(IntPtr pUnkOuter, Guid* riid, IntPtr* ppv);
    public sealed virtual int LockServer(int fLock);
}
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    internal ClassInterfaceType _val;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    public ClassInterfaceType get_Value();
}
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    internal Type _CoClass;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    public Type get_CoClass();
}
public class System.Runtime.InteropServices.ComAwareEventInfo : EventInfo {
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ComAwareEventInfo(Type type, string eventName);
    public virtual EventAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [__BlockReflectionAttribute]
public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type get_ReflectedType();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
}
[EditorBrowsableAttribute("1")]
internal class System.Runtime.InteropServices.ComCallableObject : object {
    private __native_ccw* m_pNativeCCW;
    private WithInlineStorage<CCWCacheEntry> m_CCWs;
    private __ComObject m_innerRCW;
    private object m_target;
    private bool m_supportsICustomQueryInterface;
    private bool m_hasCCWTemplateData;
    private RuntimeTypeHandle m_type;
    private static CCWWellKnownType[] CCWWellknownTypes;
    internal __native_ccw* NativeCCW { get; }
    [GCCallbackAttribute]
internal object TargetObject { get; }
    internal bool IsAggregatingRCW { get; }
    internal ComCallableObject(object target);
    internal ComCallableObject(object target, bool locked);
    internal ComCallableObject(object target, __ComObject innerRCW);
    private static ComCallableObject();
    internal static void InitRefCountedHandleCallback();
    [GCCallbackAttribute]
internal static bool IsAlive(ComCallableObject ccw);
    internal static bool TryGetCCW(IntPtr pComItf, ComCallableObject& ccw);
    [GCCallbackAttribute]
internal static ComCallableObject FromThisPointer(IntPtr pUnk);
    internal static object GetTarget(IntPtr pUnk);
    internal void Init(object target, __ComObject innerRCW, bool locked);
    internal __native_ccw* get_NativeCCW();
    internal int AddJupiterRef();
    internal int ReleaseJupiterRef();
    internal void Peg();
    internal void Unpeg();
    internal object get_TargetObject();
    internal IntPtr GetComInterfaceForIID(Guid& iid);
    internal IntPtr GetComInterfaceForIID(Guid& iid, RuntimeTypeHandle interfaceType);
    private IntPtr GetComInterfaceForIIDInternal(Guid& iid, RuntimeTypeHandle interfaceType);
    internal InterfaceCheckResult SupportsInterface(RuntimeTypeHandle ccwType, Guid& guid, RuntimeTypeHandle& interfaceType);
    internal IntPtr GetComInterfaceForType_NoCheck_NoAddRef(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr GetComInterfaceForTypeFromCache_NoCheck_NoAddRef(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr AddFirstType_NoAddRef(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr GetComInterfaceForTypeFromCache_NoCheck(RuntimeTypeHandle typeHandle, Guid& guid);
    internal IntPtr GetComInterfaceForType_NoCheck(RuntimeTypeHandle typeHandle, Guid& guid);
    internal int AddRef();
    internal int Release();
    internal bool get_IsAggregatingRCW();
    private static bool IsWellKnownInterface(Guid& guid, object targetObject, RuntimeTypeHandle& interfaceType, Boolean& isCCWSupported);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.ComCallableObjectFlags : Enum {
    public int value__;
    public static ComCallableObjectFlags None;
    public static ComCallableObjectFlags IsPegged;
    public static ComCallableObjectFlags IsAggregatingRCW;
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    internal Type _val;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    public Type get_Value();
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
    internal Type _SourceInterface;
    internal Type _EventProvider;
    public Type SourceInterface { get; }
    public Type EventProvider { get; }
    public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
    public Type get_SourceInterface();
    public Type get_EventProvider();
}
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.COMException : ExternalException {
    internal COMException(int hr);
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    protected COMException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.ComInterfaceDynamicAdapter : object {
    private __ComObject m_comObject;
    public __ComObject ComObject { get; }
    internal void Initialize(__ComObject comObject);
    public __ComObject get_ComObject();
}
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    public static ComInterfaceType InterfaceIsIInspectable;
}
internal enum System.Runtime.InteropServices.ComMarshalingType : Enum {
    public int value__;
    public static ComMarshalingType Unknown;
    public static ComMarshalingType Inhibit;
    public static ComMarshalingType Free;
    public static ComMarshalingType Standard;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
internal static class System.Runtime.InteropServices.ComObjectCache : object {
    private static Lock s_lock;
    internal static Dictionary`2<IntPtr, IntPtr> s_comObjectMap;
    internal static bool Add(IntPtr pComItf, __ComObject o);
    internal static void Remove(IntPtr pComItf, __ComObject o);
    internal static __ComObject Lookup(IntPtr pComItf);
    internal static void RemoveRCWsForContext(ContextCookie contextCookie);
    internal static void InitializeStatics();
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.ComObjectFlags : Enum {
    public int value__;
    public static ComObjectFlags None;
    public static ComObjectFlags IsDuplicate;
    public static ComObjectFlags IsJupiterObject;
    public static ComObjectFlags ExtendsComObject;
    public static ComObjectFlags GCPressure_Set;
    public static ComObjectFlags GCPressureWinRT_Low;
    public static ComObjectFlags GCPressureWinRT_Medium;
    public static ComObjectFlags GCPressureWinRT_High;
    public static ComObjectFlags GCPressureWinRT_Mask;
    public static ComObjectFlags MarshalingBehavior_Inhibit;
    public static ComObjectFlags MarshalingBehavior_Free;
    public static ComObjectFlags MarshalingBehavior_Standard;
    public static ComObjectFlags MarshalingBehavior_Mask;
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.ADVF : Enum {
    public int value__;
    public static ADVF ADVF_NODATA;
    public static ADVF ADVF_PRIMEFIRST;
    public static ADVF ADVF_ONLYONCE;
    public static ADVF ADVF_DATAONSTOP;
    public static ADVF ADVFCACHE_NOHANDLER;
    public static ADVF ADVFCACHE_FORCEBUILTIN;
    public static ADVF ADVFCACHE_ONSAVE;
}
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
public enum System.Runtime.InteropServices.ComTypes.DATADIR : Enum {
    public int value__;
    public static DATADIR DATADIR_GET;
    public static DATADIR DATADIR_SET;
}
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.DVASPECT : Enum {
    public int value__;
    public static DVASPECT DVASPECT_CONTENT;
    public static DVASPECT DVASPECT_THUMBNAIL;
    public static DVASPECT DVASPECT_ICON;
    public static DVASPECT DVASPECT_DOCPRINT;
}
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
public class System.Runtime.InteropServices.ComTypes.FORMATETC : ValueType {
    public short cfFormat;
    public IntPtr ptd;
    public DVASPECT dwAspect;
    public int lindex;
    public TYMED tymed;
}
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[GuidAttribute("0000010F-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IAdviseSink {
    public abstract virtual void OnDataChange(FORMATETC& format, STGMEDIUM& stgmedium);
    public abstract virtual void OnViewChange(int aspect, int index);
    public abstract virtual void OnRename(IMoniker moniker);
    public abstract virtual void OnSave();
    public abstract virtual void OnClose();
}
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[GuidAttribute("00000103-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumFORMATETC {
    public abstract virtual int Next(int celt, FORMATETC[] rgelt, Int32[] pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual void Clone(IEnumFORMATETC& newEnum);
}
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
public class System.Runtime.InteropServices.ComTypes.STATDATA : ValueType {
    public FORMATETC formatetc;
    public ADVF advf;
    public IAdviseSink advSink;
    public int connection;
}
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
public class System.Runtime.InteropServices.ComTypes.STGMEDIUM : ValueType {
    public TYMED tymed;
    public IntPtr unionmember;
    public object pUnkForRelease;
}
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYMED : Enum {
    public int value__;
    public static TYMED TYMED_HGLOBAL;
    public static TYMED TYMED_FILE;
    public static TYMED TYMED_ISTREAM;
    public static TYMED TYMED_ISTORAGE;
    public static TYMED TYMED_GDI;
    public static TYMED TYMED_MFPICT;
    public static TYMED TYMED_ENHMF;
    public static TYMED TYMED_NULL;
}
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.COMWeakReferenceHelpers : object {
    private static ConditionalWeakTable`2<object, ComWeakReference> s_COMWeakReferenceTable;
    private static COMWeakReferenceHelpers();
    public static void SetTarget(object weakReference, object target);
    public static object GetTarget(object weakReference);
}
internal class System.Runtime.InteropServices.ContextBoundInterfacePointer : ValueType {
    private IntPtr m_pComPtr;
    private ContextEntry m_context;
    private IntPtr m_pCachedStream;
    private ComMarshalingType m_type;
    private static int StreamInUse;
    internal IntPtr ComPointer_UnsafeNoAddRef { get; }
    internal ContextCookie ContextCookie { get; }
    internal ContextEntry ContextEntry { get; }
    internal bool IsFreeThreaded { get; }
    internal bool IsInhibit { get; }
    internal bool IsStandard { get; }
    internal bool IsUnknown { get; }
    internal bool IsDisposed { get; }
    internal void Initialize(IntPtr pComPtr, ComMarshalingType type);
    internal IntPtr GetIUnknownForCurrContext(ContextCookie currentCookie);
    internal IntPtr get_ComPointer_UnsafeNoAddRef();
    internal ContextCookie get_ContextCookie();
    internal ContextEntry get_ContextEntry();
    private ComMarshalingType GetComMarshalingBehaviorAtRuntime();
    internal bool get_IsFreeThreaded();
    internal bool get_IsInhibit();
    internal bool get_IsStandard();
    internal bool get_IsUnknown();
    private IntPtr GetAddRefedComPointerForCurrentContext();
    private IntPtr MarshalComPointerToStream();
    private static IntPtr MarshalComPointerToStream_InDifferentContext(ContextEntry context, IntPtr pComPtr);
    private static IntPtr MarshalComPointerToStream_InCurrentContext(IntPtr pComPtr);
    private static bool MarshalInterThreadInterfaceInStream(Guid& iid, IntPtr pUnknown, IntPtr& pRetStream);
    internal bool get_IsDisposed();
    internal void Dispose(bool inCurrentContext);
}
internal class System.Runtime.InteropServices.ContextCookie : ValueType {
    internal IntPtr pCookie;
    internal static ContextCookie Default { get; }
    internal bool IsDefault { get; }
    internal bool IsCurrent { get; }
    internal static ContextCookie Current { get; }
    private ContextCookie(IntPtr _pCookie);
    internal static ContextCookie get_Default();
    internal bool get_IsDefault();
    internal bool Equals(ContextCookie cookie);
    internal bool get_IsCurrent();
    internal static ContextCookie get_Current();
}
internal class System.Runtime.InteropServices.ContextCookieComparer : object {
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Runtime.InteropServices.ContextCookie>.Equals(ContextCookie x, ContextCookie y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Runtime.InteropServices.ContextCookie>.GetHashCode(ContextCookie obj);
}
internal class System.Runtime.InteropServices.ContextEntry : object {
    private ContextCookie m_cookie;
    private IntPtr m_pObjectContext;
    private Lock m_delayedReleaseListLock;
    private List`1<IntPtr> m_delayedReleaseList;
    private List`1<IntPtr> m_delayedReleaseStreamList;
    internal ContextCookie ContextCookie { get; }
    internal bool IsCurrent { get; }
    private ContextEntry(ContextCookie cookie);
    internal ContextCookie get_ContextCookie();
    internal bool get_IsCurrent();
    protected virtual override void Finalize();
    internal static void RemoveCurrentContext();
    internal bool EnterContext(EnterContextCallback callback);
    [NativeCallableAttribute]
private static int EnterContextCallbackProc(IntPtr ptr);
    internal static ContextEntry GetCurrentContext(ContextCookie currentCookie);
    internal void EnqueueDelayedComRelease(IntPtr pComPtr);
    internal void EnqueueDelayedStreamRelease(IntPtr pStream);
    internal void PerformDelayedCleanup();
    private void PerformDelayedCleanupWorker();
}
internal class System.Runtime.InteropServices.CryptographicException : Exception {
    public CryptographicException(int hr);
}
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    private decimal m_WrappedObject;
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    public CurrencyWrapper(object obj);
    public decimal get_WrappedObject();
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.DECIMAL : ValueType {
    private ulong Hi64;
    private ulong Lo64;
    internal DECIMAL(decimal dec);
    internal decimal ToDecimal();
    public static decimal op_Implicit(DECIMAL dec);
    public static DECIMAL op_Implicit(decimal dec);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
    private object value;
    public object Value { get; }
    public DefaultParameterValueAttribute(object value);
    public object get_Value();
}
internal class System.Runtime.InteropServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    public void SetPrimaryAndSecondary(object primary, object secondary);
    public void Free();
}
internal class System.Runtime.InteropServices.DependentHandleList : ValueType {
    private int m_freeIndex;
    private int m_capacity;
    private IntPtr* m_pHandles;
    private int m_shrinkHint;
    internal static int DefaultCapacity;
    internal static int ShrinkHintThreshold;
    [GCCallbackAttribute]
internal bool ResetHandles();
    [GCCallbackAttribute]
internal bool AllocateHandle(object primary, object secondary);
    [GCCallbackAttribute]
internal bool Grow();
    [GCCallbackAttribute]
internal bool Shrink();
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.DispatchHelpers : object {
    internal static Exception CheckCopyTo(int count, Array array, int index);
    public static void CopyMapTo(__ComObject _this, int count, KeyValuePair`2[] array, int arrayIndex);
}
public class System.Runtime.InteropServices.DispatchWrapper : object {
    public object WrappedObject { get; }
    public DispatchWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    public int get_Value();
}
internal static class System.Runtime.InteropServices.DynamicInteropBoxingHelpers : object {
    internal static string IReference_Prefix;
    internal static string IReferenceArray_Prefix;
    internal static string IKeyValuePair_Prefix;
    private static DynamicInteropBoxingHelpers();
    public static bool TryGetBoxingArgumentTypeHandleFromString(string typename, BoxingInterfaceKind& boxingInterfaceKind, RuntimeTypeHandle[]& genericTypeArgument);
    public static object Unboxing(BoxingInterfaceKind boxingInterfaceKind, RuntimeTypeHandle[] genericTypeArgumentTypeHandle, object target);
    private static bool TryGetWinRTBoxedType(RuntimeTypeHandle managedTypeHandle, bool isArray, RuntimeTypeHandle& boxedTypeHandle);
    internal static int TryGetWinRTBoxedPropertyType(RuntimeTypeHandle managedTypeHandle, bool isArray);
    public static bool Boxing(RuntimeTypeHandle managedTypeHandle, RuntimeTypeHandle& boxingWrapperType, Int32& boxingPropertyType);
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.DynamicInteropCCWTemplateHelper : object {
    public static RuntimeTypeHandle FindInterfaceInCCWTemplate(RuntimeTypeHandle managedObjectTypeHandle, Guid& iid);
    private static bool IsCovariantInterface(RuntimeTypeHandle typeHandle);
    private static IEnumerable`1<RuntimeTypeHandle> GetVarianceTypesForType(RuntimeTypeHandle genericArgumentTypeHandle);
    private static RuntimeTypeHandle GetRuntimeClassNameInterfaceInternal(RuntimeTypeHandle typeHandle, List`1<RuntimeTypeHandle> visitedTypes, bool lastInterfaceIsCoVariant, bool isSelf);
    private static RuntimeTypeHandle SubstituteGenericParametersWithRuntimeInterfaces(RuntimeTypeHandle interfaceTypeHandle, List`1<RuntimeTypeHandle> visitedTypes);
    private static RuntimeTypeHandle SelectTopInterface(RuntimeTypeHandle typeHandle);
    private static bool IsBoxingWrapperType(RuntimeTypeHandle typeHandle, String& runtimeClassName);
    public static string GetCCWRuntimeClassName(RuntimeTypeHandle typeHandle);
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.DynamicInteropGuidHelpers : object {
    private static Guid s_PInterfaceNamespace;
    private static DynamicInteropGuidHelpers();
    private static string GetWinRTNameForWellKnownType(RuntimeTypeHandle typeHandle);
    private static string WinRTTypeToWinRTName(RuntimeTypeHandle typeArgumentHandle);
    public static string GenericWinRTTypeToWinRTName(RuntimeTypeHandle genericInstanceTypeHandle);
    private static string GenericWinRTTypeToWinRTName(RuntimeTypeHandle openGenericTypeHandle, RuntimeTypeHandle[] genericTypeArgumentHandles);
    public static Guid GetGuid_NoThrow(RuntimeTypeHandle genericInstanceTypeHandle);
    public static Guid GetGuid(RuntimeTypeHandle openGenericTypeHandle, RuntimeTypeHandle[] genericTypeArgumentHandles);
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.DynamicInteropHelpers : object {
    private static MethodInfo GetInvokeMethodFromDelegate(TypeInfo delegateType);
    public static TDelegate GetDelegateForNativeTarget(IntPtr nativeTarget, CallingConvention callingConvention);
    public static TDelegate GetDelegateForForwardWinRTMethod(int vtableIndex);
    public static IntPtr GetFuncPtrForForwardWinRTMethod(InteropMethodData interopMethodData, int vtableIndex);
    public static TDelegate GetDelegateForForwardWinRTMethod(InteropMethodData interopMethodData, int vtableIndex);
    public static IntPtr GetDynamicInteropThunkForDelegate(Type delegateType, Delegate d, InteropCallType interopCallType, CallingConvention callingConvention);
    internal static IntPtr GetDynamicInteropThunkForInstanceMethod(IntPtr safeTargetAddress, MethodInfo invokedMemberMethod, InteropCallType callType);
    internal static IntPtr GetDynamicInteropThunkForMethod(IntPtr safeTargetAddress, InteropMethodData methodData);
    private static void GetMarshallerForMethod(InteropMethodData methodData, LocalVariableType[]& safeTypes, LocalVariableType[]& unsafeTypes, BaseMarshaller[]& marshallers, MarshallerArgumentInfo[]& marshallerArgumentInfos);
    private static IntPtr GetCCWVTableForWellKnownGenericType(RuntimeTypeHandle genericTypeDef, RuntimeTypeHandle[] genericTypeArgs);
    public static IntPtr GetCCWVTable_NoThrow(object o, RuntimeTypeHandle interfaceTypeHandle, Int32& dynamicMethodStartIndex, Int32& dynamicMethodEndIndex);
    private static IntPtr GetCCWVTable(object o, RuntimeTypeHandle typeHandle, Int32& dynamicMethodStartIndex, Int32& dynamicMethodEndIndex);
}
internal class System.Runtime.InteropServices.DynamicInteropTypeHelper : object {
    internal static bool IsWinRTType(RuntimeTypeHandle typeHandle);
    internal static bool IsWindowsRuntimeType_IgnoringGenericArgs(RuntimeTypeHandle typeHandle);
    internal static bool IsWindowsRuntimeType(RuntimeTypeHandle typeHandle);
    public static bool TryIsWindowsRuntimeType(RuntimeTypeHandle typeHandle, Boolean& isWindowsRuntimeType);
    private static bool IsWinRTNameAndType(string typeName, TypeKind typeKind);
    private static bool IsBoxingWrapperType(RuntimeTypeHandle typeHandle, String& typeName);
    public static string GetTypeName(RuntimeTypeHandle typeHandle, Boolean& isWinRT);
    private static bool RoParseTypeName(string typeName, String[]& typenameParts);
    private static RuntimeTypeHandle ComposeTypeRecursively(RuntimeTypeHandle[] typeHandleParts, Int32& pIndex);
    private static RuntimeTypeHandle GetManagedTypeFromSimpleWinRTNameInternal(string name);
    public static Type GetTypeFromWinRTName(string winRTName, int nativeTypeKind);
    public static bool IsManagedWinMDType(RuntimeTypeHandle typeHandle);
    public static bool IsManagedWinMDClassOrEnumInCLRView(RuntimeTypeHandle typeHandle);
    public static RuntimeTypeHandle ReplaceOpenGenericTypeInGenericInstantiation(RuntimeTypeHandle instantiationType, RuntimeTypeHandle newOpenGenericTypeHandle);
}
internal class System.Runtime.InteropServices.EnumerableCustomPropertyProviderProxy : object {
    private IEnumerable m_target;
    internal EnumerableCustomPropertyProviderProxy(IEnumerable target);
    public sealed virtual object GetTarget();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Runtime.InteropServices.EqualityComparerForIntPtr : EqualityComparer`1<IntPtr> {
    public virtual bool Equals(IntPtr x, IntPtr y);
    public virtual int GetHashCode(IntPtr x);
}
internal class System.Runtime.InteropServices.EquatableIntPtr : ValueType {
    private Void* m_value;
    internal EquatableIntPtr(Void* p);
    internal Void* ToPointer();
    public sealed virtual bool Equals(EquatableIntPtr other);
}
public class System.Runtime.InteropServices.ErrorWrapper : object {
    private int m_ErrorCode;
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public ErrorWrapper(Exception e);
    public int get_ErrorCode();
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.ExceptionHelpers : object {
    public static bool PropagateException(Exception ex);
    private static bool OriginateLanguageException(Exception ex);
    internal static int GetHRForExceptionWithErrorPropagationNoThrow(Exception ex, bool isWinRTScenario);
    internal static Exception GetMappingExceptionForHR(int errorCode, string message, bool createCOMException, bool hasErrorInfo);
    private static Exception ConstructExceptionUsingReflection(string exceptionTypeName, string message);
    private static bool TryGetRestrictedErrorInfo(IntPtr& pRestrictedErrorInfo);
    internal static Exception GetExceptionForHRInternalNoThrow(int hr, bool isWinRTScenario, bool isClassicCOM);
    internal static bool ReportUnhandledError(Exception e);
    internal static Exception AttachRestrictedErrorInfo(Exception e);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.ExternalInterop : object {
    internal static int FORMAT_MESSAGE_IGNORE_INSERTS;
    internal static int FORMAT_MESSAGE_FROM_SYSTEM;
    internal static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    internal static int FORMAT_MESSAGE_MAX_WIDTH_MASK;
    internal static int ERROR_INSUFFICIENT_BUFFER;
    private static int MaxAllowedBufferSize;
    public static IntPtr MemAlloc(UIntPtr sizeInBytes);
    public static IntPtr MemAlloc(IntPtr sizeInBytes);
    public static void MemFree(IntPtr ptr);
    public static IntPtr MemReAlloc(IntPtr ptr, UIntPtr newSize);
    public static IntPtr MemReAlloc(IntPtr ptr, IntPtr newSize);
    internal static IntPtr MemAllocWithZeroInitializeNoThrow(UIntPtr sizeInBytes);
    internal static IntPtr MemReAllocWithZeroInitializeNoThrow(IntPtr ptr, UIntPtr oldSize, UIntPtr newSize);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoCreateInstanceFromApp(Guid* clsid, IntPtr pUnkOuter, int context, IntPtr reserved, int count, IntPtr results);
    internal static void CreateBindCtx(UInt32 reserved, IBindCtx& ppbc);
    internal static void MkParseDisplayName(IBindCtx pbc, string szUserName, UInt32& pchEaten, IMoniker& ppmk);
    [McgGeneratedNativeCallCodeAttribute]
internal static void VariantClear(IntPtr pObject);
    public static void SafeCoTaskMemFree(Void* pv);
    [McgGeneratedNativeCallCodeAttribute]
internal static void OutputDebugString(Char* lpOutputString);
    internal static void OutputDebugString(string outputString);
    [McgGeneratedNativeCallCodeAttribute]
internal static int FormatMessage(int dwFlags, IntPtr lpSource, UInt32 dwMessageId, UInt32 dwLanguageId, Char* lpBuffer, UInt32 nSize, IntPtr Arguments);
    [McgGeneratedNativeCallCodeAttribute]
internal static int GetCPInfo(UInt32 codePage, CPINFO* lpCpInfo);
    private static bool TryGetMessage(int errorCode, int bufferSize, String& errorMsg);
    public static string GetMessage(int errorCode);
    [McgGeneratedNativeCallCodeAttribute]
public static void SysFreeString(Void* pBSTR);
    public static void SysFreeString(IntPtr pBstr);
    [McgGeneratedNativeCallCodeAttribute]
public static UInt32 SysStringLen(Void* pBSTR);
    public static UInt32 SysStringLen(IntPtr pBSTR);
    [McgGeneratedNativeCallCodeAttribute]
public static IntPtr SysAllocString(IntPtr pStrIn);
    [McgGeneratedNativeCallCodeAttribute]
public static Char* SysAllocStringLen(Char* pStrIn, UInt32 len);
    [McgGeneratedNativeCallCodeAttribute]
public static int WindowsCreateString(Char* sourceString, UInt32 length, Void* hstring);
    [McgGeneratedNativeCallCodeAttribute]
public static void WindowsDeleteString(Void* hstring);
    [McgGeneratedNativeCallCodeAttribute]
public static Char* WindowsGetStringRawBuffer(Void* hstring, UInt32* pLength);
    [McgGeneratedNativeCallCodeAttribute]
public static int RoActivateInstance(Void* hActivatableClassId, Void*& ppv);
    [McgGeneratedNativeCallCodeAttribute]
public static int GetRestrictedErrorInfo(IntPtr& pRestrictedErrorInfo);
    [McgGeneratedNativeCallCodeAttribute]
public static int RoOriginateError(int hr, HSTRING hstring);
    [McgGeneratedNativeCallCodeAttribute]
public static int SetRestrictedErrorInfo(IntPtr pRestrictedErrorInfo);
    [McgGeneratedNativeCallCodeAttribute]
internal static int RoOriginateLanguageException(int hr, HSTRING message, IntPtr pLanguageException);
    [McgGeneratedNativeCallCodeAttribute]
internal static int RoReportUnhandledError(IntPtr pRestrictedErrorInfo);
    internal static int RoParseTypeName(HSTRING typename, UInt32* typenamePartsLength, IntPtr** typenameParts);
    [McgGeneratedNativeCallCodeAttribute]
internal static void InitializeCriticalSectionEx(CRITICAL_SECTION* lpCriticalSection, int dwSpinCount, int flags);
    [McgGeneratedNativeCallCodeAttribute]
internal static void EnterCriticalSection(CRITICAL_SECTION* lpCriticalSection);
    [McgGeneratedNativeCallCodeAttribute]
internal static void LeaveCriticalSection(CRITICAL_SECTION* lpCriticalSection);
    [McgGeneratedNativeCallCodeAttribute]
internal static void DeleteCriticalSection(CRITICAL_SECTION* lpCriticalSection);
    [McgGeneratedNativeCallCodeAttribute]
public static int RoGetActivationFactory(Void* hstring_typeName, Guid* iid, Void* ppv);
    [McgGeneratedNativeCallCodeAttribute]
internal static int WindowsCreateStringReference(Char* sourceString, UInt32 length, HSTRING_HEADER* phstringHeader, Void* hstring);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoCreateFreeThreadedMarshaler(Void* pOuter, Void** ppunkMarshal);
    [McgGeneratedNativeCallCodeAttribute]
public static int CoGetContextToken(IntPtr* ppToken);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoGetObjectContext(Guid* iid, Void* ppv);
    [McgGeneratedNativeCallCodeAttribute]
private static int CoGetMarshalSizeMax(UInt64* pulSize, Guid* iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    [McgGeneratedNativeCallCodeAttribute]
private static int CoMarshalInterface(IntPtr pStream, Guid* iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    [McgGeneratedNativeCallCodeAttribute]
private static int CoUnmarshalInterface(IntPtr pStream, Guid* iid, Void** ppv);
    [McgGeneratedNativeCallCodeAttribute]
internal static int CoReleaseMarshalData(IntPtr pStream);
    internal static int CoMarshalInterface(IntPtr pStream, Guid& iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    internal static int CoUnmarshalInterface(IntPtr pStream, Guid& iid, IntPtr& ppv);
    internal static int CoGetMarshalSizeMax(UInt64& pulSize, Guid& iid, IntPtr pUnk, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    internal static void RoGetActivationFactory(string className, Guid& iid, IntPtr& ppv);
    public static int CoGetContextToken(IntPtr& ppToken);
    internal static int CoGetObjectContext(Guid& iid, IntPtr& ppv);
}
internal class System.Runtime.InteropServices.FactoryCache : object {
    private ConcurrentDictionary`2<string, FactoryCacheItem> m_cachedFactories;
    private static FactoryCache modreq(System.Runtime.CompilerServices.IsVolatile) s_factoryCache;
    internal static FactoryCache Get();
    private static __ComObject GetActivationFactoryInternal(string typeName, RuntimeTypeHandle factoryItf, ContextEntry currentContext);
    internal __ComObject GetActivationFactory(string className, RuntimeTypeHandle factoryIntf, bool skipCache);
}
internal class System.Runtime.InteropServices.FactoryCacheItem : ValueType {
    internal ContextEntry contextEntry;
    internal __ComObject factoryObject;
}
internal class System.Runtime.InteropServices.FixedHashTable : object {
    private static int slot_bucket;
    private static int slot_next;
    private static int slot_index;
    private Int32[] m_entries;
    private int m_size;
    private int m_count;
    internal FixedHashTable(int size);
    internal void Add(int hashCode, int index);
    internal int GetFirst(int hashCode);
    internal int GetIndex(int bucket);
    internal int GetNext(int bucket);
}
internal class System.Runtime.InteropServices.ForwardCOMCallInterceptor : InteropCallInterceptor {
    private int m_vtableIndex;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_unsafeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ForwardCOMCallInterceptor(int vtableIndex, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.ForwardDelegateCreationStub : MulticastDelegate {
    public ForwardDelegateCreationStub(object object, IntPtr method);
    public virtual Delegate Invoke(IntPtr pFunc);
    public virtual IAsyncResult BeginInvoke(IntPtr pFunc, AsyncCallback callback, object object);
    public virtual Delegate EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.ForwardPInvokeCallInterceptor : InteropCallInterceptor {
    private IntPtr m_unsafeTargetAddress;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_unsafeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ForwardPInvokeCallInterceptor(IntPtr unsafeTargetAddress, CallingConvention unsafeTargetCallingConvention, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
internal class System.Runtime.InteropServices.ForwardWinRTCallInterceptor : InteropCallInterceptor {
    private int m_vtableIndex;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_unsafeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ForwardWinRTCallInterceptor(int vtableIndex, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
internal class System.Runtime.InteropServices.GCCallbackAttribute : Attribute {
}
internal static class System.Runtime.InteropServices.GCEventProvider : object {
    public static bool IsETWHeapCollectionEnabled();
    [GCCallbackAttribute]
public static void TaskLogLiveCCW(IntPtr CCWGCHandle, IntPtr pCCW, IntPtr typeRawValue, IntPtr IUnknown, int ComRefCount, int JupiterRefCount, int flags);
    [GCCallbackAttribute]
public static void TaskLogLiveRCW(IntPtr pRCW, IntPtr typeRawValue, IntPtr IUnknown, IntPtr VTable, int refCount, ComObjectFlags flags);
    [GCCallbackAttribute]
public static void FlushComETW();
}
internal class System.Runtime.InteropServices.GCMemoryPressureConstants : ValueType {
    internal static int GC_PRESSURE_DEFAULT;
    internal static int GC_PRESSURE_WINRT_LOW;
    internal static int GC_PRESSURE_WINRT_MEDIUM;
    internal static int GC_PRESSURE_WINRT_HIGH;
}
internal enum System.Runtime.InteropServices.GCPressureRange : Enum {
    public int value__;
    public static GCPressureRange None;
    public static GCPressureRange WinRT_Default;
    public static GCPressureRange WinRT_Low;
    public static GCPressureRange WinRT_Medium;
    public static GCPressureRange WinRT_High;
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.GuidGenerator : object {
    private static long HostToNetworkOrder(long host);
    private static int HostToNetworkOrder(int host);
    private static short HostToNetworkOrder(short host);
    private static long NetworkToHostOrder(long network);
    private static int NetworkToHostOrder(int network);
    private static short NetworkToHostOrder(short network);
    public static Guid GenerateFromString(Guid g, string typeName);
}
public class System.Runtime.InteropServices.HandleCollector : object {
    private static int deltaPercent;
    private string name;
    private int initialThreshold;
    private int maximumThreshold;
    private int threshold;
    private int handleCount;
    private Int32[] gc_counts;
    private int gc_gen;
    public int Count { get; }
    public int InitialThreshold { get; }
    public int MaximumThreshold { get; }
    public string Name { get; }
    public HandleCollector(string name, int initialThreshold);
    public HandleCollector(string name, int initialThreshold, int maximumThreshold);
    public int get_Count();
    public int get_InitialThreshold();
    public int get_MaximumThreshold();
    public string get_Name();
    public void Add();
    public void Remove();
}
internal class System.Runtime.InteropServices.HashProviderCng : object {
    private SafeBCryptAlgorithmHandle _hAlgorithm;
    private SafeBCryptHashHandle _hHash;
    private Byte[] _key;
    private bool _reusable;
    private int _hashSize;
    public int HashSizeInBytes { get; }
    public HashProviderCng(string hashAlgId, Byte[] key);
    public void AppendHashData(Byte[] data, int offset, int count);
    internal void AppendHashDataCore(Byte[] data, int offset, int count);
    public Byte[] FinalizeHashAndReset();
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
    public int get_HashSizeInBytes();
    private void ResetHashObject();
    private void DestroyHash();
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.HSTRING : ValueType {
    public IntPtr handle;
    public HSTRING(IntPtr hndl);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.HSTRING_HEADER : ValueType {
}
[GuidAttribute("00000001-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.IClassFactory {
    public abstract virtual int CreateInstance(IntPtr pUnkOuter, Guid* riid, IntPtr* ppvObject);
    public abstract virtual int LockServer(int fLock);
}
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IEnumerable`1")]
internal class System.Runtime.InteropServices.IEnumerable_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IterableToEnumerableAdapter`1<T> m_adapter;
    private IterableToEnumerableAdapter`1<T> RCWAdapter { get; }
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IterableToEnumerableAdapter`1<T> get_RCWAdapter();
}
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.IManagedWrapper {
    public abstract virtual object GetTarget();
}
internal enum System.Runtime.InteropServices.InterfaceCheckResult : Enum {
    public int value__;
    public static InterfaceCheckResult Supported;
    public static InterfaceCheckResult Rejected;
    public static InterfaceCheckResult NotFound;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    internal ComInterfaceType _val;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    public ComInterfaceType get_Value();
}
internal class System.Runtime.InteropServices.InternalModule : McgModule {
    private static int PriorityForInternalModule;
    internal static McgInterfaceData s_IUnknown;
    internal static McgInterfaceData s_IInspectable;
    internal static McgInterfaceData s_IActivationFactoryInternal;
    internal static McgInterfaceData s_ICustomPropertyProvider;
    internal static McgInterfaceData s_IWeakReferenceSource;
    internal static McgInterfaceData s_IWeakReference;
    internal static McgInterfaceData s_ICCW;
    internal static McgInterfaceData s_IJupiterObject;
    internal static McgInterfaceData s_IStringable;
    internal static McgInterfaceData s_IManagedActivationFactory;
    internal static McgInterfaceData s_IRestrictedErrorInfo;
    internal static McgInterfaceData s_IMarshal;
    internal static McgInterfaceData s_IDispatch;
    internal static McgInterfaceData s_HSTRING;
    internal static McgInterfaceData s_ILanguageExceptionStackBackTrace;
    private static McgInterfaceData[] s_interfaceData;
    private static InternalModule();
}
internal class System.Runtime.InteropServices.InternalTypes : object {
    internal static RuntimeTypeHandle IUnknown;
    internal static RuntimeTypeHandle ICCW;
    internal static RuntimeTypeHandle IMarshal;
    internal static RuntimeTypeHandle IDispatch;
    internal static RuntimeTypeHandle IInspectable;
    internal static RuntimeTypeHandle IActivationFactoryInternal;
    internal static RuntimeTypeHandle ICustomPropertyProvider;
    internal static RuntimeTypeHandle IWeakReferenceSource;
    internal static RuntimeTypeHandle IWeakReference;
    internal static RuntimeTypeHandle IJupiterObject;
    internal static RuntimeTypeHandle IStringable;
    internal static RuntimeTypeHandle IManagedActivationFactory;
    internal static RuntimeTypeHandle IRestrictedErrorInfo;
    internal static RuntimeTypeHandle HSTRING;
    internal static RuntimeTypeHandle ILanguageExceptionStackBackTrace;
    private static InternalTypes();
}
internal abstract class System.Runtime.InteropServices.InteropCallInterceptor : CallInterceptor {
    private BaseMarshaller[] m_marshallers;
    private MarshallerArgumentInfo[] m_marshallerArgumentInfos;
    internal InteropCallInterceptor(BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos, bool nativeToManaged);
    internal void ToSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs);
    internal void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs);
    internal void CleanupSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs);
    internal void CleanupUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs);
}
[EventSourceAttribute]
internal class System.Runtime.InteropServices.InteropEventProvider : EventSource {
    public static InteropEventProvider Log;
    private static int TASKRCWCREATION_ID;
    private static int TASKRCWFINALIZATION_ID;
    private static int TASKRCWREFCOUNTINC_ID;
    private static int TASKRCWREFCOUNTDEC_ID;
    private static int TASKRCWQUERYINTERFACEFAILURE_ID;
    private static int TASKRCWQUERYINTERFACE_ID;
    private static int TASKCCWCREATION_ID;
    private static int TASKCCWFINALIZATION_ID;
    private static int TASKCCWREFCOUNTINC_ID;
    private static int TASKCCWREFCOUNTDEC_ID;
    private static int TASKCCWQUERYRUNTIMECLASSNAME_ID;
    private static int TASKCCWQUERYINTERFACEFAILURE_ID;
    private static int TASKCCWQUERYINTERFACE_ID;
    private static int TASKCCWRESOLVEFAILURE_ID;
    private static int TASKJUPITERGARBAGECOLLECT_ID;
    private static int TASKJUPITERDISCONNECTERCWSINCURRENTAPARTMENT_ID;
    private static int TASKJUPITERADDMEMORYPRESSURE_ID;
    private static int TASKJUPITERREMOVEMEMORYPRESSURE_ID;
    private static int TASKJUPITERCREATEMANAGEDREFERENCE_ID;
    private static InteropEventProvider();
    internal static bool IsEnabled();
    [EventAttribute("10")]
public void TaskRCWCreation(long objectID, long typeRawValue, string runtimeClassName, long context, long flags);
    [EventAttribute("12")]
public void TaskRCWRefCountInc(long objectID, int refCount);
    [EventAttribute("13")]
public void TaskRCWRefCountDec(long objectID, int refCount);
    [EventAttribute("11")]
public void TaskRCWFinalization(long objectID, int refCount);
    [EventAttribute("14")]
public void TaskRCWQueryInterfaceFailure(long objectID, long context, Guid interfaceIId, int reason);
    [EventAttribute("15")]
public void TaskRCWQueryInterface(long objectID, long context, Guid interfaceIId, long typeRawValue);
    [EventAttribute("20")]
public void TaskCCWCreation(long objectID, long targetObjectID, long typeRawValue);
    [EventAttribute("21")]
public void TaskCCWFinalization(long objectID, long refCount);
    [EventAttribute("22")]
public void TaskCCWRefCountInc(long objectID, long refCount);
    [EventAttribute("23")]
public void TaskCCWRefCountDec(long objectID, long refCount);
    [EventAttribute("24")]
public void TaskCCWQueryRuntimeClassName(long objectID, string runtimeClassName);
    [EventAttribute("30")]
public void TaskCCWQueryInterfaceFailure(long objectID, Guid interfaceIId);
    [EventAttribute("31")]
public void TaskCCWQueryInterface(long objectID, long typeRawValue);
    [EventAttribute("33")]
public void TaskCCWResolveFailure(long objectID, long interfaceAddress, Guid interfaceIId, int rejectedReason);
    [EventAttribute("40")]
public void TaskJupiterGarbageCollect();
    [EventAttribute("41")]
public void TaskJupiterDisconnectRCWsInCurrentApartment();
    [EventAttribute("42")]
public void TaskJupiterAddMemoryPressure(long memorySize);
    [EventAttribute("43")]
public void TaskJupiterRemoveMemoryPressure(long memorySize);
    [EventAttribute("44")]
public void TaskJupiterCreateManagedReference(long IUnknown, long objectType);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.InteropMethodData : object {
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private InteropCallType <InteropCallType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreserveSig>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private InteropParameterData[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public Type DeclaringType { get; private set; }
    public InteropCallType InteropCallType { get; private set; }
    public bool IsPreserveSig { get; private set; }
    public bool IsStatic { get; private set; }
    public InteropParameterData[] Parameters { get; private set; }
    public Type ReturnType { get; private set; }
    public InteropMethodData(MethodInfo invokeMethod, InteropCallType interopCallType, bool isStatic);
    public InteropMethodData(Type returnType, InteropParameterData[] parameters, InteropCallType interopCallType, bool isStatic);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
private void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public InteropCallType get_InteropCallType();
    [CompilerGeneratedAttribute]
private void set_InteropCallType(InteropCallType value);
    [CompilerGeneratedAttribute]
public bool get_IsPreserveSig();
    [CompilerGeneratedAttribute]
private void set_IsPreserveSig(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
private void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public InteropParameterData[] get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(InteropParameterData[] value);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(Type value);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.InteropParameterData : object {
    [CompilerGeneratedAttribute]
private bool <IsIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsByRef>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    public bool IsIn { get; internal set; }
    public bool IsOut { get; internal set; }
    public bool IsByRef { get; internal set; }
    public Type ParameterType { get; internal set; }
    public InteropParameterData(Type parameterType);
    public InteropParameterData(Type parameterType, bool isIn, bool isOut);
    private void SetDefaultInOut();
    [CompilerGeneratedAttribute]
public bool get_IsIn();
    [CompilerGeneratedAttribute]
internal void set_IsIn(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOut();
    [CompilerGeneratedAttribute]
internal void set_IsOut(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsByRef();
    [CompilerGeneratedAttribute]
internal void set_IsByRef(bool value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
internal void set_ParameterType(Type value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
internal class System.Runtime.InteropServices.IStringableHelper : object {
    internal static bool TryGetIStringableToString(object obj, String& toStringResult);
}
[GuidAttribute("9e365e57-48b2-4160-956f-c7385120bbfc")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.IUriRuntimeClass {
}
[GuidAttribute("44a9796f-723e-4fdf-a218-033e75b0c084")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.IUriRuntimeClassFactory {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    public int get_Value();
}
internal class System.Runtime.InteropServices.LightweightList`1 : ValueType {
    private T[] m_array;
    private int m_countAndLock;
    private static int InitialCapacity;
    private void AssertLockHeld();
    private int AcquireLockAndGetCount();
    private void ReleaseLockAndSetCount(int newCount);
    private void SetArrayElement(int index, T value);
    private void GetArrayAndCount(T[]& array, Int32& count);
    public void Add(T value);
    public Enumerator<T> GetEnumerator();
}
internal class System.Runtime.InteropServices.ListCustomPropertyProviderProxy : object {
    private IList m_target;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal ListCustomPropertyProviderProxy(IList target);
    public sealed virtual object GetTarget();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class System.Runtime.InteropServices.Marshal : object {
    private static long HIWORDMASK;
    [__BlockReflectionInvokeAttribute]
public static int SystemDefaultCharSize;
    [__BlockReflectionInvokeAttribute]
public static int SystemMaxDBCSCharSize;
    private static Marshal();
    [__BlockReflectionInvokeAttribute]
public static int GetLastWin32Error();
    internal static void SetLastWin32Error(int errorCode);
    [__BlockReflectionInvokeAttribute]
public static IntPtr AllocHGlobal(IntPtr cb);
    [__BlockReflectionInvokeAttribute]
public static IntPtr AllocHGlobal(int cb);
    [__BlockReflectionInvokeAttribute]
public static void FreeHGlobal(IntPtr hglobal);
    [__BlockReflectionInvokeAttribute]
public static IntPtr AllocCoTaskMem(int cb);
    [__BlockReflectionInvokeAttribute]
public static void FreeCoTaskMem(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr SecureStringToBSTR(SecureString s);
    [__BlockReflectionInvokeAttribute]
public static int GetHRForException(Exception e);
    [__BlockReflectionInvokeAttribute]
public static Exception GetExceptionForHR(int errorCode);
    private static bool IsWin32Atom(IntPtr ptr);
    private static bool IsNotWin32Atom(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringAnsi(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringAnsi(IntPtr ptr, int len);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringUni(IntPtr ptr, int len);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringUni(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringAuto(IntPtr ptr, int len);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringAuto(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    [__BlockReflectionInvokeAttribute]
public static int SizeOf();
    [__BlockReflectionInvokeAttribute]
public static int SizeOf(T structure);
    [__BlockReflectionInvokeAttribute]
public static int SizeOf(object structure);
    [__BlockReflectionInvokeAttribute]
public static int SizeOf(Type t);
    private static int SizeOfHelper(Type t);
    [__BlockReflectionInvokeAttribute]
public static IntPtr OffsetOf(Type t, string fieldName);
    public static IntPtr OffsetOf(string fieldName);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    [__BlockReflectionInvokeAttribute]
public static byte ReadByte(IntPtr ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static byte ReadByte(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static short ReadInt16(IntPtr ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static short ReadInt16(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static int ReadInt32(IntPtr ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static int ReadInt32(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static IntPtr ReadIntPtr(object ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static IntPtr ReadIntPtr(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static long ReadInt64(IntPtr ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static long ReadInt64(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static void WriteByte(IntPtr ptr, int ofs, byte val);
    [__BlockReflectionInvokeAttribute]
public static void WriteByte(IntPtr ptr, byte val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt16(IntPtr ptr, int ofs, short val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt16(IntPtr ptr, short val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt16(IntPtr ptr, int ofs, char val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt16(object ptr, int ofs, char val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt16(IntPtr ptr, char val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt32(IntPtr ptr, int ofs, int val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt32(IntPtr ptr, int val);
    [__BlockReflectionInvokeAttribute]
public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    [__BlockReflectionInvokeAttribute]
public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    [__BlockReflectionInvokeAttribute]
public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt64(IntPtr ptr, int ofs, long val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt64(IntPtr ptr, long val);
    [__BlockReflectionInvokeAttribute]
public static int GetHRForLastWin32Error();
    [__BlockReflectionInvokeAttribute]
public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    [__BlockReflectionInvokeAttribute]
public static void ThrowExceptionForHR(int errorCode);
    [__BlockReflectionInvokeAttribute]
public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    private static void ThrowExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    [__BlockReflectionInvokeAttribute]
public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    private static void ConvertToAnsi(string source, IntPtr pbNativeBuffer, int cbNativeBuffer);
    private static string ConvertToUnicode(IntPtr sourceBuffer, int cbSourceBuffer);
    private static int lstrlenA(IntPtr sz);
    private static int lstrlenW(IntPtr wsz);
    private static void SecureZeroMemory(IntPtr ptr, int bytes);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToHGlobalAnsi(string s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToHGlobalUni(string s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToHGlobalAuto(string s);
    public static IntPtr GetIUnknownForObject(object o);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    [__BlockReflectionInvokeAttribute]
public static bool IsComObject(object o);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToCoTaskMemUni(string s);
    public static IntPtr StringToCoTaskMemUTF8(string s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToCoTaskMemAnsi(string s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToCoTaskMemAuto(string s);
    [__BlockReflectionInvokeAttribute]
public static int ReleaseComObject(object o);
    [__BlockReflectionInvokeAttribute]
public static int FinalReleaseComObject(object o);
    [__BlockReflectionInvokeAttribute]
public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    [__BlockReflectionInvokeAttribute]
public static int AddRef(IntPtr pUnk);
    [__BlockReflectionInvokeAttribute]
public static int Release(IntPtr pUnk);
    [__BlockReflectionInvokeAttribute]
public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    public static void FreeBSTR(IntPtr ptr);
    public static IntPtr StringToBSTR(string s);
    public static string PtrToStringBSTR(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static void ZeroFreeBSTR(IntPtr s);
    [__BlockReflectionInvokeAttribute]
public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    [__BlockReflectionInvokeAttribute]
public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    [__BlockReflectionInvokeAttribute]
public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    [__BlockReflectionInvokeAttribute]
public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
    [__BlockReflectionInvokeAttribute]
public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    private static void PtrToStructureHelper(IntPtr ptr, object structure);
    [__BlockReflectionInvokeAttribute]
public static object PtrToStructure(IntPtr ptr, Type structureType);
    public static T PtrToStructure(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static void PtrToStructure(IntPtr ptr, object structure);
    public static void PtrToStructure(IntPtr ptr, T structure);
    [__BlockReflectionInvokeAttribute]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    [__BlockReflectionInvokeAttribute]
public static void DestroyStructure(IntPtr ptr, Type structuretype);
    public static void DestroyStructure(IntPtr ptr);
    public static IntPtr GetComInterfaceForObject(T o);
    [__BlockReflectionInvokeAttribute]
public static IntPtr GetComInterfaceForObject(object o, Type T);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    [__BlockReflectionInvokeAttribute]
public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [__BlockReflectionInvokeAttribute]
public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [__BlockReflectionInvokeAttribute]
public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    [__BlockReflectionInvokeAttribute]
public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    [__BlockReflectionInvokeAttribute]
public static object BindToMoniker(string monikerName);
    [__BlockReflectionInvokeAttribute]
public static Type GetTypeFromCLSID(Guid clsid);
    [__BlockReflectionInvokeAttribute]
public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    [__BlockReflectionInvokeAttribute]
public static bool AreComObjectsAvailableForCleanup();
    [__BlockReflectionInvokeAttribute]
public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    [__BlockReflectionInvokeAttribute]
public static object CreateWrapperOfType(object o, Type t);
    [__BlockReflectionInvokeAttribute]
public static TWrapper CreateWrapperOfType(T o);
    [__BlockReflectionInvokeAttribute]
public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    [__BlockReflectionInvokeAttribute]
public static int GetExceptionCode();
    [__BlockReflectionInvokeAttribute]
public static int GetStartComSlot(Type t);
    [__BlockReflectionInvokeAttribute]
public static string GetTypeInfoName(ITypeInfo typeInfo);
    [__BlockReflectionInvokeAttribute]
public static byte ReadByte(object ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static short ReadInt16(object ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static int ReadInt32(object ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static long ReadInt64(object ptr, int ofs);
    [__BlockReflectionInvokeAttribute]
public static void WriteByte(object ptr, int ofs, byte val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt16(object ptr, int ofs, short val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt32(object ptr, int ofs, int val);
    [__BlockReflectionInvokeAttribute]
public static void WriteInt64(object ptr, int ofs, long val);
    [__BlockReflectionInvokeAttribute]
public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    [__BlockReflectionInvokeAttribute]
public static void CleanupUnusedObjectsInCurrentContext();
    [__BlockReflectionInvokeAttribute]
public static void Prelink(MethodInfo m);
    [__BlockReflectionInvokeAttribute]
public static void PrelinkAll(Type c);
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.MarshalAdapter : object {
    public static IntPtr GetIUnknownForObject(object o);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static IntPtr GetComInterfaceForObject(T o);
    public static IntPtr GetComInterfaceForObject(object o, Type T);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static bool IsComObject(object o);
    public static int ReleaseComObject(object o);
    public static int FinalReleaseComObject(object o);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int AddRef(IntPtr pUnk);
    public static int Release(IntPtr pUnk);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.ArrayMarshaller`2 : BaseMarshaller {
    private Marshaller`2<TSafe, TUnsafe> m_elementMarshaler;
    private static ArrayMarshaller`2<TSafe, TUnsafe> s_instance;
    private ArrayMarshaller`2(Marshaller`2<TSafe, TUnsafe> elementMarshaler);
    public static ArrayMarshaller`2<TSafe, TUnsafe> GetInstance(Marshaller`2<TSafe, TUnsafe> elementMarshaler);
    private ArrayMarshalScenario GetToSafeScenario(MarshallerArgumentInfo argInfo);
    private ArrayMarshalScenario GetToUnsafeScenario(MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void ToSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.Marshallers.ArrayMarshalScenario : Enum {
    public int value__;
    public static ArrayMarshalScenario None;
    public static ArrayMarshalScenario Allocate;
    public static ArrayMarshalScenario MarshalElements;
    public static ArrayMarshalScenario AllocateAndMarshalElements;
}
[__BlockReflectionAttribute]
public abstract class System.Runtime.InteropServices.Marshallers.BaseMarshaller : object {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <SafeType>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <UnsafeType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPinningRequired>k__BackingField;
    public RuntimeTypeHandle SafeType { get; private set; }
    public RuntimeTypeHandle UnsafeType { get; private set; }
    public bool IsPinningRequired { get; private set; }
    public BaseMarshaller(RuntimeTypeHandle safeType, RuntimeTypeHandle unsafeType);
    public BaseMarshaller(RuntimeTypeHandle safeType, RuntimeTypeHandle unsafeType, bool isPinningRequired);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_SafeType();
    [CompilerGeneratedAttribute]
private void set_SafeType(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
public RuntimeTypeHandle get_UnsafeType();
    [CompilerGeneratedAttribute]
private void set_UnsafeType(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
public bool get_IsPinningRequired();
    [CompilerGeneratedAttribute]
private void set_IsPinningRequired(bool value);
    public abstract virtual void ToSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public abstract virtual void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public abstract virtual void CleanupUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public abstract virtual void CleanupSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    internal static BaseMarshaller GetMarshaller(Type parameterType, InteropCallType interopCallType);
    private static BaseMarshaller GetMarshallerForPrimitiveType(Type parameterType, InteropCallType interopCallType);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.BlittableMarshaller`1 : Marshaller`2<T, T> {
    private static BlittableMarshaller`1<T> s_instance;
    public static BlittableMarshaller`1<T> Instance { get; }
    public static BlittableMarshaller`1<T> get_Instance();
    [__BlockReflectionAttribute]
public virtual void ToSafe(T& unsafeValue, T& safeValue);
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(T& safeValue, T& unsafeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(T unsafeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(T safeValue);
}
internal class System.Runtime.InteropServices.Marshallers.BoolTo2ByteBoolMarshaller : Marshaller`2<bool, short> {
    private static BoolTo2ByteBoolMarshaller s_instance;
    public static BoolTo2ByteBoolMarshaller Instance { get; }
    public static BoolTo2ByteBoolMarshaller get_Instance();
    public virtual void ToSafe(Int16& unsafeValue, Boolean& safeValue);
    public virtual void ToUnsafe(Boolean& safeValue, Int16& unsafeValue);
    public virtual void CleanupSafe(bool safeValue);
    public virtual void CleanupUnsafe(short unsafeValue);
}
internal class System.Runtime.InteropServices.Marshallers.BoolTo4ByteBoolMarshaller : Marshaller`2<bool, int> {
    private static BoolTo4ByteBoolMarshaller s_instance;
    public static BoolTo4ByteBoolMarshaller Instance { get; }
    public static BoolTo4ByteBoolMarshaller get_Instance();
    public virtual void ToUnsafe(Boolean& safeValue, Int32& unsafeValue);
    public virtual void ToSafe(Int32& unsafeValue, Boolean& safeValue);
    public virtual void CleanupUnsafe(int unsafeValue);
    public virtual void CleanupSafe(bool safeValue);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.DelegateMarshaller`1 : Marshaller`2<T, IntPtr> {
    private static DelegateMarshaller`1<T> s_instance;
    public static DelegateMarshaller`1<T> Instance { get; }
    public static DelegateMarshaller`1<T> get_Instance();
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(T& safeValue, IntPtr& unsafeValue);
    [__BlockReflectionAttribute]
public virtual void ToSafe(IntPtr& unsafeValue, T& safeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(IntPtr unsafeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(T safeValue);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.InterfaceMarshaller`1 : Marshaller`2<TSafe, IntPtr> {
    private static InterfaceMarshaller`1<TSafe> s_instance;
    public static InterfaceMarshaller`1<TSafe> Instance { get; }
    public static InterfaceMarshaller`1<TSafe> get_Instance();
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(TSafe& safeValue, IntPtr& unsafeValue);
    [__BlockReflectionAttribute]
public virtual void ToSafe(IntPtr& unsafeValue, TSafe& safeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(IntPtr unsafeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(TSafe safeValue);
    [__BlockReflectionAttribute]
public virtual bool IsCleanupUnsafeRequired(MarshallerArgumentInfo argInfo);
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.Marshallers.InteropCallType : Enum {
    public int value__;
    public static InteropCallType Forward;
    public static InteropCallType Reverse;
    public static InteropCallType PInvoke;
    public static InteropCallType Com;
    public static InteropCallType WinRT;
    public static InteropCallType ForwardPInvoke;
    public static InteropCallType ReversePInvoke;
    public static InteropCallType ForwardCom;
    public static InteropCallType ReverseCom;
    public static InteropCallType ForwardWinRT;
    public static InteropCallType ReverseWinRT;
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public abstract class System.Runtime.InteropServices.Marshallers.Marshaller`2 : BaseMarshaller {
    [__BlockReflectionAttribute]
public Marshaller`2(bool isPinningRequired);
    [__BlockReflectionAttribute]
public virtual void ToSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public abstract virtual void ToSafe(TUnsafe& unsafeValue, TSafe& safeValue);
    [__BlockReflectionAttribute]
public abstract virtual void ToUnsafe(TSafe& safeValue, TUnsafe& unsafeValue);
    [__BlockReflectionAttribute]
public abstract virtual void CleanupSafe(TSafe safeValue);
    [__BlockReflectionAttribute]
public abstract virtual void CleanupUnsafe(TUnsafe unsafeValue);
    [__BlockReflectionAttribute]
public virtual bool IsToSafeMarshallingRequired(MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual bool IsToUnsafeMarshallingRequired(MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual bool IsCleanupUnsafeRequired(MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual bool IsCleanupSafeRequired(MarshallerArgumentInfo argInfo);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.Marshallers.MarshallerArgumentInfo : ValueType {
    [CompilerGeneratedAttribute]
private ushort <SafeIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <UnsafeIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsByRef>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReverse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReturn>k__BackingField;
    public ushort SafeIndex { get; private set; }
    public ushort UnsafeIndex { get; private set; }
    public bool IsIn { get; private set; }
    public bool IsOut { get; private set; }
    public bool IsByRef { get; private set; }
    public bool IsReverse { get; private set; }
    public bool IsReturn { get; private set; }
    public MarshallerArgumentInfo(ushort safeIndex, ushort unsafeIndex, bool isIn, bool isOut, bool isByRef, bool isReverse, bool isReturn);
    [CompilerGeneratedAttribute]
public ushort get_SafeIndex();
    [CompilerGeneratedAttribute]
private void set_SafeIndex(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_UnsafeIndex();
    [CompilerGeneratedAttribute]
private void set_UnsafeIndex(ushort value);
    [CompilerGeneratedAttribute]
public bool get_IsIn();
    [CompilerGeneratedAttribute]
private void set_IsIn(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOut();
    [CompilerGeneratedAttribute]
private void set_IsOut(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsByRef();
    [CompilerGeneratedAttribute]
private void set_IsByRef(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReverse();
    [CompilerGeneratedAttribute]
private void set_IsReverse(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReturn();
    [CompilerGeneratedAttribute]
private void set_IsReturn(bool value);
}
internal class System.Runtime.InteropServices.Marshallers.ObjectMarshaller : Marshaller`2<object, IntPtr> {
    private static ObjectMarshaller s_instance;
    public static ObjectMarshaller Instance { get; }
    public static ObjectMarshaller get_Instance();
    public virtual void CleanupSafe(object safeValue);
    public virtual bool IsCleanupUnsafeRequired(MarshallerArgumentInfo argInfo);
    public virtual void CleanupUnsafe(IntPtr unsafeValue);
    public virtual void ToSafe(IntPtr& unsafeValue, Object& safeValue);
    public virtual void ToUnsafe(Object& safeValue, IntPtr& unsafeValue);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.Marshallers.StringToHStringMarshaller : Marshaller`2<string, IntPtr> {
    private static StringToHStringMarshaller s_instance;
    public static StringToHStringMarshaller Instance { get; }
    public static StringToHStringMarshaller get_Instance();
    public virtual void ToUnsafe(String& safeValue, IntPtr& unsafeValue);
    public virtual void ToSafe(IntPtr& unsafeValue, String& safeValue);
    public virtual void CleanupUnsafe(IntPtr unsafeValue);
    public virtual void CleanupSafe(string safeValue);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.Marshallers.StringToWStrMarshaller : Marshaller`2<string, IntPtr> {
    private static StringToWStrMarshaller s_instance;
    public static StringToWStrMarshaller Instance { get; }
    public static StringToWStrMarshaller get_Instance();
    public virtual void ToUnsafe(String& safeValue, IntPtr& unsafeValue);
    public virtual void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public virtual void ToSafe(IntPtr& unsafeValue, String& safeValue);
    public virtual void CleanupUnsafe(IntPtr unsafeValue);
    public virtual void CleanupSafe(string safeValue);
    public virtual bool IsCleanupUnsafeRequired(MarshallerArgumentInfo argInfo);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.StructMarshaller`2 : Marshaller`2<TSafe, TUnsafe> {
    private static StructMarshaller`2<TSafe, TUnsafe> s_instance;
    public static StructMarshaller`2<TSafe, TUnsafe> Instance { get; }
    public static StructMarshaller`2<TSafe, TUnsafe> get_Instance();
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(TSafe& safeValue, TUnsafe& unsafeValue);
    [__BlockReflectionAttribute]
public virtual void ToSafe(TUnsafe& unsafeValue, TSafe& safeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(TUnsafe unsafeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(TSafe safeValue);
}
internal class System.Runtime.InteropServices.Marshallers.UnsafeType__Type : ValueType {
    public HSTRING Name;
    public TypeKind Kind;
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.Marshallers.VoidMarshaller : BaseMarshaller {
    private static VoidMarshaller s_instance;
    public static VoidMarshaller Instance { get; }
    public static VoidMarshaller get_Instance();
    public virtual void ToSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public virtual void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public virtual void CleanupUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    public virtual void CleanupSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.WinRTArrayMarshaller`2 : BaseMarshaller {
    private Marshaller`2<TSafe, TUnsafe> m_elementMarshaler;
    private static WinRTArrayMarshaller`2<TSafe, TUnsafe> s_instance;
    private WinRTArrayMarshaller`2(Marshaller`2<TSafe, TUnsafe> elementMarshaler);
    public static WinRTArrayMarshaller`2<TSafe, TUnsafe> GetInstance(Marshaller`2<TSafe, TUnsafe> elementMarshaler);
    private WinRTArrayMarshalScenario GetToSafeScenario(MarshallerArgumentInfo argInfo);
    private WinRTArrayMarshalScenario GetToUnsafeScenario(MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void ToSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(LocalVariableSet safeArgs, LocalVariableSet unsafeArgs, MarshallerArgumentInfo argInfo);
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.Marshallers.WinRTArrayMarshalScenario : Enum {
    public int value__;
    public static WinRTArrayMarshalScenario None;
    public static WinRTArrayMarshalScenario Allocate;
    public static WinRTArrayMarshalScenario MarshalElements;
    public static WinRTArrayMarshalScenario AllocateAndMarshalElements;
}
internal class System.Runtime.InteropServices.Marshallers.WinRTDateTimeMarshaller : Marshaller`2<DateTimeOffset, long> {
    private static long ManagedUtcTicksAtNativeZero;
    private static WinRTDateTimeMarshaller s_instance;
    public static WinRTDateTimeMarshaller Instance { get; }
    public static WinRTDateTimeMarshaller get_Instance();
    public virtual void CleanupSafe(DateTimeOffset safeValue);
    public virtual void CleanupUnsafe(long unsafeValue);
    public virtual void ToSafe(Int64& unsafeValue, DateTimeOffset& safeValue);
    public virtual void ToUnsafe(DateTimeOffset& safeValue, Int64& unsafeValue);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.WinRTDelegateMarshaller`1 : Marshaller`2<T, IntPtr> {
    private static WinRTDelegateMarshaller`1<T> s_instance;
    public static WinRTDelegateMarshaller`1<T> Instance { get; }
    public static WinRTDelegateMarshaller`1<T> get_Instance();
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(T& safeValue, IntPtr& unsafeValue);
    [__BlockReflectionAttribute]
public virtual void ToSafe(IntPtr& unsafeValue, T& safeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(IntPtr unsafeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(T safeValue);
    [__BlockReflectionAttribute]
public virtual bool IsCleanupUnsafeRequired(MarshallerArgumentInfo argInfo);
}
internal class System.Runtime.InteropServices.Marshallers.WinRTHResultMarshaller : Marshaller`2<Exception, int> {
    private static WinRTHResultMarshaller s_instance;
    public static WinRTHResultMarshaller Instance { get; }
    public static WinRTHResultMarshaller get_Instance();
    public virtual void CleanupSafe(Exception safeValue);
    public virtual void CleanupUnsafe(int unsafeValue);
    public virtual void ToSafe(Int32& unsafeValue, Exception& safeValue);
    public virtual void ToUnsafe(Exception& safeValue, Int32& unsafeValue);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.WinRTKeyValuePairMarshaller`2 : Marshaller`2<KeyValuePair`2<K, V>, IntPtr> {
    private static WinRTKeyValuePairMarshaller`2<K, V> s_instance;
    public static WinRTKeyValuePairMarshaller`2<K, V> Instance { get; }
    public static WinRTKeyValuePairMarshaller`2<K, V> get_Instance();
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(KeyValuePair`2<K, V> safeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(IntPtr unsafeValue);
    [__BlockReflectionAttribute]
public virtual void ToSafe(IntPtr& unsafeValue, KeyValuePair`2& safeValue);
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(KeyValuePair`2& safeValue, IntPtr& unsafeValue);
}
internal class System.Runtime.InteropServices.Marshallers.WinRTNotifyCollectionChangedEventArgsMarshaller : Marshaller`2<NotifyCollectionChangedEventArgs, IntPtr> {
    private static WinRTNotifyCollectionChangedEventArgsMarshaller s_instance;
    public static WinRTNotifyCollectionChangedEventArgsMarshaller Instance { get; }
    public static WinRTNotifyCollectionChangedEventArgsMarshaller get_Instance();
    public virtual void CleanupSafe(NotifyCollectionChangedEventArgs safeValue);
    public virtual void CleanupUnsafe(IntPtr unsafeValue);
    public virtual void ToSafe(IntPtr& unsafeValue, NotifyCollectionChangedEventArgs& safeValue);
    public virtual void ToUnsafe(NotifyCollectionChangedEventArgs& safeValue, IntPtr& unsafeValue);
    public static IntPtr CreateInstanceWithAllParameters(__ComObject __this, NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex, IntPtr outer, IntPtr& inner);
}
internal class System.Runtime.InteropServices.Marshallers.WinRTPropertyChangedEventArgsMarshaller : Marshaller`2<PropertyChangedEventArgs, IntPtr> {
    private static WinRTPropertyChangedEventArgsMarshaller s_instance;
    public static WinRTPropertyChangedEventArgsMarshaller Instance { get; }
    public static WinRTPropertyChangedEventArgsMarshaller get_Instance();
    public virtual void CleanupSafe(PropertyChangedEventArgs safeValue);
    public virtual void CleanupUnsafe(IntPtr unsafeValue);
    public virtual void ToSafe(IntPtr& unsafeValue, PropertyChangedEventArgs& safeValue);
    public virtual void ToUnsafe(PropertyChangedEventArgs& safeValue, IntPtr& unsafeValue);
    public static IntPtr CreateInstance(__ComObject __this, string name, IntPtr outer, IntPtr& inner);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.Marshallers.WinRTReferenceMarshaller`1 : Marshaller`2<Nullable`1<T>, IntPtr> {
    private static WinRTReferenceMarshaller`1<T> s_instance;
    public static WinRTReferenceMarshaller`1<T> Instance { get; }
    public static WinRTReferenceMarshaller`1<T> get_Instance();
    [__BlockReflectionAttribute]
public virtual void CleanupSafe(Nullable`1<T> safeValue);
    [__BlockReflectionAttribute]
public virtual void CleanupUnsafe(IntPtr unsafeValue);
    [__BlockReflectionAttribute]
public virtual void ToSafe(IntPtr& unsafeValue, Nullable`1& safeValue);
    [__BlockReflectionAttribute]
public virtual void ToUnsafe(Nullable`1& safeValue, IntPtr& unsafeValue);
    private static PropertyType GetPropertyTypeForType(Type t);
}
internal class System.Runtime.InteropServices.Marshallers.WinRTTypeNameMarshaller : Marshaller`2<Type, UnsafeType__Type> {
    private static WinRTTypeNameMarshaller s_instance;
    public static WinRTTypeNameMarshaller Instance { get; }
    public static WinRTTypeNameMarshaller get_Instance();
    public virtual void CleanupSafe(Type safeValue);
    public virtual void CleanupUnsafe(UnsafeType__Type unsafeValue);
    public virtual void ToSafe(UnsafeType__Type& unsafeValue, Type& safeValue);
    public virtual void ToUnsafe(Type& safeValue, UnsafeType__Type& unsafeValue);
}
internal class System.Runtime.InteropServices.Marshallers.WinRTUriMarshaller : Marshaller`2<Uri, IntPtr> {
    private static WinRTUriMarshaller s_instance;
    public static WinRTUriMarshaller Instance { get; }
    public static WinRTUriMarshaller get_Instance();
    public virtual void CleanupSafe(Uri safeValue);
    public virtual void CleanupUnsafe(IntPtr unsafeValue);
    public virtual void ToSafe(IntPtr& unsafeValue, Uri& safeValue);
    public virtual void ToUnsafe(Uri& safeValue, IntPtr& unsafeValue);
}
[AttributeUsageAttribute("64")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgAccessorAttribute : Attribute {
    public McgAccessorAttribute(McgAccessorKind accessorKind, string name);
}
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.McgAccessorKind : Enum {
    public int value__;
    public static McgAccessorKind PropertyGet;
    public static McgAccessorKind PropertySet;
    public static McgAccessorKind EventAdd;
    public static McgAccessorKind EventRemove;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgAdditionalClassData : ValueType {
    public int ClassDataIndex;
    public FixupRuntimeTypeHandle FixupClassType;
    public RuntimeTypeHandle ClassType { get; }
    public RuntimeTypeHandle get_ClassType();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgBoxingData : ValueType {
    public FixupRuntimeTypeHandle FixupManagedClassType;
    public FixupRuntimeTypeHandle FixupCLRBoxingWrapperType;
    public IntPtr BoxingStub;
    public IntPtr UnboxingStub;
    public short PropertyType;
    public RuntimeTypeHandle ManagedClassType { get; }
    public RuntimeTypeHandle CLRBoxingWrapperType { get; }
    public RuntimeTypeHandle get_ManagedClassType();
    public RuntimeTypeHandle get_CLRBoxingWrapperType();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgCCWFactoryInfoEntry : ValueType {
    public FixupRuntimeTypeHandle FixupFactoryType;
    public RuntimeTypeHandle FactoryType { get; }
    public RuntimeTypeHandle get_FactoryType();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgClassData : ValueType {
    public FixupRuntimeTypeHandle FixupClassType;
    public McgClassFlags Flags;
    public FixupRuntimeTypeHandle FixupBaseClassType;
    public short BaseClassIndex;
    public FixupRuntimeTypeHandle FixupDefaultInterfaceType;
    public short DefaultInterfaceIndex;
    public RuntimeTypeHandle ClassType { get; }
    internal GCPressureRange GCPressureRange { get; }
    internal ComMarshalingType MarshalingType { get; }
    public RuntimeTypeHandle BaseClassType { get; }
    public RuntimeTypeHandle DefaultInterfaceType { get; }
    public RuntimeTypeHandle get_ClassType();
    internal GCPressureRange get_GCPressureRange();
    internal ComMarshalingType get_MarshalingType();
    public RuntimeTypeHandle get_BaseClassType();
    public RuntimeTypeHandle get_DefaultInterfaceType();
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.McgClassFlags : Enum {
    public int value__;
    public static McgClassFlags None;
    public static McgClassFlags MarshalingBehavior_Inhibit;
    public static McgClassFlags MarshalingBehavior_Free;
    public static McgClassFlags MarshalingBehavior_Standard;
    public static McgClassFlags MarshalingBehavior_Mask;
    public static McgClassFlags GCPressureRange_WinRT_Default;
    public static McgClassFlags GCPressureRange_WinRT_Low;
    public static McgClassFlags GCPressureRange_WinRT_Medium;
    public static McgClassFlags GCPressureRange_WinRT_High;
    public static McgClassFlags GCPressureRange_Mask;
    public static McgClassFlags NotComObject;
    public static McgClassFlags IsSealed;
    public static McgClassFlags IsWinRT;
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgCollectionData : ValueType {
    public FixupRuntimeTypeHandle FixupCollectionType;
    public FixupRuntimeTypeHandle FixupFirstType;
    public FixupRuntimeTypeHandle FixupSecondType;
    public RuntimeTypeHandle CollectionType { get; }
    public RuntimeTypeHandle FirstType { get; }
    public RuntimeTypeHandle SecondType { get; }
    public RuntimeTypeHandle get_CollectionType();
    public RuntimeTypeHandle get_FirstType();
    public RuntimeTypeHandle get_SecondType();
}
[AttributeUsageAttribute("4108")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgComCallableAttribute : Attribute {
}
internal static class System.Runtime.InteropServices.McgComHelpers : object {
    internal static string GetRuntimeClassName(object obj);
    internal static string GetRuntimeClassName(IntPtr pWinRTItf);
    internal static bool SeekStreamToBeginning(IntPtr pStream);
    internal static bool SetStreamSize(IntPtr pStream, ulong lSize);
    internal static void SafeReleaseStream(IntPtr pStream);
    internal static bool IsFreeThreaded(IntPtr pUnknown);
    internal static Void* CachedAlloc(int size, IntPtr& cache);
    internal static void CachedFree(Void* block, IntPtr& cache);
    internal static object UnboxManagedWrapperIfBoxed(object target);
    internal static object ComInterfaceToComObject(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSigature, ContextCookie expectedContext, CreateComObjectFlags flags);
    internal static object ComInterfaceToComObjectInternal(IntPtr pComItf, IntPtr pComIdentityIUnknown, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, ContextCookie expectedContext, CreateComObjectFlags flags);
    private static object ComInterfaceToComObjectInternal_NoCache(IntPtr pComItf, IntPtr pComIdentityIUnknown, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, ContextCookie expectedContext, CreateComObjectFlags flags, String& className);
    internal static __ComGenericInterfaceDispatcher CreateGenericComDispatcher(RuntimeTypeHandle genericDispatcherDef, RuntimeTypeHandle[] genericArguments, __ComObject comThisPointer);
    private static __ComObject CreateComObjectInternal(RuntimeTypeHandle classType, IntPtr pComItf);
    internal static object ComInterfaceToObjectInternal(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, CreateComObjectFlags flags);
    private static object ComInterfaceToObjectInternal_NoManagedUnboxing(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature, CreateComObjectFlags flags);
    internal static IntPtr ObjectToComInterfaceInternal(object obj, RuntimeTypeHandle typeHnd);
    internal static IntPtr ManagedObjectToComInterface(object obj, RuntimeTypeHandle interfaceType);
    internal static IntPtr ManagedObjectToComInterface(object obj, Guid& iid);
    private static IntPtr ManagedObjectToComInterfaceInternal(object obj, Guid& iid, RuntimeTypeHandle interfaceType);
}
[AttributeUsageAttribute("1")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgGeneratedAssemblyAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgGeneratedMarshallingCodeAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgGenericArgumentMarshalInfo : ValueType {
    public UInt32 ElementSize;
    public FixupRuntimeTypeHandle FixupElementClassType;
    public FixupRuntimeTypeHandle FixupElementInterfaceType;
    public FixupRuntimeTypeHandle FixupAsyncOperationType;
    public FixupRuntimeTypeHandle FixupIteratorType;
    public FixupRuntimeTypeHandle FixupVectorViewType;
    public RuntimeTypeHandle AsyncOperationType { get; }
    public RuntimeTypeHandle ElementClassType { get; }
    public RuntimeTypeHandle ElementInterfaceType { get; }
    public RuntimeTypeHandle IteratorType { get; }
    public RuntimeTypeHandle VectorViewType { get; }
    public RuntimeTypeHandle get_AsyncOperationType();
    public RuntimeTypeHandle get_ElementClassType();
    public RuntimeTypeHandle get_ElementInterfaceType();
    public RuntimeTypeHandle get_IteratorType();
    public RuntimeTypeHandle get_VectorViewType();
}
internal class System.Runtime.InteropServices.McgGuid : ValueType {
    public UInt32 a;
    public ushort b;
    public ushort c;
    public byte d0;
    public byte d1;
    public byte d2;
    public byte d3;
    public byte d4;
    public byte d5;
    public byte d6;
    public byte d7;
    public McgGuid(Guid g);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgHashcodeVerifyEntry : ValueType {
    public FixupRuntimeTypeHandle FixupTypeHandle;
    public UInt32 HashCode;
    public RuntimeTypeHandle TypeHandle { get; }
    public RuntimeTypeHandle get_TypeHandle();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgInterfaceData : ValueType {
    public FixupRuntimeTypeHandle FixupItfType;
    public FixupRuntimeTypeHandle FixupDispatchClassType;
    public FixupRuntimeTypeHandle FixupDynamicAdapterClassType;
    public Guid ItfGuid;
    public McgInterfaceFlags Flags;
    public short MarshalIndex;
    public IntPtr CcwVtable;
    public IntPtr DelegateInvokeStub;
    public RuntimeTypeHandle ItfType { get; public set; }
    public RuntimeTypeHandle DispatchClassType { get; }
    public RuntimeTypeHandle DynamicAdapterClassType { get; }
    internal bool IsIInspectable { get; }
    internal bool IsIInspectableOrDelegate { get; }
    public RuntimeTypeHandle get_ItfType();
    public void set_ItfType(RuntimeTypeHandle value);
    public RuntimeTypeHandle get_DispatchClassType();
    public RuntimeTypeHandle get_DynamicAdapterClassType();
    internal bool get_IsIInspectable();
    internal bool get_IsIInspectableOrDelegate();
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.McgInterfaceFlags : Enum {
    public byte value__;
    public static McgInterfaceFlags None;
    public static McgInterfaceFlags isIInspectable;
    public static McgInterfaceFlags isDelegate;
    public static McgInterfaceFlags isInternal;
    public static McgInterfaceFlags useSharedCCW;
    public static McgInterfaceFlags SharedCCWMask;
    public static McgInterfaceFlags useSharedCCW_IVector;
    public static McgInterfaceFlags useSharedCCW_IVectorView;
    public static McgInterfaceFlags useSharedCCW_IIterable;
    public static McgInterfaceFlags useSharedCCW_IIterator;
    public static McgInterfaceFlags useSharedCCW_AsyncOperationCompletedHandler;
    public static McgInterfaceFlags useSharedCCW_IVectorBlittable;
    public static McgInterfaceFlags useSharedCCW_IVectorViewBlittable;
    public static McgInterfaceFlags useSharedCCW_IIteratorBlittable;
}
[AttributeUsageAttribute("4")]
internal class System.Runtime.InteropServices.McgInternalTypeAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class System.Runtime.InteropServices.McgIntrinsicsAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.McgMarshal : object {
    public static void SaveLastWin32Error();
    public static void ClearLastWin32Error();
    public static bool GuidEquals(Guid& left, Guid& right);
    public static bool ComparerEquals(T left, T right);
    public static T CreateClass();
    public static bool IsEnum(object obj);
    public static bool IsComObject(Type type);
    internal static bool IsComObject(object obj);
    public static T FastCast(object value);
    public static double ToNativeOleDate(DateTime dateTime);
    public static DateTime FromNativeOleDate(double nativeOleDate);
    public static void InitializeHandle(SafeHandle safeHandle, IntPtr win32Handle);
    public static bool IsOfType(object obj, RuntimeTypeHandle handle);
    public static void SetExceptionErrorCode(Exception exception, int errorCode);
    public static IntPtr GetHandle(CriticalHandle criticalHandle);
    public static void SetHandle(CriticalHandle criticalHandle, IntPtr handle);
    public static Type TypeNameToType(HSTRING nativeTypeName, int nativeTypeKind);
    internal static Type TypeNameToType(string nativeTypeName, int nativeTypeKind);
    public static void TypeToTypeName(Type type, HSTRING& nativeTypeName, Int32& nativeTypeKind);
    internal static string TypeToTypeName(RuntimeTypeHandle typeHandle, Int32& nativeTypeKind);
    [CLSCompliantAttribute("False")]
public static void StringBuilderToUnicodeString(StringBuilder stringBuilder, UInt16* destination);
    [CLSCompliantAttribute("False")]
public static void UnicodeStringToStringBuilder(UInt16* newBuffer, StringBuilder stringBuilder);
    [CLSCompliantAttribute("False")]
public static void StringBuilderToAnsiString(StringBuilder stringBuilder, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void AnsiStringToStringBuilder(Byte* newBuffer, StringBuilder stringBuilder);
    [CLSCompliantAttribute("False")]
public static string AnsiStringToString(Byte* pchBuffer);
    [CLSCompliantAttribute("False")]
public static Byte* StringToAnsiString(string str, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void ByValWideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, int expectedCharCount, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void ByValAnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    [CLSCompliantAttribute("False")]
public static void WideCharArrayToAnsiCharArray(Char[] managedArray, Byte* pNative, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static void AnsiCharArrayToWideCharArray(Byte* pNative, Char[] managedArray);
    public static byte WideCharToAnsiChar(char managedValue, bool bestFit, bool throwOnUnmappableChar);
    public static char AnsiCharToWideChar(byte nativeValue);
    [CLSCompliantAttribute("False")]
public static void StringToByValAnsiString(string str, Byte* pNative, int charCount, bool bestFit, bool throwOnUnmappableChar);
    [CLSCompliantAttribute("False")]
public static string ByValAnsiStringToString(Byte* pchBuffer, int charCount);
    public static Void* CoTaskMemAllocAndZeroMemory(IntPtr size);
    public static void SafeCoTaskMemFree(IntPtr allocatedMemory);
    public static void SafeCoTaskMemFree(Void* pv);
    public static Void* AllocUnicodeBuffer(string source);
    public static void CopyUnicodeString(string source, Void* _dest);
    public static UInt16* ConvertStringToBSTR(UInt16* ptrToFirstCharInBSTR, string strManaged);
    public static string ConvertBSTRToString(UInt16* bstr);
    public static void SysFreeString(Void* pBSTR);
    public static void SysFreeString(IntPtr pBSTR);
    public static HSTRING StringToHString(string sourceString);
    public static HSTRING StringToHStringForField(string sourceString);
    private static HSTRING StringToHStringInternal(string sourceString);
    internal static int StringToHStringNoNullCheck(string sourceString, HSTRING* hstring);
    [CLSCompliantAttribute("False")]
public static int AddRef(__ComObject obj);
    [CLSCompliantAttribute("False")]
public static int Release(__ComObject obj);
    public static int ComAddRef(IntPtr pComItf);
    internal static int ComRelease_StdCall(IntPtr pComItf);
    public static int ComRelease(IntPtr pComItf);
    public static int ComSafeRelease(IntPtr pComItf);
    public static int FinalReleaseComObject(object o);
    [CLSCompliantAttribute("False")]
public static __ComObject GetActivationFactory(string className, RuntimeTypeHandle factoryIntf);
    public static object ThisPointerToTargetObject(IntPtr pUnk);
    [CLSCompliantAttribute("False")]
public static object ComInterfaceToObject_NoUnboxing(IntPtr pComItf, RuntimeTypeHandle interfaceType);
    [CLSCompliantAttribute("False")]
public static object ComInterfaceToObject(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature);
    [CLSCompliantAttribute("False")]
public static object ComInterfaceToObject(IntPtr pComItf, RuntimeTypeHandle interfaceType);
    private static object ComInterfaceToObjectInternal(IntPtr pComItf, RuntimeTypeHandle interfaceType, RuntimeTypeHandle classTypeInSignature);
    public static IntPtr ComQueryInterfaceNoThrow(IntPtr pComItf, Guid& iid);
    public static IntPtr ComQueryInterfaceNoThrow(IntPtr pComItf, Guid& iid, Int32& hr);
    internal static int ComQueryInterfaceWithHR(IntPtr pComItf, Guid& iid, IntPtr& ppv);
    public static IntPtr GetCCWVTableCopy(Void* pVtbl, IntPtr& pNativeVtbl, int size);
    [CLSCompliantAttribute("False")]
public static IntPtr ObjectToComInterface(object obj, RuntimeTypeHandle typeHnd);
    public static IntPtr ObjectToIInspectable(object obj);
    private static bool DelegateTargetMethodEquals(Delegate del, IntPtr pfn);
    public static IntPtr DelegateToComInterface(Delegate del, RuntimeTypeHandle typeHnd);
    public static Delegate ComInterfaceToDelegate(IntPtr pComItf, RuntimeTypeHandle typeHnd);
    public static void ObjectArrayToComInterfaceArray(UInt32 len, IntPtr* dst, Object[] src, RuntimeTypeHandle typeHnd);
    public static IntPtr* ObjectArrayToComInterfaceArrayAlloc(Object[] src, RuntimeTypeHandle typeHnd, UInt32& len);
    [CLSCompliantAttribute("False")]
public static IntPtr GetOuterIInspectableForManagedObject(__ComObject managedObject);
    [CLSCompliantAttribute("False")]
public static IntPtr ManagedObjectToComInterface(object obj, RuntimeTypeHandle interfaceType);
    public static object IInspectableToObject(IntPtr pComItf);
    public static IntPtr CoCreateInstanceEx(Guid clsid, string server);
    public static IntPtr CoCreateInstanceEx(Guid clsid);
    public static void ReleaseRCWsInCurrentApartment();
    public static int GetTotalComObjectCount();
    public static IEnumerable`1<__ComObject> GetAllComObjects();
    public static bool PropagateException(Exception ex);
    public static int GetHRForExceptionWinRT(Exception ex);
    public static int GetHRForException(Exception ex);
    public static void ThrowOnExternalCallFailed(int hr, RuntimeTypeHandle typeHnd);
    public static Exception GetExceptionForHR(int hr, bool isWinRTScenario);
    public static void CleanupNative(IntPtr pObject);
    public static IntPtr ActivateInstance(string typeName);
    public static IntPtr GetInterface(__ComObject obj, RuntimeTypeHandle typeHnd);
    public static object GetDynamicAdapter(__ComObject obj, RuntimeTypeHandle requestedType, RuntimeTypeHandle existingType);
    public static object GetDynamicAdapter(__ComObject obj, RuntimeTypeHandle requestedType);
    public static IntPtr GetStubForPInvokeDelegate(RuntimeTypeHandle delegateType, Delegate dele);
    public static Delegate GetPInvokeDelegateForStub(IntPtr pStub, RuntimeTypeHandle delegateType);
    public static IntPtr GetCurrentCalleeOpenStaticDelegateFunctionPointer();
    public static T GetCurrentCalleeDelegate();
    public static object UnboxIfBoxed(object target);
    public static object UnboxIfBoxed(object target, string className);
    internal static object BoxIfBoxable(object target);
    internal static object BoxIfBoxable(object target, RuntimeTypeHandle typeHandleOverride);
    public static void StringToHStringReference(Char* pchPinnedSourceString, string sourceString, HSTRING_HEADER* pHeader, HSTRING* phString);
    internal static string HStringToString(IntPtr hString);
    public static string HStringToString(HSTRING pHString);
    public static void FreeHString(IntPtr pHString);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public abstract class System.Runtime.InteropServices.McgModule : object {
    private int m_mcgDataModulePriority;
    private StringPool m_stringPool;
    private McgInterfaceData[] m_interfaceData;
    private CCWTemplateData[] m_ccwTemplateData;
    private RuntimeTypeHandle[] m_supportedInterfaceList;
    private McgClassData[] m_classData;
    private McgBoxingData[] m_boxingData;
    private McgAdditionalClassData[] m_additionalClassData;
    private McgCollectionData[] m_collectionData;
    private McgPInvokeDelegateData[] m_pinvokeDelegateData;
    private McgCCWFactoryInfoEntry[] m_ccwFactories;
    private McgStructMarshalData[] m_structMarshalData;
    private McgUnsafeStructFieldOffsetData[] m_unsafeStructOffsetData;
    private McgGenericArgumentMarshalInfo[] m_genericArgumentMarshalInfo;
    private McgHashcodeVerifyEntry[] m_hashcodeVerifyData;
    private FixedHashTable m_guidMap;
    public static RuntimeTypeHandle s_DependencyReductionTypeRemovedTypeHandle;
    private StringMap m_interfaceNameMap;
    private StringMap m_classNameMap;
    private StringMap m_additionalClassNameMap;
    private StringMap m_ccwTemplateDataNameMap;
    private StringMap m_ccwFactoriesNameMap;
    private StringMap m_boxingDataNameMap;
    private StringMap m_typeNameMarshalingDataNameMap;
    private StringMap m_unsafeStructFieldNameMap;
    private StringMap m_unsafeStructDataNameMap;
    private static Guid s_IID_IClassFactory;
    private static Guid s_IID_IActivationFactory;
    public int ModulePriority { get; }
    public McgModule(int mcgDataModulePriority, McgInterfaceData[] interfaceData, CCWTemplateData[] ccwTemplateData, FixupRuntimeTypeHandle[] supportedInterfaceList, McgClassData[] classData, McgBoxingData[] boxingData, McgAdditionalClassData[] additionalClassData, McgCollectionData[] collectionData, McgPInvokeDelegateData[] pinvokeDelegateData, McgCCWFactoryInfoEntry[] ccwFactories, McgStructMarshalData[] structMarshalData, McgUnsafeStructFieldOffsetData[] unsafeStructFieldOffsetData, McgGenericArgumentMarshalInfo[] genericArgumentMarshalInfo, McgHashcodeVerifyEntry[] hashcodeVerifyData);
    private static McgModule();
    public int get_ModulePriority();
    private NativeReader NewHashtableReader(Byte[] dataArray);
    public void SetThunk(int index, IntPtr thunk);
    public void SetStringPool(Byte[] dictionary, Byte[] strings, UInt16[] index);
    public void SetinterfaceDataNameIndices(UInt16[] nameIndices);
    public void SetclassDataNameIndices(UInt16[] nameIndices);
    public void SetadditionalClassDataNameIndices(UInt16[] nameIndices);
    public void SetccwFactoriesNameIndices(UInt16[] nameIndices);
    public void SetccwTemplateDataNameIndices(UInt16[] nameIndices);
    public void SetboxingDataNameIndices(UInt16[] nameIndices);
    public void SettypeNameMarshalingDataNameIndices(UInt16[] nameIndices);
    public void SetinterfaceDataNameIndices(UInt32[] nameIndices);
    public void SetclassDataNameIndices(UInt32[] nameIndices);
    public void SetadditionalClassDataNameIndices(UInt32[] nameIndices);
    public void SetccwFactoriesNameIndices(UInt32[] nameIndices);
    public void SetccwTemplateDataNameIndices(UInt32[] nameIndices);
    public void SetboxingDataNameIndices(UInt32[] nameIndices);
    public void SettypeNameMarshalingDataNameIndices(UInt32[] nameIndices);
    public void SetstructMarshalDataNameIndices(UInt16[] nameIndices);
    public void SetstructMarshalDataNameIndices(UInt32[] nameIndices);
    public void SetunsafeStructFieldOffsetDataNameIndices(UInt16[] nameIndices);
    public void SetunsafeStructFieldOffsetDataNameIndices(UInt32[] nameIndices);
    internal bool TryGetCCWRuntimeClassName(int slot, String& ccwRuntimeClassName);
    internal bool TryGetStructFieldOffset(McgStructMarshalData structMarshalData, string fieldName, UInt32& offset);
    internal McgInterfaceData[] GetAllInterfaceData();
    internal CCWTemplateData[] GetAllCCWTemplateData();
    internal McgClassData[] GetAllClassData();
    internal McgCollectionData[] GetAllCollectionData();
    internal McgBoxingData[] GetAllBoxingData();
    internal int GetInterfaceDataCount();
    internal int GetCCWTemplateDataCount();
    internal int GetClassDataCount();
    internal int GetCollectionDataCount();
    internal int GetBoxingDataCount();
    internal RuntimeTypeHandle GetTypeFromGuid(Guid& guid);
    internal bool TryGetInterfaceTypeNameByIndex(int slot, String& name);
    internal bool TryGetClassTypeNameByIndex(int slot, String& name);
    internal Type GetTypeFromName(string name, Boolean& isWinRT);
    internal bool TryGetClassFromNameInClassData(string name, RuntimeTypeHandle& classType);
    internal bool TryGetClassFromNameInAdditionalClassData(string name, RuntimeTypeHandle& classType);
    private RuntimeTypeHandle ComputeClosestClassForClassIndex(int index);
    internal bool TryGetInterfaceTypeFromName(string name, RuntimeTypeHandle& interfaceType);
    internal McgInterfaceData GetInterfaceDataByIndex(int index);
    internal McgClassData GetClassDataByIndex(int index);
    internal CCWTemplateData GetCCWTemplateDataByIndex(int index);
    internal McgCollectionData GetCollectionDataByIndex(int index);
    internal McgBoxingData GetBoxingDataByIndex(int index);
    internal bool TryGetUnboxingStub(string className, IntPtr& unboxingStub);
    internal bool TryGetPInvokeDelegateData(RuntimeTypeHandle typeHandle, McgPInvokeDelegateData& pinvokeDelegateData);
    internal bool TryGetStructMarshalData(RuntimeTypeHandle structTypeHandle, McgStructMarshalData& structMarshalData);
    internal bool TryGetStructWinRTName(RuntimeTypeHandle structTypeHandle, String& structWinRTName);
    internal RuntimeTypeHandle FindTypeSupportDynamic(Func`2<RuntimeTypeHandle, bool> predicate);
    internal bool TryGetBaseType(int ccwTemplateIndex, RuntimeTypeHandle& baseType);
    internal bool TryGetImplementedInterfaces(int ccwTemplateIndex, IEnumerable`1& interfaces);
    internal bool TryGetIsWinRTType(int ccwTemplateIndex, Boolean& isWinRTType);
    internal bool TryGetTypeHandleForICollecton(int slot, RuntimeTypeHandle& firstTypeHandle, RuntimeTypeHandle& secondTypeHandle);
    internal bool TryGetGenericArgumentMarshalInfo(int slot, McgGenericArgumentMarshalInfo& mcgGenericArgumentMarshalInfo);
    public int DllGetClassObjectImpl(Guid rclsid, Guid riid, IntPtr* ppv);
    public int GetCCWActivationFactory(HSTRING activatableClassId, RuntimeTypeHandle itfType, IntPtr* factoryOut);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.McgModuleManager : object {
    internal static int NUM_BITS_FOR_MAX_MODULES;
    internal static int MAX_MODULES;
    private static McgModule[] s_modules;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_moduleCount;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToInterfaceIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToCCWTemplateIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToClassIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToCollectionIndexMap;
    private static Dictionary`2<RuntimeTypeHandle, int> s_runtimeTypeHandleToBoxingIndexMap;
    private static InternalModule s_internalModule;
    [CompilerGeneratedAttribute]
private static bool <UseDynamicInterop>k__BackingField;
    public static bool UseDynamicInterop { get; public set; }
    internal static void Initialize();
    [CompilerGeneratedAttribute]
public static bool get_UseDynamicInterop();
    [CompilerGeneratedAttribute]
public static void set_UseDynamicInterop(bool value);
    public static void Register(McgModule module);
    private static void Add(McgModule module);
    private static void InsertDataIntoDictionary(Dictionary`2<RuntimeTypeHandle, int> map, RuntimeTypeHandle typeHandle, int moduleIndex, int typeIndex);
    public static void LateInitialize();
    internal static bool TryGetClassTypeFromName(string name, RuntimeTypeHandle& classType);
    internal static bool TryGetInterfaceTypeFromName(string name, RuntimeTypeHandle& interfaceType);
    internal static string GetTypeName(RuntimeTypeHandle type, Boolean& isWinRT);
    internal static Type GetTypeFromName(string name, Boolean& isWinRT);
    internal static IEnumerable`1<RuntimeTypeHandle> GetTypesFromGuid(Guid& guid);
    private static bool GetIndicesFromMap(Dictionary`2<RuntimeTypeHandle, int> map, RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& typeIndex);
    internal static bool GetIndicesForInterface(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& interfaceIndex);
    internal static bool GetIndicesForClass(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& classIndex);
    internal static bool GetIndicesForCCWTemplate(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& ccwTemplateIndex);
    internal static bool GetIndicesForCollection(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& collecitonIndex);
    internal static bool GetIndicesForBoxing(RuntimeTypeHandle typeHandle, Int32& moduleIndex, Int32& boxingIndex);
    internal static McgInterfaceData GetInterfaceDataByIndex(int moduleIndex, int interfaceIndex);
    internal static McgClassData GetClassDataByIndex(int moduleIndex, int classIndex);
    internal static CCWTemplateData GetCCWTemplateDataByIndex(int moduleIndex, int ccwTemplateIndex);
    internal static IEnumerable`1<RuntimeTypeHandle> GetImplementedInterfacesByIndex(int moduleIndex, int ccwTemplateIndex);
    internal static bool TryGetTypeHandleForICollecton(RuntimeTypeHandle interfaceTypeHandle, RuntimeTypeHandle& firstTypeHandle, RuntimeTypeHandle& secondTypeHandle);
    internal static RuntimeTypeHandle FindTypeSupportDynamic(Func`2<RuntimeTypeHandle, bool> predicate);
    internal static bool TryGetCCWRuntimeClassName(RuntimeTypeHandle ccwTypeHandle, String& ccwRuntimeClassName);
    internal static bool TryGetBaseType(RuntimeTypeHandle ccwType, RuntimeTypeHandle& baseType);
    internal static bool TryGetImplementedInterfaces(RuntimeTypeHandle ccwType, IEnumerable`1& interfaces);
    internal static bool TryGetIsWinRTType(RuntimeTypeHandle ccwType, Boolean& isWinRTType);
    internal static bool TryGetStructUnsafeStructType(RuntimeTypeHandle structureTypeHandle, RuntimeTypeHandle& unsafeStructType);
    internal static bool TryGetStructUnmarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& unmarshalStub);
    internal static bool TryGetStructMarshalStub(RuntimeTypeHandle structureTypeHandle, IntPtr& marshalStub);
    internal static bool TryGetDestroyStructureStub(RuntimeTypeHandle structureTypeHandle, IntPtr& destroyStructureStub, Boolean& hasInvalidLayout);
    internal static bool TryGetStructMarshalData(RuntimeTypeHandle structureTypeHandle, McgStructMarshalData& structMarshalData);
    internal static bool TryGetStructWinRTName(RuntimeTypeHandle structTypeHandle, String& structWinRTName);
    internal static bool TryGetStructFieldOffset(RuntimeTypeHandle structureTypeHandle, string fieldName, Boolean& structExists, UInt32& offset);
    internal static bool TryGetBoxingWrapperType(RuntimeTypeHandle typeHandle, object target, RuntimeTypeHandle& boxingWrapperType, Int32& boxingPropertyType, IntPtr& boxingStub);
    internal static bool TryGetUnboxingStub(string className, IntPtr& unboxingStub);
    internal static bool GetPInvokeDelegateData(RuntimeTypeHandle delegateType, McgPInvokeDelegateData& pinvokeDelegateData);
    internal static bool TryGetGenericArgumentMarshalInfo(RuntimeTypeHandle interfaceType, McgGenericArgumentMarshalInfo& mcgGenericArgumentMarshalInfo);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgPInvokeDelegateData : ValueType {
    public FixupRuntimeTypeHandle FixupDelegate;
    public IntPtr ReverseStub;
    public IntPtr ReverseOpenStaticDelegateStub;
    public IntPtr ForwardDelegateCreationStub;
    public RuntimeTypeHandle Delegate { get; }
    public RuntimeTypeHandle get_Delegate();
}
[AttributeUsageAttribute("64")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgPInvokeMarshalStubAttribute : Attribute {
    public McgPInvokeMarshalStubAttribute(string assemblyName, string typeName, string methodName);
}
[AttributeUsageAttribute("64")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgRedirectedMethodAttribute : Attribute {
    public McgRedirectedMethodAttribute(string assemblyQualifiedTypeName, string methodName);
}
[AttributeUsageAttribute("5148")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgRedirectedTypeAttribute : Attribute {
    public McgRedirectedTypeAttribute(string assemblyQualifiedTypeName);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgRemovedType : object {
}
[AttributeUsageAttribute("8")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgRootsTypeAttribute : Attribute {
    public McgRootsTypeAttribute(Type rootedType);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgStructMarshalData : ValueType {
    public FixupRuntimeTypeHandle FixupSafeStructType;
    public FixupRuntimeTypeHandle FixupUnsafeStructType;
    public IntPtr MarshalStub;
    public IntPtr UnmarshalStub;
    public IntPtr DestroyStructureStub;
    public McgStructMarshalFlags Flags;
    public int FieldOffsetStartIndex;
    public int NumOfFields;
    public RuntimeTypeHandle SafeStructType { get; }
    public RuntimeTypeHandle UnsafeStructType { get; }
    public bool HasInvalidLayout { get; }
    public RuntimeTypeHandle get_SafeStructType();
    public RuntimeTypeHandle get_UnsafeStructType();
    public bool get_HasInvalidLayout();
}
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.McgStructMarshalFlags : Enum {
    public int value__;
    public static McgStructMarshalFlags None;
    public static McgStructMarshalFlags HasInvalidLayout;
}
internal static class System.Runtime.InteropServices.McgTypeHelpers : object {
    private static Type[] s_wellKnownTypes;
    private static String[] s_wellKnownTypeNames;
    private static string PseudonymPrefix;
    private static Dictionary`2<string, Type> s_fakeTypeMap;
    private static Lock s_fakeTypeMapLock;
    private static Dictionary`2<RuntimeTypeHandle, Type> s_realToFakeTypeMap;
    private static McgTypeHelpers();
    internal static void TypeToTypeName(Type type, HSTRING& nativeTypeName, Int32& nativeTypeKind);
    internal static bool IsWinRTPrimitiveType(RuntimeTypeHandle typeHandle, String& typeName);
    internal static bool IsWinRTPrimitiveType(string typeName, RuntimeTypeHandle& typeHandle);
    internal static void TypeToTypeName(RuntimeTypeHandle typeHandle, String& typeName, TypeKind& typeKind);
    internal static Type GetReflectableOrFakeType(Type realType);
    internal static Type GetTypeByName(string typeName);
    internal static Type TypeNameToType(HSTRING nativeTypeName, int nativeTypeKind);
    internal static Type TypeNameToType(string name, int nativeTypeKind, bool checkTypeKind);
    private static string GetCustomTypeName(RuntimeTypeHandle type);
    private static string GetPseudonymForType(RuntimeTypeHandle type, bool useFake);
    private static Type StringToCustomType(string s);
    public static string GetDiagnosticMessageForMissingType(RuntimeTypeHandle interfaceType);
    private static string ConstructGenericTypeFullName(string genericTypeDefinitionFullName, String[] genericTypeArguments);
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgTypeNameMarshalingData : ValueType {
    public FixupRuntimeTypeHandle FixupClassType;
    public RuntimeTypeHandle ClassType { get; }
    public RuntimeTypeHandle get_ClassType();
}
[CLSCompliantAttribute("False")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgUnsafeStructFieldOffsetData : ValueType {
    public UInt32 Offset;
}
[AttributeUsageAttribute("5148")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.McgWindowsRuntimeVersionAttribute : Attribute {
    public McgWindowsRuntimeVersionAttribute(int version);
}
internal class System.Runtime.InteropServices.Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class System.Runtime.InteropServices.Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class System.Runtime.InteropServices.Microsoft.Win32.SafeHandles.SafeBCryptHashHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal class System.Runtime.InteropServices.MissingInteropDataException : Exception {
    [CompilerGeneratedAttribute]
private Type <MissingType>k__BackingField;
    public Type MissingType { get; private set; }
    public MissingInteropDataException(string resourceFormat, Type pertainantType);
    [CompilerGeneratedAttribute]
public Type get_MissingType();
    [CompilerGeneratedAttribute]
private void set_MissingType(Type value);
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    public string get_Value();
}
internal static class System.Runtime.InteropServices.Projection : object {
    private static ProjectionType[] s_ProjectionType;
    private static Projection();
    public static bool IsProjectionType(RuntimeTypeHandle typeHandle);
    public static bool IsProjectionType(RuntimeTypeHandle typeHandle, String& winrtTypeName);
    public static bool IsManagedClassThatGetsProjectedToWinRTStruct(RuntimeTypeHandle typeHandle);
    public static bool IsManagedStructThatGetsProjectedToWinRTInterface(RuntimeTypeHandle typeHandle);
    public static bool IsProjectedManagedType_IgnoringGenericArgs(RuntimeTypeHandle typeHandle, String& winrtTypeName);
    public static bool IsProjectedManagedType(string winrtTypeName, RuntimeTypeHandle& typeHandle);
    public static bool IsProjectedManagedType_IgnoringGenericArgs(RuntimeTypeHandle typeHandle);
}
internal class System.Runtime.InteropServices.ProjectionType : object {
    private RuntimeTypeHandle m_managedTypeHandle;
    private ProjectionTypeKind m_managedTypeKind;
    private ProjectionTypeKind m_nativeTypeKind;
    private string m_nativeTypeName;
    public RuntimeTypeHandle ManagedType { get; }
    public ProjectionTypeKind ManagedTypeKind { get; }
    public ProjectionTypeKind NativeTypeKind { get; }
    public string NativeTypeName { get; }
    internal ProjectionType(string fullNativeTypeName, string fullManagedTypeName, string assemblyName, ProjectionTypeKind managedTypeKind, ProjectionTypeKind nativeTypeKind);
    internal ProjectionType(string fullNativeTypeName, Type fullManagedType, ProjectionTypeKind managedTypeKind, ProjectionTypeKind nativeTypeKind);
    public RuntimeTypeHandle get_ManagedType();
    public ProjectionTypeKind get_ManagedTypeKind();
    public ProjectionTypeKind get_NativeTypeKind();
    public string get_NativeTypeName();
}
internal enum System.Runtime.InteropServices.ProjectionTypeKind : Enum {
    public int value__;
    public static ProjectionTypeKind EnumType;
    public static ProjectionTypeKind ClassType;
    public static ProjectionTypeKind StructType;
    public static ProjectionTypeKind InterfaceType;
    public static ProjectionTypeKind DelegateType;
}
internal static class System.Runtime.InteropServices.RCWWalker : object {
    private static DependentHandleList s_dependentHandleList;
    private static IntPtr modreq(System.Runtime.CompilerServices.IsVolatile) s_pGCManager;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_bInitialized;
    private static bool s_globalPeggingOn;
    private static bool s_gcStarted;
    private static __com_ICLRServices s_clrServices;
    private static __com_IFindDependentWrappers s_findDependentWrapperCallbackObject;
    internal static __ComObject s_currentComObjectToWalk;
    internal static bool IsGlobalPeggingOn { get; }
    private static RCWWalker();
    [GCCallbackAttribute]
internal static bool get_IsGlobalPeggingOn();
    private static void Initialize(__com_IJupiterObject* pJupiterObject);
    [GCCallbackAttribute]
private static void InitializeImpl();
    internal static void OnJupiterRCWCreated(__ComObject comObject);
    internal static void AfterJupiterRCWCreated(__ComObject comObject);
    internal static void AfterAddRef(__ComObject comObject);
    internal static void BeforeRelease(__ComObject comObject);
    [GCCallbackAttribute]
internal static bool WalkRCWs();
    [GCCallbackAttribute]
internal static bool WalkOneRCW(__ComObject comObject);
    [GCCallbackAttribute]
internal static void LogRCWs();
    [GCCallbackAttribute]
internal static __com_IFindDependentWrappers* GetDependentWrapperCallbackObject();
    [GCCallbackAttribute]
internal static int OnDependentWrapperCallback(ComCallableObject ccw);
    [GCCallbackAttribute]
internal static int AfterMarkPhase(int nCondemnedGeneration);
    [GCCallbackAttribute]
internal static int OnGCStarted(int nCondemnedGeneration);
    [GCCallbackAttribute]
private static bool NeedToWalkRCWs();
    [GCCallbackAttribute]
internal static void OnGCStartedWorker();
    [GCCallbackAttribute]
internal static int OnGCFinished(int nCondemnedGeneration);
    [GCCallbackAttribute]
private static void OnGCFinishedWorker();
}
internal class System.Runtime.InteropServices.ReverseCOMCallInterceptor : InteropCallInterceptor {
    private IntPtr m_safeTargetAddress;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_safeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ReverseCOMCallInterceptor(IntPtr safeTargetAddress, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
internal class System.Runtime.InteropServices.ReversePInvokeCallInterceptor : InteropCallInterceptor {
    private IntPtr m_safeTargetAddress;
    private object m_safeFirstArgument;
    private CallingConvention m_unsafeTargetCallingConvention;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_safeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ReversePInvokeCallInterceptor(IntPtr delegateFunctionPointer, object delegateFirstArgument, CallingConvention unsafeTargetCallingConvention, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
internal class System.Runtime.InteropServices.ReverseWinRTCallInterceptor : InteropCallInterceptor {
    private IntPtr m_safeTargetAddress;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_safeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ReverseWinRTCallInterceptor(IntPtr safeTargetAddress, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos, bool isStatic);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
internal class System.Runtime.InteropServices.ReverseWinRTDelegateCallInterceptor : InteropCallInterceptor {
    private IntPtr m_safeTargetAddress;
    private object m_safeFirstArgument;
    private LocalVariableType[] m_safeTypes;
    private LocalVariableType[] m_unsafeTypes;
    private DynamicCallSignature m_safeDynamicCallSignature;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    internal ReverseWinRTDelegateCallInterceptor(IntPtr safeTargetAddress, object safeFirstArgument, LocalVariableType[] safeTypes, LocalVariableType[] unsafeTypes, BaseMarshaller[] marshallers, MarshallerArgumentInfo[] marshallerArgumentInfos);
    public virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public virtual CallingConvention get_CallingConvention();
    public virtual LocalVariableType[] get_LocalVariableTypes();
    public virtual void ThunkExecute(CallInterceptorArgs& callInterceptorArgs);
}
internal class System.Runtime.InteropServices.RuntimeTypeHandleMap : FixedHashTable {
    private Func`2<int, RuntimeTypeHandle> m_getHandle;
    internal RuntimeTypeHandleMap(int size, Func`2<int, RuntimeTypeHandle> getHandle);
    internal int Lookup(RuntimeTypeHandle handle);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
internal class System.Runtime.InteropServices.SHA1 : object {
    private bool _disposed;
    private Byte[] HashValue;
    private HashProviderCng _hashProvider;
    public static SHA1 Create();
    public Byte[] ComputeHash(Byte[] buffer);
    private void HashCore(Byte[] array, int ibStart, int cbSize);
    private Byte[] CaptureHashCodeAndReinitialize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class System.Runtime.InteropServices.SharedCcw_AsyncOperationCompletedHandler : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnInvoke;
    [PreInitializedAttribute]
private static SharedCcw_AsyncOperationCompletedHandler s_theCcwVtable;
    private static SharedCcw_AsyncOperationCompletedHandler();
    public static IntPtr GetVtable();
    [NativeCallableAttribute]
private static int Invoke(IntPtr pComThis, IntPtr _asyncInfo, int asyncStatus);
}
internal class System.Runtime.InteropServices.SharedCcw_IIterable : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnFirst;
    [PreInitializedAttribute]
private static SharedCcw_IIterable s_theCcwVtable;
    private static SharedCcw_IIterable();
    public static IntPtr GetVtable();
    [NativeCallableAttribute]
private static int First(IntPtr pComThis, IntPtr pResult);
}
internal class System.Runtime.InteropServices.SharedCcw_IIterator : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnget_Current;
    public IntPtr pfnget_HasCurrent;
    public IntPtr pfnMoveNext;
    public IntPtr pfnGetMany;
    [PreInitializedAttribute]
private static SharedCcw_IIterator s_theCcwVtable;
    private static SharedCcw_IIterator();
    public static IntPtr GetVtable();
    [NativeCallableAttribute]
private static int get_Current(IntPtr pComThis, IntPtr pValue);
    [NativeCallableAttribute]
private static int get_HasCurrent(IntPtr pComThis, IntPtr pValue);
    [NativeCallableAttribute]
private static int MoveNext(IntPtr pComThis, IntPtr pValue);
    [NativeCallableAttribute]
private static int GetMany(IntPtr pComThis, UInt32 len, IntPtr pDest, IntPtr pCount);
}
internal class System.Runtime.InteropServices.SharedCcw_IIterator_Blittable : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnget_Current;
    public IntPtr pfnget_HasCurrent;
    public IntPtr pfnMoveNext;
    public IntPtr pfnGetMany;
    [PreInitializedAttribute]
private static SharedCcw_IIterator_Blittable s_theCcwVtable;
    private static SharedCcw_IIterator_Blittable();
    public static IntPtr GetVtable();
    [NativeCallableAttribute]
private static int get_Current(IntPtr pComThis, IntPtr pValue);
    [NativeCallableAttribute]
private static int get_HasCurrent(IntPtr pComThis, IntPtr pValue);
    [NativeCallableAttribute]
private static int MoveNext(IntPtr pComThis, IntPtr pValue);
    [NativeCallableAttribute]
private static int GetMany(IntPtr pComThis, UInt32 len, IntPtr pDest, IntPtr pCount);
}
internal class System.Runtime.InteropServices.SharedCcw_IVector : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnGetAt;
    public IntPtr pfnget_Size;
    public IntPtr pfnGetView;
    public IntPtr pfnIndexOf;
    public IntPtr pfnSetAt;
    public IntPtr pfnInsertAt;
    public IntPtr pfnRemoveAt;
    public IntPtr pfnAppend;
    public IntPtr pfnRemoveAtEnd;
    public IntPtr pfnClear;
    public IntPtr pfnGetMany;
    public IntPtr pfnReplaceAll;
    [PreInitializedAttribute]
private static SharedCcw_IVector s_theCcwVtable;
    private static SharedCcw_IVector();
    public static IntPtr GetVtable();
    [NativeCallableAttribute]
internal static int GetAt(IntPtr pComThis, UInt32 index, IntPtr pItem);
    [NativeCallableAttribute]
internal static int get_Size(IntPtr pComThis, IntPtr pSize);
    [NativeCallableAttribute]
private static int GetView(IntPtr pComThis, IntPtr pView);
    [NativeCallableAttribute]
internal static int IndexOf(IntPtr pComThis, IntPtr _value, IntPtr pIndex, IntPtr pFound);
    [NativeCallableAttribute]
private static int SetAt(IntPtr pComThis, UInt32 index, IntPtr _value);
    [NativeCallableAttribute]
private static int InsertAt(IntPtr pComThis, UInt32 index, IntPtr _value);
    [NativeCallableAttribute]
private static int RemoveAt(IntPtr pComThis, UInt32 index);
    [NativeCallableAttribute]
private static int Append(IntPtr pComThis, IntPtr _value);
    [NativeCallableAttribute]
private static int RemoveAtEnd(IntPtr pComThis);
    [NativeCallableAttribute]
private static int Clear(IntPtr pComThis);
    [NativeCallableAttribute]
internal static int GetMany(IntPtr pComThis, UInt32 startIndex, UInt32 len, IntPtr pDest, IntPtr pCount);
    [NativeCallableAttribute]
private static int ReplaceAll(IntPtr pComThis, UInt32 length, IntPtr pItems);
}
internal class System.Runtime.InteropServices.SharedCcw_IVector_Blittable : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnGetAt;
    public IntPtr pfnget_Size;
    public IntPtr pfnGetView;
    public IntPtr pfnIndexOf;
    public IntPtr pfnSetAt;
    public IntPtr pfnInsertAt;
    public IntPtr pfnRemoveAt;
    public IntPtr pfnAppend;
    public IntPtr pfnRemoveAtEnd;
    public IntPtr pfnClear;
    public IntPtr pfnGetMany;
    public IntPtr pfnReplaceAll;
    [PreInitializedAttribute]
private static SharedCcw_IVector_Blittable s_theCcwVtable;
    private static SharedCcw_IVector_Blittable();
    public static IntPtr GetVtable();
    [NativeCallableAttribute]
internal static int GetAt(IntPtr pComThis, UInt32 _index, IntPtr pItem);
    [NativeCallableAttribute]
internal static int get_Size(IntPtr pComThis, IntPtr pSize);
    [NativeCallableAttribute]
private static int GetView(IntPtr pComThis, IntPtr pView);
    [NativeCallableAttribute]
internal static int IndexOf(IntPtr pComThis, IntPtr _value, IntPtr pIndex, IntPtr pFound);
    [NativeCallableAttribute]
private static int SetAt(IntPtr pComThis, UInt32 _index, IntPtr _value);
    [NativeCallableAttribute]
private static int InsertAt(IntPtr pComThis, UInt32 _index, IntPtr _value);
    [NativeCallableAttribute]
private static int RemoveAt(IntPtr pComThis, UInt32 _index);
    [NativeCallableAttribute]
private static int Append(IntPtr pComThis, IntPtr _value);
    [NativeCallableAttribute]
private static int RemoveAtEnd(IntPtr pComThis);
    [NativeCallableAttribute]
private static int Clear(IntPtr pComThis);
    [NativeCallableAttribute]
internal static int GetMany(IntPtr pComThis, UInt32 startIndex, UInt32 len, IntPtr pDest, IntPtr pCount);
    [NativeCallableAttribute]
private static int ReplaceAll(IntPtr pComThis, UInt32 length, IntPtr pItems);
}
internal class System.Runtime.InteropServices.SharedCcw_IVectorView : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnGetAt;
    public IntPtr pfnget_Size;
    public IntPtr pfnIndexOf;
    public IntPtr pfnGetMany;
    [PreInitializedAttribute]
private static SharedCcw_IVectorView s_theCcwVtable;
    private static SharedCcw_IVectorView();
    public static IntPtr GetVtable();
}
internal class System.Runtime.InteropServices.SharedCcw_IVectorView_Blittable : ValueType {
    public IntPtr pfnQueryInterface;
    public IntPtr pfnAddRef;
    public IntPtr pfnRelease;
    public IntPtr pfnGetIids;
    public IntPtr pfnGetRuntimeClassName;
    public IntPtr pfnGetTrustLevel;
    public IntPtr pfnGetAt;
    public IntPtr pfnget_Size;
    public IntPtr pfnIndexOf;
    public IntPtr pfnGetMany;
    [PreInitializedAttribute]
private static SharedCcw_IVectorView_Blittable s_theCcwVtable;
    private static SharedCcw_IVectorView_Blittable();
    public static IntPtr GetVtable();
}
internal class System.Runtime.InteropServices.SimpleComInterfaceCacheItem : ValueType {
    private IntPtr ptr;
    private RuntimeTypeHandle typeHandle;
    private bool hasValue;
    private bool HasValue { get; }
    private bool get_HasValue();
    internal bool Assign(IntPtr pComPtr, RuntimeTypeHandle handle);
    internal bool TryGetPtr(IntPtr& retIntPtr);
    internal bool TryGetType(RuntimeTypeHandle& retInterface);
    internal IntPtr GetPtr();
    internal bool IsMatchingEntry(IntPtr pComPtr, RuntimeTypeHandle interfaceType);
    internal bool IsCastableEntry(RuntimeTypeHandle interfaceType, IntPtr& pComPtr, RuntimeTypeHandle& entryType);
    internal bool TryReadCachedNativeInterface(RuntimeTypeHandle interfaceType, IntPtr& pComPtr);
}
[McgComCallableAttribute]
internal class System.Runtime.InteropServices.StandardCustomPropertyProviderProxy : object {
    private object m_target;
    internal StandardCustomPropertyProviderProxy(object target);
    public sealed virtual object GetTarget();
}
internal class System.Runtime.InteropServices.STATSTG_UnsafeType : ValueType {
    public IntPtr pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
internal abstract class System.Runtime.InteropServices.StringMap : object {
    private int m_size;
    private FixedHashTable m_map;
    internal StringMap(int size);
    internal abstract virtual string GetString(int i);
    internal abstract virtual int GetStringHash(int i);
    internal abstract virtual bool IsStringEqual(string name, int i);
    internal int FindString(string name);
}
internal class System.Runtime.InteropServices.StringMap16 : StringMap {
    private StringPool m_pool;
    private UInt16[] m_indices;
    internal StringMap16(StringPool pool, UInt16[] indices);
    internal virtual string GetString(int i);
    internal virtual int GetStringHash(int i);
    internal virtual bool IsStringEqual(string name, int i);
}
internal class System.Runtime.InteropServices.StringMap32 : StringMap {
    private StringPool m_pool;
    private UInt32[] m_indices;
    internal StringMap32(StringPool pool, UInt32[] indices);
    internal virtual string GetString(int i);
    internal virtual int GetStringHash(int i);
    internal virtual bool IsStringEqual(string name, int i);
}
internal class System.Runtime.InteropServices.StringPool : object {
    private Byte[] m_typeNamespaces;
    private Byte[] m_typeNames;
    private UInt16[] m_indices;
    internal static byte Escape_Start;
    internal static byte Unicode_Mark;
    private static int Hash_Init;
    internal StringPool(Byte[] typeNamespaces, Byte[] typeNames, UInt16[] indices);
    internal string GetString(UInt32 nameIdx);
    internal static int HashAccumulate(int hash, char val);
    internal static int StableStringHash(string str);
    internal int StableStringHash(UInt32 nameIdx);
    internal bool IsStringEqual(string name, UInt32 nameIdx);
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.Toolbox : object {
    public static int IListThunk(IList`1<T> list, IList_Oper oper, int index, Object& item);
    public static object IListBlittableThunk(IList`1<T> list, IList_Oper oper, Int32& index, T& item);
    internal static bool EnsureIndexInt32(UInt32 index, UInt32 listCapacity, Int32& hr);
    public static int IReadOnlyListThunk(IReadOnlyList`1<T> list, IList_Oper oper, int index, T& item);
    public static object IReadOnlyListBlittableThunk(IReadOnlyList`1<T> list, IList_Oper oper, Int32& index, T& item);
}
internal enum System.Runtime.InteropServices.TrustLevel : Enum {
    public int value__;
    public static TrustLevel BaseTrust;
    public static TrustLevel PartialTrust;
    public static TrustLevel FullTrust;
}
[ExtensionAttribute]
internal static class System.Runtime.InteropServices.TypeHandleExtensions : object {
    private static IntPtr[] SharedCCWList;
    private static TypeHandleExtensions();
    [ExtensionAttribute]
internal static string GetDisplayName(RuntimeTypeHandle handle);
    [ExtensionAttribute]
internal static bool IsComClass(RuntimeTypeHandle handle);
    [ExtensionAttribute]
internal static bool IsIJupiterObject(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool IsIInspectable(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool HasInterfaceData(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool IsSupportIInspectable(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static bool HasDynamicAdapterClass(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetDynamicAdapterClassType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static Guid GetInterfaceGuid(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static IntPtr GetCcwVtableThunk(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static IntPtr GetCcwVtable(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static int GetMarshalIndex(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static McgInterfaceFlags GetInterfaceFlags(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetDispatchClassType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static IntPtr GetDelegateInvokeStub(RuntimeTypeHandle winrtDelegateType);
    [ExtensionAttribute]
internal static GCPressureRange GetGCPressureRange(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static bool IsSealed(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static ComMarshalingType GetMarshalingType(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetDefaultInterface(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static string GetWinRTTypeName(RuntimeTypeHandle classType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetIteratorType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetElementClassType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetElementInterfaceType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetVectorViewType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetAsyncOperationType(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static int GetByteSize(RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
internal static string GetCCWRuntimeClassName(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static bool IsCCWTemplateSupported(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static bool IsCCWWinRTType(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static IEnumerable`1<RuntimeTypeHandle> GetImplementedInterfaces(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static RuntimeTypeHandle GetBaseClass(RuntimeTypeHandle ccwType);
    private static void GetIIDsImpl(RuntimeTypeHandle typeHandle, List`1<Guid> iids);
    private static void GetIIDsImpl_dynamic(RuntimeTypeHandle typeHandle, List`1<Guid> iids);
    [ExtensionAttribute]
internal static List`1<Guid> GetIIDs(RuntimeTypeHandle ccwType);
    [ExtensionAttribute]
internal static string StructWinRTName(RuntimeTypeHandle structType);
    [ExtensionAttribute]
internal static bool IsInvalid(RuntimeTypeHandle typeHandle);
}
[AttributeUsageAttribute("5144")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    internal string Scope_;
    internal string Identifier_;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    public string get_Scope();
    public string get_Identifier();
}
internal enum System.Runtime.InteropServices.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Custom;
}
internal class System.Runtime.InteropServices.TypeName : ValueType {
    public HSTRING Name;
    public TypeKind Kind;
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.TypeOfHelper : object {
    private static void RuntimeTypeHandleOf_DidntGetTransformedAway();
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3, string arg4);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3, string arg4, string arg5);
    public static RuntimeTypeHandle RuntimeTypeHandleOf(string typeName, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6);
    public static Type TypeOf(string typeName);
}
public class System.Runtime.InteropServices.UnknownWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    public object get_WrappedObject();
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; public set; }
    internal bool IsEmpty { get; }
    internal sbyte AsI1 { get; internal set; }
    internal short AsI2 { get; internal set; }
    internal int AsI4 { get; internal set; }
    internal long AsI8 { get; internal set; }
    internal byte AsUi1 { get; internal set; }
    internal ushort AsUi2 { get; internal set; }
    internal UInt32 AsUi4 { get; internal set; }
    internal ulong AsUi8 { get; internal set; }
    internal int AsInt { get; internal set; }
    internal UInt32 AsUint { get; internal set; }
    internal bool AsBool { get; internal set; }
    internal float AsR4 { get; internal set; }
    internal double AsR8 { get; internal set; }
    internal decimal AsDecimal { get; internal set; }
    internal string AsBstr { get; internal set; }
    internal object AsUnknown { get; internal set; }
    public Variant(object value);
    public object ToObject();
    public void Clear();
    public VarEnum get_VariantType();
    public void set_VariantType(VarEnum value);
    internal bool get_IsEmpty();
    internal sbyte get_AsI1();
    internal void set_AsI1(sbyte value);
    internal short get_AsI2();
    internal void set_AsI2(short value);
    internal int get_AsI4();
    internal void set_AsI4(int value);
    internal long get_AsI8();
    internal void set_AsI8(long value);
    internal byte get_AsUi1();
    internal void set_AsUi1(byte value);
    internal ushort get_AsUi2();
    internal void set_AsUi2(ushort value);
    internal UInt32 get_AsUi4();
    internal void set_AsUi4(UInt32 value);
    internal ulong get_AsUi8();
    internal void set_AsUi8(ulong value);
    internal int get_AsInt();
    internal void set_AsInt(int value);
    internal UInt32 get_AsUint();
    internal void set_AsUint(UInt32 value);
    internal bool get_AsBool();
    internal void set_AsBool(bool value);
    internal float get_AsR4();
    internal void set_AsR4(float value);
    internal double get_AsR8();
    internal void set_AsR8(double value);
    internal decimal get_AsDecimal();
    internal void set_AsDecimal(decimal value);
    internal string get_AsBstr();
    internal void set_AsBstr(string value);
    internal object get_AsUnknown();
    internal void set_AsUnknown(object value);
}
public class System.Runtime.InteropServices.VariantWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    public object get_WrappedObject();
}
[McgComCallableAttribute]
internal class System.Runtime.InteropServices.WeakReferenceSource : object {
    private WeakReference`1<object> weakRef;
    internal WeakReferenceSource(object obj);
    internal object Resolve();
}
internal class System.Runtime.InteropServices.WellknownOpenGenericType : object {
    [CompilerGeneratedAttribute]
private RuntimeTypeHandle <OpenGenericTypeHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WinRTName>k__BackingField;
    private static WellknownOpenGenericType[] s_wellKnownOpenGenericTypes;
    internal RuntimeTypeHandle OpenGenericTypeHandle { get; private set; }
    internal string Guid { get; private set; }
    internal string WinRTName { get; private set; }
    internal WellknownOpenGenericType(RuntimeTypeHandle openGenericTypeHandle, string guid, string winrtName);
    private static WellknownOpenGenericType();
    [CompilerGeneratedAttribute]
internal RuntimeTypeHandle get_OpenGenericTypeHandle();
    [CompilerGeneratedAttribute]
private void set_OpenGenericTypeHandle(RuntimeTypeHandle value);
    [CompilerGeneratedAttribute]
internal string get_Guid();
    [CompilerGeneratedAttribute]
private void set_Guid(string value);
    [CompilerGeneratedAttribute]
internal string get_WinRTName();
    [CompilerGeneratedAttribute]
private void set_WinRTName(string value);
    internal static bool TryGetIIDForGenericOpenInterface(RuntimeTypeHandle openGenericTypeHandle, String& iid);
    internal static string GetWinRTNameForGenericOpenInterface(RuntimeTypeHandle openGenericTypeHandle);
    internal static bool TryGetGenericOpenTypeFromWinRTTypeName(string winrtTypeName, RuntimeTypeHandle& openGenericTypeHandle);
}
[DependencyReductionRootAttribute]
internal interface System.Runtime.InteropServices.WindowsRuntime.__IUnboxInternal {
    public abstract virtual object get_Value(object obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__vtable_ICommand : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnadd_CanExecuteChanged;
    private IntPtr pfnremove_CanExecuteChanged;
    private IntPtr pfnCanExecute;
    private IntPtr pfnExecute;
    private static __vtable_ICommand s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __vtable_ICommand();
    internal static IntPtr GetCcwvtable();
    [NativeCallableAttribute]
private static int add_CanExecuteChanged(IntPtr pComThis, IntPtr unsafe_value, IntPtr __IntPtr_unsafe_token__retval);
    [NativeCallableAttribute]
private static int remove_CanExecuteChanged(IntPtr pComThis, EventRegistrationToken unsafe_token);
    [NativeCallableAttribute]
private static int CanExecute(IntPtr pComThis, IntPtr unsafe_parameter, IntPtr __IntPtr_unsafe_returnValue__retval);
    [NativeCallableAttribute]
private static int Execute(IntPtr pComThis, IntPtr unsafe_parameter);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.__vtable_ICustomProperty : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnget_Type;
    private IntPtr pfnget_Name;
    private IntPtr pfnGetValue;
    private IntPtr pfnSetValue;
    private IntPtr pfnGetIndexedValue;
    private IntPtr pfnSetIndexedValue;
    private IntPtr pfnget_CanWrite;
    private IntPtr pfnget_CanRead;
    private static IntPtr pNativeVtable;
    private static __vtable_ICustomProperty s_theCcwVtable;
    private static __vtable_ICustomProperty();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_ICustomProperty();
    [NativeCallableAttribute]
private static int get_Type(IntPtr pComThis, IntPtr unsafe_value__retval);
    [NativeCallableAttribute]
private static int get_Name(IntPtr pComThis, IntPtr unsafe_value__retval);
    [NativeCallableAttribute]
private static int GetValue(IntPtr pComThis, IntPtr unsafe_target, IntPtr __IntPtr_unsafe_returnValue__retval);
    [NativeCallableAttribute]
private static int SetValue(IntPtr pComThis, IntPtr __IntPtr_unsafe_target, IntPtr __IntPtr_unsafe_value);
    [NativeCallableAttribute]
private static int GetIndexedValue(IntPtr pComThis, IntPtr unsafe_target, IntPtr unsafe_index, IntPtr __IntPtr_unsafe_returnValue__retval);
    [NativeCallableAttribute]
private static int SetIndexedValue(IntPtr pComThis, IntPtr unsafe_target, IntPtr unsafe_value, IntPtr unsafe_index);
    [NativeCallableAttribute]
private static int get_CanWrite(IntPtr pComThis, IntPtr __IntPtr_unsafe_value__retval);
    [NativeCallableAttribute]
private static int get_CanRead(IntPtr pComThis, IntPtr __IntPtr_unsafe_value__retval);
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.__vtable_IDisposable : ValueType {
    internal IntPtr pfnQueryInterface;
    internal IntPtr pfnAddRef;
    internal IntPtr pfnRelease;
    internal IntPtr pfnGetIids;
    internal IntPtr pfnGetRuntimeClassName;
    internal IntPtr pfnGetTrustLevel;
    internal IntPtr pfnClose;
    private static IntPtr pNativeVtable;
    private static __vtable_IDisposable s_theCcwVtable;
    private static __vtable_IDisposable();
    internal static IntPtr GetVtableFuncPtr();
    internal static IntPtr GetCcwvtable_IDisposable();
    [NativeCallableAttribute]
public static int Close(IntPtr pComThis);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__Vtable_IEnumerable : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnFirst;
    private static __Vtable_IEnumerable s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __Vtable_IEnumerable();
    internal static IntPtr GetVtbl();
    [NativeCallableAttribute]
private static int First(IntPtr pComThis, IntPtr intptr_unsafe_returnValue__retval);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__vtable_IList : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnGetAt;
    private IntPtr pfnget_Size;
    private IntPtr pfnGetView;
    private IntPtr pfnIndexOf;
    private IntPtr pfnSetAt;
    private IntPtr pfnInsertAt;
    private IntPtr pfnRemoveAt;
    private IntPtr pfnAppend;
    private IntPtr pfnRemoveAtEnd;
    private IntPtr pfnClear;
    private static __vtable_IList s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __vtable_IList();
    internal static IntPtr GetVtbl();
    [NativeCallableAttribute]
private static int GetAt(IntPtr pComThis, UInt32 unsafe_index, IntPtr intptr_unsafe_returnValue__retval);
    [NativeCallableAttribute]
private static int get_Size(IntPtr pComThis, IntPtr intptr_unsafe_value__retval);
    [NativeCallableAttribute]
private static int GetView(IntPtr pComThis, IntPtr intptr_unsafe_returnValue__retval);
    [NativeCallableAttribute]
private static int IndexOf(IntPtr pComThis, IntPtr unsafe_value, IntPtr intptr_unsafe_index, IntPtr intptr_unsafe_returnValue__retval);
    [NativeCallableAttribute]
private static int SetAt(IntPtr pComThis, UInt32 unsafe_index, IntPtr unsafe_value);
    [NativeCallableAttribute]
private static int InsertAt(IntPtr pComThis, UInt32 unsafe_index, IntPtr unsafe_value);
    [NativeCallableAttribute]
private static int RemoveAt(IntPtr pComThis, UInt32 unsafe_index);
    [NativeCallableAttribute]
private static int Append(IntPtr pComThis, IntPtr unsafe_value);
    [NativeCallableAttribute]
private static int RemoveAtEnd(IntPtr pComThis);
    [NativeCallableAttribute]
private static int Clear(IntPtr pComThis);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__Vtbl_INotifyCollectionChanged : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnadd_CollectionChanged;
    private IntPtr pfnremove_CollectionChanged;
    private static __Vtbl_INotifyCollectionChanged s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __Vtbl_INotifyCollectionChanged();
    internal static IntPtr GetVtbl();
    [NativeCallableAttribute]
private static int add_CollectionChanged__n(IntPtr pComThis, IntPtr unsafe_value, IntPtr __intPtr_unsafe_token__retval);
    [NativeCallableAttribute]
private static int remove_CollectionChanged__n(IntPtr pComThis, EventRegistrationToken unsafe_token);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__Vtbl_INotifyPropertyChanged : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnGetIids;
    private IntPtr pfnGetRuntimeClassName;
    private IntPtr pfnGetTrustLevel;
    private IntPtr pfnadd_PropertyChanged;
    private IntPtr pfnremove_PropertyChanged;
    private static __Vtbl_INotifyPropertyChanged s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __Vtbl_INotifyPropertyChanged();
    internal static IntPtr GetVtbl();
    [NativeCallableAttribute]
private static int add_PropertyChanged(IntPtr pComThis, IntPtr unsafe_value, IntPtr intptr_unsafe_token__retval);
    [NativeCallableAttribute]
private static int remove_PropertyChanged(IntPtr pComThis, EventRegistrationToken unsafe_token);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__Vtbl_NotifyCollectionChangedEventHandler : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnInvoke;
    private static __Vtbl_NotifyCollectionChangedEventHandler s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __Vtbl_NotifyCollectionChangedEventHandler();
    internal static IntPtr GetVtbl();
    [NativeCallableAttribute]
private static int Invoke(IntPtr pComThis, IntPtr unsafe_sender, IntPtr unsafe_e);
}
internal class System.Runtime.InteropServices.WindowsRuntime.__Vtbl_PropertyChangedEventHandler : ValueType {
    private IntPtr pfnQueryInterface;
    private IntPtr pfnAddRef;
    private IntPtr pfnRelease;
    private IntPtr pfnInvoke;
    private static __Vtbl_PropertyChangedEventHandler s_staticVtable;
    private static IntPtr s_cachedVtable;
    private static __Vtbl_PropertyChangedEventHandler();
    internal static IntPtr GetVtbl();
    [NativeCallableAttribute]
private static int Invoke(IntPtr pComThis, IntPtr unsafe_sender, IntPtr unsafe_e);
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.CLRIKeyValuePairArrayImpl`2 : BoxedKeyValuePair {
    private object _pairs;
    public virtual object Initialize(object pairs);
    public virtual object GetTarget();
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.CLRIKeyValuePairImpl`2 : BoxedKeyValuePair {
    private KeyValuePair`2<K, V> _pair;
    public CLRIKeyValuePairImpl`2(KeyValuePair`2& pair);
    public sealed virtual K get_Key();
    [McgAccessorAttribute("0", "Value")]
public sealed virtual V get_Value();
    public virtual object GetTarget();
    public virtual object Initialize(object pair);
    public sealed virtual object get_Value(object obj);
    public static object Unbox(object wrapper);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.InteropServices.WindowsRuntime.ConstantSplittableMap`2 : object {
    private KeyValuePair`2[] items;
    private int firstItemIndex;
    private int lastItemIndex;
    public int Count { get; }
    public UInt32 Size { get; }
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    internal ConstantSplittableMap`2(IReadOnlyDictionary`2<TKey, TValue> data);
    private ConstantSplittableMap`2(KeyValuePair`2[] items, int firstItemIndex, int lastItemIndex);
    public sealed virtual int Compare(KeyValuePair`2<TKey, TValue> x, KeyValuePair`2<TKey, TValue> y);
    public sealed virtual int get_Count();
    public UInt32 get_Size();
    public TValue Lookup(TKey key);
    public bool HasKey(TKey key);
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public void Split(IReadOnlyDictionary`2& firstPartition, IReadOnlyDictionary`2& secondPartition);
    private int Find(TKey& key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.CustomPropertyImpl : object {
    private PropertyInfo m_property;
    private bool m_supportIndexerWithoutMetadata;
    private Type m_indexerContainingType;
    public string Name { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type Type { get; }
    public CustomPropertyImpl(PropertyInfo propertyInfo, bool supportIndexerWithoutMetadata, Type indexerContainingType);
    public sealed virtual string get_Name();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    private bool CheckAccess(bool getValue);
    internal static void LogDataBindingError(string propertyName, Exception ex);
    public sealed virtual object GetValue(object target);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual Type get_Type();
    public sealed virtual object GetIndexedValue(object target, object index);
    public sealed virtual void SetIndexedValue(object target, object value, object index);
    public static object UnwrapTarget(object target);
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.DefaultInterfaceAttribute : Attribute {
    private Type m_defaultInterface;
    public Type DefaultInterface { get; }
    public DefaultInterfaceAttribute(Type defaultInterface);
    public Type get_DefaultInterface();
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.EnumeratorToIteratorAdapter`1 : object {
    private IEnumerator`1<T> m_enumerator;
    private bool m_firstItem;
    private bool m_hasCurrent;
    public T Current { get; }
    public bool HasCurrent { get; }
    public EnumeratorToIteratorAdapter`1(IEnumerator`1<T> enumerator);
    public sealed virtual T get_Current();
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    public sealed virtual UInt32 GetMany(T[] items);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.WindowsRuntime.EventHandler_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static void Invoke(IntPtr unsafeThis, object sender, TEventArgs e);
}
[__BlockReflectionAttribute]
public static class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationHelpers : object {
    public static T ExtractHandler(EventRegistrationTokenTable`1<T> table, EventRegistrationToken token);
    public static TValue GetValueFromEquivalentKey(ConditionalWeakTable`2<TKey, TValue> table, TKey key, CreateValueCallback<TKey, TValue> callback);
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable`1 : object {
    private Dictionary`2<EventRegistrationToken, T> m_tokens;
    private T modreq(System.Runtime.CompilerServices.IsVolatile) m_invokeList;
    public T InvocationList { get; public set; }
    public T get_InvocationList();
    public void set_InvocationList(T value);
    public EventRegistrationToken AddEventHandler(T handler);
    private EventRegistrationToken AddEventHandlerNoLock(T handler);
    internal T ExtractHandler(EventRegistrationToken token);
    private static EventRegistrationToken GetPreferredToken(T handler);
    public void RemoveEventHandler(EventRegistrationToken token);
    public void RemoveEventHandler(T handler);
    private void RemoveEventHandlerNoLock(EventRegistrationToken token);
    public static EventRegistrationTokenTable`1<T> GetOrCreateEventRegistrationTokenTable(EventRegistrationTokenTable`1& refEventTable);
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactory {
    public abstract virtual object ActivateInstance();
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactoryInternal {
    public abstract virtual IntPtr ActivateInstance();
}
[DependencyReductionConditionallyDependentAttribute("Windows.Foundation.IAsyncActionWithProgress`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.IAsyncActionWithProgress_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private static int idx_set_Progress;
    private static int idx_get_Progress;
    private static int idx_set_Completed;
    private static int idx_get_Completed;
    private static int idx_GetResults;
    private static Func`2<IntPtr, AsyncActionWithProgressCompletedHandler`1<TProgress>> s_get_Completed;
    private static Action`2<IntPtr, AsyncActionWithProgressCompletedHandler`1<TProgress>> s_set_Completed;
    private static Func`2<IntPtr, AsyncActionProgressHandler`1<TProgress>> s_get_Progress;
    private static Action`2<IntPtr, AsyncActionProgressHandler`1<TProgress>> s_set_Progress;
    public AsyncActionWithProgressCompletedHandler`1<TProgress> Completed { get; public set; }
    public AsyncActionProgressHandler`1<TProgress> Progress { get; public set; }
    public UInt32 Id { get; }
    public AsyncStatus Status { get; }
    public Exception ErrorCode { get; }
    private IntPtr UnsafeThis { get; }
    public sealed virtual AsyncActionWithProgressCompletedHandler`1<TProgress> get_Completed();
    public void set_Completed(AsyncActionWithProgressCompletedHandler`1<TProgress> value);
    public sealed virtual AsyncActionProgressHandler`1<TProgress> get_Progress();
    public void set_Progress(AsyncActionProgressHandler`1<TProgress> value);
    public sealed virtual void GetResults();
    public sealed virtual UInt32 get_Id();
    public sealed virtual AsyncStatus get_Status();
    public sealed virtual Exception get_ErrorCode();
    public sealed virtual void Cancel();
    public sealed virtual void Close();
    private IntPtr get_UnsafeThis();
    private sealed virtual override void Windows.Foundation.IAsyncActionWithProgress<TProgress>.put_Progress(AsyncActionProgressHandler`1<TProgress> handler);
    private sealed virtual override void Windows.Foundation.IAsyncActionWithProgress<TProgress>.put_Completed(AsyncActionWithProgressCompletedHandler`1<TProgress> handler);
}
[DependencyReductionConditionallyDependentAttribute("Windows.Foundation.IAsyncOperation`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.IAsyncOperation_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private static Func`2<IntPtr, AsyncOperationCompletedHandler`1<TResult>> s_get_Completed;
    private static Action`2<IntPtr, AsyncOperationCompletedHandler`1<TResult>> s_set_Completed;
    private static Func`2<IntPtr, TResult> s_GetResults;
    public AsyncOperationCompletedHandler`1<TResult> Completed { get; public set; }
    public UInt32 Id { get; }
    public AsyncStatus Status { get; }
    public Exception ErrorCode { get; }
    private IntPtr UnsafeThis { get; }
    public sealed virtual AsyncOperationCompletedHandler`1<TResult> get_Completed();
    public void set_Completed(AsyncOperationCompletedHandler`1<TResult> value);
    public sealed virtual TResult GetResults();
    public sealed virtual UInt32 get_Id();
    public sealed virtual AsyncStatus get_Status();
    public sealed virtual Exception get_ErrorCode();
    public sealed virtual void Cancel();
    public sealed virtual void Close();
    private IntPtr get_UnsafeThis();
    private sealed virtual override void Windows.Foundation.IAsyncOperation<TResult>.put_Completed(AsyncOperationCompletedHandler`1<TResult> handler);
}
[DependencyReductionConditionallyDependentAttribute("Windows.Foundation.IAsyncOperationWithProgress`2")]
internal class System.Runtime.InteropServices.WindowsRuntime.IAsyncOperationWithProgress_RCWAdapter`2 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private static int idx_set_Progress;
    private static int idx_get_Progress;
    private static int idx_set_Completed;
    private static int idx_get_Completed;
    private static int idx_GetResults;
    private static Func`2<IntPtr, AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress>> s_get_Completed;
    private static Action`2<IntPtr, AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress>> s_set_Completed;
    private static Func`2<IntPtr, AsyncOperationProgressHandler`2<TResult, TProgress>> s_get_Progress;
    private static Action`2<IntPtr, AsyncOperationProgressHandler`2<TResult, TProgress>> s_set_Progress;
    private static Func`2<IntPtr, TResult> s_GetResults;
    public AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> Completed { get; public set; }
    public AsyncOperationProgressHandler`2<TResult, TProgress> Progress { get; public set; }
    public UInt32 Id { get; }
    public AsyncStatus Status { get; }
    public Exception ErrorCode { get; }
    private IntPtr UnsafeThis { get; }
    public sealed virtual AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> get_Completed();
    public void set_Completed(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> value);
    public sealed virtual AsyncOperationProgressHandler`2<TResult, TProgress> get_Progress();
    public void set_Progress(AsyncOperationProgressHandler`2<TResult, TProgress> value);
    public sealed virtual TResult GetResults();
    public sealed virtual UInt32 get_Id();
    public sealed virtual AsyncStatus get_Status();
    public sealed virtual Exception get_ErrorCode();
    public sealed virtual void Cancel();
    public sealed virtual void Close();
    private IntPtr get_UnsafeThis();
    private sealed virtual override void Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>.put_Progress(AsyncOperationProgressHandler`2<TResult, TProgress> handler);
    private sealed virtual override void Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>.put_Completed(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> handler);
}
internal class System.Runtime.InteropServices.WindowsRuntime.IBindableIterable_CCWAdapter : object {
    public static IBindableIterator First(IEnumerable _this);
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.IBindableIterator_PrivateCCWAdapter : object {
    private IEnumerator m_enumerator;
    private bool m_hasCurrent;
    private bool m_firstItem;
    public object Current { get; }
    public bool HasCurrent { get; }
    public IBindableIterator_PrivateCCWAdapter(IEnumerator enumerator);
    public virtual object get_Current();
    public virtual bool get_HasCurrent();
    public virtual bool MoveNext();
    private sealed virtual override UInt32 global::Windows.Foundation.Collections.IIterator<System.Object>.GetMany(Object[] items);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.IBindableVector_CCWAdapter : object {
    public static object GetAt(IList _this, UInt32 index);
    public static UInt32 get_Size(IList _this);
    public static IBindableVectorView GetView(IList _this);
    public static bool IndexOf(IList _this, object value, UInt32& index);
    public static void SetAt(IList _this, UInt32 index, object value);
    public static void InsertAt(IList _this, UInt32 index, object value);
    public static void RemoveAt(IList _this, UInt32 index);
    public static void Append(IList _this, object value);
    public static void RemoveAtEnd(IList _this);
    public static void Clear(IList _this);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView_PrivateCCWAdapter : object {
    private IList list;
    public UInt32 Size { get; }
    public IBindableVectorView_PrivateCCWAdapter(IList list);
    private void EnsureIndexInt32(UInt32 index, int listCapacity);
    public virtual IEnumerator GetEnumerator();
    public virtual object GetAt(UInt32 index);
    public virtual UInt32 get_Size();
    public virtual bool IndexOf(object value, UInt32& index);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.ICommand_CCWAdapter : object {
    private static ConditionalWeakTable`2<ICommand, EventRegistrationTokenTable`1<EventHandler>> m_weakTable;
    private static ICommand_CCWAdapter();
    public static EventRegistrationToken add_CanExecuteChanged(ICommand _this, EventHandler`1<object> value);
    public static void remove_CanExecuteChanged(ICommand _this, EventRegistrationToken token);
    public static bool CanExecute(ICommand _this, object parameter);
    public static void Execute(ICommand _this, object parameter);
    private static EventRegistrationTokenTable`1<EventHandler> CreateTableForICommand(ICommand command);
}
[DefaultMemberAttribute("Item")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.ICollection`1")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IDictionary`2")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.IDictionary_RCWAdapter`2 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private IterableToEnumerableAdapter`1<KeyValuePair`2<TKey, TValue>> m_EnumerableAdapter;
    private static int idx_Lookup;
    private static int idx_get_Size;
    private static int idx_HasKey;
    private static int idx_Insert;
    private static int idx_Remove;
    private static int idx_Clear;
    private static Action`2<IntPtr, TKey> s_Remove;
    private static Func`3<IntPtr, TKey, TValue> s_Lookup;
    private static Func`3<IntPtr, TKey, bool> s_HasKey;
    private static Func`4<IntPtr, TKey, TValue, sbyte> s_Insert;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IntPtr UnsafeThis { get; }
    private IterableToEnumerableAdapter`1<KeyValuePair`2<TKey, TValue>> IEnumerableRCWAdapter { get; }
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private TValue IMap_Lookup(TKey key);
    private bool IMap_HasKey(TKey key);
    private bool IMap_Insert(TKey key, TValue value);
    private IntPtr get_UnsafeThis();
    private IterableToEnumerableAdapter`1<KeyValuePair`2<TKey, TValue>> get_IEnumerableRCWAdapter();
}
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IIterable`1 {
    public abstract virtual IntPtr First();
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public static class System.Runtime.InteropServices.WindowsRuntime.IIterableOfT_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    private static IIterator`1<T> First(IEnumerable`1<T> enumerable);
}
[DependencyReductionConditionallyDependentAttribute("Windows.Foundation.Collections.IIterator`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.IIterator_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private static Func`2<IntPtr, T> s_getCurrentMethod;
    private static Func`3<IntPtr, T[], UInt32> s_getManyMethod;
    public T Current { get; }
    public bool HasCurrent { get; }
    private IntPtr UnsafeThis { get; }
    public sealed virtual T get_Current();
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    public sealed virtual UInt32 GetMany(T[] items);
    private IntPtr get_UnsafeThis();
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public static class System.Runtime.InteropServices.WindowsRuntime.IIteratorOfT_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static T get_Current(IntPtr pComThis);
    [__BlockReflectionAttribute]
public static bool get_HasCurrent(IntPtr pComThis);
    [__BlockReflectionAttribute]
public static bool MoveNext(IntPtr pComThis);
    [__BlockReflectionAttribute]
public static UInt32 GetMany(IntPtr pComThis, T[] items);
}
[DependencyReductionRootAttribute]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.WindowsRuntime.IKeyValuePair_CCWAdapter`2 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static K get_Key(IntPtr pComThis);
    [__BlockReflectionAttribute]
public static V get_Value(IntPtr pComThis);
}
[DependencyReductionConditionallyDependentAttribute("Windows.Foundation.Collections.IKeyValuePair`2")]
internal class System.Runtime.InteropServices.WindowsRuntime.IKeyValuePair_RCWAdapter`2 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private static Func`2<IntPtr, K> s_get_Key;
    private static Func`2<IntPtr, V> s_get_Value;
    private IntPtr UnsafeThis { get; }
    private sealed virtual override K Windows.Foundation.Collections.IKeyValuePair<K,V>.get_Key();
    private sealed virtual override V Windows.Foundation.Collections.IKeyValuePair<K,V>.get_Value();
    private IntPtr get_UnsafeThis();
}
[DefaultMemberAttribute("Item")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.ICollection`1")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IList`1")]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.IList_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private IterableToEnumerableAdapter`1<T> m_EnumerableAdapter;
    private static int idx_GetAt;
    private static int idx_get_Size;
    private static int idx_IndexOf;
    private static int idx_SetAt;
    private static int idx_InsertAt;
    private static int idx_RemoveAt;
    private static int idx_Append;
    private static int idx_Clear;
    private static Func`4<IntPtr, T, IntPtr, bool> s_IndexOf;
    private static Action`2<IntPtr, T> s_Append;
    private static Action`3<IntPtr, UInt32, T> s_InsertAt;
    private static Func`3<IntPtr, UInt32, T> s_GetAt;
    private static Action`3<IntPtr, UInt32, T> s_SetAt;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    private IntPtr UnsafeThis { get; }
    private IterableToEnumerableAdapter`1<T> IEnumerableRCWAdapter { get; }
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    private bool IVector_IndexOf(T item, UInt32& index);
    private void IVector_RemoveAt(UInt32 index);
    private T IVector_GetAt(UInt32 index);
    private IntPtr get_UnsafeThis();
    private IterableToEnumerableAdapter`1<T> get_IEnumerableRCWAdapter();
}
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory {
    public abstract virtual void RunClassConstructor();
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public static class System.Runtime.InteropServices.WindowsRuntime.IMap_CCWAdapter`2 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static V Lookup(IDictionary`2<K, V> _this, K key);
    [__BlockReflectionAttribute]
public static UInt32 get_Size(IDictionary`2<K, V> _this);
    [__BlockReflectionAttribute]
public static bool HasKey(IDictionary`2<K, V> _this, K key);
    [__BlockReflectionAttribute]
public static IReadOnlyDictionary`2<K, V> GetView(IDictionary`2<K, V> _this);
    [__BlockReflectionAttribute]
public static bool Insert(IDictionary`2<K, V> _this, K key, V value);
    [__BlockReflectionAttribute]
public static void Remove(IDictionary`2<K, V> _this, K key);
    [__BlockReflectionAttribute]
public static void Clear(IDictionary`2<K, V> _this);
}
[DependencyReductionConditionallyDependentAttribute("Windows.Foundation.Collections.IMapChangedEventArgs`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.IMapChangedEventArgs_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private static int idx_get_CollectionChange;
    private static int idx_get_Key;
    private static Func`2<IntPtr, K> s_get_Key;
    public CollectionChange CollectionChange { get; }
    public K Key { get; }
    private IntPtr UnsafeThis { get; }
    public sealed virtual CollectionChange get_CollectionChange();
    public sealed virtual K get_Key();
    private IntPtr get_UnsafeThis();
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.WindowsRuntime.IMapView_CCWAdapter`2 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static V Lookup(IReadOnlyDictionary`2<K, V> _this, K key);
    [__BlockReflectionAttribute]
public static UInt32 get_Size(IReadOnlyDictionary`2<K, V> _this);
    [__BlockReflectionAttribute]
public static bool HasKey(IReadOnlyDictionary`2<K, V> _this, K key);
    [__BlockReflectionAttribute]
public static void Split(IReadOnlyDictionary`2<K, V> _this, IReadOnlyDictionary`2& first, IReadOnlyDictionary`2& second);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChanged_CCWAdapter : object {
    private static ConditionalWeakTable`2<INotifyCollectionChanged, EventRegistrationTokenTable`1<NotifyCollectionChangedEventHandler>> m_weakTable;
    private static ConditionalWeakTable`2<INotifyCollectionChanged, EventRegistrationTokenTable`1<NotifyCollectionChangedEventHandler>> WeakTable { get; }
    private static ConditionalWeakTable`2<INotifyCollectionChanged, EventRegistrationTokenTable`1<NotifyCollectionChangedEventHandler>> get_WeakTable();
    public static EventRegistrationToken add_CollectionChanged(INotifyCollectionChanged _this, NotifyCollectionChangedEventHandler value);
    public static void remove_CollectionChanged(INotifyCollectionChanged _this, EventRegistrationToken token);
    private static EventRegistrationTokenTable`1<NotifyCollectionChangedEventHandler> CreateTableForINotifyCollectionChanged(INotifyCollectionChanged notifyCollectionChanged);
}
[GuidAttribute("4cf68d33-e3f2-4964-b85e-945b4f7e2f21")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChangedEventArgs {
    public abstract virtual NotifyCollectionChangedAction get_Action();
    public abstract virtual IList get_NewItems();
    public abstract virtual IList get_OldItems();
    public abstract virtual int get_NewStartingIndex();
    public abstract virtual int get_OldStartingIndex();
}
[GuidAttribute("b30c3e3a-df8d-44a5-9a38-7ac0d08ce63d")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.INotifyCollectionChangedEventArgsFactory {
}
internal static class System.Runtime.InteropServices.WindowsRuntime.INotifyPropertyChanged_CCWAdapter : object {
    private static ConditionalWeakTable`2<INotifyPropertyChanged, EventRegistrationTokenTable`1<PropertyChangedEventHandler>> m_weakTable;
    private static ConditionalWeakTable`2<INotifyPropertyChanged, EventRegistrationTokenTable`1<PropertyChangedEventHandler>> WeakTable { get; }
    private static ConditionalWeakTable`2<INotifyPropertyChanged, EventRegistrationTokenTable`1<PropertyChangedEventHandler>> get_WeakTable();
    public static EventRegistrationToken add_PropertyChanged(INotifyPropertyChanged _this, PropertyChangedEventHandler value);
    public static void remove_PropertyChanged(INotifyPropertyChanged _this, EventRegistrationToken token);
    private static EventRegistrationTokenTable`1<PropertyChangedEventHandler> CreateTableForINotifyPropertyChanged(INotifyPropertyChanged notifyCollectionChanged);
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.InterfaceImplementedInVersionAttribute : Attribute {
    private Type m_interfaceType;
    private byte m_majorVersion;
    private byte m_minorVersion;
    private byte m_buildVersion;
    private byte m_revisionVersion;
    public Type InterfaceType { get; }
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public byte BuildVersion { get; }
    public byte RevisionVersion { get; }
    public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
    public Type get_InterfaceType();
    public byte get_MajorVersion();
    public byte get_MinorVersion();
    public byte get_BuildVersion();
    public byte get_RevisionVersion();
}
[GuidAttribute("4f33a9a0-5cf4-47a4-b16f-d7faaf17457e")]
[InterfaceTypeAttribute("3")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IPropertyChangedEventArgs {
    public abstract virtual IntPtr get_PropertyName();
}
[GuidAttribute("4bd682dd-7554-40e9-9a9b-82654ede7e62")]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public interface System.Runtime.InteropServices.WindowsRuntime.IPropertyValue {
    public bool IsNumericScalar { get; }
    public abstract virtual PropertyType get_Type();
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual byte GetUInt8();
    public abstract virtual short GetInt16();
    public abstract virtual ushort GetUInt16();
    public abstract virtual int GetInt32();
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual long GetInt64();
    public abstract virtual ulong GetUInt64();
    public abstract virtual float GetSingle();
    public abstract virtual double GetDouble();
    public abstract virtual char GetChar16();
    public abstract virtual bool GetBoolean();
    public abstract virtual string GetString();
    public abstract virtual Guid GetGuid();
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual Point GetPoint();
    public abstract virtual Size GetSize();
    public abstract virtual Rect GetRect();
    public abstract virtual void GetUInt8Array(Byte[]& array);
    public abstract virtual void GetInt16Array(Int16[]& array);
    public abstract virtual void GetUInt16Array(UInt16[]& array);
    public abstract virtual void GetInt32Array(Int32[]& array);
    public abstract virtual void GetUInt32Array(UInt32[]& array);
    public abstract virtual void GetInt64Array(Int64[]& array);
    public abstract virtual void GetUInt64Array(UInt64[]& array);
    public abstract virtual void GetSingleArray(Single[]& array);
    public abstract virtual void GetDoubleArray(Double[]& array);
    public abstract virtual void GetChar16Array(Char[]& array);
    public abstract virtual void GetBooleanArray(Boolean[]& array);
    public abstract virtual void GetStringArray(String[]& array);
    public abstract virtual void GetInspectableArray(Object[]& array);
    public abstract virtual void GetGuidArray(Guid[]& array);
    public abstract virtual void GetDateTimeArray(DateTimeOffset[]& array);
    public abstract virtual void GetTimeSpanArray(TimeSpan[]& array);
    public abstract virtual void GetPointArray(Point[]& array);
    public abstract virtual void GetSizeArray(Size[]& array);
    public abstract virtual void GetRectArray(Rect[]& array);
}
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IReadOnlyCollectionAdapter {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.ICollection`1")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IReadOnlyDictionary`2")]
internal abstract class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyDictionary_RCWAdapter`2 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private IterableToEnumerableAdapter`1<KeyValuePair`2<TKey, TValue>> m_EnumerableAdapter;
    private static int idx_Lookup;
    private static int idx_get_Size;
    private static int idx_HasKey;
    private static Func`3<IntPtr, TKey, TValue> s_Lookup;
    private static Func`3<IntPtr, TKey, bool> s_HasKey;
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public TValue Item { get; }
    public int Count { get; }
    private IntPtr UnsafeThis { get; }
    private IterableToEnumerableAdapter`1<KeyValuePair`2<TKey, TValue>> IEnumerableRCWAdapter { get; }
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    protected TValue IMapView_Lookup(TKey key);
    protected bool IMapView_HasKey(TKey key);
    private IntPtr get_UnsafeThis();
    private IterableToEnumerableAdapter`1<KeyValuePair`2<TKey, TValue>> get_IEnumerableRCWAdapter();
}
[DefaultMemberAttribute("Item")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.ICollection`1")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IReadOnlyList`1")]
internal abstract class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyList_RCWAdapter`1 : __ComGenericInterfaceDispatcher {
    private IntPtr m_unsafeThis;
    private IterableToEnumerableAdapter`1<T> m_EnumerableAdapter;
    private static int idx_GetAt;
    private static int idx_get_Size;
    private static Func`3<IntPtr, UInt32, T> s_GetAt;
    public T Item { get; }
    public int Count { get; }
    private IntPtr UnsafeThis { get; }
    private IterableToEnumerableAdapter`1<T> IEnumerableRCWAdapter { get; }
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Item(int index);
    public sealed virtual int get_Count();
    private IntPtr get_UnsafeThis();
    private IterableToEnumerableAdapter`1<T> get_IEnumerableRCWAdapter();
}
[DefaultMemberAttribute("Item")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IReadOnlyListAdapter`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
[DependencyReductionRootAttribute]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public static class System.Runtime.InteropServices.WindowsRuntime.IReference_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static T get_Value(IntPtr pComThis);
}
[DependencyReductionRootAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.IReference_RCWAdapter`1 : object {
    private static int idx_get_Value;
    private static Func`2<IntPtr, T> s_get_Value;
    public sealed virtual object get_Value(object obj);
}
[DependencyReductionRootAttribute]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public static class System.Runtime.InteropServices.WindowsRuntime.IReferenceArray_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static T[] get_Value(IntPtr pComThis);
}
[DependencyReductionRootAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.IReferenceArray_RCWAdapter`1 : object {
    private static int idx_get_Value;
    private static Func`2<IntPtr, T[]> s_get_Value;
    public sealed virtual object get_Value(object obj);
}
[GuidAttribute("61c17707-2d65-11e0-9ae8-d48564015472")]
[__BlockReflectionAttribute]
public interface System.Runtime.InteropServices.WindowsRuntime.IReferenceArray`1 {
    public abstract virtual T[] get_Value();
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.IterableToEnumerableAdapter`1 : object {
    private IntPtr m_pThis;
    public IterableToEnumerableAdapter`1(IntPtr pThis);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IntPtr IterableFirst();
}
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.IteratorToEnumeratorAdapter`1 : object {
    private static Func`2<IntPtr, T> s_getCurrentMethod;
    private IntPtr m_pThis;
    private bool m_hadCurrent;
    private T m_current;
    private bool m_isInitialized;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private bool IteratorHasCurrent { get; }
    public IteratorToEnumeratorAdapter`1(IntPtr pThis);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private T IteratorGetCurrent();
    private bool get_IteratorHasCurrent();
    private bool IteratorMoveNext();
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.WindowsRuntime.IVector_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static T GetAt(IList`1<T> _this, UInt32 index);
    [__BlockReflectionAttribute]
public static UInt32 get_Size(IList`1<T> _this);
    [__BlockReflectionAttribute]
public static IReadOnlyList`1<T> GetView(IList`1<T> _this);
    [__BlockReflectionAttribute]
public static bool IndexOf(IList`1<T> _this, T value, UInt32 index);
    [__BlockReflectionAttribute]
public static void SetAt(IList`1<T> _this, UInt32 index, T value);
    [__BlockReflectionAttribute]
public static void InsertAt(IList`1<T> _this, UInt32 index, T value);
    [__BlockReflectionAttribute]
public static void RemoveAt(IList`1<T> _this, UInt32 index);
    [__BlockReflectionAttribute]
public static void Append(IList`1<T> _this, T value);
    [__BlockReflectionAttribute]
public static void RemoveAtEnd(IList`1<T> _this);
    [__BlockReflectionAttribute]
public static void Clear(IList`1<T> _this);
    [__BlockReflectionAttribute]
public static UInt32 GetMany(IList`1<T> _this, UInt32 startIndex, T[] items);
    [__BlockReflectionAttribute]
public static void ReplaceAll(IList`1<T> _this, T[] items);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
    private static UInt32 GetManyHelper(IList`1<T> sourceList, UInt32 startIndex, T[] items);
}
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.InteropServices.WindowsRuntime.IVectorView_CCWAdapter`1 : object {
    private static IntPtr s_vtable;
    [DependencyReductionRootAttribute]
public static object GetVTable();
    [__BlockReflectionAttribute]
public static T GetAt(IReadOnlyList`1<T> _this, UInt32 index);
    [__BlockReflectionAttribute]
public static UInt32 get_Size(IReadOnlyCollection`1<T> _this);
    [__BlockReflectionAttribute]
public static bool IndexOf(IReadOnlyList`1<T> _this, T value, UInt32& index);
    [__BlockReflectionAttribute]
public static UInt32 GetMany(IReadOnlyList`1<T> _this, UInt32 startIndex, T[] items);
    private static UInt32 GetManyHelper(IReadOnlyList`1<T> _this, UInt32 startIndex, T[] items);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
}
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.ICollection`1")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IEnumerable`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.PrivateKeyCollection`2 : object {
    private IDictionary`2<TKey, TValue> dictionaryAsIDictionary;
    private IReadOnlyDictionary`2<TKey, TValue> dictionaryAsIReadOnlyDictionary;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
    public PrivateKeyCollection`2(object dictionary);
    public sealed virtual void CopyTo(TKey[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Clear();
    public sealed virtual bool Contains(TKey item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IEnumerator`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.PrivateKeyEnumerator`2 : object {
    private IDictionary`2<TKey, TValue> dictionaryAsIDictionary;
    private IReadOnlyDictionary`2<TKey, TValue> dictionaryAsIReadOnlyDictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public PrivateKeyEnumerator`2(object dictionary);
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorFromDictionary();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.ICollection`1")]
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IEnumerable`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.PrivateValueCollection`2 : object {
    private IDictionary`2<TKey, TValue> dictionaryAsIDictionary;
    private IReadOnlyDictionary`2<TKey, TValue> dictionaryAsIReadOnlyDictionary;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
    public PrivateValueCollection`2(object dictionary);
    public sealed virtual void CopyTo(TValue[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Clear();
    public sealed virtual bool Contains(TValue item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
[DependencyReductionConditionallyDependentAttribute("System.Collections.Generic.IEnumerator`1")]
internal class System.Runtime.InteropServices.WindowsRuntime.PrivateValueEnumerator`2 : object {
    private IDictionary`2<TKey, TValue> dictionaryAsIDictionary;
    private IReadOnlyDictionary`2<TKey, TValue> dictionaryAsIReadOnlyDictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public PrivateValueEnumerator`2(object dictionary);
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorFromDictionary();
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
[__BlockReflectionAttribute]
public enum System.Runtime.InteropServices.WindowsRuntime.PropertyType : Enum {
    public int value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType OtherType;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherTypeArray;
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.PropertyValueImpl : BoxedValue {
    public bool IsNumericScalar { get; }
    internal PropertyValueImpl(object val, int type);
    public sealed virtual PropertyType get_Type();
    public sealed virtual bool get_IsNumericScalar();
    public sealed virtual byte GetUInt8();
    public sealed virtual short GetInt16();
    public sealed virtual ushort GetUInt16();
    public sealed virtual int GetInt32();
    public sealed virtual UInt32 GetUInt32();
    public sealed virtual long GetInt64();
    public sealed virtual ulong GetUInt64();
    public sealed virtual float GetSingle();
    public sealed virtual double GetDouble();
    public sealed virtual char GetChar16();
    public sealed virtual bool GetBoolean();
    public sealed virtual string GetString();
    public object GetInspectable();
    public sealed virtual Guid GetGuid();
    public sealed virtual DateTimeOffset GetDateTime();
    public sealed virtual TimeSpan GetTimeSpan();
    public sealed virtual Point GetPoint();
    public sealed virtual Size GetSize();
    public sealed virtual Rect GetRect();
    public sealed virtual void GetUInt8Array(Byte[]& array);
    public sealed virtual void GetInt16Array(Int16[]& array);
    public sealed virtual void GetUInt16Array(UInt16[]& array);
    public sealed virtual void GetInt32Array(Int32[]& array);
    public sealed virtual void GetUInt32Array(UInt32[]& array);
    public sealed virtual void GetInt64Array(Int64[]& array);
    public sealed virtual void GetUInt64Array(UInt64[]& array);
    public sealed virtual void GetSingleArray(Single[]& array);
    public sealed virtual void GetDoubleArray(Double[]& array);
    public sealed virtual void GetChar16Array(Char[]& array);
    public sealed virtual void GetBooleanArray(Boolean[]& array);
    public sealed virtual void GetStringArray(String[]& array);
    public sealed virtual void GetInspectableArray(Object[]& array);
    public sealed virtual void GetGuidArray(Guid[]& array);
    public sealed virtual void GetDateTimeArray(DateTimeOffset[]& array);
    public sealed virtual void GetTimeSpanArray(TimeSpan[]& array);
    public sealed virtual void GetPointArray(Point[]& array);
    public sealed virtual void GetSizeArray(Size[]& array);
    public sealed virtual void GetRectArray(Rect[]& array);
    private T[] CoerceArrayValue(PropertyType unboxType);
    private T CoerceScalarValue(PropertyType unboxType);
    private static object CoerceScalarValue(PropertyType type, object value, PropertyType unboxType);
    private static bool IsNumericScalarImpl(PropertyType type, object data);
    private void CheckType(PropertyType unboxType);
    private static InvalidCastException CreateExceptionForInvalidCast(PropertyType type, PropertyType unboxType);
    private static InvalidCastException CreateExceptionForInvalidCoersion(PropertyType type, object value, PropertyType unboxType, int hr);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyArrayAttribute : Attribute {
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.ReferenceArrayImpl`1 : ReferenceArrayImplBase {
    private T[] _value;
    public ReferenceArrayImpl`1(T[] obj, PropertyType type);
    public sealed virtual T[] get_Value();
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.ReferenceArrayImplBase : PropertyValueImpl {
    internal static Guid IID_IIterableOfObject;
    private IList _list;
    private IEnumerable`1<object> _enumerableOfObject;
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    internal ReferenceArrayImplBase(object data, PropertyType type);
    private static ReferenceArrayImplBase();
    public virtual void Initialize(object val, int type);
    private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
}
[DependencyReductionRootAttribute]
[McgInternalTypeAttribute]
[__BlockReflectionAttribute]
public class System.Runtime.InteropServices.WindowsRuntime.ReferenceImpl`1 : PropertyValueImpl {
    private T m_value;
    public ReferenceImpl`1(T data, int type);
    internal ReferenceImpl`1(T data, PropertyType type);
    public sealed virtual T get_Value();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReferenceUtility : object {
    internal static object GetWellKnownScalar(IPropertyValue ipv, PropertyType type);
}
[AttributeUsageAttribute("12288")]
public class System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute : Attribute {
    private string m_Name;
    public string Name { get; }
    public ReturnValueNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("5148")]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeImportAttribute : Attribute {
}
[__BlockReflectionActivateAttribute]
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal : object {
    [__BlockReflectionInvokeAttribute]
public static void AddEventHandler(Func`2<T, EventRegistrationToken> addMethod, Action`1<EventRegistrationToken> removeMethod, T handler);
    [__BlockReflectionInvokeAttribute]
public static void RemoveEventHandler(Action`1<EventRegistrationToken> removeMethod, T handler);
    [__BlockReflectionInvokeAttribute]
public static void RemoveAllEventHandlers(Action`1<EventRegistrationToken> removeMethod);
    internal static int GetRegistrationTokenCacheSize();
    internal static void CallRemoveMethods(Action`1<EventRegistrationToken> removeMethod, List`1<EventRegistrationToken> tokensToRemove);
    [__BlockReflectionInvokeAttribute]
public static IntPtr StringToHString(string s);
    [__BlockReflectionInvokeAttribute]
public static void FreeHString(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static string PtrToStringHString(IntPtr ptr);
    [__BlockReflectionInvokeAttribute]
public static IActivationFactory GetActivationFactory(Type type);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.WriteOnlyArrayAttribute : Attribute {
}
[McgIntrinsicsAttribute]
internal class System.Runtime.InteropServices.WinRTAddrOfIntrinsics : object {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_InvalidANSIString { get; }
    internal static string Arg_InvalidComObjectException { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidOleVariantTypeException { get; }
    internal static string Arg_VariantTypeNotSupported { get; }
    internal static string Arg_InvalidThreshold { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeStringPtrNotAtom { get; }
    internal static string Arg_NeedNonNegNumRequired { get; }
    internal static string Arg_NotIsomorphic { get; }
    internal static string Arg_SafeArrayRankMismatchException { get; }
    internal static string Arg_SafeArrayTypeMismatchException { get; }
    internal static string Arg_SizeOfNoTypeSizeInfo { get; }
    internal static string Arg_SizeOfNonValueType { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_NeedNonGenericType { get; }
    internal static string Argument_ObjNotComObject { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Null_HString { get; }
    internal static string BadMarshalField_Null_HString { get; }
    internal static string ArrayWithOffsetOverflow { get; }
    internal static string InvalidOperation_HCCountOverflow { get; }
    internal static string StructArrayTooLarge { get; }
    internal static string CustomPropertyProvider_DataBindingError { get; }
    internal static string CustomPropertyProvider_MissingMetadata { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_MethodAccessException_WithMethodName { get; }
    internal static string Arg_RemovedTypeInstantiated { get; }
    internal static string Arg_NotImplementedInNonCoreApiSet { get; }
    internal static string Arg_DelegateTypeNotRecognized { get; }
    internal static string Arg_NoMarshalCreatedObjectUsedOutOfTreadContext { get; }
    internal static string Arg_UnexpectedTypeKind { get; }
    internal static string Arg_UnrecognizedTypeName { get; }
    internal static string Arg_InvalidCustomTypeNameValue { get; }
    internal static string Argument_MustHaveLayoutOrBeBlittable { get; }
    internal static string TypeNameMarshalling_MissingMetadata { get; }
    internal static string Excep_EnumNotStarted { get; }
    internal static string Excep_EnumEnded { get; }
    internal static string Excep_EnumFailedVersion { get; }
    internal static string Excep_NotSupported { get; }
    internal static string Excep_CollectionBackingListTooLarge { get; }
    internal static string Excep_KeyNotFound { get; }
    internal static string Excep_KeyCollectionSet { get; }
    internal static string Excep_ValueCollectionSet { get; }
    internal static string Excep_InsufficientSpaceToCopyCollection { get; }
    internal static string Excep_IndexOutOfArrayBounds { get; }
    internal static string Excep_CannotRemoveFromEmptyCollection { get; }
    internal static string Excep_IndexLargerThanMaxValue { get; }
    internal static string Excep_IndexOutOfRange { get; }
    internal static string Excep_AddingDuplicate { get; }
    internal static string Excep_FromHResult { get; }
    internal static string Excep_InvalidMarshalAs_Param { get; }
    internal static string Excep_InvalidMarshalAs_Field { get; }
    internal static string Excep_InvalidMarshalAs_Return { get; }
    internal static string Excep_InvalidComObject_NoRCW_Wrapper { get; }
    internal static string StructMarshalling_MissingInteropData { get; }
    internal static string DelegateMarshalling_MissingInteropData { get; }
    internal static string ComTypeMarshalling_MissingInteropData { get; }
    internal static string Not_Enough_Thunks { get; }
    internal static string Arg_NativeToManagedCall { get; }
    internal static string Arg_NeedsDefaultCtor { get; }
    internal static string Arg_OutSafeHandleAsFieldNotSupported { get; }
    internal static string PropertyValue_InvalidCoersion { get; }
    internal static string PropertyValue_InvalidCast { get; }
    internal static string Arg_MustBeDelegateType { get; }
    internal static string Arg_CriticalHandleCannotBeAbstract { get; }
    internal static string Arg_CriticalHandleMustHaveDefaultCtor { get; }
    internal static string Arg_CriticalHandleReverse { get; }
    internal static string Arg_OutCriticalHandleAsFieldNotSupported { get; }
    internal static string Argument_OffsetOfFieldNotFound { get; }
    internal static string Argument_StructMustNotBeValueClass { get; }
    internal static string Argument_NeedNonGenericObject { get; }
    internal static string InvalidCast_WinRT { get; }
    internal static string InvalidCast_Com { get; }
    internal static string MissingMetadataType { get; }
    internal static string DirectUI_Empty { get; }
    internal static string PInvoke_GetProcAddress_NoName { get; }
    internal static string PInvoke_LoadLib { get; }
    internal static string PInvoke_GetProcAddress { get; }
    internal static string TypeNotDelegate { get; }
    internal static string WrongSizeArrayInNStruct { get; }
    internal static string Arg_InteropMarshalUnmappableChar { get; }
    internal static Type ResourceType { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_InvalidANSIString();
    internal static string get_Arg_InvalidComObjectException();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidOleVariantTypeException();
    internal static string get_Arg_VariantTypeNotSupported();
    internal static string get_Arg_InvalidThreshold();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeStringPtrNotAtom();
    internal static string get_Arg_NeedNonNegNumRequired();
    internal static string get_Arg_NotIsomorphic();
    internal static string get_Arg_SafeArrayRankMismatchException();
    internal static string get_Arg_SafeArrayTypeMismatchException();
    internal static string get_Arg_SizeOfNoTypeSizeInfo();
    internal static string get_Arg_SizeOfNonValueType();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_NeedNonGenericType();
    internal static string get_Argument_ObjNotComObject();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Null_HString();
    internal static string get_BadMarshalField_Null_HString();
    internal static string get_ArrayWithOffsetOverflow();
    internal static string get_InvalidOperation_HCCountOverflow();
    internal static string get_StructArrayTooLarge();
    internal static string get_CustomPropertyProvider_DataBindingError();
    internal static string get_CustomPropertyProvider_MissingMetadata();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_MethodAccessException_WithMethodName();
    internal static string get_Arg_RemovedTypeInstantiated();
    internal static string get_Arg_NotImplementedInNonCoreApiSet();
    internal static string get_Arg_DelegateTypeNotRecognized();
    internal static string get_Arg_NoMarshalCreatedObjectUsedOutOfTreadContext();
    internal static string get_Arg_UnexpectedTypeKind();
    internal static string get_Arg_UnrecognizedTypeName();
    internal static string get_Arg_InvalidCustomTypeNameValue();
    internal static string get_Argument_MustHaveLayoutOrBeBlittable();
    internal static string get_TypeNameMarshalling_MissingMetadata();
    internal static string get_Excep_EnumNotStarted();
    internal static string get_Excep_EnumEnded();
    internal static string get_Excep_EnumFailedVersion();
    internal static string get_Excep_NotSupported();
    internal static string get_Excep_CollectionBackingListTooLarge();
    internal static string get_Excep_KeyNotFound();
    internal static string get_Excep_KeyCollectionSet();
    internal static string get_Excep_ValueCollectionSet();
    internal static string get_Excep_InsufficientSpaceToCopyCollection();
    internal static string get_Excep_IndexOutOfArrayBounds();
    internal static string get_Excep_CannotRemoveFromEmptyCollection();
    internal static string get_Excep_IndexLargerThanMaxValue();
    internal static string get_Excep_IndexOutOfRange();
    internal static string get_Excep_AddingDuplicate();
    internal static string get_Excep_FromHResult();
    internal static string get_Excep_InvalidMarshalAs_Param();
    internal static string get_Excep_InvalidMarshalAs_Field();
    internal static string get_Excep_InvalidMarshalAs_Return();
    internal static string get_Excep_InvalidComObject_NoRCW_Wrapper();
    internal static string get_StructMarshalling_MissingInteropData();
    internal static string get_DelegateMarshalling_MissingInteropData();
    internal static string get_ComTypeMarshalling_MissingInteropData();
    internal static string get_Not_Enough_Thunks();
    internal static string get_Arg_NativeToManagedCall();
    internal static string get_Arg_NeedsDefaultCtor();
    internal static string get_Arg_OutSafeHandleAsFieldNotSupported();
    internal static string get_PropertyValue_InvalidCoersion();
    internal static string get_PropertyValue_InvalidCast();
    internal static string get_Arg_MustBeDelegateType();
    internal static string get_Arg_CriticalHandleCannotBeAbstract();
    internal static string get_Arg_CriticalHandleMustHaveDefaultCtor();
    internal static string get_Arg_CriticalHandleReverse();
    internal static string get_Arg_OutCriticalHandleAsFieldNotSupported();
    internal static string get_Argument_OffsetOfFieldNotFound();
    internal static string get_Argument_StructMustNotBeValueClass();
    internal static string get_Argument_NeedNonGenericObject();
    internal static string get_InvalidCast_WinRT();
    internal static string get_InvalidCast_Com();
    internal static string get_MissingMetadataType();
    internal static string get_DirectUI_Empty();
    internal static string get_PInvoke_GetProcAddress_NoName();
    internal static string get_PInvoke_LoadLib();
    internal static string get_PInvoke_GetProcAddress();
    internal static string get_TypeNotDelegate();
    internal static string get_WrongSizeArrayInNStruct();
    internal static string get_Arg_InteropMarshalUnmappableChar();
    internal static Type get_ResourceType();
}
[GuidAttribute("02b51929-c1c4-4a7e-8940-0312b5c18500")]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public interface Windows.Foundation.Collections.IKeyValuePair`2 {
    [__BlockReflectionAttribute]
public abstract virtual K get_Key();
    [__BlockReflectionAttribute]
public abstract virtual V get_Value();
}
[DependencyReductionRootAttribute]
[ExplicitScopeAttribute("HiddenScope, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public interface Windows.Foundation.IReference`1 {
    [McgAccessorAttribute("0", "Value")]
[__BlockReflectionAttribute]
public abstract virtual T get_Value();
}
public class Windows.Foundation.Point : ValueType {
    internal float _x;
    internal float _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
}
public class Windows.Foundation.Rect : ValueType {
    private float _x;
    private float _y;
    private float _width;
    private float _height;
    private static double EmptyX;
    private static double EmptyY;
    private static double EmptyWidth;
    private static double EmptyHeight;
    private static Rect s_empty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point location, Size size);
    private static Rect();
    internal static Rect Create(double x, double y, double width, double height);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public bool Contains(Point point);
    public void Intersect(Rect rect);
    public void Union(Rect rect);
    public void Union(Point point);
    private bool ContainsInternal(double x, double y);
    internal bool IntersectsWith(Rect rect);
    private static Rect CreateEmptyRect();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public bool Equals(Rect value);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Windows.Foundation.Size : ValueType {
    private float _width;
    private float _height;
    private static Size s_empty;
    public double Width { get; public set; }
    public double Height { get; public set; }
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public Size(double width, double height);
    private static Size();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static Size get_Empty();
    public bool get_IsEmpty();
    private static Size CreateEmptySize();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    private static bool Equals(Size size1, Size size2);
    public virtual string ToString();
}
internal static class Windows.Foundation.TokenizerHelper : object {
    internal static char GetNumericListSeparator(IFormatProvider provider);
}
