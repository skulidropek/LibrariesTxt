internal static class FxResources.System.Net.HttpListener.SR : object {
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
internal class System.Net.AuthenticationTypes : object {
    internal static string NTLM;
    internal static string Negotiate;
    internal static string Basic;
}
internal enum System.Net.BoundaryType : Enum {
    public int value__;
    public static BoundaryType ContentLength;
    public static BoundaryType Chunked;
    public static BoundaryType Multipart;
    public static BoundaryType None;
    public static BoundaryType Invalid;
}
internal class System.Net.CaseInsensitiveAscii : object {
    internal static CaseInsensitiveAscii StaticInstance;
    internal static Byte[] AsciiToLower;
    private static CaseInsensitiveAscii();
    public sealed virtual int GetHashCode(object myObject);
    public sealed virtual int Compare(object firstObject, object secondObject);
    private int FastGetHashCode(string myString);
    public sealed virtual bool Equals(object firstObject, object secondObject);
}
internal class System.Net.ChunkedInputStream : HttpRequestStream {
    private ChunkStream _decoder;
    private HttpListenerContext _context;
    private bool _no_more_data;
    public ChunkStream Decoder { get; public set; }
    public ChunkedInputStream(HttpListenerContext context, Stream stream, Byte[] buffer, int offset, int length);
    public ChunkStream get_Decoder();
    public void set_Decoder(ChunkStream value);
    protected virtual int ReadCore(Byte[] buffer, int offset, int count);
    protected virtual IAsyncResult BeginReadCore(Byte[] buffer, int offset, int size, AsyncCallback cback, object state);
    private void OnRead(IAsyncResult base_ares);
    public virtual int EndRead(IAsyncResult asyncResult);
}
internal class System.Net.ChunkStream : object {
    internal WebHeaderCollection _headers;
    private int _chunkSize;
    private int _chunkRead;
    private int _totalWritten;
    private State _state;
    private StringBuilder _saved;
    private bool _sawCR;
    private bool _gotit;
    private int _trailerState;
    private List`1<Chunk> _chunks;
    public bool WantMore { get; }
    public bool DataAvailable { get; }
    public int TotalDataSize { get; }
    public int ChunkLeft { get; }
    public ChunkStream(WebHeaderCollection headers);
    public void ResetBuffer();
    public int Read(Byte[] buffer, int offset, int size);
    private int ReadFromChunks(Byte[] buffer, int offset, int size);
    public void Write(Byte[] buffer, int offset, int size);
    private void InternalWrite(Byte[] buffer, Int32& offset, int size);
    public bool get_WantMore();
    public bool get_DataAvailable();
    public int get_TotalDataSize();
    public int get_ChunkLeft();
    private State ReadBody(Byte[] buffer, Int32& offset, int size);
    private State GetChunkSize(Byte[] buffer, Int32& offset, int size);
    private static string RemoveChunkExtension(string input);
    private State ReadCRLF(Byte[] buffer, Int32& offset, int size);
    private State ReadTrailer(Byte[] buffer, Int32& offset, int size);
    private static void ThrowProtocolViolation(string message);
}
[ExtensionAttribute]
internal static class System.Net.CookieCollectionExtensions : object {
    private static Func`4<CookieCollection, Cookie, bool, int> s_internalAddFunc;
    [ExtensionAttribute]
public static int InternalAdd(CookieCollection cookieCollection, Cookie cookie, bool isStrict);
}
internal static class System.Net.CookieComparer : object {
    internal static int Compare(Cookie left, Cookie right);
}
[ExtensionAttribute]
internal static class System.Net.CookieExtensions : object {
    private static Func`2<Cookie, string> s_toServerStringFunc;
    private static Func`2<Cookie, Cookie> s_cloneFunc;
    private static Func`2<Cookie, CookieVariant> s_getVariantFunc;
    [ExtensionAttribute]
public static string ToServerString(Cookie cookie);
    [ExtensionAttribute]
public static Cookie Clone(Cookie cookie);
    [ExtensionAttribute]
public static bool IsRfc2965Variant(Cookie cookie);
}
internal static class System.Net.CookieFields : object {
    internal static string CommentAttributeName;
    internal static string CommentUrlAttributeName;
    internal static string DiscardAttributeName;
    internal static string DomainAttributeName;
    internal static string ExpiresAttributeName;
    internal static string MaxAgeAttributeName;
    internal static string PathAttributeName;
    internal static string PortAttributeName;
    internal static string SecureAttributeName;
    internal static string VersionAttributeName;
    internal static string HttpOnlyAttributeName;
}
internal class System.Net.CookieParser : object {
    private CookieTokenizer _tokenizer;
    private Cookie _savedCookie;
    private static Func`3<Cookie, string, bool> s_internalSetNameMethod;
    private static FieldInfo s_isQuotedDomainField;
    private static FieldInfo s_isQuotedVersionField;
    private static Func`3<Cookie, string, bool> InternalSetNameMethod { get; }
    private static FieldInfo IsQuotedDomainField { get; }
    private static FieldInfo IsQuotedVersionField { get; }
    internal CookieParser(string cookieString);
    private static CookieParser();
    internal string GetString();
    private static Func`3<Cookie, string, bool> get_InternalSetNameMethod();
    private static FieldInfo get_IsQuotedDomainField();
    private static FieldInfo get_IsQuotedVersionField();
    internal Cookie Get();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
    internal bool EndofHeader();
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : object {
    private bool _eofCookie;
    private int _index;
    private int _length;
    private string _name;
    private bool _quoted;
    private int _start;
    private CookieToken _token;
    private int _tokenLength;
    private string _tokenStream;
    private string _value;
    private int _cookieStartIndex;
    private int _cookieLength;
    private static RecognizedAttribute[] s_recognizedAttributes;
    private static RecognizedAttribute[] s_recognizedServerAttributes;
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string GetCookieString();
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
internal enum System.Net.EntitySendFormat : Enum {
    public int value__;
    public static EntitySendFormat ContentLength;
    public static EntitySendFormat Chunked;
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal class System.Net.HttpConnection : object {
    private static AsyncCallback s_onreadCallback;
    private static int BufferSize;
    private Socket _socket;
    private Stream _stream;
    private HttpEndPointListener _epl;
    private MemoryStream _memoryStream;
    private Byte[] _buffer;
    private HttpListenerContext _context;
    private StringBuilder _currentLine;
    private ListenerPrefix _prefix;
    private HttpRequestStream _requestStream;
    private HttpResponseStream _responseStream;
    private bool _chunked;
    private int _reuses;
    private bool _contextBound;
    private bool _secure;
    private X509Certificate _cert;
    private int _timeout;
    private Timer _timer;
    private IPEndPoint _localEndPoint;
    private HttpListener _lastListener;
    private Int32[] _clientCertErrors;
    private X509Certificate2 _clientCert;
    private SslStream _sslStream;
    private InputState _inputState;
    private LineState _lineState;
    private int _position;
    internal Int32[] ClientCertificateErrors { get; }
    internal X509Certificate2 ClientCertificate { get; }
    internal SslStream SslStream { get; }
    public Stream ConnectedStream { get; }
    public bool IsClosed { get; }
    public int Reuses { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public bool IsSecure { get; }
    public ListenerPrefix Prefix { get; public set; }
    public HttpConnection(Socket sock, HttpEndPointListener epl, bool secure, X509Certificate cert);
    private static HttpConnection();
    internal Int32[] get_ClientCertificateErrors();
    internal X509Certificate2 get_ClientCertificate();
    internal SslStream get_SslStream();
    private void Init();
    public Stream get_ConnectedStream();
    public bool get_IsClosed();
    public int get_Reuses();
    public IPEndPoint get_LocalEndPoint();
    public IPEndPoint get_RemoteEndPoint();
    public bool get_IsSecure();
    public ListenerPrefix get_Prefix();
    public void set_Prefix(ListenerPrefix value);
    private void OnTimeout(object unused);
    public void BeginReadRequest();
    public HttpRequestStream GetRequestStream(bool chunked, long contentlength);
    public HttpResponseStream GetResponseStream();
    private static void OnRead(IAsyncResult ares);
    private void OnReadInternal(IAsyncResult ares);
    private void RemoveConnection();
    private bool ProcessInput(MemoryStream ms);
    private string ReadLine(Byte[] buffer, int offset, int len, Int32& used);
    public void SendError(string msg, int status);
    public void SendError();
    private void Unbind();
    public void Close();
    private void CloseSocket();
    internal void Close(bool force);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__27_0(object t, X509Certificate c, X509Chain ch, SslPolicyErrors e);
}
internal class System.Net.HttpEndPointListener : object {
    private HttpListener _listener;
    private IPEndPoint _endpoint;
    private Socket _socket;
    private Dictionary`2<HttpConnection, HttpConnection> _unregisteredConnections;
    private Dictionary`2<ListenerPrefix, HttpListener> _prefixes;
    private List`1<ListenerPrefix> _unhandledPrefixes;
    private List`1<ListenerPrefix> _allPrefixes;
    private X509Certificate _cert;
    private bool _secure;
    internal HttpListener Listener { get; }
    public HttpEndPointListener(HttpListener listener, IPAddress addr, int port, bool secure);
    internal HttpListener get_Listener();
    private void Accept(SocketAsyncEventArgs e);
    private static void ProcessAccept(SocketAsyncEventArgs args);
    private static void OnAccept(object sender, SocketAsyncEventArgs e);
    internal void RemoveConnection(HttpConnection conn);
    public bool BindContext(HttpListenerContext context);
    public void UnbindContext(HttpListenerContext context);
    private HttpListener SearchListener(Uri uri, ListenerPrefix& prefix);
    private HttpListener MatchFromList(string host, string path, List`1<ListenerPrefix> list, ListenerPrefix& prefix);
    private void AddSpecial(List`1<ListenerPrefix> list, ListenerPrefix prefix);
    private bool RemoveSpecial(List`1<ListenerPrefix> list, ListenerPrefix prefix);
    private void CheckIfRemove();
    public void Close();
    public void AddPrefix(ListenerPrefix prefix, HttpListener listener);
    public void RemovePrefix(ListenerPrefix prefix, HttpListener listener);
}
internal class System.Net.HttpEndPointManager : object {
    private static Dictionary`2<IPAddress, Dictionary`2<int, HttpEndPointListener>> s_ipEndPoints;
    private static HttpEndPointManager();
    public static void AddListener(HttpListener listener);
    public static void AddPrefix(string prefix, HttpListener listener);
    private static void AddPrefixInternal(string p, HttpListener listener);
    private static HttpEndPointListener GetEPListener(string host, int port, HttpListener listener, bool secure);
    public static void RemoveEndPoint(HttpEndPointListener epl, IPEndPoint ep);
    public static void RemoveListener(HttpListener listener);
    public static void RemovePrefix(string prefix, HttpListener listener);
    private static void RemovePrefixInternal(string prefix, HttpListener listener);
}
internal class System.Net.HttpHeaderStrings : object {
    internal static string Charset;
    internal static string NetCoreServerName;
    internal static string Close;
    internal static string Chunked;
    internal static string KeepAlive;
}
internal static class System.Net.HttpKnownHeaderNames : object {
    public static string Accept;
    public static string AcceptCharset;
    public static string AcceptEncoding;
    public static string AcceptLanguage;
    public static string AcceptPatch;
    public static string AcceptRanges;
    public static string AccessControlAllowCredentials;
    public static string AccessControlAllowHeaders;
    public static string AccessControlAllowMethods;
    public static string AccessControlAllowOrigin;
    public static string AccessControlExposeHeaders;
    public static string AccessControlMaxAge;
    public static string Age;
    public static string Allow;
    public static string AltSvc;
    public static string Authorization;
    public static string CacheControl;
    public static string Connection;
    public static string ContentDisposition;
    public static string ContentEncoding;
    public static string ContentLanguage;
    public static string ContentLength;
    public static string ContentLocation;
    public static string ContentMD5;
    public static string ContentRange;
    public static string ContentSecurityPolicy;
    public static string ContentType;
    public static string Cookie;
    public static string Cookie2;
    public static string Date;
    public static string ETag;
    public static string Expect;
    public static string Expires;
    public static string From;
    public static string Host;
    public static string IfMatch;
    public static string IfModifiedSince;
    public static string IfNoneMatch;
    public static string IfRange;
    public static string IfUnmodifiedSince;
    public static string KeepAlive;
    public static string LastModified;
    public static string Link;
    public static string Location;
    public static string MaxForwards;
    public static string Origin;
    public static string P3P;
    public static string Pragma;
    public static string ProxyAuthenticate;
    public static string ProxyAuthorization;
    public static string ProxyConnection;
    public static string PublicKeyPins;
    public static string Range;
    public static string Referer;
    public static string RetryAfter;
    public static string SecWebSocketAccept;
    public static string SecWebSocketExtensions;
    public static string SecWebSocketKey;
    public static string SecWebSocketProtocol;
    public static string SecWebSocketVersion;
    public static string Server;
    public static string SetCookie;
    public static string SetCookie2;
    public static string StrictTransportSecurity;
    public static string TE;
    public static string TSV;
    public static string Trailer;
    public static string TransferEncoding;
    public static string Upgrade;
    public static string UpgradeInsecureRequests;
    public static string UserAgent;
    public static string Vary;
    public static string Via;
    public static string WWWAuthenticate;
    public static string Warning;
    public static string XAspNetVersion;
    public static string XContentDuration;
    public static string XContentTypeOptions;
    public static string XFrameOptions;
    public static string XMSEdgeRef;
    public static string XPoweredBy;
    public static string XRequestID;
    public static string XUACompatible;
}
public class System.Net.HttpListener : object {
    private object _internalLock;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private HttpListenerPrefixCollection _prefixes;
    internal Hashtable _uriPrefixes;
    private bool _ignoreWriteExceptions;
    private ServiceNameStore _defaultServiceNames;
    private HttpListenerTimeoutManager _timeoutManager;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private AuthenticationSchemeSelector _authenticationDelegate;
    private AuthenticationSchemes _authenticationScheme;
    private ExtendedProtectionSelector _extendedProtectionSelectorDelegate;
    private string _realm;
    private Dictionary`2<HttpListenerContext, HttpListenerContext> _listenerContexts;
    private List`1<HttpListenerContext> _contextQueue;
    private List`1<ListenerAsyncResult> _asyncWaitQueue;
    private Dictionary`2<HttpConnection, HttpConnection> _connections;
    private bool _unsafeConnectionNtlmAuthentication;
    internal ICollection PrefixCollection { get; }
    public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    public string Realm { get; public set; }
    public bool IsListening { get; }
    public bool IgnoreWriteExceptions { get; public set; }
    public static bool IsSupported { get; }
    public HttpListenerTimeoutManager TimeoutManager { get; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    internal ICollection get_PrefixCollection();
    public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ServiceNameCollection get_DefaultServiceNames();
    public HttpListenerPrefixCollection get_Prefixes();
    internal void AddPrefix(string uriPrefix);
    internal bool ContainsPrefix(string uriPrefix);
    internal bool RemovePrefix(string uriPrefix);
    internal void RemoveAll(bool clear);
    public string get_Realm();
    public void set_Realm(string value);
    public bool get_IsListening();
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public Task`1<HttpListenerContext> GetContextAsync();
    public void Close();
    internal void CheckDisposed();
    private sealed virtual override void System.IDisposable.Dispose();
    public static bool get_IsSupported();
    public HttpListenerTimeoutManager get_TimeoutManager();
    private void AddPrefixCore(string uriPrefix);
    private void RemovePrefixCore(string uriPrefix);
    public void Start();
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    public void Stop();
    public void Abort();
    private void Dispose();
    private void Close(bool force);
    internal void UnregisterContext(HttpListenerContext context);
    internal void AddConnection(HttpConnection cnc);
    internal void RemoveConnection(HttpConnection cnc);
    internal void RegisterContext(HttpListenerContext context);
    private void Cleanup(bool close_existing);
    private HttpListenerContext GetContextFromQueue();
    public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerContext context);
    public HttpListenerContext GetContext();
    internal SslStream CreateSslStream(Stream innerStream, bool ownsStream, RemoteCertificateValidationCallback callback);
    internal X509Certificate LoadCertificateAndKey(IPAddress addr, int port);
}
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    [CompilerGeneratedAttribute]
public virtual string get_Password();
}
public class System.Net.HttpListenerContext : object {
    internal HttpListener _listener;
    private HttpListenerResponse _response;
    private IPrincipal _user;
    [CompilerGeneratedAttribute]
private HttpListenerRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationSchemes <AuthenticationSchemes>k__BackingField;
    private HttpConnection _connection;
    [CompilerGeneratedAttribute]
private int <ErrorStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public HttpListenerRequest Request { get; }
    public IPrincipal User { get; }
    internal AuthenticationSchemes AuthenticationSchemes { get; internal set; }
    public HttpListenerResponse Response { get; }
    internal int ErrorStatus { get; internal set; }
    internal string ErrorMessage { get; internal set; }
    internal bool HaveError { get; }
    internal HttpConnection Connection { get; }
    internal HttpListenerContext(HttpConnection connection);
    [CompilerGeneratedAttribute]
public HttpListenerRequest get_Request();
    public IPrincipal get_User();
    [CompilerGeneratedAttribute]
internal AuthenticationSchemes get_AuthenticationSchemes();
    [CompilerGeneratedAttribute]
internal void set_AuthenticationSchemes(AuthenticationSchemes value);
    public HttpListenerResponse get_Response();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
    [CompilerGeneratedAttribute]
internal int get_ErrorStatus();
    [CompilerGeneratedAttribute]
internal void set_ErrorStatus(int value);
    [CompilerGeneratedAttribute]
internal string get_ErrorMessage();
    [CompilerGeneratedAttribute]
internal void set_ErrorMessage(string value);
    internal bool get_HaveError();
    internal HttpConnection get_Connection();
    internal void ParseAuthentication(AuthenticationSchemes expectedSchemes);
    internal IPrincipal ParseBasicAuthentication(string authData);
    internal static bool IsBasicHeader(string header);
    internal static bool TryParseBasicAuth(string headerValue, HttpStatusCode& errorCode, String& username, String& password);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [EditorBrowsableAttribute("1")]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.HttpListenerPrefixCollection : object {
    private HttpListener _httpListener;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual int get_Count();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual bool Contains(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    public sealed virtual void Clear();
}
public class System.Net.HttpListenerRequest : object {
    private CookieCollection _cookies;
    private Nullable`1<bool> _keepAlive;
    private string _rawUrl;
    private Uri _requestUri;
    private Version _version;
    [CompilerGeneratedAttribute]
private ListenerClientCertState <ClientCertState>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ClientCertificate>k__BackingField;
    private long _contentLength;
    private bool _clSet;
    private WebHeaderCollection _headers;
    private string _method;
    private Stream _inputStream;
    private HttpListenerContext _context;
    private bool _isChunked;
    private static Byte[] s_100continue;
    private static Char[] s_separators;
    [CompilerGeneratedAttribute]
private Guid <RequestTraceIdentifier>k__BackingField;
    public String[] AcceptTypes { get; }
    public String[] UserLanguages { get; }
    public CookieCollection Cookies { get; }
    public Encoding ContentEncoding { get; }
    public string ContentType { get; }
    public bool IsLocal { get; }
    public bool IsWebSocketRequest { get; }
    public bool KeepAlive { get; }
    public NameValueCollection QueryString { get; }
    public string RawUrl { get; }
    private string RequestScheme { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    public Uri UrlReferrer { get; }
    public Uri Url { get; }
    public Version ProtocolVersion { get; }
    internal ListenerClientCertState ClientCertState { get; internal set; }
    internal X509Certificate2 ClientCertificate { get; internal set; }
    public int ClientCertificateError { get; }
    public long ContentLength64 { get; }
    public bool HasEntityBody { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsSecureConnection { get; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public Guid RequestTraceIdentifier { get; }
    public string ServiceName { get; }
    public TransportContext TransportContext { get; }
    private Uri RequestUri { get; }
    private bool SupportsWebSockets { get; }
    internal HttpListenerRequest(HttpListenerContext context);
    private static HttpListenerRequest();
    public String[] get_AcceptTypes();
    public String[] get_UserLanguages();
    private CookieCollection ParseCookies(Uri uri, string setCookieHeader);
    public CookieCollection get_Cookies();
    public Encoding get_ContentEncoding();
    public string get_ContentType();
    public bool get_IsLocal();
    public bool get_IsWebSocketRequest();
    public bool get_KeepAlive();
    public NameValueCollection get_QueryString();
    public string get_RawUrl();
    private string get_RequestScheme();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    public Uri get_UrlReferrer();
    public Uri get_Url();
    public Version get_ProtocolVersion();
    public X509Certificate2 GetClientCertificate();
    public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public Task`1<X509Certificate2> GetClientCertificateAsync();
    [CompilerGeneratedAttribute]
internal ListenerClientCertState get_ClientCertState();
    [CompilerGeneratedAttribute]
internal void set_ClientCertState(ListenerClientCertState value);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_ClientCertificate();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificate(X509Certificate2 value);
    public int get_ClientCertificateError();
    internal void SetRequestLine(string req);
    private static bool MaybeUri(string s);
    private static bool IsPredefinedScheme(string scheme);
    internal void FinishInitialization();
    internal static string Unquote(string str);
    internal void AddHeader(string header);
    internal bool FlushInput();
    private X509Certificate2 GetClientCertificateCore();
    private int GetClientCertificateErrorCore();
    public long get_ContentLength64();
    public bool get_HasEntityBody();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsSecureConnection();
    public IPEndPoint get_LocalEndPoint();
    public IPEndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public Guid get_RequestTraceIdentifier();
    private IAsyncResult BeginGetClientCertificateCore(AsyncCallback requestCallback, object state);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public string get_ServiceName();
    public TransportContext get_TransportContext();
    private Uri get_RequestUri();
    private bool get_SupportsWebSockets();
}
internal class System.Net.HttpListenerRequestUriBuilder : object {
    private static Encoding s_utf8Encoding;
    private static Encoding s_ansiEncoding;
    private string _rawUri;
    private string _cookedUriScheme;
    private string _cookedUriHost;
    private string _cookedUriPath;
    private string _cookedUriQuery;
    private StringBuilder _requestUriString;
    private List`1<byte> _rawOctets;
    private string _rawPath;
    private Uri _requestUri;
    private HttpListenerRequestUriBuilder(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private static HttpListenerRequestUriBuilder();
    public static Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private Uri Build();
    private void BuildRequestUriUsingCookedPath();
    private void BuildRequestUriUsingRawPath();
    private static Encoding GetEncoding(EncodingType type);
    private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding);
    private ParsingResult ParseRawPath(Encoding encoding);
    private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint);
    private bool AddPercentEncodedOctetToRawOctetsList(Encoding encoding, string escapedCharacter);
    private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding);
    private static void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets);
    private static string GetOctetsAsString(IEnumerable`1<byte> octets);
    private static string GetPath(string uriString);
    private static string AddSlashToAsteriskOnlyPath(string path);
}
public class System.Net.HttpListenerResponse : object {
    private BoundaryType _boundaryType;
    private CookieCollection _cookies;
    private HttpListenerContext _httpContext;
    private bool _keepAlive;
    private HttpResponseStream _responseStream;
    private string _statusDescription;
    private WebHeaderCollection _webHeaders;
    [CompilerGeneratedAttribute]
private Encoding <ContentEncoding>k__BackingField;
    private static Int32[] s_noResponseBody;
    private long _contentLength;
    private Version _version;
    private int _statusCode;
    internal object _headersLock;
    private bool _forceCloseChunked;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SentHeaders>k__BackingField;
    public WebHeaderCollection Headers { get; public set; }
    public Encoding ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    private HttpListenerContext HttpListenerContext { get; }
    private HttpListenerRequest HttpListenerRequest { get; }
    internal EntitySendFormat EntitySendFormat { get; internal set; }
    public bool SendChunked { get; public set; }
    public long ContentLength64 { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    public string RedirectLocation { get; public set; }
    public string StatusDescription { get; public set; }
    internal bool ForceCloseChunked { get; }
    public Version ProtocolVersion { get; public set; }
    public int StatusCode { get; public set; }
    private bool Disposed { get; private set; }
    internal bool SentHeaders { get; internal set; }
    internal HttpListenerResponse(HttpListenerContext context);
    private static HttpListenerResponse();
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    [CompilerGeneratedAttribute]
public Encoding get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(Encoding value);
    public string get_ContentType();
    public void set_ContentType(string value);
    private HttpListenerContext get_HttpListenerContext();
    private HttpListenerRequest get_HttpListenerRequest();
    internal EntitySendFormat get_EntitySendFormat();
    internal void set_EntitySendFormat(EntitySendFormat value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    private static bool CanSendResponseBody(int responseCode);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    public string get_RedirectLocation();
    public void set_RedirectLocation(string value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public void AddHeader(string name, string value);
    public void AppendHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    private void ComputeCookies();
    public void Redirect(string url);
    public void SetCookie(Cookie cookie);
    private sealed virtual override void System.IDisposable.Dispose();
    private void CheckDisposed();
    private void CheckSentHeaders();
    internal bool get_ForceCloseChunked();
    private void EnsureResponseStream();
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public int get_StatusCode();
    public void set_StatusCode(int value);
    private void Dispose();
    public void Close();
    public void Abort();
    private void Close(bool force);
    public void Close(Byte[] responseEntity, bool willBlock);
    public void CopyFrom(HttpListenerResponse templateResponse);
    internal void SendHeaders(bool closing, MemoryStream ms, bool isWebSocketHandshake);
    private static bool HeaderCanHaveEmptyValue(string name);
    private static string FormatHeaders(WebHeaderCollection headers);
    [CompilerGeneratedAttribute]
private bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SentHeaders();
    [CompilerGeneratedAttribute]
internal void set_SentHeaders(bool value);
}
public class System.Net.HttpListenerTimeoutManager : object {
    private TimeSpan _drainEntityBody;
    private TimeSpan _idleConnection;
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    internal HttpListenerTimeoutManager(HttpListener listener);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
    private void ValidateTimeout(TimeSpan value);
}
internal class System.Net.HttpRequestStream : Stream {
    private Byte[] _buffer;
    private int _offset;
    private int _length;
    private long _remainingBody;
    protected bool _closed;
    private Stream _stream;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Closed { get; }
    internal HttpRequestStream(Stream stream, Byte[] buffer, int offset, int length);
    internal HttpRequestStream(Stream stream, Byte[] buffer, int offset, int length, long contentlength);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal bool get_Closed();
    protected virtual void Dispose(bool disposing);
    private int FillFromBuffer(Byte[] buffer, int offset, int count);
    protected virtual int ReadCore(Byte[] buffer, int offset, int size);
    protected virtual IAsyncResult BeginReadCore(Byte[] buffer, int offset, int size, AsyncCallback cback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
}
internal class System.Net.HttpResponseStream : Stream {
    private bool _closed;
    private HttpListenerResponse _response;
    private bool _ignore_errors;
    private bool _trailer_sent;
    private Stream _stream;
    private static Byte[] s_crlf;
    internal bool Closed { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpResponseStream(Stream stream, HttpListenerResponse response, bool ignore_errors);
    private static HttpResponseStream();
    internal bool get_Closed();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    private void DisposeCore();
    [AsyncStateMachineAttribute("System.Net.HttpResponseStream/<WriteWebSocketHandshakeHeadersAsync>d__31")]
internal Task WriteWebSocketHandshakeHeadersAsync();
    private MemoryStream GetHeaders(bool closing, bool isWebSocketHandshake);
    private static Byte[] GetChunkSizeBytes(int size, bool final);
    internal void InternalWrite(Byte[] buffer, int offset, int count);
    internal Task InternalWriteAsync(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Net.HttpResponseStream/<InternalWriteIgnoreErrorsAsync>d__37")]
private Task InternalWriteIgnoreErrorsAsync(Byte[] buffer, int offset, int count);
    private void WriteCore(Byte[] buffer, int offset, int size);
    private IAsyncResult BeginWriteCore(Byte[] buffer, int offset, int size, AsyncCallback cback, object state);
    private void EndWriteCore(IAsyncResult asyncResult);
}
internal static class System.Net.HttpStatusDescription : object {
    internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal class System.Net.HttpStreamAsyncResult : object {
    private object _locker;
    private ManualResetEvent _handle;
    private bool _completed;
    internal object _parent;
    internal Byte[] _buffer;
    internal int _offset;
    internal int _count;
    internal AsyncCallback _callback;
    internal object _state;
    internal int _synchRead;
    internal Exception _error;
    internal bool _endCalled;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal HttpStreamAsyncResult(object parent);
    public void Complete(Exception e);
    public void Complete();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void <Complete>b__14_0();
}
internal class System.Net.LazyAsyncResult : object {
    private static int HighBit;
    private static int ForceAsyncCount;
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _errorCode;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; protected set; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack, object result);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    protected void set_AsyncCallback(AsyncCallback value);
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    [ConditionalAttribute("DEBUG")]
protected void DebugProtectState(bool protect);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
internal class System.Net.ListenerAsyncResult : object {
    private ManualResetEvent _handle;
    private bool _synch;
    private bool _completed;
    private AsyncCallback _cb;
    private object _state;
    private Exception _exception;
    private HttpListenerContext _context;
    private object _locker;
    private ListenerAsyncResult _forward;
    internal HttpListener _parent;
    internal bool _endCalled;
    internal bool _inGet;
    private static WaitCallback s_invokeCB;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public ListenerAsyncResult(HttpListener parent, AsyncCallback cb, object state);
    private static ListenerAsyncResult();
    internal void Complete(Exception exc);
    private static void InvokeCallback(object o);
    internal void Complete(HttpListenerContext context);
    internal void Complete(HttpListenerContext context, bool synch);
    internal HttpListenerContext GetContext();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
}
internal enum System.Net.ListenerClientCertState : Enum {
    public int value__;
    public static ListenerClientCertState NotInitialized;
    public static ListenerClientCertState InProgress;
    public static ListenerClientCertState Completed;
}
internal class System.Net.ListenerPrefix : object {
    private string _original;
    private string _host;
    private ushort _port;
    private string _path;
    private bool _secure;
    private IPAddress[] _addresses;
    internal HttpListener _listener;
    public IPAddress[] Addresses { get; public set; }
    public bool Secure { get; }
    public string Host { get; }
    public int Port { get; }
    public string Path { get; }
    public ListenerPrefix(string prefix);
    public virtual string ToString();
    public IPAddress[] get_Addresses();
    public void set_Addresses(IPAddress[] value);
    public bool get_Secure();
    public string get_Host();
    public int get_Port();
    public string get_Path();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private void Parse(string uri);
}
internal class System.Net.ListenerPrefixEnumerator : object {
    private IEnumerator _enumerator;
    public string Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ListenerPrefixEnumerator(IEnumerator enumerator);
    public sealed virtual string get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static string MissingMember;
    private static string NullInstance;
    private static string StaticMethodObject;
    private static string NoParameters;
    private static int MaxDumpSize;
    private static int EnterEventId;
    private static int ExitEventId;
    private static int AssociateEventId;
    private static int InfoEventId;
    private static int ErrorEventId;
    private static int CriticalFailureEventId;
    private static int DumpArrayEventId;
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int NextAvailableEventId;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, object arg1, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(object arg);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(FormattableString arg);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
}
internal class System.Net.ServiceNameStore : object {
    private List`1<string> _serviceNames;
    private ServiceNameCollection _serviceNameCollection;
    public ServiceNameCollection ServiceNames { get; }
    public ServiceNameCollection get_ServiceNames();
    private static string NormalizeServiceName(string inputServiceName);
    private bool AddSingleServiceName(string spn);
    public bool Add(string uriPrefix);
    public bool Remove(string uriPrefix);
    private bool Contains(string newServiceName);
    public void Clear();
    private string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings);
    public string BuildSimpleServiceName(string uriPrefix);
    public String[] BuildServiceNames(string uriPrefix);
}
internal static class System.Net.UriScheme : object {
    public static string File;
    public static string Ftp;
    public static string Gopher;
    public static string Http;
    public static string Https;
    public static string News;
    public static string NetPipe;
    public static string NetTcp;
    public static string Nntp;
    public static string Mailto;
    public static string Ws;
    public static string Wss;
    public static string SchemeDelimiter;
}
internal static class System.Net.WebHeaderEncoding : object {
    private static Encoding s_utf8Decoder;
    private static WebHeaderEncoding();
    internal static string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal static string GetString(Byte* pBytes, int byteCount);
    internal static int GetByteCount(string myString);
    internal static void GetBytes(string myString, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    internal static Byte[] GetBytes(string myString);
    internal static string DecodeUtf8FromString(string input);
}
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    private Uri _requestUri;
    private NameValueCollection _headers;
    private CookieCollection _cookieCollection;
    private IPrincipal _user;
    private bool _isAuthenticated;
    private bool _isLocal;
    private bool _isSecureConnection;
    private string _origin;
    private IEnumerable`1<string> _secWebSocketProtocols;
    private string _secWebSocketVersion;
    private string _secWebSocketKey;
    private WebSocket _webSocket;
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket);
    public virtual Uri get_RequestUri();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual string get_SecWebSocketKey();
    public virtual CookieCollection get_CookieCollection();
    public virtual IPrincipal get_User();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual WebSocket get_WebSocket();
    private static IPrincipal CopyPrincipal(IPrincipal user);
}
internal static class System.Net.WebSockets.HttpWebSocket : object {
    internal static string SecWebSocketKeyGuid;
    internal static string WebSocketUpgradeToken;
    internal static int DefaultReceiveBufferSize;
    internal static int DefaultClientSendBufferSize;
    internal static int MinSendBufferSize;
    internal static int MinReceiveBufferSize;
    internal static int MaxBufferSize;
    private static string SupportedVersion;
    private static bool WebSocketsSupported;
    internal static string GetSecWebSocketAcceptString(string secWebSocketKey);
    internal static bool ProcessWebSocketProtocolHeader(string clientSecWebSocketProtocol, string subProtocol, String& acceptProtocol);
    internal static void ValidateOptions(string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval);
    private static void ValidateWebSocketHeaders(HttpListenerContext context);
    [AsyncStateMachineAttribute("System.Net.WebSockets.HttpWebSocket/<AcceptWebSocketAsyncCore>d__12")]
internal static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsyncCore(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, Nullable`1<ArraySegment`1<byte>> internalBuffer);
}
internal static class System.Net.WebSockets.WebSocketValidate : object {
    internal static int MaxControlFramePayloadLength;
    private static int CloseStatusCodeAbort;
    private static int CloseStatusCodeFailedTLSHandshake;
    private static int InvalidCloseStatusCodesFrom;
    private static int InvalidCloseStatusCodesTo;
    private static string Separators;
    internal static void ThrowIfInvalidState(WebSocketState currentState, bool isDisposed, WebSocketState[] validStates);
    internal static void ValidateSubprotocol(string subProtocol);
    internal static void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription);
    internal static void ThrowPlatformNotSupportedException();
    internal static void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName);
    internal static void ValidateBuffer(Byte[] buffer, int offset, int count);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string net_log_listener_delegate_exception { get; }
    internal static string net_log_listener_unsupported_authentication_scheme { get; }
    internal static string net_log_listener_unmatched_authentication_scheme { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_listener_cannot_set_custom_cbt { get; }
    internal static string net_listener_detach_error { get; }
    internal static string net_listener_scheme { get; }
    internal static string net_listener_host { get; }
    internal static string net_listener_not_supported { get; }
    internal static string net_listener_mustcall { get; }
    internal static string net_listener_slash { get; }
    internal static string net_listener_already { get; }
    internal static string net_log_listener_no_cbt_disabled { get; }
    internal static string net_log_listener_no_cbt_http { get; }
    internal static string net_log_listener_no_cbt_trustedproxy { get; }
    internal static string net_log_listener_cbt { get; }
    internal static string net_log_listener_no_spn_kerberos { get; }
    internal static string net_log_listener_no_spn_disabled { get; }
    internal static string net_log_listener_no_spn_cbt { get; }
    internal static string net_log_listener_no_spn_whensupported { get; }
    internal static string net_log_listener_no_spn_loopback { get; }
    internal static string net_log_listener_spn { get; }
    internal static string net_log_listener_spn_passed { get; }
    internal static string net_log_listener_spn_failed { get; }
    internal static string net_log_listener_spn_failed_always { get; }
    internal static string net_log_listener_spn_failed_empty { get; }
    internal static string net_log_listener_spn_failed_dump { get; }
    internal static string net_log_listener_spn_add { get; }
    internal static string net_log_listener_spn_not_add { get; }
    internal static string net_log_listener_spn_remove { get; }
    internal static string net_log_listener_spn_not_remove { get; }
    internal static string net_listener_no_spns { get; }
    internal static string net_ssp_dont_support_cbt { get; }
    internal static string net_PropertyNotImplementedException { get; }
    internal static string net_array_too_small { get; }
    internal static string net_listener_mustcompletecall { get; }
    internal static string net_listener_invalid_cbt_type { get; }
    internal static string net_listener_callinprogress { get; }
    internal static string net_log_listener_cant_create_uri { get; }
    internal static string net_log_listener_cant_convert_raw_path { get; }
    internal static string net_log_listener_cant_convert_percent_value { get; }
    internal static string net_log_listener_cant_convert_to_utf8 { get; }
    internal static string net_log_listener_cant_convert_bytes { get; }
    internal static string net_invalidstatus { get; }
    internal static string net_WebHeaderInvalidControlChars { get; }
    internal static string net_rspsubmitted { get; }
    internal static string net_nochunkuploadonhttp10 { get; }
    internal static string net_cookie_exists { get; }
    internal static string net_clsmall { get; }
    internal static string net_wrongversion { get; }
    internal static string net_noseek { get; }
    internal static string net_writeonlystream { get; }
    internal static string net_entitytoobig { get; }
    internal static string net_io_notenoughbyteswritten { get; }
    internal static string net_listener_close_urlgroup_error { get; }
    internal static string net_WebSockets_NativeSendResponseHeaders { get; }
    internal static string net_WebSockets_ClientAcceptingNoProtocols { get; }
    internal static string net_WebSockets_AcceptUnsupportedProtocol { get; }
    internal static string net_WebSockets_AcceptNotAWebSocket { get; }
    internal static string net_WebSockets_AcceptHeaderNotFound { get; }
    internal static string net_WebSockets_AcceptUnsupportedWebSocketVersion { get; }
    internal static string net_WebSockets_InvalidEmptySubProtocol { get; }
    internal static string net_WebSockets_InvalidCharInProtocolString { get; }
    internal static string net_WebSockets_ReasonNotNull { get; }
    internal static string net_WebSockets_InvalidCloseStatusCode { get; }
    internal static string net_WebSockets_InvalidCloseStatusDescription { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_TooSmall { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_TooBig { get; }
    internal static string net_WebSockets_UnsupportedPlatform { get; }
    internal static string net_readonlystream { get; }
    internal static string net_WebSockets_InvalidState_ClosedOrAborted { get; }
    internal static string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync { get; }
    internal static string net_Websockets_AlreadyOneOutstandingOperation { get; }
    internal static string net_WebSockets_InvalidMessageType { get; }
    internal static string net_WebSockets_InvalidBufferType { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_InternalBuffer { get; }
    internal static string net_WebSockets_Argument_InvalidMessageType { get; }
    internal static string net_securitypackagesupport { get; }
    internal static string net_log_operation_failed_with_error { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string event_OperationReturnedSomething { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_auth_message_not_encrypted { get; }
    internal static string SSPIInvalidHandleType { get; }
    internal static string net_io_operation_aborted { get; }
    internal static string net_invalid_path { get; }
    internal static string net_listener_auth_errors { get; }
    internal static string net_listener_close { get; }
    internal static string net_invalid_port { get; }
    internal static string net_WebSockets_InvalidState { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_net_log_listener_delegate_exception();
    internal static string get_net_log_listener_unsupported_authentication_scheme();
    internal static string get_net_log_listener_unmatched_authentication_scheme();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_listener_cannot_set_custom_cbt();
    internal static string get_net_listener_detach_error();
    internal static string get_net_listener_scheme();
    internal static string get_net_listener_host();
    internal static string get_net_listener_not_supported();
    internal static string get_net_listener_mustcall();
    internal static string get_net_listener_slash();
    internal static string get_net_listener_already();
    internal static string get_net_log_listener_no_cbt_disabled();
    internal static string get_net_log_listener_no_cbt_http();
    internal static string get_net_log_listener_no_cbt_trustedproxy();
    internal static string get_net_log_listener_cbt();
    internal static string get_net_log_listener_no_spn_kerberos();
    internal static string get_net_log_listener_no_spn_disabled();
    internal static string get_net_log_listener_no_spn_cbt();
    internal static string get_net_log_listener_no_spn_whensupported();
    internal static string get_net_log_listener_no_spn_loopback();
    internal static string get_net_log_listener_spn();
    internal static string get_net_log_listener_spn_passed();
    internal static string get_net_log_listener_spn_failed();
    internal static string get_net_log_listener_spn_failed_always();
    internal static string get_net_log_listener_spn_failed_empty();
    internal static string get_net_log_listener_spn_failed_dump();
    internal static string get_net_log_listener_spn_add();
    internal static string get_net_log_listener_spn_not_add();
    internal static string get_net_log_listener_spn_remove();
    internal static string get_net_log_listener_spn_not_remove();
    internal static string get_net_listener_no_spns();
    internal static string get_net_ssp_dont_support_cbt();
    internal static string get_net_PropertyNotImplementedException();
    internal static string get_net_array_too_small();
    internal static string get_net_listener_mustcompletecall();
    internal static string get_net_listener_invalid_cbt_type();
    internal static string get_net_listener_callinprogress();
    internal static string get_net_log_listener_cant_create_uri();
    internal static string get_net_log_listener_cant_convert_raw_path();
    internal static string get_net_log_listener_cant_convert_percent_value();
    internal static string get_net_log_listener_cant_convert_to_utf8();
    internal static string get_net_log_listener_cant_convert_bytes();
    internal static string get_net_invalidstatus();
    internal static string get_net_WebHeaderInvalidControlChars();
    internal static string get_net_rspsubmitted();
    internal static string get_net_nochunkuploadonhttp10();
    internal static string get_net_cookie_exists();
    internal static string get_net_clsmall();
    internal static string get_net_wrongversion();
    internal static string get_net_noseek();
    internal static string get_net_writeonlystream();
    internal static string get_net_entitytoobig();
    internal static string get_net_io_notenoughbyteswritten();
    internal static string get_net_listener_close_urlgroup_error();
    internal static string get_net_WebSockets_NativeSendResponseHeaders();
    internal static string get_net_WebSockets_ClientAcceptingNoProtocols();
    internal static string get_net_WebSockets_AcceptUnsupportedProtocol();
    internal static string get_net_WebSockets_AcceptNotAWebSocket();
    internal static string get_net_WebSockets_AcceptHeaderNotFound();
    internal static string get_net_WebSockets_AcceptUnsupportedWebSocketVersion();
    internal static string get_net_WebSockets_InvalidEmptySubProtocol();
    internal static string get_net_WebSockets_InvalidCharInProtocolString();
    internal static string get_net_WebSockets_ReasonNotNull();
    internal static string get_net_WebSockets_InvalidCloseStatusCode();
    internal static string get_net_WebSockets_InvalidCloseStatusDescription();
    internal static string get_net_WebSockets_ArgumentOutOfRange_TooSmall();
    internal static string get_net_WebSockets_ArgumentOutOfRange_TooBig();
    internal static string get_net_WebSockets_UnsupportedPlatform();
    internal static string get_net_readonlystream();
    internal static string get_net_WebSockets_InvalidState_ClosedOrAborted();
    internal static string get_net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync();
    internal static string get_net_Websockets_AlreadyOneOutstandingOperation();
    internal static string get_net_WebSockets_InvalidMessageType();
    internal static string get_net_WebSockets_InvalidBufferType();
    internal static string get_net_WebSockets_ArgumentOutOfRange_InternalBuffer();
    internal static string get_net_WebSockets_Argument_InvalidMessageType();
    internal static string get_net_securitypackagesupport();
    internal static string get_net_log_operation_failed_with_error();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_event_OperationReturnedSomething();
    internal static string get_net_invalid_enum();
    internal static string get_net_auth_message_not_encrypted();
    internal static string get_SSPIInvalidHandleType();
    internal static string get_net_io_operation_aborted();
    internal static string get_net_invalid_path();
    internal static string get_net_listener_auth_errors();
    internal static string get_net_listener_close();
    internal static string get_net_invalid_port();
    internal static string get_net_WebSockets_InvalidState();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex);
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
