internal static class FxResources.System.Net.Requests.SR : object {
}
public class System.Net.AuthenticationManager : object {
    [CompilerGeneratedAttribute]
private static ICredentialPolicy <CredentialPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringDictionary <CustomTargetNameDictionary>k__BackingField;
    public static ICredentialPolicy CredentialPolicy { get; public set; }
    public static StringDictionary CustomTargetNameDictionary { get; }
    public static IEnumerator RegisteredModules { get; }
    private static AuthenticationManager();
    [CompilerGeneratedAttribute]
public static ICredentialPolicy get_CredentialPolicy();
    [CompilerGeneratedAttribute]
public static void set_CredentialPolicy(ICredentialPolicy value);
    [CompilerGeneratedAttribute]
public static StringDictionary get_CustomTargetNameDictionary();
    public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public static void Register(IAuthenticationModule authenticationModule);
    public static void Unregister(IAuthenticationModule authenticationModule);
    public static void Unregister(string authenticationScheme);
    public static IEnumerator get_RegisteredModules();
}
public class System.Net.Authorization : object {
    private String[] _protectionRealm;
    private bool _mutualAuth;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Complete>k__BackingField;
    public string Message { get; }
    public string ConnectionGroupId { get; }
    public bool Complete { get; internal set; }
    public String[] ProtectionRealm { get; public set; }
    public bool MutuallyAuthenticated { get; public set; }
    public Authorization(string token);
    public Authorization(string token, bool finished);
    public Authorization(string token, bool finished, string connectionGroupId);
    internal Authorization(string token, bool finished, string connectionGroupId, bool mutualAuth);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_ConnectionGroupId();
    [CompilerGeneratedAttribute]
public bool get_Complete();
    [CompilerGeneratedAttribute]
internal void set_Complete(bool value);
    public String[] get_ProtectionRealm();
    public void set_ProtectionRealm(String[] value);
    public bool get_MutuallyAuthenticated();
    public void set_MutuallyAuthenticated(bool value);
}
public enum System.Net.Cache.HttpCacheAgeControl : Enum {
    public int value__;
    public static HttpCacheAgeControl None;
    public static HttpCacheAgeControl MinFresh;
    public static HttpCacheAgeControl MaxAge;
    public static HttpCacheAgeControl MaxStale;
    public static HttpCacheAgeControl MaxAgeAndMinFresh;
    public static HttpCacheAgeControl MaxAgeAndMaxStale;
}
public enum System.Net.Cache.HttpRequestCacheLevel : Enum {
    public int value__;
    public static HttpRequestCacheLevel Default;
    public static HttpRequestCacheLevel BypassCache;
    public static HttpRequestCacheLevel CacheOnly;
    public static HttpRequestCacheLevel CacheIfAvailable;
    public static HttpRequestCacheLevel Revalidate;
    public static HttpRequestCacheLevel Reload;
    public static HttpRequestCacheLevel NoCacheNoStore;
    public static HttpRequestCacheLevel CacheOrNextCacheOnly;
    public static HttpRequestCacheLevel Refresh;
}
public class System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
    private DateTime _lastSyncDateUtc;
    private TimeSpan _maxAge;
    private TimeSpan _minFresh;
    private TimeSpan _maxStale;
    [CompilerGeneratedAttribute]
private HttpRequestCacheLevel <Level>k__BackingField;
    public HttpRequestCacheLevel Level { get; }
    public DateTime CacheSyncDate { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MinFresh { get; }
    public TimeSpan MaxStale { get; }
    public HttpRequestCachePolicy(HttpRequestCacheLevel level);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale);
    public HttpRequestCachePolicy(DateTime cacheSyncDate);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate);
    [CompilerGeneratedAttribute]
public HttpRequestCacheLevel get_Level();
    public DateTime get_CacheSyncDate();
    public TimeSpan get_MaxAge();
    public TimeSpan get_MinFresh();
    public TimeSpan get_MaxStale();
    public virtual string ToString();
    private static RequestCacheLevel MapLevel(HttpRequestCacheLevel level);
}
internal class System.Net.CallbackClosure : object {
    private AsyncCallback _savedCallback;
    private ExecutionContext _savedContext;
    internal AsyncCallback AsyncCallback { get; }
    internal ExecutionContext Context { get; }
    internal CallbackClosure(ExecutionContext context, AsyncCallback callback);
    internal bool IsCompatible(AsyncCallback callback);
    internal AsyncCallback get_AsyncCallback();
    internal ExecutionContext get_Context();
}
[FlagsAttribute]
internal enum System.Net.CloseExState : Enum {
    public int value__;
    public static CloseExState Normal;
    public static CloseExState Abort;
    public static CloseExState Silent;
}
internal class System.Net.CommandStream : NetworkStreamWrapper {
    private static AsyncCallback s_writeCallbackDelegate;
    private static AsyncCallback s_readCallbackDelegate;
    private bool _recoverableFailure;
    protected WebRequest _request;
    protected bool _isAsync;
    private bool _aborted;
    protected PipelineEntry[] _commands;
    protected int _index;
    private bool _doRead;
    private bool _doSend;
    private ResponseDescription _currentResponseDescription;
    protected string _abortReason;
    private static int WaitingForPipeline;
    private static int CompletedPipeline;
    private string _buffer;
    private Encoding _encoding;
    private Decoder _decoder;
    internal bool RecoverableFailure { get; }
    protected Encoding Encoding { get; protected set; }
    internal CommandStream(TcpClient client);
    private static CommandStream();
    internal virtual void Abort(Exception e);
    protected virtual void Dispose(bool disposing);
    protected void InvokeRequestCallback(object obj);
    internal bool get_RecoverableFailure();
    protected void MarkAsRecoverableFailure();
    internal Stream SubmitRequest(WebRequest request, bool isAsync, bool readInitalResponseOnConnect);
    protected virtual void ClearState();
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest request);
    protected Exception GenerateException(string message, WebExceptionStatus status, Exception innerException);
    protected Exception GenerateException(FtpStatusCode code, string statusDescription, Exception innerException);
    protected void InitCommandPipeline(WebRequest request, PipelineEntry[] commands, bool isAsync);
    internal void CheckContinuePipeline();
    protected Stream ContinueCommandPipeline();
    private bool PostSendCommandProcessing(Stream& stream);
    private bool PostReadCommandProcessing(Stream& stream);
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    private static void ReadCallback(IAsyncResult asyncResult);
    private static void WriteCallback(IAsyncResult asyncResult);
    protected Encoding get_Encoding();
    protected void set_Encoding(Encoding value);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
    private ResponseDescription ReceiveCommandResponse();
    private void ReceiveCommandResponseCallback(ReceiveState state, int bytesRead);
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    private WindowsIdentity _windowsIdentity;
    internal ExecutionContext ContextCopy { get; }
    internal EndPoint RemoteEndPoint { get; }
    internal WindowsIdentity Identity { get; }
    internal ContextAwareResult(object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal ExecutionContext get_ContextCopy();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    internal bool FinishPostingAsyncOp(CallbackClosure& closure);
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
    internal virtual EndPoint get_RemoteEndPoint();
    private void SafeCaptureIdentity();
    internal WindowsIdentity get_Identity();
    private void CleanupInternal();
}
internal static class System.Net.DebugThreadTracking : object {
    [ThreadStaticAttribute]
private static Stack`1<ThreadKinds> t_threadKindStack;
    private static Stack`1<ThreadKinds> ThreadKindStack { get; }
    internal static ThreadKinds CurrentThreadKind { get; }
    private static Stack`1<ThreadKinds> get_ThreadKindStack();
    internal static ThreadKinds get_CurrentThreadKind();
    internal static IDisposable SetThreadKind(ThreadKinds kind);
    internal static void SetThreadSource(ThreadKinds source);
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.ExceptionHelper : object {
    internal static NotSupportedException PropertyNotSupportedException { get; }
    internal static WebException RequestAbortedException { get; }
    internal static WebException TimeoutException { get; }
    internal static NotSupportedException get_PropertyNotSupportedException();
    internal static WebException get_RequestAbortedException();
    internal static WebException get_TimeoutException();
}
public class System.Net.FileWebRequest : WebRequest {
    private WebHeaderCollection _headers;
    private string _method;
    private FileAccess _fileAccess;
    private ManualResetEventSlim _blockReaderUntilRequestStreamDisposed;
    private WebResponse _response;
    private WebFileStream _stream;
    private Uri _uri;
    private long _contentLength;
    private int _timeout;
    private bool _readPending;
    private bool _writePending;
    private bool _writing;
    private bool _syncHint;
    private int _aborted;
    [CompilerGeneratedAttribute]
private string <ConnectionGroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreAuthenticate>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    internal bool Aborted { get; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int Timeout { get; public set; }
    public Uri RequestUri { get; }
    public bool UseDefaultCredentials { get; public set; }
    internal FileWebRequest(Uri uri);
    [ObsoleteAttribute("Serialization is obsoleted for this type. http://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal bool get_Aborted();
    [CompilerGeneratedAttribute]
public virtual string get_ConnectionGroupName();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_PreAuthenticate();
    [CompilerGeneratedAttribute]
public virtual void set_PreAuthenticate(bool value);
    [CompilerGeneratedAttribute]
public virtual IWebProxy get_Proxy();
    [CompilerGeneratedAttribute]
public virtual void set_Proxy(IWebProxy value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual Uri get_RequestUri();
    private static Exception CreateRequestAbortedException();
    private void CheckAndMarkAsyncGetRequestStreamPending();
    private Stream CreateWriteStream();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Task`1<Stream> GetRequestStreamAsync();
    private void CheckAndMarkAsyncGetResponsePending();
    private WebResponse CreateResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual Task`1<WebResponse> GetResponseAsync();
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    internal void UnblockReader();
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual void Abort();
    [CompilerGeneratedAttribute]
private WebResponse <GetResponseAsync>b__60_0(object s);
}
internal class System.Net.FileWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public class System.Net.FileWebResponse : WebResponse {
    private static int DefaultFileStreamBufferSize;
    private static string DefaultFileContentType;
    private long _contentLength;
    private FileAccess _fileAccess;
    private WebHeaderCollection _headers;
    private Uri _uri;
    private Stream _stream;
    private bool _closed;
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    internal FileWebResponse(FileWebRequest request, Uri uri, FileAccess access, bool useAsync);
    [ObsoleteAttribute("Serialization is obsoleted for this type. http://go.microsoft.com/fwlink/?linkid=14202")]
protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    private void CheckDisposed();
    public virtual void Close();
    public virtual Stream GetResponseStream();
}
internal class System.Net.FtpControlStream : CommandStream {
    private Socket _dataSocket;
    private IPEndPoint _passiveEndPoint;
    private TlsStream _tlsStream;
    private StringBuilder _bannerMessage;
    private StringBuilder _welcomeMessage;
    private StringBuilder _exitMessage;
    private WeakReference _credentials;
    private string _currentTypeSetting;
    private long _contentLength;
    private DateTime _lastModified;
    private bool _dataHandshakeStarted;
    private string _loginDirectory;
    private string _establishedServerDirectory;
    private string _requestedServerDirectory;
    private Uri _responseUri;
    private FtpLoginState _loginState;
    internal FtpStatusCode StatusCode;
    internal string StatusLine;
    private static AsyncCallback s_acceptCallbackDelegate;
    private static AsyncCallback s_connectCallbackDelegate;
    private static AsyncCallback s_SSLHandshakeCallback;
    internal NetworkCredential Credentials { get; internal set; }
    internal long ContentLength { get; }
    internal DateTime LastModified { get; }
    internal Uri ResponseUri { get; }
    internal string BannerMessage { get; }
    internal string WelcomeMessage { get; }
    internal string ExitMessage { get; }
    internal FtpControlStream(TcpClient client);
    private static FtpControlStream();
    internal NetworkCredential get_Credentials();
    internal void set_Credentials(NetworkCredential value);
    internal void AbortConnect();
    private static void AcceptCallback(IAsyncResult asyncResult);
    private static void ConnectCallback(IAsyncResult asyncResult);
    private static void SSLHandshakeCallback(IAsyncResult asyncResult);
    private PipelineInstruction QueueOrCreateFtpDataStream(Stream& stream);
    protected virtual void ClearState();
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest req);
    private PipelineInstruction QueueOrCreateDataConection(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream, Boolean& isSocketReady);
    private static void GetPathInfo(GetPathOption pathOption, Uri uri, String& path, String& directory, String& filename);
    private string FormatAddress(IPAddress address, int Port);
    private string FormatAddressV6(IPAddress address, int port);
    internal long get_ContentLength();
    internal DateTime get_LastModified();
    internal Uri get_ResponseUri();
    internal string get_BannerMessage();
    internal string get_WelcomeMessage();
    internal string get_ExitMessage();
    private long GetContentLengthFrom213Response(string responseString);
    private DateTime GetLastModifiedFrom213Response(string str);
    private void TryUpdateResponseUri(string str, FtpWebRequest request);
    private void TryUpdateContentLength(string str);
    private string GetLoginDirectory(string str);
    private int GetPortV4(string responseString);
    private int GetPortV6(string responseString);
    private void CreateFtpListenerSocket(FtpWebRequest request);
    private string GetPortCommandLine(FtpWebRequest request);
    private string FormatFtpCommand(string command, string parameter);
    protected Socket CreateFtpDataSocket(FtpWebRequest request, Socket templateSocket);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
    private TriState IsFtpDataStreamWriteable();
}
internal class System.Net.FtpDataStream : Stream {
    private FtpWebRequest _request;
    private NetworkStream _networkStream;
    private bool _writeable;
    private bool _readable;
    private bool _isFullyRead;
    private bool _closing;
    private static int DefaultCloseTimeout;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal FtpDataStream(NetworkStream networkStream, FtpWebRequest request, TriState writeOnly);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    private void CheckError();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    private void AsyncReadCallback(IAsyncResult ar);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    internal void SetSocketTimeoutOption(int timeout);
}
internal enum System.Net.FtpLoginState : Enum {
    public byte value__;
    public static FtpLoginState NotLoggedIn;
    public static FtpLoginState LoggedIn;
    public static FtpLoginState LoggedInButNeedsRelogin;
    public static FtpLoginState ReloginFailed;
}
[FlagsAttribute]
internal enum System.Net.FtpMethodFlags : Enum {
    public int value__;
    public static FtpMethodFlags None;
    public static FtpMethodFlags IsDownload;
    public static FtpMethodFlags IsUpload;
    public static FtpMethodFlags TakesParameter;
    public static FtpMethodFlags MayTakeParameter;
    public static FtpMethodFlags DoesNotTakeParameter;
    public static FtpMethodFlags ParameterIsDirectory;
    public static FtpMethodFlags ShouldParseForResponseUri;
    public static FtpMethodFlags HasHttpCommand;
    public static FtpMethodFlags MustChangeWorkingDirectoryToPath;
}
internal class System.Net.FtpMethodInfo : object {
    internal string Method;
    internal FtpOperation Operation;
    internal FtpMethodFlags Flags;
    internal string HttpCommand;
    private static FtpMethodInfo[] s_knownMethodInfo;
    internal bool IsCommandOnly { get; }
    internal bool IsUpload { get; }
    internal bool IsDownload { get; }
    internal bool ShouldParseForResponseUri { get; }
    internal FtpMethodInfo(string method, FtpOperation operation, FtpMethodFlags flags, string httpCommand);
    private static FtpMethodInfo();
    internal bool HasFlag(FtpMethodFlags flags);
    internal bool get_IsCommandOnly();
    internal bool get_IsUpload();
    internal bool get_IsDownload();
    internal bool get_ShouldParseForResponseUri();
    internal static FtpMethodInfo GetMethodInfo(string method);
}
internal enum System.Net.FtpOperation : Enum {
    public int value__;
    public static FtpOperation DownloadFile;
    public static FtpOperation ListDirectory;
    public static FtpOperation ListDirectoryDetails;
    public static FtpOperation UploadFile;
    public static FtpOperation UploadFileUnique;
    public static FtpOperation AppendFile;
    public static FtpOperation DeleteFile;
    public static FtpOperation GetDateTimestamp;
    public static FtpOperation GetFileSize;
    public static FtpOperation Rename;
    public static FtpOperation MakeDirectory;
    public static FtpOperation RemoveDirectory;
    public static FtpOperation PrintWorkingDirectory;
    public static FtpOperation Other;
}
public enum System.Net.FtpStatusCode : Enum {
    public int value__;
    public static FtpStatusCode Undefined;
    public static FtpStatusCode RestartMarker;
    public static FtpStatusCode ServiceTemporarilyNotAvailable;
    public static FtpStatusCode DataAlreadyOpen;
    public static FtpStatusCode OpeningData;
    public static FtpStatusCode CommandOK;
    public static FtpStatusCode CommandExtraneous;
    public static FtpStatusCode DirectoryStatus;
    public static FtpStatusCode FileStatus;
    public static FtpStatusCode SystemType;
    public static FtpStatusCode SendUserCommand;
    public static FtpStatusCode ClosingControl;
    public static FtpStatusCode ClosingData;
    public static FtpStatusCode EnteringPassive;
    public static FtpStatusCode LoggedInProceed;
    public static FtpStatusCode ServerWantsSecureSession;
    public static FtpStatusCode FileActionOK;
    public static FtpStatusCode PathnameCreated;
    public static FtpStatusCode SendPasswordCommand;
    public static FtpStatusCode NeedLoginAccount;
    public static FtpStatusCode FileCommandPending;
    public static FtpStatusCode ServiceNotAvailable;
    public static FtpStatusCode CantOpenData;
    public static FtpStatusCode ConnectionClosed;
    public static FtpStatusCode ActionNotTakenFileUnavailableOrBusy;
    public static FtpStatusCode ActionAbortedLocalProcessingError;
    public static FtpStatusCode ActionNotTakenInsufficientSpace;
    public static FtpStatusCode CommandSyntaxError;
    public static FtpStatusCode ArgumentSyntaxError;
    public static FtpStatusCode CommandNotImplemented;
    public static FtpStatusCode BadCommandSequence;
    public static FtpStatusCode NotLoggedIn;
    public static FtpStatusCode AccountNeeded;
    public static FtpStatusCode ActionNotTakenFileUnavailable;
    public static FtpStatusCode ActionAbortedUnknownPageType;
    public static FtpStatusCode FileActionAborted;
    public static FtpStatusCode ActionNotTakenFilenameNotAllowed;
}
public class System.Net.FtpWebRequest : WebRequest {
    private object _syncObject;
    private ICredentials _authInfo;
    private Uri _uri;
    private FtpMethodInfo _methodInfo;
    private string _renameTo;
    private bool _getRequestStreamStarted;
    private bool _getResponseStarted;
    private DateTime _startTime;
    private int _timeout;
    private int _remainingTimeout;
    private long _contentLength;
    private long _contentOffset;
    private X509CertificateCollection _clientCertificates;
    private bool _passive;
    private bool _binary;
    private string _connectionGroupName;
    private ServicePoint _servicePoint;
    private bool _async;
    private bool _aborted;
    private bool _timedOut;
    private Exception _exception;
    private Queue _timerQueue;
    private Callback _timerCallback;
    private bool _enableSsl;
    private FtpControlStream _connection;
    private Stream _stream;
    private RequestStage _requestStage;
    private bool _onceFailed;
    private WebHeaderCollection _ftpRequestHeaders;
    private FtpWebResponse _ftpWebResponse;
    private int _readWriteTimeout;
    private ContextAwareResult _writeAsyncResult;
    private LazyAsyncResult _readAsyncResult;
    private LazyAsyncResult _requestCompleteAsyncResult;
    private static NetworkCredential s_defaultFtpNetworkCredential;
    private static int s_DefaultTimeout;
    private static Queue s_DefaultTimerQueue;
    internal FtpMethodInfo MethodInfo { get; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public string Method { get; public set; }
    public string RenameTo { get; public set; }
    public ICredentials Credentials { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    internal int RemainingTimeout { get; }
    public int ReadWriteTimeout { get; public set; }
    public long ContentOffset { get; public set; }
    public long ContentLength { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public ServicePoint ServicePoint { get; }
    internal bool Aborted { get; }
    private Queue TimerQueue { get; }
    public bool KeepAlive { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public bool UseBinary { get; public set; }
    public bool UsePassive { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public bool EnableSsl { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string ContentType { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool PreAuthenticate { get; public set; }
    private bool InUse { get; }
    internal FtpWebRequest(Uri uri);
    private static FtpWebRequest();
    internal FtpMethodInfo get_MethodInfo();
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public string get_RenameTo();
    public void set_RenameTo(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    internal int get_RemainingTimeout();
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public long get_ContentOffset();
    public void set_ContentOffset(long value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public ServicePoint get_ServicePoint();
    internal bool get_Aborted();
    public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    private void SubmitRequest(bool isAsync);
    private Exception TranslateConnectException(Exception e);
    [AsyncStateMachineAttribute("System.Net.FtpWebRequest/<CreateConnectionAsync>d__86")]
private void CreateConnectionAsync();
    private FtpControlStream CreateConnection();
    private Stream TimedSubmitRequestHelper(bool isAsync);
    private void TimerCallback(Timer timer, int timeNoticed, object context);
    private Queue get_TimerQueue();
    private bool AttemptedRecovery(Exception e);
    private void SetException(Exception exception);
    private void CheckError();
    internal void RequestCallback(object obj);
    private void SyncRequestCallback(object obj);
    private void AsyncRequestCallback(object obj);
    private RequestStage FinishRequestStage(RequestStage stage);
    public virtual void Abort();
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public bool get_UseBinary();
    public void set_UseBinary(bool value);
    public bool get_UsePassive();
    public void set_UsePassive(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    private bool get_InUse();
    private void EnsureFtpWebResponse(Exception exception);
    internal void DataStreamClosed(CloseExState closeState);
}
internal class System.Net.FtpWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
public class System.Net.FtpWebResponse : WebResponse {
    internal Stream _responseStream;
    private long _contentLength;
    private Uri _responseUri;
    private FtpStatusCode _statusCode;
    private string _statusLine;
    private WebHeaderCollection _ftpRequestHeaders;
    private DateTime _lastModified;
    private string _bannerMessage;
    private string _welcomeMessage;
    private string _exitMessage;
    public long ContentLength { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    public FtpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public DateTime LastModified { get; }
    public string BannerMessage { get; }
    public string WelcomeMessage { get; }
    public string ExitMessage { get; }
    internal FtpWebResponse(Stream responseStream, long contentLength, Uri responseUri, FtpStatusCode statusCode, string statusLine, DateTime lastModified, string bannerMessage, string welcomeMessage, string exitMessage);
    internal void UpdateStatus(FtpStatusCode statusCode, string statusLine, string exitMessage);
    public virtual Stream GetResponseStream();
    internal void SetResponseStream(Stream stream);
    public virtual void Close();
    public virtual long get_ContentLength();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    public FtpStatusCode get_StatusCode();
    public string get_StatusDescription();
    public DateTime get_LastModified();
    public string get_BannerMessage();
    public string get_WelcomeMessage();
    public string get_ExitMessage();
}
[ObsoleteAttribute("This class has been deprecated. Please use WebRequest.DefaultWebProxy instead to access and set the global default proxy. Use 'null' instead of GetEmptyWebProxy. http://go.microsoft.com/fwlink/?linkid=14202")]
public class System.Net.GlobalProxySelection : object {
    public static IWebProxy Select { get; public set; }
    public static IWebProxy get_Select();
    public static void set_Select(IWebProxy value);
    public static IWebProxy GetEmptyWebProxy();
}
internal static class System.Net.Http.HttpHandlerDefaults : object {
    public static int DefaultMaxAutomaticRedirections;
    public static int DefaultMaxConnectionsPerServer;
    public static int DefaultMaxResponseDrainSize;
    public static TimeSpan DefaultResponseDrainTimeout;
    public static int DefaultMaxResponseHeadersLength;
    public static DecompressionMethods DefaultAutomaticDecompression;
    public static bool DefaultAutomaticRedirection;
    public static bool DefaultUseCookies;
    public static bool DefaultPreAuthenticate;
    public static ClientCertificateOption DefaultClientCertificateOption;
    public static bool DefaultUseProxy;
    public static bool DefaultUseDefaultCredentials;
    public static bool DefaultCheckCertificateRevocationList;
    public static TimeSpan DefaultPooledConnectionLifetime;
    public static TimeSpan DefaultPooledConnectionIdleTimeout;
    public static TimeSpan DefaultExpect100ContinueTimeout;
    public static TimeSpan DefaultConnectTimeout;
    private static HttpHandlerDefaults();
}
public class System.Net.HttpContinueDelegate : MulticastDelegate {
    public HttpContinueDelegate(object object, IntPtr method);
    public virtual void Invoke(int StatusCode, WebHeaderCollection httpHeaders);
    public virtual IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.HttpDateParse : object {
    private static int BASE_DEC;
    private static int DATE_INDEX_DAY_OF_WEEK;
    private static int DATE_1123_INDEX_DAY;
    private static int DATE_1123_INDEX_MONTH;
    private static int DATE_1123_INDEX_YEAR;
    private static int DATE_1123_INDEX_HRS;
    private static int DATE_1123_INDEX_MINS;
    private static int DATE_1123_INDEX_SECS;
    private static int DATE_ANSI_INDEX_MONTH;
    private static int DATE_ANSI_INDEX_DAY;
    private static int DATE_ANSI_INDEX_HRS;
    private static int DATE_ANSI_INDEX_MINS;
    private static int DATE_ANSI_INDEX_SECS;
    private static int DATE_ANSI_INDEX_YEAR;
    private static int DATE_INDEX_TZ;
    private static int DATE_INDEX_LAST;
    private static int MAX_FIELD_DATE_ENTRIES;
    private static int DATE_TOKEN_JANUARY;
    private static int DATE_TOKEN_FEBRUARY;
    private static int DATE_TOKEN_MARCH;
    private static int DATE_TOKEN_APRIL;
    private static int DATE_TOKEN_MAY;
    private static int DATE_TOKEN_JUNE;
    private static int DATE_TOKEN_JULY;
    private static int DATE_TOKEN_AUGUST;
    private static int DATE_TOKEN_SEPTEMBER;
    private static int DATE_TOKEN_OCTOBER;
    private static int DATE_TOKEN_NOVEMBER;
    private static int DATE_TOKEN_DECEMBER;
    private static int DATE_TOKEN_LAST_MONTH;
    private static int DATE_TOKEN_SUNDAY;
    private static int DATE_TOKEN_MONDAY;
    private static int DATE_TOKEN_TUESDAY;
    private static int DATE_TOKEN_WEDNESDAY;
    private static int DATE_TOKEN_THURSDAY;
    private static int DATE_TOKEN_FRIDAY;
    private static int DATE_TOKEN_SATURDAY;
    private static int DATE_TOKEN_LAST_DAY;
    private static int DATE_TOKEN_GMT;
    private static int DATE_TOKEN_LAST;
    private static int DATE_TOKEN_ERROR;
    private static int MapDayMonthToDword(string day, int index);
    public static bool ParseHttpDate(string dateString, DateTime& result);
    public static DateTime StringToDate(string s);
}
internal static class System.Net.HttpKnownHeaderNames : object {
    public static string Accept;
    public static string AcceptCharset;
    public static string AcceptEncoding;
    public static string AcceptLanguage;
    public static string AcceptPatch;
    public static string AcceptRanges;
    public static string AccessControlAllowCredentials;
    public static string AccessControlAllowHeaders;
    public static string AccessControlAllowMethods;
    public static string AccessControlAllowOrigin;
    public static string AccessControlExposeHeaders;
    public static string AccessControlMaxAge;
    public static string Age;
    public static string Allow;
    public static string AltSvc;
    public static string Authorization;
    public static string CacheControl;
    public static string Connection;
    public static string ContentDisposition;
    public static string ContentEncoding;
    public static string ContentLanguage;
    public static string ContentLength;
    public static string ContentLocation;
    public static string ContentMD5;
    public static string ContentRange;
    public static string ContentSecurityPolicy;
    public static string ContentType;
    public static string Cookie;
    public static string Cookie2;
    public static string Date;
    public static string ETag;
    public static string Expect;
    public static string Expires;
    public static string From;
    public static string Host;
    public static string IfMatch;
    public static string IfModifiedSince;
    public static string IfNoneMatch;
    public static string IfRange;
    public static string IfUnmodifiedSince;
    public static string KeepAlive;
    public static string LastModified;
    public static string Link;
    public static string Location;
    public static string MaxForwards;
    public static string Origin;
    public static string P3P;
    public static string Pragma;
    public static string ProxyAuthenticate;
    public static string ProxyAuthorization;
    public static string ProxyConnection;
    public static string PublicKeyPins;
    public static string Range;
    public static string Referer;
    public static string RetryAfter;
    public static string SecWebSocketAccept;
    public static string SecWebSocketExtensions;
    public static string SecWebSocketKey;
    public static string SecWebSocketProtocol;
    public static string SecWebSocketVersion;
    public static string Server;
    public static string SetCookie;
    public static string SetCookie2;
    public static string StrictTransportSecurity;
    public static string TE;
    public static string TSV;
    public static string Trailer;
    public static string TransferEncoding;
    public static string Upgrade;
    public static string UpgradeInsecureRequests;
    public static string UserAgent;
    public static string Vary;
    public static string Via;
    public static string WWWAuthenticate;
    public static string Warning;
    public static string XAspNetVersion;
    public static string XContentDuration;
    public static string XContentTypeOptions;
    public static string XFrameOptions;
    public static string XMSEdgeRef;
    public static string XPoweredBy;
    public static string XRequestID;
    public static string XUACompatible;
}
internal static class System.Net.HttpValidationHelpers : object {
    private static Char[] s_httpTrimCharacters;
    private static HttpValidationHelpers();
    internal static string CheckBadHeaderNameChars(string name);
    internal static bool ContainsNonAsciiChars(string token);
    internal static bool IsValidToken(string token);
    public static string CheckBadHeaderValueChars(string value);
    public static bool IsInvalidMethodOrHeaderString(string stringValue);
}
public class System.Net.HttpWebRequest : WebRequest {
    private static int DefaultContinueTimeout;
    private static int DefaultReadWriteTimeout;
    private WebHeaderCollection _webHeaderCollection;
    private Uri _requestUri;
    private string _originVerb;
    private int _continueTimeout;
    private bool _allowReadStreamBuffering;
    private CookieContainer _cookieContainer;
    private ICredentials _credentials;
    private IWebProxy _proxy;
    private Task`1<HttpResponseMessage> _sendRequestTask;
    private static int _defaultMaxResponseHeadersLength;
    private int _beginGetRequestStreamCalled;
    private int _beginGetResponseCalled;
    private int _endGetRequestStreamCalled;
    private int _endGetResponseCalled;
    private int _maximumAllowedRedirections;
    private int _maximumResponseHeadersLen;
    private ServicePoint _servicePoint;
    private int _timeout;
    private int _readWriteTimeout;
    private HttpContinueDelegate _continueDelegate;
    private bool _hostHasPort;
    private Uri _hostUri;
    private RequestStream _requestStream;
    private TaskCompletionSource`1<Stream> _requestStreamOperation;
    private TaskCompletionSource`1<WebResponse> _responseOperation;
    private AsyncCallback _requestStreamCallback;
    private AsyncCallback _responseCallback;
    private int _abortCalled;
    private CancellationTokenSource _sendRequestCts;
    private X509CertificateCollection _clientCertificates;
    private Booleans _booleans;
    private bool _pipelined;
    private bool _preAuthenticate;
    private DecompressionMethods _automaticDecompression;
    private static string ContinueHeader;
    private static string ChunkedHeader;
    private static string GZipHeader;
    private static string DeflateHeader;
    [CompilerGeneratedAttribute]
private string <MediaType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionGroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <DefaultMaximumErrorResponseLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static RequestCachePolicy <DefaultCachePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <ServerCertificateValidationCallback>k__BackingField;
    private static String[] s_wellKnownContentHeaders;
    public string Accept { get; public set; }
    public bool AllowReadStreamBuffering { get; public set; }
    public int MaximumResponseHeadersLength { get; public set; }
    public int MaximumAutomaticRedirections { get; public set; }
    public string ContentType { get; public set; }
    public int ContinueTimeout { get; public set; }
    public int Timeout { get; public set; }
    public long ContentLength { get; public set; }
    public Uri Address { get; }
    public string UserAgent { get; public set; }
    public string Host { get; public set; }
    public bool Pipelined { get; public set; }
    public string Referer { get; public set; }
    public string MediaType { get; public set; }
    public string TransferEncoding { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public bool AllowWriteStreamBuffering { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public string Connection { get; public set; }
    public string Expect { get; public set; }
    public static int DefaultMaximumResponseHeadersLength { get; public set; }
    public static int DefaultMaximumErrorResponseLength { get; public set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public DateTime IfModifiedSince { get; public set; }
    public DateTime Date { get; public set; }
    public bool SendChunked { get; public set; }
    public HttpContinueDelegate ContinueDelegate { get; public set; }
    public ServicePoint ServicePoint { get; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public Version ProtocolVersion { get; public set; }
    public int ReadWriteTimeout { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool HaveResponse { get; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public bool SupportsCookieContainer { get; }
    public bool UseDefaultCredentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    private bool IsVersionHttp10 { get; private set; }
    private bool RequestSubmitted { get; }
    [ObsoleteAttribute("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal HttpWebRequest(Uri uri);
    private static HttpWebRequest();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private void SetSpecialHeaders(string HeaderName, string value);
    public string get_Accept();
    public void set_Accept(string value);
    public virtual bool get_AllowReadStreamBuffering();
    public virtual void set_AllowReadStreamBuffering(bool value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    public int get_MaximumAutomaticRedirections();
    public void set_MaximumAutomaticRedirections(int value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public int get_ContinueTimeout();
    public void set_ContinueTimeout(int value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public Uri get_Address();
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public string get_Host();
    public void set_Host(string value);
    public bool get_Pipelined();
    public void set_Pipelined(bool value);
    public string get_Referer();
    public void set_Referer(string value);
    [CompilerGeneratedAttribute]
public string get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(string value);
    public string get_TransferEncoding();
    public void set_TransferEncoding(string value);
    [CompilerGeneratedAttribute]
public bool get_KeepAlive();
    [CompilerGeneratedAttribute]
public void set_KeepAlive(bool value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public virtual bool get_AllowWriteStreamBuffering();
    public virtual void set_AllowWriteStreamBuffering(bool value);
    public virtual bool get_AllowAutoRedirect();
    public virtual void set_AllowAutoRedirect(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_ConnectionGroupName();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionGroupName(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public string get_Connection();
    public void set_Connection(string value);
    public string get_Expect();
    public void set_Expect(string value);
    public static int get_DefaultMaximumResponseHeadersLength();
    public static void set_DefaultMaximumResponseHeadersLength(int value);
    [CompilerGeneratedAttribute]
public static int get_DefaultMaximumErrorResponseLength();
    [CompilerGeneratedAttribute]
public static void set_DefaultMaximumErrorResponseLength(int value);
    [CompilerGeneratedAttribute]
public static RequestCachePolicy get_DefaultCachePolicy();
    [CompilerGeneratedAttribute]
public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public DateTime get_IfModifiedSince();
    public void set_IfModifiedSince(DateTime value);
    public DateTime get_Date();
    public void set_Date(DateTime value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public HttpContinueDelegate get_ContinueDelegate();
    public void set_ContinueDelegate(HttpContinueDelegate value);
    public ServicePoint get_ServicePoint();
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_ClientCertificates(X509CertificateCollection value);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public virtual CookieContainer get_CookieContainer();
    public virtual void set_CookieContainer(CookieContainer value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual bool get_HaveResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual Uri get_RequestUri();
    public virtual bool get_SupportsCookieContainer();
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual void Abort();
    private bool get_IsVersionHttp10();
    private void set_IsVersionHttp10(bool value);
    public virtual WebResponse GetResponse();
    public virtual Stream GetRequestStream();
    private Task`1<Stream> InternalGetRequestStream();
    public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context);
    public Stream GetRequestStream(TransportContext& context);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Net.HttpWebRequest/<SendRequest>d__194")]
private Task`1<WebResponse> SendRequest();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public void AddRange(int from, int to);
    public void AddRange(long from, long to);
    public void AddRange(int range);
    public void AddRange(long range);
    public void AddRange(string rangeSpecifier, int from, int to);
    public void AddRange(string rangeSpecifier, long from, long to);
    public void AddRange(string rangeSpecifier, int range);
    public void AddRange(string rangeSpecifier, long range);
    private bool AddRange(string rangeSpecifier, string from, string to);
    private bool get_RequestSubmitted();
    private void CheckAbort();
    private bool IsWellKnownContentHeader(string header);
    private DateTime GetDateHeaderHelper(string headerName);
    private void SetDateHeaderHelper(string headerName, DateTime dateTime);
    private static string DateToString(DateTime D);
    private bool TryGetHostUri(string hostName, Uri& hostUri);
}
public class System.Net.HttpWebResponse : WebResponse {
    private HttpResponseMessage _httpResponseMessage;
    private Uri _requestUri;
    private CookieCollection _cookies;
    private WebHeaderCollection _webHeaderCollection;
    private string _characterSet;
    private bool _isVersionHttp11;
    public bool IsMutuallyAuthenticated { get; }
    public long ContentLength { get; }
    public string ContentType { get; }
    public string ContentEncoding { get; }
    public CookieCollection Cookies { get; public set; }
    public DateTime LastModified { get; }
    public string Server { get; }
    public Version ProtocolVersion { get; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; }
    public Uri ResponseUri { get; }
    public HttpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public string CharacterSet { get; }
    public bool SupportsHeaders { get; }
    [ObsoleteAttribute("Serialization is obsoleted for this type.  http://go.microsoft.com/fwlink/?linkid=14202")]
protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal HttpWebResponse(HttpResponseMessage _message, Uri requestUri, CookieContainer cookieContainer);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public string get_ContentEncoding();
    public virtual CookieCollection get_Cookies();
    public virtual void set_Cookies(CookieCollection value);
    public DateTime get_LastModified();
    public string get_Server();
    public Version get_ProtocolVersion();
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual Uri get_ResponseUri();
    public virtual HttpStatusCode get_StatusCode();
    public virtual string get_StatusDescription();
    public string get_CharacterSet();
    public virtual bool get_SupportsHeaders();
    public virtual Stream GetResponseStream();
    public string GetResponseHeader(string headerName);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
    private string GetHeaderValueAsString(IEnumerable`1<string> values);
}
public interface System.Net.IAuthenticationModule {
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public abstract virtual bool get_CanPreAuthenticate();
    public abstract virtual string get_AuthenticationType();
}
internal interface System.Net.ICloseEx {
    public abstract virtual void CloseEx(CloseExState closeState);
}
public interface System.Net.ICredentialPolicy {
    public abstract virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
}
internal class System.Net.InternalException : Exception {
}
internal static class System.Net.Interop : object {
    public static int WININET_E_OUT_OF_HANDLES;
    public static int WININET_E_TIMEOUT;
    public static int WININET_E_EXTENDED_ERROR;
    public static int WININET_E_INTERNAL_ERROR;
    public static int WININET_E_INVALID_URL;
    public static int WININET_E_UNRECOGNIZED_SCHEME;
    public static int WININET_E_NAME_NOT_RESOLVED;
    public static int WININET_E_PROTOCOL_NOT_FOUND;
    public static int WININET_E_INVALID_OPTION;
    public static int WININET_E_BAD_OPTION_LENGTH;
    public static int WININET_E_OPTION_NOT_SETTABLE;
    public static int WININET_E_SHUTDOWN;
    public static int WININET_E_INCORRECT_USER_NAME;
    public static int WININET_E_INCORRECT_PASSWORD;
    public static int WININET_E_LOGIN_FAILURE;
    public static int WININET_E_INVALID_OPERATION;
    public static int WININET_E_OPERATION_CANCELLED;
    public static int WININET_E_INCORRECT_HANDLE_TYPE;
    public static int WININET_E_INCORRECT_HANDLE_STATE;
    public static int WININET_E_NOT_PROXY_REQUEST;
    public static int WININET_E_REGISTRY_VALUE_NOT_FOUND;
    public static int WININET_E_BAD_REGISTRY_PARAMETER;
    public static int WININET_E_NO_DIRECT_ACCESS;
    public static int WININET_E_NO_CONTEXT;
    public static int WININET_E_NO_CALLBACK;
    public static int WININET_E_REQUEST_PENDING;
    public static int WININET_E_INCORRECT_FORMAT;
    public static int WININET_E_ITEM_NOT_FOUND;
    public static int WININET_E_CANNOT_CONNECT;
    public static int WININET_E_CONNECTION_ABORTED;
    public static int WININET_E_CONNECTION_RESET;
    public static int WININET_E_FORCE_RETRY;
    public static int WININET_E_INVALID_PROXY_REQUEST;
    public static int WININET_E_NEED_UI;
    public static int WININET_E_HANDLE_EXISTS;
    public static int WININET_E_SEC_CERT_DATE_INVALID;
    public static int WININET_E_SEC_CERT_CN_INVALID;
    public static int WININET_E_HTTP_TO_HTTPS_ON_REDIR;
    public static int WININET_E_HTTPS_TO_HTTP_ON_REDIR;
    public static int WININET_E_MIXED_SECURITY;
    public static int WININET_E_CHG_POST_IS_NON_SECURE;
    public static int WININET_E_POST_IS_NON_SECURE;
    public static int WININET_E_CLIENT_AUTH_CERT_NEEDED;
    public static int WININET_E_INVALID_CA;
    public static int WININET_E_CLIENT_AUTH_NOT_SETUP;
    public static int WININET_E_ASYNC_THREAD_FAILED;
    public static int WININET_E_REDIRECT_SCHEME_CHANGE;
    public static int WININET_E_DIALOG_PENDING;
    public static int WININET_E_RETRY_DIALOG;
    public static int WININET_E_NO_NEW_CONTAINERS;
    public static int WININET_E_HTTPS_HTTP_SUBMIT_REDIR;
    public static int WININET_E_SEC_CERT_ERRORS;
    public static int WININET_E_SEC_CERT_REV_FAILED;
    public static int WININET_E_HEADER_NOT_FOUND;
    public static int WININET_E_DOWNLEVEL_SERVER;
    public static int WININET_E_INVALID_SERVER_RESPONSE;
    public static int WININET_E_INVALID_HEADER;
    public static int WININET_E_INVALID_QUERY_REQUEST;
    public static int WININET_E_HEADER_ALREADY_EXISTS;
    public static int WININET_E_REDIRECT_FAILED;
    public static int WININET_E_SECURITY_CHANNEL_ERROR;
    public static int WININET_E_UNABLE_TO_CACHE_FILE;
    public static int WININET_E_TCPIP_NOT_INSTALLED;
    public static int WININET_E_DISCONNECTED;
    public static int WININET_E_SERVER_UNREACHABLE;
    public static int WININET_E_PROXY_SERVER_UNREACHABLE;
    public static int WININET_E_BAD_AUTO_PROXY_SCRIPT;
    public static int WININET_E_UNABLE_TO_DOWNLOAD_SCRIPT;
    public static int WININET_E_SEC_INVALID_CERT;
    public static int WININET_E_SEC_CERT_REVOKED;
    public static int WININET_E_FAILED_DUETOSECURITYCHECK;
    public static int WININET_E_NOT_INITIALIZED;
    public static int WININET_E_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;
    public static int WININET_E_DECODING_FAILED;
    public static int WININET_E_NOT_REDIRECTED;
    public static int WININET_E_COOKIE_NEEDS_CONFIRMATION;
    public static int WININET_E_COOKIE_DECLINED;
    public static int WININET_E_REDIRECT_NEEDS_CONFIRMATION;
}
public interface System.Net.IWebRequestCreate {
    public abstract virtual WebRequest Create(Uri uri);
}
internal class System.Net.LazyAsyncResult : object {
    private static int HighBit;
    private static int ForceAsyncCount;
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _errorCode;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; protected set; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack, object result);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    protected void set_AsyncCallback(AsyncCallback value);
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    [ConditionalAttribute("DEBUG")]
protected void DebugProtectState(bool protect);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static string MissingMember;
    private static string NullInstance;
    private static string StaticMethodObject;
    private static string NoParameters;
    private static int MaxDumpSize;
    private static int EnterEventId;
    private static int ExitEventId;
    private static int AssociateEventId;
    private static int InfoEventId;
    private static int ErrorEventId;
    private static int CriticalFailureEventId;
    private static int DumpArrayEventId;
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int NextAvailableEventId;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, object arg1, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(object arg);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(FormattableString arg);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
}
internal static class System.Net.NetRes : object {
    public static string GetWebStatusCodeString(FtpStatusCode statusCode, string statusDescription);
}
internal class System.Net.NetworkStreamWrapper : Stream {
    private TcpClient _client;
    private NetworkStream _networkStream;
    protected bool UsingSecureStream { get; }
    internal IPAddress ServerAddress { get; }
    internal Socket Socket { get; }
    internal NetworkStream NetworkStream { get; internal set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal NetworkStreamWrapper(TcpClient client);
    protected bool get_UsingSecureStream();
    internal IPAddress get_ServerAddress();
    internal Socket get_Socket();
    internal NetworkStream get_NetworkStream();
    internal void set_NetworkStream(NetworkStream value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    protected virtual void Dispose(bool disposing);
    internal void CloseSocket();
    public void Close(int timeout);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(int timeout);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.ProtocolViolationException : InvalidOperationException {
    public ProtocolViolationException(string message);
    protected ProtocolViolationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.ReceiveState : object {
    private static int bufferSize;
    internal ResponseDescription Resp;
    internal int ValidThrough;
    internal Byte[] Buffer;
    internal CommandStream Connection;
    internal ReceiveState(CommandStream connection);
}
internal class System.Net.RequestStream : Stream {
    private MemoryStream _buffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public ArraySegment`1<byte> GetBuffer();
}
internal class System.Net.ResponseDescription : object {
    internal static int NoStatus;
    internal bool Multiline;
    internal int Status;
    internal string StatusDescription;
    internal StringBuilder StatusBuffer;
    internal string StatusCodeString;
    internal bool PositiveIntermediate { get; }
    internal bool PositiveCompletion { get; }
    internal bool TransientFailure { get; }
    internal bool PermanentFailure { get; }
    internal bool InvalidStatusCode { get; }
    internal bool get_PositiveIntermediate();
    internal bool get_PositiveCompletion();
    internal bool get_TransientFailure();
    internal bool get_PermanentFailure();
    internal bool get_InvalidStatusCode();
}
internal static class System.Net.SecurityProtocol : object {
    public static SslProtocols DefaultSecurityProtocols;
    public static SslProtocols SystemDefaultSecurityProtocols;
}
internal class System.Net.SystemWebProxy : object {
    private static IWebProxy s_systemWebProxy;
    private static bool s_systemWebProxyInitialized;
    private static object s_lockObject;
    private ICredentials _credentials;
    public ICredentials Credentials { get; public set; }
    private static SystemWebProxy();
    public static IWebProxy Get();
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri host);
}
[ExtensionAttribute]
internal static class System.Net.TaskExtensions : object {
    [ExtensionAttribute]
public static TaskCompletionSource`1<TResult> ToApm(Task`1<TResult> task, AsyncCallback callback, object state);
}
[FlagsAttribute]
internal enum System.Net.ThreadKinds : Enum {
    public int value__;
    public static ThreadKinds Unknown;
    public static ThreadKinds User;
    public static ThreadKinds System;
    public static ThreadKinds Sync;
    public static ThreadKinds Async;
    public static ThreadKinds Timer;
    public static ThreadKinds CompletionPort;
    public static ThreadKinds Worker;
    public static ThreadKinds Finalization;
    public static ThreadKinds Other;
    public static ThreadKinds OwnerMask;
    public static ThreadKinds SyncMask;
    public static ThreadKinds SourceMask;
    public static ThreadKinds SafeSources;
    public static ThreadKinds ThreadPool;
}
internal static class System.Net.TimerThread : object {
    private static int ThreadIdleTimeoutMilliseconds;
    private static int CacheScanPerIterations;
    private static int TickCountResolution;
    private static LinkedList`1<WeakReference> s_queues;
    private static LinkedList`1<WeakReference> s_newQueues;
    private static int s_threadState;
    private static AutoResetEvent s_threadReadyEvent;
    private static ManualResetEvent s_threadShutdownEvent;
    private static WaitHandle[] s_threadEvents;
    private static int s_cacheScanIteration;
    private static Hashtable s_queuesCache;
    private static TimerThread();
    internal static Queue GetOrCreateQueue(int durationMilliseconds);
    private static void Prod();
    private static void ThreadProc();
    private static bool IsTickBetween(int start, int end, int comparand);
}
internal class System.Net.TlsStream : NetworkStream {
    private SslStream _sslStream;
    private string _host;
    private X509CertificateCollection _clientCertificates;
    public TlsStream(NetworkStream stream, Socket socket, string host, X509CertificateCollection clientCertificates);
    public void AuthenticateAsClient();
    public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object state);
    public void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Close();
}
internal enum System.Net.TriState : Enum {
    public int value__;
    public static TriState Unspecified;
    public static TriState False;
    public static TriState True;
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.WebException : InvalidOperationException {
    private static WebExceptionStatus DefaultStatus;
    private WebExceptionStatus _status;
    private WebResponse _response;
    public WebExceptionStatus Status { get; }
    public WebResponse Response { get; }
    public WebException(string message);
    public WebException(string message, Exception innerException);
    public WebException(string message, WebExceptionStatus status);
    public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response);
    protected WebException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public WebExceptionStatus get_Status();
    public WebResponse get_Response();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal static Exception CreateCompatibleException(Exception exception);
    private static WebExceptionStatus GetStatusFromExceptionHelper(HttpRequestException ex);
    internal static WebExceptionStatus GetStatusFromException(HttpRequestException ex);
}
public enum System.Net.WebExceptionStatus : Enum {
    public int value__;
    public static WebExceptionStatus Success;
    public static WebExceptionStatus NameResolutionFailure;
    public static WebExceptionStatus ConnectFailure;
    public static WebExceptionStatus ReceiveFailure;
    public static WebExceptionStatus SendFailure;
    public static WebExceptionStatus PipelineFailure;
    public static WebExceptionStatus RequestCanceled;
    public static WebExceptionStatus ProtocolError;
    public static WebExceptionStatus ConnectionClosed;
    public static WebExceptionStatus TrustFailure;
    public static WebExceptionStatus SecureChannelFailure;
    public static WebExceptionStatus ServerProtocolViolation;
    public static WebExceptionStatus KeepAliveFailure;
    public static WebExceptionStatus Pending;
    public static WebExceptionStatus Timeout;
    public static WebExceptionStatus ProxyNameResolutionFailure;
    public static WebExceptionStatus UnknownError;
    public static WebExceptionStatus MessageLengthLimitExceeded;
    public static WebExceptionStatus CacheEntryNotFound;
    public static WebExceptionStatus RequestProhibitedByCachePolicy;
    public static WebExceptionStatus RequestProhibitedByProxy;
}
internal class System.Net.WebFileStream : FileStream {
    private FileWebRequest _request;
    public WebFileStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing);
    public WebFileStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing, int length, bool async);
    protected virtual void Dispose(bool disposing);
    internal void Abort();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult ar);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void CheckAborted();
}
public abstract class System.Net.WebRequest : MarshalByRefObject {
    private static List`1<WebRequestPrefixElement> s_prefixList;
    private static object s_internalSyncObject;
    internal static int DefaultTimeoutMilliseconds;
    [CompilerGeneratedAttribute]
private static RequestCachePolicy <DefaultCachePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestCachePolicy <CachePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationLevel <AuthenticationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenImpersonationLevel <ImpersonationLevel>k__BackingField;
    private static IWebProxy s_DefaultWebProxy;
    private static bool s_DefaultWebProxyInitialized;
    internal static List`1<WebRequestPrefixElement> PrefixList { get; internal set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public AuthenticationLevel AuthenticationLevel { get; public set; }
    public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public WebHeaderCollection Headers { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public static IWebProxy DefaultWebProxy { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebRequest();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebRequest Create(Uri requestUri, bool useUriBase);
    public static WebRequest Create(string requestUriString);
    public static WebRequest Create(Uri requestUri);
    public static WebRequest CreateDefault(Uri requestUri);
    public static HttpWebRequest CreateHttp(string requestUriString);
    public static HttpWebRequest CreateHttp(Uri requestUri);
    public static bool RegisterPrefix(string prefix, IWebRequestCreate creator);
    internal static List`1<WebRequestPrefixElement> get_PrefixList();
    internal static void set_PrefixList(List`1<WebRequestPrefixElement> value);
    [CompilerGeneratedAttribute]
public static RequestCachePolicy get_DefaultCachePolicy();
    [CompilerGeneratedAttribute]
public static void set_DefaultCachePolicy(RequestCachePolicy value);
    [CompilerGeneratedAttribute]
public virtual RequestCachePolicy get_CachePolicy();
    [CompilerGeneratedAttribute]
public virtual void set_CachePolicy(RequestCachePolicy value);
    [CompilerGeneratedAttribute]
public AuthenticationLevel get_AuthenticationLevel();
    [CompilerGeneratedAttribute]
public void set_AuthenticationLevel(AuthenticationLevel value);
    [CompilerGeneratedAttribute]
public TokenImpersonationLevel get_ImpersonationLevel();
    [CompilerGeneratedAttribute]
public void set_ImpersonationLevel(TokenImpersonationLevel value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual Uri get_RequestUri();
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual Task`1<Stream> GetRequestStreamAsync();
    public virtual Task`1<WebResponse> GetResponseAsync();
    public virtual void Abort();
    public static IWebProxy GetSystemWebProxy();
    public static IWebProxy get_DefaultWebProxy();
    public static void set_DefaultWebProxy(IWebProxy value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    [CompilerGeneratedAttribute]
private Task`1<Stream> <GetRequestStreamAsync>b__67_0();
    [CompilerGeneratedAttribute]
private Task`1<WebResponse> <GetResponseAsync>b__68_0();
}
public static class System.Net.WebRequestMethods : object {
}
public abstract class System.Net.WebResponse : MarshalByRefObject {
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public bool IsFromCache { get; }
    public bool IsMutuallyAuthenticated { get; }
    public Uri ResponseUri { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual bool get_IsFromCache();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual Stream GetResponseStream();
    public virtual Uri get_ResponseUri();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string net_unknown_prefix { get; }
    internal static string net_reqsubmitted { get; }
    internal static string net_io_timeout_use_ge_zero { get; }
    internal static string net_writestarted { get; }
    internal static string net_badmethod { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_servererror { get; }
    internal static string net_reqaborted { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string net_OperationNotSupportedException { get; }
    internal static string net_PropertyNotImplementedException { get; }
    internal static string net_nouploadonget { get; }
    internal static string net_repcall { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_securityprotocolnotsupported { get; }
    internal static string net_requestaborted { get; }
    internal static string net_clsmall { get; }
    internal static string net_webstatus_Timeout { get; }
    internal static string net_baddate { get; }
    internal static string net_connarg { get; }
    internal static string net_fromto { get; }
    internal static string net_needchunked { get; }
    internal static string net_no100 { get; }
    internal static string net_nochunked { get; }
    internal static string net_nottoken { get; }
    internal static string net_rangetoosmall { get; }
    internal static string net_rangetype { get; }
    internal static string net_toosmall { get; }
    internal static string net_wrongversion { get; }
    internal static string net_WebHeaderInvalidControlChars { get; }
    internal static string net_WebHeaderInvalidCRLFChars { get; }
    internal static string net_WebHeaderInvalidHeaderChars { get; }
    internal static string net_timeout { get; }
    internal static string net_completed_result { get; }
    internal static string net_PropertyNotSupportedException { get; }
    internal static string net_InvalidStatusCode { get; }
    internal static string net_io_timeout_use_gt_zero { get; }
    internal static string net_ftp_servererror { get; }
    internal static string net_ftp_active_address_different { get; }
    internal static string net_ftp_invalid_method_name { get; }
    internal static string net_ftp_invalid_renameto { get; }
    internal static string net_ftp_invalid_response_filename { get; }
    internal static string net_ftp_invalid_status_response { get; }
    internal static string net_ftp_invalid_uri { get; }
    internal static string net_ftp_no_defaultcreds { get; }
    internal static string net_ftp_response_invalid_format { get; }
    internal static string net_ftp_server_failed_passive { get; }
    internal static string net_ftp_unsupported_method { get; }
    internal static string net_ftp_protocolerror { get; }
    internal static string net_ftp_receivefailure { get; }
    internal static string net_webstatus_NameResolutionFailure { get; }
    internal static string net_webstatus_ConnectFailure { get; }
    internal static string net_ftpstatuscode_ServiceNotAvailable { get; }
    internal static string net_ftpstatuscode_CantOpenData { get; }
    internal static string net_ftpstatuscode_ConnectionClosed { get; }
    internal static string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy { get; }
    internal static string net_ftpstatuscode_ActionAbortedLocalProcessingError { get; }
    internal static string net_ftpstatuscode_ActionNotTakenInsufficientSpace { get; }
    internal static string net_ftpstatuscode_CommandSyntaxError { get; }
    internal static string net_ftpstatuscode_ArgumentSyntaxError { get; }
    internal static string net_ftpstatuscode_CommandNotImplemented { get; }
    internal static string net_ftpstatuscode_BadCommandSequence { get; }
    internal static string net_ftpstatuscode_NotLoggedIn { get; }
    internal static string net_ftpstatuscode_AccountNeeded { get; }
    internal static string net_ftpstatuscode_ActionNotTakenFileUnavailable { get; }
    internal static string net_ftpstatuscode_ActionAbortedUnknownPageType { get; }
    internal static string net_ftpstatuscode_FileActionAborted { get; }
    internal static string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed { get; }
    internal static string net_invalid_host { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_net_unknown_prefix();
    internal static string get_net_reqsubmitted();
    internal static string get_net_io_timeout_use_ge_zero();
    internal static string get_net_writestarted();
    internal static string get_net_badmethod();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_servererror();
    internal static string get_net_reqaborted();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_net_OperationNotSupportedException();
    internal static string get_net_PropertyNotImplementedException();
    internal static string get_net_nouploadonget();
    internal static string get_net_repcall();
    internal static string get_net_invalid_enum();
    internal static string get_net_securityprotocolnotsupported();
    internal static string get_net_requestaborted();
    internal static string get_net_clsmall();
    internal static string get_net_webstatus_Timeout();
    internal static string get_net_baddate();
    internal static string get_net_connarg();
    internal static string get_net_fromto();
    internal static string get_net_needchunked();
    internal static string get_net_no100();
    internal static string get_net_nochunked();
    internal static string get_net_nottoken();
    internal static string get_net_rangetoosmall();
    internal static string get_net_rangetype();
    internal static string get_net_toosmall();
    internal static string get_net_wrongversion();
    internal static string get_net_WebHeaderInvalidControlChars();
    internal static string get_net_WebHeaderInvalidCRLFChars();
    internal static string get_net_WebHeaderInvalidHeaderChars();
    internal static string get_net_timeout();
    internal static string get_net_completed_result();
    internal static string get_net_PropertyNotSupportedException();
    internal static string get_net_InvalidStatusCode();
    internal static string get_net_io_timeout_use_gt_zero();
    internal static string get_net_ftp_servererror();
    internal static string get_net_ftp_active_address_different();
    internal static string get_net_ftp_invalid_method_name();
    internal static string get_net_ftp_invalid_renameto();
    internal static string get_net_ftp_invalid_response_filename();
    internal static string get_net_ftp_invalid_status_response();
    internal static string get_net_ftp_invalid_uri();
    internal static string get_net_ftp_no_defaultcreds();
    internal static string get_net_ftp_response_invalid_format();
    internal static string get_net_ftp_server_failed_passive();
    internal static string get_net_ftp_unsupported_method();
    internal static string get_net_ftp_protocolerror();
    internal static string get_net_ftp_receivefailure();
    internal static string get_net_webstatus_NameResolutionFailure();
    internal static string get_net_webstatus_ConnectFailure();
    internal static string get_net_ftpstatuscode_ServiceNotAvailable();
    internal static string get_net_ftpstatuscode_CantOpenData();
    internal static string get_net_ftpstatuscode_ConnectionClosed();
    internal static string get_net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy();
    internal static string get_net_ftpstatuscode_ActionAbortedLocalProcessingError();
    internal static string get_net_ftpstatuscode_ActionNotTakenInsufficientSpace();
    internal static string get_net_ftpstatuscode_CommandSyntaxError();
    internal static string get_net_ftpstatuscode_ArgumentSyntaxError();
    internal static string get_net_ftpstatuscode_CommandNotImplemented();
    internal static string get_net_ftpstatuscode_BadCommandSequence();
    internal static string get_net_ftpstatuscode_NotLoggedIn();
    internal static string get_net_ftpstatuscode_AccountNeeded();
    internal static string get_net_ftpstatuscode_ActionNotTakenFileUnavailable();
    internal static string get_net_ftpstatuscode_ActionAbortedUnknownPageType();
    internal static string get_net_ftpstatuscode_FileActionAborted();
    internal static string get_net_ftpstatuscode_ActionNotTakenFilenameNotAllowed();
    internal static string get_net_invalid_host();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
