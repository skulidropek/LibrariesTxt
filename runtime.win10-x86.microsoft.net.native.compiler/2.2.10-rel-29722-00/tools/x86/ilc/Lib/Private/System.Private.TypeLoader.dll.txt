internal static class FxResources.System.Private.TypeLoader.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Metadata.NativeFormat.MetadataTypeHashingAlgorithms : object {
    private static TypeAttributes NestedMask;
    private static void AppendNamespaceHashCode(HashCodeBuilder& builder, NamespaceDefinitionHandle namespaceDefHandle, MetadataReader reader);
    private static void AppendNamespaceHashCode(HashCodeBuilder& builder, NamespaceReferenceHandle namespaceRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static int ComputeHashCode(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static int ComputeHashCode(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
private static bool IsNested(TypeAttributes flags);
}
internal enum Internal.NativeFormat.BagElementKind : Enum {
    public UInt32 value__;
    public static BagElementKind End;
    public static BagElementKind BaseType;
    public static BagElementKind ImplementedInterfaces;
    public static BagElementKind DictionaryLayout;
    public static BagElementKind TypeFlags;
    public static BagElementKind NonGcStaticData;
    public static BagElementKind GcStaticData;
    public static BagElementKind NonGcStaticDataSize;
    public static BagElementKind GcStaticDataSize;
    public static BagElementKind GcStaticDesc;
    public static BagElementKind ThreadStaticDataSize;
    public static BagElementKind ThreadStaticDesc;
    public static BagElementKind ThreadStaticIndex;
    public static BagElementKind ThreadStaticOffset;
    public static BagElementKind FieldLayout;
    public static BagElementKind VTableMethodSignatures;
    public static BagElementKind SealedVTableEntries;
    public static BagElementKind ClassConstructorPointer;
    public static BagElementKind BaseTypeSize;
    public static BagElementKind GenericVarianceInfo;
    public static BagElementKind DelegateInvokeSignature;
    public static BagElementKind GcStaticEEType;
}
internal enum Internal.NativeFormat.CallingConventionConverterKind : Enum {
    public UInt32 value__;
    public static CallingConventionConverterKind NoInstantiatingParam;
    public static CallingConventionConverterKind HasInstantiatingParam;
    public static CallingConventionConverterKind MaybeInstantiatingParam;
}
internal enum Internal.NativeFormat.FieldStorage : Enum {
    public UInt32 value__;
    public static FieldStorage Instance;
    public static FieldStorage NonGCStatic;
    public static FieldStorage GCStatic;
    public static FieldStorage TLSStatic;
}
internal enum Internal.NativeFormat.FixupSignatureKind : Enum {
    public UInt32 value__;
    public static FixupSignatureKind Null;
    public static FixupSignatureKind TypeHandle;
    public static FixupSignatureKind InterfaceCall;
    public static FixupSignatureKind MethodDictionary;
    public static FixupSignatureKind StaticData;
    public static FixupSignatureKind UnwrapNullableType;
    public static FixupSignatureKind FieldLdToken;
    public static FixupSignatureKind MethodLdToken;
    public static FixupSignatureKind AllocateObject;
    public static FixupSignatureKind DefaultConstructor;
    public static FixupSignatureKind TlsIndex;
    public static FixupSignatureKind TlsOffset;
    public static FixupSignatureKind Method;
    public static FixupSignatureKind IsInst;
    public static FixupSignatureKind CastClass;
    public static FixupSignatureKind AllocateArray;
    public static FixupSignatureKind CheckArrayElementType;
    public static FixupSignatureKind TypeSize;
    public static FixupSignatureKind FieldOffset;
    public static FixupSignatureKind CallingConventionConverter;
    public static FixupSignatureKind VTableOffset;
    public static FixupSignatureKind NonGenericConstrainedMethod;
    public static FixupSignatureKind GenericConstrainedMethod;
    public static FixupSignatureKind NonGenericDirectConstrainedMethod;
    public static FixupSignatureKind PointerToOtherSlot;
    public static FixupSignatureKind IntValue;
    public static FixupSignatureKind NotYetSupported;
}
internal enum Internal.NativeFormat.GenericContextKind : Enum {
    public UInt32 value__;
    public static GenericContextKind FromThis;
    public static GenericContextKind FromHiddenArg;
    public static GenericContextKind FromMethodHiddenArg;
    public static GenericContextKind HasDeclaringType;
    public static GenericContextKind NeedsUSGContext;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodCallingConvention : Enum {
    public UInt32 value__;
    public static MethodCallingConvention Generic;
    public static MethodCallingConvention Static;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.MethodFlags : Enum {
    public UInt32 value__;
    public static MethodFlags HasInstantiation;
    public static MethodFlags IsUnboxingStub;
    public static MethodFlags HasFunctionPointer;
    public static MethodFlags FunctionPointerIsUSG;
}
internal class Internal.NativeFormat.NativeHashtable : ValueType {
    private NativeReader _reader;
    private UInt32 _baseOffset;
    private UInt32 _bucketMask;
    private byte _entryIndexSize;
    public bool IsNull { get; }
    public NativeHashtable(NativeParser parser);
    public bool get_IsNull();
    private NativeParser GetParserForBucket(UInt32 bucket, UInt32& endOffset);
    public Enumerator Lookup(int hashcode);
    public AllEntriesEnumerator EnumerateAllEntries();
}
internal class Internal.NativeFormat.NativeParser : ValueType {
    private NativeReader _reader;
    private UInt32 _offset;
    public bool IsNull { get; }
    public NativeReader Reader { get; }
    public UInt32 Offset { get; public set; }
    public NativeParser(NativeReader reader, UInt32 offset);
    public bool get_IsNull();
    public NativeReader get_Reader();
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public void ThrowBadImageFormatException();
    public byte GetUInt8();
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public int GetSigned();
    public UInt32 GetRelativeOffset();
    public void SkipInteger();
    public NativeParser GetParserFromRelativeOffset();
    public UInt32 GetSequenceCount();
    public BagElementKind GetBagElementKind();
    public FixupSignatureKind GetFixupSignatureKind();
    public TypeSignatureKind GetTypeSignatureKind(UInt32& data);
    public NativeParser GetLookbackParser(UInt32 lookback);
    public Nullable`1<UInt32> GetUnsignedForBagElementKind(BagElementKind kindToFind);
    public NativeParser GetParserForBagElementKind(BagElementKind kindToFind);
    public string GetString();
    public void SkipString();
}
internal class Internal.NativeFormat.NativePrimitiveDecoder : ValueType {
    public static void ThrowBadImageFormatException();
    public static UInt32 DecodeUnsigned(Byte*& stream, Byte* streamEnd);
    public static int DecodeSigned(Byte*& stream, Byte* streamEnd);
    public static ulong DecodeUnsignedLong(Byte*& stream, Byte* streamEnd);
    public static long DecodeSignedLong(Byte*& stream, Byte* streamEnd);
    public static void SkipInteger(Byte*& stream);
    public static byte ReadUInt8(Byte*& stream);
    public static ushort ReadUInt16(Byte*& stream);
    public static UInt32 ReadUInt32(Byte*& stream);
    public static ulong ReadUInt64(Byte*& stream);
    public static float ReadFloat(Byte*& stream);
    public static double ReadDouble(Byte*& stream);
    public static UInt32 GetUnsignedEncodingSize(UInt32 value);
    public static UInt32 DecodeUnsigned(Byte*& stream);
    public static int DecodeSigned(Byte*& stream);
    public static ulong DecodeUnsignedLong(Byte*& stream);
    public static long DecodeSignedLong(Byte*& stream);
}
internal class Internal.NativeFormat.NativePrimitiveEncoder : ValueType {
    private Byte[] _buffer;
    private int _size;
    public int Size { get; }
    public void Init();
    public int get_Size();
    public void Clear();
    public void RollbackTo(int offset);
    public void WriteByte(byte b);
    public void WriteUInt8(byte value);
    public void WriteUInt16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteFloat(float value);
    public void WriteDouble(double value);
    public void WriteUnsigned(UInt32 d);
    public static int GetUnsignedEncodingSize(UInt32 d);
    public void WriteSigned(int i);
    public void WriteUnsignedLong(ulong i);
    public void WriteSignedLong(long i);
    public void PatchByteAt(int offset, byte value);
    public void Save(Stream stream);
    public bool Save(Byte* stream, int streamLength);
    public Byte[] GetBytes();
}
internal class Internal.NativeFormat.NativeReader : object {
    private Byte* _base;
    private UInt32 _size;
    public UInt32 Size { get; }
    public NativeReader(Byte* base_, UInt32 size);
    public UInt32 get_Size();
    public UInt32 AddressToOffset(IntPtr address);
    public IntPtr OffsetToAddress(UInt32 offset);
    public void ThrowBadImageFormatException();
    private UInt32 EnsureOffsetInRange(UInt32 offset, UInt32 lookAhead);
    public byte ReadUInt8(UInt32 offset);
    public ushort ReadUInt16(UInt32 offset);
    public UInt32 ReadUInt32(UInt32 offset);
    public ulong ReadUInt64(UInt32 offset);
    public float ReadFloat(UInt32 offset);
    public double ReadDouble(UInt32 offset);
    public UInt32 DecodeUnsigned(UInt32 offset, UInt32& value);
    public UInt32 DecodeSigned(UInt32 offset, Int32& value);
    public UInt32 DecodeUnsignedLong(UInt32 offset, UInt64& value);
    public UInt32 DecodeSignedLong(UInt32 offset, Int64& value);
    public UInt32 SkipInteger(UInt32 offset);
    public string ReadString(UInt32 offset);
    public UInt32 DecodeString(UInt32 offset, String& value);
    public UInt32 SkipString(UInt32 offset);
    public bool StringEquals(UInt32 offset, string value);
}
internal enum Internal.NativeFormat.StaticDataKind : Enum {
    public UInt32 value__;
    public static StaticDataKind Gc;
    public static StaticDataKind NonGc;
}
[FlagsAttribute]
internal enum Internal.NativeFormat.TypeFlags : Enum {
    public UInt32 value__;
    public static TypeFlags HasClassConstructor;
    public static TypeFlags HasInstantiationDeterminedSize;
}
[__BlockReflectionAttribute]
public static class Internal.NativeFormat.TypeHashingAlgorithms : object {
    private static int _rotl(int value, int shift);
    public static int ComputeNameHashCode(string src);
    public static int ComputeASCIINameHashCode(Byte* data, int length, Boolean& isAscii);
    private static string IntToString(int arg);
    public static int ComputeArrayTypeHashCode(int elementTypeHashCode, int rank);
    public static int ComputeArrayTypeHashCode(T elementType, int rank);
    public static int ComputePointerTypeHashCode(int pointeeTypeHashCode);
    public static int ComputePointerTypeHashCode(T pointeeType);
    public static int ComputeByrefTypeHashCode(int parameterTypeHashCode);
    public static int ComputeByrefTypeHashCode(T parameterType);
    public static int ComputeNestedTypeHashCode(int enclosingTypeHashCode, int nestedTypeNameHash);
    public static int ComputeGenericInstanceHashCode(int genericDefinitionHashCode, ARG[] genericTypeArguments);
    public static int ComputeMethodSignatureHashCode(int returnTypeHashCode, ARG[] parameters);
    public static int ComputeMethodHashCode(int typeHashCode, int nameOrNameAndGenericArgumentsHashCode);
    public static int ComputeSignatureVariableHashCode(int index, bool method);
}
internal enum Internal.NativeFormat.TypeModifierKind : Enum {
    public UInt32 value__;
    public static TypeModifierKind Array;
    public static TypeModifierKind ByRef;
    public static TypeModifierKind Pointer;
}
internal enum Internal.NativeFormat.TypeSignatureKind : Enum {
    public UInt32 value__;
    public static TypeSignatureKind Null;
    public static TypeSignatureKind Lookback;
    public static TypeSignatureKind Modifier;
    public static TypeSignatureKind Instantiation;
    public static TypeSignatureKind Variable;
    public static TypeSignatureKind BuiltIn;
    public static TypeSignatureKind External;
    public static TypeSignatureKind MultiDimArray;
    public static TypeSignatureKind FunctionPointer;
}
[__BlockReflectionAttribute]
public abstract class Internal.Reflection.Core.AssemblyBinder : object {
    public static string DefaultAssemblyNameForGetType;
    public abstract virtual bool Bind(RuntimeAssemblyName refName, bool cacheMissedLookups, AssemblyBindResult& result, Exception& exception);
    public abstract virtual bool Bind(Byte[] rawAssembly, Byte[] rawSymbolStore, AssemblyBindResult& result, Exception& exception);
    public abstract virtual IList`1<AssemblyBindResult> GetLoadedAssemblies();
}
[__BlockReflectionAttribute]
public class Internal.Reflection.Core.AssemblyBindResult : ValueType {
    public MetadataReader Reader;
    public ScopeDefinitionHandle ScopeDefinitionHandle;
    public IEnumerable`1<QScopeDefinition> OverflowScopes;
}
[__BlockReflectionAttribute]
public class Internal.Reflection.Core.QScopeDefinition : ValueType {
    private MetadataReader _reader;
    private ScopeDefinitionHandle _handle;
    public MetadataReader Reader { get; }
    public ScopeDefinitionHandle Handle { get; }
    public ScopeDefinition ScopeDefinition { get; }
    public QScopeDefinition(MetadataReader reader, ScopeDefinitionHandle handle);
    public MetadataReader get_Reader();
    public ScopeDefinitionHandle get_Handle();
    public ScopeDefinition get_ScopeDefinition();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(QScopeDefinition other);
    public virtual int GetHashCode();
}
[__BlockReflectionAttribute]
public class Internal.Reflection.Execution.AssemblyBinderImplementation : AssemblyBinder {
    [CompilerGeneratedAttribute]
private static AssemblyBinderImplementation <Instance>k__BackingField;
    private KeyValuePair`2[] modreq(System.Runtime.CompilerServices.IsVolatile) _scopeGroups;
    public static AssemblyBinderImplementation Instance { get; }
    private KeyValuePair`2[] ScopeGroups { get; }
    private static AssemblyBinderImplementation();
    [CompilerGeneratedAttribute]
public static AssemblyBinderImplementation get_Instance();
    public sealed virtual bool Bind(Byte[] rawAssembly, Byte[] rawSymbolStore, AssemblyBindResult& bindResult, Exception& exception);
    public sealed virtual bool Bind(RuntimeAssemblyName refName, bool cacheMissedLookups, AssemblyBindResult& result, Exception& exception);
    public sealed virtual IList`1<AssemblyBindResult> GetLoadedAssemblies();
    private bool MscorlibAssemblyNameMatches(RuntimeAssemblyName coreAssemblyName, RuntimeAssemblyName defName);
    private bool AssemblyNameMatches(RuntimeAssemblyName refName, RuntimeAssemblyName defName, Exception& preferredException);
    private static bool AssemblyVersionMatches(Version refVersion, Version defVersion);
    private void RegisterModule(ModuleInfo moduleInfo);
    private KeyValuePair`2[] get_ScopeGroups();
    private void AddScopesFromReaderToGroups(LowLevelDictionaryWithIEnumerable`2<RuntimeAssemblyName, ScopeDefinitionGroup> groups, MetadataReader reader);
    private static bool ArePktsEqual(Byte[] pkt1, Byte[] pkt2);
}
internal class Internal.Reflection.ExplicitScopeAttribute : Attribute {
    public ExplicitScopeAttribute(string p0);
}
internal class Internal.Runtime.ArchitectureConstants : ValueType {
    public static int MAX_ARG_SIZE;
    public static int NUM_ARGUMENT_REGISTERS;
    public static int ARGUMENTREGISTERS_SIZE;
    public static int ENREGISTERED_RETURNTYPE_MAXSIZE;
    public static int ENREGISTERED_RETURNTYPE_INTEGER_MAXSIZE;
    public static int ENREGISTERED_RETURNTYPE_INTEGER_MAXSIZE_PRIMITIVE;
    public static int STACK_ELEM_SIZE;
    public static int StackElemSize(int size);
}
internal class Internal.Runtime.ArgumentRegisters : ValueType {
    public IntPtr edx;
    public IntPtr ecx;
    public static int GetOffsetOfEdx();
    public static int GetOffsetOfEcx();
}
internal static class Internal.Runtime.ArrayTypesConstants : object {
    public static int MaxSizeForValueClassInArray;
}
internal class Internal.Runtime.CallConverter.ArgIterator : ValueType {
    private bool _hasThis;
    private bool _hasParamType;
    private bool _extraFunctionPointerArg;
    private ArgIteratorData _argData;
    private Boolean[] _forcedByRefParams;
    private bool _skipFirstArg;
    private bool _extraObjectFirstArg;
    private CallingConvention _interpreterCallingConvention;
    private int _nSizeOfArgStack;
    private int _argNum;
    private CorElementType _argType;
    private int _argSize;
    private TypeHandle _argTypeHandle;
    private TypeHandle _argTypeHandleOfByRefParam;
    private bool _argForceByRef;
    private int _curOfs;
    private int _numRegistersUsed;
    private bool _ITERATION_STARTED;
    private bool _SIZE_OF_ARG_STACK_COMPUTED;
    private bool _RETURN_FLAGS_COMPUTED;
    private bool _RETURN_HAS_RET_BUFFER;
    private UInt32 _fpReturnSize;
    private ParamTypeLocation _paramTypeLoc;
    public ArgIterator(ArgIteratorData argData, CallingConvention callConv, bool hasParamType, bool extraFunctionPointerArg, Boolean[] forcedByRefParams, bool skipFirstArg, bool extraObjectFirstArg);
    public bool HasThis();
    public bool IsVarArg();
    public bool HasParamType();
    public int NumFixedArgs();
    public CorElementType GetArgumentType(int argNum, TypeHandle& thArgType, Boolean& forceByRefReturn);
    public CorElementType GetReturnType(TypeHandle& thRetType, Boolean& forceByRefReturn);
    public void Reset();
    public void SetHasParamTypeAndReset(bool value);
    public void SetHasThisAndReset(bool value);
    private UInt32 SizeOfArgStack();
    public int SizeOfFrameArgumentArray();
    public int CbStackPop();
    public bool HasRetBuffArg();
    public UInt32 GetFPReturnSize();
    private static bool IsArgumentInRegister(Int32& pNumRegistersUsed, CorElementType typ, TypeHandle thArgType);
    public bool IsArgPassedByRef();
    private bool IsArgForcedPassedByRef();
    public static int GetThisOffset();
    public int GetRetBuffArgOffset();
    public int GetVASigCookieOffset();
    public int GetParamTypeArgOffset();
    public int GetNextOffset();
    public CorElementType GetArgType(TypeHandle& pTypeHandle);
    public CorElementType GetByRefArgType(TypeHandle& pByRefArgTypeHandle);
    public int GetArgSize();
    private void ForceSigWalk();
    internal static void ComputeReturnValueTreatment(CorElementType type, TypeHandle thRetType, bool isVarArgMethod, Boolean& usesRetBuffer, UInt32& fpReturnSize);
    private void ComputeReturnFlags();
    public static int ALIGN_UP(int input, int align_to);
    public static bool IS_ALIGNED(IntPtr val, int alignment);
    public static bool IsRetBuffPassedAsFirstArg();
}
internal class Internal.Runtime.CallConverter.ArgIteratorData : object {
    private bool _hasThis;
    private bool _isVarArg;
    private TypeHandle[] _parameterTypes;
    private TypeHandle _returnType;
    public ArgIteratorData(bool hasThis, bool isVarArg, TypeHandle[] parameterTypes, TypeHandle returnType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool HasThis();
    public bool IsVarArg();
    public int NumFixedArgs();
    public CorElementType GetArgumentType(int argNum, TypeHandle& thArgType);
    public TypeHandle GetByRefArgumentType(int argNum);
    public CorElementType GetReturnType(TypeHandle& thRetType);
}
internal class Internal.Runtime.CallConverter.ArgLocDesc : ValueType {
    public int m_idxFloatReg;
    public int m_cFloatReg;
    public int m_idxGenReg;
    public int m_cGenReg;
    public int m_idxStack;
    public int m_cStack;
    public void Init();
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.CallConverter.CallingConvention : Enum {
    public int value__;
    public static CallingConvention ManagedInstance;
    public static CallingConvention ManagedStatic;
    public static CallingConvention StdCall;
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.CallConverter.CallingConventionInfo : object {
    public static bool TypeUsesReturnBuffer(RuntimeTypeHandle returnType, bool methodWithReturnTypeIsVarArg);
}
internal class Internal.Runtime.CallConverter.TypeHandle : ValueType {
    private EEType* _eeType;
    private bool _isByRef;
    private static Int32[] s_elemSizes;
    public TypeHandle(bool isByRef, RuntimeTypeHandle eeType);
    private static TypeHandle();
    public bool Equals(TypeHandle other);
    public virtual int GetHashCode();
    public bool IsNull();
    public bool IsValueType();
    public bool IsPointerType();
    public UInt32 GetSize();
    public bool RequiresAlign8();
    public bool IsHFA();
    public CorElementType GetHFAType();
    public CorElementType GetCorElementType();
    public static int GetElemSize(CorElementType t, TypeHandle thValueType);
    public RuntimeTypeHandle GetRuntimeTypeHandle();
}
internal static class Internal.Runtime.CallInterceptor.CallConversionInterpreter : object {
    public static int ArgBlock;
    public static int LocalBlock;
    private static void SetupLocalsBlock1(Void* pBuffer, CallConversionInterpreterLocals& locals);
    private static void SetupLocalsBlock2(Void* pBuffer, CallConversionInterpreterLocals& locals);
    private static void SetupTransitionBlock(Void* pBuffer, CallConversionInterpreterLocals& locals);
    public static void Interpret(CallConversionInterpreterLocals& locals);
}
internal class Internal.Runtime.CallInterceptor.CallConversionOperation : ValueType {
    public static int HasFPArgsFlag;
    public OpCode Op;
    public int X;
    public int Y;
    public int Z;
    public int W;
    public CallConversionOperation(OpCode op, int X, int Y, int Z, int W);
    public CallConversionOperation(OpCode op, int X, int Y, int Z);
    public CallConversionOperation(OpCode op, int X, int Y);
    public CallConversionOperation(OpCode op, int X);
    public CallConversionOperation(OpCode op);
}
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.CallInterceptor.CallInterceptor : object {
    private bool _nativeToManaged;
    private int _id;
    private IntPtr _thunkAddress;
    private static object s_thunkPoolHeap;
    internal static CallingConventionConverter_CommonCallingStub_PointerData s_managedToManagedCommonStubData;
    internal static CallingConventionConverter_CommonCallingStub_PointerData s_nativeToManagedCommonStubData;
    internal static LowLevelList`1<CallInterceptor> s_callInterceptors;
    internal static LowLevelList`1<int> s_freeCallInterceptorIds;
    private static int s_countFreeCallInterceptorId;
    private static LocalVariableType[] s_ReturnBlockTypes;
    public LocalVariableType[] ArgumentAndReturnTypes { get; }
    public CallingConvention CallingConvention { get; }
    public LocalVariableType[] LocalVariableTypes { get; }
    protected CallInterceptor(bool nativeToManaged);
    private static CallInterceptor();
    public abstract virtual LocalVariableType[] get_ArgumentAndReturnTypes();
    public abstract virtual CallingConvention get_CallingConvention();
    public abstract virtual LocalVariableType[] get_LocalVariableTypes();
    public abstract virtual void ThunkExecute(CallInterceptorArgs& callInterceptor);
    private int GetThunkId();
    public IntPtr GetThunkAddress();
    public void FreeThunk();
    public static void FreeThunk(IntPtr thunkAddress);
    public static void MakeDynamicCall(IntPtr address, DynamicCallSignature callSignature, LocalVariableSet arguments);
    private static CallInterceptor GetInterceptorFromId(IntPtr id);
    private CallConversionInterpreterLocals GetInterpreterLocals();
    private CallConversionOperation[] BuildOpsListForThunk(CallingConvention callingConvention, LocalVariableType[] returnAndArgumentTypes, LocalVariableType[] locals);
    private static IntPtr CallInterceptorThunk(IntPtr callerTransitionBlockParam, IntPtr thunkId);
    [NativeCallableAttribute]
private static IntPtr CallInterceptorThunkNativeCallable(IntPtr callerTransitionBlockParam, IntPtr thunkId);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CallInterceptor.CallInterceptorArgs : ValueType {
    public LocalVariableSet ArgumentsAndReturnValue;
    public LocalVariableSet Locals;
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CallInterceptor.DynamicCallSignature : object {
    private CallConversionOperation[] _callConversionOpsNormal;
    private CallConversionOperation[] _callConversionOpsFatPtr;
    private CallingConvention _callingConvention;
    internal static LocalVariableType[] s_returnBlockDescriptor;
    internal CallConversionOperation[] NormalOps { get; }
    internal CallConversionOperation[] FatOps { get; }
    internal CallingConvention CallingConvention { get; }
    public DynamicCallSignature(CallingConvention callingConvention, LocalVariableType[] returnAndArgumentTypes, int returnAndArgTypesToUse);
    private static DynamicCallSignature();
    internal CallConversionOperation[] get_NormalOps();
    internal CallConversionOperation[] get_FatOps();
    internal CallingConvention get_CallingConvention();
    private static CallConversionOperation[] ProduceOpcodesForDynamicCall(CallingConvention callingConvention, LocalVariableType[] returnAndArgumentTypes, int returnAndArgTypesToUse, bool fatFunctionPointer);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CallInterceptor.LocalVariableSet : ValueType {
    private IntPtr* _pbMemory;
    private LocalVariableType[] _types;
    public LocalVariableSet(IntPtr* pbMemory, LocalVariableType[] types);
    public T GetVar(int index);
    public void SetVar(int index, T value);
    public void SetByRef(int targetIndex, LocalVariableSet& sourceLocalSet, int sourceIndex);
    public IntPtr GetAddressOfVarData(int index);
    internal IntPtr* GetRawMemoryPointer();
    private static void SetupArbitraryLocalVariableSet_Inner(IntPtr* localData, T& context, SetupLocalVariableSetInfo`1& localVarSetInfo);
    public static void SetupArbitraryLocalVariableSet(LocalVariableSetFunc`1<T> callback, T& param, LocalVariableType[] types);
    public static void DefaultInitializeLocalVariableSet(LocalVariableSet& localSet);
    public static int ComputeNecessaryMemoryForStackLocalVariableSet(LocalVariableType[] types);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CallInterceptor.LocalVariableSetFunc`1 : MulticastDelegate {
    public LocalVariableSetFunc`1(object object, IntPtr method);
    public virtual void Invoke(T& param, LocalVariableSet& variables);
    public virtual IAsyncResult BeginInvoke(T& param, LocalVariableSet& variables, AsyncCallback callback, object object);
    public virtual void EndInvoke(T& param, LocalVariableSet& variables, IAsyncResult result);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CallInterceptor.LocalVariableType : ValueType {
    public RuntimeTypeHandle TypeHandle;
    public bool Pinned;
    public bool ByRef;
    internal int TypeInstanceFieldSize { get; }
    internal int TypeInstanceFieldAlignment { get; }
    internal bool IsValueType { get; }
    public LocalVariableType(RuntimeTypeHandle typeHandle, bool pinned, bool byRef);
    internal int get_TypeInstanceFieldSize();
    internal int get_TypeInstanceFieldAlignment();
    internal bool get_IsValueType();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.CompilerHelpers.LibraryInitializer : object {
    public static void InitializeLibrary();
}
internal enum Internal.Runtime.CorElementType : Enum {
    public int value__;
    public static CorElementType ELEMENT_TYPE_END;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
}
[__BlockReflectionAttribute]
public class Internal.Runtime.DebuggerSupport.LowLevelNativeFormatReader : object {
    private NativeReader _nativeReader;
    private UInt32 _offset;
    internal NativeReader InternalReader { get; }
    internal UInt32 Offset { get; internal set; }
    public LowLevelNativeFormatReader(Byte* buffer, UInt32 bufferSize);
    public UInt32 GetUnsigned();
    public ulong GetUnsignedLong();
    public RuntimeSignature CreateRuntimeSignature();
    internal NativeReader get_InternalReader();
    internal UInt32 get_Offset();
    internal void set_Offset(UInt32 value);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.DebuggerSupport.TypeSystemHelper : object {
    public static IntPtr GetVirtualMethodFunctionPointer(IntPtr thisPointer, UInt32 virtualMethodSlot);
    public static bool IsValueType(RuntimeTypeHandle runtimeTypeHandle);
    public static IntPtr GetInterfaceDispatchFunctionPointer(IntPtr thisPointer, RuntimeTypeHandle interfaceType, UInt32 virtualMethodSlot);
    public static bool CallingConverterDataFromMethodSignature(LowLevelNativeFormatReader reader, UInt64[] externalReferences, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& paramsWithDependentLayout);
    public static RuntimeTypeHandle GetConstructedRuntimeTypeHandle(LowLevelNativeFormatReader reader, UInt64[] externalReferences);
    private static TypeDesc GetConstructedType(LowLevelNativeFormatReader reader, UInt64[] externalReferences);
}
[DefaultMemberAttribute("Item")]
internal class Internal.Runtime.DispatchMap : ValueType {
    private UInt32 _entryCount;
    private DispatchMapEntry _dispatchMap;
    public bool IsEmpty { get; }
    public UInt32 NumEntries { get; public set; }
    public int Size { get; }
    public DispatchMapEntry* Item { get; }
    public bool get_IsEmpty();
    public UInt32 get_NumEntries();
    public void set_NumEntries(UInt32 value);
    public int get_Size();
    public DispatchMapEntry* get_Item(int index);
}
internal class Internal.Runtime.DynamicInvokeMapEntry : ValueType {
    public static UInt32 IsImportMethodFlag;
    public static UInt32 InstantiationDetailIndexMask;
}
internal class Internal.Runtime.DynamicModule : ValueType {
    private int _cbSize;
    private IntPtr _dynamicTypeSlotDispatchResolve;
    private IntPtr _getRuntimeException;
    public static int DynamicModuleSize;
    public int CbSize { get; public set; }
    public IntPtr DynamicTypeSlotDispatchResolve { get; public set; }
    public IntPtr GetRuntimeException { get; public set; }
    private static DynamicModule();
    public int get_CbSize();
    public void set_CbSize(int value);
    public IntPtr get_DynamicTypeSlotDispatchResolve();
    public void set_DynamicTypeSlotDispatchResolve(IntPtr value);
    public IntPtr get_GetRuntimeException();
    public void set_GetRuntimeException(IntPtr value);
}
internal class Internal.Runtime.EEInterfaceInfo : ValueType {
    private InterfaceTypeUnion _interfaceType;
    internal EEType* InterfaceType { get; internal set; }
    internal EEType* get_InterfaceType();
    internal void set_InterfaceType(EEType* value);
}
internal class Internal.Runtime.EEType : ValueType {
    private static int POINTER_SIZE;
    private static int PADDING;
    internal static int SZARRAY_BASE_SIZE;
    private ushort _usComponentSize;
    private ushort _usFlags;
    private UInt32 _uBaseSize;
    private RelatedTypeUnion _relatedType;
    private ushort _usNumVtableSlots;
    private ushort _usNumInterfaces;
    private UInt32 _uHashCode;
    private IntPtr _ppTypeManager;
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    internal static bool SupportsRelativePointers { get; }
    internal ushort ComponentSize { get; internal set; }
    internal ushort GenericArgumentCount { get; internal set; }
    internal ushort Flags { get; internal set; }
    internal UInt32 BaseSize { get; internal set; }
    internal ushort NumVtableSlots { get; internal set; }
    internal ushort NumInterfaces { get; internal set; }
    internal UInt32 HashCode { get; internal set; }
    private EETypeKind Kind { get; }
    internal bool HasOptionalFields { get; }
    internal bool HasGenericVariance { get; }
    internal bool IsFinalizable { get; }
    internal bool IsNullable { get; }
    internal bool IsCloned { get; }
    internal bool IsCanonical { get; }
    internal bool IsString { get; }
    internal bool IsArray { get; }
    internal int ArrayRank { get; }
    internal bool IsSzArray { get; }
    internal bool IsGeneric { get; }
    internal bool IsGenericTypeDefinition { get; }
    internal EEType* GenericDefinition { get; internal set; }
    internal UInt32 GenericArity { get; }
    internal EETypeRef* GenericArguments { get; }
    internal GenericVariance* GenericVariance { get; }
    internal bool IsPointerType { get; }
    internal bool IsByRefType { get; }
    internal bool IsInterface { get; }
    internal bool IsAbstract { get; }
    internal bool IsByRefLike { get; }
    internal bool IsDynamicType { get; }
    internal bool HasDynamicallyAllocatedDispatchMap { get; }
    internal bool IsNullableTypeViaIAT { get; }
    internal bool IsParameterizedType { get; }
    internal UInt32 ParameterizedTypeShape { get; internal set; }
    internal bool IsRelatedTypeViaIAT { get; }
    internal bool RequiresAlign8 { get; }
    internal bool IsICastable { get; }
    internal IntPtr ICastableIsInstanceOfInterfaceMethod { get; }
    internal IntPtr ICastableGetImplTypeMethod { get; }
    internal bool IsValueType { get; }
    internal bool HasGCPointers { get; internal set; }
    internal bool IsHFA { get; }
    internal UInt32 ValueTypeFieldPadding { get; }
    internal UInt32 ValueTypeSize { get; }
    internal UInt32 FieldByteCountNonGCAligned { get; }
    internal EEInterfaceInfo* InterfaceMap { get; }
    internal bool HasDispatchMap { get; }
    internal IntPtr FinalizerCode { get; internal set; }
    internal EEType* BaseType { get; internal set; }
    internal EEType* NonArrayBaseType { get; }
    internal EEType* NonClonedNonArrayBaseType { get; }
    internal EEType* RawBaseType { get; }
    internal EEType* CanonicalEEType { get; }
    internal EEType* NullableType { get; internal set; }
    internal byte NullableValueOffset { get; }
    internal EEType* RelatedParameterType { get; internal set; }
    internal Byte* OptionalFieldsPtr { get; internal set; }
    internal EEType* DynamicTemplateType { get; internal set; }
    internal IntPtr DynamicGcStaticsData { get; internal set; }
    internal IntPtr DynamicNonGcStaticsData { get; internal set; }
    internal DynamicModule* DynamicModule { get; internal set; }
    internal IntPtr TypeManager { get; }
    internal IntPtr PointerToTypeManager { get; internal set; }
    internal EETypeRareFlags RareFlags { get; }
    internal int FieldAlignmentRequirement { get; }
    internal CorElementType CorElementType { get; }
    public bool HasCctor { get; }
    [IntrinsicAttribute]
internal static bool get_SupportsRelativePointers();
    internal ushort get_ComponentSize();
    internal void set_ComponentSize(ushort value);
    internal ushort get_GenericArgumentCount();
    internal void set_GenericArgumentCount(ushort value);
    internal ushort get_Flags();
    internal void set_Flags(ushort value);
    internal UInt32 get_BaseSize();
    internal void set_BaseSize(UInt32 value);
    internal ushort get_NumVtableSlots();
    internal void set_NumVtableSlots(ushort value);
    internal ushort get_NumInterfaces();
    internal void set_NumInterfaces(ushort value);
    internal UInt32 get_HashCode();
    internal void set_HashCode(UInt32 value);
    private EETypeKind get_Kind();
    internal bool get_HasOptionalFields();
    internal bool get_HasGenericVariance();
    internal bool get_IsFinalizable();
    internal bool get_IsNullable();
    internal bool get_IsCloned();
    internal bool get_IsCanonical();
    internal bool get_IsString();
    internal bool get_IsArray();
    internal int get_ArrayRank();
    internal bool get_IsSzArray();
    internal bool get_IsGeneric();
    internal bool get_IsGenericTypeDefinition();
    internal EEType* get_GenericDefinition();
    internal void set_GenericDefinition(EEType* value);
    internal UInt32 get_GenericArity();
    internal EETypeRef* get_GenericArguments();
    internal GenericVariance* get_GenericVariance();
    internal bool get_IsPointerType();
    internal bool get_IsByRefType();
    internal bool get_IsInterface();
    internal bool get_IsAbstract();
    internal bool get_IsByRefLike();
    internal bool get_IsDynamicType();
    internal bool get_HasDynamicallyAllocatedDispatchMap();
    internal bool get_IsNullableTypeViaIAT();
    internal bool get_IsParameterizedType();
    internal UInt32 get_ParameterizedTypeShape();
    internal void set_ParameterizedTypeShape(UInt32 value);
    internal bool get_IsRelatedTypeViaIAT();
    internal bool get_RequiresAlign8();
    internal bool get_IsICastable();
    internal IntPtr get_ICastableIsInstanceOfInterfaceMethod();
    internal IntPtr get_ICastableGetImplTypeMethod();
    internal bool get_IsValueType();
    internal bool get_HasGCPointers();
    internal void set_HasGCPointers(bool value);
    internal bool get_IsHFA();
    internal UInt32 get_ValueTypeFieldPadding();
    internal UInt32 get_ValueTypeSize();
    internal UInt32 get_FieldByteCountNonGCAligned();
    internal EEInterfaceInfo* get_InterfaceMap();
    internal bool get_HasDispatchMap();
    internal IntPtr get_FinalizerCode();
    internal void set_FinalizerCode(IntPtr value);
    internal EEType* get_BaseType();
    internal void set_BaseType(EEType* value);
    internal EEType* get_NonArrayBaseType();
    internal EEType* get_NonClonedNonArrayBaseType();
    internal EEType* get_RawBaseType();
    internal EEType* get_CanonicalEEType();
    internal EEType* get_NullableType();
    internal void set_NullableType(EEType* value);
    internal byte get_NullableValueOffset();
    internal EEType* get_RelatedParameterType();
    internal void set_RelatedParameterType(EEType* value);
    internal IntPtr* GetVTableStartAddress();
    private static IntPtr FollowRelativePointer(Int32* pDist);
    internal IntPtr GetSealedVirtualSlot(ushort slotNumber);
    internal void SetSealedVirtualSlot(IntPtr value, ushort slotNumber);
    internal Byte* get_OptionalFieldsPtr();
    internal void set_OptionalFieldsPtr(Byte* value);
    internal EEType* get_DynamicTemplateType();
    internal void set_DynamicTemplateType(EEType* value);
    internal IntPtr get_DynamicGcStaticsData();
    internal void set_DynamicGcStaticsData(IntPtr value);
    internal IntPtr get_DynamicNonGcStaticsData();
    internal void set_DynamicNonGcStaticsData(IntPtr value);
    internal DynamicModule* get_DynamicModule();
    internal void set_DynamicModule(DynamicModule* value);
    internal IntPtr get_TypeManager();
    internal IntPtr get_PointerToTypeManager();
    internal void set_PointerToTypeManager(IntPtr value);
    internal EETypeRareFlags get_RareFlags();
    internal int get_FieldAlignmentRequirement();
    internal CorElementType get_CorElementType();
    public bool get_HasCctor();
    public UInt32 GetFieldOffset(EETypeField eField);
    public T& GetField(EETypeField eField);
    internal static UInt32 GetSizeofEEType(ushort cVirtuals, ushort cInterfaces, bool fHasFinalizer, bool fRequiresOptionalFields, bool fRequiresNullableType, bool fHasSealedVirtuals, bool fHasGenericInfo, bool fHasNonGcStatics, bool fHasGcStatics, bool fHasThreadStatics);
    private static EEType* GetArrayEEType();
    internal RuntimeTypeHandle ToRuntimeTypeHandle();
}
internal static class Internal.Runtime.EETypeBuilderHelpers : object {
    private static UInt32 ValueTypePaddingLowMask;
    private static UInt32 ValueTypePaddingHighMask;
    private static UInt32 ValueTypePaddingMax;
    private static int ValueTypePaddingHighShift;
    private static UInt32 ValueTypePaddingAlignmentMask;
    private static int ValueTypePaddingAlignmentShift;
    private static CorElementType ComputeRhCorElementType(TypeDesc type);
    public static ushort ComputeFlags(TypeDesc type);
    public static bool ComputeRequiresAlign8(TypeDesc type);
    internal static UInt32 ComputeValueTypeFieldPaddingFieldValue(UInt32 padding, UInt32 alignment, int targetPointerSize);
}
internal enum Internal.Runtime.EETypeField : Enum {
    public int value__;
    public static EETypeField ETF_InterfaceMap;
    public static EETypeField ETF_Finalizer;
    public static EETypeField ETF_OptionalFieldsPtr;
    public static EETypeField ETF_NullableType;
    public static EETypeField ETF_SealedVirtualSlots;
    public static EETypeField ETF_DynamicTemplateType;
    public static EETypeField ETF_DynamicDispatchMap;
    public static EETypeField ETF_DynamicModule;
    public static EETypeField ETF_GenericDefinition;
    public static EETypeField ETF_GenericComposition;
    public static EETypeField ETF_DynamicGcStatics;
    public static EETypeField ETF_DynamicNonGcStatics;
    public static EETypeField ETF_DynamicThreadStaticOffset;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeFlags : Enum {
    public ushort value__;
    public static EETypeFlags EETypeKindMask;
    public static EETypeFlags RelatedTypeViaIATFlag;
    public static EETypeFlags ValueTypeFlag;
    public static EETypeFlags HasFinalizerFlag;
    public static EETypeFlags HasPointersFlag;
    public static EETypeFlags ICastableFlag;
    public static EETypeFlags GenericVarianceFlag;
    public static EETypeFlags OptionalFieldsFlag;
    public static EETypeFlags IsInterfaceFlag;
    public static EETypeFlags IsGenericFlag;
    public static EETypeFlags CorElementTypeMask;
    public static EETypeFlags CorElementTypeShift;
    public static EETypeFlags ComplexCastingMask;
}
internal enum Internal.Runtime.EETypeKind : Enum {
    public ushort value__;
    public static EETypeKind CanonicalEEType;
    public static EETypeKind ClonedEEType;
    public static EETypeKind ParameterizedEEType;
    public static EETypeKind GenericTypeDefEEType;
}
internal enum Internal.Runtime.EETypeOptionalFieldTag : Enum {
    public byte value__;
    public static EETypeOptionalFieldTag RareFlags;
    public static EETypeOptionalFieldTag ICastableIsInstSlot;
    public static EETypeOptionalFieldTag DispatchMap;
    public static EETypeOptionalFieldTag ValueTypeFieldPadding;
    public static EETypeOptionalFieldTag ICastableGetImplTypeSlot;
    public static EETypeOptionalFieldTag NullableValueOffset;
    public static EETypeOptionalFieldTag Count;
}
[FlagsAttribute]
internal enum Internal.Runtime.EETypeRareFlags : Enum {
    public int value__;
    public static EETypeRareFlags RequiresAlign8Flag;
    public static EETypeRareFlags UNUSED1;
    public static EETypeRareFlags IsNullableFlag;
    public static EETypeRareFlags NullableTypeViaIATFlag;
    public static EETypeRareFlags IsDynamicTypeFlag;
    public static EETypeRareFlags HasCctorFlag;
    public static EETypeRareFlags UNUSED2;
    public static EETypeRareFlags HasDynamicallyAllocatedDispatchMapFlag;
    public static EETypeRareFlags IsHFAFlag;
    public static EETypeRareFlags HasSealedVTableEntriesFlag;
    public static EETypeRareFlags IsDynamicTypeWithGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithNonGcStatics;
    public static EETypeRareFlags IsDynamicTypeWithThreadStatics;
    public static EETypeRareFlags HasDynamicModuleFlag;
    public static EETypeRareFlags IsAbstractClassFlag;
    public static EETypeRareFlags IsByRefLikeFlag;
}
internal class Internal.Runtime.EETypeRef : ValueType {
    private Byte* _value;
    public EEType* Value { get; public set; }
    public EEType* get_Value();
    public void set_Value(EEType* value);
}
internal static class Internal.Runtime.FatFunctionPointerConstants : object {
    public static int Offset;
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum Internal.Runtime.FieldTableFlags : Enum {
    public UInt32 value__;
    public static FieldTableFlags Instance;
    public static FieldTableFlags Static;
    public static FieldTableFlags ThreadStatic;
    public static FieldTableFlags StorageClass;
    public static FieldTableFlags IsUniversalCanonicalEntry;
    public static FieldTableFlags HasMetadataHandle;
    public static FieldTableFlags IsGcSection;
    public static FieldTableFlags FieldOffsetEncodedDirectly;
    public static FieldTableFlags IsAnyCanonicalEntry;
}
internal class Internal.Runtime.FloatArgumentRegisters : ValueType {
}
internal static class Internal.Runtime.GCStaticRegionConstants : object {
    public static int Uninitialized;
    public static int HasPreInitializedData;
    public static int Mask;
}
internal enum Internal.Runtime.GenericVariance : Enum {
    public byte value__;
    public static GenericVariance NonVariant;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
    public static GenericVariance ArrayCovariant;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwarePointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.IatAwareRelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal static class Internal.Runtime.IndirectionConstants : object {
    public static int IndirectionCellPointer;
    public static UInt32 RVAPointsToIndirection;
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum Internal.Runtime.InvokeTableFlags : Enum {
    public UInt32 value__;
    public static InvokeTableFlags HasVirtualInvoke;
    public static InvokeTableFlags IsGenericMethod;
    public static InvokeTableFlags HasMetadataHandle;
    public static InvokeTableFlags IsDefaultConstructor;
    public static InvokeTableFlags RequiresInstArg;
    public static InvokeTableFlags HasEntrypoint;
    public static InvokeTableFlags IsUniversalCanonicalEntry;
    public static InvokeTableFlags NeedsParameterInterpretation;
    public static InvokeTableFlags CallingConventionDefault;
    public static InvokeTableFlags Cdecl;
    public static InvokeTableFlags Winapi;
    public static InvokeTableFlags StdCall;
    public static InvokeTableFlags ThisCall;
    public static InvokeTableFlags FastCall;
    public static InvokeTableFlags CallingConventionMask;
}
internal class Internal.Runtime.ObjHeader : ValueType {
    private IntPtr _objHeaderContents;
}
internal static class Internal.Runtime.ParameterizedTypeShapeConstants : object {
    public static int Pointer;
    public static int ByRef;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.Pointer`1 : ValueType {
    private T* _value;
    public T* Value { get; }
    public T* get_Value();
}
internal enum Internal.Runtime.ReflectionMapBlob : Enum {
    public int value__;
    public static ReflectionMapBlob TypeMap;
    public static ReflectionMapBlob ArrayMap;
    public static ReflectionMapBlob GenericInstanceMap;
    public static ReflectionMapBlob GenericParameterMap;
    public static ReflectionMapBlob BlockReflectionTypeMap;
    public static ReflectionMapBlob InvokeMap;
    public static ReflectionMapBlob VirtualInvokeMap;
    public static ReflectionMapBlob CommonFixupsTable;
    public static ReflectionMapBlob FieldAccessMap;
    public static ReflectionMapBlob CCtorContextMap;
    public static ReflectionMapBlob DiagGenericInstanceMap;
    public static ReflectionMapBlob DiagGenericParameterMap;
    public static ReflectionMapBlob EmbeddedMetadata;
    public static ReflectionMapBlob DefaultConstructorMap;
    public static ReflectionMapBlob UnboxingAndInstantiatingStubMap;
    public static ReflectionMapBlob StructMarshallingStubMap;
    public static ReflectionMapBlob DelegateMarshallingStubMap;
    public static ReflectionMapBlob GenericVirtualMethodTable;
    public static ReflectionMapBlob InterfaceGenericVirtualMethodTable;
    public static ReflectionMapBlob TypeTemplateMap;
    public static ReflectionMapBlob GenericMethodsTemplateMap;
    public static ReflectionMapBlob DynamicInvokeTemplateData;
    public static ReflectionMapBlob BlobIdResourceIndex;
    public static ReflectionMapBlob BlobIdResourceData;
    public static ReflectionMapBlob BlobIdStackTraceEmbeddedMetadata;
    public static ReflectionMapBlob BlobIdStackTraceMethodRvaToTokenMapping;
    public static ReflectionMapBlob NativeLayoutInfo;
    public static ReflectionMapBlob NativeReferences;
    public static ReflectionMapBlob GenericsHashtable;
    public static ReflectionMapBlob NativeStatics;
    public static ReflectionMapBlob StaticsInfoHashtable;
    public static ReflectionMapBlob GenericMethodsHashtable;
    public static ReflectionMapBlob ExactMethodInstantiationsHashtable;
}
[IsReadOnlyAttribute]
internal class Internal.Runtime.RelativePointer`1 : ValueType {
    private int _value;
    public T* Value { get; }
    public T* get_Value();
}
internal class Internal.Runtime.ReturnBlock : ValueType {
    public IntPtr returnValue;
    public IntPtr returnValue2;
}
internal static class Internal.Runtime.StringComponentSize : object {
    public static int Value;
}
internal class Internal.Runtime.TransitionBlock : ValueType {
    public ArgumentRegisters m_argumentRegisters;
    public ReturnBlock m_returnBlock;
    private IntPtr m_ebp;
    private IntPtr m_ReturnAddress;
    public static int InvalidOffset;
    public static int GetOffsetOfArgumentRegisters();
    public static int GetOffsetOfReturnValuesBlock();
    public static byte GetOffsetOfArgs();
    public static bool IsStackArgumentOffset(int offset);
    public static bool IsArgumentRegisterOffset(int offset);
    public static int GetNegSpaceSize();
    public static int GetThisOffset();
}
internal class Internal.Runtime.TypeLoader.Callbacks : TypeLoaderCallbacks {
    public virtual bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public virtual int GetThreadStaticsSizeForDynamicType(int index, Int32& numTlsCells);
    public virtual IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    public virtual bool GetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public virtual bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public virtual IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    public virtual IntPtr GetDelegateThunk(Delegate delegateObject, int thunkKind);
    public virtual bool TryGetGenericVirtualTargetForTypeAndSlot(RuntimeTypeHandle targetHandle, RuntimeTypeHandle& declaringType, RuntimeTypeHandle[] genericArguments, String& methodName, RuntimeSignature& methodSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer, Boolean& slotUpdated);
    public virtual bool GetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public virtual IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
    public virtual bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public virtual bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public virtual IntPtr UpdateFloatingDictionary(IntPtr context, IntPtr dictionaryPtr);
    public virtual void RegisterThunk(IntPtr thunkAddress);
}
internal class Internal.Runtime.TypeLoader.CallConversionInfo : object {
    private static int s_callConvertersCount;
    private static CallConversionInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) s_callConverters;
    private static Lock s_callConvertersCacheLock;
    private static LowLevelDictionary`2<CallConversionInfo, int> s_callConvertersCache;
    private CallConversionInfoRegistrationKind _registrationKind;
    private ThunkKind _thunkKind;
    private IntPtr _targetFunctionPointer;
    private IntPtr _instantiatingArg;
    private ArgIteratorData _argIteratorData;
    private Boolean[] _paramsByRefForced;
    private RuntimeSignature _methodSignature;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _signatureParsed;
    private RuntimeTypeHandle[] _typeArgs;
    private RuntimeTypeHandle[] _methodArgs;
    private Nullable`1<int> _hashCode;
    public IntPtr TargetFunctionPointer { get; }
    public bool StandardToStandardThunk { get; }
    public bool CallerHasExtraParameterWhichIsFunctionTarget { get; }
    public bool CalleeMayHaveParamType { get; }
    public bool IsUnboxingThunk { get; }
    public bool IsDelegateThunk { get; }
    public bool TargetDelegateFunctionIsExtraFunctionPointerOrDataField { get; }
    public bool IsOpenInstanceDelegateThunk { get; }
    public bool IsClosedStaticDelegate { get; }
    public bool IsMulticastDelegate { get; }
    public bool IsObjectArrayDelegateThunk { get; }
    public bool IsDelegateDynamicInvokeThunk { get; }
    public bool IsReflectionDynamicInvokerThunk { get; }
    public bool IsAnyDynamicInvokerThunk { get; }
    public bool IsStaticDelegateThunk { get; }
    public bool IsThisPointerInDelegateData { get; }
    public IntPtr InstantiatingStubArgument { get; }
    public ArgIteratorData ArgIteratorData { get; }
    public bool HasKnownTargetPointerAndInstantiatingArgument { get; }
    public bool CalleeHasParamType { get; }
    public bool CallerHasParamType { get; }
    private bool ForcedByRefParametersAreCaller { get; }
    public Boolean[] CallerForcedByRefData { get; }
    public Boolean[] CalleeForcedByRefData { get; }
    private static CallConversionInfo();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CallConversionInfo other);
    private bool ArraysAreEqual(T[] array1, T[] array2);
    public virtual int GetHashCode();
    private void EnsureCallConversionInfoLoaded();
    public static int RegisterCallConversionInfo(ThunkKind thunkKind, IntPtr targetPointer, RuntimeSignature methodSignature, IntPtr instantiatingArg, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs);
    public static int RegisterCallConversionInfo(ThunkKind thunkKind, IntPtr targetPointer, IntPtr instantiatingArg, bool hasThis, TypeHandle returnType, TypeHandle[] parameterTypes, Boolean[] paramsByRefForced);
    public static int RegisterCallConversionInfo(ThunkKind thunkKind, IntPtr targetPointer, IntPtr instantiatingArg, ArgIteratorData argIteratorData, Boolean[] paramsByRefForced);
    private static int AddConverter(CallConversionInfo newConversionInfo);
    public static CallConversionInfo GetConverter(int id);
    public IntPtr get_TargetFunctionPointer();
    public bool get_StandardToStandardThunk();
    public bool get_CallerHasExtraParameterWhichIsFunctionTarget();
    public bool get_CalleeMayHaveParamType();
    public bool get_IsUnboxingThunk();
    public bool get_IsDelegateThunk();
    public bool get_TargetDelegateFunctionIsExtraFunctionPointerOrDataField();
    public bool get_IsOpenInstanceDelegateThunk();
    public bool get_IsClosedStaticDelegate();
    public bool get_IsMulticastDelegate();
    public bool get_IsObjectArrayDelegateThunk();
    public bool get_IsDelegateDynamicInvokeThunk();
    public bool get_IsReflectionDynamicInvokerThunk();
    public bool get_IsAnyDynamicInvokerThunk();
    public bool get_IsStaticDelegateThunk();
    public bool get_IsThisPointerInDelegateData();
    public IntPtr get_InstantiatingStubArgument();
    public ArgIteratorData get_ArgIteratorData();
    public bool get_HasKnownTargetPointerAndInstantiatingArgument();
    public bool get_CalleeHasParamType();
    public bool get_CallerHasParamType();
    private bool get_ForcedByRefParametersAreCaller();
    public Boolean[] get_CallerForcedByRefData();
    public Boolean[] get_CalleeForcedByRefData();
}
internal enum Internal.Runtime.TypeLoader.CallConversionInfoRegistrationKind : Enum {
    public int value__;
    public static CallConversionInfoRegistrationKind UsesMethodSignatureAndGenericArgs;
    public static CallConversionInfoRegistrationKind UsesArgIteratorData;
}
internal class Internal.Runtime.TypeLoader.CallConversionParameters : ValueType {
    internal CallConversionInfo _conversionInfo;
    internal ArgIterator _callerArgs;
    internal ArgIterator _calleeArgs;
    internal Byte* _callerTransitionBlock;
    internal IntPtr _invokeReturnValue;
    internal bool _copyReturnValue;
    internal Object[] _dynamicInvokeParams;
    internal DynamicInvokeByRefArgObjectWrapper[] _dynamicInvokeByRefObjectArgs;
    private IntPtr _instantiatingStubArgument;
    private IntPtr _functionPointerToCall;
    private DelegateData _delegateData;
    [ThreadStaticAttribute]
internal static GCHandleContainer s_pinnedGCHandles;
    private static ArgIteratorData s_delegateDynamicInvokeImplArgIteratorData;
    private static ArgIteratorData s_reflectionDynamicInvokeImplArgIteratorData;
    internal int MulticastDelegateCallCount { get; }
    private object BoxedCallerFirstArgument { get; }
    internal IntPtr ClosedStaticDelegateThisPointer { get; }
    internal Void* ThisPointer { get; }
    internal Void* CallerReturnBuffer { get; }
    internal Void* VarArgSigCookie { get; }
    internal IntPtr InstantiatingStubArgument { get; }
    internal IntPtr FunctionPointerToCall { get; }
    internal CallConversionParameters(CallConversionInfo conversionInfo, IntPtr callerTransitionBlockParam);
    private static CallConversionParameters();
    private void ComputeCalleeFlagsAndFunctionPointerForReflectionInvokeThunk();
    internal void ResetPinnedObjects();
    private bool UpdateCalleeFunctionPointer(IntPtr newFunctionPointer);
    internal void PrepareNextMulticastDelegateCall(int currentIndex);
    internal int get_MulticastDelegateCallCount();
    private object get_BoxedCallerFirstArgument();
    internal IntPtr get_ClosedStaticDelegateThisPointer();
    internal Void* get_ThisPointer();
    internal Void* get_CallerReturnBuffer();
    internal Void* get_VarArgSigCookie();
    internal IntPtr get_InstantiatingStubArgument();
    internal IntPtr get_FunctionPointerToCall();
    internal IntPtr InvokeObjectArrayDelegate(Object[] arguments);
    internal IntPtr GetArgSetupStateDataPointer();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.CallConverterThunk : object {
    private static LowLevelList`1<IntPtr> s_allocatedThunks;
    private static Object modreq(System.Runtime.CompilerServices.IsVolatile) s_thunkPoolHeap;
    internal static IntPtr CommonInputThunkStub;
    internal static IntPtr ReturnFloatingPointReturn4Thunk;
    internal static IntPtr ReturnFloatingPointReturn8Thunk;
    internal static IntPtr ReturnVoidReturnThunk;
    internal static IntPtr ReturnIntegerPointReturnThunk;
    [ThreadStaticAttribute]
internal static ReturnBlock t_NonArgRegisterReturnSpace;
    internal static CallingConventionConverter_CommonCallingStub_PointerData s_commonStubData;
    private static bool s_callConverterThunk;
    private static int MulticastThunk;
    private static int ClosedStaticThunk;
    private static int OpenStaticThunk;
    private static int ClosedInstanceThunkOverGenericMethod;
    private static int DelegateInvokeThunk;
    private static int OpenInstanceThunk;
    private static int ReversePinvokeThunk;
    private static int ObjectArrayThunk;
    private static CallConverterThunk();
    private static void CallingConventionConverter_GetStubs(IntPtr& returnVoidStub, IntPtr& returnIntegerStub, IntPtr& commonStub, IntPtr& returnFloatingPointReturn4Thunk, IntPtr& returnFloatingPointReturn8Thunk);
    private static bool CallConverterThunk_LazyCctor();
    internal static bool GetByRefIndicatorAtIndex(int index, Boolean[] lookup);
    public static IntPtr MakeThunk(ThunkKind thunkKind, IntPtr targetPointer, IntPtr instantiatingArg, bool hasThis, RuntimeTypeHandle[] parameters, Boolean[] byRefParameters, Boolean[] paramsByRefForced);
    public static IntPtr MakeThunk(ThunkKind thunkKind, IntPtr targetPointer, RuntimeSignature methodSignature, IntPtr instantiatingArg, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs);
    internal static IntPtr MakeThunk(ThunkKind thunkKind, IntPtr targetPointer, IntPtr instantiatingArg, ArgIteratorData argIteratorData, Boolean[] paramsByRefForced);
    private static IntPtr FindExistingOrAllocateThunk(int callConversionInfo);
    public static IntPtr GetDelegateThunk(Delegate delegateObject, int thunkKind);
    public static bool TryGetNonUnboxingFunctionPointerFromUnboxingAndInstantiatingStub(IntPtr potentialStub, RuntimeTypeHandle exactType, IntPtr& nonUnboxingMethod);
    public static bool TryGetCallConversionTargetPointerAndInstantiatingArg(IntPtr potentialStub, IntPtr& methodTarget, IntPtr& instantiatingArg);
    internal static void gcSafeMemzeroPointer(Byte* pointer, int size);
    internal static void memzeroPointer(Byte* pointer, int size);
    internal static void memzeroPointerAligned(Byte* pointer, int size);
    private static bool isPointerAligned(Void* pointer);
    [DebuggerGuidedStepThroughAttribute]
private static IntPtr CallConversionThunk(IntPtr callerTransitionBlockParam, IntPtr callConversionId);
    [DebuggerGuidedStepThroughAttribute]
private static IntPtr MulticastDelegateInvoke(CallConversionParameters& conversionParams);
    [DebuggerGuidedStepThroughAttribute]
private static void InvokeTarget(Void* allocatedStackBuffer, CallConversionParameters& conversionParams);
    private static void ExtendingCopy_WriteBarrier(Void* pSrcVoid, Void* pDestVoid, CorElementType type, int typeSize);
    private static void ExtendingCopy_NoWriteBarrier(Void* pSrcVoid, Void* pDestVoid, CorElementType type, int typeSize);
    private static bool SignExtendType(CorElementType type);
    private static bool ZeroExtendType(CorElementType type);
    internal static void SignExtend(Void* pSrcVoid, Void* pDestVoid, int size);
    internal static void ZeroExtend(Void* pSrcVoid, Void* pDestVoid, int size);
    private static void SetupCallerPopArgument(Byte* callerTransitionBlock, ArgIterator callerArgs);
    internal static void SetupCallerActualReturnData(Byte* callerTransitionBlock);
}
internal static class Internal.Runtime.TypeLoader.CallingConventionConverterLogger : object {
    [ConditionalAttribute("CCCONVERTER_TRACE")]
public static void WriteLine(string message);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.CanonicallyEquivalentEntryLocator : ValueType {
    private RuntimeTypeHandle _typeToFind;
    private RuntimeTypeHandle _genericDefinition;
    private RuntimeTypeHandle[] _genericArgs;
    private DefType _defType;
    private CanonicalFormKind _canonKind;
    public int LookupHashCode { get; }
    public CanonicallyEquivalentEntryLocator(RuntimeTypeHandle typeToFind, CanonicalFormKind kind);
    internal CanonicallyEquivalentEntryLocator(DefType typeToFind, CanonicalFormKind kind);
    public int get_LookupHashCode();
    public bool IsCanonicallyEquivalent(RuntimeTypeHandle other);
    public bool ConversionToCanonFormIsAChange();
}
internal class Internal.Runtime.TypeLoader.ConstrainedCallSupport : object {
    private static IntPtr s_constrainedCallSupport_DerefThisAndCall_CommonCallingStub;
    private static IntPtr s_constrainedCallSupport_DirectConstrainedCall_CommonCallingStub;
    private static object s_DerefThisAndCall_ThunkPoolHeap;
    private static object s_DirectConstrainedCall_ThunkPoolHeap;
    private static object s_DirectConstrainedCall_ThunkPoolHeapLock;
    private static LowLevelDictionary`2<IntPtr, IntPtr> s_deferenceAndCallThunks;
    private static ConstrainedCallSupport();
    private static void ConstrainedCallSupport_GetStubs(IntPtr& constrainedCallSupport_DerefThisAndCall_CommonCallingStub, IntPtr& constrainedCallSupport_DirectConstrainedCall_CommonCallingStub);
    private static IntPtr GetThunkThatDereferencesThisPointerAndTailCallsTarget(IntPtr target);
}
internal class Internal.Runtime.TypeLoader.EETypeCreator : object {
    private static IntPtr s_emptyGCDesc;
    private static void CreateEETypeWorker(EEType* pTemplateEEType, UInt32 hashCodeOfNewType, int arity, bool requireVtableSlotMapping, TypeBuilderState state);
    private static IntPtr CreateStaticGCDesc(LowLevelList`1<bool> gcBitfield, Boolean& allocated, Int32& cbGCDesc);
    private static void CreateInstanceGCDesc(TypeBuilderState state, EEType* pTemplateEEType, EEType* pEEType, int baseSize, int cbGCDesc, bool isValueType, bool isArray, bool isSzArray, int arrayRank);
    private static int GetInstanceGCDescSize(TypeBuilderState state, EEType* pTemplateEEType, bool isValueType, bool isArray);
    private static int CreateArrayGCDesc(LowLevelList`1<bool> bitfield, int rank, bool isSzArray, Void* gcdesc);
    private static int CreateGCDesc(LowLevelList`1<bool> bitfield, int size, bool isValueType, bool isStatic, Void* gcdesc);
    [ConditionalAttribute("GENERICS_FORCE_USG")]
private static void TestGCDescsForEquality(IntPtr dynamicGCDesc, IntPtr templateGCDesc, int cbGCDesc, bool isInstanceGCDesc);
    public static RuntimeTypeHandle CreatePointerEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle pointeeTypeHandle, TypeDesc pointerType);
    public static RuntimeTypeHandle CreateByRefEEType(UInt32 hashCodeOfNewType, RuntimeTypeHandle pointeeTypeHandle, TypeDesc byRefType);
    public static RuntimeTypeHandle CreateEEType(TypeDesc type, TypeBuilderState state);
    public static int GetDictionaryOffsetInEEtype(EEType* pEEType);
    public static IntPtr GetDictionaryAtOffset(EEType* pEEType, int offset);
    public static IntPtr GetDictionary(EEType* pEEType);
    public static int GetDictionarySlotInVTable(TypeDesc type);
    private static int GetMostDerivedDictionarySlot(TypeDesc& nextTypeToExamineForDictionarySlot, TypeDesc& typeWithDictionary);
    public static EEType* GetBaseEETypeForDictionaryPtr(EEType* pEEType, IntPtr dictionaryPtr);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ExternalReferencesTable : ValueType {
    private IntPtr _elements;
    private UInt32 _elementsCount;
    private TypeManagerHandle _moduleHandle;
    private UInt64[] debuggerPreparedExternalReferences;
    public bool IsInitialized();
    private bool Initialize(NativeFormatModuleInfo module, ReflectionMapBlob blobId);
    public void InitializeDebuggerReference(UInt64[] debuggerPreparedExternalReferences);
    public bool InitializeNativeReferences(NativeFormatModuleInfo module);
    public bool InitializeNativeStatics(NativeFormatModuleInfo module);
    public bool InitializeCommonFixupsTable(NativeFormatModuleInfo module);
    public UInt32 GetRvaFromIndex(UInt32 index);
    public IntPtr GetIntPtrFromIndex(UInt32 index);
    public IntPtr GetFunctionPointerFromIndex(UInt32 index);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromIndex(UInt32 index);
    public IntPtr GetGenericDictionaryFromIndex(UInt32 index);
    public UInt32 GetExternalNativeLayoutOffset(UInt32 index);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.FieldAccessMetadata : ValueType {
    public TypeManagerHandle MappingTableModule;
    public IntPtr Cookie;
    public FieldTableFlags Flags;
    public int Offset;
}
[FlagsAttribute]
internal enum Internal.Runtime.TypeLoader.FieldLoadState : Enum {
    public int value__;
    public static FieldLoadState None;
    public static FieldLoadState Instance;
    public static FieldLoadState Statics;
}
internal abstract class Internal.Runtime.TypeLoader.GenericDictionary : object {
    protected GenericDictionaryCell[] _cells;
    protected IntPtr _addressOfFirstCellSlot;
    public GenericDictionary(GenericDictionaryCell[] cells);
    public abstract virtual IntPtr Allocate();
    public void Finish(TypeBuilder typeBuilder);
}
[__BlockReflectionAttribute]
public abstract class Internal.Runtime.TypeLoader.GenericDictionaryCell : object {
    internal abstract virtual void Prepare(TypeBuilder builder);
    internal abstract virtual IntPtr Create(TypeBuilder builder);
    internal virtual void WriteCellIntoDictionary(TypeBuilder typeBuilder, IntPtr* pDictionary, int slotIndex);
    internal virtual IntPtr CreateLazyLookupCell(TypeBuilder builder, IntPtr& auxResult);
    private static RuntimeTypeHandle GetRuntimeTypeHandleWithNullableTransform(TypeBuilder builder, TypeDesc type);
    public static GenericDictionaryCell CreateTypeHandleCell(TypeDesc type);
    public static GenericDictionaryCell CreateIntPtrCell(IntPtr ptrValue);
    internal static GenericDictionaryCell[] BuildDictionary(TypeBuilder typeBuilder, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser parser);
    internal static GenericDictionaryCell[] BuildFloatingDictionary(TypeBuilder typeBuilder, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser parser, Int32& floatingVersionCellIndex, Int32& floatingVersionInLayout);
    private static TypeDesc TransformNullable(TypeDesc type);
    private static int ComputeConstrainedMethodSlot(MethodDesc constrainedMethod);
    internal static GenericDictionaryCell CreateMethodCell(MethodDesc method, bool exactCallableAddressNeeded);
    internal static GenericDictionaryCell ParseAndCreateCell(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser& parser);
}
internal class Internal.Runtime.TypeLoader.GenericMethodDictionary : GenericDictionary {
    public GenericMethodDictionary(GenericDictionaryCell[] cells);
    public virtual IntPtr Allocate();
}
internal class Internal.Runtime.TypeLoader.GenericTypeDictionary : GenericDictionary {
    public GenericTypeDictionary(GenericDictionaryCell[] cells);
    public virtual IntPtr Allocate();
}
[McgIntrinsicsAttribute]
internal static class Internal.Runtime.TypeLoader.Intrinsics : object {
    internal static IntPtr AddrOf(T ftn);
    public static void Call(IntPtr pfn, object obj);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.LowLevelListExtensions : object {
    [ExtensionAttribute]
public static void Expand(LowLevelList`1<T> list, int count);
    [ExtensionAttribute]
public static bool HasSetBits(LowLevelList`1<bool> list);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.LowLevelStringConverter : object {
    private static string HexDigits;
    private static string LowLevelToString(ulong arg, int shift);
    [ExtensionAttribute]
public static string LowLevelToString(LayoutInt arg);
    [ExtensionAttribute]
public static string LowLevelToString(byte arg);
    [ExtensionAttribute]
public static string LowLevelToString(ushort arg);
    [ExtensionAttribute]
public static string LowLevelToString(int arg);
    [ExtensionAttribute]
public static string LowLevelToString(UInt32 arg);
    [ExtensionAttribute]
public static string LowLevelToString(ulong arg);
    [ExtensionAttribute]
public static string LowLevelToString(IntPtr arg);
    [ExtensionAttribute]
public static string LowLevelToString(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static string LowLevelToStringRawEETypeAddress(RuntimeTypeHandle rtth);
}
internal class Internal.Runtime.TypeLoader.MemoryHelpers : object {
    public static int AlignUp(int val, int alignment);
    public static void Memset(IntPtr destination, int length, byte value);
    public static IntPtr AllocateMemory(int cbBytes);
    public static void FreeMemory(IntPtr memoryPtrToFree);
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.TypeLoader.MetadataFixupKind : Enum {
    public int value__;
    public static MetadataFixupKind TypeHandle;
    public static MetadataFixupKind GcStaticData;
    public static MetadataFixupKind NonGcStaticData;
    public static MetadataFixupKind UnwrapNullableType;
    public static MetadataFixupKind TypeSize;
    public static MetadataFixupKind AllocateObject;
    public static MetadataFixupKind DefaultConstructor;
    public static MetadataFixupKind TlsIndex;
    public static MetadataFixupKind TlsOffset;
    public static MetadataFixupKind IsInst;
    public static MetadataFixupKind CastClass;
    public static MetadataFixupKind AllocateArray;
    public static MetadataFixupKind CheckArrayElementType;
    public static MetadataFixupKind ArrayOfTypeHandle;
    public static MetadataFixupKind DirectGcStaticData;
    public static MetadataFixupKind DirectNonGcStaticData;
    public static MetadataFixupKind EndTypeTokenFixups;
    public static MetadataFixupKind VirtualCallDispatch;
    public static MetadataFixupKind MethodDictionary;
    public static MetadataFixupKind MethodLdToken;
    public static MetadataFixupKind Method;
    public static MetadataFixupKind UnboxingStubMethod;
    public static MetadataFixupKind CallableMethod;
    public static MetadataFixupKind EndMethodTokenFixups;
    public static MetadataFixupKind NonGenericDirectConstrainedMethod;
    public static MetadataFixupKind NonGenericConstrainedMethod;
    public static MetadataFixupKind GenericConstrainedMethod;
    public static MetadataFixupKind EndConstraintMethodFixups;
    public static MetadataFixupKind FieldLdToken;
    public static MetadataFixupKind FieldOffset;
    public static MetadataFixupKind EndFieldTokenFixups;
    public static MetadataFixupKind CallingConventionConverter_NoInstantiatingParam;
    public static MetadataFixupKind CallingConventionConverter_HasInstantiatingParam;
    public static MetadataFixupKind CallingConventionConverter_MaybeInstantiatingParam;
    public static MetadataFixupKind EndSignatureTokenFixups;
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.MetadataNameExtentions : object {
    [ExtensionAttribute]
public static string GetFullName(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ByReferenceSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(PointerSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ArraySignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(SZArraySignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(TypeSpecificationHandle typeSpecHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(TypeInstantiationSignatureHandle typeInstSigHandle, MetadataReader reader);
    [ExtensionAttribute]
public static void GetFullName(TypeDefinitionHandle typeDefHandle, MetadataReader reader, String& name, String& enclosing, String& nspace);
    [ExtensionAttribute]
public static string GetFullName(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetContainingModuleName(TypeDefinitionHandle typeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(NamespaceDefinitionHandle namespaceHandle, MetadataReader reader);
    [ExtensionAttribute]
public static void GetFullName(TypeReferenceHandle typeRefHandle, MetadataReader reader, String& name, String& enclosing, String& nspace);
    [ExtensionAttribute]
public static string GetFullName(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetContainingModuleName(TypeReferenceHandle typeRefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(NamespaceReferenceHandle namespaceHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ScopeDefinitionHandle scopeDefHandle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetFullName(ScopeReferenceHandle scopeRefHandle, MetadataReader reader);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.MetadataReaderEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal MetadataReaderEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public MetadataReaderEnumerator GetEnumerator();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.MetadataReaderEnumerator : ValueType {
    private NativeFormatModuleInfoEnumerator _moduleInfoEnumerator;
    public MetadataReader Current { get; }
    internal MetadataReaderEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public MetadataReader get_Current();
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.TypeLoader.MetadataReaderHelpers : object {
    public static bool CompareTypeReferenceAcrossModules(TypeReferenceHandle tr1, MetadataReader mr1, TypeReferenceHandle tr2, MetadataReader mr2);
    public static bool CompareNamespaceReferenceAcrossModules(NamespaceReferenceHandle nr1, MetadataReader mr1, NamespaceReferenceHandle nr2, MetadataReader mr2);
    public static bool CompareScopeReferenceAcrossModules(ScopeReferenceHandle sr1, MetadataReader mr1, ScopeReferenceHandle sr2, MetadataReader mr2);
    public static bool CompareTypeReferenceToDefinition(TypeReferenceHandle tr1, MetadataReader mr1, TypeDefinitionHandle td2, MetadataReader mr2);
    public static bool CompareNamespaceReferenceToDefinition(NamespaceReferenceHandle nr1, MetadataReader mr1, NamespaceDefinitionHandle nd2, MetadataReader mr2);
    public static bool CompareScopeReferenceToDefinition(ScopeReferenceHandle sr1, MetadataReader mr1, ScopeDefinitionHandle sd2, MetadataReader mr2);
    public static bool ComparePublicKeyOrTokens(ByteCollection keyOrToken1, bool isKey1, ByteCollection keyOrToken2, bool isKey2);
    private static Byte[] ConvertByteCollectionOfPublicKeyToByteArrayOfPublicKeyToken(ByteCollection publicKeyCollection);
    private static Byte[] ConvertByteCollectionKeyOrTokenToPublicKeyTokenByteArray(ByteCollection publicKeyOrToken, bool isKey);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.MethodDescExtensions : object {
    [ExtensionAttribute]
public static bool CanShareNormalGenericCode(InstantiatedMethod method);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.MethodInvokeMetadata : ValueType {
    public NativeFormatModuleInfo MappingTableModule;
    public IntPtr MethodEntryPoint;
    public IntPtr RawMethodEntryPoint;
    public IntPtr DictionaryComponent;
    public UInt32 DynamicInvokeCookie;
    public InvokeTableFlags InvokeTableFlags;
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.MethodSignatureComparer : ValueType {
    private MetadataReader _metadataReader;
    private MethodHandle _methodHandle;
    private Method _method;
    private MethodSignature _methodSignature;
    private bool _isStatic;
    private bool _isGeneric;
    public MethodSignatureComparer(QMethodDefinition methodHandle);
    public MethodSignatureComparer(MetadataReader metadataReader, MethodHandle methodHandle);
    public bool IsMatchingNativeLayoutMethodNameAndSignature(string name, RuntimeSignature signature);
    public bool IsMatchingNativeLayoutMethodSignature(RuntimeSignature signature);
    internal static NativeParser GetNativeParserForSignature(RuntimeSignature signature);
    private bool CompareTypeSigWithType(NativeParser& parser, TypeManagerHandle moduleHandle, Handle typeHandle);
    private bool CompareCallingConventions(MethodCallingConvention callingConvention);
    private static bool CanGetTypeHandle(Type type);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ModuleHandleEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal ModuleHandleEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public ModuleHandleEnumerator GetEnumerator();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ModuleHandleEnumerator : ValueType {
    private ModuleInfoEnumerator _moduleInfoEnumerator;
    public TypeManagerHandle Current { get; }
    internal ModuleHandleEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public TypeManagerHandle get_Current();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ModuleInfo : object {
    [CompilerGeneratedAttribute]
private TypeManagerHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicModule* <DynamicModulePtr>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleType <ModuleType>k__BackingField;
    public TypeManagerHandle Handle { get; private set; }
    internal DynamicModule* DynamicModulePtr { get; private set; }
    public IntPtr DynamicModulePtrAsIntPtr { get; }
    internal ModuleType ModuleType { get; private set; }
    internal ModuleInfo(TypeManagerHandle moduleHandle, ModuleType moduleType);
    [CompilerGeneratedAttribute]
public TypeManagerHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(TypeManagerHandle value);
    [CompilerGeneratedAttribute]
internal DynamicModule* get_DynamicModulePtr();
    [CompilerGeneratedAttribute]
private void set_DynamicModulePtr(DynamicModule* value);
    public IntPtr get_DynamicModulePtrAsIntPtr();
    [CompilerGeneratedAttribute]
internal ModuleType get_ModuleType();
    [CompilerGeneratedAttribute]
private void set_ModuleType(ModuleType value);
    internal static IntPtr ResolveTypeSlotDispatch(IntPtr targetTypeAsIntPtr, IntPtr interfaceTypeAsIntPtr, ushort slot);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ModuleInfoEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal ModuleInfoEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public ModuleInfoEnumerator GetEnumerator();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ModuleInfoEnumerator : ValueType {
    private ModuleInfo[] _modules;
    private int _preferredIndex;
    private int _iterationIndex;
    private ModuleInfo _currentModule;
    public ModuleInfo Current { get; }
    internal ModuleInfoEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public ModuleInfo get_Current();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.ModuleList : object {
    private ModuleMap modreq(System.Runtime.CompilerServices.IsVolatile) _loadedModuleMap;
    private Action`1<ModuleInfo> _moduleRegistrationCallbacks;
    private Lock _moduleRegistrationLock;
    private ModuleInfo _systemModule;
    public static ModuleList Instance { get; }
    public ModuleInfo SystemModule { get; }
    internal ModuleMap GetLoadedModuleMapInternal();
    public static ModuleList get_Instance();
    public static void AddModuleRegistrationCallback(Action`1<ModuleInfo> newModuleRegistrationCallback);
    public static void RegisterEagerModules();
    public void RegisterNewModules(ModuleType moduleType);
    public void RegisterModule(ModuleInfo newModuleInfo);
    public NativeFormatModuleInfo GetModuleInfoByHandle(TypeManagerHandle moduleHandle);
    public bool TryGetModuleInfoByHandle(TypeManagerHandle moduleHandle, ModuleInfo& moduleInfo);
    public MetadataReader GetMetadataReaderForModule(TypeManagerHandle moduleHandle);
    public ModuleInfo GetModuleInfoForDynamicModule(IntPtr dynamicModuleHandle);
    public NativeFormatModuleInfo GetModuleInfoForMetadataReader(MetadataReader reader);
    public TypeManagerHandle GetModuleForMetadataReader(MetadataReader reader);
    public ModuleInfo get_SystemModule();
    public static NativeFormatModuleInfoEnumerable EnumerateModules();
    public static NativeFormatModuleInfoEnumerable EnumerateModules(TypeManagerHandle preferredModule);
    public static MetadataReaderEnumerable EnumerateMetadataReaders();
    public static MetadataReaderEnumerable EnumerateMetadataReaders(TypeManagerHandle preferredModule);
    public static ModuleHandleEnumerable Enumerate();
    public static ModuleHandleEnumerable Enumerate(TypeManagerHandle preferredModule);
}
internal class Internal.Runtime.TypeLoader.ModuleMap : object {
    public ModuleInfo[] Modules;
    public LowLevelDictionary`2<TypeManagerHandle, int> HandleToModuleIndex;
    internal ModuleMap(ModuleInfo[] modules);
}
[__BlockReflectionAttribute]
public enum Internal.Runtime.TypeLoader.ModuleType : Enum {
    public int value__;
    public static ModuleType Eager;
    public static ModuleType ReadyToRun;
    public static ModuleType Ecma;
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfo : ModuleInfo {
    [CompilerGeneratedAttribute]
private MetadataReader <MetadataReader>k__BackingField;
    public MetadataReader MetadataReader { get; private set; }
    internal NativeFormatModuleInfo(TypeManagerHandle moduleHandle, ModuleType moduleType, IntPtr pBlob, int cbBlob);
    [CompilerGeneratedAttribute]
public MetadataReader get_MetadataReader();
    [CompilerGeneratedAttribute]
private void set_MetadataReader(MetadataReader value);
    internal bool TryFindBlob(ReflectionMapBlob blobId, Byte*& pBlob, UInt32& cbBlob);
    public bool TryFindBlob(int blobId, Byte*& pBlob, UInt32& cbBlob);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfoEnumerable : ValueType {
    private ModuleMap _moduleMap;
    private TypeManagerHandle _preferredModuleHandle;
    internal NativeFormatModuleInfoEnumerable(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public NativeFormatModuleInfoEnumerator GetEnumerator();
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.NativeFormatModuleInfoEnumerator : ValueType {
    private ModuleInfo[] _modules;
    private int _preferredIndex;
    private int _iterationIndex;
    private NativeFormatModuleInfo _currentModule;
    public NativeFormatModuleInfo Current { get; }
    internal NativeFormatModuleInfoEnumerator(ModuleMap moduleMap, TypeManagerHandle preferredModuleHandle);
    public bool MoveNext();
    public NativeFormatModuleInfo get_Current();
}
internal class Internal.Runtime.TypeLoader.NativeLayoutFieldAlgorithm : FieldLayoutAlgorithm {
    private NoMetadataFieldLayoutAlgorithm _noMetadataFieldLayoutAlgorithm;
    private static int InstanceAlignmentEntry;
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    private ComputedStaticFieldLayout ParseStaticRegionSizesFromNativeLayout(TypeDesc type);
    internal static void EnsureFieldLayoutLoadedForGenericType(DefType type);
    private static void EnsureFieldLayoutLoadedForUniversalType(DefType type, NativeLayoutInfoLoadContext loadContext, NativeParser fieldLayoutParser);
    private static void EnsureFieldLayoutLoadedForNonUniversalType(DefType type);
    private static NativeLayoutFieldDesc[] ParseFieldLayout(DefType owningType, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser fieldLayoutParser);
    internal void ComputeTypeSizeBeforeFields(TypeDesc type, LayoutInt& initialSize, LayoutInt& alignRequired);
    internal bool ShouldProcessField(FieldStorage fieldStorage, FieldLoadState loadRequested);
    internal LayoutInt[] ComputeTypeSizeAndAlignment(TypeDesc type, FieldLoadState loadRequested, LowLevelList`1& fieldOffsets);
    internal void GetFieldSizeAlignment(TypeDesc fieldType, LayoutInt& size, LayoutInt& alignment);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutFieldDesc : FieldDesc {
    private DefType _owningType;
    private TypeDesc _fieldType;
    private FieldStorage _fieldStorage;
    public TypeSystemContext Context { get; }
    public TypeDesc FieldType { get; }
    public bool HasRva { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsStatic { get; }
    public bool IsThreadStatic { get; }
    internal FieldStorage FieldStorage { get; }
    public DefType OwningType { get; }
    public NativeLayoutFieldDesc(DefType owningType, TypeDesc fieldType, FieldStorage fieldStorage);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_FieldType();
    public virtual bool get_HasRva();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsLiteral();
    public virtual bool get_IsStatic();
    public virtual bool get_IsThreadStatic();
    internal FieldStorage get_FieldStorage();
    public virtual DefType get_OwningType();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInfo : ValueType {
    public UInt32 Offset;
    public NativeFormatModuleInfo Module;
    public NativeReader Reader;
    public NativeLayoutInfoLoadContext LoadContext;
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInfoLoadContext : object {
    public TypeSystemContext _typeSystemContext;
    public NativeFormatModuleInfo _module;
    private ExternalReferencesTable _staticInfoLookup;
    private ExternalReferencesTable _externalReferencesLookup;
    public Instantiation _typeArgumentHandles;
    public Instantiation _methodArgumentHandles;
    public UInt64[] _debuggerPreparedExternalReferences;
    private TypeDesc GetInstantiationType(NativeParser& parser, UInt32 arity);
    private TypeDesc GetModifierType(NativeParser& parser, TypeModifierKind modifier);
    private void InitializeExternalReferencesLookup();
    private IntPtr GetExternalReferencePointer(UInt32 index);
    internal TypeDesc GetExternalType(UInt32 index);
    internal IntPtr GetGCStaticInfo(UInt32 index);
    private TypeDesc GetLookbackType(NativeParser& parser, UInt32 lookback);
    internal TypeDesc GetType(NativeParser& parser);
    internal MethodDesc GetMethod(NativeParser& parser, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    internal MethodDesc GetMethod(NativeParser& parser);
    internal TypeDesc[] GetTypeSequence(NativeParser& parser);
}
internal class Internal.Runtime.TypeLoader.NativeLayoutInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
    private static bool InterfaceInSet(DefType[] interfaces, int numInterfaces, DefType interfaceType);
}
internal class Internal.Runtime.TypeLoader.NoMetadataFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    private MetadataFieldLayoutAlgorithm _metadataFieldLayoutAlgorithm;
    private static NativeLayoutFieldAlgorithm s_nativeLayoutFieldAlgorithm;
    private static NoMetadataFieldLayoutAlgorithm();
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
}
internal class Internal.Runtime.TypeLoader.NoMetadataRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
internal class Internal.Runtime.TypeLoader.OptionalFieldsRuntimeBuilder : object {
    private NativePrimitiveEncoder _encoder;
    private OptionalField[] _rgFields;
    internal OptionalFieldsRuntimeBuilder(Byte* pInitializeFromOptionalFields);
    internal UInt32 GetFieldValue(EETypeOptionalFieldTag eTag, UInt32 defaultValueIfNotFound);
    internal void SetFieldValue(EETypeOptionalFieldTag eTag, UInt32 value);
    internal void ClearField(EETypeOptionalFieldTag eTag);
    internal int Encode();
    internal void WriteToEEType(EEType* pEEType, int sizeOfOptionalFieldsDataInEEType);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.PermanentAllocatedMemoryBlobs : object {
    private static PermanentlyAllocatedMemoryRegions_Uint_In_IntPtr s_uintCellValues;
    private static PermanentlyAllocatedMemoryRegions_IntPtr_In_IntPtr s_pointerIndirectionCellValues;
    private static PermanentAllocatedMemoryBlobs();
    public static IntPtr GetPointerToUInt(UInt32 value);
    public static IntPtr GetPointerToIntPtr(IntPtr value);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.RuntimeHandleExtensions : object {
    [ExtensionAttribute]
public static bool IsNull(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static bool IsDynamic(RuntimeFieldHandle rtfh);
    [ExtensionAttribute]
public static bool IsDynamic(RuntimeMethodHandle rtfh);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.TypeLoader.RuntimeSignatureExtensions : object {
    [ExtensionAttribute]
public static IntPtr NativeLayoutSignature(RuntimeSignature signature);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.TypeLoader.RuntimeSignatureHelper : object {
    [ExtensionAttribute]
public static ModuleInfo GetModuleInfo(RuntimeSignature methodSignature);
    public static bool TryCreate(MethodDesc method, RuntimeSignature& methodSignature);
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.RuntimeTypeHandleEETypeExtensions : object {
    [ExtensionAttribute]
public static EEType* ToEETypePtr(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static IntPtr ToIntPtr(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static bool IsDynamicType(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static int GetNumVtableSlots(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static IntPtr GetDictionary(RuntimeTypeHandle rtth);
    [ExtensionAttribute]
public static void SetDictionary(RuntimeTypeHandle rtth, int dictionarySlot, IntPtr dictionary);
    [ExtensionAttribute]
public static void SetInterface(RuntimeTypeHandle rtth, int interfaceIndex, RuntimeTypeHandle interfaceType);
    [ExtensionAttribute]
public static void SetGenericDefinition(RuntimeTypeHandle rtth, RuntimeTypeHandle genericDefinitionHandle);
    [ExtensionAttribute]
public static void SetGenericArgument(RuntimeTypeHandle rtth, int argumentIndex, RuntimeTypeHandle argumentType);
    [ExtensionAttribute]
public static void SetNullableType(RuntimeTypeHandle rtth, RuntimeTypeHandle T_typeHandle);
    [ExtensionAttribute]
public static void SetRelatedParameterType(RuntimeTypeHandle rtth, RuntimeTypeHandle relatedTypeHandle);
    [ExtensionAttribute]
public static void SetParameterizedTypeShape(RuntimeTypeHandle rtth, UInt32 value);
    [ExtensionAttribute]
public static void SetBaseType(RuntimeTypeHandle rtth, RuntimeTypeHandle baseTypeHandle);
    [ExtensionAttribute]
public static void SetComponentSize(RuntimeTypeHandle rtth, ushort componentSize);
}
internal class Internal.Runtime.TypeLoader.SerializedDebugData : object {
    private static IntPtr DBGVISIBLE_serializedDataHeader;
    private static int SerializationFormatVersion;
    private static int HeaderBufferListSize;
    private static int HeaderBufferListOffset;
    private static int PhysicalBufferSize;
    private static int PhysicalBufferDataOffset;
    internal static SerializedDebugData Instance;
    private IntPtr _activePhysicalBuffer;
    private int _activePhysicalBufferIdx;
    private int _activePhysicalBufferOffset;
    private int _activePhysicalBufferAvailableSize;
    private int _serializedDataHeaderSize;
    private static bool s_tailCallThunkSizeRegistered;
    private static SerializedDebugData();
    private void InitializeHeader(int physicalBufferListSize);
    private int GetAllocatedPhysicalBufferCount();
    private void AddAllocatedBufferToHeader(IntPtr buffer, int insertIdx);
    private int AllocatePhysicalBuffer(IntPtr& buffer);
    private int GetPhysicalBuffer(int requestedSize, IntPtr& bufferPtr);
    private void UpdatePhysicalBufferUsedSize();
    private void ThreadSafeWriteBytes(Byte[] src);
    public void SerializeDataBlobTypeAndFlags(NativePrimitiveEncoder& encoder, SerializedDataBlobKind blobType, byte flags);
    public static void RegisterDebugDataForType(TypeBuilder typeBuilder, DefType defType, TypeBuilderState state);
    public static void RegisterDebugDataForNativeFormatType(TypeBuilder typeBuilder, DefType defType, TypeBuilderState state);
    public static void RegisterDebugDataForMethod(TypeBuilder typeBuilder, InstantiatedMethod method);
    public static void RegisterTailCallThunk(IntPtr thunk);
}
internal static class Internal.Runtime.TypeLoader.SigParsing : object {
    public static RuntimeTypeHandle GetTypeFromNativeLayoutSignature(NativeParser& parser, TypeManagerHandle moduleHandle, UInt32 offset);
}
internal class Internal.Runtime.TypeLoader.TemplateLocator : ValueType {
    private static UInt32 BadTokenFixupValue;
    public TypeDesc TryGetTypeTemplate(TypeDesc concreteType, NativeLayoutInfo& nativeLayoutInfo);
    public TypeDesc TryGetUniversalTypeTemplate(TypeDesc concreteType, NativeLayoutInfo& nativeLayoutInfo);
    public bool TryGetMetadataNativeLayout(TypeDesc concreteType, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    public bool TryGetMetadataNativeLayout(MethodDesc concreteMethod, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private TypeDesc TryGetTypeTemplate_Internal(TypeDesc concreteType, CanonicalFormKind kind, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    public InstantiatedMethod TryGetGenericMethodTemplate(InstantiatedMethod concreteMethod, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private InstantiatedMethod TryGetGenericMethodTemplate_Internal(InstantiatedMethod concreteMethod, CanonicalFormKind kind, NativeFormatModuleInfo& nativeLayoutInfoModule, UInt32& nativeLayoutInfoToken);
    private NativeHashtable LoadHashtable(NativeFormatModuleInfo module, ReflectionMapBlob hashtableBlobId, ExternalReferencesTable& externalFixupsTable);
}
internal class Internal.Runtime.TypeLoader.ThreadStaticFieldOffsets : ValueType {
    public UInt32 StartingOffsetInTlsBlock;
    public UInt32 FieldOffset;
}
internal class Internal.Runtime.TypeLoader.TypeBuilder : object {
    private static int MinimumValueTypeSize;
    public static int ClassConstructorOffset;
    private LowLevelList`1<TypeDesc> _typesThatNeedTypeHandles;
    private LowLevelList`1<InstantiatedMethod> _methodsThatNeedDictionaries;
    private LowLevelList`1<TypeDesc> _typesThatNeedPreparation;
    private object _epoch;
    private static TypeBuilder();
    private bool CheckAllHandlesValidForMethod(MethodDesc method);
    internal bool RetrieveExactFunctionPointerIfPossible(MethodDesc method, IntPtr& result);
    internal bool RetrieveMethodDictionaryIfPossible(InstantiatedMethod method);
    public void RegisterForPreparation(TypeDesc type);
    public void PrepareMethod(MethodDesc method);
    private void InsertIntoNeedsTypeHandleList(TypeBuilderState state, TypeDesc type);
    internal void PrepareType(TypeDesc type);
    private void PrepareRuntimeInterfaces(TypeDesc type);
    private void PrepareBaseTypeAndDictionaries(TypeDesc type);
    private void ProcessTypesNeedingPreparation();
    private GenericDictionaryCell[] GetGenericMethodDictionaryCellsForMetadataBasedLoad(InstantiatedMethod method, InstantiatedMethod nonTemplateMethod);
    internal void ParseNativeLayoutInfo(InstantiatedMethod method);
    internal void ParseNativeLayoutInfo(TypeBuilderState state, TypeDesc type);
    private void ParseVTableMethodSignatures(TypeBuilderState state, NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser methodSignaturesParser);
    private void ComputeVTableLayout(TypeDesc currentType, TypeDesc currentTemplateType, TypeBuilderState targetTypeState);
    private void AllocateRuntimeType(TypeDesc type);
    private void AllocateRuntimeMethodDictionary(InstantiatedMethod method);
    private RuntimeTypeHandle[] GetGenericContextOfBaseType(DefType type, int vtableMethodSlot);
    private void FinishVTableCallingConverterThunks(TypeDesc type, TypeBuilderState state);
    public RuntimeTypeHandle GetRuntimeTypeHandle(TypeDesc type);
    public RuntimeTypeHandle[] GetRuntimeTypeHandles(Instantiation types);
    public static DefType GetBaseTypeUsingRuntimeTypeHandle(TypeDesc type);
    public static DefType GetBaseTypeThatIsCorrectForMDArrays(TypeDesc type);
    private void FinishInterfaces(TypeDesc type, TypeBuilderState state);
    private void FinishTypeDictionary(TypeDesc type, TypeBuilderState state);
    private void FinishMethodDictionary(InstantiatedMethod method);
    private void FinishClassConstructor(TypeDesc type, TypeBuilderState state);
    private void CopyDictionaryFromTypeToAppropriateSlotInDerivedType(TypeDesc baseType, TypeBuilderState derivedTypeState);
    private void FinishBaseTypeAndDictionaries(TypeDesc type, TypeBuilderState state);
    private void FinishRuntimeType(TypeDesc type);
    [IteratorStateMachineAttribute("Internal.Runtime.TypeLoader.TypeBuilder/<TypesToRegister>d__39")]
private IEnumerable`1<TypeEntryToRegister> TypesToRegister();
    [IteratorStateMachineAttribute("Internal.Runtime.TypeLoader.TypeBuilder/<MethodsToRegister>d__40")]
private IEnumerable`1<GenericMethodEntry> MethodsToRegister();
    private void RegisterGenericTypesAndMethods();
    private void RegisterDebugDataForTypesAndMethods();
    private void FinishTypeAndMethodBuilding();
    internal void BuildType(TypeDesc type);
    internal bool TryComputeFieldOffset(DefType declaringType, UInt32 fieldOrdinal, Int32& fieldOffset);
    private void BuildMethod(InstantiatedMethod method);
    private static DefType GetExactDeclaringType(DefType srcDefType, DefType dstDefType);
    private IntPtr BuildGenericLookupTarget(TypeSystemContext typeSystemContext, IntPtr context, IntPtr signature, IntPtr& auxResult);
    private IntPtr BuildFloatingDictionary(TypeSystemContext typeSystemContext, IntPtr context, bool isTypeContext, IntPtr fixedDictionary, Boolean& isNewlyAllocatedDictionary);
    public static bool TryBuildGenericType(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public static bool TryBuildArrayType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public static bool TryBuildPointerType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public static bool TryBuildByRefType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public static bool TryBuildGenericMethod(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericMethodArgHandles, MethodNameAndSignature methodNameAndSignature, IntPtr& methodDictionary);
    internal static bool TryBuildGenericMethod(InstantiatedMethod methodBeingLoaded, IntPtr& methodDictionary);
    private void ResolveSingleCell_Worker(GenericDictionaryCell cell, IntPtr& fixupResolution);
    private void ResolveMultipleCells_Worker(GenericDictionaryCell[] cells, IntPtr[]& fixups);
    internal static void ResolveSingleCell(GenericDictionaryCell cell, IntPtr& fixupResolution);
    public static void ResolveMultipleCells(GenericDictionaryCell[] cells, IntPtr[]& fixups);
    public static IntPtr BuildGenericLookupTarget(IntPtr typeContext, IntPtr signature, IntPtr& auxResult);
    public static bool TryGetFieldOffset(RuntimeTypeHandle declaringTypeHandle, UInt32 fieldOrdinal, Int32& fieldOffset);
    internal static bool TryGetDelegateInvokeMethodSignature(RuntimeTypeHandle delegateTypeHandle, RuntimeSignature& signature);
    internal static IntPtr TryBuildFloatingDictionary(IntPtr context, bool isTypeContext, IntPtr fixedDictionary, Boolean& isNewlyAllocatedDictionary);
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.TypeLoader.TypeBuilderApi : object {
    public static void ResolveMultipleCells(GenericDictionaryCell[] cells, IntPtr[]& fixups);
}
internal class Internal.Runtime.TypeLoader.TypeBuilderState : object {
    public TypeDesc TypeBeingBuilt;
    public bool AttemptedAndFailedToRetrieveTypeHandle;
    public bool NeedsTypeHandle;
    public bool HasBeenPrepared;
    public RuntimeTypeHandle HalfBakedRuntimeTypeHandle;
    public IntPtr HalfBakedDictionary;
    public IntPtr HalfBakedSealedVTable;
    private bool _templateComputed;
    private bool _nativeLayoutTokenComputed;
    private TypeDesc _templateType;
    private bool _nativeLayoutComputed;
    private bool _templateTypeLoaderNativeLayout;
    private bool _readyToRunNativeLayout;
    private NativeLayoutInfo _nativeLayoutInfo;
    private NativeLayoutInfo _r2rnativeLayoutInfo;
    private Nullable`1<bool> _hasDictionarySlotInVTable;
    private Nullable`1<bool> _hasDictionaryInVTable;
    private Nullable`1<ushort> _numVTableSlots;
    public GenericTypeDictionary Dictionary;
    public Nullable`1<IntPtr> ClassConstructorPointer;
    public IntPtr GcStaticDesc;
    public IntPtr GcStaticEEType;
    public IntPtr ThreadStaticDesc;
    public bool AllocatedStaticGCDesc;
    public bool AllocatedThreadStaticGCDesc;
    public UInt32 ThreadStaticOffset;
    public UInt32 NumSealedVTableEntries;
    public Int32[] GenericVarianceFlags;
    private static LowLevelList`1<bool> s_emptyLayout;
    private LowLevelList`1<bool> _instanceGCLayout;
    public LowLevelList`1<bool> StaticGCLayout;
    public LowLevelList`1<bool> ThreadStaticGCLayout;
    private bool _staticGCLayoutPrepared;
    public VTableLayoutInfo[] VTableMethodSignatures;
    public int NumSealedVTableMethodSignatures;
    public VTableSlotMapper VTableSlotsMapping;
    public TypeDesc TemplateType { get; }
    public NativeLayoutInfo NativeLayoutInfo { get; }
    public NativeLayoutInfo R2RNativeLayoutInfo { get; }
    public DefType[] RuntimeInterfaces { get; }
    public bool HasDictionarySlotInVTable { get; }
    public bool HasDictionaryInVTable { get; }
    public ushort NumVTableSlots { get; }
    public int NonGcDataSize { get; }
    public int GcDataSize { get; }
    public int ThreadDataSize { get; }
    public bool HasStaticConstructor { get; }
    public LowLevelList`1<bool> InstanceGCLayout { get; }
    public bool IsArrayOfReferenceTypes { get; }
    public Nullable`1<int> ArrayRank { get; }
    public Nullable`1<int> BaseTypeSize { get; }
    public Nullable`1<int> TypeSize { get; }
    public Nullable`1<int> UnalignedTypeSize { get; }
    public Nullable`1<int> FieldAlignment { get; }
    public Nullable`1<ushort> ComponentSize { get; }
    public UInt32 NullableValueOffset { get; }
    public bool IsHFA { get; }
    public TypeBuilderState(TypeDesc typeBeingBuilt);
    private static TypeBuilderState();
    public TypeDesc get_TemplateType();
    private void EnsureNativeLayoutInfoComputed();
    private static void FinishInitNativeLayoutInfo(TypeDesc type, NativeLayoutInfo& nativeLayoutInfo);
    public NativeLayoutInfo get_NativeLayoutInfo();
    public NativeLayoutInfo get_R2RNativeLayoutInfo();
    public NativeParser GetParserForNativeLayoutInfo();
    public NativeParser GetParserForReadyToRunNativeLayoutInfo();
    public NativeParser GetParserForUniversalNativeLayoutInfo(NativeLayoutInfoLoadContext& universalLayoutLoadContext, NativeLayoutInfo& universalLayoutInfo);
    public DefType[] get_RuntimeInterfaces();
    private bool ComputeHasDictionarySlotInVTable();
    public bool get_HasDictionarySlotInVTable();
    private bool ComputeHasDictionaryInVTable();
    public bool get_HasDictionaryInVTable();
    private ushort ComputeNumVTableSlots();
    public ushort get_NumVTableSlots();
    public int get_NonGcDataSize();
    public int get_GcDataSize();
    public int get_ThreadDataSize();
    public bool get_HasStaticConstructor();
    public LowLevelList`1<bool> get_InstanceGCLayout();
    public void PrepareStaticGCLayout();
    private IEnumerable`1<FieldDesc> GetFieldsForGCLayout();
    private GCLayout GetInstanceGCLayout(TypeDesc type);
    private GCLayout GetFieldGCLayout(TypeDesc fieldType);
    public bool get_IsArrayOfReferenceTypes();
    public Nullable`1<int> get_ArrayRank();
    public Nullable`1<int> get_BaseTypeSize();
    public Nullable`1<int> get_TypeSize();
    public Nullable`1<int> get_UnalignedTypeSize();
    public Nullable`1<int> get_FieldAlignment();
    public Nullable`1<ushort> get_ComponentSize();
    public UInt32 get_NullableValueOffset();
    public bool get_IsHFA();
}
[ExtensionAttribute]
internal static class Internal.Runtime.TypeLoader.TypeDescExtensions : object {
    [ExtensionAttribute]
public static bool CanShareNormalGenericCode(TypeDesc type);
    [ExtensionAttribute]
public static bool IsGeneric(TypeDesc type);
    [ExtensionAttribute]
public static DefType GetClosestDefType(TypeDesc type);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.TypeLoaderEnvironment : object {
    private DynamicGenericMethodsHashtable _dynamicGenericMethods;
    private DynamicGenericMethodComponentsHashtable _dynamicGenericMethodComponents;
    private Lock _dynamicGenericsLock;
    private DynamicGenericTypesHashtable _dynamicGenericTypes;
    private LowLevelDictionary`2<LazyDictionaryContext, IntPtr> _lazyGenericDictionaries;
    [ThreadStaticAttribute]
private static bool t_isReentrant;
    [CompilerGeneratedAttribute]
private static TypeLoaderEnvironment <Instance>k__BackingField;
    public ModuleList ModuleList;
    [ThreadStaticAttribute]
private static LowLevelDictionary`2<TypeManagerHandle, NativeReader> t_moduleNativeReaders;
    private Lock _typeLoaderLock;
    private LowLevelDictionary`2<string, IntPtr> _nativeFormatStrings;
    private LowLevelDictionary`2<RuntimeFieldHandleKey, RuntimeFieldHandle> _runtimeFieldHandles;
    private LowLevelDictionary`2<RuntimeMethodHandleKey, RuntimeMethodHandle> _runtimeMethodHandles;
    private static UInt32 RVAIsIndirect;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _namedTypeLookupLiveVersion;
    private NamedTypeRuntimeTypeHandleToMetadataHashtable _runtimeTypeHandleToMetadataHashtable;
    [CompilerGeneratedAttribute]
private static IntPtr <NoStaticsData>k__BackingField;
    private QTypeDefinitionToRuntimeTypeHandleHashtable _metadataToRuntimeTypeHandleHashtable;
    private static int DynamicTypeTlsOffsetFlag;
    private Lock _threadStaticsLock;
    private int _maxTlsCells;
    private LowLevelDictionary`2<RuntimeTypeHandle, UInt32> _dynamicGenericsThreadStatics;
    private LowLevelDictionary`2<UInt32, int> _dynamicGenericsThreadStaticSizes;
    public static TypeLoaderEnvironment Instance { get; private set; }
    public static IntPtr NoStaticsData { get; private set; }
    internal bool TryLookupGenericMethodDictionaryForComponents(GenericMethodLookupData lookupData, IntPtr& result);
    public bool TryLookupGenericMethodDictionaryForComponents(RuntimeTypeHandle declaringType, MethodNameAndSignature nameAndSignature, RuntimeTypeHandle[] genericMethodArgumentHandles, IntPtr& result);
    public bool TryGetGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    public bool TryLookupExactMethodPointerForComponents(RuntimeTypeHandle declaringType, MethodNameAndSignature nameAndSignature, RuntimeTypeHandle[] genericMethodArgumentHandles, IntPtr& result);
    public bool TryGetGenericVirtualMethodPointer(RuntimeTypeHandle targetTypeHandle, MethodNameAndSignature nameAndSignature, RuntimeTypeHandle[] genericMethodArgumentHandles, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private bool TryGetDynamicGenericMethodDictionaryForComponents(GenericMethodLookupData lookupData, IntPtr& result);
    private bool TryGetStaticGenericMethodDictionaryForComponents(GenericMethodLookupData lookupData, IntPtr& result);
    private bool TryGetDynamicGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    private bool TryGetStaticGenericMethodComponents(IntPtr methodDictionary, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle[]& genericMethodArgumentHandles);
    internal void RegisterDynamicGenericTypesAndMethods(DynamicGenericsRegistrationData registrationData);
    public void RegisterConstructedLazyDictionaryForContext(IntPtr context, IntPtr signature, IntPtr dictionary);
    internal bool TryLookupConstructedGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryLookupConstructedLazyDictionaryForContext(IntPtr context, IntPtr signature, IntPtr& dictionary);
    private bool TryGetDynamicGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    internal bool TryGetStaticGenericTypeForComponents(GenericTypeLookupData lookupData, RuntimeTypeHandle& runtimeTypeHandle);
    [CompilerGeneratedAttribute]
public static TypeLoaderEnvironment get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(TypeLoaderEnvironment value);
    internal static void Initialize();
    public void VerifyTypeLoaderLockHeld();
    public void RunUnderTypeLoaderLock(Action action);
    public IntPtr GenericLookupFromContextAndSignature(IntPtr context, IntPtr signature, IntPtr& auxResult);
    private bool EnsureTypeHandleForType(TypeDesc type);
    internal TypeDesc GetConstructedTypeFromParserAndNativeLayoutContext(NativeParser& parser, NativeLayoutInfoLoadContext nativeLayoutContext);
    internal bool GetTypeFromSignatureAndContext(RuntimeSignature signature, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, RuntimeSignature& remainingSignature);
    internal bool GetTypeFromSignatureAndContext(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType);
    public bool GetMethodFromSignatureAndContext(RuntimeSignature signature, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles, RuntimeSignature& remainingSignature);
    internal bool GetMethodFromSignatureAndContext(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeTypeHandle[] typeArgs, RuntimeTypeHandle[] methodArgs, RuntimeTypeHandle& createdType, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodTypeArgumentHandles);
    internal NativeReader GetNativeLayoutInfoReader(NativeFormatModuleInfo module);
    internal NativeReader GetNativeLayoutInfoReader(RuntimeSignature signature);
    internal NativeReader GetNativeLayoutInfoReader(TypeManagerHandle moduleHandle);
    private static RuntimeTypeHandle[] GetTypeSequence(ExternalReferencesTable& extRefs, NativeParser& parser);
    private static RuntimeTypeHandle[] TypeDescsToRuntimeHandles(Instantiation types);
    public bool TryGetConstructedGenericTypeForComponents(RuntimeTypeHandle genericTypeDefinitionHandle, RuntimeTypeHandle[] genericTypeArgumentHandles, RuntimeTypeHandle& runtimeTypeHandle);
    public bool TryGetArrayTypeForElementType(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    internal bool TryGetArrayTypeForElementType_LookupOnly(RuntimeTypeHandle elementTypeHandle, bool isMdArray, int rank, RuntimeTypeHandle& arrayTypeHandle);
    public bool TryGetPointerTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& pointerTypeHandle);
    public bool TryGetByRefTypeForTargetType(RuntimeTypeHandle pointeeTypeHandle, RuntimeTypeHandle& byRefTypeHandle);
    public int GetCanonicalHashCode(RuntimeTypeHandle typeHandle, CanonicalFormKind kind);
    private object TryParseNativeSignatureWorker(TypeSystemContext typeSystemContext, TypeManagerHandle moduleHandle, NativeParser& parser, RuntimeTypeHandle[] typeGenericArgumentHandles, RuntimeTypeHandle[] methodGenericArgumentHandles, bool isMethodSignature);
    public bool TryGetGenericMethodDictionaryForComponents(RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericMethodArgHandles, MethodNameAndSignature nameAndSignature, IntPtr& methodDictionary);
    public bool TryGetFieldOffset(RuntimeTypeHandle declaringTypeHandle, UInt32 fieldOrdinal, Int32& fieldOffset);
    public IntPtr UpdateFloatingDictionary(IntPtr context, IntPtr dictionaryPtr);
    public bool CanInstantiationsShareCode(RuntimeTypeHandle[] genericArgHandles1, RuntimeTypeHandle[] genericArgHandles2, CanonicalFormKind kind);
    public bool ConversionToCanonFormIsAChange(RuntimeTypeHandle[] genericArgHandles, CanonicalFormKind kind);
    private bool GetHashtableFromBlob(NativeFormatModuleInfo module, ReflectionMapBlob blobId, NativeHashtable& hashtable, ExternalReferencesTable& externalReferencesLookup);
    public static void GetFieldAlignmentAndSize(RuntimeTypeHandle fieldType, Int32& alignment, Int32& size);
    public static bool TryGetTargetOfUnboxingAndInstantiatingStub(IntPtr maybeInstantiatingAndUnboxingStub, IntPtr& targetMethod);
    public bool TryComputeHasInstantiationDeterminedSize(RuntimeTypeHandle typeHandle, Boolean& hasInstantiationDeterminedSize);
    public bool TryComputeHasInstantiationDeterminedSize(RuntimeTypeHandle typeHandle, TypeSystemContext context, Boolean& hasInstantiationDeterminedSize);
    internal bool TryComputeHasInstantiationDeterminedSize(DefType type, Boolean& hasInstantiationDeterminedSize);
    public bool TryResolveSingleMetadataFixup(ModuleInfo module, int metadataToken, MetadataFixupKind fixupKind, IntPtr& fixupResolution);
    public bool TryDispatchMethodOnTarget(NativeFormatModuleInfo module, int metadataToken, RuntimeTypeHandle targetInstanceType, IntPtr& methodAddress);
    internal bool TryResolveTypeSlotDispatch(IntPtr targetTypeAsIntPtr, IntPtr interfaceTypeAsIntPtr, ushort slot, IntPtr& methodAddress);
    public bool TryGetOrCreateNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public static IntPtr ConvertUnboxingFunctionPointerToUnderlyingNonUnboxingPointer(IntPtr unboxingFunctionPointer, RuntimeTypeHandle declaringType);
    public static bool TryGetFieldAccessMetadata(MetadataReader metadataReader, RuntimeTypeHandle runtimeTypeHandle, FieldHandle fieldHandle, FieldAccessMetadata& fieldAccessMetadata);
    private static bool TryGetFieldAccessMetadataFromFieldAccessMap(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, FieldHandle fieldHandle, CanonicalFormKind canonFormKind, FieldAccessMetadata& fieldAccessMetadata);
    public static IntPtr RvaToNonGenericStaticFieldAddress(TypeManagerHandle moduleHandle, int staticFieldRVA);
    private static bool TryGetStaticFieldBaseFromFieldAccessMap(RuntimeTypeHandle declaringTypeHandle, FieldAccessStaticDataKind fieldAccessKind, IntPtr& staticsRegionAddress);
    private static bool TryGetFieldAccessMetadataFromNativeFormatMetadata(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, FieldHandle fieldHandle, TypeSystemContext context, FieldAccessMetadata& fieldAccessMetadata);
    private static bool TryGetFieldAccessMetadataForNativeFormatType(TypeDesc type, string fieldName, FieldAccessMetadata& fieldAccessMetadata);
    public bool TryGetGenericVirtualTargetForTypeAndSlot(RuntimeTypeHandle targetHandle, RuntimeTypeHandle& declaringType, RuntimeTypeHandle[] genericArguments, String& methodName, RuntimeSignature& methodSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer, Boolean& slotUpdated);
    private MethodNameAndSignature GetMethodNameAndSignatureFromNativeReader(NativeReader nativeLayoutReader, TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset);
    private RuntimeTypeHandle GetOpenTypeDefinition(RuntimeTypeHandle typeHandle, RuntimeTypeHandle[]& typeArgumentsHandles);
    private RuntimeTypeHandle GetTypeDefinition(RuntimeTypeHandle typeHandle);
    private bool FindMatchingInterfaceSlot(NativeFormatModuleInfo module, NativeReader nativeLayoutReader, NativeParser& entryParser, ExternalReferencesTable& extRefs, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature, RuntimeTypeHandle openTargetTypeHandle, RuntimeTypeHandle[] targetTypeInstantiation, bool variantDispatch);
    private bool ResolveInterfaceGenericVirtualMethodSlot(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature);
    private bool ResolveInterfaceGenericVirtualMethodSlot_Static(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle& declaringType, MethodNameAndSignature& methodNameAndSignature);
    public static bool IsPregeneratedOrTemplateRuntimeTypeHandle(RuntimeTypeHandle rtth);
    private bool ResolveGenericVirtualMethodTarget(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeHandle[] genericArguments, MethodNameAndSignature callingMethodNameAndSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private bool ResolveGenericVirtualMethodTarget_Static(RuntimeTypeHandle targetTypeHandle, RuntimeTypeHandle declaringType, RuntimeTypeHandle[] genericArguments, MethodNameAndSignature callingMethodNameAndSignature, IntPtr& methodPointer, IntPtr& dictionaryPointer);
    private static string GetStringFromMemoryInNativeFormat(IntPtr pointerToDataStream);
    public IntPtr GetNativeFormatStringForString(string str);
    public RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string fieldName);
    public RuntimeFieldHandle GetRuntimeFieldHandleForComponents(RuntimeTypeHandle declaringTypeHandle, IntPtr fieldName);
    public bool TryGetRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    private bool TryGetDynamicRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    private bool TryGetStaticRuntimeFieldHandleComponents(RuntimeFieldHandle runtimeFieldHandle, RuntimeTypeHandle& declaringTypeHandle, String& fieldName);
    public RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, IntPtr methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public RuntimeMethodHandle GetRuntimeMethodHandleForComponents(RuntimeTypeHandle declaringTypeHandle, string methodName, RuntimeSignature methodSignature, RuntimeTypeHandle[] genericMethodArgs);
    public bool TryGetRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    private bool TryGetDynamicRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    private bool TryGetStaticRuntimeMethodHandleComponents(RuntimeMethodHandle runtimeMethodHandle, RuntimeTypeHandle& declaringTypeHandle, MethodNameAndSignature& nameAndSignature, RuntimeTypeHandle[]& genericMethodArgs);
    public static RuntimeTypeHandle RvaToRuntimeTypeHandle(TypeManagerHandle moduleHandle, UInt32 rva);
    public static IntPtr RvaToFunctionPointer(TypeManagerHandle moduleHandle, UInt32 rva);
    private static bool SequenceEqual(T[] seq1, T[] seq2);
    internal static NativeReader GetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob);
    public static bool TryGetTypeReferenceForNamedType(RuntimeTypeHandle runtimeTypeHandle, MetadataReader& metadataReader, TypeReferenceHandle& typeRefHandle);
    public static bool TryGetNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle, bool searchAllModules);
    public static bool TryResolveNamedTypeForTypeReference(MetadataReader metadataReader, TypeReferenceHandle typeRefHandle, RuntimeTypeHandle& runtimeTypeHandle);
    private static bool TryGetNamedTypeForTypeReference_Inner(MetadataReader metadataReader, NativeFormatModuleInfo typeRefModule, TypeReferenceHandle typeRefHandle, int hashCode, NativeFormatModuleInfo module, RuntimeTypeHandle& runtimeTypeHandle);
    public static bool TryGetArrayTypeForNonDynamicElementType(RuntimeTypeHandle elementTypeHandle, RuntimeTypeHandle& arrayTypeHandle);
    public bool TryGetArrayTypeHandleForNonDynamicArrayTypeFromTemplateTable(ArrayType arrayType, RuntimeTypeHandle& arrayTypeHandle);
    private NativeHashtable LoadHashtable(NativeFormatModuleInfo module, ReflectionMapBlob hashtableBlobId, ExternalReferencesTable& externalFixupsTable);
    public static IntPtr TryGetStaticClassConstructionContext(RuntimeTypeHandle typeHandle);
    private static bool TryGetNativeReaderForBlob(NativeFormatModuleInfo module, ReflectionMapBlob blob, NativeReader& reader);
    internal IntPtr TryGetDefaultConstructorForType(TypeDesc type);
    public IntPtr TryGetDefaultConstructorForType(RuntimeTypeHandle runtimeTypeHandle);
    private IntPtr TryGetDefaultConstructorForTypeViaMetadata_Inner(TypeDesc type);
    internal IntPtr TryGetDefaultConstructorForType_Inner(NativeFormatModuleInfo mappingTableModule, CanonicallyEquivalentEntryLocator& canonHelper);
    public static bool TryResolveMemberReference(MetadataReader metadataReader, MemberReferenceHandle memberReferenceHandle, MetadataReader& resolvedMetadataReader, RuntimeTypeHandle& resolvedContainingTypeHandle, Handle& resolvedMemberHandle);
    public static bool TryGetMethodMethodNameAndSigFromVTableSlotForPregeneratedOrTemplateType(TypeSystemContext context, RuntimeTypeHandle type, int vtableSlot, MethodNameAndSignature& methodNameAndSig);
    public static bool TryGetVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle methodHandleDeclaringType, RuntimeTypeHandle[] genericArgs, MethodSignatureComparer& methodSignatureComparer, VirtualResolveDataResult& lookupResult);
    private static bool TryGetMethodNameAndSigFromVirtualResolveData(NativeFormatModuleInfo module, RuntimeTypeHandle declaringType, int logicalSlot, MethodNameAndSignature& methodNameAndSig);
    public static bool TryGetMethodInvokeMetadata(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    private static bool TryGetMethodInvokeMetadataFromInvokeMap(MetadataReader metadataReader, RuntimeTypeHandle declaringTypeHandle, MethodHandle methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    private static bool TryGetMethodInvokeMetadataFromNativeFormatMetadata(RuntimeTypeHandle declaringTypeHandle, QMethodDefinition methodHandle, RuntimeTypeHandle[] genericMethodTypeArgumentHandles, MethodSignatureComparer& methodSignatureComparer, TypeSystemContext typeSystemContext, CanonicalFormKind canonFormKind, MethodInvokeMetadata& methodInvokeMetadata);
    public static ModuleInfo GetModuleInfoForType(TypeDesc type);
    public bool TryGetMetadataForTypeMethodNameAndSignature(RuntimeTypeHandle declaringTypeHandle, MethodNameAndSignature nameAndSignature, QMethodDefinition& methodHandle);
    internal static bool TryGetMethodAddressFromMethodDesc(MethodDesc method, IntPtr& methodAddress, IntPtr& unboxingStubAddress, MethodAddressType& foundAddressType);
    private static bool TryGetMethodAddressFromTypeSystemMethodViaInvokeMap(MethodDesc method, IntPtr& methodAddress, IntPtr& unboxingStubAddress, MethodAddressType& foundAddressType);
    private static bool TryDispatchMethodOnTarget_Inner(NativeFormatModuleInfo module, int metadataToken, RuntimeTypeHandle targetInstanceType, IntPtr& methodAddress);
    private bool TryResolveTypeSlotDispatch_Inner(IntPtr targetTypeAsIntPtr, IntPtr interfaceTypeAsIntPtr, ushort slot, IntPtr& methodAddress);
    [CompilerGeneratedAttribute]
public static IntPtr get_NoStaticsData();
    [CompilerGeneratedAttribute]
private static void set_NoStaticsData(IntPtr value);
    public bool TryGetMetadataForNamedType(RuntimeTypeHandle runtimeTypeHandle, QTypeDefinition& qTypeDefinition);
    public bool TryGetStaticsInfoForNamedType(RuntimeTypeHandle runtimeTypeHandle, IntPtr& nonGcStaticsData, IntPtr& gcStaticsData);
    public bool TryGetNamedTypeForMetadata(QTypeDefinition qTypeDefinition, RuntimeTypeHandle& runtimeTypeHandle);
    public void RegisterNewNamedTypeRuntimeTypeHandle(QTypeDefinition qTypeDefinition, RuntimeTypeHandle runtimeTypeHandle, IntPtr nonGcStaticFields, IntPtr gcStaticFields);
    public void UnregisterNewNamedTypeRuntimeTypeHandle(QTypeDefinition qTypeDefinition, RuntimeTypeHandle runtimeTypeHandle);
    public void FinishAddingNewNamedTypes();
    public bool CompareMethodSignatures(RuntimeSignature signature1, RuntimeSignature signature2);
    public UInt32 GetGenericArgumentCountFromMethodNameAndSignature(MethodNameAndSignature signature);
    public bool TryGetMethodNameAndSignatureFromNativeLayoutSignature(RuntimeSignature signature, MethodNameAndSignature& nameAndSignature);
    public bool TryGetMethodNameAndSignaturePointersFromNativeLayoutSignature(TypeManagerHandle module, UInt32 methodNameAndSigToken, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    public bool TryGetMethodNameAndSignatureFromNativeLayoutOffset(TypeManagerHandle moduleHandle, UInt32 nativeLayoutOffset, MethodNameAndSignature& nameAndSignature);
    internal MethodNameAndSignature GetMethodNameAndSignature(NativeParser& parser, TypeManagerHandle moduleHandle, RuntimeSignature& methodNameSig, RuntimeSignature& methodSig);
    internal bool IsStaticMethodSignature(RuntimeSignature methodSig);
    internal bool GetCallingConverterDataFromMethodSignature(TypeSystemContext context, RuntimeSignature methodSig, Instantiation typeInstantiation, Instantiation methodInstantiation, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& parametersWithGenericDependentLayout);
    internal bool GetCallingConverterDataFromMethodSignature_NativeLayout(TypeSystemContext context, RuntimeSignature methodSig, Instantiation typeInstantiation, Instantiation methodInstantiation, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& parametersWithGenericDependentLayout);
    internal bool GetCallingConverterDataFromMethodSignature_NativeLayout_Common(TypeSystemContext context, RuntimeSignature methodSig, Instantiation typeInstantiation, Instantiation methodInstantiation, Boolean& hasThis, TypeDesc[]& parameters, Boolean[]& parametersWithGenericDependentLayout, NativeReader nativeReader, UInt64[] debuggerPreparedExternalReferences);
    internal bool MethodSignatureHasVarsNeedingCallingConventionConverter(TypeSystemContext context, RuntimeSignature methodSig);
    private bool MethodSignatureHasVarsNeedingCallingConventionConverter_NativeLayout(TypeSystemContext context, RuntimeSignature methodSig);
    private bool TypeSignatureHasVarsNeedingCallingConventionConverter(NativeParser& parser, NativeFormatModuleInfo moduleHandle, TypeSystemContext context, HasVarsInvestigationLevel investigationLevel);
    private bool TryGetTypeFromSimpleTypeSignature(NativeParser& parser, NativeFormatModuleInfo moduleHandle, RuntimeTypeHandle& typeHandle);
    private RuntimeTypeHandle GetExternalTypeHandle(NativeFormatModuleInfo moduleHandle, UInt32 typeIndex);
    private UInt32 GetGenericArgCountFromSig(NativeParser parser);
    private bool CompareMethodSigs(NativeParser parser1, NativeFormatModuleInfo moduleHandle1, NativeParser parser2, NativeFormatModuleInfo moduleHandle2);
    private bool CompareTypeSigs(NativeParser& parser1, NativeFormatModuleInfo moduleHandle1, NativeParser& parser2, NativeFormatModuleInfo moduleHandle2);
    public IntPtr TryGetNonGcStaticFieldDataDirect(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetNonGcStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetGcStaticFieldDataDirect(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetGcStaticFieldData(RuntimeTypeHandle runtimeTypeHandle);
    public int TryGetThreadStaticsSizeForDynamicType(int index, Int32& numTlsCells);
    public UInt32 GetNextThreadStaticsOffsetValue();
    public void RegisterDynamicThreadStaticsInfo(RuntimeTypeHandle runtimeTypeHandle, UInt32 offsetValue, int storageSize);
    public IntPtr TryGetTlsIndexDictionaryCellForType(RuntimeTypeHandle runtimeTypeHandle);
    public IntPtr TryGetTlsOffsetDictionaryCellForType(RuntimeTypeHandle runtimeTypeHandle);
    private bool GetStaticsInfoHashtable(NativeFormatModuleInfo module, NativeHashtable& staticsInfoHashtable, ExternalReferencesTable& externalReferencesLookup, ExternalReferencesTable& staticInfoLookup);
    private NativeParser GetStaticInfo(RuntimeTypeHandle instantiatedType, ExternalReferencesTable& staticsInfoLookup);
    private IntPtr TryCreateDictionaryCellWithValue(UInt32 value);
    public bool TryGetThreadStaticStartOffset(RuntimeTypeHandle runtimeTypeHandle, Int32& threadStaticsStartOffset);
    private IntPtr TryGetTlsIndexDictionaryCellForStaticType(RuntimeTypeHandle runtimeTypeHandle);
    private IntPtr TryGetTlsOffsetDictionaryCellForStaticType(RuntimeTypeHandle runtimeTypeHandle);
    private IntPtr TryGetTlsIndexDictionaryCellForDynamicType(RuntimeTypeHandle runtimeTypeHandle);
    private IntPtr TryGetTlsOffsetDictionaryCellForDynamicType(RuntimeTypeHandle runtimeTypeHandle);
}
internal static class Internal.Runtime.TypeLoader.TypeLoaderLogger : object {
    internal static int s_pauseHash;
    private static TypeLoaderLogger();
    [ConditionalAttribute("TYPE_LOADER_TRACE")]
public static void WriteLine(string message);
}
[__BlockReflectionAttribute]
public class Internal.Runtime.TypeLoader.TypeLoaderTypeSystemContext : TypeSystemContext {
    private static MetadataFieldLayoutAlgorithm s_metadataFieldLayoutAlgorithm;
    private static MetadataRuntimeInterfacesAlgorithm s_metadataRuntimeInterfacesAlgorithm;
    private static MetadataVirtualMethodAlgorithm s_metadataVirtualMethodAlgorithm;
    private static NoMetadataFieldLayoutAlgorithm s_noMetadataFieldLayoutAlgorithm;
    private static NoMetadataRuntimeInterfacesAlgorithm s_noMetadataRuntimeInterfacesAlgorithm;
    private static NativeLayoutFieldAlgorithm s_nativeLayoutFieldAlgorithm;
    private static NativeLayoutInterfacesAlgorithm s_nativeLayoutInterfacesAlgorithm;
    public bool SupportsUniversalCanon { get; }
    public bool SupportsCanon { get; }
    public TypeLoaderTypeSystemContext(TargetDetails targetDetails);
    private static TypeLoaderTypeSystemContext();
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    public virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwErrorIfNotFound);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    protected internal virtual bool ComputeHasGCStaticBase(FieldDesc field);
    protected internal virtual bool ComputeHasStaticConstructor(TypeDesc type);
    public virtual bool get_SupportsUniversalCanon();
    public virtual bool get_SupportsCanon();
}
[__BlockReflectionAttribute]
public static class Internal.Runtime.TypeLoader.TypeSystemContextFactory : object {
    private static GCHandle s_cachedContext;
    private static Lock s_lock;
    private static TypeSystemContextFactory();
    public static TypeSystemContext Create();
    public static void Recycle(TypeSystemContext context);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.Runtime.TypeLoader.WellKnownTypeExtensions : object {
    [ExtensionAttribute]
public static RuntimeTypeHandle GetRuntimeTypeHandle(WellKnownType wkt);
}
internal static class Internal.Runtime.UniversalGenericParameterLayout : object {
    public static bool IsLayoutDependentOnGenericInstantiation(TypeDesc type);
    private static bool IsLayoutDependentOnGenericInstantiation(TypeDesc type, HasVarsInvestigationLevel investigationLevel);
    public static bool MethodSignatureHasVarsNeedingCallingConventionConverter(MethodSignature methodSignature);
    public static bool VTableMethodRequiresCallingConventionConverter(MethodDesc method);
}
internal class Internal.Runtime.VirtualInvokeTableEntry : ValueType {
    public static int GenericVirtualMethod;
    public static int FlagsMask;
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.AlignmentHelper : object {
    [ExtensionAttribute]
public static int AlignUp(int val, int alignment);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ArrayMethod : MethodDesc {
    private ArrayType _owningType;
    private ArrayMethodKind _kind;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public ArrayType OwningArray { get; }
    public ArrayMethodKind Kind { get; }
    public MethodSignature Signature { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    internal ArrayMethod(ArrayType owningType, ArrayMethodKind kind);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    public ArrayType get_OwningArray();
    public ArrayMethodKind get_Kind();
    public virtual MethodSignature get_Signature();
    public virtual string get_Name();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual MethodNameAndSignature get_NameAndSignature();
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.ArrayMethodKind : Enum {
    public int value__;
    public static ArrayMethodKind Get;
    public static ArrayMethodKind Set;
    public static ArrayMethodKind Address;
    public static ArrayMethodKind AddressWithHiddenArg;
    public static ArrayMethodKind Ctor;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ArrayOfTRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private MetadataType _arrayOfTType;
    public ArrayOfTRuntimeInterfacesAlgorithm(MetadataType arrayOfTType);
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ArrayType : ParameterizedType {
    private int _rank;
    internal MethodDesc[] _methods;
    public DefType BaseType { get; }
    public TypeDesc ElementType { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public int Rank { get; }
    internal ArrayType(TypeDesc elementType, int rank);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual DefType get_BaseType();
    public TypeDesc get_ElementType();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public int get_Rank();
    private void InitializeMethods();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public MethodDesc GetArrayMethod(ArrayMethodKind kind);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.BaseTypeRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    private static RuntimeInterfacesAlgorithm _singleton;
    public static RuntimeInterfacesAlgorithm Instance { get; }
    private static BaseTypeRuntimeInterfacesAlgorithm();
    public static RuntimeInterfacesAlgorithm get_Instance();
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ByRefType : ParameterizedType {
    internal ByRefType(TypeDesc parameter);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.CanonBaseType : MetadataType {
    private TypeSystemContext _context;
    public TypeSystemContext Context { get; }
    public MetadataType MetadataBaseType { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsSequentialLayout { get; }
    public bool IsExplicitLayout { get; }
    public ModuleDesc Module { get; }
    public bool IsModuleType { get; }
    public CanonBaseType(TypeSystemContext context);
    public sealed virtual TypeSystemContext get_Context();
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MetadataType get_MetadataBaseType();
    public virtual DefType get_ContainingType();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsExplicitLayout();
    public virtual ModuleDesc get_Module();
    public virtual bool get_IsModuleType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual MetadataType GetNestedType(string name);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.CanonicalFormKind : Enum {
    public int value__;
    public static CanonicalFormKind Specific;
    public static CanonicalFormKind Universal;
    public static CanonicalFormKind Any;
}
internal class Internal.TypeSystem.CanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public bool IsSealed { get; }
    public DefType BaseType { get; }
    public CanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual bool get_IsSealed();
    private void Initialize();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.CastingHelper : object {
    [ExtensionAttribute]
public static bool CanCastTo(TypeDesc thisType, TypeDesc otherType);
    [ExtensionAttribute]
private static bool CanCastToInternal(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastGenericParameterTo(GenericParameterDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastArrayTo(ArrayType thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastParamTo(ParameterizedType thisType, TypeDesc paramType, StackOverflowProtect protect);
    private static bool ArePrimitveTypesEquivalentSize(TypeDesc type1, TypeDesc type2);
    [ExtensionAttribute]
private static int GetIntegralTypeMatchSize(TypeDesc type);
    public static bool IsArrayElementTypeCastableBySize(TypeDesc elementType);
    [ExtensionAttribute]
private static bool CanCastToClassOrInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastToNonVariantInterface(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool CanCastByVarianceToInterfaceOrDelegate(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protectInput);
    [ExtensionAttribute]
private static bool CanCastToClass(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
    [ExtensionAttribute]
private static bool IsBoxedAndCanCastTo(TypeDesc thisType, TypeDesc otherType, StackOverflowProtect protect);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ClassLayoutMetadata : ValueType {
    public int PackingSize;
    public int Size;
    public FieldAndOffset[] Offsets;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ComputedInstanceFieldLayout : ValueType {
    public LayoutInt FieldSize;
    public LayoutInt FieldAlignment;
    public LayoutInt ByteCountUnaligned;
    public LayoutInt ByteCountAlignment;
    public FieldAndOffset[] Offsets;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ComputedStaticFieldLayout : ValueType {
    public StaticsBlock NonGcStatics;
    public StaticsBlock GcStatics;
    public StaticsBlock ThreadNonGcStatics;
    public StaticsBlock ThreadGcStatics;
    public FieldAndOffset[] Offsets;
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.ConstructedTypeRewritingHelpers : object {
    [ExtensionAttribute]
public static bool IsConstructedOverType(TypeDesc type, TypeDesc[] typesToFind);
    [ExtensionAttribute]
public static TypeDesc ReplaceTypesInConstructionOfType(TypeDesc type, TypeDesc[] typesToReplace, TypeDesc[] replacementTypes);
    [ExtensionAttribute]
public static MethodDesc ReplaceTypesInConstructionOfMethod(MethodDesc method, TypeDesc[] typesToReplace, TypeDesc[] replacementTypes);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.DefType : TypeDesc {
    private ThreadSafeFlags _fieldLayoutFlags;
    private LayoutInt _instanceFieldSize;
    private LayoutInt _instanceFieldAlignment;
    private LayoutInt _instanceByteCountUnaligned;
    private LayoutInt _instanceByteAlignment;
    private StaticBlockInfo _staticBlockInfo;
    private ValueTypeShapeCharacteristics _valueTypeShapeCharacteristics;
    internal static LayoutInt MaximumAlignmentPossible;
    public string Namespace { get; }
    public string Name { get; }
    public DefType ContainingType { get; }
    public bool ContainsGCPointers { get; }
    public LayoutInt InstanceFieldSize { get; }
    public LayoutInt InstanceFieldAlignment { get; }
    public LayoutInt InstanceByteCount { get; }
    public LayoutInt InstanceByteCountUnaligned { get; }
    public LayoutInt InstanceByteAlignment { get; }
    public LayoutInt NonGCStaticFieldSize { get; }
    public LayoutInt NonGCStaticFieldAlignment { get; }
    public LayoutInt GCStaticFieldSize { get; }
    public LayoutInt GCStaticFieldAlignment { get; }
    public LayoutInt ThreadNonGcStaticFieldSize { get; }
    public LayoutInt ThreadNonGcStaticFieldAlignment { get; }
    public LayoutInt ThreadGcStaticFieldSize { get; }
    public LayoutInt ThreadGcStaticFieldAlignment { get; }
    public bool IsHfa { get; }
    internal ValueTypeShapeCharacteristics ValueTypeShapeCharacteristics { get; }
    public DefType HfaElementType { get; }
    public bool HasNativeLayout { get; }
    private static DefType();
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual DefType get_ContainingType();
    public bool get_ContainsGCPointers();
    public LayoutInt get_InstanceFieldSize();
    public LayoutInt get_InstanceFieldAlignment();
    public LayoutInt get_InstanceByteCount();
    public LayoutInt get_InstanceByteCountUnaligned();
    public LayoutInt get_InstanceByteAlignment();
    public LayoutInt get_NonGCStaticFieldSize();
    public LayoutInt get_NonGCStaticFieldAlignment();
    public LayoutInt get_GCStaticFieldSize();
    public LayoutInt get_GCStaticFieldAlignment();
    public LayoutInt get_ThreadNonGcStaticFieldSize();
    public LayoutInt get_ThreadNonGcStaticFieldAlignment();
    public LayoutInt get_ThreadGcStaticFieldSize();
    public LayoutInt get_ThreadGcStaticFieldAlignment();
    public bool get_IsHfa();
    internal ValueTypeShapeCharacteristics get_ValueTypeShapeCharacteristics();
    public DefType get_HfaElementType();
    private void ComputeValueTypeShapeCharacteristics();
    public void ComputeInstanceLayout(InstanceLayoutKind layoutKind);
    public void ComputeStaticFieldLayout(StaticLayoutKind layoutKind);
    public void ComputeTypeContainsGCPointers();
    internal IEnumerable`1<FieldDesc> GetDiagnosticFields();
    public FieldDesc GetFieldByNativeLayoutOrdinal(UInt32 ordinal);
    public virtual bool get_HasNativeLayout();
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ExceptionTypeNameFormatter : TypeNameFormatter {
    [CompilerGeneratedAttribute]
private static ExceptionTypeNameFormatter <Instance>k__BackingField;
    public static ExceptionTypeNameFormatter Instance { get; }
    private static ExceptionTypeNameFormatter();
    [CompilerGeneratedAttribute]
public static ExceptionTypeNameFormatter get_Instance();
    public virtual void AppendName(StringBuilder sb, PointerType type);
    public virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    public virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public virtual void AppendName(StringBuilder sb, ByRefType type);
    public virtual void AppendName(StringBuilder sb, ArrayType type);
    protected virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    private string GetTypeName(DefType type);
    private string GetTypeNamespace(DefType type);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.FieldAndOffset : ValueType {
    public static LayoutInt InvalidOffset;
    public FieldDesc Field;
    public LayoutInt Offset;
    public FieldAndOffset(FieldDesc field, LayoutInt offset);
    private static FieldAndOffset();
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.FieldDesc : TypeSystemEntity {
    public static FieldDesc[] EmptyFields;
    private LayoutInt _offset;
    public string Name { get; }
    public DefType OwningType { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    public bool IsTypicalFieldDefinition { get; }
    public LayoutInt Offset { get; }
    public bool HasGCStaticBase { get; }
    private static FieldDesc();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string get_Name();
    public abstract virtual DefType get_OwningType();
    public abstract virtual TypeDesc get_FieldType();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual bool get_IsThreadStatic();
    public abstract virtual bool get_HasRva();
    public abstract virtual bool get_IsLiteral();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
    public bool get_IsTypicalFieldDefinition();
    public virtual FieldDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public LayoutInt get_Offset();
    public bool get_HasGCStaticBase();
    internal void InitializeOffset(LayoutInt offset);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.FieldForInstantiatedType : FieldDesc {
    private FieldDesc _fieldDef;
    private InstantiatedType _instantiatedType;
    public TypeSystemContext Context { get; }
    public DefType OwningType { get; }
    public string Name { get; }
    public TypeDesc FieldType { get; }
    public bool IsStatic { get; }
    public bool IsInitOnly { get; }
    public bool IsThreadStatic { get; }
    public bool HasRva { get; }
    public bool IsLiteral { get; }
    internal FieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_OwningType();
    public virtual string get_Name();
    public virtual TypeDesc get_FieldType();
    public virtual bool get_IsStatic();
    public virtual bool get_IsInitOnly();
    public virtual bool get_IsThreadStatic();
    public virtual bool get_HasRva();
    public virtual bool get_IsLiteral();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual FieldDesc GetTypicalFieldDefinition();
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.FieldLayoutAlgorithm : object {
    public abstract virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public abstract virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public abstract virtual bool ComputeContainsGCPointers(DefType type);
    public abstract virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    public abstract virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.FunctionPointerType : TypeDesc {
    private MethodSignature _signature;
    private int _hashCode;
    public MethodSignature Signature { get; }
    public TypeSystemContext Context { get; }
    internal FunctionPointerType(MethodSignature signature);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public MethodSignature get_Signature();
    public virtual TypeSystemContext get_Context();
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.GenericConstraints : Enum {
    public int value__;
    public static GenericConstraints None;
    public static GenericConstraints ReferenceTypeConstraint;
    public static GenericConstraints NotNullableValueTypeConstraint;
    public static GenericConstraints DefaultConstructorConstraint;
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.GenericParameterDesc : TypeDesc {
    public string Name { get; }
    public GenericParameterKind Kind { get; }
    public int Index { get; }
    public GenericVariance Variance { get; }
    public GenericConstraints Constraints { get; }
    public IEnumerable`1<TypeDesc> TypeConstraints { get; }
    public bool HasNotNullableValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasDefaultConstructorConstraint { get; }
    public bool IsCovariant { get; }
    public bool IsContravariant { get; }
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected sealed virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual string get_Name();
    public abstract virtual GenericParameterKind get_Kind();
    public abstract virtual int get_Index();
    public virtual GenericVariance get_Variance();
    public virtual GenericConstraints get_Constraints();
    public virtual IEnumerable`1<TypeDesc> get_TypeConstraints();
    public bool get_HasNotNullableValueTypeConstraint();
    public bool get_HasReferenceTypeConstraint();
    public bool get_HasDefaultConstructorConstraint();
    public bool get_IsCovariant();
    public bool get_IsContravariant();
    protected sealed virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public sealed virtual int GetHashCode();
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.GenericParameterKind : Enum {
    public int value__;
    public static GenericParameterKind Type;
    public static GenericParameterKind Method;
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.GenericVariance : Enum {
    public int value__;
    public static GenericVariance None;
    public static GenericVariance Covariant;
    public static GenericVariance Contravariant;
}
[__BlockReflectionAttribute]
public interface Internal.TypeSystem.IAssemblyDesc {
    public abstract virtual AssemblyName GetName();
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.InstanceLayoutKind : Enum {
    public int value__;
    public static InstanceLayoutKind TypeOnly;
    public static InstanceLayoutKind TypeAndFields;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.InstantiatedMethod : MethodDesc {
    private InstantiatedMethod _specificCanonCache;
    private InstantiatedMethod _universalCanonCache;
    private MethodDesc _methodDef;
    private Instantiation _instantiation;
    private MethodSignature _signature;
    [CompilerGeneratedAttribute]
private bool <NeedsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <RuntimeMethodDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericDictionary <Dictionary>k__BackingField;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public bool NeedsDictionary { get; public set; }
    public IntPtr RuntimeMethodDictionary { get; private set; }
    internal GenericDictionary Dictionary { get; private set; }
    public bool UnboxingStub { get; }
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    internal InstantiatedMethod(MethodDesc methodDef, Instantiation instantiation, int hashcode);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    private InstantiatedMethod GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, InstantiatedMethod value);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    protected virtual int ComputeHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual bool get_IsDefaultConstructor();
    public virtual MethodDesc GetMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual string get_Name();
    public virtual MethodNameAndSignature get_NameAndSignature();
    protected virtual bool ComputeIsNonSharableMethod();
    [CompilerGeneratedAttribute]
public bool get_NeedsDictionary();
    [CompilerGeneratedAttribute]
public void set_NeedsDictionary(bool value);
    [CompilerGeneratedAttribute]
public IntPtr get_RuntimeMethodDictionary();
    [CompilerGeneratedAttribute]
private void set_RuntimeMethodDictionary(IntPtr value);
    [CompilerGeneratedAttribute]
internal GenericDictionary get_Dictionary();
    [CompilerGeneratedAttribute]
private void set_Dictionary(GenericDictionary value);
    internal void SetGenericDictionary(GenericDictionary dictionary);
    public void AssociateWithRuntimeMethodDictionary(IntPtr rmd);
    public virtual bool get_UnboxingStub();
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.InstantiatedType : MetadataType {
    private MetadataType _typeDef;
    private Instantiation _instantiation;
    private int _hashCode;
    private MetadataType _baseType;
    private DefType[] _implementedInterfaces;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public DefType BaseType { get; }
    public MetadataType MetadataBaseType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public ModuleDesc Module { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    internal InstantiatedType(MetadataType typeDef, Instantiation instantiation);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    private MetadataType InitializeBaseType();
    public virtual DefType get_BaseType();
    public virtual MetadataType get_MetadataBaseType();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual string get_Name();
    public virtual string get_Namespace();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetMethods>d__23")]
public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual MethodDesc GetFinalizer();
    [IteratorStateMachineAttribute("Internal.TypeSystem.InstantiatedType/<GetFields>d__28")]
public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public static T[] InstantiateTypeArray(T[] uninstantiatedTypes, Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public virtual ClassLayoutMetadata GetClassLayout();
    public virtual bool get_IsExplicitLayout();
    public virtual bool get_IsSequentialLayout();
    public virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual ModuleDesc get_Module();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual DefType get_ContainingType();
    public virtual MetadataType GetNestedType(string name);
    public virtual IEnumerable`1<MetadataType> GetNestedTypes();
    private DefType[] InitializeImplementedInterfaces();
    public virtual DefType[] get_ExplicitlyImplementedInterfaces();
    private MethodImplRecord[] InstantiateMethodImpls(MethodImplRecord[] uninstMethodImpls);
    protected virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
}
[DefaultMemberAttribute("GenericParameters")]
[__BlockReflectionAttribute]
public class Internal.TypeSystem.Instantiation : ValueType {
    private TypeDesc[] _genericParameters;
    public static Instantiation Empty;
    public TypeDesc GenericParameters { get; }
    public int Length { get; }
    public bool IsNull { get; }
    public Instantiation(TypeDesc[] genericParameters);
    private static Instantiation();
    public TypeDesc get_GenericParameters(int index);
    public int get_Length();
    public bool get_IsNull();
    public int ComputeGenericInstanceHashCode(int genericDefinitionHashCode);
    public Enumerator GetEnumerator();
    public virtual string ToString();
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.LayoutInt : ValueType {
    private int _value;
    public static LayoutInt Indeterminate;
    public static LayoutInt Zero;
    public static LayoutInt One;
    public bool IsIndeterminate { get; }
    public int AsInt { get; }
    public LayoutInt(int input);
    private static LayoutInt();
    private static LayoutInt CreateIndeterminateLayoutInt();
    public bool get_IsIndeterminate();
    public int get_AsInt();
    public virtual string ToString();
    public string ToStringInvariant();
    public static bool op_Equality(LayoutInt left, LayoutInt right);
    public static bool op_Inequality(LayoutInt left, LayoutInt right);
    public static LayoutInt op_Addition(LayoutInt left, LayoutInt right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LayoutInt Max(LayoutInt left, LayoutInt right);
    public static LayoutInt Min(LayoutInt left, LayoutInt right);
    public static LayoutInt AlignUp(LayoutInt value, LayoutInt alignment);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.LockFreeObjectInterner : LockFreeReaderHashtableOfPointers`2<object, GCHandle> {
    private static LockFreeObjectInterner s_interner;
    private static LockFreeObjectInterner();
    public static GCHandle GetInternedObjectHandle(object obj);
    protected virtual int GetKeyHashCode(object key);
    protected virtual int GetValueHashCode(GCHandle value);
    protected virtual bool CompareKeyToValue(object key, GCHandle value);
    protected virtual bool CompareValueToValue(GCHandle value1, GCHandle value2);
    protected virtual GCHandle CreateValueFromKey(object key);
    protected virtual IntPtr ConvertValueToIntPtr(GCHandle value);
    protected virtual GCHandle ConvertIntPtrToValue(IntPtr pointer);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.LockFreeReaderHashtableOfPointers`2 : object {
    private static int _initialSize;
    private static int _fillPercentageBeforeResize;
    private IntPtr[] modreq(System.Runtime.CompilerServices.IsVolatile) _hashtable;
    private IntPtr[] modreq(System.Runtime.CompilerServices.IsVolatile) _newHashTable;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _count;
    private int _reserve;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _resizeCount;
    public int Count { get; }
    private IntPtr[] GetCurrentHashtable();
    private void SetCurrentHashtable(IntPtr[] hashtable);
    public static int HashInt1(int key);
    public static int HashInt2(int key);
    public int get_Count();
    public bool TryGetValue(TKey key, TValue& value);
    private void Expand(IntPtr[] oldHashtable);
    public void Reserve(int size);
    public bool TryAdd(TValue value);
    public TValue AddOrGetExisting(TValue value);
    private TValue AddOrGetExistingInner(TValue value, Boolean& addedValue);
    private bool TryAddOrGetExisting(TValue value, Boolean& addedValue, TValue& valueInHashtable);
    private bool TryWriteValueToLocation(IntPtr value, IntPtr[] hashTableLocal, int tableIndex);
    private TValue CreateValueAndEnsureValueIsInTable(TKey key);
    public TValue GetOrCreateValue(TKey key);
    public bool Contains(TKey key);
    public TValue GetValueIfExists(TValue value);
    protected abstract virtual int GetKeyHashCode(TKey key);
    protected abstract virtual int GetValueHashCode(TValue value);
    protected abstract virtual bool CompareKeyToValue(TKey key, TValue value);
    protected abstract virtual bool CompareValueToValue(TValue value1, TValue value2);
    protected abstract virtual TValue CreateValueFromKey(TKey key);
    protected abstract virtual IntPtr ConvertValueToIntPtr(TValue value);
    protected abstract virtual TValue ConvertIntPtrToValue(IntPtr pointer);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MetadataFieldLayoutAlgorithm : FieldLayoutAlgorithm {
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType defType, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType defType, StaticLayoutKind layoutKind);
    private StaticsBlock& GetStaticsBlockForField(ComputedStaticFieldLayout& layout, FieldDesc field);
    public virtual bool ComputeContainsGCPointers(DefType type);
    protected virtual void PrepareRuntimeSpecificStaticFieldLayout(TypeSystemContext context, ComputedStaticFieldLayout& layout);
    protected virtual void FinalizeRuntimeSpecificStaticFieldLayout(TypeSystemContext context, ComputedStaticFieldLayout& layout);
    private static ComputedInstanceFieldLayout ComputeExplicitFieldLayout(MetadataType type, int numInstanceFields);
    private static ComputedInstanceFieldLayout ComputeSequentialFieldLayout(MetadataType type, int numInstanceFields);
    private static LayoutInt ComputeBytesUsedInParentType(DefType type);
    private static SizeAndAlignment ComputeFieldSizeAndAlignment(TypeDesc fieldType, int packingSize);
    private static int ComputePackingSize(MetadataType type, ClassLayoutMetadata layoutMetadata);
    private static SizeAndAlignment ComputeInstanceSize(MetadataType type, LayoutInt instanceSize, LayoutInt alignment, SizeAndAlignment& byteCount);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
    private ValueTypeShapeCharacteristics ComputeHomogeneousFloatAggregateCharacteristic(DefType type);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MetadataRuntimeInterfacesAlgorithm : RuntimeInterfacesAlgorithm {
    public virtual DefType[] ComputeRuntimeInterfaces(TypeDesc _type);
    private DefType[] ComputeRuntimeInterfacesForInstantiatedType(InstantiatedType instantiatedType);
    private DefType[] ComputeRuntimeInterfacesForNonInstantiatedMetadataType(MetadataType type);
    private void BuildPostOrderInterfaceList(DefType iface, ArrayBuilder`1& interfacesArray);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.MetadataType : DefType {
    private MethodImplRecord[] _allVirtualMethodImplsForType;
    public string Name { get; }
    public string Namespace { get; }
    public bool IsExplicitLayout { get; }
    public bool IsSequentialLayout { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsModuleType { get; }
    public ModuleDesc Module { get; }
    public MetadataType MetadataBaseType { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public DefType ContainingType { get; }
    public DefType[] ExplicitlyImplementedInterfaces { get; }
    public MethodImplRecord[] VirtualMethodImplsForType { get; }
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public abstract virtual ClassLayoutMetadata GetClassLayout();
    public abstract virtual bool get_IsExplicitLayout();
    public abstract virtual bool get_IsSequentialLayout();
    public abstract virtual bool get_IsBeforeFieldInit();
    public virtual bool get_IsModuleType();
    public abstract virtual ModuleDesc get_Module();
    public abstract virtual MetadataType get_MetadataBaseType();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public abstract virtual DefType get_ContainingType();
    public abstract virtual IEnumerable`1<MetadataType> GetNestedTypes();
    public abstract virtual MetadataType GetNestedType(string name);
    public abstract virtual DefType[] get_ExplicitlyImplementedInterfaces();
    protected abstract virtual MethodImplRecord[] ComputeVirtualMethodImplsForType();
    public MethodImplRecord[] get_VirtualMethodImplsForType();
    public abstract virtual MethodImplRecord[] FindMethodsImplWithMatchingDeclName(string name);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MetadataVirtualMethodAlgorithm : VirtualMethodAlgorithm {
    private static Func`3<MethodDesc, MethodDesc, bool> s_VerifyMethodsHaveTheSameVirtualSlot;
    private static MetadataVirtualMethodAlgorithm();
    public virtual MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, TypeDesc objectType);
    private static MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, MetadataType objectType);
    private static bool IsInterfaceImplementedOnType(MetadataType type, MetadataType interfaceType);
    private static MethodDesc FindImplFromDeclFromMethodImpls(MetadataType type, MethodDesc decl);
    private static bool IsInterfaceExplicitlyImplementedOnType(MetadataType type, MetadataType interfaceType);
    private static MethodDesc FindMatchingVirtualMethodOnTypeByNameAndSig(MethodDesc targetMethod, DefType currentType, bool reverseMethodSearch, Func`3<MethodDesc, MethodDesc, bool> nameSigMatchMethodIsValidCandidate);
    private static MethodDesc FindNameSigOverrideForVirtualMethod(MethodDesc targetMethod, MetadataType currentType);
    public static MethodDesc FindSlotDefiningMethodForVirtualMethod(MethodDesc method);
    private static MethodDesc FindMatchingVirtualMethodOnTypeByNameAndSigWithSlotCheck(MethodDesc method, DefType currentType, bool reverseMethodSearch);
    private static bool VerifyMethodsHaveTheSameVirtualSlot(MethodDesc slotDefiningMethod, MethodDesc methodToVerify);
    private static void FindBaseUnificationGroup(MetadataType currentType, UnificationGroup unificationGroup);
    public virtual MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public virtual MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    private static MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, MetadataType currentType);
    public static MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, MetadataType currentType);
    private static MethodDesc ResolveInterfaceMethodToVirtualMethodOnTypeRecursive(MethodDesc interfaceMethod, MetadataType currentType);
    private static MethodDesc FindNameSigOverrideForInterfaceMethodRecursive(MethodDesc interfaceMethod, MetadataType currentType);
    public virtual IEnumerable`1<MethodDesc> ComputeAllVirtualSlots(TypeDesc type);
    [IteratorStateMachineAttribute("Internal.TypeSystem.MetadataVirtualMethodAlgorithm/<EnumAllVirtualSlots>d__21")]
public static IEnumerable`1<MethodDesc> EnumAllVirtualSlots(MetadataType type);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.MethodDesc : TypeSystemEntity {
    public static MethodDesc[] EmptyMethods;
    private int _hashcode;
    private IntPtr _functionPointer;
    private IntPtr _usgFunctionPointer;
    private Nullable`1<bool> _isNonSharableCache;
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public bool IsConstructor { get; }
    public bool IsDefaultConstructor { get; }
    public bool IsStaticConstructor { get; }
    public string Name { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsMethodDefinition { get; }
    public bool IsTypicalMethodDefinition { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsFinalizer { get; }
    public IntPtr FunctionPointer { get; }
    public IntPtr UsgFunctionPointer { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public bool IsNonSharableMethod { get; }
    public bool UnboxingStub { get; }
    private static MethodDesc();
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    protected void SetHashCode(int hashcode);
    public sealed virtual int GetHashCode();
    private int AcquireHashCode();
    protected virtual int ComputeHashCode();
    public virtual bool Equals(object o);
    public abstract virtual TypeDesc get_OwningType();
    public abstract virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    public bool get_IsConstructor();
    public virtual bool get_IsDefaultConstructor();
    public bool get_IsStaticConstructor();
    public virtual string get_Name();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public abstract virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetMethodDefinition();
    public bool get_IsMethodDefinition();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public bool get_IsTypicalMethodDefinition();
    public bool get_IsGenericMethodDefinition();
    public bool get_IsFinalizer();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public void SetFunctionPointer(IntPtr functionPointer, bool isFunctionPointerUSG);
    public IntPtr get_FunctionPointer();
    public IntPtr get_UsgFunctionPointer();
    public abstract virtual MethodNameAndSignature get_NameAndSignature();
    public virtual bool get_IsNonSharableMethod();
    protected virtual bool ComputeIsNonSharableMethod();
    public virtual bool get_UnboxingStub();
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MethodForInstantiatedType : MethodDesc {
    private MethodDesc _typicalMethodDef;
    private InstantiatedType _instantiatedType;
    private MethodSignature _signature;
    public TypeSystemContext Context { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public Instantiation Instantiation { get; }
    public bool IsVirtual { get; }
    public bool IsNewSlot { get; }
    public bool IsAbstract { get; }
    public bool IsFinal { get; }
    public bool IsDefaultConstructor { get; }
    public string Name { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    internal MethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual TypeDesc get_OwningType();
    private TypeDesc Instantiate(TypeDesc type);
    public virtual MethodSignature get_Signature();
    public virtual Instantiation get_Instantiation();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsNewSlot();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsFinal();
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual bool get_IsDefaultConstructor();
    public virtual string get_Name();
    public virtual MethodNameAndSignature get_NameAndSignature();
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MethodImplRecord : ValueType {
    public MethodDesc Decl;
    public MethodDesc Body;
    public MethodImplRecord(MethodDesc decl, MethodDesc body);
}
[DefaultMemberAttribute("Parameter")]
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MethodSignature : TypeSystemEntity {
    internal MethodSignatureFlags _flags;
    internal int _genericParameterCount;
    internal TypeDesc _returnType;
    internal TypeDesc[] _parameters;
    public MethodSignatureFlags Flags { get; }
    public bool IsStatic { get; }
    public int GenericParameterCount { get; }
    public TypeDesc ReturnType { get; }
    public TypeDesc Parameter { get; }
    public int Length { get; }
    public TypeSystemContext Context { get; }
    public MethodSignature(MethodSignatureFlags flags, int genericParameterCount, TypeDesc returnType, TypeDesc[] parameters);
    public MethodSignatureFlags get_Flags();
    public bool get_IsStatic();
    public int get_GenericParameterCount();
    public TypeDesc get_ReturnType();
    public TypeDesc get_Parameter(int index);
    public int get_Length();
    public bool Equals(MethodSignature otherSignature);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SignatureEnumerator GetEnumerator();
    public virtual TypeSystemContext get_Context();
}
[DefaultMemberAttribute("Parameter")]
[__BlockReflectionAttribute]
public class Internal.TypeSystem.MethodSignatureBuilder : ValueType {
    private MethodSignature _template;
    private MethodSignatureFlags _flags;
    private int _genericParameterCount;
    private TypeDesc _returnType;
    private TypeDesc[] _parameters;
    unknown MethodSignatureFlags Flags {public set; }
    unknown TypeDesc ReturnType {public set; }
    unknown TypeDesc Parameter {public set; }
    unknown int Length {public set; }
    public MethodSignatureBuilder(MethodSignature template);
    public void set_Flags(MethodSignatureFlags value);
    public void set_ReturnType(TypeDesc value);
    public void set_Parameter(int index, TypeDesc value);
    public void set_Length(int value);
    public MethodSignature ToSignature();
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.MethodSignatureFlags : Enum {
    public int value__;
    public static MethodSignatureFlags None;
    public static MethodSignatureFlags UnmanagedCallingConventionMask;
    public static MethodSignatureFlags UnmanagedCallingConventionCdecl;
    public static MethodSignatureFlags UnmanagedCallingConventionStdCall;
    public static MethodSignatureFlags UnmanagedCallingConventionThisCall;
    public static MethodSignatureFlags CallingConventionVarargs;
    public static MethodSignatureFlags Static;
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.ModuleDesc : TypeSystemEntity {
    [CompilerGeneratedAttribute]
private TypeSystemContext <Context>k__BackingField;
    public TypeSystemContext Context { get; }
    public ModuleDesc(TypeSystemContext context);
    [CompilerGeneratedAttribute]
public virtual TypeSystemContext get_Context();
    public abstract virtual MetadataType GetType(string nameSpace, string name, bool throwIfNotFound);
    public abstract virtual MetadataType GetGlobalModuleType();
    public abstract virtual IEnumerable`1<MetadataType> GetAllTypes();
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.NativeFormat.MetadataExtensions : object {
    private static TypeAttributes NestedMask;
    [ExtensionAttribute]
public static bool HasCustomAttribute(MetadataReader metadataReader, CustomAttributeHandleCollection customAttributes, string attributeNamespace, string attributeName);
    [ExtensionAttribute]
public static bool GetAttributeNamespaceAndName(MetadataReader metadataReader, CustomAttributeHandle attributeHandle, String& namespaceString, ConstantStringValueHandle& nameHandle);
    [ExtensionAttribute]
private static Handle GetAttributeTypeHandle(CustomAttribute customAttribute, MetadataReader reader);
    [ExtensionAttribute]
public static bool GetAttributeTypeAndConstructor(MetadataReader metadataReader, CustomAttributeHandle attributeHandle, Handle& attributeType, Handle& attributeCtor);
    [ExtensionAttribute]
public static bool GetAttributeTypeNamespaceAndName(MetadataReader metadataReader, Handle attributeType, String& namespaceString, ConstantStringValueHandle& nameHandle);
    [ExtensionAttribute]
internal static string GetNamespaceName(MetadataReader metadataReader, NamespaceDefinitionHandle namespaceDefinitionHandle);
    [ExtensionAttribute]
internal static string GetNamespaceName(MetadataReader metadataReader, NamespaceReferenceHandle namespaceReferenceHandle);
    private static bool IsNested(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsRuntimeSpecialName(MethodAttributes flags);
    [ExtensionAttribute]
public static bool IsPublic(MethodAttributes flags);
    [ExtensionAttribute]
public static int ToInt(Handle handle);
    [ExtensionAttribute]
public static int ToInt(MethodHandle handle);
    [ExtensionAttribute]
public static Byte[] ConvertByteCollectionToArray(ByteCollection collection);
}
internal abstract class Internal.TypeSystem.NoMetadata.NoMetadataMethodDesc : MethodDesc {
}
internal class Internal.TypeSystem.NoMetadata.NoMetadataType : DefType {
    private TypeSystemContext _context;
    private int _hashcode;
    private RuntimeTypeHandle _genericTypeDefinition;
    private DefType _genericTypeDefinitionAsDefType;
    private Instantiation _instantiation;
    private DefType _baseType;
    public TypeSystemContext Context { get; }
    public DefType BaseType { get; }
    public Instantiation Instantiation { get; }
    public TypeDesc UnderlyingType { get; }
    public string DiagnosticNamespace { get; }
    public string DiagnosticName { get; }
    public string DiagnosticModuleName { get; }
    public NoMetadataType(TypeSystemContext context, RuntimeTypeHandle genericTypeDefinition, DefType genericTypeDefinitionAsDefType, Instantiation instantiation, int hashcode);
    public virtual int GetHashCode();
    public virtual TypeSystemContext get_Context();
    public virtual DefType get_BaseType();
    internal virtual void ParseBaseType(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser baseTypeParser);
    public void SetBaseType(DefType baseType);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual TypeDesc GetTypeDefinition();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual Instantiation get_Instantiation();
    public virtual TypeDesc get_UnderlyingType();
    private void GetTypeNameHelper(String& name, String& nsName, String& assemblyName);
    public string get_DiagnosticNamespace();
    public string get_DiagnosticName();
    public string get_DiagnosticModuleName();
}
internal class Internal.TypeSystem.NoMetadata.RuntimeMethodDesc : NoMetadataMethodDesc {
    private Instantiation _instantiation;
    private TypeDesc _owningType;
    private MethodNameAndSignature _nameAndSignature;
    private bool _unboxingStub;
    public TypeSystemContext Context { get; }
    public Instantiation Instantiation { get; }
    public TypeDesc OwningType { get; }
    public MethodSignature Signature { get; }
    public MethodNameAndSignature NameAndSignature { get; }
    public string Name { get; }
    public bool UnboxingStub { get; }
    public RuntimeMethodDesc(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, int hashcode);
    public virtual bool IsCanonicalMethod(CanonicalFormKind policy);
    public virtual MethodDesc GetCanonMethodTarget(CanonicalFormKind kind);
    public virtual TypeSystemContext get_Context();
    public virtual Instantiation get_Instantiation();
    public virtual TypeDesc get_OwningType();
    public virtual MethodSignature get_Signature();
    public virtual MethodNameAndSignature get_NameAndSignature();
    public virtual string get_Name();
    public virtual bool get_UnboxingStub();
    public virtual MethodDesc GetTypicalMethodDefinition();
    public virtual MethodDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual bool HasCustomAttribute(string attributeNamespace, string attributeName);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.ParameterizedType : TypeDesc {
    private TypeDesc _parameterType;
    public TypeDesc ParameterType { get; }
    public TypeSystemContext Context { get; }
    internal ParameterizedType(TypeDesc parameterType);
    public sealed virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    public TypeDesc get_ParameterType();
    public virtual TypeSystemContext get_Context();
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.PointerType : ParameterizedType {
    internal PointerType(TypeDesc parameterType);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual int GetHashCode();
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.RuntimeInterfacesAlgorithm : object {
    public abstract virtual DefType[] ComputeRuntimeInterfaces(TypeDesc type);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.SignatureMethodVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    internal SignatureMethodVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.SignatureTypeVariable : SignatureVariable {
    public bool IsMethodSignatureVariable { get; }
    internal SignatureTypeVariable(TypeSystemContext context, int index);
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public virtual bool get_IsMethodSignatureVariable();
    public virtual int GetHashCode();
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.SignatureVariable : TypeDesc {
    private TypeSystemContext _context;
    private int _index;
    public int Index { get; }
    public TypeSystemContext Context { get; }
    public bool IsMethodSignatureVariable { get; }
    internal SignatureVariable(TypeSystemContext context, int index);
    public int get_Index();
    public virtual TypeSystemContext get_Context();
    public abstract virtual bool get_IsMethodSignatureVariable();
}
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.StandardCanonicalizationAlgorithm : object {
    public static Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    public static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    private static TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind& kind);
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.StaticLayoutKind : Enum {
    public int value__;
    public static StaticLayoutKind StaticRegionSizes;
    public static StaticLayoutKind StaticRegionSizesAndFields;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.StaticsBlock : ValueType {
    public LayoutInt Size;
    public LayoutInt LargestAlignment;
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.TargetAbi : Enum {
    public int value__;
    public static TargetAbi Unknown;
    public static TargetAbi CoreRT;
    public static TargetAbi ProjectN;
    public static TargetAbi Jit;
    public static TargetAbi CppCodegen;
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture Unknown;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARMEL;
    public static TargetArchitecture ARM64;
    public static TargetArchitecture X64;
    public static TargetArchitecture X86;
    public static TargetArchitecture Wasm32;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.TargetDetails : object {
    [CompilerGeneratedAttribute]
private TargetArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetOS <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetAbi <Abi>k__BackingField;
    public TargetArchitecture Architecture { get; }
    public TargetOS OperatingSystem { get; }
    public TargetAbi Abi { get; }
    public int PointerSize { get; }
    public bool SupportsRelativePointers { get; }
    public static int MaximumAlignment { get; }
    public LayoutInt LayoutPointerSize { get; }
    public int DefaultPackingSize { get; }
    public int MinimumFunctionAlignment { get; }
    public int MinimumCodeAlignment { get; }
    public bool IsWindows { get; }
    public int MaximumHfaElementCount { get; }
    public TargetDetails(TargetArchitecture architecture, TargetOS targetOS, TargetAbi abi);
    [CompilerGeneratedAttribute]
public TargetArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
public TargetOS get_OperatingSystem();
    [CompilerGeneratedAttribute]
public TargetAbi get_Abi();
    public int get_PointerSize();
    public bool get_SupportsRelativePointers();
    public static int get_MaximumAlignment();
    public LayoutInt get_LayoutPointerSize();
    public int get_DefaultPackingSize();
    public int get_MinimumFunctionAlignment();
    public int get_MinimumCodeAlignment();
    public LayoutInt GetWellKnownTypeSize(DefType type);
    public LayoutInt GetWellKnownTypeAlignment(DefType type);
    public LayoutInt GetObjectAlignment(LayoutInt fieldAlignment);
    public bool get_IsWindows();
    public int get_MaximumHfaElementCount();
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.TargetOS : Enum {
    public int value__;
    public static TargetOS Unknown;
    public static TargetOS Windows;
    public static TargetOS Linux;
    public static TargetOS OSX;
    public static TargetOS FreeBSD;
    public static TargetOS NetBSD;
    public static TargetOS WebAssembly;
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.ThreadSafeFlags : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _value;
    public int Value { get; }
    public int get_Value();
    public bool HasFlags(int value);
    public void AddFlags(int flagsToAdd);
}
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.ThrowHelper : object {
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string nestedTypeName, ModuleDesc module);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(string namespace, string name, ModuleDesc module);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(TypeDesc type);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, MethodDesc method);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type, string messageArg);
    [DebuggerHiddenAttribute]
public static void ThrowTypeLoadException(ExceptionStringID id, TypeDesc type);
    private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName, string messageArg);
    private static void ThrowTypeLoadException(ExceptionStringID id, string typeName, string assemblyName);
    public static void ThrowMissingMethodException(TypeDesc owningType, string methodName, MethodSignature signature);
    public static void ThrowMissingFieldException(TypeDesc owningType, string fieldName);
    public static void ThrowFileNotFoundException(ExceptionStringID id, string fileName);
    public static void ThrowInvalidProgramException();
    public static void ThrowInvalidProgramException(ExceptionStringID id, MethodDesc method);
    public static void ThrowBadImageFormatException();
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.TypeDesc : TypeSystemEntity {
    private TypeDesc _specificCanonCache;
    private TypeDesc _universalCanonCache;
    public static TypeDesc[] EmptyTypes;
    private TypeFlags _typeFlags;
    private DefType[] _runtimeInterfaces;
    private RuntimeTypeHandle _runtimeTypeHandle;
    private NativeLayoutFieldDesc[] _nativeLayoutFields;
    [CompilerGeneratedAttribute]
private TypeBuilderState <TypeBuilderState>k__BackingField;
    internal bool IsCanonicalType { get; }
    public Instantiation Instantiation { get; }
    public bool HasInstantiation { get; }
    public TypeFlags Category { get; }
    public bool IsInterface { get; }
    public bool IsValueType { get; }
    public bool IsPrimitive { get; }
    public bool IsEnum { get; }
    public bool IsDelegate { get; }
    public bool IsVoid { get; }
    public bool IsString { get; }
    public bool IsObject { get; }
    public bool IsNullable { get; }
    public bool IsByReferenceOfT { get; }
    public bool IsArray { get; }
    public bool IsSzArray { get; }
    public bool IsMdArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsFunctionPointer { get; }
    public bool IsSignatureVariable { get; }
    public bool IsGenericParameter { get; }
    public bool IsParameterizedType { get; }
    public bool IsDefType { get; }
    public bool IsGCPointer { get; }
    public DefType BaseType { get; }
    public bool HasBaseType { get; }
    public TypeDesc UnderlyingType { get; }
    public bool HasStaticConstructor { get; }
    public bool IsTypeDefinition { get; }
    public bool HasFinalizer { get; }
    public bool HasVariance { get; }
    public bool IsGenericDefinition { get; }
    public bool IsByRefLike { get; }
    public DefType[] RuntimeInterfaces { get; }
    public RuntimeTypeHandle RuntimeTypeHandle { get; }
    internal NativeLayoutFieldDesc[] NativeLayoutFields { get; internal set; }
    internal TypeBuilderState TypeBuilderState { get; internal set; }
    private static TypeDesc();
    private TypeDesc GetCachedCanonValue(CanonicalFormKind kind);
    private void SetCachedCanonValue(CanonicalFormKind kind, TypeDesc value);
    public TypeDesc ConvertToCanonForm(CanonicalFormKind kind);
    protected abstract virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    public abstract virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    internal bool get_IsCanonicalType();
    public abstract virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual Instantiation get_Instantiation();
    public bool get_HasInstantiation();
    internal void SetWellKnownType(WellKnownType wellKnownType);
    protected abstract virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    private TypeFlags InitializeTypeFlags(TypeFlags mask);
    protected internal TypeFlags GetTypeFlags(TypeFlags mask);
    public TypeFlags get_Category();
    public bool get_IsInterface();
    public bool get_IsValueType();
    public bool get_IsPrimitive();
    public bool get_IsEnum();
    public bool get_IsDelegate();
    public bool get_IsVoid();
    public bool get_IsString();
    public bool get_IsObject();
    public bool get_IsNullable();
    public bool get_IsByReferenceOfT();
    public bool get_IsArray();
    public bool get_IsSzArray();
    public bool get_IsMdArray();
    public bool get_IsByRef();
    public bool get_IsPointer();
    public bool get_IsFunctionPointer();
    public bool get_IsSignatureVariable();
    public bool get_IsGenericParameter();
    public bool get_IsParameterizedType();
    public bool get_IsDefType();
    public bool get_IsGCPointer();
    public virtual DefType get_BaseType();
    public bool get_HasBaseType();
    public virtual TypeDesc get_UnderlyingType();
    public bool get_HasStaticConstructor();
    public virtual IEnumerable`1<MethodDesc> GetMethods();
    public virtual MethodDesc GetMethod(string name, MethodSignature signature);
    public virtual MethodDesc GetStaticConstructor();
    public virtual MethodDesc GetDefaultConstructor();
    public virtual IEnumerable`1<FieldDesc> GetFields();
    public virtual FieldDesc GetField(string name);
    public virtual TypeDesc InstantiateSignature(Instantiation typeInstantiation, Instantiation methodInstantiation);
    public virtual TypeDesc GetTypeDefinition();
    public bool get_IsTypeDefinition();
    public bool HasSameTypeDefinition(TypeDesc otherType);
    public bool get_HasFinalizer();
    public virtual MethodDesc GetFinalizer();
    public bool get_HasVariance();
    public bool get_IsGenericDefinition();
    public bool get_IsByRefLike();
    public DefType[] get_RuntimeInterfaces();
    private DefType[] InitializeRuntimeInterfaces();
    public RuntimeTypeHandle get_RuntimeTypeHandle();
    public void SetRuntimeTypeHandleUnsafe(RuntimeTypeHandle runtimeTypeHandle);
    public RuntimeTypeHandle GetRuntimeTypeHandle();
    internal NativeLayoutFieldDesc[] get_NativeLayoutFields();
    internal void set_NativeLayoutFields(NativeLayoutFieldDesc[] value);
    [CompilerGeneratedAttribute]
internal TypeBuilderState get_TypeBuilderState();
    [CompilerGeneratedAttribute]
internal void set_TypeBuilderState(TypeBuilderState value);
    internal bool RetrieveRuntimeTypeHandleIfPossible();
    internal TypeBuilderState GetTypeBuilderStateIfExist();
    internal TypeBuilderState GetTypeBuilderState();
    internal TypeBuilderState GetOrCreateTypeBuilderState();
    internal virtual void ParseBaseType(NativeLayoutInfoLoadContext nativeLayoutInfoLoadContext, NativeParser baseTypeParser);
    internal TypeDesc ComputeTemplate(bool templateRequired);
    internal TypeDesc ComputeTemplate(TypeBuilderState state, bool templateRequired);
    internal bool IsTemplateUniversal();
    internal bool IsTemplateCanonical();
}
[FlagsAttribute]
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.TypeFlags : Enum {
    public int value__;
    public static TypeFlags CategoryMask;
    public static TypeFlags Unknown;
    public static TypeFlags Void;
    public static TypeFlags Boolean;
    public static TypeFlags Char;
    public static TypeFlags SByte;
    public static TypeFlags Byte;
    public static TypeFlags Int16;
    public static TypeFlags UInt16;
    public static TypeFlags Int32;
    public static TypeFlags UInt32;
    public static TypeFlags Int64;
    public static TypeFlags UInt64;
    public static TypeFlags IntPtr;
    public static TypeFlags UIntPtr;
    public static TypeFlags Single;
    public static TypeFlags Double;
    public static TypeFlags ValueType;
    public static TypeFlags Enum;
    public static TypeFlags Nullable;
    public static TypeFlags Class;
    public static TypeFlags Interface;
    public static TypeFlags Array;
    public static TypeFlags SzArray;
    public static TypeFlags ByRef;
    public static TypeFlags Pointer;
    public static TypeFlags FunctionPointer;
    public static TypeFlags GenericParameter;
    public static TypeFlags SignatureTypeVariable;
    public static TypeFlags SignatureMethodVariable;
    public static TypeFlags HasGenericVariance;
    public static TypeFlags HasGenericVarianceComputed;
    public static TypeFlags HasStaticConstructor;
    public static TypeFlags HasStaticConstructorComputed;
    public static TypeFlags HasFinalizerComputed;
    public static TypeFlags HasFinalizer;
    public static TypeFlags IsByRefLike;
    public static TypeFlags AttributeCacheComputed;
    public static TypeFlags IsIntrinsic;
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.TypeNameFormatter : object {
    public void AppendName(StringBuilder sb, TypeDesc type);
    public void AppendName(StringBuilder sb, DefType type);
    public abstract virtual void AppendName(StringBuilder sb, ArrayType type);
    public abstract virtual void AppendName(StringBuilder sb, ByRefType type);
    public abstract virtual void AppendName(StringBuilder sb, PointerType type);
    public abstract virtual void AppendName(StringBuilder sb, FunctionPointerType type);
    public abstract virtual void AppendName(StringBuilder sb, GenericParameterDesc type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureMethodVariable type);
    public abstract virtual void AppendName(StringBuilder sb, SignatureTypeVariable type);
    protected abstract virtual void AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType);
    protected abstract virtual void AppendNameForNamespaceType(StringBuilder sb, DefType type);
    protected abstract virtual void AppendNameForInstantiatedType(StringBuilder sb, DefType type);
    public string FormatName(TypeDesc type);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.TypeNameFormatter`2 : object {
    public TState AppendName(StringBuilder sb, TypeDesc type, TOptions options);
    public TState AppendName(StringBuilder sb, DefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ArrayType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, ByRefType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, PointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, FunctionPointerType type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, GenericParameterDesc type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureMethodVariable type, TOptions options);
    public abstract virtual TState AppendName(StringBuilder sb, SignatureTypeVariable type, TOptions options);
    protected abstract virtual TState AppendNameForNestedType(StringBuilder sb, DefType nestedType, DefType containingType, TOptions options);
    protected abstract virtual TState AppendNameForNamespaceType(StringBuilder sb, DefType type, TOptions options);
    protected abstract virtual TState AppendNameForInstantiatedType(StringBuilder sb, DefType type, TOptions options);
    public string FormatName(TypeDesc type, TOptions options);
}
[ExtensionAttribute]
internal static class Internal.TypeSystem.TypeNameHelper : object {
    [ExtensionAttribute]
public static T WithDebugName(T type);
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.TypeSystemContext : object {
    private CanonType _canonType;
    private UniversalCanonType _universalCanonType;
    [CompilerGeneratedAttribute]
private TargetDetails <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleDesc <SystemModule>k__BackingField;
    private ArrayTypeKeyHashtable _arrayTypes;
    private ByRefHashtable _byRefTypes;
    private PointerHashtable _pointerTypes;
    private FunctionPointerHashtable _functionPointerTypes;
    private InstantiatedTypeKeyHashtable _instantiatedTypes;
    private InstantiatedMethodKeyHashtable _instantiatedMethods;
    private MethodForInstantiatedTypeKeyHashtable _methodForInstantiatedTypes;
    private FieldForInstantiatedTypeKeyHashtable _fieldForInstantiatedTypes;
    private SignatureVariableHashtable _signatureVariables;
    [CompilerGeneratedAttribute]
private TemplateLocator <TemplateLookup>k__BackingField;
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable[] s_ArrayTypesCaches;
    [CompilerGeneratedAttribute]
private static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable <PointerTypesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable <ByRefTypesCache>k__BackingField;
    private LowLevelDictionary`2<RuntimeTypeHandle, TypeDesc> _runtimeTypeHandleResolutionCache;
    private RuntimeMethodKeyHashtable _runtimeMethods;
    private LowLevelDictionary`2<GenericTypeInstanceKey, DefType> _genericTypeInstances;
    private LowLevelList`1<TypeDesc> _typesToFlushTypeSystemStateFrom;
    private TypeDesc _canonAlikeType;
    private TypeDesc[] _canonAlikeTypeArray;
    private TypeDesc[] _canonTypeArray;
    public CanonBaseType CanonType { get; }
    public CanonBaseType UniversalCanonType { get; }
    protected internal ModuleDesc CanonTypesModule { get; }
    public bool SupportsCanon { get; }
    public bool SupportsUniversalCanon { get; }
    public TargetDetails Target { get; }
    public ModuleDesc SystemModule { get; private set; }
    internal TemplateLocator TemplateLookup { get; }
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable PointerTypesCache { get; }
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable ByRefTypesCache { get; }
    public int LoadFactor { get; }
    public TypeDesc CanonAlikeType { get; }
    public TypeDesc[] CanonAlikeTypeArray { get; }
    public TypeDesc[] CanonTypeArray { get; }
    public TypeSystemContext(TargetDetails target);
    private static TypeSystemContext();
    public CanonBaseType get_CanonType();
    public CanonBaseType get_UniversalCanonType();
    protected internal virtual ModuleDesc get_CanonTypesModule();
    public bool IsCanonicalDefinitionType(TypeDesc type, CanonicalFormKind kind);
    public Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind);
    protected internal virtual Instantiation ConvertInstantiationToCanonForm(Instantiation instantiation, CanonicalFormKind kind, Boolean& changed);
    protected internal virtual TypeDesc ConvertToCanon(TypeDesc typeToConvert, CanonicalFormKind kind);
    public abstract virtual bool get_SupportsCanon();
    public abstract virtual bool get_SupportsUniversalCanon();
    public MetadataType GetCanonType(string name);
    [CompilerGeneratedAttribute]
public TargetDetails get_Target();
    [CompilerGeneratedAttribute]
public ModuleDesc get_SystemModule();
    [CompilerGeneratedAttribute]
private void set_SystemModule(ModuleDesc value);
    protected void InitializeSystemModule(ModuleDesc systemModule);
    public abstract virtual DefType GetWellKnownType(WellKnownType wellKnownType, bool throwIfNotFound);
    public virtual ModuleDesc ResolveAssembly(AssemblyName name, bool throwIfNotFound);
    internal virtual ModuleDesc ResolveModule(ModuleDesc referencingModule, string fileName, bool throwIfNotFound);
    public ArrayType GetArrayType(TypeDesc elementType);
    public ArrayType GetArrayType(TypeDesc elementType, int rank);
    public ByRefType GetByRefType(TypeDesc parameterType);
    public PointerType GetPointerType(TypeDesc parameterType);
    public FunctionPointerType GetFunctionPointerType(MethodSignature signature);
    public InstantiatedType GetInstantiatedType(MetadataType typeDef, Instantiation instantiation);
    public InstantiatedMethod GetInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    public MethodDesc GetMethodForInstantiatedType(MethodDesc typicalMethodDef, InstantiatedType instantiatedType);
    public FieldDesc GetFieldForInstantiatedType(FieldDesc fieldDef, InstantiatedType instantiatedType);
    public TypeDesc GetSignatureVariable(int index, bool method);
    protected internal virtual IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    public virtual FieldLayoutAlgorithm GetLayoutAlgorithmForType(DefType type);
    public RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForType(TypeDesc type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForDefType(DefType type);
    protected virtual RuntimeInterfacesAlgorithm GetRuntimeInterfacesAlgorithmForNonPointerArrayType(ArrayType type);
    public virtual VirtualMethodAlgorithm GetVirtualMethodAlgorithmForType(TypeDesc type);
    protected internal virtual bool ComputeHasGCStaticBase(FieldDesc field);
    internal TypeFlags ComputeTypeFlags(TypeDesc type, TypeFlags flags, TypeFlags mask);
    protected internal abstract virtual bool ComputeHasStaticConstructor(TypeDesc type);
    [CompilerGeneratedAttribute]
internal TemplateLocator get_TemplateLookup();
    internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable GetArrayTypesCache(bool isMdArray, int rank);
    [CompilerGeneratedAttribute]
internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable get_PointerTypesCache();
    [CompilerGeneratedAttribute]
internal static RuntimeTypeHandleToParameterTypeRuntimeTypeHandleHashtable get_ByRefTypesCache();
    internal TypeDesc GetTypeFromCorElementType(CorElementType corElementType);
    public Instantiation ResolveRuntimeTypeHandles(RuntimeTypeHandle[] runtimeTypeHandles);
    private TypeDesc TryGetMetadataBasedTypeFromRuntimeTypeHandle_Uncached(RuntimeTypeHandle rtth);
    public TypeDesc ResolveRuntimeTypeHandle(RuntimeTypeHandle rtth);
    internal MethodDesc ResolveRuntimeMethod(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, IntPtr functionPointer, bool usgFunctionPointer);
    public DefType ResolveGenericInstantiation(DefType typeDef, Instantiation arguments);
    public MethodDesc ResolveGenericMethodInstantiation(bool unboxingStub, DefType owningType, MethodNameAndSignature nameAndSignature, Instantiation methodInstantiation, IntPtr functionPointer, bool usgFunctionPointer);
    public virtual int get_LoadFactor();
    internal void RegisterTypeForTypeSystemStateFlushing(TypeDesc type);
    internal void FlushTypeBuilderStates();
    public TypeDesc get_CanonAlikeType();
    public TypeDesc[] get_CanonAlikeTypeArray();
    public TypeDesc[] get_CanonTypeArray();
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.TypeSystemEntity : object {
    public TypeSystemContext Context { get; }
    public abstract virtual TypeSystemContext get_Context();
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class Internal.TypeSystem.TypeSystemHelpers : object {
    [ExtensionAttribute]
public static bool IsWellKnownType(TypeDesc type, WellKnownType wellKnownType);
    [ExtensionAttribute]
public static InstantiatedType MakeInstantiatedType(MetadataType typeDef, Instantiation instantiation);
    [ExtensionAttribute]
public static InstantiatedType MakeInstantiatedType(MetadataType typeDef, TypeDesc[] genericParameters);
    [ExtensionAttribute]
public static InstantiatedMethod MakeInstantiatedMethod(MethodDesc methodDef, Instantiation instantiation);
    [ExtensionAttribute]
public static InstantiatedMethod MakeInstantiatedMethod(MethodDesc methodDef, TypeDesc[] genericParameters);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeDesc type);
    [ExtensionAttribute]
public static ArrayType MakeArrayType(TypeDesc type, int rank);
    [ExtensionAttribute]
public static ByRefType MakeByRefType(TypeDesc type);
    [ExtensionAttribute]
public static PointerType MakePointerType(TypeDesc type);
    [ExtensionAttribute]
public static TypeDesc GetParameterType(TypeDesc type);
    [ExtensionAttribute]
public static LayoutInt GetElementSize(TypeDesc type);
    [ExtensionAttribute]
public static MethodDesc GetParameterlessConstructor(TypeDesc type);
    [ExtensionAttribute]
public static bool HasExplicitOrImplicitDefaultConstructor(TypeDesc type);
    [ExtensionAttribute]
internal static MethodDesc FindMethodOnExactTypeWithMatchingTypicalMethod(TypeDesc type, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc FindMethodOnTypeWithMatchingTypicalMethod(TypeDesc targetType, MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc TryResolveConstraintMethodApprox(TypeDesc constrainedType, TypeDesc interfaceType, MethodDesc interfaceMethod, Boolean& forceRuntimeLookup);
    [ExtensionAttribute]
public static string GetFullName(DefType metadataType);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> GetAllMethods(TypeDesc type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodDesc> EnumAllVirtualSlots(TypeDesc type);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(TypeDesc type, MethodDesc interfaceMethod);
    [ExtensionAttribute]
public static MethodDesc FindVirtualFunctionTargetMethodOnObjectType(TypeDesc type, MethodDesc targetMethod);
    [ExtensionAttribute]
public static TypeDesc InstantiateAsOpen(TypeDesc type);
    [ExtensionAttribute]
public static FieldDesc InstantiateAsOpen(FieldDesc field);
    [ExtensionAttribute]
public static MethodDesc InstantiateAsOpen(MethodDesc method);
    [ExtensionAttribute]
public static MethodDesc ResolveInterfaceMethodTarget(TypeDesc thisType, MethodDesc interfaceMethodToResolve);
}
[__BlockReflectionAttribute]
public class Internal.TypeSystem.UniversalCanonLayoutAlgorithm : FieldLayoutAlgorithm {
    public static UniversalCanonLayoutAlgorithm Instance;
    private static UniversalCanonLayoutAlgorithm();
    public virtual bool ComputeContainsGCPointers(DefType type);
    public virtual DefType ComputeHomogeneousFloatAggregateElementType(DefType type);
    public virtual ComputedInstanceFieldLayout ComputeInstanceLayout(DefType type, InstanceLayoutKind layoutKind);
    public virtual ComputedStaticFieldLayout ComputeStaticFieldLayout(DefType type, StaticLayoutKind layoutKind);
    public virtual ValueTypeShapeCharacteristics ComputeValueTypeShapeCharacteristics(DefType type);
}
internal class Internal.TypeSystem.UniversalCanonType : CanonBaseType {
    private static string _Namespace;
    private static string _Name;
    public static string FullName;
    private int _hashcode;
    public string Namespace { get; }
    public string Name { get; }
    public bool IsSealed { get; }
    public DefType BaseType { get; }
    public UniversalCanonType(TypeSystemContext context);
    public virtual string get_Namespace();
    public virtual string get_Name();
    public virtual bool get_IsSealed();
    private void Initialize();
    public virtual DefType get_BaseType();
    public virtual bool IsCanonicalSubtype(CanonicalFormKind policy);
    protected virtual TypeDesc ConvertToCanonFormImpl(CanonicalFormKind kind);
    protected virtual TypeFlags ComputeTypeFlags(TypeFlags mask);
    public virtual int GetHashCode();
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.ValueTypeShapeCharacteristics : Enum {
    public int value__;
    public static ValueTypeShapeCharacteristics None;
    public static ValueTypeShapeCharacteristics HomogenousFloatAggregate;
}
[__BlockReflectionAttribute]
public abstract class Internal.TypeSystem.VirtualMethodAlgorithm : object {
    public abstract virtual MethodDesc ResolveInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc ResolveVariantInterfaceMethodToVirtualMethodOnType(MethodDesc interfaceMethod, TypeDesc currentType);
    public abstract virtual MethodDesc FindVirtualFunctionTargetMethodOnObjectType(MethodDesc targetMethod, TypeDesc objectType);
    public abstract virtual IEnumerable`1<MethodDesc> ComputeAllVirtualSlots(TypeDesc type);
}
[__BlockReflectionAttribute]
public enum Internal.TypeSystem.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Unknown;
    public static WellKnownType Void;
    public static WellKnownType Boolean;
    public static WellKnownType Char;
    public static WellKnownType SByte;
    public static WellKnownType Byte;
    public static WellKnownType Int16;
    public static WellKnownType UInt16;
    public static WellKnownType Int32;
    public static WellKnownType UInt32;
    public static WellKnownType Int64;
    public static WellKnownType UInt64;
    public static WellKnownType IntPtr;
    public static WellKnownType UIntPtr;
    public static WellKnownType Single;
    public static WellKnownType Double;
    public static WellKnownType ValueType;
    public static WellKnownType Enum;
    public static WellKnownType Nullable;
    public static WellKnownType Object;
    public static WellKnownType String;
    public static WellKnownType Array;
    public static WellKnownType MulticastDelegate;
    public static WellKnownType RuntimeTypeHandle;
    public static WellKnownType RuntimeMethodHandle;
    public static WellKnownType RuntimeFieldHandle;
    public static WellKnownType Exception;
    public static WellKnownType TypedReference;
    public static WellKnownType ByReferenceOfT;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _items;
    private int _count;
    public int Count { get; }
    public T Item { get; public set; }
    public T[] ToArray();
    public void Add(T item);
    public void Append(T[] newItems);
    public void Append(T[] newItems, int offset, int length);
    public void Append(ArrayBuilder`1<T> newItems);
    public void ZeroExtend(int numItems);
    public void EnsureCapacity(int requestedCapacity);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public bool Contains(T t);
}
[ForceDictionaryLookupsAttribute]
internal static class System.Collections.Generic.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
[DefaultMemberAttribute("Item")]
[ForceDictionaryLookupsAttribute]
internal class System.Collections.Generic.LowLevelDictionary`2 : object {
    private static int DefaultSize;
    private Entry[] _buckets;
    private int _numEntries;
    private int _version;
    public int Count { get; }
    public TValue Item { get; public set; }
    public LowLevelDictionary`2(int capacity);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void Clear(int capacity);
    public bool Remove(TKey key);
    internal TValue LookupOrAdd(TKey key, TValue value);
    private Entry<TKey, TValue> Find(TKey key);
    private Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
    private void ExpandBuckets();
    private int GetBucket(TKey key, int numBuckets);
}
internal class System.Collections.Generic.LowLevelDictionaryWithIEnumerable`2 : LowLevelDictionary`2<TKey, TValue> {
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ForceDictionaryLookupsAttribute]
internal class System.Collections.Generic.LowLevelList`1 : object {
    private static int _defaultCapacity;
    protected T[] _items;
    protected int _size;
    protected int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public LowLevelList`1(int capacity);
    public LowLevelList`1(IEnumerable`1<T> collection);
    private static LowLevelList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    private void EnsureCapacity(int min);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
[ExtensionAttribute]
[__BlockReflectionAttribute]
public static class System.Reflection.Runtime.General.MetadataReaderExtensions : object {
    [ExtensionAttribute]
public static Handle AsHandle(int token);
    [ExtensionAttribute]
public static Handle AsHandle(UInt32 token);
    [ExtensionAttribute]
public static int AsInt(Handle handle);
    [ExtensionAttribute]
public static UInt32 AsUInt(Handle handle);
    [ExtensionAttribute]
public static string GetString(ConstantStringValueHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetStringOrNull(ConstantStringValueHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsTypeDefRefOrSpecHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool IsTypeDefRefSpecOrModifiedTypeHandle(Handle handle, MetadataReader reader);
    [ExtensionAttribute]
public static RuntimeAssemblyName ToRuntimeAssemblyName(ScopeDefinitionHandle scopeDefinitionHandle, MetadataReader reader);
    [ExtensionAttribute]
public static RuntimeAssemblyName ToRuntimeAssemblyName(ScopeReferenceHandle scopeReferenceHandle, MetadataReader reader);
    private static RuntimeAssemblyName CreateRuntimeAssemblyNameFromMetadata(MetadataReader reader, ConstantStringValueHandle name, ushort majorVersion, ushort minorVersion, ushort buildNumber, ushort revisionNumber, ConstantStringValueHandle culture, ByteCollection publicKeyOrToken, AssemblyFlags assemblyFlags);
}
[__BlockReflectionAttribute]
public class System.Reflection.Runtime.General.QGenericParameter : ValueType {
    private MetadataReader _reader;
    private GenericParameterHandle _handle;
    public MetadataReader Reader { get; }
    public GenericParameterHandle Handle { get; }
    public QGenericParameter(MetadataReader reader, GenericParameterHandle handle);
    public MetadataReader get_Reader();
    public GenericParameterHandle get_Handle();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(QGenericParameter other);
    public virtual int GetHashCode();
}
[__BlockReflectionAttribute]
public class System.Reflection.Runtime.General.QHandle : ValueType {
    private MetadataReader _reader;
    private Handle _handle;
    public MetadataReader Reader { get; }
    public Handle Handle { get; }
    public QHandle(MetadataReader reader, Handle handle);
    public MetadataReader get_Reader();
    public Handle get_Handle();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(QHandle other);
    public virtual int GetHashCode();
}
[__BlockReflectionAttribute]
public class System.Reflection.Runtime.General.QMethodDefinition : ValueType {
    public static QMethodDefinition Null;
    private object _reader;
    private int _handle;
    public object Reader { get; }
    public int Token { get; }
    public bool IsValid { get; }
    public MetadataReader NativeFormatReader { get; }
    public MethodHandle NativeFormatHandle { get; }
    public bool IsNativeFormatMetadataBased { get; }
    private QMethodDefinition(object reader, int token);
    public QMethodDefinition(MetadataReader reader, MethodHandle handle);
    private static QMethodDefinition();
    public static QMethodDefinition FromObjectAndInt(object reader, int token);
    public object get_Reader();
    public int get_Token();
    public bool get_IsValid();
    public MetadataReader get_NativeFormatReader();
    public MethodHandle get_NativeFormatHandle();
    public bool get_IsNativeFormatMetadataBased();
}
[__BlockReflectionAttribute]
public class System.Reflection.Runtime.General.QTypeDefinition : ValueType {
    public static QTypeDefinition Null;
    private object _reader;
    private int _handle;
    public object Reader { get; }
    public int Token { get; }
    public bool IsValid { get; }
    public MetadataReader NativeFormatReader { get; }
    public TypeDefinitionHandle NativeFormatHandle { get; }
    public bool IsNativeFormatMetadataBased { get; }
    public QTypeDefinition(MetadataReader reader, TypeDefinitionHandle handle);
    private static QTypeDefinition();
    public object get_Reader();
    public int get_Token();
    public bool get_IsValid();
    public MetadataReader get_NativeFormatReader();
    public TypeDefinitionHandle get_NativeFormatHandle();
    public bool get_IsNativeFormatMetadataBased();
}
[__BlockReflectionAttribute]
public class System.Reflection.Runtime.General.QTypeDefRefOrSpec : ValueType {
    public static QTypeDefRefOrSpec Null;
    private object _reader;
    private int _handle;
    public object Reader { get; }
    public int Handle { get; }
    public bool IsValid { get; }
    public bool IsNativeFormatMetadataBased { get; }
    public QTypeDefRefOrSpec(MetadataReader reader, Handle handle, bool skipCheck);
    private static QTypeDefRefOrSpec();
    public object get_Reader();
    public int get_Handle();
    public bool get_IsValid();
    public bool get_IsNativeFormatMetadataBased();
}
internal class System.Runtime.CompilerServices.__BlockReflectionActivateAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.__BlockReflectionInvokeAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[AttributeUsageAttribute("68")]
internal class System.Runtime.InteropServices.McgIntrinsicsAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string FileNotFound_AssemblyNotFound { get; }
    internal static string FileLoadException_RefDefMismatch { get; }
    internal static Type ResourceType { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_FileNotFound_AssemblyNotFound();
    internal static string get_FileLoadException_RefDefMismatch();
    internal static Type get_ResourceType();
}
[ExtensionAttribute]
internal static class System.TypeLoaderFormattingHelpers : object {
    [ExtensionAttribute]
public static string ToStringInvariant(int arg);
    [ExtensionAttribute]
public static string ToStringInvariant(UInt32 arg);
    [ExtensionAttribute]
public static string ToStringInvariant(byte arg);
    [ExtensionAttribute]
public static string ToStringInvariant(ushort arg);
    [ExtensionAttribute]
public static string ToStringInvariant(ulong arg);
    [ExtensionAttribute]
public static string ToStringInvariant(float arg);
    [ExtensionAttribute]
public static string ToStringInvariant(double arg);
}
