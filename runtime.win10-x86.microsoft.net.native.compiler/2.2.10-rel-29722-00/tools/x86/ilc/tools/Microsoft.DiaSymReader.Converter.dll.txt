[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
internal class Microsoft.CodeAnalysis.Collections.ByteSequenceComparer : object {
    internal static ByteSequenceComparer Instance;
    private static ByteSequenceComparer();
    internal static bool Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    internal static bool Equals(Byte[] left, int leftStart, Byte[] right, int rightStart, int length);
    internal static bool Equals(Byte[] left, Byte[] right);
    internal static int GetHashCode(Byte[] x);
    internal static int GetHashCode(ImmutableArray`1<byte> x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Byte[]>.Equals(Byte[] x, Byte[] y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Byte[]>.GetHashCode(Byte[] x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.GetHashCode(ImmutableArray`1<byte> x);
}
internal class Microsoft.CodeAnalysis.Collections.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool();
    public static PooledDictionary`2<K, V> GetInstance();
}
internal class Microsoft.CodeAnalysis.Collections.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool);
    private static PooledHashSet`1();
    public void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool();
    public static PooledHashSet`1<T> GetInstance();
}
internal class Microsoft.CodeAnalysis.Collections.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
internal class Microsoft.CodeAnalysis.Collections.SequenceComparer`1 : object {
    internal static SequenceComparer`1<T> Instance;
    private IEqualityComparer`1<T> _elementComparer;
    private SequenceComparer`1(IEqualityComparer`1<T> elementComparer);
    private static SequenceComparer`1();
    internal static bool Equals(ImmutableArray`1<T> x, ImmutableArray`1<T> y, IEqualityComparer`1<T> elementComparer);
    internal static bool Equals(T[] left, int leftStart, T[] right, int rightStart, int length, IEqualityComparer`1<T> elementComparer);
    internal static bool Equals(T[] left, T[] right, IEqualityComparer`1<T> elementComparer);
    public sealed virtual bool Equals(T[] x, T[] y);
    public sealed virtual bool Equals(ImmutableArray`1<T> x, ImmutableArray`1<T> y);
    public sealed virtual int GetHashCode(T[] x);
    public sealed virtual int GetHashCode(ImmutableArray`1<T> x);
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants : object {
    internal static byte Version;
    internal static int GlobalHeaderSize;
    internal static int RecordHeaderSize;
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    private Blob _recordCountFixup;
    private int _recordCount;
    internal static int DynamicAttributeSize;
    internal static int IdentifierSize;
    public BlobBuilder Builder { get; }
    public int RecordCount { get; }
    public CustomDebugInfoEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public int get_RecordCount();
    public Byte[] ToArray();
    public void AddStateMachineTypeName(string typeName);
    public void AddForwardMethodInfo(MethodDefinitionHandle methodHandle);
    public void AddForwardModuleInfo(MethodDefinitionHandle methodHandle);
    public void AddUsingGroups(IReadOnlyCollection`1<int> groupSizes);
    public void AddStateMachineHoistedLocalScopes(ImmutableArray`1<StateMachineHoistedLocalScope> scopes);
    public void AddDynamicLocals(IReadOnlyCollection`1<ValueTuple`4<string, Byte[], int, int>> dynamicLocals);
    public void AddTupleElementNames(IReadOnlyCollection`1<ValueTuple`5<string, int, int, int, ImmutableArray`1<string>>> tupleLocals);
    public void AddRecord(CustomDebugInfoKind kind, T debugInfo, Action`2<T, BlobBuilder> recordSerializer);
}
internal enum Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind : Enum {
    public byte value__;
    public static CustomDebugInfoKind UsingGroups;
    public static CustomDebugInfoKind ForwardMethodInfo;
    public static CustomDebugInfoKind ForwardModuleInfo;
    public static CustomDebugInfoKind StateMachineHoistedLocalScopes;
    public static CustomDebugInfoKind StateMachineTypeName;
    public static CustomDebugInfoKind DynamicLocals;
    public static CustomDebugInfoKind EditAndContinueLocalSlotMap;
    public static CustomDebugInfoKind EditAndContinueLambdaMap;
    public static CustomDebugInfoKind TupleElementNames;
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader : object {
    private static void ReadGlobalHeader(Byte[] bytes, Int32& offset, Byte& version, Byte& count);
    private static void ReadRecordHeader(Byte[] bytes, Int32& offset, Byte& version, CustomDebugInfoKind& kind, Int32& size, Int32& alignmentSize);
    public static ImmutableArray`1<byte> TryGetCustomDebugInfoRecord(Byte[] customDebugInfo, CustomDebugInfoKind recordKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader/<GetCustomDebugInfoRecords>d__3")]
public static IEnumerable`1<CustomDebugInfoRecord> GetCustomDebugInfoRecords(Byte[] customDebugInfo);
    public static ImmutableArray`1<short> DecodeUsingRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardToModuleRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<StateMachineHoistedLocalScope> DecodeStateMachineHoistedLocalScopesRecord(ImmutableArray`1<byte> bytes);
    public static string DecodeForwardIteratorRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<DynamicLocalInfo> DecodeDynamicLocalsRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<TupleElementNamesInfo> DecodeTupleElementNamesRecord(ImmutableArray`1<byte> bytes);
    private static TupleElementNamesInfo DecodeTupleElementNamesInfo(ImmutableArray`1<byte> bytes, Int32& offset);
    private static void ReadRawRecordBody(Byte[] bytes, Int32& offset, int size, ImmutableArray`1& body);
    private static void SkipRecord(Byte[] bytes, Int32& offset, int size);
    public static ImmutableArray`1<ImmutableArray`1<string>> GetCSharpGroupedImportStrings(int methodToken, TArg arg, Func`3<int, TArg, Byte[]> getMethodCustomDebugInfo, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings, ImmutableArray`1& externAliasStrings);
    public static ImmutableArray`1<string> GetVisualBasicImportStrings(int methodToken, TArg arg, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings);
    private static void CheckVersion(byte globalVersion, int methodToken);
    private static int ReadInt32(ImmutableArray`1<byte> bytes, Int32& offset);
    private static short ReadInt16(ImmutableArray`1<byte> bytes, Int32& offset);
    private static byte ReadByte(ImmutableArray`1<byte> bytes, Int32& offset);
    private static bool IsCSharpExternAliasInfo(string import);
    public static bool TryParseCSharpImportString(string import, String& alias, String& externAlias, String& target, ImportTargetKind& kind);
    public static bool TryParseVisualBasicImportString(string import, String& alias, String& target, ImportTargetKind& kind, VBImportScopeKind& scope);
    private static bool TrySplit(string input, int offset, char separator, String& before, String& after);
    private static string FormatMethodToken(int methodToken);
    private static string ReadUtf8String(ImmutableArray`1<byte> bytes, Int32& offset);
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoRecord : ValueType {
    public CustomDebugInfoKind Kind;
    public byte Version;
    public ImmutableArray`1<byte> Data;
    public CustomDebugInfoRecord(CustomDebugInfoKind kind, byte version, ImmutableArray`1<byte> data);
}
internal class Microsoft.CodeAnalysis.Debugging.DynamicLocalInfo : ValueType {
    public ImmutableArray`1<bool> Flags;
    public int SlotId;
    public string LocalName;
    public DynamicLocalInfo(ImmutableArray`1<bool> flags, int slotId, string localName);
}
internal enum Microsoft.CodeAnalysis.Debugging.ImportTargetKind : Enum {
    public int value__;
    public static ImportTargetKind Namespace;
    public static ImportTargetKind Type;
    public static ImportTargetKind NamespaceOrType;
    public static ImportTargetKind Assembly;
    public static ImportTargetKind XmlNamespace;
    public static ImportTargetKind MethodToken;
    public static ImportTargetKind CurrentNamespace;
    public static ImportTargetKind DefaultNamespace;
    public static ImportTargetKind Defunct;
}
internal static class Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds : object {
    public static Guid AsyncMethodSteppingInformationBlob;
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid TupleElementNames;
    public static Guid DefaultNamespace;
    public static Guid EncLocalSlotMap;
    public static Guid EncLambdaAndClosureMap;
    public static Guid SourceLink;
    public static Guid EmbeddedSource;
    private static PortableCustomDebugInfoKinds();
}
internal class Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    public int Length { get; }
    public bool IsDefault { get; }
    public StateMachineHoistedLocalScope(int startOffset, int endOffset);
    public int get_Length();
    public bool get_IsDefault();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StateMachineHoistedLocalScope other);
    public virtual int GetHashCode();
    public static bool op_Equality(StateMachineHoistedLocalScope scope1, StateMachineHoistedLocalScope scope2);
    public static bool op_Inequality(StateMachineHoistedLocalScope scope1, StateMachineHoistedLocalScope scope2);
}
internal class Microsoft.CodeAnalysis.Debugging.TupleElementNamesInfo : ValueType {
    internal ImmutableArray`1<string> ElementNames;
    internal int SlotIndex;
    internal string LocalName;
    internal int ScopeStart;
    internal int ScopeEnd;
    internal TupleElementNamesInfo(ImmutableArray`1<string> elementNames, int slotIndex, string localName, int scopeStart, int scopeEnd);
}
internal enum Microsoft.CodeAnalysis.Debugging.VBImportScopeKind : Enum {
    public int value__;
    public static VBImportScopeKind Unspecified;
    public static VBImportScopeKind File;
    public static VBImportScopeKind Project;
}
internal class Microsoft.DiaSymReader.AsyncMethodData : object {
    public static AsyncMethodData None;
    public MethodDefinitionHandle KickoffMethod;
    public int CatchHandlerOffset;
    public ImmutableArray`1<int> YieldOffsets;
    public ImmutableArray`1<int> ResumeOffsets;
    public ImmutableArray`1<int> ResumeMethods;
    public bool IsNone { get; }
    public AsyncMethodData(MethodDefinitionHandle kickoffMethod, int catchHandlerOffset, ImmutableArray`1<int> yieldOffsets, ImmutableArray`1<int> resumeOffsets, ImmutableArray`1<int> resumeMethods);
    private static AsyncMethodData();
    public bool get_IsNone();
}
internal class Microsoft.DiaSymReader.PortablePdb.BlobWriter : ValueType {
    private Byte[] _buffer;
    private int _position;
    public BlobWriter(int initialCapacity);
    private void EnsureCapacity(int size);
    public void Write(byte value);
    public void Write(byte b1, byte b2);
    public void Write(byte b1, byte b2, byte b3, byte b4);
    internal void Write(Byte[] buffer);
    internal void Write(Byte[] buffer, int index, int length);
    public void WriteCompressedInteger(int value);
    public Byte[] ToArray();
}
[ExtensionAttribute]
internal static class Microsoft.DiaSymReader.PortablePdb.MetadataUtilities : object {
    public static int MaxCompressedIntegerValue;
    public static SignatureTypeCode SignatureTypeCode_ValueType;
    public static SignatureTypeCode SignatureTypeCode_Class;
    public static Guid MethodSteppingInformationBlobId;
    public static Guid VbDefaultNamespaceId;
    public static Guid EmbeddedSourceId;
    public static Guid SourceLinkId;
    private static MetadataUtilities();
    public static int MethodDefToken(int rowId);
    public static int GetRowId(int token);
    public static bool IsMethodToken(int token);
    internal static int GetTypeDefOrRefOrSpecCodedIndex(EntityHandle typeHandle);
    [ExtensionAttribute]
public static string GetQualifiedTypeName(MetadataReader reader, EntityHandle typeDefOrRef);
    [ExtensionAttribute]
internal static BlobHandle GetCustomDebugInformation(MetadataReader reader, EntityHandle parent, Guid kind);
    internal static string GetVisualBasicDefaultNamespace(MetadataReader reader);
    [ExtensionAttribute]
internal static string GetStringUTF8(MetadataReader reader, BlobHandle handle);
    public static ImmutableArray`1<StateMachineHoistedLocalScope> DecodeHoistedLocalScopes(BlobReader reader);
    public static ImmutableArray`1<bool> ReadDynamicCustomDebugInformation(MetadataReader reader, EntityHandle variableOrConstantHandle);
    private static ImmutableArray`1<bool> DecodeDynamicFlags(BlobReader reader);
    public static ImmutableArray`1<string> ReadTupleCustomDebugInformation(MetadataReader reader, EntityHandle variableOrConstantHandle);
    private static ImmutableArray`1<string> DecodeTupleElementNames(BlobReader reader);
    public static AsyncMethodData ReadAsyncMethodData(MetadataReader metadataReader, MethodDebugInformationHandle debugHandle);
    internal static void SerializeBitVector(BlobBuilder builder, ImmutableArray`1<bool> flags);
    internal static void SerializeTupleElementNames(BlobBuilder builder, ImmutableArray`1<string> names);
}
internal static class Microsoft.DiaSymReader.PortablePdb.PortableConstantSignature : object {
    private static object s_nullReferenceValue;
    private static PortableConstantSignature();
    public static ValueTuple`2<object, Byte[]> GetConstantValueAndSignature(MetadataReader mdReader, LocalConstantHandle handle, Func`2<EntityHandle, string> getQualifiedTypeName);
    private static object ReadAndTranslateValue(BlobReader& sigReader, SignatureTypeCode typeCode, Boolean& isEnumTypeCode);
}
internal static class Microsoft.DiaSymReader.Tools.ConverterResources : object {
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager ResourceManager { get; }
    internal static string InvalidPdbFormat { get; }
    internal static string InvalidUserEntryPointInSourcePdb { get; }
    internal static string MetadataNotAvailable { get; }
    internal static string SpecifiedPEBuiltWithPortablePdb { get; }
    internal static string SpecifiedPEFileHasNoAssociatedPdb { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeSeakable { get; }
    internal static string StreamMustBeWritable { get; }
    internal static string MethodAssociatedWithLocalScopeHasNoBody { get; }
    internal static string MethodContainingLocalVariablesHasNoLocalSignature { get; }
    internal static string LocalConstantNameTooLong { get; }
    internal static string LocalVariableNameTooLong { get; }
    internal static string ImportStringTooLong { get; }
    internal static string LocalScopeRangesNestingIsInvalid { get; }
    internal static string UnsupportedImportType { get; }
    internal static string UndefinedAssemblyReferenceAlias { get; }
    internal static string UnknownImportDefinitionKind { get; }
    internal static string DiagnosticLocation { get; }
    internal static string ForwardedToUndefinedMethod { get; }
    internal static string ForwardedToMethodWithNoScope { get; }
    internal static string BothForwardMethodInfoAndImportsSpecified { get; }
    internal static string InvalidStateMachineTypeName { get; }
    internal static string BothStateMachineTypeNameAndImportsSpecified { get; }
    internal static string DuplicateDynamicLocals { get; }
    internal static string DuplicateTupleElementNamesForSlot { get; }
    internal static string DuplicateTupleElementNamesForConstant { get; }
    internal static string InvalidImportStringFormat { get; }
    internal static string InvalidEntryPointToken { get; }
    internal static string InvalidScopeILOffsetRange { get; }
    internal static string InvalidLocalVariableData { get; }
    internal static string InvalidLocalConstantData { get; }
    internal static string InvalidLocalConstantSignature { get; }
    internal static string InvalidLocalScope { get; }
    internal static string InvalidSequencePointDocument { get; }
    internal static string UnmappedDocumentName { get; }
    internal static string UriSchemeIsNotHttp { get; }
    internal static string NoSupportedUrisFoundInSourceLink { get; }
    internal static string PdbNotMatchingDebugDirectory { get; }
    internal static string InvalidSourceLinkData { get; }
    internal static string InvalidSourceLink { get; }
    internal static string InvalidSourceServerData { get; }
    internal static string BothSourceLinkDataAndSourceServerData { get; }
    internal static string InvalidEmbeddedSource { get; }
    internal static string InconsistentStateMachineMethodMapping { get; }
    internal static string InvalidJsonDataFormat { get; }
    private static ConverterResources();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_ResourceManager();
    internal static string get_InvalidPdbFormat();
    internal static string get_InvalidUserEntryPointInSourcePdb();
    internal static string get_MetadataNotAvailable();
    internal static string get_SpecifiedPEBuiltWithPortablePdb();
    internal static string get_SpecifiedPEFileHasNoAssociatedPdb();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeSeakable();
    internal static string get_StreamMustBeWritable();
    internal static string get_MethodAssociatedWithLocalScopeHasNoBody();
    internal static string get_MethodContainingLocalVariablesHasNoLocalSignature();
    internal static string get_LocalConstantNameTooLong();
    internal static string get_LocalVariableNameTooLong();
    internal static string get_ImportStringTooLong();
    internal static string get_LocalScopeRangesNestingIsInvalid();
    internal static string get_UnsupportedImportType();
    internal static string get_UndefinedAssemblyReferenceAlias();
    internal static string get_UnknownImportDefinitionKind();
    internal static string get_DiagnosticLocation();
    internal static string get_ForwardedToUndefinedMethod();
    internal static string get_ForwardedToMethodWithNoScope();
    internal static string get_BothForwardMethodInfoAndImportsSpecified();
    internal static string get_InvalidStateMachineTypeName();
    internal static string get_BothStateMachineTypeNameAndImportsSpecified();
    internal static string get_DuplicateDynamicLocals();
    internal static string get_DuplicateTupleElementNamesForSlot();
    internal static string get_DuplicateTupleElementNamesForConstant();
    internal static string get_InvalidImportStringFormat();
    internal static string get_InvalidEntryPointToken();
    internal static string get_InvalidScopeILOffsetRange();
    internal static string get_InvalidLocalVariableData();
    internal static string get_InvalidLocalConstantData();
    internal static string get_InvalidLocalConstantSignature();
    internal static string get_InvalidLocalScope();
    internal static string get_InvalidSequencePointDocument();
    internal static string get_UnmappedDocumentName();
    internal static string get_UriSchemeIsNotHttp();
    internal static string get_NoSupportedUrisFoundInSourceLink();
    internal static string get_PdbNotMatchingDebugDirectory();
    internal static string get_InvalidSourceLinkData();
    internal static string get_InvalidSourceLink();
    internal static string get_InvalidSourceServerData();
    internal static string get_BothSourceLinkDataAndSourceServerData();
    internal static string get_InvalidEmbeddedSource();
    internal static string get_InconsistentStateMachineMethodMapping();
    internal static string get_InvalidJsonDataFormat();
}
internal class Microsoft.DiaSymReader.Tools.DummySymReaderMetadataProvider : object {
    public static ISymReaderMetadataProvider Instance;
    private static DummySymReaderMetadataProvider();
    public sealed virtual bool TryGetStandaloneSignature(int standaloneSignatureToken, Byte*& signature, Int32& length);
    public sealed virtual bool TryGetTypeDefinitionInfo(int typeDefinitionToken, String& namespaceName, String& typeName, TypeAttributes& attributes);
    public sealed virtual bool TryGetTypeReferenceInfo(int typeReferenceToken, String& namespaceName, String& typeName);
}
[ExtensionAttribute]
internal static class Microsoft.DiaSymReader.Tools.EnumerableUtilities : object {
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, Func`2<T, bool> selector);
    [ExtensionAttribute]
public static ValueTuple`2<T, int> FirstOrDefaultWithIndex(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.DiaSymReader.Tools.EnumerableUtilities/<SelectWithIndex>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<T, int>> SelectWithIndex(IEnumerable`1<T> sequence);
}
internal static class Microsoft.DiaSymReader.Tools.HResult : object {
    internal static int S_OK;
    internal static int S_FALSE;
    internal static int E_NOTIMPL;
    internal static int E_FAIL;
    internal static int E_INVALIDARG;
    internal static int E_UNEXPECTED;
}
internal class Microsoft.DiaSymReader.Tools.MetadataModel : object {
    [CompilerGeneratedAttribute]
private MetadataReader <Reader>k__BackingField;
    private Lazy`1<Dictionary`2<Byte[], StandaloneSignatureHandle>> _lazyStandaloneSignatureMap;
    private Lazy`1<ImmutableArray`1<string>> _lazyAssemblyRefDisplayNames;
    private Lazy`1<IReadOnlyDictionary`2<string, AssemblyReferenceHandle>> _lazyAssemblyRefDisplayNameMap;
    private SerializedTypeNameSignatureDecoder _serializedTypeNameDecoder;
    private Lazy`1<AssemblyReferenceHandle> _lazyCorlibAssemblyRef;
    private Lazy`1<IReadOnlyDictionary`2<Byte[], TypeSpecificationHandle>> _lazyTypeSpecificationMap;
    private Lazy`1<IReadOnlyDictionary`2<string, EntityHandle>> _lazySerializedTypeNameMap;
    private static ValueTuple`2[] s_corTypes;
    public MetadataReader Reader { get; }
    public MetadataModel(MetadataReader reader, bool vbSemantics);
    private static MetadataModel();
    [CompilerGeneratedAttribute]
public MetadataReader get_Reader();
    public ImmutableArray`1<int> GetRowCounts();
    private AssemblyReferenceHandle FindCorlibAssemblyRef();
    private ImmutableArray`1<string> BuildAssemblyRefDisplayNames();
    private IReadOnlyDictionary`2<string, AssemblyReferenceHandle> BuildAssemblyRefDisplayNameMap();
    private string GetDisplayName(AssemblyReferenceHandle handle);
    public bool TryResolveAssemblyReference(string displayName, AssemblyReferenceHandle& handle);
    private Dictionary`2<Byte[], StandaloneSignatureHandle> BuildStandaloneSignatureMap();
    public bool TryGetStandaloneSignatureHandle(Byte[] signature, StandaloneSignatureHandle& handle);
    private IReadOnlyDictionary`2<Byte[], TypeSpecificationHandle> BuildTypeSpecificationMap();
    public bool TryResolveTypeSpecification(Byte[] spec, TypeSpecificationHandle& typeSpec);
    public string GetSerializedTypeName(EntityHandle typeHandle);
    internal static void BuildQualifiedName(StringBuilder builder, MetadataReader reader, TypeDefinitionHandle typeHandle, char nestedNameSeparator);
    internal static void BuildQualifiedName(StringBuilder builder, MetadataReader reader, TypeReferenceHandle typeHandle, char nestedNameSeparator, AssemblyReferenceHandle& assemblyRefHandle);
    private static void BuildQualifiedName(StringBuilder builder, MetadataReader reader, StringHandle namespaceHandle, StringHandle nameHandle, IReadOnlyList`1<StringHandle> nestedNames, char nestedNameSeparator);
    private static void BuildQualifiedName(StringBuilder builder, MetadataReader reader, StringHandle namespaceHandle, StringHandle nameHandle);
    private static void BuildName(StringBuilder builder, MetadataReader reader, StringHandle nameHandle);
    private static string GetPrimitiveTypeQualifiedName(PrimitiveTypeCode typeCode);
    private IReadOnlyDictionary`2<string, EntityHandle> BuildSerializedTypeNameMap();
    internal bool TryResolveType(string serializedTypeName, EntityHandle& type);
    public MethodDefinitionHandle FindStateMachineMoveNextMethod(MethodDefinitionHandle methodHandle, bool vbSemantics);
    public MethodDefinitionHandle FindStateMachineMoveNextMethod(MethodDefinition kickoffMethodDef, string stateMachineTypeName, bool isGenericSuffixIncluded);
    private TypeDefinitionHandle FindNestedStateMachineTypeByNamePattern(MethodDefinition kickoffMethodDef, bool vbSemantics);
    private TypeDefinitionHandle FindNestedTypeByName(TypeDefinition typeDef, string name);
    private MethodDefinitionHandle FindMethodByName(TypeDefinition typeDef, string name);
    private TypeDefinitionHandle FindSingleNestedTypeByNamePrefixAndSuffix(TypeDefinition typeDef, string prefix, string suffix);
    private bool TryGetDeclaringTypeQualifiedName(EntityHandle attributeConstructorHandle, StringHandle& namespaceHandle, StringHandle& nameHandle);
    internal static bool TryParseVisualBasicResumableLocalIndex(string synthesizedName, Int32& index);
    public ImmutableArray`1<string> GetVisualBasicHoistedLocalNames(TypeDefinitionHandle stateMachineTypeDefinitionHandle);
}
public enum Microsoft.DiaSymReader.Tools.PdbConversionOptions : Enum {
    public int value__;
    public static PdbConversionOptions Default;
    public static PdbConversionOptions SuppressSourceLinkConversion;
}
public class Microsoft.DiaSymReader.Tools.PdbConverter : object {
    public static PdbConverter Default;
    private Action`1<PdbDiagnostic> _diagnosticReporterOpt;
    public PdbConverter(Action`1<PdbDiagnostic> diagnosticReporter);
    private static PdbConverter();
    public static bool IsPortable(Stream pdbStream);
    public void ConvertWindowsToPortable(Stream peStream, Stream sourcePdbStream, Stream targetPdbStream);
    public void ConvertWindowsToPortable(PEReader peReader, Stream sourcePdbStream, Stream targetPdbStream);
    public void ConvertPortableToWindows(Stream peStream, Stream sourcePdbStream, Stream targetPdbStream, PdbConversionOptions options);
    public void ConvertPortableToWindows(PEReader peReader, Stream sourcePdbStream, Stream targetPdbStream, PdbConversionOptions options);
    public void ConvertPortableToWindows(PEReader peReader, MetadataReader pdbReader, Stream targetPdbStream, PdbConversionOptions options);
    public void ConvertPortableToWindows(PEReader peReader, MetadataReader pdbReader, SymUnmanagedWriter pdbWriter, PdbConversionOptions options);
}
internal class Microsoft.DiaSymReader.Tools.PdbConverterPortableToWindows : object {
    private static Guid s_languageVendorMicrosoft;
    private static Guid s_documentTypeText;
    private static Guid s_csharpGuid;
    private static Guid s_visualBasicGuid;
    private static Guid s_fsharpGuid;
    private Action`1<PdbDiagnostic> _diagnosticReporterOpt;
    private static int MaxEntityNameLength;
    public PdbConverterPortableToWindows(Action`1<PdbDiagnostic> diagnosticReporterOpt);
    private static PdbConverterPortableToWindows();
    private void ReportDiagnostic(PdbDiagnosticId id, int token, Object[] args);
    private static Guid GetLanguageVendorGuid(Guid languageGuid);
    internal void Convert(PEReader peReader, MetadataReader pdbReader, SymUnmanagedWriter pdbWriter, PdbConversionOptions options);
    private static string GetMethodNamespace(MetadataReader metadataReader, MethodDefinition methodDef);
    private static int AdjustEndScopeOffset(int exclusiveOffset, bool isEndInclusive);
    private static bool TryGetDynamicLocal(string name, int slotIndex, ImmutableArray`1<bool> flagsOpt, ValueTuple`4& result);
    private static void CopyCustomDebugInfoRecord(CustomDebugInfoEncoder& cdiEncoder, MetadataReader pdbReader, MethodDefinitionHandle methodDefHandle, Guid portableKind, CustomDebugInfoKind windowsKind);
    private static ImmutableArray`1<StateMachineHoistedLocalScope> GetStateMachineHoistedLocalScopes(MetadataReader pdbReader, MethodDefinitionHandle methodDefHandle);
    private static string GetIteratorTypeName(MetadataReader metadataReader, MethodDefinitionHandle moveNextHandle);
    private static void WriteImports(SymUnmanagedWriter pdbWriter, ImmutableArray`1<string> importStrings);
    private void AddImportStrings(List`1<string> importStrings, List`1<int> importGroups, HashSet`1<string> declaredExternAliases, MetadataReader pdbReader, MetadataModel metadataModel, ImportScopeHandle importScopeHandle, ImmutableArray`1<ValueTuple`2<AssemblyReferenceHandle, string>> aliasedAssemblyRefs, string vbDefaultNamespaceImportStringOpt, string vbCurrentMethodNamespaceOpt, bool vbSemantics);
    private static void AddExternAliases(HashSet`1<string> externAliases, MetadataReader pdbReader, ImportScopeHandle importScopeHandle);
    private static ImmutableArray`1<ValueTuple`2<AssemblyReferenceHandle, string>> GetAliasedAssemblyRefs(MetadataReader pdbReader);
    private string TryEncodeImport(MetadataReader pdbReader, MetadataModel metadataModel, ImportScopeHandle importScopeHandle, ImportDefinition import, HashSet`1<string> declaredExternAliases, ImmutableArray`1<ValueTuple`2<AssemblyReferenceHandle, string>> aliasedAssemblyRefs, bool isProjectLevel, bool vbSemantics);
    private static string TryGetAssemblyReferenceAlias(AssemblyReferenceHandle targetAssembly, HashSet`1<string> declaredExternAliases, ImmutableArray`1<ValueTuple`2<AssemblyReferenceHandle, string>> aliasedAssemblyRefs);
    private void WriteSequencePoints(SymUnmanagedSequencePointsWriter symSequencePointsWriter, SequencePointCollection sequencePoints, int documentCount, int methodToken);
    private void ConvertSourceServerData(string sourceLink, SymUnmanagedWriter pdbWriter, IReadOnlyCollection`1<string> documentNames);
    [CompilerGeneratedAttribute]
internal static int <Convert>g__CompareScopeRanges11_0(int leftStart, int leftEnd, int rightStart, int rightEnd);
    [CompilerGeneratedAttribute]
internal static void <Convert>g__LazyOpenMethod11_3(<>c__DisplayClass11_1& , <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static LocalScopeInfo <Convert>g__GetNextLocalScope11_4(<>c__DisplayClass11_1& , <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static void <Convert>g__CloseOpenScopes11_5(int currentScopeStartOffset, <>c__DisplayClass11_1& );
    [CompilerGeneratedAttribute]
internal static void <Convert>g__OpenScope11_6(int startOffset, int endOffset, <>c__DisplayClass11_1& , <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
private void <ConvertSourceServerData>b__25_0(string errorMessage);
}
internal class Microsoft.DiaSymReader.Tools.PdbConverterWindowsToPortable : object {
    private Action`1<PdbDiagnostic> _diagnosticReporterOpt;
    private static ImportScopeHandle ModuleImportScopeHandle;
    public PdbConverterWindowsToPortable(Action`1<PdbDiagnostic> diagnosticReporterOpt);
    private static PdbConverterWindowsToPortable();
    private static void ConvertConstantSignature(BlobBuilder builder, MetadataModel metadataModel, Byte[] signature, object value);
    private void ReportDiagnostic(PdbDiagnosticId id, int token, Object[] args);
    public void Convert(PEReader peReader, Stream sourcePdbStream, Stream targetPdbStream);
    private void Convert(ISymUnmanagedReader5 symReader, PEReader peReader, Stream targetPdbStream, BlobContentId pdbId);
    private void DefineDocument(MetadataBuilder metadataBuilder, ISymUnmanagedDocument document, Dictionary`2<string, DocumentHandle> documentIndex);
    private void BuildDynamicLocalMaps(Dictionary`2<int, DynamicLocalInfo> variables, Dictionary`2<string, List`1<DynamicLocalInfo>> constants, ImmutableArray`1<DynamicLocalInfo> infos, int methodToken);
    private void BuildTupleLocalMaps(Dictionary`2<int, TupleElementNamesInfo> variables, Dictionary`2<ValueTuple`3<string, int, int>, TupleElementNamesInfo> constants, ImmutableArray`1<TupleElementNamesInfo> infos, int methodToken);
    private static BlobHandle SerializeStateMachineHoistedLocalsBlob(MetadataBuilder metadataBuilder, ImmutableArray`1<StateMachineHoistedLocalScope> scopes);
    private static BlobHandle SerializeAsyncMethodSteppingInfo(MetadataBuilder metadataBuilder, ISymUnmanagedAsyncMethod symAsyncMethod, int moveNextMethodRowId);
    private static bool TryParseImportString(string importString, ImportInfo& import, bool vbSemantics);
    private static ImmutableArray`1<string> GetImportStrings(int token, Dictionary`2<int, ImmutableArray`1<string>> cache, ISymUnmanagedReader3 reader);
    private MethodDefinitionHandle ReadEntryPointHandle(ISymUnmanagedReader symReader);
    private static ImportScopeHandle DefineImportScope(ImmutableArray`1<ImmutableArray`1<ImportInfo>> importGroups, Dictionary`2<ImportScopeInfo, ImportScopeHandle> importScopeIndex, List`1<ImportScopeInfo> importScopes);
    private ImmutableArray`1<ImportInfo> ParseCSharpImportStrings(ImmutableArray`1<string> importStrings, int methodToken);
    private static BlobHandle SerializeModuleImportScope(MetadataBuilder metadataBuilder, IEnumerable`1<ImportInfo> csExternAliasImports, IEnumerable`1<ImportInfo> vbProjectLevelImports, string vbDefaultNamespace, MetadataModel metadataModel);
    private static void SerializeModuleDefaultNamespace(MetadataBuilder metadataBuilder, string namespaceName);
    private static BlobHandle SerializeImportsBlob(MetadataBuilder metadataBuilder, ImmutableArray`1<ImportInfo> imports, MetadataModel metadataModel);
    private static void SerializeImport(ImportDefinitionEncoder encoder, ImportInfo import, MetadataModel metadataModel);
    private void AddScopesRecursive(List`1<ValueTuple`4<int, int, ISymUnmanagedVariable[], ISymUnmanagedConstant[]>> builder, List`1<StateMachineHoistedLocalScope> vbHoistedLocalScopeBuilder, ISymUnmanagedScope symScope, int methodToken, bool vbSemantics, bool isTopScope);
    private void SerializeScope(MetadataBuilder metadataBuilder, MetadataModel metadataModel, MethodDefinitionHandle methodHandle, ImportScopeHandle importScopeHandle, int start, int end, ISymUnmanagedVariable[] symVariables, ISymUnmanagedConstant[] symConstants, Dictionary`2<int, TupleElementNamesInfo> tupleVariables, Dictionary`2<ValueTuple`3<string, int, int>, TupleElementNamesInfo> tupleConstants, Dictionary`2<int, DynamicLocalInfo> dynamicVariables, Dictionary`2<string, List`1<DynamicLocalInfo>> dynamicConstants, bool vbSemantics, LocalVariableHandle& lastLocalVariableHandle, LocalConstantHandle& lastLocalConstantHandle);
    private static BlobHandle SerializeConstantSignature(MetadataBuilder metadataBuilder, MetadataModel metadataModel, Byte[] signature, object value);
    private static BlobHandle SerializeDynamicInfo(MetadataBuilder metadataBuilder, DynamicLocalInfo dynamicInfo);
    private static BlobHandle SerializeTupleInfo(MetadataBuilder metadataBuilder, TupleElementNamesInfo tupleInfo);
    private static LocalVariableHandle NextHandle(LocalVariableHandle handle);
    private static LocalConstantHandle NextHandle(LocalConstantHandle handle);
    private BlobHandle SerializeSequencePoints(MetadataBuilder metadataBuilder, int localSignatureRowId, ImmutableArray`1<SymUnmanagedSequencePoint> sequencePoints, IReadOnlyDictionary`2<string, DocumentHandle> documentIndex, int methodIndex, DocumentHandle& singleDocumentHandle);
    private static SymUnmanagedSequencePoint SanitizeSequencePoint(SymUnmanagedSequencePoint sequencePoint, int previousOffset);
    private DocumentHandle TryGetSingleDocument(ImmutableArray`1<SymUnmanagedSequencePoint> sequencePoints, IReadOnlyDictionary`2<string, DocumentHandle> documentIndex, int methodToken);
    private DocumentHandle GetDocumentHandle(ISymUnmanagedDocument document, IReadOnlyDictionary`2<string, DocumentHandle> documentIndex, int methodToken);
    private static void SerializeDeltaLinesAndColumns(BlobBuilder writer, SymUnmanagedSequencePoint sequencePoint);
    private static void SerializeSourceLinkData(MetadataBuilder metadataBuilder, Byte[] data);
    private static Byte[] ConvertSourceServerToSourceLinkData(Byte[] sourceServerData);
    internal static string ConvertSourceServerToSourceLinkData(string sourceServerData);
    [CompilerGeneratedAttribute]
internal static bool <SerializeScope>g__TryPopConstantInfo24_0(string name, DynamicLocalInfo& info, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static string <ConvertSourceServerToSourceLinkData>g__Escape37_5(string str);
}
public class Microsoft.DiaSymReader.Tools.PdbDiagnostic : ValueType {
    [CompilerGeneratedAttribute]
private PdbDiagnosticId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public PdbDiagnosticId Id { get; }
    public int Token { get; }
    public Object[] Args { get; }
    internal PdbDiagnostic(PdbDiagnosticId id, int token, Object[] args);
    [CompilerGeneratedAttribute]
public PdbDiagnosticId get_Id();
    [CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PdbDiagnostic other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string GetMessage(IFormatProvider formatProvider);
}
public enum Microsoft.DiaSymReader.Tools.PdbDiagnosticId : Enum {
    public int value__;
    public static PdbDiagnosticId None;
    public static PdbDiagnosticId MethodAssociatedWithLocalScopeHasNoBody;
    public static PdbDiagnosticId LocalConstantNameTooLong;
    public static PdbDiagnosticId LocalVariableNameTooLong;
    public static PdbDiagnosticId MethodContainingLocalVariablesHasNoLocalSignature;
    public static PdbDiagnosticId LocalScopeRangesNestingIsInvalid;
    public static PdbDiagnosticId UnsupportedImportType;
    public static PdbDiagnosticId UndefinedAssemblyReferenceAlias;
    public static PdbDiagnosticId UnknownImportDefinitionKind;
    public static PdbDiagnosticId InvalidStateMachineTypeName;
    public static PdbDiagnosticId BothStateMachineTypeNameAndImportsSpecified;
    public static PdbDiagnosticId DuplicateDynamicLocals;
    public static PdbDiagnosticId DuplicateTupleElementNamesForSlot;
    public static PdbDiagnosticId DuplicateTupleElementNamesForConstant;
    public static PdbDiagnosticId InvalidImportStringFormat;
    public static PdbDiagnosticId InvalidEntryPointToken;
    public static PdbDiagnosticId InvalidScopeILOffsetRange;
    public static PdbDiagnosticId InvalidLocalConstantData;
    public static PdbDiagnosticId InvalidLocalConstantSignature;
    public static PdbDiagnosticId InvalidLocalScope;
    public static PdbDiagnosticId InvalidSequencePointDocument;
    public static PdbDiagnosticId UnmappedDocumentName;
    public static PdbDiagnosticId UriSchemeIsNotHttp;
    public static PdbDiagnosticId NoSupportedUrisFoundInSourceLink;
    public static PdbDiagnosticId InvalidSourceLinkData;
    public static PdbDiagnosticId InvalidSourceServerData;
    public static PdbDiagnosticId BothSourceLinkDataAndSourceServerData;
    public static PdbDiagnosticId InvalidEmbeddedSource;
    public static PdbDiagnosticId InconsistentStateMachineMethodMapping;
    public static PdbDiagnosticId InvalidSourceLink;
}
[ExtensionAttribute]
internal static class Microsoft.DiaSymReader.Tools.PdbDiagnosticIdExtensions : object {
    [ExtensionAttribute]
internal static string GetMessageTemplate(PdbDiagnosticId id);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.DiaSymReader.Tools.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MetadataNotAvailable { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeSeakable { get; }
    internal static string StreamMustBeWritable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MetadataNotAvailable();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeSeakable();
    internal static string get_StreamMustBeWritable();
}
internal class Microsoft.DiaSymReader.Tools.SourceLinkMap : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<FilePath, Uri>> _entries;
    public SourceLinkMap(List`1<ValueTuple`2<FilePath, Uri>> entries);
    internal static SourceLinkMap Parse(string json, Action`1<string> reportDiagnostic);
    private static bool TryParseEntry(string key, string value, FilePath& path, Uri& uri);
    public string GetUri(string path);
}
internal static class Microsoft.DiaSymReader.Tools.StreamUtilities : object {
    public static void ValidateStream(Stream stream, string parameterName, bool readRequired, bool writeRequired, bool seekRequired);
}
internal static class Microsoft.DiaSymReader.Tools.StringUtilities : object {
    public static int GetLongestCommonSuffixLength(string left, string right);
    public static string GetLongestCommonPrefix(IEnumerable`1<string> strings);
    public static int IndexOfFirstDifference(string left, string right, int length);
}
internal class Microsoft.DiaSymReader.Tools.SymMetadataProvider : object {
    private MetadataReader _reader;
    internal SymMetadataProvider(MetadataReader reader);
    public sealed virtual bool TryGetStandaloneSignature(int standaloneSignatureToken, Byte*& signature, Int32& length);
    public sealed virtual bool TryGetTypeDefinitionInfo(int typeDefinitionToken, String& namespaceName, String& typeName, TypeAttributes& attributes);
    public sealed virtual bool TryGetTypeReferenceInfo(int typeReferenceToken, String& namespaceName, String& typeName);
    public sealed virtual bool TryGetEnclosingType(int nestedTypeToken, Int32& enclosingTypeToken);
    public sealed virtual bool TryGetMethodInfo(int methodDefinitionToken, String& methodName, Int32& declaringTypeToken);
}
[ExtensionAttribute]
internal static class Microsoft.DiaSymReader.Tools.SymReaderHelpers : object {
    internal static Guid VisualBasicLanguageGuid;
    private static SymReaderHelpers();
    internal static bool IsPortable(Stream pdbStream);
    public static ISymUnmanagedReader5 CreateWindowsPdbReader(Stream pdbStream);
    public static ISymUnmanagedReader5 CreateWindowsPdbReader(Stream pdbStream, PEReader peReader);
    public static ISymUnmanagedReader5 CreateWindowsPdbReader(Stream pdbStream, MetadataReader metadataReader);
    public static ImmutableArray`1<string> GetImportStrings(ISymUnmanagedReader reader, int methodToken, int methodVersion);
    public static bool TryReadPdbId(PEReader peReader, BlobContentId& id, Int32& age);
    public static void GetWindowsPdbSignature(ImmutableArray`1<byte> bytes, Guid& guid, UInt32& timestamp, Int32& age);
    private static Byte[] GetBytes(Byte* data, int size);
    private static string GetString(Byte* data, int size);
    [ExtensionAttribute]
public static string GetSourceLinkData(ISymUnmanagedReader5 reader);
    [ExtensionAttribute]
public static Byte[] GetRawSourceLinkData(ISymUnmanagedReader5 reader);
    private static bool TryGetSourceLinkData(ISymUnmanagedReader5 reader, Byte*& data, Int32& size);
    [ExtensionAttribute]
public static Byte[] GetRawSourceServerData(ISymUnmanagedReader reader);
    [ExtensionAttribute]
public static string GetSourceServerData(ISymUnmanagedReader reader);
    [ExtensionAttribute]
public static Byte[] GetRawEmbeddedSource(ISymUnmanagedDocument document);
}
public static class Roslyn.Utilities.AssemblyDisplayNameBuilder : object {
    internal static string InvariantCultureDisplay;
    internal static int PublicKeyTokenSize;
    internal static string GetAssemblyDisplayName(MetadataReader reader, AssemblyReference assemblyRef);
    private static string BuildDisplayName(string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, bool isRetargetable, AssemblyContentType contentType);
    private static void AppendKey(StringBuilder sb, ImmutableArray`1<byte> key);
    private static void EscapeName(StringBuilder result, string name);
    private static bool IsWhiteSpace(char c);
    public static SignatureTypeCode GetConstantTypeCode(object value);
}
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception Unreachable { get; }
    internal static Exception UnexpectedValue(object o);
    internal static Exception get_Unreachable();
}
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    internal static int CombineValues(ImmutableArray`1<T> values, IEqualityComparer`1<T> comparer, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<T> values, IEqualityComparer`1<T> comparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(Byte* data, int length, Boolean& isAscii);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
internal class Roslyn.Utilities.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
internal class System.Reflection.Metadata.ImportDefinitionEncoder : ValueType {
    [CompilerGeneratedAttribute]
private MetadataBuilder <MetadataBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    public MetadataBuilder MetadataBuilder { get; }
    public BlobBuilder Builder { get; }
    public ImportDefinitionEncoder(MetadataBuilder metadataBuilder, BlobBuilder builder);
    [CompilerGeneratedAttribute]
public MetadataBuilder get_MetadataBuilder();
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public void Type(EntityHandle type, string alias);
    public void Namespace(string namespaceName, string alias, AssemblyReferenceHandle externAlias);
    public void XmlNamespace(string alias, string target);
    public void ImportAssemblyReferenceAlias(string alias);
    public void AliasAssemblyReference(AssemblyReferenceHandle assemblyReference, string alias);
}
