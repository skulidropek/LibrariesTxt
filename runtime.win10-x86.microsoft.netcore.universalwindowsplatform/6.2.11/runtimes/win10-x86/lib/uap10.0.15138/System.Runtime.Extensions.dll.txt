internal static class FxResources.System.Runtime.Extensions.SR : object {
}
internal static class Interop : object {
}
public class System.AppDomain : MarshalByRefObject {
    private static AppDomain s_domain;
    private object _forLock;
    private IPrincipal _defaultPrincipal;
    [CompilerGeneratedAttribute]
private EventHandler DomainUnload;
    [CompilerGeneratedAttribute]
private ResolveEventHandler ReflectionOnlyAssemblyResolve;
    public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public string DynamicDirectory { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    public bool ShadowCopyFiles { get; }
    private static AppDomain();
    public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    public string get_RelativeSearchPath();
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public string get_DynamicDirectory();
    [ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetDynamicBase(string path);
    public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    [CompilerGeneratedAttribute]
public void add_DomainUnload(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    public string ApplyPolicy(string assemblyName);
    public static AppDomain CreateDomain(string friendlyName);
    public int ExecuteAssembly(string assemblyFile);
    public int ExecuteAssembly(string assemblyFile, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    private int ExecuteAssembly(Assembly assembly, String[] args);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public int ExecuteAssemblyByName(string assemblyName);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public object GetData(string name);
    public void SetData(string name, object data);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    public virtual string ToString();
    public static void Unload(AppDomain domain);
    public Assembly Load(Byte[] rawAssembly);
    public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public Assembly Load(AssemblyName assemblyRef);
    public Assembly Load(string assemblyString);
    public Assembly[] ReflectionOnlyGetAssemblies();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    public TimeSpan get_MonitoringTotalProcessorTime();
    private static Exception CreateResMonNotAvailException();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    public bool get_ShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void AppendPrivatePath(string path);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearShadowCopyPath();
    [ObsoleteAttribute("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetCachePath(string path);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyPath(string path);
    public Assembly[] GetAssemblies();
    public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    public void SetThreadPrincipal(IPrincipal principal);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AppDomainUnloadedException : SystemException {
    internal static int COR_E_APPDOMAINUNLOADED;
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
public class System.ApplicationId : object {
    private Byte[] _publicKeyToken;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Culture { get; }
    public string Name { get; }
    public string ProcessorArchitecture { get; }
    public Version Version { get; }
    public Byte[] PublicKeyToken { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public Byte[] get_PublicKeyToken();
    public ApplicationId Copy();
    public virtual string ToString();
    private static char HexDigit(int num);
    private static string EncodeHexString(Byte[] sArray);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CannotUnloadAppDomainException : SystemException {
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
    protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
}
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    private TextWriter _writer;
    private string _tabString;
    private int _indentLevel;
    private bool _tabsPending;
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public void WriteLineNoTabs(string s);
    public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ArrayList : object {
    private Object[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int _defaultCapacity;
    internal static int MaxArrayLength;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    internal ArrayList(bool trash);
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public static ArrayList Adapter(IList list);
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    public virtual int BinarySearch(object value);
    public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    private void EnsureCapacity(int min);
    public static IList FixedSize(IList list);
    public static ArrayList FixedSize(ArrayList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    public virtual int IndexOf(object value);
    public virtual int IndexOf(object value, int startIndex);
    public virtual int IndexOf(object value, int startIndex, int count);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual int LastIndexOf(object value);
    public virtual int LastIndexOf(object value, int startIndex);
    public virtual int LastIndexOf(object value, int startIndex, int count);
    public static IList ReadOnly(IList list);
    public static ArrayList ReadOnly(ArrayList list);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual ArrayList GetRange(int index, int count);
    public virtual void Sort();
    public virtual void Sort(IComparer comparer);
    public virtual void Sort(int index, int count, IComparer comparer);
    public static IList Synchronized(IList list);
    public static ArrayList Synchronized(ArrayList list);
    public virtual Object[] ToArray();
    public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ContextMarshalException : SystemException {
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
    protected ContextMarshalException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.ContextStaticAttribute : Attribute {
}
public class System.Diagnostics.Stopwatch : object {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private long _elapsed;
    private long _startTimeStamp;
    private bool _isRunning;
    public static long Frequency;
    public static bool IsHighResolution;
    private static double s_tickFrequency;
    public bool IsRunning { get; }
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private static Stopwatch();
    public void Start();
    public static Stopwatch StartNew();
    public void Stop();
    public void Reset();
    public void Restart();
    public bool get_IsRunning();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public static long GetTimestamp();
    private long GetRawElapsedTicks();
    private long GetElapsedDateTimeTicks();
    private static bool QueryPerformanceFrequency(Int64& value);
    private static bool QueryPerformanceCounter(Int64& value);
}
[ExtensionAttribute]
public static class System.Environment : object {
    private static Lazy`1<OperatingSystem> s_osVersion;
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int CurrentManagedThreadId { get; }
    public static bool HasShutdownStarted { get; }
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static OperatingSystem OSVersion { get; }
    public static int ProcessorCount { get; }
    public static string StackTrace { get; }
    public static int TickCount { get; }
    public static bool UserInteractive { get; }
    public static Version Version { get; }
    public static long WorkingSet { get; }
    public static string UserName { get; }
    public static string UserDomainName { get; }
    private static string CurrentDirectoryCore { get; private set; }
    public static string NewLine { get; }
    public static int SystemPageSize { get; }
    public static int ExitCode { get; public set; }
    private static bool Is64BitOperatingSystemWhen32BitProcess { get; }
    public static string MachineName { get; }
    public static string SystemDirectory { get; }
    private static Environment();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    [ExtensionAttribute]
private static Hashtable ToHashtable(IEnumerable`1<KeyValuePair`2<string, string>> pairs);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static int get_CurrentManagedThreadId();
    public static void Exit(int exitCode);
    public static void FailFast(string message);
    public static void FailFast(string message, Exception exception);
    public static string ExpandEnvironmentVariables(string name);
    public static String[] GetCommandLineArgs();
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static bool get_HasShutdownStarted();
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    public static OperatingSystem get_OSVersion();
    public static int get_ProcessorCount();
    public static string get_StackTrace();
    public static int get_TickCount();
    public static bool get_UserInteractive();
    public static Version get_Version();
    public static long get_WorkingSet();
    public static string get_UserName();
    public static string get_UserDomainName();
    private static string GetFolderPathCore(SpecialFolder folder, SpecialFolderOption option);
    private static string GetFolderPathCoreCurrent(SpecialFolder folder);
    private static string GetFolderPathCoreFallBack(SpecialFolder folder);
    private static string get_CurrentDirectoryCore();
    private static void set_CurrentDirectoryCore(string value);
    public static String[] GetLogicalDrives();
    public static string get_NewLine();
    public static int get_SystemPageSize();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    private static string ExpandEnvironmentVariablesCore(string name);
    private static bool get_Is64BitOperatingSystemWhen32BitProcess();
    public static string get_MachineName();
    public static string get_SystemDirectory();
}
internal static class System.HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_HANDLE;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_INVALIDARG;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_OWNER;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TIMEOUT;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
public class System.IO.BufferedStream : Stream {
    private static int MaxShadowBufferSize;
    private static int DefaultBufferSize;
    private Stream _stream;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _readPos;
    private int _readLen;
    private int _writePos;
    private Task`1<int> _lastSyncCompletedReadTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public Stream UnderlyingStream { get; }
    public int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    internal SemaphoreSlim LazyEnsureAsyncActiveSemaphoreInitialized();
    private void EnsureNotClosed();
    private void EnsureCanSeek();
    private void EnsureCanRead();
    private void EnsureCanWrite();
    private void EnsureShadowBufferAllocated();
    private void EnsureBufferAllocated();
    public Stream get_UnderlyingStream();
    public int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushAsyncInternal>d__37")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void FlushRead();
    private void ClearReadBufferBeforeWrite();
    private void FlushWrite();
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushWriteAsync>d__41")]
private Task FlushWriteAsync(CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] array, int offset, int count);
    private int ReadFromBuffer(Span`1<byte> destination);
    private int ReadFromBuffer(Byte[] array, int offset, int count, Exception& error);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    private Task`1<int> LastSyncCompletedReadTask(int val);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<ReadFromUnderlyingStreamAsync>d__50")]
private ValueTask`1<int> ReadFromUnderlyingStreamAsync(Memory`1<byte> buffer, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    private int ReadByteSlow();
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count);
    private int WriteToBuffer(ReadOnlySpan`1<byte> buffer);
    private void WriteToBuffer(Byte[] array, Int32& offset, Int32& count, Exception& error);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<WriteToUnderlyingStreamAsync>d__62")]
private Task WriteToUnderlyingStreamAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken, Task semaphoreLockTask);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<CopyToAsyncCore>d__70")]
private Task CopyToAsyncCore(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
internal static class System.IO.DriveInfoInternal : object {
    public static String[] GetLogicalDrives();
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
    private InvalidDataException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PathHelper : object {
    internal static string Normalize(string path);
    internal static string Normalize(ValueStringBuilder& path);
    private static void GetFullPathName(ReadOnlySpan`1<char> path, ValueStringBuilder& builder);
    internal static int PrependDevicePathChars(ValueStringBuilder& content, bool isDosUnc, ValueStringBuilder& buffer);
    internal static string TryExpandShortFileName(ValueStringBuilder& outputBuilder, string originalPath);
}
internal static class System.IO.PathInternal : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static char PathSeparator;
    internal static string DirectorySeparatorCharAsString;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static string ParentDirectoryPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefixOverMaxPath(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static bool HasWildCardCharacters(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
internal static class System.IO.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    private static int DEFAULT_CAPACITY;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.IO.StringReader : TextReader {
    private string _s;
    private int _pos;
    private int _length;
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    public virtual int ReadBlock(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
}
public class System.IO.StringWriter : TextWriter {
    private static UnicodeEncoding modreq(System.Runtime.CompilerServices.IsVolatile) s_encoding;
    private StringBuilder _sb;
    private bool _isOpen;
    public Encoding Encoding { get; }
    public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    private static StringWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_Encoding();
    public virtual StringBuilder GetStringBuilder();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(string value);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    public virtual string ToString();
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static int TryMakeWin32ErrorCodeFromHR(int hr);
    internal static string GetMessage(int errorCode);
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    private byte _val;
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
public static class System.Net.WebUtility : object {
    private static char HIGH_SURROGATE_START;
    private static char LOW_SURROGATE_START;
    private static char LOW_SURROGATE_END;
    private static int UNICODE_PLANE00_END;
    private static int UNICODE_PLANE01_START;
    private static int UNICODE_PLANE16_END;
    private static int UnicodeReplacementChar;
    private static Char[] s_htmlEntityEndingChars;
    private static WebUtility();
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    private static void HtmlEncode(string value, int index, StringBuilder output);
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
    private static void HtmlDecode(string value, StringBuilder output);
    private static int IndexOfHtmlEncodingChars(string s, int startPos);
    private static void GetEncodedBytes(Byte[] originalBytes, int offset, int count, Byte[] expandedBytes);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    private static void ConvertSmpToUtf16(UInt32 smpChar, Char& leadingSurrogate, Char& trailingSurrogate);
    private static int GetNextUnicodeScalarValueFromUtf16Surrogate(Char*& pch, Int32& charsRemaining);
    private static int HexToInt(char h);
    private static char IntToHex(int n);
    private static bool IsUrlSafeChar(char ch);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
    private static bool StringRequiresHtmlDecoding(string s);
}
public class System.OperatingSystem : object {
    private Version _version;
    private PlatformID _platform;
    private string _servicePack;
    private string _versionString;
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
}
internal static class System.PasteArguments : object {
    private static char Quote;
    private static char Backslash;
    internal static void AppendArgument(StringBuilder stringBuilder, string argument);
    private static bool ContainsNoWhitespaceOrQuotes(string s);
    internal static string Paste(IEnumerable`1<string> arguments, bool pasteFirstArgumentUsingArgV0Rules);
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    public static PlatformID Unix;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    public AssemblyName GetAssemblyName(string assemblyFile);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ComponentGuaranteesOptions <Guarantees>k__BackingField;
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    [CompilerGeneratedAttribute]
public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions Stable;
    public static ComponentGuaranteesOptions SideBySide;
}
public class System.Runtime.Versioning.FrameworkName : object {
    private string _identifier;
    private Version _version;
    private string _profile;
    private string _fullName;
    private static char ComponentSeparator;
    private static char KeyValueSeparator;
    private static char VersionValuePrefix;
    private static string VersionKey;
    private static string ProfileKey;
    private static Char[] s_componentSplitSeparator;
    public string Identifier { get; }
    public Version Version { get; }
    public string Profile { get; }
    public string FullName { get; }
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public FrameworkName(string frameworkName);
    private static FrameworkName();
    public string get_Identifier();
    public Version get_Version();
    public string get_Profile();
    public string get_FullName();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(FrameworkName left, FrameworkName right);
    public static bool op_Inequality(FrameworkName left, FrameworkName right);
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ResourceScope <ResourceScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceScope <ConsumptionScope>k__BackingField;
    public ResourceScope ResourceScope { get; }
    public ResourceScope ConsumptionScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    [CompilerGeneratedAttribute]
public ResourceScope get_ResourceScope();
    [CompilerGeneratedAttribute]
public ResourceScope get_ConsumptionScope();
}
[AttributeUsageAttribute("480")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ResourceScope <ResourceExposureLevel>k__BackingField;
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    [CompilerGeneratedAttribute]
public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope None;
    public static ResourceScope Machine;
    public static ResourceScope Process;
    public static ResourceScope AppDomain;
    public static ResourceScope Library;
    public static ResourceScope Private;
    public static ResourceScope Assembly;
}
[FlagsAttribute]
internal enum System.Runtime.Versioning.SxSRequirements : Enum {
    public int value__;
    public static SxSRequirements None;
    public static SxSRequirements AppDomainID;
    public static SxSRequirements ProcessID;
    public static SxSRequirements CLRInstanceID;
    public static SxSRequirements AssemblyName;
    public static SxSRequirements TypeName;
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    private static ResourceScope ResTypeMask;
    private static ResourceScope VisibilityMask;
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
    private static string GetCLRInstanceString();
    private static SxSRequirements GetRequirements(ResourceScope consumeAsScope, ResourceScope calleeScope);
    private static int GetCurrentProcessId();
}
public interface System.Security.IPermission {
    public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
internal interface System.Security.ISecurityElementFactory {
    public abstract virtual SecurityElement CreateSecurityElement();
    public abstract virtual object Copy();
    public abstract virtual string GetTag();
    public abstract virtual string Attribute(string attributeName);
}
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    public abstract virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Assert;
    public static SecurityAction Demand;
    [ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction Deny;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction LinkDemand;
    public static SecurityAction PermitOnly;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestMinimum;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestOptional;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestRefuse;
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unrestricted>k__BackingField;
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public SecurityAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SecurityAction value);
    [CompilerGeneratedAttribute]
public bool get_Unrestricted();
    [CompilerGeneratedAttribute]
public void set_Unrestricted(bool value);
    public abstract virtual IPermission CreatePermission();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BindingRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlAppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlDomainPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlEvidence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Execution>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityPermissionFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Infrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemotingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializationFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnmanagedCode>k__BackingField;
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Assertion();
    [CompilerGeneratedAttribute]
public void set_Assertion(bool value);
    [CompilerGeneratedAttribute]
public bool get_BindingRedirects();
    [CompilerGeneratedAttribute]
public void set_BindingRedirects(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlAppDomain();
    [CompilerGeneratedAttribute]
public void set_ControlAppDomain(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlDomainPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlDomainPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlEvidence();
    [CompilerGeneratedAttribute]
public void set_ControlEvidence(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPrincipal();
    [CompilerGeneratedAttribute]
public void set_ControlPrincipal(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlThread();
    [CompilerGeneratedAttribute]
public void set_ControlThread(bool value);
    [CompilerGeneratedAttribute]
public bool get_Execution();
    [CompilerGeneratedAttribute]
public void set_Execution(bool value);
    [CompilerGeneratedAttribute]
public SecurityPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SecurityPermissionFlag value);
    [CompilerGeneratedAttribute]
public bool get_Infrastructure();
    [CompilerGeneratedAttribute]
public void set_Infrastructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemotingConfiguration();
    [CompilerGeneratedAttribute]
public void set_RemotingConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializationFormatter();
    [CompilerGeneratedAttribute]
public void set_SerializationFormatter(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipVerification();
    [CompilerGeneratedAttribute]
public void set_SkipVerification(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnmanagedCode();
    [CompilerGeneratedAttribute]
public void set_UnmanagedCode(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag AllFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag UnmanagedCode;
}
public class System.Security.SecurityElement : object {
    internal string _tag;
    internal string _text;
    private ArrayList _children;
    internal ArrayList _attributes;
    private static int AttributesTypical;
    private static int ChildrenTypical;
    private static string Indent;
    private static Char[] s_tagIllegalCharacters;
    private static Char[] s_textIllegalCharacters;
    private static Char[] s_valueIllegalCharacters;
    private static Char[] s_escapeChars;
    private static String[] s_escapeStringPairs;
    public string Tag { get; public set; }
    public Hashtable Attributes { get; public set; }
    public string Text { get; public set; }
    public ArrayList Children { get; public set; }
    public SecurityElement(string tag);
    public SecurityElement(string tag, string text);
    private static SecurityElement();
    public string get_Tag();
    public void set_Tag(string value);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public string get_Text();
    public void set_Text(string value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    internal void ConvertSecurityElementFactories();
    internal void AddAttributeSafe(string name, string value);
    public void AddAttribute(string name, string value);
    public void AddChild(SecurityElement child);
    public bool Equal(SecurityElement other);
    public SecurityElement Copy();
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    private static string GetEscapeSequence(char c);
    public static string Escape(string str);
    private static string GetUnescapeSequence(string str, int index, Int32& newIndex);
    private static string Unescape(string str);
    public virtual string ToString();
    private void ToString(string indent, object obj, Action`2<object, string> write);
    public string Attribute(string name);
    public SecurityElement SearchForChildByTag(string tag);
    public string SearchForTextOfTag(string tag);
    public static SecurityElement FromString(string xml);
    private sealed virtual override SecurityElement System.Security.ISecurityElementFactory.CreateSecurityElement();
    private sealed virtual override string System.Security.ISecurityElementFactory.GetTag();
    private sealed virtual override object System.Security.ISecurityElementFactory.Copy();
    private sealed virtual override string System.Security.ISecurityElementFactory.Attribute(string attributeName);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Argument_EmptyApplicationName { get; }
    internal static string Argument_FrameworkNameMissingVersion { get; }
    internal static string Argument_FrameworkNameInvalid { get; }
    internal static string Argument_FrameworkNameInvalidVersion { get; }
    internal static string Argument_FrameworkNameTooShort { get; }
    internal static string net_emptystringcall { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_FileNotFound { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string InvalidOperation_ComputerName { get; }
    internal static string InvalidOperation_GetVersion { get; }
    internal static string PersistedFiles_NoHomeDirectory { get; }
    internal static string Argument_BadResourceScopeTypeBits { get; }
    internal static string Argument_BadResourceScopeVisibilityBits { get; }
    internal static string ArgumentNull_TypeRequiredByResourceScope { get; }
    internal static string Argument_ResourceScopeWrongDirection { get; }
    internal static string AppDomain_Name { get; }
    internal static string AppDomain_NoContextPolicies { get; }
    internal static string Arg_MustBeTrue { get; }
    internal static string Arg_CannotUnloadAppDomainException { get; }
    internal static string Arg_AppDomainUnloadedException { get; }
    internal static string ZeroLengthString { get; }
    internal static string EntryPointNotFound { get; }
    internal static string NotSupported { get; }
    internal static string Arg_ContextMarshalException { get; }
    internal static string AppDomain_Policy_PrincipalTwice { get; }
    internal static string ArgumentNull_Collection { get; }
    internal static string ArgumentOutOfRange_ArrayListInsert { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_UnderlyingArrayListChanged { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string NotSupported_RangeCollection { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string GenericInvalidData { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ObjectDisposed_WriterClosed { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ArgumentNull_Child { get; }
    internal static string Argument_AttributeNamesMustBeUnique { get; }
    internal static string Argument_InvalidElementName { get; }
    internal static string Argument_InvalidElementTag { get; }
    internal static string Argument_InvalidElementText { get; }
    internal static string Argument_InvalidElementValue { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string PlatformNotSupported_AppDomains { get; }
    internal static string PlatformNotSupported_CAS { get; }
    internal static string PlatformNotSupported_AppDomain_ResMon { get; }
    internal static string IO_PathTooLong_Path { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Argument_EmptyApplicationName();
    internal static string get_Argument_FrameworkNameMissingVersion();
    internal static string get_Argument_FrameworkNameInvalid();
    internal static string get_Argument_FrameworkNameInvalidVersion();
    internal static string get_Argument_FrameworkNameTooShort();
    internal static string get_net_emptystringcall();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_Argument_PathEmpty();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_FileNotFound();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_FileExists_Name();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_InvalidOperation_ComputerName();
    internal static string get_InvalidOperation_GetVersion();
    internal static string get_PersistedFiles_NoHomeDirectory();
    internal static string get_Argument_BadResourceScopeTypeBits();
    internal static string get_Argument_BadResourceScopeVisibilityBits();
    internal static string get_ArgumentNull_TypeRequiredByResourceScope();
    internal static string get_Argument_ResourceScopeWrongDirection();
    internal static string get_AppDomain_Name();
    internal static string get_AppDomain_NoContextPolicies();
    internal static string get_Arg_MustBeTrue();
    internal static string get_Arg_CannotUnloadAppDomainException();
    internal static string get_Arg_AppDomainUnloadedException();
    internal static string get_ZeroLengthString();
    internal static string get_EntryPointNotFound();
    internal static string get_NotSupported();
    internal static string get_Arg_ContextMarshalException();
    internal static string get_AppDomain_Policy_PrincipalTwice();
    internal static string get_ArgumentNull_Collection();
    internal static string get_ArgumentOutOfRange_ArrayListInsert();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_UnderlyingArrayListChanged();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_NotSupported_RangeCollection();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_GenericInvalidData();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ObjectDisposed_WriterClosed();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ArgumentNull_Child();
    internal static string get_Argument_AttributeNamesMustBeUnique();
    internal static string get_Argument_InvalidElementName();
    internal static string get_Argument_InvalidElementTag();
    internal static string get_Argument_InvalidElementText();
    internal static string get_Argument_InvalidElementValue();
    internal static string get_Argument_InvalidFlag();
    internal static string get_PlatformNotSupported_AppDomains();
    internal static string get_PlatformNotSupported_CAS();
    internal static string get_PlatformNotSupported_AppDomain_ResMon();
    internal static string get_IO_PathTooLong_Path();
}
[ExtensionAttribute]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string strInput);
    [ExtensionAttribute]
public static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string strInput);
    [ExtensionAttribute]
public static string Normalize(string strInput, NormalizationForm normalizationForm);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int requiredAdditionalCapacity);
    public void Dispose();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
