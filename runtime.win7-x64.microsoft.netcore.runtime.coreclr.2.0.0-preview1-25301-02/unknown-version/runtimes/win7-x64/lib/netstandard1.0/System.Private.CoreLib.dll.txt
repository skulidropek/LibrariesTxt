internal static class AssemblyRef : object {
    internal static string EcmaPublicKey;
    internal static string EcmaPublicKeyToken;
    internal static string MicrosoftPublicKeyToken;
    internal static string SystemRuntimeWindowsRuntime;
}
internal static class FXAssembly : object {
    internal static string Version;
}
internal static class FxResources.System.Private.CoreLib.SR : object {
}
public static class Internal.Console : object {
    private static SafeFileHandle _outputHandle;
    private static Console();
    public static void Write(string s);
    public static void WriteLine(string s);
    public static void WriteLine();
}
public static class Internal.Runtime.Augments.EnvironmentAugments : object {
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static int TickCount { get; }
    public static string StackTrace { get; }
    public static int get_CurrentManagedThreadId();
    public static void Exit(int exitCode);
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static void FailFast(string message, Exception error);
    public static String[] GetCommandLineArgs();
    public static bool get_HasShutdownStarted();
    public static int get_TickCount();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    public static string get_StackTrace();
}
public class Internal.Runtime.Augments.RuntimeThread : CriticalFinalizerObject {
    public static RuntimeThread CurrentThread { get; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public bool IsThreadPoolThread { get; }
    public int ManagedThreadId { get; }
    public string Name { get; public set; }
    public ThreadPriority Priority { get; public set; }
    public ThreadState ThreadState { get; }
    public static RuntimeThread Create(ThreadStart start);
    public static RuntimeThread Create(ThreadStart start, int maxStackSize);
    public static RuntimeThread Create(ParameterizedThreadStart start);
    public static RuntimeThread Create(ParameterizedThreadStart start, int maxStackSize);
    private Thread AsThread();
    public static RuntimeThread get_CurrentThread();
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    private bool IsBackgroundNative();
    private void SetBackgroundNative(bool isBackground);
    public bool get_IsThreadPoolThread();
    public int get_ManagedThreadId();
    public string get_Name();
    public void set_Name(string value);
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    private int GetPriorityNative();
    private void SetPriorityNative(int priority);
    public ThreadState get_ThreadState();
    private int GetThreadStateNative();
    public ApartmentState GetApartmentState();
    public bool TrySetApartmentState(ApartmentState state);
    internal bool SetApartmentStateHelper(ApartmentState state, bool fireMDAOnMismatch);
    internal int GetApartmentStateNative();
    internal int SetApartmentStateNative(int state, bool fireMDAOnMismatch);
    public void DisableComObjectEagerCleanup();
    public void Interrupt();
    private void InterruptInternal();
    public void Join();
    public bool Join(int millisecondsTimeout);
    private bool JoinInternal(int millisecondsTimeout);
    public static void Sleep(int millisecondsTimeout);
    public static void SpinWait(int iterations);
    public static bool Yield();
    public void Start();
    public void Start(object parameter);
}
internal static class Interop : object {
    internal static void GetRandomBytes(Byte* buffer, int length);
}
[ExtensionAttribute]
internal static class Microsoft.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool ReflectionOnly(Assembly assm);
}
internal static class Microsoft.Win32.OAVariantLib : object {
    public static int NoValueProp;
    public static int AlphaBool;
    public static int NoUserOverride;
    public static int CalendarHijri;
    public static int LocalBool;
    internal static Type[] ClassTypes;
    private static int CV_OBJECT;
    private static OAVariantLib();
    internal static Variant ChangeType(Variant source, Type targetClass, short options, CultureInfo culture);
    private static int GetCVTypeFromClass(Type ctype);
    private static void ChangeTypeEx(Variant& result, Variant& source, int lcid, IntPtr typeHandle, int cvType, short flags);
}
internal static class Microsoft.Win32.Registry : object {
    public static RegistryKey CurrentUser;
    public static RegistryKey LocalMachine;
    public static RegistryKey ClassesRoot;
    public static RegistryKey Users;
    public static RegistryKey PerformanceData;
    public static RegistryKey CurrentConfig;
    private static Registry();
    private static RegistryKey GetBaseKeyFromKeyName(string keyName, String& subKeyName);
    public static object GetValue(string keyName, string valueName, object defaultValue);
}
internal class Microsoft.Win32.RegistryKey : MarshalByRefObject {
    internal static IntPtr HKEY_CLASSES_ROOT;
    internal static IntPtr HKEY_CURRENT_USER;
    internal static IntPtr HKEY_LOCAL_MACHINE;
    internal static IntPtr HKEY_USERS;
    internal static IntPtr HKEY_PERFORMANCE_DATA;
    internal static IntPtr HKEY_CURRENT_CONFIG;
    private static int STATE_DIRTY;
    private static int STATE_SYSTEMKEY;
    private static int STATE_WRITEACCESS;
    private static int STATE_PERF_DATA;
    private static String[] hkeyNames;
    private static int MaxKeyLength;
    private static int MaxValueLength;
    private SafeRegistryHandle modreq(System.Runtime.CompilerServices.IsVolatile) hkey;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) state;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) keyName;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) remoteKey;
    private RegistryKeyPermissionCheck modreq(System.Runtime.CompilerServices.IsVolatile) checkMode;
    private RegistryView modreq(System.Runtime.CompilerServices.IsVolatile) regView;
    private static int FORMAT_MESSAGE_IGNORE_INSERTS;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    private static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    private RegistryKey(SafeRegistryHandle hkey, bool writable, bool systemkey, bool remoteKey, bool isPerfData, RegistryView view);
    private static RegistryKey();
    public void Close();
    private void Dispose(bool disposing);
    private sealed virtual override void System.IDisposable.Dispose();
    public void DeleteValue(string name, bool throwOnMissingValue);
    internal static RegistryKey GetBaseKey(IntPtr hKey);
    internal static RegistryKey GetBaseKey(IntPtr hKey, RegistryView view);
    public RegistryKey OpenSubKey(string name, bool writable);
    internal RegistryKey InternalOpenSubKey(string name, bool writable);
    public RegistryKey OpenSubKey(string name);
    public String[] GetSubKeyNames();
    public String[] GetValueNames();
    public object GetValue(string name);
    public object GetValue(string name, object defaultValue);
    public object GetValue(string name, object defaultValue, RegistryValueOptions options);
    internal object InternalGetValue(string name, object defaultValue, bool doNotExpand, bool checkSecurity);
    private bool IsSystemKey();
    private bool IsWritable();
    private bool IsPerfDataKey();
    private void SetDirty();
    public void SetValue(string name, object value);
    public void SetValue(string name, object value, RegistryValueKind valueKind);
    private RegistryValueKind CalculateValueKind(object value);
    public virtual string ToString();
    internal void Win32Error(int errorCode, string str);
    internal static string FixupName(string name);
    private static void FixupPath(StringBuilder path);
    private bool ContainsRegistryValue(string name);
    private void EnsureNotDisposed();
    private void EnsureWriteable();
    private static int GetRegistryKeyAccess(bool isWritable);
    private RegistryKeyPermissionCheck GetSubKeyPermissonCheck(bool subkeyWritable);
    private static void ValidateKeyName(string name);
    private static void ValidateKeyView(RegistryView view);
}
internal enum Microsoft.Win32.RegistryKeyPermissionCheck : Enum {
    public int value__;
    public static RegistryKeyPermissionCheck Default;
    public static RegistryKeyPermissionCheck ReadSubTree;
    public static RegistryKeyPermissionCheck ReadWriteSubTree;
}
internal enum Microsoft.Win32.RegistryValueKind : Enum {
    public int value__;
    public static RegistryValueKind String;
    public static RegistryValueKind ExpandString;
    public static RegistryValueKind Binary;
    public static RegistryValueKind DWord;
    public static RegistryValueKind MultiString;
    public static RegistryValueKind QWord;
    public static RegistryValueKind Unknown;
    public static RegistryValueKind None;
}
[FlagsAttribute]
internal enum Microsoft.Win32.RegistryValueOptions : Enum {
    public int value__;
    public static RegistryValueOptions None;
    public static RegistryValueOptions DoNotExpandEnvironmentNames;
}
internal enum Microsoft.Win32.RegistryView : Enum {
    public int value__;
    public static RegistryView Default;
    public static RegistryView Registry64;
    public static RegistryView Registry32;
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private Nullable`1<bool> _isAsync;
    [CompilerGeneratedAttribute]
private ThreadPoolBoundHandle <ThreadPoolBinding>k__BackingField;
    internal Nullable`1<bool> IsAsync { get; internal set; }
    internal ThreadPoolBoundHandle ThreadPoolBinding { get; internal set; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    internal Nullable`1<bool> get_IsAsync();
    internal void set_IsAsync(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal ThreadPoolBoundHandle get_ThreadPoolBinding();
    [CompilerGeneratedAttribute]
internal void set_ThreadPoolBinding(ThreadPoolBoundHandle value);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int RegCloseKey(IntPtr hKey);
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
    internal static int GetTimeZoneInformation(TimeZoneInformation& lpTimeZoneInformation);
    internal static int GetDynamicTimeZoneInformation(DynamicTimeZoneInformation& lpDynamicTimeZoneInformation);
    internal static bool GetFileMUIPath(int flags, string filePath, StringBuilder language, Int32& languageLength, StringBuilder fileMuiPath, Int32& fileMuiPathLength, Int64& enumerator);
    internal static int LoadString(SafeLibraryHandle handle, int id, StringBuilder buffer, int bufferLength);
    internal static SafeLibraryHandle LoadLibraryEx(string libFilename, IntPtr reserved, int flags);
    internal static bool FreeLibrary(IntPtr hModule);
    internal static int RoGetActivationFactory(string activatableClassId, Guid& iid, Object& factory);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.Win32.Win32Native : object {
    internal static int KEY_QUERY_VALUE;
    internal static int KEY_SET_VALUE;
    internal static int KEY_CREATE_SUB_KEY;
    internal static int KEY_ENUMERATE_SUB_KEYS;
    internal static int KEY_NOTIFY;
    internal static int KEY_CREATE_LINK;
    internal static int KEY_READ;
    internal static int KEY_WRITE;
    internal static int KEY_WOW64_64KEY;
    internal static int KEY_WOW64_32KEY;
    internal static int REG_OPTION_NON_VOLATILE;
    internal static int REG_OPTION_VOLATILE;
    internal static int REG_OPTION_CREATE_LINK;
    internal static int REG_OPTION_BACKUP_RESTORE;
    internal static int REG_NONE;
    internal static int REG_SZ;
    internal static int REG_EXPAND_SZ;
    internal static int REG_BINARY;
    internal static int REG_DWORD;
    internal static int REG_DWORD_LITTLE_ENDIAN;
    internal static int REG_DWORD_BIG_ENDIAN;
    internal static int REG_LINK;
    internal static int REG_MULTI_SZ;
    internal static int REG_RESOURCE_LIST;
    internal static int REG_FULL_RESOURCE_DESCRIPTOR;
    internal static int REG_RESOURCE_REQUIREMENTS_LIST;
    internal static int REG_QWORD;
    internal static int HWND_BROADCAST;
    internal static int WM_SETTINGCHANGE;
    internal static int TIME_ZONE_ID_INVALID;
    internal static int TIME_ZONE_ID_UNKNOWN;
    internal static int TIME_ZONE_ID_STANDARD;
    internal static int TIME_ZONE_ID_DAYLIGHT;
    internal static int MAX_PATH;
    internal static int MUI_LANGUAGE_ID;
    internal static int MUI_LANGUAGE_NAME;
    internal static int MUI_PREFERRED_UI_LANGUAGES;
    internal static int MUI_INSTALLED_LANGUAGES;
    internal static int MUI_ALL_LANGUAGES;
    internal static int MUI_LANG_NEUTRAL_PE_FILE;
    internal static int MUI_NON_LANG_NEUTRAL_FILE;
    internal static int LOAD_LIBRARY_AS_DATAFILE;
    internal static int LOAD_STRING_MAX_LENGTH;
    internal static int READ_CONTROL;
    internal static int SYNCHRONIZE;
    internal static int STANDARD_RIGHTS_READ;
    internal static int STANDARD_RIGHTS_WRITE;
    internal static int SEMAPHORE_MODIFY_STATE;
    internal static int EVENT_MODIFY_STATE;
    internal static int MUTEX_MODIFY_STATE;
    internal static int MUTEX_ALL_ACCESS;
    internal static int LMEM_FIXED;
    internal static int LMEM_ZEROINIT;
    internal static int LPTR;
    internal static string KERNEL32;
    internal static string USER32;
    internal static string OLE32;
    internal static string OLEAUT32;
    internal static string NTDLL;
    internal static string ADVAPI32;
    internal static string SHELL32;
    internal static string SHIM;
    internal static string CRYPT32;
    internal static string SECUR32;
    internal static string MSCORWKS;
    internal static int SEM_FAILCRITICALERRORS;
    internal static int FIND_STARTSWITH;
    internal static int FIND_ENDSWITH;
    internal static int FIND_FROMSTART;
    internal static int FIND_FROMEND;
    internal static IntPtr INVALID_HANDLE_VALUE;
    internal static int STD_INPUT_HANDLE;
    internal static int STD_OUTPUT_HANDLE;
    internal static int STD_ERROR_HANDLE;
    internal static int CTRL_C_EVENT;
    internal static int CTRL_BREAK_EVENT;
    internal static int CTRL_CLOSE_EVENT;
    internal static int CTRL_LOGOFF_EVENT;
    internal static int CTRL_SHUTDOWN_EVENT;
    internal static short KEY_EVENT;
    internal static int FILE_TYPE_DISK;
    internal static int FILE_TYPE_CHAR;
    internal static int FILE_TYPE_PIPE;
    internal static int REPLACEFILE_WRITE_THROUGH;
    internal static int REPLACEFILE_IGNORE_MERGE_ERRORS;
    private static int FORMAT_MESSAGE_IGNORE_INSERTS;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    private static int FORMAT_MESSAGE_ARGUMENT_ARRAY;
    internal static UInt32 FILE_MAP_WRITE;
    internal static UInt32 FILE_MAP_READ;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static int IO_REPARSE_TAG_MOUNT_POINT;
    internal static int PAGE_READWRITE;
    internal static int MEM_COMMIT;
    internal static int MEM_RESERVE;
    internal static int MEM_RELEASE;
    internal static int MEM_FREE;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_INVALID_FUNCTION;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_INVALID_HANDLE;
    internal static int ERROR_NOT_ENOUGH_MEMORY;
    internal static int ERROR_INVALID_DATA;
    internal static int ERROR_INVALID_DRIVE;
    internal static int ERROR_NO_MORE_FILES;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_BAD_LENGTH;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_NOT_SUPPORTED;
    internal static int ERROR_FILE_EXISTS;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_CALL_NOT_IMPLEMENTED;
    internal static int ERROR_INSUFFICIENT_BUFFER;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_BAD_PATHNAME;
    internal static int ERROR_ALREADY_EXISTS;
    internal static int ERROR_ENVVAR_NOT_FOUND;
    internal static int ERROR_FILENAME_EXCED_RANGE;
    internal static int ERROR_NO_DATA;
    internal static int ERROR_PIPE_NOT_CONNECTED;
    internal static int ERROR_MORE_DATA;
    internal static int ERROR_DIRECTORY;
    internal static int ERROR_OPERATION_ABORTED;
    internal static int ERROR_NOT_FOUND;
    internal static int ERROR_NO_TOKEN;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_NON_ACCOUNT_SID;
    internal static int ERROR_NOT_ALL_ASSIGNED;
    internal static int ERROR_UNKNOWN_REVISION;
    internal static int ERROR_INVALID_OWNER;
    internal static int ERROR_INVALID_PRIMARY_GROUP;
    internal static int ERROR_NO_SUCH_PRIVILEGE;
    internal static int ERROR_PRIVILEGE_NOT_HELD;
    internal static int ERROR_NONE_MAPPED;
    internal static int ERROR_INVALID_ACL;
    internal static int ERROR_INVALID_SID;
    internal static int ERROR_INVALID_SECURITY_DESCR;
    internal static int ERROR_BAD_IMPERSONATION_LEVEL;
    internal static int ERROR_CANT_OPEN_ANONYMOUS;
    internal static int ERROR_NO_SECURITY_ON_OBJECT;
    internal static int ERROR_TRUSTED_RELATIONSHIP_FAILURE;
    internal static UInt32 STATUS_SUCCESS;
    internal static UInt32 STATUS_SOME_NOT_MAPPED;
    internal static UInt32 STATUS_NO_MEMORY;
    internal static UInt32 STATUS_OBJECT_NAME_NOT_FOUND;
    internal static UInt32 STATUS_NONE_MAPPED;
    internal static UInt32 STATUS_INSUFFICIENT_RESOURCES;
    internal static UInt32 STATUS_ACCESS_DENIED;
    internal static int INVALID_FILE_SIZE;
    internal static int STATUS_ACCOUNT_RESTRICTION;
    private static Version ThreadErrorModeMinOsVersion;
    internal static int LCID_SUPPORTED;
    internal static int SHGFP_TYPE_CURRENT;
    internal static int UOI_FLAGS;
    internal static int WSF_VISIBLE;
    internal static int CSIDL_FLAG_CREATE;
    internal static int CSIDL_FLAG_DONT_VERIFY;
    internal static int CSIDL_ADMINTOOLS;
    internal static int CSIDL_CDBURN_AREA;
    internal static int CSIDL_COMMON_ADMINTOOLS;
    internal static int CSIDL_COMMON_DOCUMENTS;
    internal static int CSIDL_COMMON_MUSIC;
    internal static int CSIDL_COMMON_OEM_LINKS;
    internal static int CSIDL_COMMON_PICTURES;
    internal static int CSIDL_COMMON_STARTMENU;
    internal static int CSIDL_COMMON_PROGRAMS;
    internal static int CSIDL_COMMON_STARTUP;
    internal static int CSIDL_COMMON_DESKTOPDIRECTORY;
    internal static int CSIDL_COMMON_TEMPLATES;
    internal static int CSIDL_COMMON_VIDEO;
    internal static int CSIDL_FONTS;
    internal static int CSIDL_MYVIDEO;
    internal static int CSIDL_NETHOOD;
    internal static int CSIDL_PRINTHOOD;
    internal static int CSIDL_PROFILE;
    internal static int CSIDL_PROGRAM_FILES_COMMONX86;
    internal static int CSIDL_PROGRAM_FILESX86;
    internal static int CSIDL_RESOURCES;
    internal static int CSIDL_RESOURCES_LOCALIZED;
    internal static int CSIDL_SYSTEMX86;
    internal static int CSIDL_WINDOWS;
    internal static int CSIDL_APPDATA;
    internal static int CSIDL_COMMON_APPDATA;
    internal static int CSIDL_LOCAL_APPDATA;
    internal static int CSIDL_COOKIES;
    internal static int CSIDL_FAVORITES;
    internal static int CSIDL_HISTORY;
    internal static int CSIDL_INTERNET_CACHE;
    internal static int CSIDL_PROGRAMS;
    internal static int CSIDL_RECENT;
    internal static int CSIDL_SENDTO;
    internal static int CSIDL_STARTMENU;
    internal static int CSIDL_STARTUP;
    internal static int CSIDL_SYSTEM;
    internal static int CSIDL_TEMPLATES;
    internal static int CSIDL_DESKTOPDIRECTORY;
    internal static int CSIDL_PERSONAL;
    internal static int CSIDL_PROGRAM_FILES;
    internal static int CSIDL_PROGRAM_FILES_COMMON;
    internal static int CSIDL_DESKTOP;
    internal static int CSIDL_DRIVES;
    internal static int CSIDL_MYMUSIC;
    internal static int CSIDL_MYPICTURES;
    internal static int NameSamCompatible;
    internal static byte VER_GREATER_EQUAL;
    internal static UInt32 VER_MAJORVERSION;
    internal static UInt32 VER_MINORVERSION;
    internal static UInt32 VER_SERVICEPACKMAJOR;
    internal static UInt32 VER_SERVICEPACKMINOR;
    private static Win32Native();
    internal static int FormatMessage(int dwFlags, IntPtr lpSource, int dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr va_list_arguments);
    internal static string GetMessage(int errorCode);
    internal static IntPtr LocalAlloc_NoSafeHandle(int uFlags, UIntPtr sizetdwBytes);
    internal static IntPtr LocalFree(IntPtr handle);
    internal static void ZeroMemory(IntPtr address, UIntPtr length);
    internal static bool GlobalMemoryStatusEx(MEMORYSTATUSEX& buffer);
    private static bool GlobalMemoryStatusExNative(MEMORYSTATUSEX& buffer);
    internal static UIntPtr VirtualQuery(Void* address, MEMORY_BASIC_INFORMATION& buffer, UIntPtr sizeOfBuffer);
    internal static Void* VirtualAlloc(Void* address, UIntPtr numBytes, int commitOrReserve, int pageProtectionMode);
    internal static bool VirtualFree(Void* address, UIntPtr numBytes, int pageFreeMode);
    internal static int lstrlenA(IntPtr ptr);
    internal static int lstrlenW(IntPtr ptr);
    internal static IntPtr SysAllocStringLen(string src, int len);
    internal static UInt32 SysStringLen(IntPtr bstr);
    internal static void SysFreeString(IntPtr bstr);
    internal static IntPtr SysAllocStringByteLen(Byte[] str, UInt32 len);
    internal static UInt32 SysStringByteLen(IntPtr bstr);
    internal static bool SetEvent(SafeWaitHandle handle);
    internal static bool ResetEvent(SafeWaitHandle handle);
    internal static SafeWaitHandle CreateEvent(SECURITY_ATTRIBUTES lpSecurityAttributes, bool isManualReset, bool initialState, string name);
    internal static SafeWaitHandle OpenEvent(int desiredAccess, bool inheritHandle, string name);
    internal static SafeWaitHandle CreateMutex(SECURITY_ATTRIBUTES lpSecurityAttributes, bool initialOwner, string name);
    internal static SafeWaitHandle OpenMutex(int desiredAccess, bool inheritHandle, string name);
    internal static bool ReleaseMutex(SafeWaitHandle handle);
    internal static bool CloseHandle(IntPtr handle);
    internal static int WriteFile(SafeFileHandle handle, Byte* bytes, int numBytesToWrite, Int32& numBytesWritten, IntPtr mustBeZero);
    internal static SafeWaitHandle CreateSemaphore(SECURITY_ATTRIBUTES lpSecurityAttributes, int initialCount, int maximumCount, string name);
    internal static bool ReleaseSemaphore(SafeWaitHandle handle, int releaseCount, Int32& previousCount);
    internal static SafeWaitHandle OpenSemaphore(int desiredAccess, bool inheritHandle, string name);
    internal static int GetSystemDirectory(StringBuilder sb, int length);
    internal static IntPtr GetStdHandle(int nStdHandle);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static SafeFindHandle FindFirstFile(string fileName, WIN32_FIND_DATA data);
    internal static bool FindNextFile(SafeFindHandle hndFindFile, WIN32_FIND_DATA lpFindFileData);
    internal static bool FindClose(IntPtr handle);
    internal static UInt32 GetCurrentDirectoryW(UInt32 nBufferLength, Char[] lpBuffer);
    internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    internal static bool SetCurrentDirectory(string path);
    private static int SetErrorMode_VistaAndOlder(int newMode);
    internal static int SetErrorMode(int newMode);
    internal static int WideCharToMultiByte(UInt32 cp, UInt32 flags, Char* pwzSource, int cchSource, Byte* pbDestBuffer, int cbDestBuffer, IntPtr null1, IntPtr null2);
    internal static bool SetEnvironmentVariable(string lpName, string lpValue);
    internal static int GetEnvironmentVariable(string lpName, StringBuilder lpValue, int size);
    internal static Char* GetEnvironmentStrings();
    internal static bool FreeEnvironmentStrings(Char* pStrings);
    internal static UInt32 GetCurrentProcessId();
    internal static int CoCreateGuid(Guid& guid);
    internal static IntPtr CoTaskMemAlloc(UIntPtr cb);
    internal static void CoTaskMemFree(IntPtr ptr);
    internal static IntPtr CoTaskMemRealloc(IntPtr pv, UIntPtr cb);
    internal static int RegDeleteValue(SafeRegistryHandle hKey, string lpValueName);
    internal static int RegEnumKeyEx(SafeRegistryHandle hKey, int dwIndex, Char[] lpName, Int32& lpcbName, Int32[] lpReserved, StringBuilder lpClass, Int32[] lpcbClass, Int64[] lpftLastWriteTime);
    internal static int RegEnumValue(SafeRegistryHandle hKey, int dwIndex, Char[] lpValueName, Int32& lpcbValueName, IntPtr lpReserved_MustBeZero, Int32[] lpType, Byte[] lpData, Int32[] lpcbData);
    internal static int RegOpenKeyEx(SafeRegistryHandle hKey, string lpSubKey, int ulOptions, int samDesired, SafeRegistryHandle& hkResult);
    internal static int RegQueryInfoKey(SafeRegistryHandle hKey, StringBuilder lpClass, Int32[] lpcbClass, IntPtr lpReserved_MustBeZero, Int32& lpcSubKeys, Int32[] lpcbMaxSubKeyLen, Int32[] lpcbMaxClassLen, Int32& lpcValues, Int32[] lpcbMaxValueNameLen, Int32[] lpcbMaxValueLen, Int32[] lpcbSecurityDescriptor, Int32[] lpftLastWriteTime);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Byte[] lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Int32& lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Int64& lpData, Int32& lpcbData);
    internal static int RegQueryValueEx(SafeRegistryHandle hKey, string lpValueName, Int32[] lpReserved, Int32& lpType, Char[] lpData, Int32& lpcbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, Byte[] lpData, int cbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, Int32& lpData, int cbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, Int64& lpData, int cbData);
    internal static int RegSetValueEx(SafeRegistryHandle hKey, string lpValueName, int Reserved, RegistryValueKind dwType, string lpData, int cbData);
    internal static int ExpandEnvironmentStrings(string lpSrc, StringBuilder lpDst, int nSize);
    internal static IntPtr LocalReAlloc(IntPtr handle, IntPtr sizetcbBytes, int uFlags);
    internal static IntPtr SendMessageTimeout(IntPtr hWnd, int Msg, IntPtr wParam, string lParam, UInt32 fuFlags, UInt32 uTimeout, IntPtr lpdwResult);
    internal static bool QueryUnbiasedInterruptTime(UInt64& UnbiasedTime);
    internal static bool VerifyVersionInfoW(OSVERSIONINFOEX lpVersionInfo, UInt32 dwTypeMask, ulong dwlConditionMask);
    internal static ulong VerSetConditionMask(ulong dwlConditionMask, UInt32 dwTypeBitMask, byte dwConditionMask);
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
internal class System.__Canon : object {
}
internal class System.__ComObject : MarshalByRefObject {
    private Hashtable m_ObjectToDataMap;
    public virtual string ToString();
    internal object GetData(object key);
    internal bool SetData(object key, object data);
    internal void ReleaseAllData();
    internal object GetEventProvider(RuntimeType t);
    internal int ReleaseSelf();
    internal void FinalReleaseSelf();
    private object CreateEventProvider(RuntimeType t);
}
internal class System.__DTString : ValueType {
    internal string Value;
    internal int Index;
    internal int len;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    private static Char[] WhiteSpaceChecks;
    internal CompareInfo CompareInfo { get; }
    internal __DTString(string str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(string str, DateTimeFormatInfo dtfi);
    private static __DTString();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool AtEnd();
    internal bool Advance(int count);
    internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWord(string target, int endIndex);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
internal static class System.__HResults : object {
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    internal static int E_FAIL;
    internal static int E_POINTER;
    internal static int E_NOTIMPL;
    internal static int REGDB_E_CLASSNOTREG;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_COMEMULATE;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTMEMORY;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SAFEHANDLEMISSINGATTRIBUTE;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SEMAPHOREFULL;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_THREADSTOP;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_UNSUPPORTEDFORMAT;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_HOSTPROTECTION;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int NTE_FAIL;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int DISP_E_OVERFLOW;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int TYPE_E_TYPEMISMATCH;
}
public class System.AccessViolationException : SystemException {
    private IntPtr _ip;
    private IntPtr _target;
    private int _accessType;
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Activator : object {
    internal static int LookupMask;
    internal static BindingFlags ConLookup;
    internal static BindingFlags ConstructorDefault;
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static object CreateInstance(Type type, Object[] args);
    public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    public static object CreateInstance(Type type);
    public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public static object CreateInstance(Type type, bool nonPublic);
    public static T CreateInstance();
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    internal static ObjectHandle CreateInstance(string assemblyString, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo, StackCrawlMark& stackMark);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    private static ObjectHandle CreateInstanceFromInternal(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo);
    public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
    public static ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [ConditionalAttribute("_DEBUG")]
private static void Log(bool test, string title, string success, string failure);
}
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
public class System.AggregateException : Exception {
    private ReadOnlyCollection`1<Exception> m_innerExceptions;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    private int InnerExceptionCount { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, IList`1<Exception> innerExceptions);
    internal AggregateException(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    private AggregateException(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string get_Message();
    public virtual string ToString();
    private int get_InnerExceptionCount();
}
public static class System.AppContext : object {
    private static Dictionary`2<string, SwitchValueState> s_switchMap;
    [CompilerGeneratedAttribute]
private static EventHandler ProcessExit;
    [CompilerGeneratedAttribute]
private static EventHandler Unloading;
    public static string BaseDirectory { get; }
    public static string TargetFrameworkName { get; }
    private static AppContext();
    public static string get_BaseDirectory();
    public static string get_TargetFrameworkName();
    public static object GetData(string name);
    public static void SetData(string name, object data);
    public static void add_UnhandledException(UnhandledExceptionEventHandler value);
    public static void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public static void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public static void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_Unloading(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_Unloading(EventHandler value);
    private static void OnProcessExit(object sender, EventArgs e);
    private static void OnUnloading(object sender, EventArgs e);
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    public static void SetSwitch(string switchName, bool isEnabled);
    internal static void DefineSwitchDefault(string switchName, bool isEnabled);
}
internal static class System.AppContextDefaultValues : object {
    internal static string SwitchNoAsyncCurrentCulture;
    internal static string SwitchThrowExceptionIfDisposedCancellationTokenSource;
    internal static string SwitchPreserveEventListnerObjectIdentity;
    private static AppContextDefaultValues();
    public static void PopulateDefaultValues();
    private static void ParseTargetFrameworkName(String& identifier, String& profile, Int32& version);
    private static bool TryParseFrameworkName(string frameworkName, String& identifier, Int32& version, String& profile);
    private static void TryGetSwitchOverridePartial(string switchName, Boolean& overrideFound, Boolean& overrideValue);
    private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version);
    public static bool TryGetSwitchOverride(string switchName, Boolean& overrideValue);
}
internal static class System.AppContextSwitches : object {
    private static int _noAsyncCurrentCulture;
    private static int _throwExceptionIfDisposedCancellationTokenSource;
    private static int _preserveEventListnerObjectIdentity;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    public static bool NoAsyncCurrentCulture { get; }
    public static bool ThrowExceptionIfDisposedCancellationTokenSource { get; }
    public static bool PreserveEventListnerObjectIdentity { get; }
    private static bool DisableCaching { get; private set; }
    private static AppContextSwitches();
    public static bool get_NoAsyncCurrentCulture();
    public static bool get_ThrowExceptionIfDisposedCancellationTokenSource();
    public static bool get_PreserveEventListnerObjectIdentity();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
}
internal class System.AppDomain : object {
    private AppDomainManager _domainManager;
    private Dictionary`2<string, object> _LocalStore;
    private AppDomainSetup _FusionStore;
    private Evidence _SecurityIdentity;
    private Object[] _Policies;
    [CompilerGeneratedAttribute]
private AssemblyLoadEventHandler AssemblyLoad;
    private ResolveEventHandler _TypeResolve;
    private ResolveEventHandler _ResourceResolve;
    private ResolveEventHandler _AssemblyResolve;
    private ApplicationTrust _applicationTrust;
    private EventHandler _processExit;
    private EventHandler _domainUnload;
    private UnhandledExceptionEventHandler _unhandledException;
    private Dictionary`2<string, object> _compatFlags;
    private EventHandler`1<FirstChanceExceptionEventArgs> _firstChanceException;
    private IntPtr _pDomain;
    private bool _HasSetPolicy;
    private bool _IsFastFullTrustDomain;
    private bool _compatFlagsInitialized;
    internal static string TargetFrameworkNameAppCompatSetting;
    private static APPX_FLAGS s_flags;
    private static APPX_FLAGS Flags { get; }
    public AppDomainManager DomainManager { get; }
    public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    internal AppDomainSetup FusionStore { get; }
    private Dictionary`2<string, object> LocalStore { get; }
    public AppDomainSetup SetupInformation { get; }
    public bool IsFullyTrusted { get; }
    public int Id { get; }
    [CompilerGeneratedAttribute]
public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    private static APPX_FLAGS get_Flags();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool DisableFusionUpdatesFromADManager(AppDomainHandle domain);
    [SuppressUnmanagedCodeSecurityAttribute]
private static APPX_FLAGS nGetAppXFlags();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetAppDomainManagerType(AppDomainHandle domain, StringHandleOnStack retAssembly, StringHandleOnStack retType);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void SetAppDomainManagerType(AppDomainHandle domain, string assembly, string type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void SetSecurityHomogeneousFlag(AppDomainHandle domain, bool runtimeSuppliedHomogenousGrantSet);
    internal AppDomainHandle GetNativeHandle();
    private void CreateAppDomainManager();
    private void InitializeCompatibilityFlags();
    internal bool DisableFusionUpdatesFromADManager();
    internal static bool IsAppXModel();
    internal static bool IsAppXDesignMode();
    internal static void CheckLoadFromSupported();
    internal static void CheckLoadFileSupported();
    internal static void CheckReflectionOnlyLoadSupported();
    internal static void CheckLoadByteArraySupported();
    internal void GetAppDomainManagerType(String& assembly, String& type);
    private void SetAppDomainManagerType(string assembly, string type);
    private void InitializeDomainSecurity(Evidence providedSecurityInfo, Evidence creatorsSecurityInfo, bool generateDefaultEvidence, IntPtr parentSecurityDescriptor, bool publishAppDomain);
    private void SetupDomainSecurityForHomogeneousDomain(ApplicationTrust appTrust, bool runtimeSuppliedHomogenousGrantSet);
    public AppDomainManager get_DomainManager();
    public ObjectHandle CreateInstance(string assemblyName, string typeName);
    public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    public virtual string ToString();
    internal bool IsUnloadingForcedFinalize();
    public bool IsFinalizingForUnload();
    internal static void PublishAnonymouslyHostedDynamicMethodsAssembly(RuntimeAssembly assemblyHandle);
    public void SetData(string name, object data);
    public object GetData(string name);
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    internal void nCreateContext();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void nSetupBindingPaths(string trustedPlatformAssemblies, string platformResourceRoots, string appPath, string appNiPaths, string appLocalWinMD);
    internal void SetupBindingPaths(string trustedPlatformAssemblies, string platformResourceRoots, string appPath, string appNiPaths, string appLocalWinMD);
    private string nGetFriendlyName();
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    public void add_DomainUnload(EventHandler value);
    public void remove_DomainUnload(EventHandler value);
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    private void OnAssemblyLoadEvent(RuntimeAssembly LoadedAssembly);
    private RuntimeAssembly OnResourceResolveEvent(RuntimeAssembly assembly, string resourceName);
    private RuntimeAssembly OnTypeResolveEvent(RuntimeAssembly assembly, string typeName);
    private RuntimeAssembly OnAssemblyResolveEvent(RuntimeAssembly assembly, string assemblyFullName);
    private String[] OnDesignerNamespaceResolveEvent(string namespaceName);
    internal AppDomainSetup get_FusionStore();
    internal static RuntimeAssembly GetRuntimeAssembly(Assembly asm);
    private Dictionary`2<string, object> get_LocalStore();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void nSetNativeDllSearchDirectories(string paths);
    private void SetupFusionStore(AppDomainSetup info, AppDomainSetup oldInfo);
    private static void RunInitializer(AppDomainSetup setup);
    private static object PrepareDataForSetup(string friendlyName, AppDomainSetup setup, Evidence providedSecurityInfo, Evidence creatorsSecurityInfo, IntPtr parentSecurityDescriptor, string sandboxName, String[] propertyNames, String[] propertyValues);
    private static object Setup(object arg);
    private static string NormalizeAppPaths(string values);
    internal static string NormalizePath(string path, bool fullCheck);
    private void SetupDomain(bool allowRedirects, string path, string configFile, String[] propertyNames, String[] propertyValues);
    private void SetupDomainSecurity(Evidence appDomainEvidence, IntPtr creatorsSecurityDescriptor, bool publishAppDomain);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void SetupDomainSecurity(AppDomainHandle appDomain, ObjectHandleOnStack appDomainEvidence, IntPtr creatorsSecurityDescriptor, bool publishAppDomain);
    private void nSetupFriendlyName(string friendlyName);
    private void nSetDisableInterfaceCache();
    internal void UpdateLoaderOptimization(LoaderOptimization optimization);
    public AppDomainSetup get_SetupInformation();
    internal string IsStringInterned(string str);
    internal string GetOrInternString(string str);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetGrantSet(AppDomainHandle domain, ObjectHandleOnStack retGrantSet);
    public bool get_IsFullyTrusted();
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
    public int get_Id();
    internal int GetId();
}
internal class System.AppDomainHandle : ValueType {
    private IntPtr m_appDomainHandle;
    internal AppDomainHandle(IntPtr domainHandle);
}
internal class System.AppDomainInitializer : MulticastDelegate {
    public AppDomainInitializer(object object, IntPtr method);
    public virtual void Invoke(String[] args);
    public virtual IAsyncResult BeginInvoke(String[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.AppDomainInitializerInfo : object {
    internal ItemInfo[] Info;
    internal AppDomainInitializerInfo(AppDomainInitializer init);
    internal AppDomainInitializer Unwrap();
}
internal class System.AppDomainManager : MarshalByRefObject {
    private Assembly m_entryAssembly;
    public Assembly EntryAssembly { get; }
    internal static AppDomainManager CurrentAppDomainManager { get; }
    public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetEntryAssembly(ObjectHandleOnStack retAssembly);
    public virtual Assembly get_EntryAssembly();
    internal static AppDomainManager get_CurrentAppDomainManager();
}
internal class System.AppDomainPauseManager : object {
    private static AppDomainPauseManager instance;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isPaused;
    [CompilerGeneratedAttribute]
private static ManualResetEvent <ResumeEvent>k__BackingField;
    internal static bool IsPaused { get; }
    internal static ManualResetEvent ResumeEvent { get; internal set; }
    private static AppDomainPauseManager();
    internal static bool get_IsPaused();
    [CompilerGeneratedAttribute]
internal static ManualResetEvent get_ResumeEvent();
    [CompilerGeneratedAttribute]
internal static void set_ResumeEvent(ManualResetEvent value);
}
internal class System.AppDomainSetup : object {
    private static string LOADER_OPTIMIZATION;
    private static string ACTAG_APP_BASE_URL;
    private String[] _Entries;
    private LoaderOptimization _LoaderOptimization;
    private string _AppBase;
    [OptionalFieldAttribute]
private AppDomainInitializer _AppDomainInitializer;
    [OptionalFieldAttribute]
private String[] _AppDomainInitializerArguments;
    [OptionalFieldAttribute]
private string _ApplicationTrust;
    [OptionalFieldAttribute]
private Byte[] _ConfigurationBytes;
    [OptionalFieldAttribute]
private bool _DisableInterfaceCache;
    [OptionalFieldAttribute]
private string _AppDomainManagerAssembly;
    [OptionalFieldAttribute]
private string _AppDomainManagerType;
    [OptionalFieldAttribute]
private Dictionary`2<string, object> _CompatFlags;
    [OptionalFieldAttribute]
private string _TargetFrameworkName;
    [OptionalFieldAttribute]
private bool _CheckedForTargetFrameworkName;
    [OptionalFieldAttribute]
private bool _UseRandomizedStringHashing;
    internal String[] Value { get; }
    public string AppDomainManagerAssembly { get; public set; }
    public string AppDomainManagerType { get; public set; }
    public string ApplicationBase { get; public set; }
    public string TargetFrameworkName { get; public set; }
    public string ApplicationName { get; public set; }
    public AppDomainInitializer AppDomainInitializer { get; public set; }
    public String[] AppDomainInitializerArguments { get; public set; }
    internal ApplicationTrust ApplicationTrust { get; }
    public LoaderOptimization LoaderOptimization { get; public set; }
    internal static string LoaderOptimizationKey { get; }
    public bool SandboxInterop { get; public set; }
    internal AppDomainSetup(AppDomainSetup copy, bool copyDomainBoundData);
    internal void SetupDefaults(string imageLocation, bool imageLocationAlreadyNormalized);
    internal String[] get_Value();
    public string get_AppDomainManagerAssembly();
    public void set_AppDomainManagerAssembly(string value);
    public string get_AppDomainManagerType();
    public void set_AppDomainManagerType(string value);
    public string get_ApplicationBase();
    public void set_ApplicationBase(string value);
    internal Dictionary`2<string, object> GetCompatibilityFlags();
    public void SetCompatibilitySwitches(IEnumerable`1<string> switches);
    public string get_TargetFrameworkName();
    public void set_TargetFrameworkName(string value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public AppDomainInitializer get_AppDomainInitializer();
    public void set_AppDomainInitializer(AppDomainInitializer value);
    public String[] get_AppDomainInitializerArguments();
    public void set_AppDomainInitializerArguments(String[] value);
    internal ApplicationTrust InternalGetApplicationTrust();
    internal void InternalSetApplicationTrust(string permissionSetName);
    internal ApplicationTrust get_ApplicationTrust();
    public LoaderOptimization get_LoaderOptimization();
    public void set_LoaderOptimization(LoaderOptimization value);
    internal static string get_LoaderOptimizationKey();
    internal static int Locate(string s);
    public bool get_SandboxInterop();
    public void set_SandboxInterop(bool value);
}
internal class System.AppDomainUnloadedException : SystemException {
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    protected ApplicationException(SerializationInfo info, StreamingContext context);
}
public class System.ArgIterator : ValueType {
    private IntPtr ArgCookie;
    private IntPtr sigPtr;
    private IntPtr sigPtrLen;
    private IntPtr ArgPtr;
    private int RemainingArgs;
    public ArgIterator(RuntimeArgumentHandle arglist);
    [CLSCompliantAttribute("False")]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    public void End();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    public RuntimeTypeHandle GetNextArgType();
    public int GetRemainingCount();
}
public class System.ArgumentException : SystemException {
    private string _paramName;
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_ParamName();
}
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
public class System.ArgumentOutOfRangeException : ArgumentException {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) _rangeMessage;
    private object m_actualValue;
    private static string RangeMessage { get; }
    public string Message { get; }
    public object ActualValue { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string paramName, string message);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    private static string get_RangeMessage();
    public virtual string get_Message();
    public virtual object get_ActualValue();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Array : object {
    internal static int MaxArrayLength;
    internal static int MaxByteArrayLength;
    public int Length { get; }
    public long LongLength { get; }
    public int Rank { get; }
    private int System.Collections.ICollection.Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static void Resize(T[]& array, int newSize);
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    private static Array InternalCreate(Void* elementType, int rank, Int32* pLengths, Int32* pLowerBounds);
    internal static Array UnsafeCreateInstance(Type elementType, int length);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    internal static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public static void Clear(Array array, int index, int length);
    public object GetValue(Int32[] indices);
    public object GetValue(int index);
    public object GetValue(int index1, int index2);
    public object GetValue(int index1, int index2, int index3);
    public object GetValue(long index);
    public object GetValue(long index1, long index2);
    public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public void SetValue(object value, int index);
    public void SetValue(object value, int index1, int index2);
    public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    public void SetValue(object value, long index);
    public void SetValue(object value, long index1, long index2);
    public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    private void InternalGetReference(Void* elemRef, int rank, Int32* pIndices);
    private static void InternalSetValue(Void* target, object value);
    public int get_Length();
    private static int GetMedian(int low, int hi);
    public long get_LongLength();
    public int GetLength(int dimension);
    public long GetLongLength(int dimension);
    public int get_Rank();
    public int GetUpperBound(int dimension);
    public int GetLowerBound(int dimension);
    internal int GetDataPtrOffsetInternal();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    internal static int CombineHashCodes(int h1, int h2);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    private static bool TrySZBinarySearch(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public sealed virtual IEnumerator GetEnumerator();
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    private static bool TrySZIndexOf(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    private static bool TrySZLastIndexOf(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    private static bool TrySZReverse(Array array, int index, int count);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    private static bool TrySZSort(Array keys, Array items, int left, int right);
    public static void Sort(T[] array);
    public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    public void Initialize();
}
[DefaultMemberAttribute("Item")]
public class System.ArraySegment`1 : ValueType {
    [CompilerGeneratedAttribute]
private static ArraySegment`1<T> <Empty>k__BackingField;
    private T[] _array;
    private int _offset;
    private int _count;
    public static ArraySegment`1<T> Empty { get; }
    public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    private static ArraySegment`1();
    [CompilerGeneratedAttribute]
public static ArraySegment`1<T> get_Empty();
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowInvalidOperationIfDefault();
}
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.AssemblyLoadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    [CompilerGeneratedAttribute]
public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    private static Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit);
    private static bool InternalIsDefined(PropertyInfo element, Type attributeType, bool inherit);
    private static PropertyInfo GetParentDefinition(PropertyInfo property, Type[] propertyParameters);
    private static Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit);
    private static EventInfo GetParentDefinition(EventInfo ev);
    private static bool InternalIsDefined(EventInfo element, Type attributeType, bool inherit);
    private static ParameterInfo GetParentDefinition(ParameterInfo param);
    private static Attribute[] InternalParamGetCustomAttributes(ParameterInfo param, Type type, bool inherit);
    private static bool InternalParamIsDefined(ParameterInfo param, Type type, bool inherit);
    private static void CopyToArrayList(List`1<Attribute> attributeList, Attribute[] attributes, Dictionary`2<Type, AttributeUsageAttribute> types);
    private static Type[] GetIndexParameterTypes(PropertyInfo element);
    private static void AddAttributesToList(List`1<Attribute> attributeList, Attribute[] attributes, Dictionary`2<Type, AttributeUsageAttribute> types);
    private static AttributeUsageAttribute InternalGetAttributeUsage(Type type);
    private static Attribute[] CreateAttributeArrayHelper(Type elementType, int elementCount);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public virtual bool Equals(object obj);
    private static bool AreFieldValuesEqual(object thisValue, object thatValue);
    public virtual int GetHashCode();
    public virtual object get_TypeId();
    public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    private AttributeTargets _attributeTarget;
    private bool _allowMultiple;
    private bool _inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
public class System.BadImageFormatException : SystemException {
    private string _fileName;
    private string _fusionLog;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    private BadImageFormatException(string fileName, string fusionLog, int hResult);
    public virtual string get_Message();
    private void SetMessageField();
    public string get_FileName();
    public virtual string ToString();
    public string get_FusionLog();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
internal static class System.BCLDebug : object {
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_registryChecked;
    internal static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_loggingNotEnabled;
    internal static bool m_perfWarnings;
    internal static bool m_correctnessWarnings;
    internal static bool m_safeHandleStackTraces;
    private static SwitchStructure[] switches;
    private static LogLevel[] levelConversions;
    internal static bool SafeHandleStackTracesEnabled { get; }
    private static BCLDebug();
    [ConditionalAttribute("_DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("_DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("_LOGGING")]
public static void Log(string message);
    [ConditionalAttribute("_LOGGING")]
public static void Log(string switchName, string message);
    private static int GetRegistryLoggingValues(Boolean& loggingEnabled, Boolean& logToConsole, Int32& logLevel, Boolean& perfWarnings, Boolean& correctnessWarnings, Boolean& safeHandleStackTraces);
    private static void CheckRegistry();
    internal static bool CheckEnabled(string switchName);
    private static bool CheckEnabled(string switchName, LogLevel level, LogSwitch& logSwitch);
    [ConditionalAttribute("_LOGGING")]
public static void Log(string switchName, LogLevel level, Object[] messages);
    [ConditionalAttribute("_LOGGING")]
public static void Trace(string switchName, string format, Object[] messages);
    [ConditionalAttribute("_DEBUG")]
internal static void Perf(bool expr, string msg);
    [ConditionalAttribute("_DEBUG")]
internal static void Correctness(bool expr, string msg);
    internal static bool get_SafeHandleStackTracesEnabled();
}
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    public static Byte[] GetBytes(float value);
    public static Byte[] GetBytes(double value);
    public static char ToChar(Byte[] value, int startIndex);
    private static short ReadInt16(Byte[] value, int startIndex);
    private static int ReadInt32(Byte[] value, int startIndex);
    private static long ReadInt64(Byte[] value, int startIndex);
    public static short ToInt16(Byte[] value, int startIndex);
    public static int ToInt32(Byte[] value, int startIndex);
    public static long ToInt64(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    public static float ToSingle(Byte[] value, int startIndex);
    public static double ToDouble(Byte[] value, int startIndex);
    private static char GetHexValue(int i);
    public static string ToString(Byte[] value, int startIndex, int length);
    private static string ToString(Byte[] value, int startIndex, int length, Char* chArray, int chArrayLength);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    public static long DoubleToInt64Bits(double value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static float Int32BitsToSingle(int value);
}
public class System.Boolean : ValueType {
    private bool m_value;
    internal static int True;
    internal static int False;
    internal static string TrueLiteral;
    internal static string FalseLiteral;
    public static string TrueString;
    public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(bool obj);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    public static bool Parse(string value);
    public static bool TryParse(string value, Boolean& result);
    private static string TrimWhiteSpaceAndNull(string value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    internal static void InternalBlockCopy(Array src, int srcOffsetBytes, Array dst, int dstOffsetBytes, int byteCount);
    internal static int IndexOfByte(Byte* src, byte value, int index, int count);
    private static bool IsPrimitiveTypeArray(Array array);
    private static byte _GetByte(Array array, int index);
    public static byte GetByte(Array array, int index);
    private static void _SetByte(Array array, int index, byte value);
    public static void SetByte(Array array, int index, byte value);
    private static int _ByteLength(Array array);
    public static int ByteLength(Array array);
    internal static void ZeroMemory(Byte* src, long len);
    internal static void Memcpy(Byte[] dest, int destIndex, Byte* src, int srcIndex, int len);
    internal static void Memcpy(Byte* pDest, int destIndex, Byte[] src, int srcIndex, int len);
    [FriendAccessAllowedAttribute]
internal static void Memcpy(Byte* dest, Byte* src, int len);
    internal static void Memmove(Byte* dest, Byte* src, ulong len);
    private static void _Memmove(Byte* dest, Byte* src, ulong len);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void __Memmove(Byte* dest, Byte* src, ulong len);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
}
public abstract class System.Buffers.ArrayPool`1 : object {
    [CompilerGeneratedAttribute]
private static ArrayPool`1<T> <Shared>k__BackingField;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    [CompilerGeneratedAttribute]
public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
}
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxNumberOfArraysPerBucket;
    private Bucket[] _buckets;
    private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
internal class System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
    private static int NumBuckets;
    private static int MaxPerCorePerArraySizeStacks;
    private static int MaxBuffersPerArraySizePerCore;
    private Int32[] _bucketArraySizes;
    private PerCoreLockedStacks[] _buckets;
    [ThreadStaticAttribute]
private static T[][] t_tlsBuckets;
    private int Id { get; }
    private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
internal class System.ByReference`1 : ValueType {
    private IntPtr _value;
    public T& Value { get; }
    public ByReference`1(T& value);
    public T& get_Value();
}
public class System.Byte : ValueType {
    private byte m_value;
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, IFormatProvider provider);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    private static byte Parse(string s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    private static bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Byte& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
public class System.Char : ValueType {
    internal char m_value;
    public static char MaxValue;
    public static char MinValue;
    private static Byte[] s_categoryForLatin1;
    internal static int UNICODE_PLANE00_END;
    internal static int UNICODE_PLANE01_START;
    internal static int UNICODE_PLANE16_END;
    internal static int HIGH_SURROGATE_START;
    internal static int LOW_SURROGATE_END;
    private static Char();
    private static bool IsLatin1(char ch);
    private static bool IsAscii(char ch);
    private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(char obj);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public static string ToString(char c);
    public static char Parse(string s);
    public static bool TryParse(string s, Char& result);
    public static bool IsDigit(char c);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    private static bool IsWhiteSpaceLatin1(char c);
    public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    public static bool IsLetterOrDigit(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(string s, int index);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    private static bool IsSeparatorLatin1(char c);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
}
public class System.CharEnumerator : object {
    private string _str;
    private int _index;
    private char _currentElement;
    private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
internal class System.CLRConfig : object {
    internal static bool GetBoolValue(string switchName);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool GetConfigBoolValue(string configSwitchName);
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    private bool _compliant;
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.ArrayList : object {
    private Object[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static int _defaultCapacity;
    private static Object[] emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public object Item { get; public set; }
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    private static ArrayList();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array, int arrayIndex);
    private void EnsureCapacity(int min);
    public virtual IEnumerator GetEnumerator();
    public virtual int IndexOf(object value);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    [FriendAccessAllowedAttribute]
public static IList ReadOnly(IList list);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual Array ToArray(Type type);
}
internal class System.Collections.Comparer : object {
    private CompareInfo m_compareInfo;
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    private static string CompareInfoName;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    private static Comparer();
    public sealed virtual int Compare(object a, object b);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Collections.CompatibleComparer : object {
    private IComparer _comparer;
    private IHashCodeProvider _hcp;
    internal IComparer Comparer { get; }
    internal IHashCodeProvider HashCodeProvider { get; }
    internal CompatibleComparer(IComparer comparer, IHashCodeProvider hashCodeProvider);
    public int Compare(object a, object b);
    public sealed virtual bool Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
    internal IComparer get_Comparer();
    internal IHashCodeProvider get_HashCodeProvider();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    private Tables modreq(System.Runtime.CompilerServices.IsVolatile) m_tables;
    internal IEqualityComparer`1<TKey> m_comparer;
    private bool m_growLockArray;
    private int m_keyRehashCount;
    private int m_budget;
    private static int DEFAULT_CONCURRENCY_MULTIPLIER;
    private static int DEFAULT_CAPACITY;
    private static int MAX_LOCK_NUMBER;
    private static bool s_isValueWriteAtomic;
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static int DefaultConcurrencyLevel { get; }
    internal ConcurrentDictionary`2(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<TKey> comparer);
    private static ConcurrentDictionary`2();
    private static bool IsValueWriteAtomic();
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool TryRemove(TKey key, TValue& value);
    private bool TryRemoveInternal(TKey key, TValue& value, bool matchValue, TValue oldValue);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    public KeyValuePair`2[] ToArray();
    private void CopyToPairs(KeyValuePair`2[] array, int index);
    private void CopyToEntries(DictionaryEntry[] array, int index);
    private void CopyToObjects(Object[] array, int index);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentDictionary`2/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private bool TryAddInternal(TKey key, TValue value, bool updateIfExists, bool acquireLock, TValue& resultingValue);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void GrowTable(Tables<TKey, TValue> tables, IEqualityComparer`1<TKey> newComparer, bool regenerateHashKeys, int rehashCount);
    private void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount);
    private static int get_DefaultConcurrencyLevel();
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private ReadOnlyCollection`1<TKey> GetKeys();
    private ReadOnlyCollection`1<TValue> GetValues();
    [ConditionalAttribute("DEBUG")]
private void Assert(bool condition);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
internal class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private static int InitialSegmentLength;
    private static int MaxSegmentLength;
    private object _crossSegmentLock;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private T[] _serializationArray;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnSerializedAttribute]
private void OnSerialized(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    private static int GetCount(Segment<T> s, int head, int tail);
    private static long GetCount(Segment<T> head, int headHead, Segment<T> tail, int tailTail);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void SnapForObservation(Segment& head, Int32& headHead, Segment& tail, Int32& tailTail);
    private T GetItemWhenAvailable(Segment<T> segment, int i);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentQueue`1/<Enumerate>d__29")]
private IEnumerator`1<T> Enumerate(Segment<T> head, int headHead, Segment<T> tail, int tailTail);
    private static int RoundUpToPowerOf2(int i);
    public void Enqueue(T item);
    private void EnqueueSlow(T item);
    public bool TryDequeue(T& result);
    private bool TryDequeueSlow(T& item);
    public bool TryPeek(T& result);
    private bool TryPeek(T& result, bool resultUsed);
    public void Clear();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
internal class System.Collections.Concurrent.ConcurrentStack`1 : object {
    private Node modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private static int BACKOFF_MAX_YIELDS;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(T[] array, int index);
    public void Push(T item);
    private void PushCore(Node<T> head, Node<T> tail);
    public bool TryPop(T& result);
    private bool TryPopCore(T& result);
    private int TryPopCore(int count, Node& poppedHead);
    public sealed virtual T[] ToArray();
    private List`1<T> ToList();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentStack`1/<GetEnumerator>d__20")]
private IEnumerator`1<T> GetEnumerator(Node<T> head);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual T[] ToArray();
}
[DebuggerDisplayAttribute("Head = {Head}, Tail = {Tail}")]
internal class System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
    public int Head;
    public int Tail;
}
internal class System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> m_collection;
}
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.EmptyReadOnlyDictionaryInternal : object {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`1")]
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    private static IArraySortHelper`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultArraySortHelper;
    public static IArraySortHelper`1<T> Default { get; }
    public static IArraySortHelper`1<T> get_Default();
    private static IArraySortHelper`1<T> CreateArraySortHelper();
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(T[] keys, int index, int length, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`2")]
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    private static IArraySortHelper`2 modreq(System.Runtime.CompilerServices.IsVolatile) defaultArraySortHelper;
    public static IArraySortHelper`2<TKey, TValue> Default { get; }
    public static IArraySortHelper`2<TKey, TValue> get_Default();
    private static IArraySortHelper`2<TKey, TValue> CreateArraySortHelper();
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, IComparer`1<TKey> comparer, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
}
internal class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte b);
    internal virtual int IndexOf(Byte[] array, byte value, int startIndex, int count);
    internal virtual int LastIndexOf(Byte[] array, byte value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectComparer`1")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    [CompilerGeneratedAttribute]
private static Comparer`1<T> <Default>k__BackingField;
    public static Comparer`1<T> Default { get; }
    private static Comparer`1();
    [CompilerGeneratedAttribute]
public static Comparer`1<T> get_Default();
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    public abstract virtual int Compare(T x, T y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal static class System.Collections.Generic.ComparerHelpers : object {
    internal static object CreateDefaultComparer(Type type);
    private static object TryCreateNullableComparer(RuntimeType nullableType);
    private static object TryCreateEnumComparer(RuntimeType enumType);
    internal static object CreateDefaultEqualityComparer(Type type);
    private static object TryCreateNullableEqualityComparer(RuntimeType nullableType);
    private static object TryCreateEnumEqualityComparer(RuntimeType enumType);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] buckets;
    private Entry[] entries;
    private int count;
    private int version;
    private int freeList;
    private int freeCount;
    private IEqualityComparer`1<TKey> comparer;
    private KeyCollection<TKey, TValue> keys;
    private ValueCollection<TKey, TValue> values;
    private object _syncRoot;
    private static string VersionName;
    private static string HashSizeName;
    private static string KeyValuePairsName;
    private static string ComparerName;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private int FindEntry(TKey key);
    private void Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    public virtual void OnDeserialization(object sender);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public TValue GetValueOrDefault(TKey key);
    public TValue GetValueOrDefault(TKey key, TValue defaultValue);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectEqualityComparer`1")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<T> <Default>k__BackingField;
    public static EqualityComparer`1<T> Default { get; }
    private static EqualityComparer`1();
    [CompilerGeneratedAttribute]
public static EqualityComparer`1<T> get_Default();
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(T[] array, int index, int length, T value);
    private static void SwapIfGreaterWithItems(T[] keys, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi);
    private static void Heapsort(T[] keys, int lo, int hi);
    private static void DownHeap(T[] keys, int i, int n, int lo);
    private static void InsertionSort(T[] keys, int lo, int hi);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi);
}
internal class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface System.Collections.Generic.IArraySortHelper`1 {
    public abstract virtual void Sort(TKey[] keys, int index, int length, IComparer`1<TKey> comparer);
    public abstract virtual int BinarySearch(TKey[] keys, int index, int length, TKey value, IComparer`1<TKey> comparer);
}
internal interface System.Collections.Generic.IArraySortHelper`2 {
    public abstract virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
internal enum System.Collections.Generic.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
internal class System.Collections.Generic.Int32EnumComparer`1 : Comparer`1<T> {
    private Int32EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Collections.Generic.Int64EnumComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal static class System.Collections.Generic.IntrospectiveSortUtilities : object {
    internal static int IntrosortSizeThreshold;
    internal static int FloorLog2(int n);
    internal static void ThrowOrIgnoreBadComparer(object comparer);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
    internal static string PairToString(object key, object value);
}
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.List`1 : object {
    private static int _defaultCapacity;
    private T[] _items;
    private int _size;
    private int _version;
    private object _syncRoot;
    private static T[] _emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    private void AddEnumerable(IEnumerable`1<T> enumerable);
}
internal class System.Collections.Generic.LongEnumEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
}
internal class System.Collections.Generic.Mscorlib_CollectionDebugView`1 : object {
    private ICollection`1<T> collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public Mscorlib_CollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryDebugView`2 : object {
    private IDictionary`2<K, V> dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public Mscorlib_DictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public Mscorlib_DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public Mscorlib_DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.NonRandomizedStringEqualityComparer : GenericEqualityComparer`1<string> {
    private static IEqualityComparer`1<string> s_nonRandomizedComparer;
    internal static IEqualityComparer`1<string> Default { get; }
    internal static IEqualityComparer`1<string> get_Default();
    public virtual int GetHashCode(string obj);
}
internal class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    public virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    public virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public virtual int GetHashCode(Nullable`1<T> obj);
    internal virtual int IndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    internal virtual int LastIndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Collections.Generic.SByteEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    public virtual int GetHashCode(T obj);
}
internal class System.Collections.Generic.ShortEnumEqualityComparer`1 : EnumEqualityComparer`1<T> {
    public virtual int GetHashCode(T obj);
}
internal class System.Collections.Generic.UInt32EnumComparer`1 : Comparer`1<T> {
    private UInt32EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Collections.Generic.UInt64EnumComparer`1 : Comparer`1<T> {
    private UInt64EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FriendAccessAllowedAttribute]
internal static class System.Collections.HashHelpers : object {
    public static int HashCollisionThreshold;
    public static bool s_UseRandomizedStringHashing;
    public static Int32[] primes;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_SerializationInfoTable;
    public static int MaxPrimeArrayLength;
    internal static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    private static HashHelpers();
    internal static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Hashtable : object {
    internal static int HashPrime;
    private static int InitialSize;
    private static string LoadFactorName;
    private static string VersionName;
    private static string ComparerName;
    private static string HashCodeProviderName;
    private static string HashSizeName;
    private static string KeysName;
    private static string ValuesName;
    private static string KeyComparerName;
    private bucket[] buckets;
    private int count;
    private int occupancy;
    private int loadsize;
    private float loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isWriterInProgress;
    private ICollection keys;
    private ICollection values;
    private IEqualityComparer _keycomparer;
    private object _syncRoot;
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool trash);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    public Hashtable(IEqualityComparer equalityComparer);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize, bool forceNewHashCode);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode);
    public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
internal interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.ListDictionaryInternal : object {
    private DictionaryNode head;
    private int version;
    private int count;
    private object _syncRoot;
    public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.Collection`1 : object {
    private IList`1<T> items;
    private object _syncRoot;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static bool IsCompatibleObject(object value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_CollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private IList`1<T> list;
    private object _syncRoot;
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> m_dictionary;
    private object m_syncRoot;
    private KeyCollection<TKey, TValue> m_keys;
    private ValueCollection<TKey, TValue> m_values;
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
internal static class System.Collections.ObjectModel.ReadOnlyDictionaryHelpers : object {
    internal static void CopyToNonGenericICollectionHelper(ICollection`1<T> collection, Array array, int index);
}
internal static class System.CommonlyUsedGenericInstantiations : object {
    private static CommonlyUsedGenericInstantiations();
    private static T NullableHelper();
    private static void SZArrayHelper(SZArrayHelper oSZArrayHelper);
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper>d__3`1")]
private static void AsyncHelper();
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper2>d__4`1")]
private static Task`1<string> AsyncHelper2();
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper3>d__5")]
private static Task AsyncHelper3();
    private static void CommonlyUsedWinRTRedirectedInterfaceStubs();
    private static void WinRT_IEnumerable(IterableToEnumerableAdapter iterableToEnumerableAdapter, EnumerableToIterableAdapter enumerableToIterableAdapter, IIterable`1<T> iterable);
    private static void WinRT_IList(VectorToListAdapter vectorToListAdapter, VectorToCollectionAdapter vectorToCollectionAdapter, ListToVectorAdapter listToVectorAdapter, IVector`1<T> vector);
    private static void WinRT_IReadOnlyCollection(VectorViewToReadOnlyCollectionAdapter vectorViewToReadOnlyCollectionAdapter);
    private static void WinRT_IReadOnlyList(IVectorViewToIReadOnlyListAdapter vectorToListAdapter, IReadOnlyListToIVectorViewAdapter listToVectorAdapter, IVectorView`1<T> vectorView);
    private static void WinRT_IDictionary(MapToDictionaryAdapter mapToDictionaryAdapter, MapToCollectionAdapter mapToCollectionAdapter, DictionaryToMapAdapter dictionaryToMapAdapter, IMap`2<K, V> map);
    private static void WinRT_IReadOnlyDictionary(IMapViewToIReadOnlyDictionaryAdapter mapToDictionaryAdapter, IReadOnlyDictionaryToIMapViewAdapter dictionaryToMapAdapter, IMapView`2<K, V> mapView, MapViewToReadOnlyCollectionAdapter mapViewToReadOnlyCollectionAdapter);
    private static void WinRT_Nullable();
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal static class System.CompatibilitySwitches : object {
    private static bool s_AreSwitchesSet;
    public static bool IsCompatibilityBehaviorDefined { get; }
    public static bool get_IsCompatibilityBehaviorDefined();
    internal static void InitializeSwitches();
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    private object _value;
    public object Value { get; }
    public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    private EditorBrowsableState browsableState;
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
public static class System.Convert : object {
    internal static Type[] ConvertTypes;
    private static Type EnumType;
    internal static Char[] base64Table;
    private static int base64LineBreakPosition;
    public static object DBNull;
    private static Convert();
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    private static void ThrowCharOverflowException();
    private static void ThrowByteOverflowException();
    private static void ThrowSByteOverflowException();
    private static void ThrowInt16OverflowException();
    private static void ThrowUInt16OverflowException();
    private static void ThrowInt32OverflowException();
    private static void ThrowUInt32OverflowException();
    private static void ThrowInt64OverflowException();
    private static void ThrowUInt64OverflowException();
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    public static string ToString(byte value, int toBase);
    public static string ToString(short value, int toBase);
    public static string ToString(int value, int toBase);
    public static string ToString(long value, int toBase);
    public static string ToBase64String(Byte[] inArray);
    public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    private static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks);
    private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
    public static Byte[] FromBase64String(string s);
    public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    private static Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength);
    private static int FromBase64_Decode(Char* startInputPtr, int inputLength, Byte* startDestPtr, int destLength);
    private static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
internal class System.CoreLib : object {
    public static string Name;
    public static string FixupCoreLibName(string strToFixup);
}
internal class System.CrossAppDomainMarshaledException : SystemException {
    public CrossAppDomainMarshaledException(string message, int errorCode);
    internal virtual string InternalToString();
}
internal class System.CtorDelegate : MulticastDelegate {
    public CtorDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.CultureAwareComparer : StringComparer {
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    internal CultureAwareComparer(CultureInfo culture, bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Currency : ValueType {
    internal long m_value;
    public Currency(decimal value);
    internal Currency(long value, int ignored);
    public static Currency FromOACurrency(long cy);
    public long ToOACurrency();
    public static decimal ToDecimal(Currency c);
    private static void FCallToDecimal(Decimal& result, Currency c);
}
[ObsoleteAttribute("System.CurrentSystemTimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo.Local instead.")]
internal class System.CurrentSystemTimeZone : TimeZone {
    private Hashtable m_CachedDaylightChanges;
    private long m_ticksOffset;
    private string m_standardName;
    private string m_daylightName;
    public string StandardName { get; }
    public string DaylightName { get; }
    private DaylightTime GetCachedDaylightChanges(int year);
    public virtual string get_StandardName();
    public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DaylightTime GetDaylightChanges(int year);
    private static DaylightTime CreateDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
}
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    internal DataMisalignedException(SerializationInfo info, StreamingContext context);
}
public class System.DateTime : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    internal static int DaysTo1970;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static long MaxMillis;
    private static long TicksTo1970;
    private static long FileTimeOffset;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static double OADateMinAsDouble;
    private static double OADateMaxAsDouble;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    private static ulong TicksMask;
    private static ulong FlagsMask;
    private static ulong LocalMask;
    private static long TicksCeiling;
    private static ulong KindUnspecified;
    private static ulong KindUtc;
    private static ulong KindLocal;
    private static ulong KindLocalAmbiguousDst;
    private static int KindShift;
    private static string TicksField;
    private static string DateDataField;
    private ulong _dateData;
    public static DateTime UtcNow { get; }
    internal long InternalTicks { get; }
    private ulong InternalKind { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public DateTime(long ticks);
    private DateTime(ulong dateData);
    public DateTime(long ticks, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    private DateTime(SerializationInfo info, StreamingContext context);
    private static DateTime();
    public static DateTime get_UtcNow();
    internal static long GetSystemTimeAsFileTime();
    internal long get_InternalTicks();
    private ulong get_InternalKind();
    public DateTime Add(TimeSpan value);
    private DateTime Add(double value, int scale);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    private static long DateToTicks(int year, int month, int day);
    private static long TimeToTicks(int hour, int minute, int second);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    internal static DateTime FromBinaryRaw(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    public DateTime get_Date();
    private int GetDatePart(int part);
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public virtual int GetHashCode();
    public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private static double TicksToOADate(long value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    internal DateTime ToLocalTime(bool throwOnOverflow);
    public string ToLongDateString();
    public string ToLongTimeString();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
}
internal static class System.DateTimeFormat : object {
    internal static int MaxSecondsFractionDigits;
    internal static TimeSpan NullOffset;
    internal static Char[] allStandardFormats;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    private static int DEFAULT_ALL_DATETIMES_SIZE;
    internal static DateTimeFormatInfo InvariantFormatInfo;
    internal static String[] InvariantAbbreviatedMonthNames;
    internal static String[] InvariantAbbreviatedDayNames;
    internal static string Gmt;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
    private static void HebrewFormatDigits(StringBuilder outputBuffer, int digits);
    internal static int ParseRepeatPattern(string format, int pos, char patternChar);
    private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
    private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
    private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
    internal static int ParseQuoteString(string format, int pos, StringBuilder result);
    internal static int ParseNextChar(string format, int pos);
    private static bool IsUseGenitiveForm(string format, int index, int tokenLen, char patternToMatch);
    private static string FormatCustomized(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset);
    private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, string format, int tokenLen, bool timeOnly, StringBuilder result);
    private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result);
    internal static string GetRealFormat(string format, DateTimeFormatInfo dtfi);
    private static string ExpandPredefinedFormat(string format, DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan& offset);
    internal static string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi);
    internal static string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset);
    internal static string FastFormatRfc1123(DateTime dateTime, TimeSpan offset, DateTimeFormatInfo dtfi);
    internal static string FastFormatRoundtrip(DateTime dateTime, TimeSpan offset);
    private static void AppendHHmmssTimeOfDay(StringBuilder result, DateTime dateTime);
    internal static void AppendNumber(StringBuilder builder, long val, int digits);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
    internal static void InvalidFormatForLocal(string format, DateTime dateTime);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
public class System.DateTimeOffset : ValueType {
    internal static long MaxOffset;
    internal static long MinOffset;
    private static long UnixEpochTicks;
    private static long UnixEpochSeconds;
    private static long UnixEpochMilliseconds;
    internal static long UnixMinSeconds;
    internal static long UnixMaxSeconds;
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    private DateTime _dateTime;
    private short _offsetMinutes;
    public static DateTimeOffset Now { get; }
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    private DateTime ClockDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    private DateTimeOffset(SerializationInfo info, StreamingContext context);
    private static DateTimeOffset();
    public static DateTimeOffset get_Now();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    private DateTime get_ClockDateTime();
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public long ToUnixTimeSeconds();
    public long ToUnixTimeMilliseconds();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    private static short ValidateOffset(TimeSpan offset);
    private static DateTime ValidateDate(DateTime dateTime, TimeSpan offset);
    private static DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
}
internal static class System.DateTimeParse : object {
    internal static int MaxDateTimeNumberDigits;
    internal static MatchNumberDelegate m_hebrewNumberParser;
    private static DS[][] dateParsingStates;
    internal static string GMTName;
    internal static string ZuluName;
    private static int ORDER_YMD;
    private static int ORDER_MDY;
    private static int ORDER_DMY;
    private static int ORDER_YDM;
    private static int ORDER_YM;
    private static int ORDER_MY;
    private static int ORDER_MD;
    private static int ORDER_DM;
    private static DateTimeParse();
    internal static DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(string s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    private static bool MatchWord(__DTString& str, string target);
    private static bool GetTimeZoneName(__DTString& str);
    internal static bool IsDigit(char ch);
    private static bool ParseFraction(__DTString& str, Double& result);
    private static bool ParseTimeZone(__DTString& str, TimeSpan& result);
    private static bool HandleTimeZone(__DTString& str, DateTimeResult& result);
    private static bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles);
    private static bool VerifyValidPunctuation(__DTString& str);
    private static bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear);
    private static bool SetDateYMD(DateTimeResult& result, int year, int month, int day);
    private static bool SetDateMDY(DateTimeResult& result, int month, int day, int year);
    private static bool SetDateDMY(DateTimeResult& result, int day, int month, int year);
    private static bool SetDateYDM(DateTimeResult& result, int year, int day, int month);
    private static void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles);
    private static bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw);
    private static bool AdjustHour(Int32& hour, TM timeMark);
    private static bool GetTimeOfN(DateTimeFormatInfo dtfi, DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNN(DateTimeFormatInfo dtfi, DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNNN(DateTimeFormatInfo dtfi, DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok);
    internal static bool ProcessHebrewTerminalState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminaltState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    private static bool DetermineTimeZoneAdjustments(DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly);
    private static bool DateTimeOffsetTimeZonePostProcessing(DateTimeResult& result, DateTimeStyles styles);
    private static bool AdjustTimeZoneToUniversal(DateTimeResult& result);
    private static bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly);
    private static bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    private static bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result);
    private static bool ParseSign(__DTString& str, Boolean& result);
    private static bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result);
    private static bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result);
    private static DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles);
    private static bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles);
    private static string ExpandPredefinedFormat(string format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result);
    internal static bool TryParseQuoteString(string format, int pos, StringBuilder result, Int32& returnValue);
    private static bool DoStrictParse(string s, string formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result);
    private static Exception GetDateTimeParseException(DateTimeResult& result);
    [ConditionalAttribute("_LOGGING")]
internal static void LexTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
internal static void PTSTraceExit(DS dps, bool passed);
    [ConditionalAttribute("_LOGGING")]
internal static void TPTraceExit(string message, DS dps);
    [ConditionalAttribute("_LOGGING")]
internal static void DTFITrace(DateTimeFormatInfo dtfi);
}
internal class System.DateTimeRawInfo : ValueType {
    private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool hasSameDateAndTimeSeparators;
    internal void Init(Int32* numberBuffer);
    internal void AddNumber(int value);
    internal int GetNumber(int index);
}
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal string failureMessageID;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal void Init();
    internal void SetDate(int year, int month, int day);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
public class System.DBNull : object {
    public static DBNull Value;
    private DBNull(SerializationInfo info, StreamingContext context);
    private static DBNull();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NonVersionableAttribute]
public class System.Decimal : ValueType {
    private static int SignMask;
    private static byte DECIMAL_NEG;
    private static byte DECIMAL_ADD;
    private static int ScaleMask;
    private static int ScaleShift;
    private static int MaxInt32Scale;
    private static UInt32[] Powers10;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("27", "128", "0", "0", "1")]
private static decimal NearNegativeZero;
    [DecimalConstantAttribute("27", "0", "0", "0", "1")]
private static decimal NearPositiveZero;
    private int flags;
    private int hi;
    private int lo;
    private int mid;
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public Decimal(float value);
    public Decimal(double value);
    internal Decimal(Currency value);
    public Decimal(Int32[] bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private Decimal(int lo, int mid, int hi, int flags);
    private static Decimal();
    public static long ToOACurrency(decimal value);
    public static decimal FromOACurrency(long cy);
    private void SetBits(Int32[] bits);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    internal static decimal Abs(decimal d);
    public static decimal Add(decimal d1, decimal d2);
    private static void FCallAddSub(Decimal& d1, Decimal& d2, byte bSign);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    private static int FCallCompare(Decimal& d1, Decimal& d2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    private static void FCallDivide(Decimal& d1, Decimal& d2);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(decimal value);
    public virtual int GetHashCode();
    public static bool Equals(decimal d1, decimal d2);
    public static decimal Floor(decimal d);
    private static void FCallFloor(Decimal& d);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static Int32[] GetBits(decimal d);
    internal static void GetBytes(decimal d, Byte[] buffer);
    internal static decimal ToDecimal(Byte[] buffer);
    private static void InternalAddUInt32RawUnchecked(Decimal& value, UInt32 i);
    private static UInt32 InternalDivRemUInt32(Decimal& value, UInt32 divisor);
    private static void InternalRoundFromZero(Decimal& d, int decimalCount);
    internal static decimal Max(decimal d1, decimal d2);
    internal static decimal Min(decimal d1, decimal d2);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Multiply(decimal d1, decimal d2);
    private static void FCallMultiply(Decimal& d1, Decimal& d2);
    public static decimal Negate(decimal d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static void FCallRound(Decimal& d, int decimals);
    public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    internal static Currency ToCurrency(decimal d);
    private static void FCallToCurrency(Currency& result, decimal d);
    public static double ToDouble(decimal d);
    internal static int FCallToInt32(decimal d);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static float ToSingle(decimal d);
    public static decimal Truncate(decimal d);
    private static void FCallTruncate(Decimal& d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_Increment(decimal d);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Division(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal class System.DefaultBinder : Binder {
    private static bool CanChangePrimitive(Type source, Type target);
    private static bool CanChangePrimitiveObjectToType(object source, Type type);
    private static bool CanConvertPrimitive(RuntimeType source, RuntimeType target);
    private static bool CanConvertPrimitiveObjectToType(object source, RuntimeType type);
    public sealed virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    public sealed virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public sealed virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    public static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    private static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
public abstract class System.Delegate : object {
    internal object _target;
    internal object _methodBase;
    internal IntPtr _methodPtr;
    internal IntPtr _methodPtrAux;
    public MethodInfo Method { get; }
    public object Target { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    public object DynamicInvoke(Object[] args);
    protected virtual object DynamicInvokeImpl(Object[] args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Combine(Delegate[] delegates);
    public virtual Delegate[] GetInvocationList();
    public MethodInfo get_Method();
    protected virtual MethodInfo GetMethodImpl();
    public object get_Target();
    public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    protected virtual Delegate CombineImpl(Delegate d);
    protected virtual Delegate RemoveImpl(Delegate d);
    public virtual object Clone();
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static Delegate CreateDelegateNoSecurityCheck(Type type, object target, RuntimeMethodHandle method);
    internal static Delegate CreateDelegateNoSecurityCheck(RuntimeType type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    internal static Delegate CreateDelegateInternal(RuntimeType rtType, RuntimeMethodInfo rtMethod, object firstArgument, DelegateBindingFlags flags, StackCrawlMark& stackMark);
    internal static Delegate UnsafeCreateDelegate(RuntimeType rtType, RuntimeMethodInfo rtMethod, object firstArgument, DelegateBindingFlags flags);
    private bool BindToMethodName(object target, RuntimeType methodType, string method, DelegateBindingFlags flags);
    private bool BindToMethodInfo(object target, IRuntimeMethodInfo method, RuntimeType methodType, DelegateBindingFlags flags);
    private static MulticastDelegate InternalAlloc(RuntimeType type);
    internal static MulticastDelegate InternalAllocLike(Delegate d);
    internal static bool InternalEqualTypes(object a, object b);
    private void DelegateConstruct(object target, IntPtr slot);
    internal IntPtr GetMulticastInvoke();
    internal IntPtr GetInvokeMethod();
    internal IRuntimeMethodInfo FindMethodHandle();
    internal static bool InternalEqualMethodHandles(Delegate left, Delegate right);
    internal IntPtr AdjustTarget(object target, IntPtr methodPtr);
    internal IntPtr GetCallStub(IntPtr methodPtr);
    internal virtual object GetTarget();
    internal static bool CompareUnmanagedFunctionPtrs(Delegate d1, Delegate d2);
}
internal enum System.DelegateBindingFlags : Enum {
    public int value__;
    public static DelegateBindingFlags StaticMethodOnly;
    public static DelegateBindingFlags InstanceMethodOnly;
    public static DelegateBindingFlags OpenDelegateOnly;
    public static DelegateBindingFlags ClosedDelegateOnly;
    public static DelegateBindingFlags NeverCloseOverNull;
    public static DelegateBindingFlags CaselessMatching;
    public static DelegateBindingFlags SkipSecurityChecks;
    public static DelegateBindingFlags RelaxedSignature;
}
internal class System.DelegateSerializationHolder : object {
    private DelegateEntry m_delegateEntry;
    private MethodInfo[] m_methods;
    private DelegateSerializationHolder(SerializationInfo info, StreamingContext context);
    internal static DelegateEntry GetDelegateSerializationInfo(SerializationInfo info, Type delegateType, object target, MethodInfo method, int targetIndex);
    private void ThrowInsufficientState(string field);
    private DelegateEntry OldDelegateWireFormat(SerializationInfo info, StreamingContext context);
    private Delegate GetDelegate(DelegateEntry de, int index);
    public sealed virtual object GetRealObject(StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal static class System.Diagnostics.Assert : object {
    internal static int COR_E_FAILFAST;
    private static AssertFilter Filter;
    private static Assert();
    internal static void Check(bool condition, string conditionString, string message);
    internal static void Fail(string conditionString, string message);
    internal static void Fail(string conditionString, string message, string windowTitle, int exitCode);
    internal static void Fail(string conditionString, string message, int exitCode, TraceFormat stackTraceFormat);
    internal static void Fail(string conditionString, string message, string windowTitle, int exitCode, TraceFormat stackTraceFormat, int numStackFramesToSkip);
    internal static int ShowDefaultAssertDialog(string conditionString, string message, string stackTrace, string windowTitle);
}
internal abstract class System.Diagnostics.AssertFilter : object {
    public abstract virtual AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle);
}
internal enum System.Diagnostics.AssertFilters : Enum {
    public int value__;
    public static AssertFilters FailDebug;
    public static AssertFilters FailIgnore;
    public static AssertFilters FailTerminate;
    public static AssertFilters FailContinueFilter;
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public SuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConditionString>k__BackingField;
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    [CompilerGeneratedAttribute]
public string get_ConditionString();
}
public static class System.Diagnostics.Contracts.Contract : object {
    [ThreadStaticAttribute]
private static bool _assertingMustUseRewriter;
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition, string userMessage);
    public static void Requires(bool condition);
    public static void Requires(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    public static T Result();
    public static T ValueAtReturn(T& value);
    public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EndContractBlock();
    [DebuggerNonUserCodeAttribute]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
    public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
[AttributeUsageAttribute("5124")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    private Type _typeWithContracts;
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    private Type _typeIAmAContractFor;
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
internal class System.Diagnostics.Contracts.ContractException : Exception {
    private ContractFailureKind _Kind;
    private string _UserMessage;
    private string _Condition;
    public ContractFailureKind Kind { get; }
    public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    private ContractException(SerializationInfo info, StreamingContext context);
    public ContractFailureKind get_Kind();
    public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    private ContractFailureKind _failureKind;
    private string _message;
    private string _condition;
    private Exception _originalException;
    private bool _handled;
    private bool _unwind;
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    public void SetHandled();
    public bool get_Unwind();
    public void SetUnwind();
}
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    private string _category;
    private string _setting;
    private bool _enabled;
    private string _value;
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    public string get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("256")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    private string _publicName;
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("237")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    private bool _value;
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[ObsoleteAttribute("Use the ContractHelper class in the System.Runtime.CompilerServices namespace instead.")]
public static class System.Diagnostics.Contracts.Internal.ContractHelper : object {
    [DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("6884")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
public static class System.Diagnostics.Debug : object {
    private static object s_lock;
    [ThreadStaticAttribute]
private static int s_indentLevel;
    private static int s_indentSize;
    private static object s_ForLock;
    private static bool s_needIndent;
    private static string s_indentString;
    internal static Action`3<string, string, string> s_ShowAssertDialog;
    internal static Action`1<string> s_WriteCore;
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static Debug();
    private static void ShowAssertDialog(string stackTrace, string message, string detailMessage);
    private static void WriteCore(string message);
    private static void WriteToDebugger(string message);
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    private static string FormatAssert(string stackTrace, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
    private static string GetIndentString();
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    private DebuggingModes m_debuggingModes;
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    public DebuggingModes get_DebuggingFlags();
}
public class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    private static Debugger();
    public static void Break();
    private static void BreakCanThrow();
    private static void BreakInternal();
    public static bool Launch();
    private static void NotifyOfCrossThreadDependencySlow();
    public static void NotifyOfCrossThreadDependency();
    private static bool LaunchInternal();
    public static bool get_IsAttached();
    public static void Log(int level, string category, string message);
    public static bool IsLogging();
    private static void CustomNotification(ICustomDebuggerNotification data);
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    private DebuggerBrowsableState state;
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    private string name;
    private string value;
    private string type;
    private string targetName;
    private Type target;
    public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    public string get_Value();
    public string get_Name();
    public void set_Name(string value);
    public string get_Type();
    public void set_Type(string value);
    public void set_Target(Type value);
    public Type get_Target();
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    private string typeName;
    private string targetName;
    private Type target;
    public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerTypeProxyAttribute(Type type);
    public DebuggerTypeProxyAttribute(string typeName);
    public string get_ProxyTypeName();
    public void set_Target(Type value);
    public Type get_Target();
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
internal class System.Diagnostics.DefaultFilter : AssertFilter {
    public virtual AssertFilters AssertFailure(string condition, string message, StackTrace location, TraceFormat stackTraceFormat, string windowTitle);
}
internal class System.Diagnostics.EditAndContinueHelper : object {
    private object _objectReference;
}
internal interface System.Diagnostics.ICustomDebuggerNotification {
}
internal static class System.Diagnostics.Log : object {
    internal static Hashtable m_Hashtable;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_fConsoleDeviceEnabled;
    private static LogSwitchLevelHandler modreq(System.Runtime.CompilerServices.IsVolatile) _LogSwitchLevelHandler;
    private static object locker;
    public static LogSwitch GlobalSwitch;
    public static bool IsConsoleEnabled { get; public set; }
    private static Log();
    internal static void InvokeLogSwitchLevelHandlers(LogSwitch ls, LoggingLevels newLevel);
    public static bool get_IsConsoleEnabled();
    public static void set_IsConsoleEnabled(bool value);
    public static void LogMessage(LoggingLevels level, LogSwitch logswitch, string message);
    public static void Trace(LogSwitch logswitch, string message);
    public static void Trace(string message);
    internal static void AddLogSwitch(LogSwitch logSwitch);
    internal static void ModifyLogSwitch(int iNewLevel, string strSwitchName, string strParentName);
}
internal enum System.Diagnostics.LoggingLevels : Enum {
    public int value__;
    public static LoggingLevels TraceLevel0;
    public static LoggingLevels TraceLevel1;
    public static LoggingLevels TraceLevel2;
    public static LoggingLevels TraceLevel3;
    public static LoggingLevels TraceLevel4;
    public static LoggingLevels StatusLevel0;
    public static LoggingLevels StatusLevel1;
    public static LoggingLevels StatusLevel2;
    public static LoggingLevels StatusLevel3;
    public static LoggingLevels StatusLevel4;
    public static LoggingLevels WarningLevel;
    public static LoggingLevels ErrorLevel;
    public static LoggingLevels PanicLevel;
}
internal class System.Diagnostics.LogSwitch : object {
    internal string strName;
    internal string strDescription;
    private LogSwitch ParentSwitch;
    internal LoggingLevels modreq(System.Runtime.CompilerServices.IsVolatile) iLevel;
    internal LoggingLevels modreq(System.Runtime.CompilerServices.IsVolatile) iOldLevel;
    public string Name { get; }
    public LoggingLevels MinimumLevel { get; public set; }
    public LogSwitch(string name, string description, LogSwitch parent);
    internal LogSwitch(string name, string description);
    public virtual string get_Name();
    public virtual LoggingLevels get_MinimumLevel();
    public virtual void set_MinimumLevel(LoggingLevels value);
    public virtual bool CheckLevel(LoggingLevels level);
    public static LogSwitch GetSwitch(string name);
}
internal class System.Diagnostics.LogSwitchLevelHandler : MulticastDelegate {
    public LogSwitchLevelHandler(object object, IntPtr method);
    public virtual void Invoke(LogSwitch ls, LoggingLevels newLevel);
    public virtual IAsyncResult BeginInvoke(LogSwitch ls, LoggingLevels newLevel, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Diagnostics.StackFrame : object {
    private MethodBase method;
    private int offset;
    private int ILOffset;
    private string strFileName;
    private int iLineNumber;
    private int iColumnNumber;
    [OptionalFieldAttribute]
private bool fIsLastFrameFromForeignExceptionStackTrace;
    public static int OFFSET_UNKNOWN;
    public StackFrame(bool fNeedFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool fNeedFileInfo);
    internal StackFrame(bool DummyFlag1, bool DummyFlag2);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    internal void InitMembers();
    internal virtual void SetMethodBase(MethodBase mb);
    internal virtual void SetOffset(int iOffset);
    internal virtual void SetILOffset(int iOffset);
    internal virtual void SetFileName(string strFName);
    internal virtual void SetLineNumber(int iLine);
    internal virtual void SetColumnNumber(int iCol);
    internal virtual void SetIsLastFrameFromForeignExceptionStackTrace(bool fIsLastFrame);
    internal virtual bool GetIsLastFrameFromForeignExceptionStackTrace();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual int GetILOffset();
    public virtual string GetFileName();
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    public virtual string ToString();
    private void BuildStackFrame(int skipFrames, bool fNeedFileInfo);
}
internal class System.Diagnostics.StackFrameHelper : object {
    private Thread targetThread;
    private Int32[] rgiOffset;
    private Int32[] rgiILOffset;
    private MethodBase[] rgMethodBase;
    private object dynamicMethods;
    private IntPtr[] rgMethodHandle;
    private String[] rgAssemblyPath;
    private IntPtr[] rgLoadedPeAddress;
    private Int32[] rgiLoadedPeSize;
    private IntPtr[] rgInMemoryPdbAddress;
    private Int32[] rgiInMemoryPdbSize;
    private Int32[] rgiMethodToken;
    private String[] rgFilename;
    private Int32[] rgiLineNumber;
    private Int32[] rgiColumnNumber;
    [OptionalFieldAttribute]
private Boolean[] rgiLastFrameFromForeignExceptionStackTrace;
    private GetSourceLineInfoDelegate getSourceLineInfo;
    private int iFrameCount;
    private static Type s_symbolsType;
    private static MethodInfo s_symbolsMethodInfo;
    [ThreadStaticAttribute]
private static int t_reentrancy;
    public StackFrameHelper(Thread target);
    private static StackFrameHelper();
    internal void InitializeSourceInfo(int iSkip, bool fNeedFileInfo, Exception exception);
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual MethodBase GetMethodBase(int i);
    public virtual int GetOffset(int i);
    public virtual int GetILOffset(int i);
    public virtual string GetFilename(int i);
    public virtual int GetLineNumber(int i);
    public virtual int GetColumnNumber(int i);
    public virtual bool IsLastFrameFromForeignExceptionStackTrace(int i);
    public virtual int GetNumberOfFrames();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnSerializedAttribute]
private void OnSerialized(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
public class System.Diagnostics.StackTrace : object {
    private StackFrame[] frames;
    private int m_iNumOfFrames;
    public static int METHODS_TO_SKIP;
    private int m_iMethodsToSkip;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    internal static void GetStackFramesInternal(StackFrameHelper sfh, int iSkip, bool fNeedFileInfo, Exception e);
    internal static int CalculateFramesToSkip(StackFrameHelper StackF, int iNumFrames);
    private void CaptureStackTrace(int iSkip, bool fNeedFileInfo, Thread targetThread, Exception e);
    public virtual int get_FrameCount();
    public virtual StackFrame GetFrame(int index);
    public virtual StackFrame[] GetFrames();
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
    private static string GetManagedStackTraceStringHelper(bool fNeedFileInfo);
}
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetSource(Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
}
internal interface System.Diagnostics.SymbolStore.ISymbolWriter {
    public abstract virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void CloseMethod();
    public abstract virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual int OpenScope(int startOffset);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public abstract virtual void UsingNamespace(string fullName);
}
internal enum System.Diagnostics.SymbolStore.SymAddressKind : Enum {
    public int value__;
    public static SymAddressKind ILOffset;
    public static SymAddressKind NativeRVA;
    public static SymAddressKind NativeRegister;
    public static SymAddressKind NativeRegisterRelative;
    public static SymAddressKind NativeOffset;
    public static SymAddressKind NativeRegisterRegister;
    public static SymAddressKind NativeRegisterStack;
    public static SymAddressKind NativeStackRegister;
    public static SymAddressKind BitField;
    public static SymAddressKind NativeSectionOffset;
}
internal class System.Diagnostics.SymbolStore.SymbolToken : ValueType {
    internal int m_token;
    public SymbolToken(int val);
    public int GetToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SymbolToken obj);
}
internal class System.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    private static ushort MAX_ACTIVITY_DEPTH;
    public static ActivityTracker Instance { get; }
    private Guid CurrentActivityId { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId);
    public void Enable();
    public static ActivityTracker get_Instance();
    private Guid get_CurrentActivityId();
    private ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class System.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class System.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
internal class System.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddBinary(string value, int size);
    internal void AddBinary(Array value, int size);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class System.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class System.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
[FriendAccessAllowedAttribute]
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class System.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum System.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    public EventCommand Command { get; internal set; }
    public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; internal set; }
    internal EventOpcode Opcode { get; internal set; }
    internal EventKeywords Keywords { get; internal set; }
    internal EventTags Tags { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal void set_Level(EventLevel value);
    internal EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventTags value);
}
internal class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    internal string Name { get; internal set; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
public class System.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    [CompilerGeneratedAttribute]
private void add__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    public static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    private static void DisposeOnShutdown(object sender, EventArgs e);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    [ConditionalAttribute("DEBUG")]
internal static void Validate();
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
[FriendAccessAllowedAttribute]
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.EventPayload : object {
    private List`1<string> m_names;
    private List`1<object> m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(List`1<string> payloadNames, List`1<object> payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.EventPayload/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    private static bool m_setInformationMissing;
    private EtwEnableCallback m_etwCallback;
    private long m_regHandle;
    private byte m_level;
    private long m_anyKeywordMask;
    private long m_allKeywordMask;
    private List`1<SessionInfo> m_liveSessions;
    private bool m_enabled;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static int s_basicTypeAllocationBufferSize;
    private static int s_etwMaxNumberArguments;
    private static int s_etwAPIMaxRefObjCount;
    private static int s_maxEventDataDescriptors;
    private static int s_traceEventMaximumSize;
    private static int s_traceEventMaximumStringSize;
    private static Int32[] nibblebits;
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    private static EventProvider();
    internal int SetInformation(EVENT_INFO_CLASS eventInfoClass, IntPtr data, UInt32 dataSize);
    internal void Register(Guid providerGuid);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual override void Finalize();
    private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, long anyKeyword, long allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    private static int FindNull(Byte[] buffer, int idx);
    private List`1<Tuple`2<SessionInfo, bool>> GetSessions();
    private static void GetSessionInfoCallback(int etwSessionId, long matchAllKeywords, List`1& sessionList);
    private void GetSessionInfo(SessionInfoCallback action, List`1& sessionList);
    private static int IndexOfSessionInList(List`1<SessionInfo> sessions, int etwSessionId);
    private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(int error);
    private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    internal bool WriteEvent(EventDescriptor& eventDescriptor, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    protected internal bool WriteEvent(EventDescriptor& eventDescriptor, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    internal bool WriteEventRaw(EventDescriptor& eventDescriptor, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private UInt32 EventRegister(Guid& providerId, EtwEnableCallback enableCallback);
    private UInt32 EventUnregister(long registrationHandle);
    private static int bitcount(UInt32 n);
    private static int bitindex(UInt32 n);
}
public class System.Diagnostics.Tracing.EventSource : object {
    private static bool m_EventSourcePreventRecursion;
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceDisposed;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_provider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    internal static UInt32 s_currentPid;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    [ThreadStaticAttribute]
private static bool m_EventSourceInDecodeObject;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    internal static string s_ActivityStartSuffix;
    internal static string s_ActivityStopSuffix;
    private static Byte[] namespaceBytes;
    private Byte[] providerMetadata;
    public static Guid CurrentThreadActivityId { get; }
    public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    internal static Guid InternalCurrentThreadActivityId { get; }
    internal static Guid FallbackActivityId { get; }
    public Exception ConstructionException { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; private set; }
    private bool SelfDescribingEvents { get; private set; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    public EventSource(string eventSourceName);
    public EventSource(string eventSourceName, EventSourceSettings config);
    public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    public static Guid get_CurrentThreadActivityId();
    private int GetParameterCount(EventMetadata eventData);
    private Type GetDataType(EventMetadata eventData, int parameterId);
    private static string GetResourceString(string key, Object[] args);
    public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    public static Guid GetGuid(Type eventSourceType);
    public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    public static IEnumerable`1<EventSource> GetSources();
    public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    internal static Guid get_InternalCurrentThreadActivityId();
    internal static Guid get_FallbackActivityId();
    public Exception get_ConstructionException();
    public string GetTrait(string key);
    public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    internal virtual void GetMetadata(Guid& eventSourceGuid, String& eventSourceName, EventMetadata[]& eventData, Byte[]& manifestBytes);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void WriteEventRaw(string eventName, EventDescriptor& eventDescriptor, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private object DecodeObject(int eventId, int parameterId, EventData*& data);
    private EventDispatcher GetDispatcher(EventListener listener);
    private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(ParameterInfo[] infos, Object[] args);
    private int GetParamLenghtIncludingByteArray(ParameterInfo[] parameters);
    private void WriteToAllListeners(int eventId, Guid* childActivityID, int eventDataCount, EventData* data);
    private void WriteToAllListeners(int eventId, Guid* childActivityID, Object[] args);
    private void DispatchToAllListeners(int eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs);
    private void WriteEventString(EventLevel level, long keywords, string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(string eventName, Exception innerEx);
    private void ValidateEventOpcodeForTransfer(EventMetadata& eventData, string eventName);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    private void EnsureDescriptorsInitialized();
    private bool SendManifest(Byte[] rawManifest);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    private EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private void set_ThrowOnEventWriteErrors(bool value);
    private bool get_SelfDescribingEvents();
    private void set_SelfDescribingEvents(bool value);
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, EventPayload payload);
    [ReliabilityContractAttribute("3", "2")]
[NonEventAttribute]
private void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
}
internal class System.Diagnostics.Tracing.EventSourceActivity : object {
    private EventSource eventSource;
    private EventSourceOptions startStopOptions;
    internal Guid activityId;
    private State state;
    private string eventName;
    internal static Guid s_empty;
    public EventSource EventSource { get; }
    public Guid Id { get; }
    private bool StartEventWasFired { get; }
    public EventSourceActivity(EventSource eventSource);
    public static EventSourceActivity op_Implicit(EventSource eventSource);
    public EventSource get_EventSource();
    public Guid get_Id();
    public EventSourceActivity Start(string eventName, EventSourceOptions options, T data);
    public EventSourceActivity Start(string eventName);
    public EventSourceActivity Start(string eventName, EventSourceOptions options);
    public EventSourceActivity Start(string eventName, T data);
    public void Stop(T data);
    public void Stop(string eventName);
    public void Stop(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName);
    public void Write(EventSource source, string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
    private EventSourceActivity Start(string eventName, EventSourceOptions& options, T& data);
    private void Write(EventSource eventSource, string eventName, EventSourceOptions& options, T& data);
    private void Stop(string eventName, T& data);
    private bool get_StartEventWasFired();
}
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    internal static byte keywordsSet;
    internal static byte tagsSet;
    internal static byte levelSet;
    internal static byte opcodeSet;
    internal static byte activityOptionsSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
[FriendAccessAllowedAttribute]
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    private string m_message;
    private string m_eventName;
    private EventSource m_eventSource;
    private ReadOnlyCollection`1<string> m_payloadNames;
    internal EventTags m_tags;
    internal EventOpcode m_opcode;
    internal EventLevel m_level;
    internal EventKeywords m_keywords;
    public string EventName { get; internal set; }
    public int EventId { get; internal set; }
    public Guid ActivityId { get; }
    public Guid RelatedActivityId { get; internal set; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public EventTags Tags { get; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; }
    internal EventWrittenEventArgs(EventSource eventSource);
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public EventTags get_Tags();
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
}
internal class System.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, ushort fixedCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, Byte[] custom);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
[FriendAccessAllowedAttribute]
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.FrameworkEventSource : EventSource {
    public static FrameworkEventSource Log;
    public static bool IsInitialized { get; }
    private static FrameworkEventSource();
    public static bool get_IsInitialized();
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3, bool arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, string arg2, bool arg3, bool arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, bool arg2, bool arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, bool arg2, bool arg3, int arg4);
    [EventAttribute("1")]
public void ResourceManagerLookupStarted(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("2")]
public void ResourceManagerLookingForResourceSet(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("3")]
public void ResourceManagerFoundResourceSetInCache(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("4")]
public void ResourceManagerFoundResourceSetInCacheUnexpected(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("5")]
public void ResourceManagerStreamFound(string baseName, string mainAssemblyName, string cultureName, string loadedAssemblyName, string resourceFileName);
    [EventAttribute("6")]
public void ResourceManagerStreamNotFound(string baseName, string mainAssemblyName, string cultureName, string loadedAssemblyName, string resourceFileName);
    [EventAttribute("7")]
public void ResourceManagerGetSatelliteAssemblySucceeded(string baseName, string mainAssemblyName, string cultureName, string assemblyName);
    [EventAttribute("8")]
public void ResourceManagerGetSatelliteAssemblyFailed(string baseName, string mainAssemblyName, string cultureName, string assemblyName);
    [EventAttribute("9")]
public void ResourceManagerCaseInsensitiveResourceStreamLookupSucceeded(string baseName, string mainAssemblyName, string assemblyName, string resourceFileName);
    [EventAttribute("10")]
public void ResourceManagerCaseInsensitiveResourceStreamLookupFailed(string baseName, string mainAssemblyName, string assemblyName, string resourceFileName);
    [EventAttribute("11")]
public void ResourceManagerManifestResourceAccessDenied(string baseName, string mainAssemblyName, string assemblyName, string canonicalName);
    [EventAttribute("12")]
public void ResourceManagerNeutralResourcesSufficient(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("13")]
public void ResourceManagerNeutralResourceAttributeMissing(string mainAssemblyName);
    [EventAttribute("14")]
public void ResourceManagerCreatingResourceSet(string baseName, string mainAssemblyName, string cultureName, string fileName);
    [EventAttribute("15")]
public void ResourceManagerNotCreatingResourceSet(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("16")]
public void ResourceManagerLookupFailed(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("17")]
public void ResourceManagerReleasingResources(string baseName, string mainAssemblyName);
    [EventAttribute("18")]
public void ResourceManagerNeutralResourcesNotFound(string baseName, string mainAssemblyName, string resName);
    [EventAttribute("19")]
public void ResourceManagerNeutralResourcesFound(string baseName, string mainAssemblyName, string resName);
    [EventAttribute("20")]
public void ResourceManagerAddingCultureFromConfigFile(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("21")]
public void ResourceManagerCultureNotFoundInConfigFile(string baseName, string mainAssemblyName, string cultureName);
    [EventAttribute("22")]
public void ResourceManagerCultureFoundInConfigFile(string baseName, string mainAssemblyName, string cultureName);
    [NonEventAttribute]
public void ResourceManagerLookupStarted(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerLookingForResourceSet(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerFoundResourceSetInCache(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerFoundResourceSetInCacheUnexpected(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerStreamFound(string baseName, Assembly mainAssembly, string cultureName, Assembly loadedAssembly, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerStreamNotFound(string baseName, Assembly mainAssembly, string cultureName, Assembly loadedAssembly, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerGetSatelliteAssemblySucceeded(string baseName, Assembly mainAssembly, string cultureName, string assemblyName);
    [NonEventAttribute]
public void ResourceManagerGetSatelliteAssemblyFailed(string baseName, Assembly mainAssembly, string cultureName, string assemblyName);
    [NonEventAttribute]
public void ResourceManagerCaseInsensitiveResourceStreamLookupSucceeded(string baseName, Assembly mainAssembly, string assemblyName, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerCaseInsensitiveResourceStreamLookupFailed(string baseName, Assembly mainAssembly, string assemblyName, string resourceFileName);
    [NonEventAttribute]
public void ResourceManagerManifestResourceAccessDenied(string baseName, Assembly mainAssembly, string assemblyName, string canonicalName);
    [NonEventAttribute]
public void ResourceManagerNeutralResourcesSufficient(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerNeutralResourceAttributeMissing(Assembly mainAssembly);
    [NonEventAttribute]
public void ResourceManagerCreatingResourceSet(string baseName, Assembly mainAssembly, string cultureName, string fileName);
    [NonEventAttribute]
public void ResourceManagerNotCreatingResourceSet(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerLookupFailed(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerReleasingResources(string baseName, Assembly mainAssembly);
    [NonEventAttribute]
public void ResourceManagerNeutralResourcesNotFound(string baseName, Assembly mainAssembly, string resName);
    [NonEventAttribute]
public void ResourceManagerNeutralResourcesFound(string baseName, Assembly mainAssembly, string resName);
    [NonEventAttribute]
public void ResourceManagerAddingCultureFromConfigFile(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerCultureNotFoundInConfigFile(string baseName, Assembly mainAssembly, string cultureName);
    [NonEventAttribute]
public void ResourceManagerCultureFoundInConfigFile(string baseName, Assembly mainAssembly, string cultureName);
    private static string GetName(Assembly assembly);
    [EventAttribute("30")]
public void ThreadPoolEnqueueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolEnqueueWorkObject(object workID);
    [EventAttribute("31")]
public void ThreadPoolDequeueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolDequeueWorkObject(object workID);
    [EventAttribute("140")]
private void GetResponseStart(long id, string uri, bool success, bool synchronous);
    [EventAttribute("141")]
private void GetResponseStop(long id, bool success, bool synchronous, int statusCode);
    [EventAttribute("142")]
private void GetRequestStreamStart(long id, string uri, bool success, bool synchronous);
    [EventAttribute("143")]
private void GetRequestStreamStop(long id, bool success, bool synchronous);
    [NonEventAttribute]
public void BeginGetResponse(object id, string uri, bool success, bool synchronous);
    [NonEventAttribute]
public void EndGetResponse(object id, bool success, bool synchronous, int statusCode);
    [NonEventAttribute]
public void BeginGetRequestStream(object id, string uri, bool success, bool synchronous);
    [NonEventAttribute]
public void EndGetRequestStream(object id, bool success, bool synchronous);
    [EventAttribute("150")]
public void ThreadTransferSend(long id, int kind, string info, bool multiDequeues);
    [NonEventAttribute]
public void ThreadTransferSendObj(object id, int kind, string info, bool multiDequeues);
    [EventAttribute("151")]
public void ThreadTransferReceive(long id, int kind, string info);
    [NonEventAttribute]
public void ThreadTransferReceiveObj(object id, int kind, string info);
    [EventAttribute("152")]
public void ThreadTransferReceiveHandled(long id, int kind, string info);
    [NonEventAttribute]
public void ThreadTransferReceiveHandledObj(object id, int kind, string info);
    private static long IdForObject(object obj);
}
internal static class System.Diagnostics.Tracing.Internal.Environment : object {
    public static string NewLine;
    private static ResourceManager rm;
    public static int TickCount { get; }
    private static Environment();
    public static int get_TickCount();
    public static string GetResourceString(string key, Object[] args);
    public static string GetRuntimeResourceString(string key, Object[] args);
}
internal class System.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    private PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    private static String[] s_escapes;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    internal static ulong ValidPredefinedChannelKeywords;
    private ulong nextChannelKeywordBit;
    private static int MaxCountChannels;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    private static ManifestBuilder();
    private string GetTypeNameHelper(Type type);
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private EventChannelType EventChannelToChannelType(EventChannel channel);
    private EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel, ulong channelKeyword);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static List`1<CultureInfo> GetSupportedCultures(ResourceManager resources);
    private static string GetLevelName(EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private string GetKeywords(ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public static int MaxChunkSize;
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class System.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    private Func`2<PropertyValue, PropertyValue> hasValueGetter;
    private Func`2<PropertyValue, PropertyValue> valueGetter;
    public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
internal class System.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    public static Func`2<object, PropertyValue> GetFactory(Type type);
    public object get_ReferenceValue();
    public Scalar get_ScalarValue();
    public int get_ScalarLength();
    public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
internal static class System.Diagnostics.Tracing.Resources : object {
    internal static string GetResourceString(string key, Object[] args);
}
internal class System.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class System.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    internal static int SHIFT_SESSION_TO_KEYWORD;
    internal static UInt32 MASK;
    internal static UInt32 MAX;
    public static SessionMask All { get; }
    public bool Item { get; public set; }
    public SessionMask(SessionMask m);
    public SessionMask(UInt32 mask);
    public bool IsEqualOrSupersetOf(SessionMask m);
    public static SessionMask get_All();
    public static SessionMask FromId(int perEventSourceSessionId);
    public ulong ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public bool get_Item(int perEventSourceSessionId);
    public void set_Item(int perEventSourceSessionId, bool value);
    public static SessionMask op_BitwiseOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_BitwiseAnd(SessionMask m1, SessionMask m2);
    public static SessionMask op_ExclusiveOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_OnesComplement(SessionMask m);
    public static ulong op_Explicit(SessionMask m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal static class System.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    public static TraceLoggingEventTypes get_Instance();
    private static TraceLoggingEventTypes InitInstance();
}
internal static class System.Diagnostics.Tracing.Statics : object {
    public static byte DefaultLevel;
    public static byte TraceLoggingChannel;
    public static byte InTypeMask;
    public static byte InTypeFixedCountFlag;
    public static byte InTypeVariableCountFlag;
    public static byte InTypeCustomCountFlag;
    public static byte InTypeCountMask;
    public static byte InTypeChainFlag;
    public static byte OutTypeMask;
    public static byte OutTypeChainFlag;
    public static EventTags EventTagsMask;
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static byte Combine(int settingValue1, int settingValue2, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static object CreateInstance(Type type, Object[] parameters);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    public static MethodInfo GetDeclaredStaticMethod(Type declaringType, string name);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static Delegate CreateDelegate(Type delegateType, MethodInfo methodInfo);
    public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    internal static TraceLoggingDataCollector Instance;
    private static TraceLoggingDataCollector();
    public int BeginBufferedArray();
    public void EndBufferedArray(int bookmark, int count);
    public TraceLoggingDataCollector AddGroup();
    public void AddScalar(PropertyValue value);
    public void AddScalar(long value);
    public void AddScalar(double value);
    public void AddBinary(string value);
    public void AddArray(PropertyValue value, int elementSize);
}
internal enum System.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
public class System.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    internal string Name { get; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    internal EventKeywords get_Keywords();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
}
internal class System.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddBinary(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    public void AddCustom(string name, TraceLoggingDataType type, Byte[] metadata);
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class System.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
    public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
public class System.Double : ValueType {
    internal double m_value;
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    internal static double NegativeZero;
    private static Double();
    [NonVersionableAttribute]
public static bool IsInfinity(double d);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(double d);
    internal static bool IsNegative(double d);
    [NonVersionableAttribute]
public static bool IsNaN(double d);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public static bool op_Equality(double left, double right);
    [NonVersionableAttribute]
public static bool op_Inequality(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, IFormatProvider provider);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    private static double Parse(string s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    private static bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
internal class System.DTSubString : ValueType {
    internal string s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
public class System.DuplicateWaitObjectException : ArgumentException {
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_duplicateWaitObjectMessage;
    private static string DuplicateWaitObjectMessage { get; }
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    private static DuplicateWaitObjectException();
    private static string get_DuplicateWaitObjectMessage();
}
internal class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Enum : ValueType {
    private static char enumSeparatorChar;
    private static string enumSeparatorString;
    private static TypeValuesAndNames GetCachedValuesAndNames(RuntimeType enumType, bool getNames);
    private string InternalFormattedHexString();
    private static string InternalFormattedHexString(object value);
    internal static string GetEnumName(RuntimeType eT, ulong ulValue);
    private static string InternalFormat(RuntimeType eT, ulong value);
    private static string InternalFlagsFormat(RuntimeType eT, ulong result);
    private static string InternalFlagsFormat(RuntimeType eT, TypeValuesAndNames entry, ulong result);
    internal static ulong ToUInt64(object value);
    private static int InternalCompareTo(object o1, object o2);
    internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetEnumValuesAndNames(RuntimeTypeHandle enumType, ObjectHandleOnStack values, ObjectHandleOnStack names, bool getNames);
    private static object InternalBoxEnum(RuntimeType enumType, long value);
    public static bool TryParse(Type enumType, string value, Object& result);
    public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParse(string value, TEnum& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static TEnum Parse(string value);
    public static TEnum Parse(string value, bool ignoreCase);
    private static bool TryParseEnum(Type enumType, string value, bool ignoreCase, EnumResult& parseResult);
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    internal static UInt64[] InternalGetValues(RuntimeType enumType);
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    internal static String[] InternalGetNames(RuntimeType enumType);
    public static object ToObject(Type enumType, object value);
    public static bool IsDefined(Type enumType, object value);
    public static string Format(Type enumType, object value, string format);
    internal object GetValue();
    private ulong ToUInt64();
    private bool InternalHasFlag(Enum flags);
    private CorElementType InternalGetCorElementType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual int CompareTo(object target);
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    public bool HasFlag(Enum flag);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    public static object ToObject(Type enumType, short value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, byte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    public static object ToObject(Type enumType, long value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    private static object ToObject(Type enumType, char value);
    private static object ToObject(Type enumType, bool value);
}
internal static class System.Environment : object {
    private static int MaxEnvVariableValueLength;
    private static int MaxSystemEnvVariableLength;
    private static int MaxUserEnvVariableLength;
    private static int MaxMachineNameLength;
    private static object s_InternalSyncObject;
    private static OperatingSystem modreq(System.Runtime.CompilerServices.IsVolatile) m_os;
    private static String[] s_CommandLineArgs;
    private static Lazy`1<bool> s_IsWindows8OrAbove;
    private static Lazy`1<bool> s_IsWinRTSupported;
    [ThreadStaticAttribute]
private static int t_executionIdCache;
    private static int ExecutionIdCacheShift;
    private static int ExecutionIdCacheCountDownMask;
    private static int ExecutionIdRefreshRate;
    private static object InternalSyncObject { get; }
    public static int TickCount { get; }
    public static int ExitCode { get; public set; }
    internal static string CurrentDirectory { get; internal set; }
    internal static string SystemDirectory { get; }
    public static int ProcessorCount { get; }
    public static string NewLine { get; }
    public static Version Version { get; }
    internal static bool IsWindows8OrAbove { get; }
    internal static bool IsWinRTSupported { get; }
    public static string StackTrace { get; }
    public static bool HasShutdownStarted { get; }
    internal static bool UserInteractive { get; }
    public static int CurrentManagedThreadId { get; }
    internal static int CurrentProcessorNumber { get; }
    internal static int CurrentExecutionId { get; }
    private static Environment();
    internal static string GetResourceStringLocal(string key);
    private static object get_InternalSyncObject();
    public static int get_TickCount();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void _Exit(int exitCode);
    public static void Exit(int exitCode);
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static void FailFast(string message);
    public static void FailFast(string message, Exception exception);
    internal static string get_CurrentDirectory();
    internal static void set_CurrentDirectory(string value);
    internal static string get_SystemDirectory();
    public static string ExpandEnvironmentVariables(string name);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetProcessorCount();
    public static int get_ProcessorCount();
    public static String[] GetCommandLineArgs();
    private static String[] GetCommandLineArgsNative();
    private static void SetCommandLineArgs(String[] cmdLineArgs);
    private static Char[] GetEnvironmentCharArray();
    public static string get_NewLine();
    public static Version get_Version();
    internal static bool get_IsWindows8OrAbove();
    internal static bool get_IsWinRTSupported();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool WinRTSupported();
    public static string get_StackTrace();
    internal static string GetStackTrace(Exception e, bool needFileInfo);
    public static bool get_HasShutdownStarted();
    internal static bool get_UserInteractive();
    public static int get_CurrentManagedThreadId();
    internal static int get_CurrentProcessorNumber();
    private static int RefreshExecutionId();
    internal static int get_CurrentExecutionId();
    public static string GetEnvironmentVariable(string variable);
    internal static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    internal static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    internal static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    private static void ValidateVariableAndValue(string variable, String& value);
    private static void ValidateTarget(EnvironmentVariableTarget target);
    private static Dictionary`2<string, string> GetRawEnvironmentVariables();
    private static string GetEnvironmentVariableCore(string variable);
    private static string GetEnvironmentVariableCore(string variable, EnvironmentVariableTarget target);
    private static IDictionary GetEnvironmentVariablesCore();
    private static IDictionary GetEnvironmentVariablesCore(EnvironmentVariableTarget target);
    private static void SetEnvironmentVariableCore(string variable, string value);
    private static void SetEnvironmentVariableCore(string variable, string value, EnvironmentVariableTarget target);
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
public class System.EventArgs : object {
    public static EventArgs Empty;
    private static EventArgs();
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Exception : object {
    [OptionalFieldAttribute]
private static object s_EDILock;
    private string _className;
    private MethodBase _exceptionMethod;
    private string _exceptionMethodString;
    internal string _message;
    private IDictionary _data;
    private Exception _innerException;
    private string _helpURL;
    private object _stackTrace;
    [OptionalFieldAttribute]
private object _watsonBuckets;
    private string _stackTraceString;
    private string _remoteStackTraceString;
    private int _remoteStackIndex;
    private object _dynamicMethods;
    internal int _HResult;
    private string _source;
    private IntPtr _xptrs;
    private int _xcode;
    [OptionalFieldAttribute]
private UIntPtr _ipForWatsonBuckets;
    private static int _COMPlusExceptionCode;
    public string Message { get; }
    public IDictionary Data { get; }
    public Exception InnerException { get; }
    public MethodBase TargetSite { get; }
    public string StackTrace { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    internal UIntPtr IPForWatsonBuckets { get; }
    internal object WatsonBuckets { get; }
    internal string RemoteStackTrace { get; }
    public int HResult { get; protected set; }
    internal bool IsTransient { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    protected Exception(SerializationInfo info, StreamingContext context);
    private static Exception();
    private void Init();
    public virtual string get_Message();
    public virtual IDictionary get_Data();
    private static bool IsImmutableAgileException(Exception e);
    [FriendAccessAllowedAttribute]
internal void AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject, bool hasrestrictedLanguageErrorObject);
    internal bool TryGetRestrictedLanguageErrorObject(Object& restrictedErrorObject);
    private string GetClassName();
    public virtual Exception GetBaseException();
    public Exception get_InnerException();
    private static IRuntimeMethodInfo GetMethodFromStackTrace(object stackTrace);
    private MethodBase GetExceptionMethodFromStackTrace();
    public MethodBase get_TargetSite();
    private MethodBase GetTargetSiteInternal();
    public virtual string get_StackTrace();
    private string GetStackTrace(bool needFileInfo);
    [FriendAccessAllowedAttribute]
internal void SetErrorCode(int hr);
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string ToString();
    private string ToString(bool needFileLineInfo, bool needMessage);
    private string GetExceptionMethodString();
    private MethodBase GetExceptionMethodFromString();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    internal void InternalPreserveStackTrace();
    internal UIntPtr get_IPForWatsonBuckets();
    internal object get_WatsonBuckets();
    internal string get_RemoteStackTrace();
    private static void PrepareForForeignExceptionRaise();
    private static void GetStackTracesDeepCopy(Exception exception, Object& currentStackTrace, Object& dynamicMethodArray);
    internal static void SaveStackTracesFromDeepCopy(Exception exception, object currentStackTrace, object dynamicMethodArray);
    private static object CopyStackTrace(object currentStackTrace);
    private static object CopyDynamicMethods(object currentDynamicMethods);
    internal object DeepCopyStackTrace(object currentStackTrace);
    internal object DeepCopyDynamicMethods(object currentDynamicMethods);
    internal void GetStackTracesDeepCopy(Object& currentStackTrace, Object& dynamicMethodArray);
    internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo);
    public int get_HResult();
    protected void set_HResult(int value);
    internal virtual string InternalToString();
    public Type GetType();
    internal bool get_IsTransient();
    private static bool nIsTransient(int hr);
    internal static string GetMessageFromNativeResources(ExceptionMessageKind kind);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetMessageFromNativeResources(ExceptionMessageKind kind, StringHandleOnStack retMesg);
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument dictionaryCreationThreshold;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument collection;
    public static ExceptionArgument list;
    public static ExceptionArgument match;
    public static ExceptionArgument converter;
    public static ExceptionArgument queue;
    public static ExceptionArgument stack;
    public static ExceptionArgument capacity;
    public static ExceptionArgument index;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument value;
    public static ExceptionArgument count;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument name;
    public static ExceptionArgument mode;
    public static ExceptionArgument item;
    public static ExceptionArgument options;
    public static ExceptionArgument view;
    public static ExceptionArgument sourceBytesToCopy;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument offset;
    public static ExceptionArgument newSize;
    public static ExceptionArgument elementType;
    public static ExceptionArgument length;
    public static ExceptionArgument length1;
    public static ExceptionArgument length2;
    public static ExceptionArgument length3;
    public static ExceptionArgument lengths;
    public static ExceptionArgument len;
    public static ExceptionArgument lowerBounds;
    public static ExceptionArgument sourceArray;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument sourceIndex;
    public static ExceptionArgument destinationIndex;
    public static ExceptionArgument indices;
    public static ExceptionArgument index1;
    public static ExceptionArgument index2;
    public static ExceptionArgument index3;
    public static ExceptionArgument other;
    public static ExceptionArgument comparer;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument keys;
    public static ExceptionArgument creationOptions;
    public static ExceptionArgument timeout;
    public static ExceptionArgument tasks;
    public static ExceptionArgument scheduler;
    public static ExceptionArgument continuationFunction;
    public static ExceptionArgument millisecondsTimeout;
    public static ExceptionArgument millisecondsDelay;
    public static ExceptionArgument function;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument cancellationToken;
    public static ExceptionArgument delay;
    public static ExceptionArgument asyncResult;
    public static ExceptionArgument endMethod;
    public static ExceptionArgument endFunction;
    public static ExceptionArgument beginMethod;
    public static ExceptionArgument continuationOptions;
    public static ExceptionArgument continuationAction;
    public static ExceptionArgument valueFactory;
    public static ExceptionArgument addValueFactory;
    public static ExceptionArgument updateValueFactory;
    public static ExceptionArgument concurrencyLevel;
    public static ExceptionArgument text;
    public static ExceptionArgument callBack;
    public static ExceptionArgument type;
    public static ExceptionArgument stateMachine;
    public static ExceptionArgument pHandle;
    public static ExceptionArgument values;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource Argument_ImplementIComparable;
    public static ExceptionResource Argument_InvalidType;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Argument_InvalidRegistryKeyPermissionCheck;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_RegKeyDelHive;
    public static ExceptionResource Arg_RegKeyStrLenBug;
    public static ExceptionResource Arg_RegSetStrArrNull;
    public static ExceptionResource Arg_RegSetMismatchedKind;
    public static ExceptionResource Arg_RegSubKeyAbsent;
    public static ExceptionResource Arg_RegSubKeyValueAbsent;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Serialization_InvalidOnDeser;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource Argument_InvalidArrayType;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource Argument_ItemNotExist;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource ArgumentOutOfRange_InvalidThreshold;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue;
    public static ExceptionResource InvalidOperation_EmptyQueue;
    public static ExceptionResource InvalidOperation_EnumOpCantHappen;
    public static ExceptionResource InvalidOperation_EnumFailedVersion;
    public static ExceptionResource InvalidOperation_EmptyStack;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource InvalidOperation_EnumNotStarted;
    public static ExceptionResource InvalidOperation_EnumEnded;
    public static ExceptionResource NotSupported_SortedListNestedWrite;
    public static ExceptionResource InvalidOperation_NoValue;
    public static ExceptionResource InvalidOperation_RegRemoveSubKey;
    public static ExceptionResource Security_RegistryPermission;
    public static ExceptionResource UnauthorizedAccess_RegistryNoWrite;
    public static ExceptionResource ObjectDisposed_RegKeyClosed;
    public static ExceptionResource NotSupported_InComparableType;
    public static ExceptionResource Argument_InvalidRegistryOptionsCheck;
    public static ExceptionResource Argument_InvalidRegistryViewCheck;
    public static ExceptionResource InvalidOperation_NullArray;
    public static ExceptionResource Arg_MustBeType;
    public static ExceptionResource Arg_NeedAtLeast1Rank;
    public static ExceptionResource ArgumentOutOfRange_HugeArrayNotSupported;
    public static ExceptionResource Arg_RanksAndBounds;
    public static ExceptionResource Arg_RankIndices;
    public static ExceptionResource Arg_Need1DArray;
    public static ExceptionResource Arg_Need2DArray;
    public static ExceptionResource Arg_Need3DArray;
    public static ExceptionResource NotSupported_FixedSizeCollection;
    public static ExceptionResource ArgumentException_OtherNotArrayOfCorrectLength;
    public static ExceptionResource Rank_MultiDimNotSupported;
    public static ExceptionResource InvalidOperation_IComparerFailed;
    public static ExceptionResource ArgumentOutOfRange_EndIndexStartIndex;
    public static ExceptionResource Arg_LowerBoundsMustMatch;
    public static ExceptionResource Arg_BogusIComparer;
    public static ExceptionResource Task_WaitMulti_NullTask;
    public static ExceptionResource Task_ThrowIfDisposed;
    public static ExceptionResource Task_Start_TaskCompleted;
    public static ExceptionResource Task_Start_Promise;
    public static ExceptionResource Task_Start_ContinuationTask;
    public static ExceptionResource Task_Start_AlreadyStarted;
    public static ExceptionResource Task_RunSynchronously_TaskCompleted;
    public static ExceptionResource Task_RunSynchronously_Continuation;
    public static ExceptionResource Task_RunSynchronously_Promise;
    public static ExceptionResource Task_RunSynchronously_AlreadyStarted;
    public static ExceptionResource Task_MultiTaskContinuation_NullTask;
    public static ExceptionResource Task_MultiTaskContinuation_EmptyTaskList;
    public static ExceptionResource Task_Dispose_NotCompleted;
    public static ExceptionResource Task_Delay_InvalidMillisecondsDelay;
    public static ExceptionResource Task_Delay_InvalidDelay;
    public static ExceptionResource Task_ctor_LRandSR;
    public static ExceptionResource Task_ContinueWith_NotOnAnything;
    public static ExceptionResource Task_ContinueWith_ESandLR;
    public static ExceptionResource TaskT_TransitionToFinal_AlreadyCompleted;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NullException;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NoExceptions;
    public static ExceptionResource InvalidOperation_WrongAsyncResultOrEndCalledMultiple;
    public static ExceptionResource ConcurrentDictionary_ConcurrencyLevelMustBePositive;
    public static ExceptionResource ConcurrentDictionary_CapacityMustNotBeNegative;
    public static ExceptionResource ConcurrentDictionary_TypeOfValueIncorrect;
    public static ExceptionResource ConcurrentDictionary_TypeOfKeyIncorrect;
    public static ExceptionResource ConcurrentDictionary_SourceContainsDuplicateKeys;
    public static ExceptionResource ConcurrentDictionary_KeyAlreadyExisted;
    public static ExceptionResource ConcurrentDictionary_ItemKeyIsNull;
    public static ExceptionResource ConcurrentDictionary_IndexIsNegative;
    public static ExceptionResource ConcurrentDictionary_ArrayNotLargeEnough;
    public static ExceptionResource ConcurrentDictionary_ArrayIncorrectType;
    public static ExceptionResource ConcurrentCollection_SyncRoot_NotSupported;
    public static ExceptionResource ArgumentOutOfRange_Enum;
    public static ExceptionResource InvalidOperation_HandleIsNotInitialized;
    public static ExceptionResource AsyncMethodBuilder_InstanceNotInitialized;
    public static ExceptionResource ArgumentNull_SafeHandle;
}
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    internal ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    protected FormatException(SerializationInfo info, StreamingContext context);
}
public abstract class System.FormattableString : object {
    public string Format { get; }
    public int ArgumentCount { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] GetArguments();
    public abstract virtual int get_ArgumentCount();
    public abstract virtual object GetArgument(int index);
    public abstract virtual string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    public virtual string ToString();
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    public static int MaxGeneration { get; }
    internal static int GetGCLatencyMode();
    internal static int SetGCLatencyMode(int newLatencyMode);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int _StartNoGCRegion(long totalSize, bool lohSizeKnown, long lohSize, bool disallowFullBlockingGC);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int _EndNoGCRegion();
    internal static int GetLOHCompactionMode();
    internal static void SetLOHCompactionMode(int newLOHCompactionMode);
    private static int GetGenerationWR(IntPtr handle);
    [SuppressUnmanagedCodeSecurityAttribute]
private static long GetTotalMemory();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _Collect(int generation, int mode);
    private static int GetMaxGeneration();
    private static int _CollectionCount(int generation, int getSpecialGCCount);
    internal static bool IsServerGC();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _AddMemoryPressure(ulong bytesAllocated);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _RemoveMemoryPressure(ulong bytesAllocated);
    public static void AddMemoryPressure(long bytesAllocated);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static int GetGeneration(object obj);
    public static void Collect(int generation);
    public static void Collect();
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    public static void KeepAlive(object obj);
    public static int GetGeneration(WeakReference wo);
    public static int get_MaxGeneration();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _WaitForPendingFinalizers();
    public static void WaitForPendingFinalizers();
    private static void _SuppressFinalize(object o);
    public static void SuppressFinalize(object obj);
    private static void _ReRegisterForFinalize(object o);
    public static void ReRegisterForFinalize(object obj);
    public static long GetTotalMemory(bool forceFullCollection);
    private static long _GetAllocatedBytesForCurrentThread();
    public static long GetAllocatedBytesForCurrentThread();
    private static bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage);
    private static bool _CancelFullGCNotification();
    private static int _WaitForFullGCApproach(int millisecondsTimeout);
    private static int _WaitForFullGCComplete(int millisecondsTimeout);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void CancelFullGCNotification();
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    private static bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    private static EndNoGCRegionStatus EndNoGCRegionWorker();
    public static void EndNoGCRegion();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Func`2<object, bool> m_callback;
    private GCHandle m_weakTargetObj;
    public static void Register(Func`2<object, bool> callback, object targetObj);
    private void Setup(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
internal enum System.Globalization.BidiCategory : Enum {
    public int value__;
    public static BidiCategory LeftToRight;
    public static BidiCategory LeftToRightEmbedding;
    public static BidiCategory LeftToRightOverride;
    public static BidiCategory RightToLeft;
    public static BidiCategory RightToLeftArabic;
    public static BidiCategory RightToLeftEmbedding;
    public static BidiCategory RightToLeftOverride;
    public static BidiCategory PopDirectionalFormat;
    public static BidiCategory EuropeanNumber;
    public static BidiCategory EuropeanNumberSeparator;
    public static BidiCategory EuropeanNumberTerminator;
    public static BidiCategory ArabicNumber;
    public static BidiCategory CommonNumberSeparator;
    public static BidiCategory NonSpacingMark;
    public static BidiCategory BoundaryNeutral;
    public static BidiCategory ParagraphSeparator;
    public static BidiCategory SegmentSeparator;
    public static BidiCategory Whitespace;
    public static BidiCategory OtherNeutrals;
    public static BidiCategory LeftToRightIsolate;
    public static BidiCategory RightToLeftIsolate;
    public static BidiCategory FirstStrongIsolate;
    public static BidiCategory PopDirectionIsolate;
}
public abstract class System.Globalization.Calendar : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    private int _currentEraValue;
    [OptionalFieldAttribute]
private bool _isReadOnly;
    internal static CalendarId CAL_HEBREW;
    internal static CalendarId CAL_HIJRI;
    internal static CalendarId CAL_JAPAN;
    internal static CalendarId CAL_JULIAN;
    internal static CalendarId CAL_TAIWAN;
    internal static CalendarId CAL_UMALQURA;
    internal static CalendarId CAL_PERSIAN;
    public static int CurrentEra;
    internal int twoDigitYearMax;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays);
    private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal static int GetSystemTwoDigitYearSetting(CalendarId CalID, int defaultYearValue);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal static int MAX_CALENDARS;
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    internal int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    private static UInt32 CAL_RETURN_NUMBER;
    private static UInt32 CAL_RETURN_GENITIVE_NAMES;
    private static UInt32 CAL_NOUSEROVERRIDE;
    private static UInt32 CAL_SCALNAME;
    private static UInt32 CAL_SMONTHDAY;
    private static UInt32 CAL_SSHORTDATE;
    private static UInt32 CAL_SLONGDATE;
    private static UInt32 CAL_SYEARMONTH;
    private static UInt32 CAL_SDAYNAME7;
    private static UInt32 CAL_SABBREVDAYNAME7;
    private static UInt32 CAL_SMONTHNAME1;
    private static UInt32 CAL_SABBREVMONTHNAME1;
    private static UInt32 CAL_SSHORTESTDAYNAME7;
    private static UInt32 CAL_SERASTRING;
    private static UInt32 CAL_SABBREVERASTRING;
    private static UInt32 CAL_ICALINTVALUE;
    private static UInt32 CAL_ITWODIGITYEARMAX;
    private static UInt32 ENUM_ALL_CALENDARS;
    private static UInt32 LOCALE_SSHORTDATE;
    private static UInt32 LOCALE_SLONGDATE;
    private static UInt32 LOCALE_SYEARMONTH;
    private static UInt32 LOCALE_ICALENDARTYPE;
    internal CalendarData(string localeName, CalendarId calendarId, bool bUseUserOverrides);
    private static CalendarData();
    private static CalendarData CreateInvariant();
    private void InitializeEraNames(string localeName, CalendarId calendarId);
    private void InitializeAbbreviatedEraNames(string localeName, CalendarId calendarId);
    internal static CalendarData GetCalendarData(CalendarId calendarId);
    private static string CalendarIdToCultureName(CalendarId calendarId);
    private bool LoadCalendarDataFromSystem(string localeName, CalendarId calendarId);
    internal static int GetTwoDigitYearMax(CalendarId calendarId);
    internal static int GetCalendars(string localeName, bool useUserOverride, CalendarId[] calendars);
    private static bool SystemSupportsTaiwaneseCalendar();
    private static void CheckSpecialCalendar(CalendarId& calendar, String& localeName);
    private static bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, UInt32 calType, Int32& data);
    private static bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, UInt32 calType, String& data);
    private static BOOL EnumCalendarInfoCallback(IntPtr lpCalendarInfoString, UInt32 calendar, IntPtr pReserved, IntPtr lParam);
    private static bool CallEnumCalendarInfo(string localeName, CalendarId calendar, UInt32 calType, UInt32 lcType, String[]& data);
    private static bool GetCalendarDayInfo(string localeName, CalendarId calendar, UInt32 calType, String[]& outputStrings);
    private static bool GetCalendarMonthInfo(string localeName, CalendarId calendar, UInt32 calType, String[]& outputStrings);
    private static BOOL EnumCalendarsCallback(IntPtr lpCalendarInfoString, UInt32 calendar, IntPtr reserved, IntPtr lParam);
    private static string GetUserDefaultLocaleName();
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId UNINITIALIZED_VALUE;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
internal class System.Globalization.CalendricalCalculationsHelper : object {
    private static double FullCircleOfArc;
    private static int HalfCircleOfArc;
    private static double TwelveHours;
    private static double Noon2000Jan01;
    internal static double MeanTropicalYearInDays;
    private static double MeanSpeedOfSun;
    private static double LongitudeSpring;
    private static double TwoDegreesAfterSpring;
    private static int SecondsPerDay;
    private static int DaysInUniformLengthCentury;
    private static int SecondsPerMinute;
    private static int MinutesPerDegree;
    private static long s_startOf1810;
    private static long s_startOf1900Century;
    private static Double[] s_coefficients1900to1987;
    private static Double[] s_coefficients1800to1899;
    private static Double[] s_coefficients1700to1799;
    private static Double[] s_coefficients1620to1699;
    private static Double[] s_lambdaCoefficients;
    private static Double[] s_anomalyCoefficients;
    private static Double[] s_eccentricityCoefficients;
    private static Double[] s_coefficients;
    private static Double[] s_coefficientsA;
    private static Double[] s_coefficientsB;
    private static EphemerisCorrectionAlgorithmMap[] s_ephemerisCorrectionTable;
    private static CalendricalCalculationsHelper();
    private static double RadiansFromDegrees(double degree);
    private static double SinOfDegree(double degree);
    private static double CosOfDegree(double degree);
    private static double TanOfDegree(double degree);
    public static double Angle(int degrees, int minutes, double seconds);
    private static double Obliquity(double julianCenturies);
    internal static long GetNumberOfDays(DateTime date);
    private static int GetGregorianYear(double numberOfDays);
    private static double Reminder(double divisor, double dividend);
    private static double NormalizeLongitude(double longitude);
    public static double AsDayFraction(double longitude);
    private static double PolynomialSum(Double[] coefficients, double indeterminate);
    private static double CenturiesFrom1900(int gregorianYear);
    private static double DefaultEphemerisCorrection(int gregorianYear);
    private static double EphemerisCorrection1988to2019(int gregorianYear);
    private static double EphemerisCorrection1900to1987(int gregorianYear);
    private static double EphemerisCorrection1800to1899(int gregorianYear);
    private static double EphemerisCorrection1700to1799(int gregorianYear);
    private static double EphemerisCorrection1620to1699(int gregorianYear);
    private static double EphemerisCorrection(double time);
    public static double JulianCenturies(double moment);
    private static bool IsNegative(double value);
    private static double CopySign(double value, double sign);
    private static double EquationOfTime(double time);
    private static double AsLocalTime(double apparentMidday, double longitude);
    public static double Midday(double date, double longitude);
    private static double InitLongitude(double longitude);
    public static double MiddayAtPersianObservationSite(double date);
    private static double PeriodicTerm(double julianCenturies, int x, double y, double z);
    private static double SumLongSequenceOfPeriodicTerms(double julianCenturies);
    private static double Aberration(double julianCenturies);
    private static double Nutation(double julianCenturies);
    public static double Compute(double time);
    public static double AsSeason(double longitude);
    private static double EstimatePrior(double longitude, double time);
    internal static long PersianNewYearOnOrBefore(long numberOfDays);
}
public static class System.Globalization.CharUnicodeInfo : object {
    internal static char HIGH_SURROGATE_START;
    internal static char HIGH_SURROGATE_END;
    internal static char LOW_SURROGATE_START;
    internal static char LOW_SURROGATE_END;
    internal static int UNICODE_CATEGORY_OFFSET;
    internal static int BIDI_CATEGORY_OFFSET;
    internal static int UNICODE_PLANE01_START;
    private static UInt16[] s_pCategoryLevel1Index;
    private static Byte[] s_pCategoriesValue;
    private static UInt16[] s_pNumericLevel1Index;
    private static Byte[] s_pNumericValues;
    private static UInt16[] s_pDigitValues;
    private static CharUnicodeInfo();
    internal static int InternalConvertToUtf32(string s, int index);
    internal static int InternalConvertToUtf32(string s, int index, Int32& charLength);
    internal static bool IsWhiteSpace(string s, int index);
    internal static bool IsWhiteSpace(char c);
    internal static double InternalGetNumericValue(int ch);
    internal static ushort InternalGetDigitValues(int ch);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(int ch);
    internal static byte InternalGetCategoryValue(int ch, int offset);
    internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
    internal static BidiCategory GetBidiCategory(string s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength);
    internal static bool IsCombiningCategory(UnicodeCategory uc);
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
internal class System.Globalization.CodePageDataItem : object {
    internal int m_dataIndex;
    internal int m_uiFamilyCodePage;
    internal string m_webName;
    internal string m_headerName;
    internal string m_bodyName;
    internal UInt32 m_flags;
    public string WebName { get; }
    public int UIFamilyCodePage { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public UInt32 Flags { get; }
    internal CodePageDataItem(int dataIndex);
    internal static string CreateString(SByte* pStrings, UInt32 index);
    public string get_WebName();
    public virtual int get_UIFamilyCodePage();
    public string get_HeaderName();
    public string get_BodyName();
    public UInt32 get_Flags();
}
public class System.Globalization.CompareInfo : object {
    private static CompareOptions ValidIndexMaskOffFlags;
    private static CompareOptions ValidCompareMaskOffFlags;
    private static CompareOptions ValidHashCodeOfStringMaskOffFlags;
    private static CompareOptions ValidSortkeyCtorMaskOffFlags;
    [OptionalFieldAttribute]
private string _name;
    private string _sortName;
    [OptionalFieldAttribute]
private SortVersion _sortVersion;
    private bool _invariantMode;
    private IntPtr _sortHandle;
    private static UInt32 LCMAP_SORTKEY;
    private static UInt32 LCMAP_HASH;
    private static int FIND_STARTSWITH;
    private static int FIND_ENDSWITH;
    private static int FIND_FROMSTART;
    private static int FIND_FROMEND;
    private static int COMPARE_OPTIONS_ORDINAL;
    private static int NORM_IGNORECASE;
    private static int NORM_IGNOREKANATYPE;
    private static int NORM_IGNORENONSPACE;
    private static int NORM_IGNORESYMBOLS;
    private static int NORM_IGNOREWIDTH;
    private static int NORM_LINGUISTIC_CASING;
    private static int SORT_STRINGSORT;
    public string Name { get; }
    public SortVersion Version { get; }
    public int LCID { get; }
    internal CompareInfo(CultureInfo culture);
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private void OnDeserialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public virtual string get_Name();
    public virtual int Compare(string string1, string string2);
    public virtual int Compare(string string1, string string2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    private static int CompareOrdinal(string string1, int offset1, int length1, string string2, int offset2, int length2);
    internal static int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int IndexOf(string source, string value, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal int GetHashCodeOfString(string source, CompareOptions options);
    public virtual int GetHashCode(string source, CompareOptions options);
    public virtual string ToString();
    public SortVersion get_Version();
    public int get_LCID();
    internal static int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    private static int InvariantFindString(Char* source, int sourceCount, Char* value, int valueCount, bool ignoreCase, bool start);
    private static char InvariantToUpper(char c);
    private SortKey InvariantCreateSortKey(string source, CompareOptions options);
    private void InitSort(CultureInfo culture);
    private static int FindStringOrdinal(UInt32 dwFindStringOrdinalFlags, string stringSource, int offset, int cchSource, string value, int cchValue, bool bIgnoreCase);
    internal static int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    private int GetHashCodeOfStringCore(string source, CompareOptions options);
    private static int CompareStringOrdinalIgnoreCase(Char* string1, int count1, Char* string2, int count2);
    private int CompareString(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    private int FindString(UInt32 dwFindNLSStringFlags, string lpStringSource, int startSource, int cchSource, string lpStringValue, int startValue, int cchValue, Int32* pcchFound);
    internal int IndexOfCore(string source, string target, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    private int LastIndexOfCore(string source, string target, int startIndex, int count, CompareOptions options);
    private bool StartsWith(string source, string prefix, CompareOptions options);
    private bool EndsWith(string source, string suffix, CompareOptions options);
    private static int FastIndexOfString(string source, string target, int startIndex, int sourceCount, int targetCount, bool findLastIndex);
    private SortKey CreateSortKey(string source, CompareOptions options);
    private static bool IsSortable(Char* text, int length);
    private static int GetNativeCompareFlags(CompareOptions options);
    private SortVersion GetSortVersion();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int InternalGetGlobalizedHashCode(IntPtr handle, string localeName, string source, int length, int dwFlags, long additionalEntropy);
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
internal class System.Globalization.CultureData : object {
    private static int LOCALE_NAME_MAX_LENGTH;
    private static int undef;
    private string _sRealName;
    private string _sWindowsName;
    private string _sName;
    private string _sParent;
    private string _sLocalizedDisplayName;
    private string _sEnglishDisplayName;
    private string _sNativeDisplayName;
    private string _sSpecificCulture;
    private string _sISO639Language;
    private string _sISO639Language2;
    private string _sLocalizedLanguage;
    private string _sEnglishLanguage;
    private string _sNativeLanguage;
    private string _sAbbrevLang;
    private string _sConsoleFallbackName;
    private int _iInputLanguageHandle;
    private string _sRegionName;
    private string _sLocalizedCountry;
    private string _sEnglishCountry;
    private string _sNativeCountry;
    private string _sISO3166CountryName;
    private string _sISO3166CountryName2;
    private int _iGeoId;
    private string _sPositiveSign;
    private string _sNegativeSign;
    private int _iDigits;
    private int _iNegativeNumber;
    private Int32[] _waGrouping;
    private string _sDecimalSeparator;
    private string _sThousandSeparator;
    private string _sNaN;
    private string _sPositiveInfinity;
    private string _sNegativeInfinity;
    private int _iNegativePercent;
    private int _iPositivePercent;
    private string _sPercent;
    private string _sPerMille;
    private string _sCurrency;
    private string _sIntlMonetarySymbol;
    private string _sEnglishCurrency;
    private string _sNativeCurrency;
    private int _iCurrencyDigits;
    private int _iCurrency;
    private int _iNegativeCurrency;
    private Int32[] _waMonetaryGrouping;
    private string _sMonetaryDecimal;
    private string _sMonetaryThousand;
    private int _iMeasure;
    private string _sListSeparator;
    private string _sAM1159;
    private string _sPM2359;
    private string _sTimeSeparator;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saLongTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saShortTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saDurationFormats;
    private int _iFirstDayOfWeek;
    private int _iFirstWeekOfYear;
    private CalendarId[] modreq(System.Runtime.CompilerServices.IsVolatile) _waCalendars;
    private CalendarData[] _calendars;
    private int _iReadingLayout;
    private int _iDefaultAnsiCodePage;
    private int _iDefaultOemCodePage;
    private int _iDefaultMacCodePage;
    private int _iDefaultEbcdicCodePage;
    private int _iLanguage;
    private bool _bUseOverrides;
    private bool _bNeutral;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedRegions;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_RegionNames;
    private static CultureData modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCultures;
    private static object s_lock;
    private static UInt32 LOCALE_NOUSEROVERRIDE;
    private static UInt32 LOCALE_RETURN_NUMBER;
    private static UInt32 LOCALE_SISO3166CTRYNAME;
    private static UInt32 TIME_NOSECONDS;
    private static Dictionary`2<string, string> RegionNames { get; }
    internal static CultureData Invariant { get; }
    internal string CultureName { get; }
    internal bool UseUserOverride { get; }
    internal string SNAME { get; }
    internal string SPARENT { get; }
    internal string SLOCALIZEDDISPLAYNAME { get; }
    internal string SENGDISPLAYNAME { get; }
    internal string SNATIVEDISPLAYNAME { get; }
    internal string SSPECIFICCULTURE { get; }
    internal string SISO639LANGNAME { get; }
    internal string SISO639LANGNAME2 { get; }
    internal string SABBREVLANGNAME { get; }
    internal string SLOCALIZEDLANGUAGE { get; }
    internal string SENGLISHLANGUAGE { get; }
    internal string SNATIVELANGUAGE { get; }
    internal string SREGIONNAME { get; }
    internal int IGEOID { get; }
    internal string SLOCALIZEDCOUNTRY { get; }
    internal string SENGCOUNTRY { get; }
    internal string SNATIVECOUNTRY { get; }
    internal string SISO3166CTRYNAME { get; }
    internal string SISO3166CTRYNAME2 { get; }
    internal int IINPUTLANGUAGEHANDLE { get; }
    internal string SCONSOLEFALLBACKNAME { get; }
    internal Int32[] WAGROUPING { get; }
    internal string SNAN { get; }
    internal string SPOSINFINITY { get; }
    internal string SNEGINFINITY { get; }
    internal int INEGATIVEPERCENT { get; }
    internal int IPOSITIVEPERCENT { get; }
    internal string SPERCENT { get; }
    internal string SPERMILLE { get; }
    internal string SCURRENCY { get; }
    internal string SINTLSYMBOL { get; }
    internal string SENGLISHCURRENCY { get; }
    internal string SNATIVECURRENCY { get; }
    internal Int32[] WAMONGROUPING { get; }
    internal int IMEASURE { get; }
    internal string SLIST { get; }
    internal string SAM1159 { get; }
    internal string SPM2359 { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal int IFIRSTDAYOFWEEK { get; }
    internal int IFIRSTWEEKOFYEAR { get; }
    internal CalendarId[] CalendarIds { get; }
    internal bool IsRightToLeft { get; }
    private int IREADINGLAYOUT { get; }
    internal string STEXTINFO { get; }
    internal string SCOMPAREINFO { get; }
    internal bool IsSupplementalCustomCulture { get; }
    internal int IDEFAULTANSICODEPAGE { get; }
    internal int IDEFAULTOEMCODEPAGE { get; }
    internal int IDEFAULTMACCODEPAGE { get; }
    internal int IDEFAULTEBCDICCODEPAGE { get; }
    internal int ILANGUAGE { get; }
    internal bool IsNeutralCulture { get; }
    internal bool IsInvariantCulture { get; }
    internal Calendar DefaultCalendar { get; }
    internal string TimeSeparator { get; }
    internal bool IsFramework { get; }
    internal bool IsWin32Installed { get; }
    internal bool IsReplacementCulture { get; }
    private static CultureData();
    private static Dictionary`2<string, string> get_RegionNames();
    internal static CultureData GetCultureDataForRegion(string cultureName, bool useUserOverride);
    internal static void ClearCachedData();
    internal static CultureInfo[] GetCultures(CultureTypes types);
    private static CultureData CreateCultureWithInvariantData();
    internal static CultureData get_Invariant();
    internal static CultureData GetCultureData(string cultureName, bool useUserOverride);
    private static string NormalizeCultureName(string name, Boolean& isNeutralName);
    private static CultureData CreateCultureData(string cultureName, bool useUserOverride);
    private bool InitCompatibilityCultureData();
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    internal string get_CultureName();
    internal bool get_UseUserOverride();
    internal string get_SNAME();
    internal string get_SPARENT();
    internal string get_SLOCALIZEDDISPLAYNAME();
    internal string get_SENGDISPLAYNAME();
    internal string get_SNATIVEDISPLAYNAME();
    internal string get_SSPECIFICCULTURE();
    internal string get_SISO639LANGNAME();
    internal string get_SISO639LANGNAME2();
    internal string get_SABBREVLANGNAME();
    internal string get_SLOCALIZEDLANGUAGE();
    internal string get_SENGLISHLANGUAGE();
    internal string get_SNATIVELANGUAGE();
    internal string get_SREGIONNAME();
    internal int get_IGEOID();
    internal string get_SLOCALIZEDCOUNTRY();
    internal string get_SENGCOUNTRY();
    internal string get_SNATIVECOUNTRY();
    internal string get_SISO3166CTRYNAME();
    internal string get_SISO3166CTRYNAME2();
    internal int get_IINPUTLANGUAGEHANDLE();
    internal string get_SCONSOLEFALLBACKNAME();
    internal Int32[] get_WAGROUPING();
    internal string get_SNAN();
    internal string get_SPOSINFINITY();
    internal string get_SNEGINFINITY();
    internal int get_INEGATIVEPERCENT();
    internal int get_IPOSITIVEPERCENT();
    internal string get_SPERCENT();
    internal string get_SPERMILLE();
    internal string get_SCURRENCY();
    internal string get_SINTLSYMBOL();
    internal string get_SENGLISHCURRENCY();
    internal string get_SNATIVECURRENCY();
    internal Int32[] get_WAMONGROUPING();
    internal int get_IMEASURE();
    internal string get_SLIST();
    internal string get_SAM1159();
    internal string get_SPM2359();
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    private String[] AdjustShortTimesForMac(String[] shortTimes);
    private String[] DeriveShortTimesFromLong();
    private static string StripSecondsFromPattern(string time);
    private static int GetIndexOfNextTokenAfterSeconds(string time, int index, Boolean& containsSpace);
    internal int get_IFIRSTDAYOFWEEK();
    internal int get_IFIRSTWEEKOFYEAR();
    internal String[] ShortDates(CalendarId calendarId);
    internal String[] LongDates(CalendarId calendarId);
    internal String[] YearMonths(CalendarId calendarId);
    internal String[] DayNames(CalendarId calendarId);
    internal String[] AbbreviatedDayNames(CalendarId calendarId);
    internal String[] SuperShortDayNames(CalendarId calendarId);
    internal String[] MonthNames(CalendarId calendarId);
    internal String[] GenitiveMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(CalendarId calendarId);
    internal String[] LeapYearMonthNames(CalendarId calendarId);
    internal string MonthDay(CalendarId calendarId);
    internal CalendarId[] get_CalendarIds();
    internal string CalendarName(CalendarId calendarId);
    internal CalendarData GetCalendar(CalendarId calendarId);
    internal bool get_IsRightToLeft();
    private int get_IREADINGLAYOUT();
    internal string get_STEXTINFO();
    internal string get_SCOMPAREINFO();
    internal bool get_IsSupplementalCustomCulture();
    internal int get_IDEFAULTANSICODEPAGE();
    internal int get_IDEFAULTOEMCODEPAGE();
    internal int get_IDEFAULTMACCODEPAGE();
    internal int get_IDEFAULTEBCDICCODEPAGE();
    internal int get_ILANGUAGE();
    internal bool get_IsNeutralCulture();
    internal bool get_IsInvariantCulture();
    internal Calendar get_DefaultCalendar();
    internal String[] EraNames(CalendarId calendarId);
    internal String[] AbbrevEraNames(CalendarId calendarId);
    internal String[] AbbreviatedEnglishEraNames(CalendarId calendarId);
    internal string get_TimeSeparator();
    internal string DateSeparator(CalendarId calendarId);
    private static string UnescapeNlsString(string str, int start, int end);
    private static string GetTimeSeparator(string format);
    private static string GetDateSeparator(string format);
    private static string GetSeparator(string format, string timeParts);
    private static int IndexOfTimePart(string format, int startIndex, string timeParts);
    internal static bool IsCustomCultureId(int cultureId);
    internal void GetNFIValues(NumberFormatInfo nfi);
    internal static string AnsiToLower(string testString);
    private bool InitCultureData();
    internal static string GetLocaleInfoEx(string localeName, UInt32 field);
    internal static int GetLocaleInfoExInt(string localeName, UInt32 field);
    internal static int GetLocaleInfoEx(string lpLocaleName, UInt32 lcType, Char* lpLCData, int cchData);
    private string GetLocaleInfo(LocaleStringData type);
    private string GetLocaleInfo(string localeName, LocaleStringData type);
    private int GetLocaleInfo(LocaleNumberData type);
    private Int32[] GetLocaleInfo(LocaleGroupingData type);
    private string GetTimeFormatString();
    private int GetFirstDayOfWeek();
    private String[] GetTimeFormats();
    private String[] GetShortTimeFormats();
    private static CultureData GetCultureDataFromRegionName(string regionName);
    private string GetLanguageDisplayName(string cultureName);
    private string GetRegionDisplayName(string isoCountryCode);
    private static CultureInfo GetUserDefaultCulture();
    private static string GetLocaleInfoFromLCType(string localeName, UInt32 lctype, bool useUserOveride);
    internal static string ReescapeWin32String(string str);
    internal static String[] ReescapeWin32Strings(String[] array);
    private static Int32[] ConvertWin32GroupString(string win32Str);
    private static int ConvertFirstDayOfWeekMonToSun(int iTemp);
    private static BOOL EnumSystemLocalesProc(IntPtr lpLocaleString, UInt32 flags, IntPtr contextHandle);
    private static BOOL EnumAllSystemLocalesProc(IntPtr lpLocaleString, UInt32 flags, IntPtr contextHandle);
    private static BOOL EnumTimeCallback(IntPtr lpTimeFormatString, IntPtr lParam);
    private static String[] nativeEnumTimeFormats(string localeName, UInt32 dwFlags, bool useUserOverride);
    private static int LocaleNameToLCID(string cultureName);
    private static string LCIDToLocaleName(int culture);
    private int GetAnsiCodePage(string cultureName);
    private int GetOemCodePage(string cultureName);
    private int GetMacCodePage(string cultureName);
    private int GetEbcdicCodePage(string cultureName);
    private int GetGeoId(string cultureName);
    private int GetDigitSubstitution(string cultureName);
    private string GetThreeLetterWindowsLanguageName(string cultureName);
    private static CultureInfo[] EnumCultures(CultureTypes types);
    private string GetConsoleFallbackName(string cultureName);
    internal bool get_IsFramework();
    internal bool get_IsWin32Installed();
    internal bool get_IsReplacementCulture();
}
public class System.Globalization.CultureInfo : object {
    private bool _isReadOnly;
    private CompareInfo compareInfo;
    private TextInfo textInfo;
    internal NumberFormatInfo numInfo;
    internal DateTimeFormatInfo dateTimeInfo;
    private Calendar calendar;
    internal CultureData _cultureData;
    internal bool _isInherited;
    private CultureInfo _consoleFallbackCulture;
    internal string _name;
    private string _nonSortName;
    private string _sortName;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultCulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_InvariantCultureInfo;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture;
    internal static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture;
    internal static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture;
    private static object _lock;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_NameCachedCultures;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_LcidCachedCultures;
    private CultureInfo _parent;
    internal static int LOCALE_NEUTRAL;
    private static int LOCALE_USER_DEFAULT;
    private static int LOCALE_SYSTEM_DEFAULT;
    internal static int LOCALE_CUSTOM_UNSPECIFIED;
    internal static int LOCALE_CUSTOM_DEFAULT;
    internal static int LOCALE_INVARIANT;
    private static bool init;
    private bool _useUserOverride;
    private static WindowsRuntimeResourceManagerBase modreq(System.Runtime.CompilerServices.IsVolatile) s_WindowsRuntimeResourceManager;
    [ThreadStaticAttribute]
private static bool ts_IsDoingAppXCultureInfoLookup;
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public static CultureInfo InvariantCulture { get; }
    public CultureInfo Parent { get; }
    public int LCID { get; }
    public int KeyboardLayoutId { get; }
    public string Name { get; }
    internal string SortName { get; }
    public string IetfLanguageTag { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string EnglishName { get; }
    public string TwoLetterISOLanguageName { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public CompareInfo CompareInfo { get; }
    private static bool OkayToCacheClassWithCompatibilityBehavior { get; }
    public TextInfo TextInfo { get; }
    public bool IsNeutralCulture { get; }
    public CultureTypes CultureTypes { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public Calendar Calendar { get; }
    public Calendar[] OptionalCalendars { get; }
    public bool UseUserOverride { get; }
    public bool IsReadOnly { get; }
    internal bool HasInvariantCultureName { get; }
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    internal CultureInfo(string cultureName, string textAndCompareCultureName);
    private static CultureInfo();
    internal static void AsyncLocalSetCurrentCulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    internal static void AsyncLocalSetCurrentUICulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static bool Init();
    private void InitializeFromCultureId(int culture, bool useUserOverride);
    private void InitializeFromName(string name, bool useUserOverride);
    private static CultureInfo GetCultureByName(string name, bool userOverride);
    public static CultureInfo CreateSpecificCulture(string name);
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    internal static CultureInfo GetCurrentUICultureNoAppX();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_DefaultThreadCurrentCulture();
    public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public static CultureInfo get_InvariantCulture();
    public virtual CultureInfo get_Parent();
    public virtual int get_LCID();
    public virtual int get_KeyboardLayoutId();
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual string get_Name();
    internal string get_SortName();
    public string get_IetfLanguageTag();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_EnglishName();
    public virtual string get_TwoLetterISOLanguageName();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual CompareInfo get_CompareInfo();
    private static bool get_OkayToCacheClassWithCompatibilityBehavior();
    public virtual TextInfo get_TextInfo();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual object GetFormat(Type formatType);
    public virtual bool get_IsNeutralCulture();
    public CultureTypes get_CultureTypes();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public void ClearCachedData();
    internal static Calendar GetCalendarInstance(CalendarId calType);
    internal static Calendar GetCalendarInstanceRare(CalendarId calType);
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public bool get_UseUserOverride();
    public CultureInfo GetConsoleFallbackUICulture();
    public virtual object Clone();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public bool get_IsReadOnly();
    private void VerifyWritable();
    internal bool get_HasInvariantCultureName();
    internal static CultureInfo GetCultureInfoHelper(int lcid, string name, string altName);
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    private static CultureInfo GetUserDefaultCultureCacheOverride();
    internal static CultureInfo GetUserDefaultCulture();
    private static CultureInfo GetUserDefaultUILanguage();
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    internal static CultureInfo GetCultureInfoForUserPreferredLanguageInAppX();
    internal static bool SetCultureInfoForUserPreferredLanguageInAppX(CultureInfo ci);
}
public class System.Globalization.CultureNotFoundException : ArgumentException {
    private string _invalidCultureName;
    private Nullable`1<int> _invalidCultureId;
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    private static string DefaultMessage { get; }
    private string FormatedInvalidCultureId { get; }
    public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    private static string get_DefaultMessage();
    private string get_FormatedInvalidCultureId();
    public virtual string get_Message();
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
public class System.Globalization.DateTimeFormatInfo : object {
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    private CultureData _cultureData;
    [OptionalFieldAttribute]
private string _name;
    private string _langName;
    private CompareInfo _compareInfo;
    private CultureInfo _cultureInfo;
    private string amDesignator;
    private string pmDesignator;
    private string dateSeparator;
    private string generalShortTimePattern;
    private string generalLongTimePattern;
    private string timeSeparator;
    private string monthDayPattern;
    private string dateTimeOffsetPattern;
    private static string rfc1123Pattern;
    private static string sortableDateTimePattern;
    private static string universalSortableDateTimePattern;
    private Calendar calendar;
    private int firstDayOfWeek;
    private int calendarWeekRule;
    private string fullDateTimePattern;
    private String[] abbreviatedDayNames;
    private String[] m_superShortDayNames;
    private String[] dayNames;
    private String[] abbreviatedMonthNames;
    private String[] monthNames;
    private String[] genitiveMonthNames;
    private String[] m_genitiveAbbreviatedMonthNames;
    private String[] leapYearMonthNames;
    private string longDatePattern;
    private string shortDatePattern;
    private string yearMonthPattern;
    private string longTimePattern;
    private string shortTimePattern;
    [OptionalFieldAttribute]
private String[] allYearMonthPatterns;
    private String[] allShortDatePatterns;
    private String[] allLongDatePatterns;
    private String[] allShortTimePatterns;
    private String[] allLongTimePatterns;
    private String[] m_eraNames;
    private String[] m_abbrevEraNames;
    private String[] m_abbrevEnglishEraNames;
    private CalendarId[] optionalCalendars;
    private static int DEFAULT_ALL_DATETIMES_SIZE;
    internal bool _isReadOnly;
    private DateTimeFormatFlags formatFlags;
    [OptionalFieldAttribute]
private bool _useUserOverride;
    internal String[] m_dateWords;
    private static Char[] s_monthSpaces;
    internal static string RoundtripFormat;
    internal static string RoundtripDateTimeUnfixed;
    private string _fullTimeSpanPositivePattern;
    private string _fullTimeSpanNegativePattern;
    internal static DateTimeStyles InvalidDateTimeStyles;
    private TokenHashValue[] _dtfiTokenHash;
    private static int TOKEN_HASH_SIZE;
    private static int SECOND_PRIME;
    private static string dateSeparatorOrTimeZoneOffset;
    private static string invariantDateSeparator;
    private static string invariantTimeSeparator;
    internal static string IgnorablePeriod;
    internal static string IgnorableComma;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal static string LocalTimeMark;
    internal static string GMTName;
    internal static string ZuluName;
    internal static string KoreanLangName;
    internal static string JapaneseLangName;
    internal static string EnglishLangName;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI;
    private string CultureName { get; }
    private CultureInfo Culture { get; }
    private string LanguageName { get; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    private CalendarId[] OptionalCalendars { get; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    private String[] AllYearMonthPatterns { get; }
    private String[] AllShortDatePatterns { get; }
    private String[] AllShortTimePatterns { get; }
    private String[] AllLongDatePatterns { get; }
    private String[] AllLongTimePatterns { get; }
    private String[] UnclonedYearMonthPatterns { get; }
    private String[] UnclonedShortDatePatterns { get; }
    private String[] UnclonedLongDatePatterns { get; }
    private String[] UnclonedShortTimePatterns { get; }
    private String[] UnclonedLongTimePatterns { get; }
    public bool IsReadOnly { get; }
    public string NativeCalendarName { get; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private static DateTimeFormatInfo();
    private string get_CultureName();
    private CultureInfo get_Culture();
    private string get_LanguageName();
    private String[] internalGetAbbreviatedDayOfWeekNames();
    private String[] internalGetSuperShortDayNames();
    private String[] internalGetDayOfWeekNames();
    private String[] internalGetAbbreviatedMonthNames();
    private String[] internalGetMonthNames();
    private void InitializeOverridableProperties(CultureData cultureData, CalendarId calendarId);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    private CalendarId[] get_OptionalCalendars();
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    private static void CheckNullValue(String[] values, int length);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    private String[] internalGetGenitiveMonthNames(bool abbreviated);
    internal String[] internalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    private static String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    private static String[] GetMergedPatterns(String[] patterns, string defaultPattern);
    private String[] get_AllYearMonthPatterns();
    private String[] get_AllShortDatePatterns();
    private String[] get_AllShortTimePatterns();
    private String[] get_AllLongDatePatterns();
    private String[] get_AllLongTimePatterns();
    private String[] get_UnclonedYearMonthPatterns();
    private String[] get_UnclonedShortDatePatterns();
    private String[] get_UnclonedLongDatePatterns();
    private String[] get_UnclonedShortTimePatterns();
    private String[] get_UnclonedLongTimePatterns();
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, string parameterName);
    internal DateTimeFormatFlags get_FormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    private void ClearTokenHashTable();
    internal TokenHashValue[] CreateTokenHashTable();
    private void AddMonthNames(TokenHashValue[] temp, string monthPostfix);
    private static bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number);
    private static bool IsHebrewChar(char ch);
    internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
    private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
    private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
    private bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal static char MonthPostfixChar;
    internal static char IgnorableSymbolChar;
    internal static string CJKYearSuff;
    internal static string CJKMonthSuff;
    internal static string CJKDaySuff;
    internal static string KoreanYearSuff;
    internal static string KoreanMonthSuff;
    internal static string KoreanDaySuff;
    internal static string KoreanHourSuff;
    internal static string KoreanMinuteSuff;
    internal static string KoreanSecondSuff;
    internal static string CJKHourSuff;
    internal static string ChineseHourSuff;
    internal static string CJKMinuteSuff;
    internal static string CJKSecondSuff;
    internal List`1<string> m_dateWords;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_knownWords;
    private FoundDatePattern _ymdFlags;
    private static Dictionary`2<string, string> KnownWords { get; }
    private static Dictionary`2<string, string> get_KnownWords();
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
    private static bool EqualStringArrays(String[] array1, String[] array2);
    private static bool ArrayElementsHaveSpace(String[] array);
    private static bool ArrayElementsBeginWithDigit(String[] array);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    private DateTime _start;
    private DateTime _end;
    private TimeSpan _delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
internal class System.Globalization.DaylightTimeStruct : ValueType {
    public DateTime Start;
    public DateTime End;
    public TimeSpan Delta;
    public DaylightTimeStruct(DateTime start, DateTime end, TimeSpan delta);
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    internal static int LeapMonth;
    internal static int Jan1Month;
    internal static int Jan1Date;
    internal static int nDaysPerMonth;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    private static int DEFAULT_GREGORIAN_TWO_DIGIT_YEAR_MAX;
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static EastAsianLunisolarCalendar();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    private static int GregorianIsLeapYear(int y);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal void GregorianToLunar(int nSYear, int nSMonth, int nSDate, Int32& nLYear, Int32& nLMonth, Int32& nLDate);
    internal bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, Int32& nSolarYear, Int32& nSolarMonth, Int32& nSolarDay);
    internal DateTime LunarToTime(DateTime time, int year, int month, int day);
    internal void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.EncodingTable : object {
    private static int lastEncodingItem;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) lastCodePageItem;
    internal static InternalEncodingDataItem* encodingDataPtr;
    internal static InternalCodePageDataItem* codePageDataPtr;
    private static Hashtable hashByName;
    private static Hashtable hashByCodePage;
    private static EncodingTable();
    private static int internalGetCodePageFromName(string name);
    internal static EncodingInfo[] GetEncodings();
    internal static int GetCodePageFromName(string name);
    internal static CodePageDataItem GetCodePageDataItem(int codepage);
    private static InternalEncodingDataItem* GetEncodingData();
    private static int GetNumEncodingItems();
    private static InternalCodePageDataItem* GetCodePageData();
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    [OptionalFieldAttribute]
internal string eraName;
    [OptionalFieldAttribute]
internal string abbrevEraName;
    [OptionalFieldAttribute]
internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
internal class System.Globalization.GlobalizationAssembly : object {
    internal static Byte* GetGlobalizationResourceBytePtr(Assembly assembly, string tableName);
}
internal class System.Globalization.GlobalizationMode : object {
    private static string c_InvariantModeConfigSwitch;
    [CompilerGeneratedAttribute]
private static bool <Invariant>k__BackingField;
    internal static bool Invariant { get; }
    private static GlobalizationMode();
    [CompilerGeneratedAttribute]
internal static bool get_Invariant();
    private static bool GetGlobalizationInvariantMode();
}
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MaxYear;
    internal GregorianCalendarTypes m_type;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    private static GregorianCalendar();
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual CalendarId get_ID();
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal virtual long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerSecond;
    internal static long TicksPerMinute;
    internal static long TicksPerHour;
    internal static long TicksPerDay;
    internal static int MillisPerSecond;
    internal static int MillisPerMinute;
    internal static int MillisPerHour;
    internal static int MillisPerDay;
    internal static int DaysPerYear;
    internal static int DaysPer4Years;
    internal static int DaysPer100Years;
    internal static int DaysPer400Years;
    internal static int DaysTo10000;
    internal static long MaxMillis;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    [OptionalFieldAttribute]
internal int m_maxYear;
    [OptionalFieldAttribute]
internal int m_minYear;
    internal Calendar m_Cal;
    [OptionalFieldAttribute]
internal EraInfo[] m_EraInfo;
    [OptionalFieldAttribute]
internal Int32[] m_eras;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    private static GregorianCalendarHelper();
    internal int get_MaxYear();
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int DatePartDayOfWeek;
    private static int HebrewYearOf1AD;
    private static int FirstGregorianTableYear;
    private static int LastGregorianTableYear;
    private static int TABLESIZE;
    private static int MinHebrewYear;
    private static int MaxHebrewYear;
    private static Byte[] s_hebrewTable;
    private static int MaxMonthPlusOne;
    private static Byte[] s_lunarMonthLen;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    private static void CheckHebrewYearValue(int y, int era, string varName);
    private void CheckHebrewMonthValue(int year, int month, int era);
    private void CheckHebrewDayValue(int year, int month, int day, int era);
    internal static void CheckEraRange(int era);
    private static void CheckTicksRange(long ticks);
    internal static int GetResult(__DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, __DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    private static int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
    private static DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.HebrewNumber : object {
    private static HebrewValue[] s_hebrewValues;
    private static int minHebrewNumberCh;
    private static char s_maxHebrewNumberCh;
    private static HS[] s_numberPasingState;
    private static int HebrewTokenCount;
    private static HebrewNumber();
    internal static string ToString(int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
public class System.Globalization.HijriCalendar : Calendar {
    private static string InternationalRegKey;
    private static string HijriAdvanceRegKeyEntry;
    public static int HijriEra;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MinAdvancedHijri;
    internal static int MaxAdvancedHijri;
    internal static Int32[] HijriMonthDays;
    private int _hijriAdvance;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static DateTime calendarMinValue;
    internal static DateTime calendarMaxValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    private int GetHijriDateAdjustment();
    private static int GetAdvanceHijriDate();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private long GetAbsoluteDateHijri(int y, int m, int d);
    private long DaysUpToHijriYear(int HijriYear);
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.IdnMapping : object {
    private bool _allowUnassigned;
    private bool _useStd3AsciiRules;
    private static char c_delimiter;
    private static string c_strAcePrefix;
    private static int c_labelLimit;
    private static int c_defaultNameLimit;
    private static int c_initialN;
    private static int c_maxint;
    private static int c_initialBias;
    private static int c_punycodeBase;
    private static int c_tmin;
    private static int c_tmax;
    private static int c_skew;
    private static int c_damp;
    private static Char[] c_Dots;
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    private UInt32 Flags { get; }
    private static IdnMapping();
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetAsciiInvariant(string unicode, int index, int count);
    private static bool ValidateStd3AndAscii(string unicode, bool bUseStd3, bool bCheckAscii);
    private static string PunycodeEncode(string unicode);
    private static bool IsDot(char c);
    private static bool IsSupplementary(int cTest);
    private static bool Basic(UInt32 cp);
    private static void ValidateStd3(char c, bool bNextToDot);
    private string GetUnicodeInvariant(string ascii, int index, int count);
    private static string PunycodeDecode(string ascii);
    private static int DecodeDigit(char cp);
    private static int Adapt(int delta, int numpoints, bool firsttime);
    private static char EncodeBasic(char bcp);
    private static bool HasUpperCaseFlag(char punychar);
    private static char EncodeDigit(int d);
    private string GetAsciiCore(Char* unicode, int count);
    private string GetAsciiCore(Char* unicode, int count, UInt32 flags, Char* output, int outputLength);
    private string GetUnicodeCore(Char* ascii, int count);
    private string GetUnicodeCore(Char* ascii, int count, UInt32 flags, Char* output, int outputLength);
    private UInt32 get_Flags();
    private static void ThrowForZeroLength(string paramName, string invalidNameString, string otherString);
}
internal class System.Globalization.InternalCodePageDataItem : ValueType {
    internal ushort codePage;
    internal ushort uiFamilyCodePage;
    internal UInt32 flags;
    internal SByte* Names;
}
internal class System.Globalization.InternalEncodingDataItem : ValueType {
    internal SByte* webName;
    internal ushort codePage;
}
internal class System.Globalization.InternalGlobalizationHelper : object {
    internal static long TicksPerMillisecond;
    internal static long TicksPerTenthSecond;
    internal static long TicksPerSecond;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo10000;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    internal static long MaxTicks;
    internal static long MinTicks;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static int StringBuilderDefaultCapacity;
    internal static long MaxOffset;
    internal static long MinOffset;
    internal static long TimeToTicks(int hour, int minute, int second);
}
public class System.Globalization.JapaneseCalendar : Calendar {
    private static string c_japaneseErasHive;
    private static string c_japaneseErasHivePermissionList;
    private static String[] s_japaneseErasEnglishNames;
    internal static DateTime calendarMinValue;
    internal static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) japaneseEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    private static EraInfo[] GetJapaneseEras();
    private static int CompareEraRanges(EraInfo a, EraInfo b);
    private static EraInfo GetEraFromValue(string value, string data);
    private static string GetJapaneseEnglishEraName(int era);
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    internal static Calendar GetDefaultInstance();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    internal GregorianCalendarHelper helper;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    private static EraInfo[] TrimEras(EraInfo[] baseEras);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    private static int DatePartYear;
    private static int DatePartDayOfYear;
    private static int DatePartMonth;
    private static int DatePartDay;
    private static int JulianDaysPerYear;
    private static int JulianDaysPer4Years;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    internal int MaxYear;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    internal static EraInfo[] koreanEraInfo;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
public class System.Globalization.NumberFormatInfo : object {
    private static NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    internal Int32[] numberGroupSizes;
    internal Int32[] currencyGroupSizes;
    internal Int32[] percentGroupSizes;
    internal string positiveSign;
    internal string negativeSign;
    internal string numberDecimalSeparator;
    internal string numberGroupSeparator;
    internal string currencyGroupSeparator;
    internal string currencyDecimalSeparator;
    internal string currencySymbol;
    internal string nanSymbol;
    internal string positiveInfinitySymbol;
    internal string negativeInfinitySymbol;
    internal string percentDecimalSeparator;
    internal string percentGroupSeparator;
    internal string percentSymbol;
    internal string perMilleSymbol;
    [OptionalFieldAttribute]
internal String[] nativeDigits;
    internal int numberDecimalDigits;
    internal int currencyDecimalDigits;
    internal int currencyPositivePattern;
    internal int currencyNegativePattern;
    internal int numberNegativePattern;
    internal int percentPositivePattern;
    internal int percentNegativePattern;
    internal int percentDecimalDigits;
    [OptionalFieldAttribute]
internal int digitSubstitution;
    internal bool isReadOnly;
    [OptionalFieldAttribute]
internal bool m_isInvariant;
    private static NumberStyles InvalidNumberStyles;
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public DigitShapes DigitSubstitution { get; public set; }
    internal NumberFormatInfo(CultureData cultureData);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private static void VerifyDecimalSeparator(string decSep, string propertyName);
    private static void VerifyGroupSeparator(string groupSep, string propertyName);
    private static void VerifyNativeDigits(String[] nativeDig, string propertyName);
    private static void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName);
    private void VerifyWritable();
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    internal static long PersianEpoch;
    private static int ApproximateHalfYear;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static int MonthsPerYear;
    internal static Int32[] DaysToMonth;
    internal static int MaxCalendarYear;
    internal static int MaxCalendarMonth;
    internal static int MaxCalendarDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    private long GetAbsoluteDatePersian(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static int MonthFromOrdinalDay(int ordinalDay);
    private static int DaysInPreviousMonths(int month);
    internal int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.RegionInfo : object {
    internal string _name;
    internal CultureData _cultureData;
    internal static RegionInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_currentRegionInfo;
    public static RegionInfo CurrentRegion { get; }
    public string Name { get; }
    public string EnglishName { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string TwoLetterISORegionName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public bool IsMetric { get; }
    public int GeoId { get; }
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public string ISOCurrencySymbol { get; }
    public RegionInfo(string name);
    public RegionInfo(int culture);
    internal RegionInfo(CultureData cultureData);
    private void SetName(string name);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    public static RegionInfo get_CurrentRegion();
    public virtual string get_Name();
    public virtual string get_EnglishName();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_TwoLetterISORegionName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual bool get_IsMetric();
    public virtual int get_GeoId();
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public virtual string get_ISOCurrencySymbol();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortKey : object {
    [OptionalFieldAttribute]
internal string _localeName;
    [OptionalFieldAttribute]
internal int _win32LCID;
    internal CompareOptions _options;
    internal string _string;
    internal Byte[] _keyData;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(string localeName, string str, CompareOptions options, Byte[] keyData);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    public virtual string get_OriginalString();
    public virtual Byte[] get_KeyData();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortVersion : object {
    private int _nlsVersion;
    private Guid _sortId;
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
public class System.Globalization.StringInfo : object {
    [OptionalFieldAttribute]
private string _str;
    private Int32[] _indexes;
    private Int32[] Indexes { get; }
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    private Int32[] get_Indexes();
    public string get_String();
    public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    internal static int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
public class System.Globalization.TaiwanCalendar : Calendar {
    internal static EraInfo[] taiwanEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper helper;
    internal static DateTime calendarMinValue;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    internal static EraInfo[] taiwanLunisolarEraInfo;
    internal GregorianCalendarHelper helper;
    internal static int MIN_LUNISOLAR_YEAR;
    internal static int MAX_LUNISOLAR_YEAR;
    internal static int MIN_GREGORIAN_YEAR;
    internal static int MIN_GREGORIAN_MONTH;
    internal static int MIN_GREGORIAN_DAY;
    internal static int MAX_GREGORIAN_YEAR;
    internal static int MAX_GREGORIAN_MONTH;
    internal static int MAX_GREGORIAN_DAY;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
public class System.Globalization.TextElementEnumerator : object {
    private string _str;
    private int _index;
    private int _startIndex;
    private int _strLen;
    private int _currTextElementLen;
    [OptionalFieldAttribute]
private UnicodeCategory _uc;
    [OptionalFieldAttribute]
private int _charLen;
    private int _endIndex;
    private int _nextTextElementLen;
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex, int strLen);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
public class System.Globalization.TextInfo : object {
    [OptionalFieldAttribute]
private string _listSeparator;
    [OptionalFieldAttribute]
private bool _isReadOnly;
    [OptionalFieldAttribute]
private string _cultureName;
    private CultureData _cultureData;
    private string _textInfoName;
    private Tristate _isAsciiCasingSameAsInvariant;
    private bool _invariantMode;
    internal static TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static int c_wordSeparatorMask;
    private IntPtr _sortHandle;
    private static UInt32 LCMAP_LINGUISTIC_CASING;
    private static UInt32 LCMAP_LOWERCASE;
    private static UInt32 LCMAP_UPPERCASE;
    internal static TextInfo Invariant { get; }
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    public int LCID { get; }
    public string CultureName { get; }
    public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    private bool IsAsciiCasingSameAsInvariant { get; }
    public bool IsRightToLeft { get; }
    internal TextInfo(CultureData cultureData);
    internal static TextInfo get_Invariant();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private void OnDeserialized();
    internal static int GetHashCodeOrdinalIgnoreCase(string s);
    internal static int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
    internal static int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
    public virtual int get_ANSICodePage();
    public virtual int get_OEMCodePage();
    public virtual int get_MacCodePage();
    public virtual int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    public virtual string get_ListSeparator();
    public virtual void set_ListSeparator(string value);
    public virtual char ToLower(char c);
    public virtual string ToLower(string str);
    private string ToLowerAsciiInvariant(string s);
    private string ToUpperAsciiInvariant(string s);
    private static char ToLowerAsciiInvariant(char c);
    public virtual char ToUpper(char c);
    public virtual string ToUpper(string str);
    private static char ToUpperAsciiInvariant(char c);
    private static bool IsAscii(char c);
    private bool get_IsAsciiCasingSameAsInvariant();
    public bool get_IsRightToLeft();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    private static int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private static bool IsWordSeparator(UnicodeCategory category);
    private static bool IsLetterCategory(UnicodeCategory uc);
    internal int GetCaseInsensitiveHashCode(string str);
    private int GetCaseInsensitiveHashCodeSlow(string str);
    private void FinishInitialization(string textInfoName);
    private string ChangeCase(string s, bool toUpper);
    private char ChangeCase(char c, bool toUpper);
    private static bool IsInvariantLocale(string localeName);
}
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    internal static EraInfo[] thaiBuddhistEraInfo;
    public static int ThaiBuddhistEra;
    internal GregorianCalendarHelper helper;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    private static string IntToString(int n, int digits);
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    private static string FormatStandard(TimeSpan value, bool isInvariant, string format, Pattern pattern);
    internal static string FormatCustomized(TimeSpan value, string format, DateTimeFormatInfo dtfi);
}
internal static class System.Globalization.TimeSpanParse : object {
    internal static int unlimitedDigits;
    internal static int maxFractionDigits;
    internal static int maxDays;
    internal static int maxHours;
    internal static int maxMinutes;
    internal static int maxSeconds;
    internal static int maxFraction;
    private static TimeSpanToken zero;
    private static TimeSpanParse();
    internal static void ValidateStyles(TimeSpanStyles style, string parameterName);
    private static bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result);
    internal static TimeSpan Parse(string input, IFormatProvider formatProvider);
    internal static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    private static bool TryParseTimeSpan(string input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result);
    private static bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool TryParseExactTimeSpan(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool TryParseByFormat(string input, string format, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result);
    private static bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, StringBuilder enquotedString);
    private static bool TryParseTimeSpanConstant(string input, TimeSpanResult& result);
    private static bool TryParseExactMultipleTimeSpan(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    internal static int MinCalendarYear;
    internal static int MaxCalendarYear;
    private static DateMapping[] s_hijriYearInfo;
    public static int UmAlQuraEra;
    internal static int DateCycle;
    internal static int DatePartYear;
    internal static int DatePartDayOfYear;
    internal static int DatePartMonth;
    internal static int DatePartDay;
    internal static DateTime minDate;
    internal static DateTime maxDate;
    private static int DEFAULT_TWO_DIGIT_YEAR_MAX;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    private static DateMapping[] InitDateMapping();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private static void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg);
    private static long GetAbsoluteDateUmAlQura(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay);
    internal virtual int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[NonVersionableAttribute]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    public Guid(Byte[] b);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(string g);
    private static Guid();
    public static Guid Parse(string input);
    public static bool TryParse(string input, Guid& result);
    public static Guid ParseExact(string input, string format);
    public static bool TryParseExact(string input, string format, Guid& result);
    private static bool TryParseGuid(string g, GuidStyles flags, GuidResult& result);
    private static bool TryParseGuidWithHexPrefix(string guidString, GuidResult& result);
    private static bool TryParseGuidWithNoStyle(string guidString, GuidResult& result);
    private static bool TryParseGuidWithDashes(string guidString, GuidResult& result);
    private static bool StringToShort(string str, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToShort(string str, Int32* parsePos, int requiredLength, int flags, Int16& result, GuidResult& parseResult);
    private static bool StringToInt(string str, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToInt(string str, Int32& parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToInt(string str, Int32* parsePos, int requiredLength, int flags, Int32& result, GuidResult& parseResult);
    private static bool StringToLong(string str, Int32& parsePos, int flags, Int64& result, GuidResult& parseResult);
    private static bool StringToLong(string str, Int32* parsePos, int flags, Int64& result, GuidResult& parseResult);
    private static string EatAllWhitespace(string str);
    private static bool IsHexPrefix(string str, int i);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    private int GetResult(UInt32 me, UInt32 them);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public static Guid NewGuid();
    public string ToString(string format);
    private static char HexToChar(int a);
    private static int HexsToChars(Char* guidChars, int a, int b);
    private static int HexsToCharsHexOutput(Char* guidChars, int a, int b);
    public sealed virtual string ToString(string format, IFormatProvider provider);
}
internal static class System.HResults : object {
    internal static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int CLDB_E_FILE_CORRUPT;
    internal static int CLDB_E_FILE_OLDVER;
    internal static int CLDB_E_INDEX_NOTFOUND;
    internal static int CLR_E_BIND_ASSEMBLY_NOT_FOUND;
    internal static int CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH;
    internal static int CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW;
    internal static int CLR_E_BIND_TYPE_NOT_FOUND;
    internal static int CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT;
    internal static int COR_E_ABANDONEDMUTEX;
    internal static int COR_E_AMBIGUOUSMATCH;
    internal static int COR_E_APPDOMAINUNLOADED;
    internal static int COR_E_APPLICATION;
    internal static int COR_E_ARGUMENT;
    internal static int COR_E_ARGUMENTOUTOFRANGE;
    internal static int COR_E_ARITHMETIC;
    internal static int COR_E_ARRAYTYPEMISMATCH;
    internal static int COR_E_ASSEMBLYEXPECTED;
    internal static int COR_E_BADIMAGEFORMAT;
    internal static int COR_E_CANNOTUNLOADAPPDOMAIN;
    internal static int COR_E_CODECONTRACTFAILED;
    internal static int COR_E_CONTEXTMARSHAL;
    internal static int COR_E_CUSTOMATTRIBUTEFORMAT;
    internal static int COR_E_DATAMISALIGNED;
    internal static int COR_E_DIVIDEBYZERO;
    internal static int COR_E_DLLNOTFOUND;
    internal static int COR_E_DUPLICATEWAITOBJECT;
    internal static int COR_E_ENTRYPOINTNOTFOUND;
    internal static int COR_E_EXCEPTION;
    internal static int COR_E_EXECUTIONENGINE;
    internal static int COR_E_FIELDACCESS;
    internal static int COR_E_FIXUPSINEXE;
    internal static int COR_E_FORMAT;
    internal static int COR_E_INDEXOUTOFRANGE;
    internal static int COR_E_INSUFFICIENTEXECUTIONSTACK;
    internal static int COR_E_INVALIDCAST;
    internal static int COR_E_INVALIDCOMOBJECT;
    internal static int COR_E_INVALIDFILTERCRITERIA;
    internal static int COR_E_INVALIDOLEVARIANTTYPE;
    internal static int COR_E_INVALIDOPERATION;
    internal static int COR_E_INVALIDPROGRAM;
    internal static int COR_E_KEYNOTFOUND;
    internal static int COR_E_LOADING_REFERENCE_ASSEMBLY;
    internal static int COR_E_MARSHALDIRECTIVE;
    internal static int COR_E_MEMBERACCESS;
    internal static int COR_E_METHODACCESS;
    internal static int COR_E_MISSINGFIELD;
    internal static int COR_E_MISSINGMANIFESTRESOURCE;
    internal static int COR_E_MISSINGMEMBER;
    internal static int COR_E_MISSINGMETHOD;
    internal static int COR_E_MISSINGSATELLITEASSEMBLY;
    internal static int COR_E_MODULE_HASH_CHECK_FAILED;
    internal static int COR_E_MULTICASTNOTSUPPORTED;
    internal static int COR_E_NEWER_RUNTIME;
    internal static int COR_E_NOTFINITENUMBER;
    internal static int COR_E_NOTSUPPORTED;
    internal static int COR_E_NULLREFERENCE;
    internal static int COR_E_OBJECTDISPOSED;
    internal static int COR_E_OPERATIONCANCELED;
    internal static int COR_E_OUTOFMEMORY;
    internal static int COR_E_OVERFLOW;
    internal static int COR_E_PLATFORMNOTSUPPORTED;
    internal static int COR_E_RANK;
    internal static int COR_E_REFLECTIONTYPELOAD;
    internal static int COR_E_REMOTING;
    internal static int COR_E_RUNTIMEWRAPPED;
    internal static int COR_E_SAFEARRAYRANKMISMATCH;
    internal static int COR_E_SAFEARRAYTYPEMISMATCH;
    internal static int COR_E_SECURITY;
    internal static int COR_E_SERIALIZATION;
    internal static int COR_E_SERVER;
    internal static int COR_E_STACKOVERFLOW;
    internal static int COR_E_SYNCHRONIZATIONLOCK;
    internal static int COR_E_SYSTEM;
    internal static int COR_E_TARGET;
    internal static int COR_E_TARGETINVOCATION;
    internal static int COR_E_TARGETPARAMCOUNT;
    internal static int COR_E_THREADABORTED;
    internal static int COR_E_THREADINTERRUPTED;
    internal static int COR_E_THREADSTART;
    internal static int COR_E_THREADSTATE;
    internal static int COR_E_TIMEOUT;
    internal static int COR_E_TYPEACCESS;
    internal static int COR_E_TYPEINITIALIZATION;
    internal static int COR_E_TYPELOAD;
    internal static int COR_E_TYPEUNLOADED;
    internal static int COR_E_UNAUTHORIZEDACCESS;
    internal static int COR_E_VERIFICATION;
    internal static int COR_E_WAITHANDLECANNOTBEOPENED;
    internal static int CORSEC_E_CRYPTO;
    internal static int CORSEC_E_CRYPTO_UNEX_OPER;
    internal static int CORSEC_E_INVALID_IMAGE_FORMAT;
    internal static int CORSEC_E_INVALID_PUBLICKEY;
    internal static int CORSEC_E_INVALID_STRONGNAME;
    internal static int CORSEC_E_MIN_GRANT_FAIL;
    internal static int CORSEC_E_MISSING_STRONGNAME;
    internal static int CORSEC_E_NO_EXEC_PERM;
    internal static int CORSEC_E_POLICY_EXCEPTION;
    internal static int CORSEC_E_SIGNATURE_MISMATCH;
    internal static int CORSEC_E_XMLSYNTAX;
    internal static int CTL_E_DEVICEIOERROR;
    internal static int CTL_E_DIVISIONBYZERO;
    internal static int CTL_E_FILENOTFOUND;
    internal static int CTL_E_OUTOFMEMORY;
    internal static int CTL_E_OUTOFSTACKSPACE;
    internal static int CTL_E_OVERFLOW;
    internal static int CTL_E_PATHFILEACCESSERROR;
    internal static int CTL_E_PATHNOTFOUND;
    internal static int CTL_E_PERMISSIONDENIED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_FAIL;
    internal static int E_HANDLE;
    internal static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    internal static int E_ILLEGAL_METHOD_CALL;
    internal static int E_ILLEGAL_STATE_CHANGE;
    internal static int E_INVALIDARG;
    internal static int E_LAYOUTCYCLE;
    internal static int E_NOTIMPL;
    internal static int E_OUTOFMEMORY;
    internal static int E_POINTER;
    internal static int E_XAMLPARSEFAILED;
    internal static int ERROR_BAD_EXE_FORMAT;
    internal static int ERROR_BAD_NET_NAME;
    internal static int ERROR_BAD_NETPATH;
    internal static int ERROR_DISK_CORRUPT;
    internal static int ERROR_DLL_INIT_FAILED;
    internal static int ERROR_DLL_NOT_FOUND;
    internal static int ERROR_EXE_MARKED_INVALID;
    internal static int ERROR_FILE_CORRUPT;
    internal static int ERROR_FILE_INVALID;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_INVALID_DLL;
    internal static int ERROR_INVALID_NAME;
    internal static int ERROR_INVALID_ORDINAL;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_LOCK_VIOLATION;
    internal static int ERROR_MOD_NOT_FOUND;
    internal static int ERROR_NO_UNICODE_TRANSLATION;
    internal static int ERROR_NOACCESS;
    internal static int ERROR_NOT_READY;
    internal static int ERROR_OPEN_FAILED;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_SHARING_VIOLATION;
    internal static int ERROR_TOO_MANY_OPEN_FILES;
    internal static int ERROR_UNRECOGNIZED_VOLUME;
    internal static int ERROR_WRONG_TARGET_NAME;
    internal static int FUSION_E_ASM_MODULE_MISSING;
    internal static int FUSION_E_CACHEFILE_FAILED;
    internal static int FUSION_E_CODE_DOWNLOAD_DISABLED;
    internal static int FUSION_E_HOST_GAC_ASM_MISMATCH;
    internal static int FUSION_E_INVALID_NAME;
    internal static int FUSION_E_INVALID_PRIVATE_ASM_LOCATION;
    internal static int FUSION_E_LOADFROM_BLOCKED;
    internal static int FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static int FUSION_E_REF_DEF_MISMATCH;
    internal static int FUSION_E_SIGNATURE_CHECK_FAILED;
    internal static int INET_E_CANNOT_CONNECT;
    internal static int INET_E_CONNECTION_TIMEOUT;
    internal static int INET_E_DATA_NOT_AVAILABLE;
    internal static int INET_E_DOWNLOAD_FAILURE;
    internal static int INET_E_OBJECT_NOT_FOUND;
    internal static int INET_E_RESOURCE_NOT_FOUND;
    internal static int INET_E_UNKNOWN_PROTOCOL;
    internal static int ISS_E_ALLOC_TOO_LARGE;
    internal static int ISS_E_BLOCK_SIZE_TOO_SMALL;
    internal static int ISS_E_CALLER;
    internal static int ISS_E_CORRUPTED_STORE_FILE;
    internal static int ISS_E_CREATE_DIR;
    internal static int ISS_E_CREATE_MUTEX;
    internal static int ISS_E_DEPRECATE;
    internal static int ISS_E_FILE_NOT_MAPPED;
    internal static int ISS_E_FILE_WRITE;
    internal static int ISS_E_GET_FILE_SIZE;
    internal static int ISS_E_ISOSTORE;
    internal static int ISS_E_LOCK_FAILED;
    internal static int ISS_E_MACHINE;
    internal static int ISS_E_MACHINE_DACL;
    internal static int ISS_E_MAP_VIEW_OF_FILE;
    internal static int ISS_E_OPEN_FILE_MAPPING;
    internal static int ISS_E_OPEN_STORE_FILE;
    internal static int ISS_E_PATH_LENGTH;
    internal static int ISS_E_SET_FILE_POINTER;
    internal static int ISS_E_STORE_NOT_OPEN;
    internal static int ISS_E_STORE_VERSION;
    internal static int ISS_E_TABLE_ROW_NOT_FOUND;
    internal static int ISS_E_USAGE_WILL_EXCEED_QUOTA;
    internal static int META_E_BAD_SIGNATURE;
    internal static int META_E_CA_FRIENDS_SN_REQUIRED;
    internal static int MSEE_E_ASSEMBLYLOADINPROGRESS;
    internal static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int RO_E_METADATA_NAME_NOT_FOUND;
    internal static int SECURITY_E_INCOMPATIBLE_EVIDENCE;
    internal static int SECURITY_E_INCOMPATIBLE_SHARE;
    internal static int SECURITY_E_UNVERIFIABLE;
    internal static int STG_E_PATHNOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_IO;
    public static int COR_E_PATHTOOLONG;
}
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
public interface System.ICloneable {
    public abstract virtual object Clone();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
    internal InsufficientExecutionStackException(SerializationInfo info, StreamingContext context);
}
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
    private InsufficientMemoryException(SerializationInfo info, StreamingContext context);
}
public class System.Int16 : ValueType {
    internal short m_value;
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    private string ToString(string format, NumberFormatInfo info);
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, IFormatProvider provider);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    private static short Parse(string s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Int16& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    private static bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
public class System.Int32 : ValueType {
    internal int m_value;
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(int value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, IFormatProvider provider);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int32& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
public class System.Int64 : ValueType {
    internal long m_value;
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, IFormatProvider provider);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static bool TryParse(string s, Int64& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal enum System.InternalGCCollectionMode : Enum {
    public int value__;
    public static InternalGCCollectionMode NonBlocking;
    public static InternalGCCollectionMode Blocking;
    public static InternalGCCollectionMode Optimized;
    public static InternalGCCollectionMode Compacting;
}
public class System.IntPtr : ValueType {
    private Void* m_value;
    public static IntPtr Zero;
    public static int Size { get; }
    [NonVersionableAttribute]
public IntPtr(int value);
    [NonVersionableAttribute]
public IntPtr(long value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public IntPtr(Void* value);
    private IntPtr(SerializationInfo info, StreamingContext context);
    internal bool IsNull();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
public int ToInt32();
    [NonVersionableAttribute]
public long ToInt64();
    public virtual string ToString();
    public string ToString(string format);
    [NonVersionableAttribute]
public static IntPtr op_Explicit(int value);
    [NonVersionableAttribute]
public static IntPtr op_Explicit(long value);
    [CLSCompliantAttribute("False")]
[ReliabilityContractAttribute("2", "1")]
[NonVersionableAttribute]
public static IntPtr op_Explicit(Void* value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static Void* op_Explicit(IntPtr value);
    [NonVersionableAttribute]
public static int op_Explicit(IntPtr value);
    [NonVersionableAttribute]
public static long op_Explicit(IntPtr value);
    [NonVersionableAttribute]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static IntPtr Add(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static int get_Size();
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public Void* ToPointer();
}
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    internal InvalidProgramException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.__Error : object {
    internal static int ERROR_FILE_NOT_FOUND;
    internal static int ERROR_PATH_NOT_FOUND;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_INVALID_PARAMETER;
    internal static void EndOfFile();
    internal static void FileNotOpen();
    internal static void StreamIsClosed();
    internal static void MemoryStreamNotExpandable();
    internal static void ReaderClosed();
    internal static void ReadNotSupported();
    internal static void WrongAsyncResult();
    internal static void EndReadCalledTwice();
    internal static void EndWriteCalledTwice();
    internal static string GetDisplayablePath(string path, bool isInvalidPath);
    internal static void WinIOError();
    internal static void WinIOError(int errorCode, string maybeFullPath);
    internal static void WriteNotSupported();
}
internal static class System.IO.__HResults : object {
    public static int COR_E_ENDOFSTREAM;
    public static int COR_E_FILELOAD;
    public static int COR_E_FILENOTFOUND;
    public static int COR_E_DIRECTORYNOTFOUND;
    public static int COR_E_PATHTOOLONG;
    public static int COR_E_IO;
}
public class System.IO.BinaryReader : object {
    private static int MaxCharBytesSize;
    private Stream m_stream;
    private Byte[] m_buffer;
    private Decoder m_decoder;
    private Byte[] m_charBytes;
    private Char[] m_singleChar;
    private Char[] m_charBuffer;
    private int m_maxCharsSize;
    private bool m_2BytesPerChar;
    private bool m_isMemoryStream;
    private bool m_leaveOpen;
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual int PeekChar();
    public virtual int Read();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual char ReadChar();
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    public virtual int Read(Char[] buffer, int index, int count);
    private int InternalReadChars(Char[] buffer, int index, int count);
    private int InternalReadOneChar();
    public virtual Char[] ReadChars(int count);
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual Byte[] ReadBytes(int count);
    protected virtual void FillBuffer(int numBytes);
    protected internal int Read7BitEncodedInt();
}
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    private Byte[] _buffer;
    private Encoding _encoding;
    private Encoder _encoder;
    [OptionalFieldAttribute]
private bool _leaveOpen;
    private Byte[] _largeByteBuffer;
    private int _maxChars;
    private static int LargeByteBufferSize;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    protected void Write7BitEncodedInt(int value);
}
internal static class System.IO.Directory : object {
    internal static string InternalGetDirectoryRoot(string path);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
}
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.DriveNotFoundException : IOException {
    public DriveNotFoundException(string message);
    protected DriveNotFoundException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.EncodingCache : object {
    internal static Encoding UTF8NoBOM;
    private static EncodingCache();
}
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.Error : object {
    internal static Exception GetStreamIsClosed();
    internal static Exception GetEndOfFile();
    internal static Exception GetFileNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
}
internal static class System.IO.File : object {
    private static int ERROR_INVALID_PARAMETER;
    internal static int GENERIC_READ;
    private static int GetFileExInfoStandard;
    public static bool Exists(string path);
    private static bool InternalExistsHelper(string path);
    internal static bool InternalExists(string path);
    public static Byte[] ReadAllBytes(string path);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool tryagain, bool returnErrorOnNotFound);
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
public class System.IO.FileLoadException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private FileLoadException(string fileName, string fusionLog, int hResult);
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetFileLoadExceptionMessage(int hResult, StringHandleOnStack retString);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetMessageForHR(int hresult, StringHandleOnStack retString);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
public class System.IO.FileNotFoundException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private FileNotFoundException(string fileName, string fusionLog, int hResult);
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
public class System.IO.FileStream : Stream {
    private static FileShare DefaultShare;
    private static bool DefaultIsAsync;
    internal static int DefaultBufferSize;
    private Byte[] _buffer;
    private int _bufferLength;
    private SafeFileHandle _fileHandle;
    private FileAccess _access;
    private string _path;
    private int _readPos;
    private int _readLength;
    private int _writePos;
    private bool _useAsyncIO;
    private long _filePosition;
    private bool _exposedHandle;
    private bool _canSeek;
    private bool _isPipe;
    private long _appendStart;
    private static IOCompletionCallback s_ioCallback;
    private Task`1<int> _lastSynchronouslyCompletedTask;
    private Task _activeBufferOperation;
    private PreAllocatedOverlapped _preallocatedOverlapped;
    private FileStreamCompletionSource _currentOverlappedOwner;
    private static int FILE_ATTRIBUTE_NORMAL;
    private static int FILE_ATTRIBUTE_ENCRYPTED;
    private static int FILE_FLAG_OVERLAPPED;
    internal static int GENERIC_READ;
    private static int GENERIC_WRITE;
    private static int FILE_BEGIN;
    private static int FILE_CURRENT;
    private static int FILE_END;
    internal static int ERROR_BROKEN_PIPE;
    internal static int ERROR_NO_DATA;
    private static int ERROR_HANDLE_EOF;
    private static int ERROR_INVALID_PARAMETER;
    private static int ERROR_IO_PENDING;
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public string Name { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool IsClosed { get; }
    private bool HasActiveBufferOperation { get; }
    public bool CanSeek { get; }
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    private static FileStream();
    private static bool GetDefaultIsAsync(SafeFileHandle handle);
    public virtual IntPtr get_Handle();
    public virtual void Lock(long position, long length);
    public virtual void Unlock(long position, long length);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    private void ValidateReadWriteArgs(Byte[] array, int offset, int count);
    public virtual void SetLength(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual string get_Name();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    private void VerifyOSHandlePosition();
    [ConditionalAttribute("DEBUG")]
private void AssertBufferInvariants();
    private void PrepareForReading();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal virtual bool get_IsClosed();
    private Byte[] GetBuffer();
    private void OnBufferAllocated();
    private void FlushInternalBuffer();
    private void FlushReadBuffer();
    private int ReadByteCore();
    private void WriteByteCore(byte value);
    private void PrepareForWriting();
    protected virtual override void Finalize();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private SafeFileHandle OpenHandle(FileMode mode, FileShare share, FileOptions options);
    private void Init(FileMode mode, FileShare share);
    private void InitFromHandle(SafeFileHandle handle);
    private static bool GetSuppressBindHandle(SafeFileHandle handle);
    private static SECURITY_ATTRIBUTES GetSecAttrs(FileShare share);
    private void VerifyHandleIsSync();
    private bool get_HasActiveBufferOperation();
    public virtual bool get_CanSeek();
    private long GetLengthInternal();
    protected virtual void Dispose(bool disposing);
    private void FlushOSBuffer();
    private Task FlushWriteAsync(CancellationToken cancellationToken);
    private void FlushWriteBuffer(bool calledFromFinalizer);
    private void SetLengthInternal(long value);
    private void SetLengthCore(long value);
    private FileStreamCompletionSource CompareExchangeCurrentOverlappedOwner(FileStreamCompletionSource newSource, FileStreamCompletionSource existingSource);
    public virtual int Read(Byte[] array, int offset, int count);
    private int ReadCore(Byte[] array, int offset, int count);
    [ConditionalAttribute("DEBUG")]
private void AssertCanRead(Byte[] buffer, int offset, int count);
    private int ReadNative(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    private long SeekCore(long offset, SeekOrigin origin);
    public virtual void Write(Byte[] array, int offset, int count);
    private void WriteCore(Byte[] buffer, int offset, int count);
    private Task`1<int> ReadAsyncInternal(Byte[] array, int offset, int numBytes, CancellationToken cancellationToken);
    private Task`1<int> ReadNativeAsync(Byte[] bytes, int offset, int numBytes, int numBufferedBytesRead, CancellationToken cancellationToken);
    public virtual int ReadByte();
    private Task WriteAsyncInternal(Byte[] array, int offset, int numBytes, CancellationToken cancellationToken);
    private Task WriteInternalCoreAsync(Byte[] bytes, int offset, int numBytes, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    private int ReadFileNative(SafeFileHandle handle, Byte[] bytes, int offset, int count, NativeOverlapped* overlapped, Int32& errorCode);
    private int WriteFileNative(SafeFileHandle handle, Byte[] bytes, int offset, int count, NativeOverlapped* overlapped, Int32& errorCode);
    private int GetLastWin32ErrorAndDisposeHandleIfInvalid(bool throwIfInvalidHandle);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.FileStream/<AsyncModeCopyToAsync>d__128")]
private Task AsyncModeCopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private Task`1<int> TaskFromResultOrCache(int result);
    private void LockInternal(long position, long length);
    private void UnlockInternal(long position, long length);
}
public class System.IO.IOException : SystemException {
    private string _maybeFullPath;
    public IOException(string message);
    public IOException(string message, int hresult);
    internal IOException(string message, int hresult, string maybeFullPath);
    public IOException(string message, Exception innerException);
    protected IOException(SerializationInfo info, StreamingContext context);
}
public class System.IO.MemoryStream : Stream {
    private Byte[] _buffer;
    private int _origin;
    private int _position;
    private int _length;
    private int _capacity;
    private bool _expandable;
    private bool _writable;
    private bool _exposable;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    private static int MemStreamMaxLength;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureWriteable();
    protected virtual void Dispose(bool disposing);
    private bool EnsureCapacity(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    internal Byte[] InternalGetBuffer();
    [FriendAccessAllowedAttribute]
internal void InternalGetOriginAndLength(Int32& origin, Int32& length);
    internal int InternalGetPosition();
    internal int InternalReadInt32();
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
public static class System.IO.Path : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static char PathSeparator;
    private static int KeyLength;
    [ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    private static Char[] s_base32Char;
    internal static int MaxPath;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static Path();
    public static string ChangeExtension(string path, string extension);
    public static string GetDirectoryName(string path);
    public static string GetExtension(string path);
    public static string GetFileName(string path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetRandomFileName();
    public static bool HasExtension(string path);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    private static string CombineNoChecks(string path1, string path2);
    private static string CombineNoChecks(string path1, string path2, string path3);
    private static string CombineNoChecks(string path1, string path2, string path3, string path4);
    private static void Populate83FileNameFromRandomBytes(Byte* bytes, int byteCount, Char* chars, int charCount);
    public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    internal static StringComparison get_StringComparison();
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static string GetFullPath(string path);
    public static string GetTempPath();
    public static string GetTempFileName();
    public static bool IsPathRooted(string path);
    public static string GetPathRoot(string path);
    internal static bool get_IsCaseSensitive();
}
internal class System.IO.PathHelper : object {
    private static int MaxShortName;
    private static char LastAnsi;
    private static char Delete;
    internal static string Normalize(string path, bool checkInvalidCharacters, bool expandShortPaths);
    private static bool IsDosUnc(StringBuffer& buffer);
    private static void GetFullPathName(string path, StringBuffer& fullPath);
    private static int GetInputBuffer(StringBuffer& content, bool isDosUnc, StringBuffer& buffer);
    private static string TryExpandShortFileName(StringBuffer& outputBuffer, string originalPath);
    private static StringBuffer& Choose(bool condition, StringBuffer& s1, StringBuffer& s2);
}
internal static class System.IO.PathInternal : object {
    internal static Char[] s_trimEndChars;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static char PathSeparator;
    internal static string DirectorySeparatorCharAsString;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static string ParentDirectoryPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int MaxLongPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    internal static int MaxComponentLength;
    private static PathInternal();
    internal static void CheckInvalidPathChars(string path);
    internal static int FindFileNameIndex(string path);
    internal static bool EndsInDirectorySeparator(string path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static void CheckSearchPattern(string searchPattern);
    internal static bool IsValidDriveChar(char value);
    internal static string EnsureExtendedPrefixOverMaxPath(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(string path);
    internal static bool IsExtended(string path);
    internal static bool HasIllegalCharacters(string path);
    internal static bool HasWildCardCharacters(string path);
    internal static int GetRootLength(string path);
    private static int GetRootLength(Char* path, int pathLength);
    private static bool StartsWithOrdinal(Char* source, int sourceLength, string value);
    internal static bool IsPartiallyQualified(string path);
    internal static int PathStartSkip(string path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsDirectoryOrVolumeSeparator(char ch);
    internal static bool IsExtended(StringBuffer& path);
    internal static int GetRootLength(StringBuffer& path);
    internal static bool IsDevice(StringBuffer& path);
    internal static bool IsPartiallyQualified(StringBuffer& path);
}
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    private Byte[] _array;
    private GCHandle _pinningHandle;
    internal PinnedBufferMemoryStream(Byte[] array);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
internal enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    private static int _DefaultCopyBufferSize;
    private ReadWriteTask _activeReadWriteTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private static Stream();
    internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<CopyToAsyncInternal>d__27")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    public virtual int EndRead(IAsyncResult asyncResult);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private bool HasOverriddenBeginEndRead();
    private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    private void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask);
    private void RunReadWriteTask(ReadWriteTask readWriteTask);
    private void FinishTrackingAsyncOperation();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private bool HasOverriddenBeginEndWrite();
    private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static int BlockingEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static void BlockingEndWrite(IAsyncResult asyncResult);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
public class System.IO.UnmanagedMemoryAccessor : object {
    private SafeBuffer _buffer;
    private long _offset;
    private long _capacity;
    private FileAccess _access;
    private bool _isOpen;
    private bool _canRead;
    private bool _canWrite;
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    public decimal ReadDecimal(long position);
    public float ReadSingle(long position);
    public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    public void Write(long position, decimal value);
    public void Write(long position, float value);
    public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void Write(long position, T& structure);
    public void WriteArray(long position, T[] array, int offset, int count);
    private byte InternalReadByte(long position);
    private void InternalWrite(long position, byte value);
    private void EnsureSafeToRead(long position, int sizeOfType);
    private void EnsureSafeToWrite(long position, int sizeOfType);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    private static long UnmanagedMemStreamMaxLength;
    private SafeBuffer _buffer;
    private Byte* _mem;
    private long _length;
    private long _capacity;
    private long _position;
    private long _offset;
    private FileAccess _access;
    internal bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    internal Byte* Pointer { get; }
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public long get_Capacity();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    internal Byte* get_Pointer();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    private UnmanagedMemoryStream _unmanagedStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error();
    internal static Exception GetExceptionForWin32Error(int errorCode);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static string GetMessage(int errorCode);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
internal interface System.IRuntimeFieldInfo {
    public RuntimeFieldHandleInternal Value { get; }
    public abstract virtual RuntimeFieldHandleInternal get_Value();
}
internal interface System.IRuntimeMethodInfo {
    public RuntimeMethodHandleInternal Value { get; }
    public abstract virtual RuntimeMethodHandleInternal get_Value();
}
internal interface System.ITupleInternal {
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
internal interface System.IValueTupleInternal {
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual string ToStringEnd();
}
[DebuggerTypeProxyAttribute("System.System_LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
public class System.Lazy`1 : object {
    private LazyHelper modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Func`1<T> _factory;
    private T _value;
    internal T ValueForDebugDisplay { get; }
    internal Nullable`1<LazyThreadSafetyMode> Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode, bool useDefaultConstructor);
    private static T CreateViaDefaultConstructor();
    private void ViaConstructor();
    private void ViaFactory(LazyThreadSafetyMode mode);
    private void ExecutionAndPublication(LazyHelper executionAndPublication, bool useDefaultConstructor);
    private void PublicationOnly(LazyHelper publicationOnly, T possibleValue);
    private void PublicationOnlyViaConstructor(LazyHelper initializer);
    private void PublicationOnlyViaFactory(LazyHelper initializer);
    private void PublicationOnlyWaitForOtherThreadToPublish();
    private T CreateValue();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal Nullable`1<LazyThreadSafetyMode> get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
internal class System.LazyHelper : object {
    internal static LazyHelper NoneViaConstructor;
    internal static LazyHelper NoneViaFactory;
    internal static LazyHelper PublicationOnlyViaConstructor;
    internal static LazyHelper PublicationOnlyViaFactory;
    internal static LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
    [CompilerGeneratedAttribute]
private LazyState <State>k__BackingField;
    private ExceptionDispatchInfo _exceptionDispatch;
    internal LazyState State { get; }
    internal LazyHelper(LazyState state);
    internal LazyHelper(LazyThreadSafetyMode mode, Exception exception);
    private static LazyHelper();
    [CompilerGeneratedAttribute]
internal LazyState get_State();
    internal void ThrowException();
    private LazyThreadSafetyMode GetMode();
    internal static Nullable`1<LazyThreadSafetyMode> GetMode(LazyHelper state);
    internal static bool GetIsValueFaulted(LazyHelper state);
    internal static LazyHelper Create(LazyThreadSafetyMode mode, bool useDefaultConstructor);
    internal static object CreateViaDefaultConstructor(Type type);
    internal static LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
}
internal enum System.LazyState : Enum {
    public int value__;
    public static LazyState NoneViaConstructor;
    public static LazyState NoneViaFactory;
    public static LazyState NoneException;
    public static LazyState PublicationOnlyViaConstructor;
    public static LazyState PublicationOnlyViaFactory;
    public static LazyState PublicationOnlyWait;
    public static LazyState PublicationOnlyException;
    public static LazyState ExecutionAndPublicationViaConstructor;
    public static LazyState ExecutionAndPublicationViaFactory;
    public static LazyState ExecutionAndPublicationException;
}
internal enum System.LoaderOptimization : Enum {
    public int value__;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
}
internal enum System.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Status;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Panic;
}
public abstract class System.MarshalByRefObject : object {
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
public static class System.Math : object {
    private static double doubleRoundLimit;
    private static int maxRoundingDigits;
    private static Double[] roundPower10Double;
    public static double PI;
    public static double E;
    private static Math();
    public static double Acos(double d);
    public static double Asin(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static decimal Ceiling(decimal d);
    public static double Ceiling(double a);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static decimal Floor(decimal d);
    public static double Floor(double d);
    private static double InternalRound(double value, int digits, MidpointRounding mode);
    private static double InternalTruncate(double d);
    public static double Sin(double a);
    public static double Tan(double a);
    public static double Sinh(double value);
    public static double Tanh(double value);
    public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static double SplitFractionDouble(Double* value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
    public static double Sqrt(double d);
    public static double Log(double d);
    public static double Log10(double d);
    public static double Exp(double d);
    public static double Pow(double x, double y);
    public static double IEEERemainder(double x, double y);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    private static sbyte AbsHelper(sbyte value);
    public static short Abs(short value);
    private static short AbsHelper(short value);
    public static int Abs(int value);
    private static int AbsHelper(int value);
    public static long Abs(long value);
    private static long AbsHelper(long value);
    public static float Abs(float value);
    public static double Abs(double value);
    public static decimal Abs(decimal value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Max(sbyte val1, sbyte val2);
    [NonVersionableAttribute]
public static byte Max(byte val1, byte val2);
    [NonVersionableAttribute]
public static short Max(short val1, short val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Max(ushort val1, ushort val2);
    [NonVersionableAttribute]
public static int Max(int val1, int val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [NonVersionableAttribute]
public static long Max(long val1, long val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Max(ulong val1, ulong val2);
    public static float Max(float val1, float val2);
    public static double Max(double val1, double val2);
    public static decimal Max(decimal val1, decimal val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Min(sbyte val1, sbyte val2);
    [NonVersionableAttribute]
public static byte Min(byte val1, byte val2);
    [NonVersionableAttribute]
public static short Min(short val1, short val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Min(ushort val1, ushort val2);
    [NonVersionableAttribute]
public static int Min(int val1, int val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [NonVersionableAttribute]
public static long Min(long val1, long val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Min(ulong val1, ulong val2);
    public static float Min(float val1, float val2);
    public static double Min(double val1, double val2);
    public static decimal Min(decimal val1, decimal val2);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    private static void ThrowMinMaxException(T min, T max);
    public static double Log(double a, double newBase);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    public static int Sign(float value);
    public static int Sign(double value);
    public static int Sign(decimal value);
    public static long BigMul(int a, int b);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
}
public static class System.MathF : object {
    private static float singleRoundLimit;
    private static int maxRoundingDigits;
    private static Single[] roundPower10Single;
    public static float PI;
    public static float E;
    private static MathF();
    public static float Abs(float x);
    public static float Acos(float x);
    public static float Asin(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x);
    public static float Log(float x, float y);
    public static float Log10(float x);
    public static float Max(float x, float y);
    public static float Min(float x, float y);
    public static float Pow(float x, float y);
    public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static float Round(float x, MidpointRounding mode);
    public static int Sign(float x);
    public static float Sin(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    public static float Truncate(float x);
    private static float InternalRound(float x, int digits, MidpointRounding mode);
    private static float InternalTruncate(float x);
    private static float SplitFractionSingle(Single* x);
}
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.MemberSerializationStringGenerator : object {
    [ExtensionAttribute]
public static string SerializationToString(PropertyInfo property);
    [ExtensionAttribute]
public static string SerializationToString(ConstructorInfo constructor);
    [ExtensionAttribute]
public static string SerializationToString(MethodInfo method);
}
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
}
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    public MissingFieldException(string message);
    public MissingFieldException(string message, Exception inner);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public MissingFieldException(string className, string fieldName);
    public virtual string get_Message();
}
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public MissingMemberException(string className, string memberName);
    public virtual string get_Message();
    internal static string FormatSignature(Byte[] signature);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    public MissingMethodException(string message);
    public MissingMethodException(string message, Exception inner);
    public MissingMethodException(string className, string methodName);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
public class System.ModuleHandle : ValueType {
    public static ModuleHandle EmptyHandle;
    private RuntimeModule m_ptr;
    public int MDStreamVersion { get; }
    internal ModuleHandle(RuntimeModule module);
    private static ModuleHandle();
    private static ModuleHandle GetEmptyMH();
    internal RuntimeModule GetRuntimeModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ModuleHandle handle);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    internal static IRuntimeMethodInfo GetDynamicMethod(DynamicMethod method, RuntimeModule module, string name, Byte[] sig, Resolver resolver);
    internal static int GetToken(RuntimeModule module);
    private static void ValidateModulePointer(RuntimeModule module);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static RuntimeType ResolveTypeHandleInternal(RuntimeModule module, int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void ResolveType(RuntimeModule module, int typeToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount, ObjectHandleOnStack type);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static RuntimeMethodHandleInternal ResolveMethodHandleInternalCore(RuntimeModule module, int methodToken, IntPtr[] typeInstantiationContext, int typeInstCount, IntPtr[] methodInstantiationContext, int methodInstCount);
    [SuppressUnmanagedCodeSecurityAttribute]
private static RuntimeMethodHandleInternal ResolveMethod(RuntimeModule module, int methodToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static IRuntimeFieldInfo ResolveFieldHandleInternal(RuntimeModule module, int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void ResolveField(RuntimeModule module, int fieldToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount, ObjectHandleOnStack retField);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool _ContainsPropertyMatchingHash(RuntimeModule module, int propertyToken, UInt32 hash);
    internal static bool ContainsPropertyMatchingHash(RuntimeModule module, int propertyToken, UInt32 hash);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetModuleType(RuntimeModule handle, ObjectHandleOnStack type);
    internal static RuntimeType GetModuleType(RuntimeModule module);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetPEKind(RuntimeModule handle, Int32& peKind, Int32& machine);
    internal static void GetPEKind(RuntimeModule module, PortableExecutableKinds& peKind, ImageFileMachine& machine);
    internal static int GetMDStreamVersion(RuntimeModule module);
    public int get_MDStreamVersion();
    private static IntPtr _GetMetadataImport(RuntimeModule module);
    internal static MetadataImport GetMetadataImport(RuntimeModule module);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
[ComVisibleAttribute("True")]
public abstract class System.MulticastDelegate : Delegate {
    private object _invocationList;
    private IntPtr _invocationCount;
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    internal bool IsUnmanagedFunctionPtr();
    internal bool InvocationListLogicallyNull();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual bool Equals(object obj);
    private bool InvocationListEquals(MulticastDelegate d);
    private bool TrySetSlot(Object[] a, int index, object o);
    private MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount, bool thisIsMultiCastAlready);
    internal MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount);
    internal void StoreDynamicMethod(MethodInfo dynamicMethod);
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    private Object[] DeleteFromInvocationList(Object[] invocationList, int invocationCount, int deleteIndex, int deleteCount);
    private bool EqualInvocationLists(Object[] a, Object[] b, int start, int count);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
    public sealed virtual Delegate[] GetInvocationList();
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    public sealed virtual int GetHashCode();
    internal virtual object GetTarget();
    protected virtual MethodInfo GetMethodImpl();
    [DebuggerNonUserCodeAttribute]
private void ThrowNullThisInDelegateToInstance();
    [DebuggerNonUserCodeAttribute]
private void CtorClosed(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorClosedStatic(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorRTClosed(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk);
    [DebuggerNonUserCodeAttribute]
private void CtorSecureClosed(object target, IntPtr methodPtr, IntPtr callThunk, IntPtr creatorMethod);
    [DebuggerNonUserCodeAttribute]
private void CtorSecureClosedStatic(object target, IntPtr methodPtr, IntPtr callThunk, IntPtr creatorMethod);
    [DebuggerNonUserCodeAttribute]
private void CtorSecureRTClosed(object target, IntPtr methodPtr, IntPtr callThunk, IntPtr creatorMethod);
    [DebuggerNonUserCodeAttribute]
private void CtorSecureOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr callThunk, IntPtr creatorMethod);
    [DebuggerNonUserCodeAttribute]
private void CtorVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk);
    [DebuggerNonUserCodeAttribute]
private void CtorSecureVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr callThunk, IntPtr creatorMethod);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleClosedStatic(object target, IntPtr methodPtr, IntPtr gchandle);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr gchandle);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr gchandle);
}
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    internal static bool IsDefined(RuntimeFieldInfo field);
}
public class System.NotFiniteNumberException : ArithmeticException {
    private double _offendingNumber;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
}
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
[NonVersionableAttribute]
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [NonVersionableAttribute]
public Nullable`1(T value);
    [NonVersionableAttribute]
public bool get_HasValue();
    public T get_Value();
    [NonVersionableAttribute]
public T GetValueOrDefault();
    [NonVersionableAttribute]
public T GetValueOrDefault(T defaultValue);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NonVersionableAttribute]
public static Nullable`1<T> op_Implicit(T value);
    [NonVersionableAttribute]
public static T op_Explicit(Nullable`1<T> value);
}
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
[FriendAccessAllowedAttribute]
internal class System.Number : object {
    private static int NumberMaxDigits;
    private static int Int32Precision;
    private static int UInt32Precision;
    private static int Int64Precision;
    private static int UInt64Precision;
    public static string FormatDecimal(decimal value, string format, NumberFormatInfo info);
    public static string FormatDouble(double value, string format, NumberFormatInfo info);
    public static string FormatInt32(int value, string format, NumberFormatInfo info);
    public static string FormatUInt32(UInt32 value, string format, NumberFormatInfo info);
    public static string FormatInt64(long value, string format, NumberFormatInfo info);
    public static string FormatUInt64(ulong value, string format, NumberFormatInfo info);
    public static string FormatSingle(float value, string format, NumberFormatInfo info);
    public static bool NumberBufferToDecimal(Byte* number, Decimal& value);
    internal static bool NumberBufferToDouble(Byte* number, Double& value);
    private static bool HexNumberToInt32(NumberBuffer& number, Int32& value);
    private static bool HexNumberToInt64(NumberBuffer& number, Int64& value);
    private static bool HexNumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool HexNumberToUInt64(NumberBuffer& number, UInt64& value);
    private static bool IsWhite(char ch);
    private static bool NumberToInt32(NumberBuffer& number, Int32& value);
    private static bool NumberToInt64(NumberBuffer& number, Int64& value);
    private static bool NumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool NumberToUInt64(NumberBuffer& number, UInt64& value);
    private static Char* MatchChars(Char* p, string str);
    private static Char* MatchChars(Char* p, Char* str);
    internal static decimal ParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt);
    internal static double ParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt);
    internal static int ParseInt32(string s, NumberStyles style, NumberFormatInfo info);
    internal static long ParseInt64(string value, NumberStyles options, NumberFormatInfo numfmt);
    private static bool ParseNumber(Char*& str, NumberStyles options, NumberBuffer& number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal);
    internal static float ParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt);
    internal static UInt32 ParseUInt32(string value, NumberStyles options, NumberFormatInfo numfmt);
    internal static ulong ParseUInt64(string value, NumberStyles options, NumberFormatInfo numfmt);
    private static void StringToNumber(string str, NumberStyles options, NumberBuffer& number, NumberFormatInfo info, bool parseDecimal);
    private static bool TrailingZeros(string s, int index);
    internal static bool TryParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt, Decimal& result);
    internal static bool TryParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt, Double& result);
    internal static bool TryParseInt32(string s, NumberStyles style, NumberFormatInfo info, Int32& result);
    internal static bool TryParseInt64(string s, NumberStyles style, NumberFormatInfo info, Int64& result);
    internal static bool TryParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt, Single& result);
    internal static bool TryParseUInt32(string s, NumberStyles style, NumberFormatInfo info, UInt32& result);
    internal static bool TryParseUInt64(string s, NumberStyles style, NumberFormatInfo info, UInt64& result);
    internal static bool TryStringToNumber(string str, NumberStyles options, NumberBuffer& number, NumberFormatInfo numfmt, bool parseDecimal);
    [FriendAccessAllowedAttribute]
internal static bool TryStringToNumber(string str, NumberStyles options, NumberBuffer& number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal);
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int RandomSeed;
    private static HashHelpers();
    public static int Combine(int h1, int h2);
}
[ClassInterfaceAttribute("2")]
[ComVisibleAttribute("True")]
public class System.Object {
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    [NonVersionableAttribute]
public static bool ReferenceEquals(object objA, object objB);
    public virtual int GetHashCode();
    public Type GetType();
    [NonVersionableAttribute]
protected virtual void Finalize();
    protected object MemberwiseClone();
    private void FieldSetter(string typeName, string fieldName, object val);
    private void FieldGetter(string typeName, string fieldName, Object& val);
    private FieldInfo GetFieldInfo(string typeName, string fieldName);
}
public class System.ObjectDisposedException : InvalidOperationException {
    private string _objectName;
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string objectName, string message);
    public ObjectDisposedException(string message, Exception innerException);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    private string _message;
    private bool _error;
    public string Message { get; }
    public bool IsError { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_Message();
    public bool get_IsError();
}
internal class System.OleAutBinder : DefaultBinder {
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
}
internal class System.OperatingSystem : object {
    private Version _version;
    private PlatformID _platform;
    private string _servicePack;
    private string _versionString;
    public Version Version { get; }
    public string VersionString { get; }
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    private OperatingSystem(SerializationInfo info, StreamingContext context);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
}
public class System.OperationCanceledException : SystemException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalComparer : StringComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.OrdinalIgnoreCaseComparer : StringComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
internal class System.ParamsArray : ValueType {
    private static Object[] s_oneArgArray;
    private static Object[] s_twoArgArray;
    private static Object[] s_threeArgArray;
    private object _arg0;
    private object _arg1;
    private object _arg2;
    private Object[] _args;
    public int Length { get; }
    public object Item { get; }
    public ParamsArray(object arg0);
    public ParamsArray(object arg0, object arg1);
    public ParamsArray(object arg0, object arg1, object arg2);
    public ParamsArray(Object[] args);
    private static ParamsArray();
    public int get_Length();
    public object get_Item(int index);
    private object GetAtSlow(int index);
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull;
    public static ParseFailureKind Format;
    public static ParseFailureKind FormatWithParameter;
    public static ParseFailureKind FormatBadDateTimeCalendar;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    internal static int PrintAsI1;
    internal static int PrintAsI2;
    internal static int PrintAsI4;
    internal static int TreatAsUnsigned;
    internal static int TreatAsI1;
    internal static int TreatAsI2;
    internal static int IsTight;
    internal static int NoSpace;
    public static long StringToLong(string s, int radix, int flags);
    public static long StringToLong(string s, int radix, int flags, Int32* currPos);
    public static long StringToLong(string s, int radix, int flags, Int32& currPos);
    public static int StringToInt(string s, int radix, int flags);
    public static int StringToInt(string s, int radix, int flags, Int32* currPos);
    public static int StringToInt(string s, int radix, int flags, Int32& currPos);
    public static string IntToString(int l, int radix, int width, char paddingChar, int flags);
    public static string LongToString(long l, int radix, int width, char paddingChar, int flags);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fCustomNumberParser;
    internal MatchNumberDelegate parseNumberDelegate;
    internal void Init();
}
internal class System.PinnableBufferCache : object {
    private static int DefaultNumberOfBuffers;
    private string m_CacheName;
    private Func`1<object> m_factory;
    private ConcurrentStack`1<object> m_FreeList;
    private List`1<object> m_NotGen2;
    private int m_gen1CountAtLastRestock;
    private int m_msecNoUseBeyondFreeListSinceThisTime;
    private bool m_moreThanFreeListNeeded;
    private int m_buffersUnderManagement;
    private int m_restockSize;
    private bool m_trimmingExperimentInProgress;
    private int m_minBufferCount;
    private int m_numAllocCalls;
    internal PinnableBufferCache(string cacheName, Func`1<object> factory);
    internal object Allocate();
    internal void Free(object buffer);
    private void Restock(Object& returnBuffer);
    private bool AgePendingBuffers();
    private void CreateNewBuffers();
    private static bool Gen2GcCallbackFunc(object targetObj);
    private bool TrimFreeListIfNeeded();
}
internal class System.PinnableBufferCacheEventSource : object {
    public static PinnableBufferCacheEventSource Log;
    private static PinnableBufferCacheEventSource();
    public bool IsEnabled();
    public void DebugMessage(string message);
    public void Create(string cacheName);
    public void AllocateBuffer(string cacheName, ulong objectId, int objectHash, int objectGen, int freeCountAfter);
    public void AllocateBufferFromNotGen2(string cacheName, int notGen2CountAfter);
    public void AllocateBufferCreatingNewBuffers(string cacheName, int totalBuffsBefore, int objectCount);
    public void AllocateBufferAged(string cacheName, int agedCount);
    public void AllocateBufferFreeListEmpty(string cacheName, int notGen2CountBefore);
    public void FreeBuffer(string cacheName, ulong objectId, int objectHash, int freeCountBefore);
    public void FreeBufferStillTooYoung(string cacheName, int notGen2CountBefore);
    public void TrimCheck(string cacheName, int totalBuffs, bool neededMoreThanFreeList, int deltaMSec);
    public void TrimFree(string cacheName, int totalBuffs, int freeListCount, int toBeFreed);
    public void TrimExperiment(string cacheName, int totalBuffs, int freeListCount, int numTrimTrial);
    public void TrimFreeSizeOK(string cacheName, int totalBuffs, int freeListCount);
    public void TrimFlush(string cacheName, int totalBuffs, int freeListCount, int notGen2CountBefore);
    public void AgePendingBuffersResults(string cacheName, int promotedToFreeListCount, int heldBackCount);
    public void WalkFreeListResult(string cacheName, int freeListCount, int gen0BuffersInFreeList);
    internal static ulong AddressOf(object obj);
}
internal enum System.PlatformID : Enum {
    public int value__;
    public static PlatformID Win32S;
    public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    public static PlatformID WinCE;
    public static PlatformID Unix;
    public static PlatformID Xbox;
    public static PlatformID MacOSX;
}
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.Progress`1 : object {
    private SynchronizationContext _synchronizationContext;
    private Action`1<T> _handler;
    private SendOrPostCallback _invokeHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<T> ProgressChanged;
    public Progress`1(Action`1<T> handler);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    private void InvokeHandlers(object state);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
public class System.Random : object {
    private static int MBIG;
    private static int MSEED;
    private static int MZ;
    private int _inext;
    private int _inextp;
    private Int32[] _seedArray;
    [ThreadStaticAttribute]
private static Random t_threadRandom;
    private static Random s_globalRandom;
    public Random(int Seed);
    private static Random();
    protected virtual double Sample();
    private int InternalSample();
    private static int GenerateSeed();
    private static int GenerateGlobalSeed();
    public virtual int Next();
    private double GetSampleForLargeRange();
    public virtual int Next(int minValue, int maxValue);
    public virtual int Next(int maxValue);
    public virtual double NextDouble();
    public virtual void NextBytes(Byte[] buffer);
}
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    protected RankException(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.ReadOnlySpan`1 : ValueType {
    private ByReference`1<T> _pointer;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public T Item { get; }
    public static ReadOnlySpan`1<T> Empty { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(T& ptr, int length);
    public static ReadOnlySpan`1<T> DangerousCreate(object obj, T& objectData, int length);
    public T& DangerousGetPinnableReference();
    public int get_Length();
    public bool get_IsEmpty();
    public T get_Item(int index);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> arraySegment);
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    public static ReadOnlySpan`1<T> get_Empty();
}
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Assembly : object {
    private static Dictionary`2<string, Assembly> s_loadfile;
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public bool IsFullyTrusted { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string EscapedCodeBase { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    private static Assembly();
    public static Assembly LoadFrom(string assemblyFile);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
internal static Assembly LoadFrom(string assemblyFile, Evidence securityEvidence);
    public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public static Assembly Load(string assemblyString);
    internal static Type GetType_Compat(string assemblyString, string typeName);
    public static Assembly Load(AssemblyName assemblyRef);
    internal static Assembly Load(AssemblyName assemblyRef, IntPtr ptrLoadContextBinder);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly LoadFile(string path);
    public static Assembly GetExecutingAssembly();
    public static Assembly GetCallingAssembly();
    public static Assembly GetEntryAssembly();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Type[] GetTypes();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual Type[] GetExportedTypes();
    public virtual string get_CodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_FullName();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public bool get_IsFullyTrusted();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string get_EscapedCodeBase();
    public object CreateInstance(string typeName);
    public object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual Module get_ManifestModule();
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual IEnumerable`1<Module> get_Modules();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    public static Assembly Load(Byte[] rawAssembly);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    public static Assembly UnsafeLoadFrom(string assemblyFile);
    public Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual SecurityRuleSet get_SecurityRuleSet();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <AlgorithmId>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    [CompilerGeneratedAttribute]
public UInt32 get_AlgorithmId();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    [CompilerGeneratedAttribute]
public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultAlias>k__BackingField;
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    [CompilerGeneratedAttribute]
public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    private AssemblyNameFlags _flags;
    [ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Reflection.AssemblyName : object {
    private string _Name;
    private Byte[] _PublicKey;
    private Byte[] _PublicKeyToken;
    private CultureInfo _CultureInfo;
    private string _CodeBase;
    private Version _Version;
    private StrongNameKeyPair _StrongNameKeyPair;
    private SerializationInfo m_siInfo;
    private Byte[] _HashForControl;
    private AssemblyHashAlgorithm _HashAlgorithm;
    private AssemblyHashAlgorithm _HashAlgorithmForControl;
    private AssemblyVersionCompatibility _VersionCompatibility;
    private AssemblyNameFlags _Flags;
    private static Char[] s_hexUpperChars;
    internal static char c_DummyChar;
    private static short c_MaxAsciiCharsReallocate;
    private static short c_MaxUnicodeCharsReallocate;
    private static short c_MaxUTF_8BytesPerUnicodeChar;
    private static short c_EncodedCharsPerByte;
    private static string RFC3986ReservedMarks;
    private static string RFC3986UnreservedMarks;
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    public string CodeBase { get; public set; }
    public string EscapedCodeBase { get; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public string FullName { get; }
    internal AssemblyName(SerializationInfo info, StreamingContext context);
    public AssemblyName(string assemblyName);
    private static AssemblyName();
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public string get_EscapedCodeBase();
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public sealed virtual object Clone();
    public static AssemblyName GetAssemblyName(string assemblyFile);
    internal void SetHashControl(Byte[] hash, AssemblyHashAlgorithm hashAlgorithm);
    public Byte[] GetPublicKey();
    public void SetPublicKey(Byte[] publicKey);
    public Byte[] GetPublicKeyToken();
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public string get_FullName();
    public virtual string ToString();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    internal void nInit(RuntimeAssembly& assembly, bool forIntrospection, bool raiseResolveEvent);
    internal void nInit();
    internal void SetProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm);
    internal static ProcessorArchitecture CalculateProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm, AssemblyNameFlags flags);
    internal void Init(string name, Byte[] publicKey, Byte[] publicKeyToken, Version version, CultureInfo cultureInfo, AssemblyHashAlgorithm hashAlgorithm, AssemblyVersionCompatibility versionCompatibility, string codeBase, AssemblyNameFlags flags, StrongNameKeyPair keyPair);
    internal static AssemblyName nGetFileInformation(string s);
    private string nToString();
    private Byte[] nGetPublicKeyToken();
    internal static string EscapeCodeBase(string codebase);
    internal static Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd);
    private static Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos);
    internal static void EscapeAsciiChar(char ch, Char[] to, Int32& pos);
    internal static char EscapedAscii(char digit, char next);
    private static bool IsReservedUnreservedOrHash(char c);
    internal static bool IsUnreserved(char c);
    internal static bool IsAsciiLetter(char character);
    internal static bool IsAsciiLetterOrDigit(char character);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    [CompilerGeneratedAttribute]
public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Countersignature>k__BackingField;
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public string get_Countersignature();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Trademark>k__BackingField;
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    [CompilerGeneratedAttribute]
public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
internal static class System.Reflection.Associates : object {
    internal static bool IncludeAccessor(MethodInfo associate, bool nonPublic);
    private static RuntimeMethodInfo AssignAssociates(int tkMethod, RuntimeType declaredType, RuntimeType reflectedType);
    internal static void AssignAssociates(MetadataImport scope, int mdPropEvent, RuntimeType declaringType, RuntimeType reflectedType, RuntimeMethodInfo& addOn, RuntimeMethodInfo& removeOn, RuntimeMethodInfo& fireOn, RuntimeMethodInfo& getter, RuntimeMethodInfo& setter, MethodInfo[]& other, Boolean& composedOfAllPrivateMethods, BindingFlags& bindingFlags);
}
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.CerHashtable`2 : ValueType {
    private Table<K, V> m_Table;
    private static int MinSize;
    internal V Item { get; internal set; }
    private static int GetHashCodeHelper(K key);
    private void Rehash(int newSize);
    internal void set_Item(K key, V value);
    internal V get_Item(K key);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.ConstArray : ValueType {
    internal int m_length;
    internal IntPtr m_constArray;
    public IntPtr Signature { get; }
    public int Length { get; }
    public byte Item { get; }
    public IntPtr get_Signature();
    public int get_Length();
    public byte get_Item(int index);
}
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    public static string ConstructorName;
    public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
internal enum System.Reflection.CorElementType : Enum {
    public byte value__;
    public static CorElementType End;
    public static CorElementType Void;
    public static CorElementType Boolean;
    public static CorElementType Char;
    public static CorElementType I1;
    public static CorElementType U1;
    public static CorElementType I2;
    public static CorElementType U2;
    public static CorElementType I4;
    public static CorElementType U4;
    public static CorElementType I8;
    public static CorElementType U8;
    public static CorElementType R4;
    public static CorElementType R8;
    public static CorElementType String;
    public static CorElementType Ptr;
    public static CorElementType ByRef;
    public static CorElementType ValueType;
    public static CorElementType Class;
    public static CorElementType Var;
    public static CorElementType Array;
    public static CorElementType GenericInst;
    public static CorElementType TypedByRef;
    public static CorElementType I;
    public static CorElementType U;
    public static CorElementType FnPtr;
    public static CorElementType Object;
    public static CorElementType SzArray;
    public static CorElementType MVar;
    public static CorElementType CModReqd;
    public static CorElementType CModOpt;
    public static CorElementType Internal;
    public static CorElementType Max;
    public static CorElementType Modifier;
    public static CorElementType Sentinel;
    public static CorElementType Pinned;
}
internal static class System.Reflection.CustomAttribute : object {
    private static RuntimeType Type_RuntimeType;
    private static RuntimeType Type_Type;
    private static CustomAttribute();
    internal static bool IsDefined(RuntimeType type, RuntimeType caType, bool inherit);
    internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
    internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeType type, RuntimeType caType, bool inherit);
    private static bool AllowCriticalCustomAttributes(RuntimeType type);
    private static bool SpecialAllowCriticalAttributes(RuntimeType type);
    private static bool AllowCriticalCustomAttributes(MethodBase method);
    private static bool AllowCriticalCustomAttributes(RuntimeFieldInfo field);
    private static bool AllowCriticalCustomAttributes(RuntimeParameterInfo parameter);
    internal static Object[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    internal static Object[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeModule module, RuntimeType caType);
    internal static bool IsAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, int attributeCtorToken);
    private static bool IsCustomAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType);
    private static bool IsCustomAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType, int attributeCtorToken, bool mustBeInheritable);
    private static Object[] GetCustomAttributes(RuntimeModule decoratedModule, int decoratedMetadataToken, int pcaCount, RuntimeType attributeFilterType, bool isDecoratedTargetSecurityTransparent);
    private static Object[] GetCustomAttributes(RuntimeModule decoratedModule, int decoratedMetadataToken, int pcaCount, RuntimeType attributeFilterType, bool mustBeInheritable, IList derivedAttributes, bool isDecoratedTargetSecurityTransparent);
    private static bool FilterCustomAttributeRecord(CustomAttributeRecord caRecord, MetadataImport scope, Assembly& lastAptcaOkAssembly, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, bool mustBeInheritable, Object[] attributes, IList derivedAttributes, RuntimeType& attributeType, IRuntimeMethodInfo& ctor, Boolean& ctorHasParameters, Boolean& isVarArg);
    private static bool AttributeUsageCheck(RuntimeType attributeType, bool mustBeInheritable, Object[] attributes, IList derivedAttributes);
    internal static AttributeUsageAttribute GetAttributeUsage(RuntimeType decoratedAttribute);
    private static void _ParseAttributeUsageAttribute(IntPtr pCa, int cCa, Int32& targets, Boolean& inherited, Boolean& allowMultiple);
    private static void ParseAttributeUsageAttribute(ConstArray ca, AttributeTargets& targets, Boolean& inherited, Boolean& allowMultiple);
    private static object _CreateCaObject(RuntimeModule pModule, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs);
    private static object CreateCaObject(RuntimeModule module, IRuntimeMethodInfo ctor, IntPtr& blob, IntPtr blobEnd, Int32& namedArgs);
    private static void _GetPropertyOrFieldData(RuntimeModule pModule, Byte** ppBlobStart, Byte* pBlobEnd, String& name, Boolean& bIsProperty, RuntimeType& type, Object& value);
    private static void GetPropertyOrFieldData(RuntimeModule module, IntPtr& blobStart, IntPtr blobEnd, String& name, Boolean& isProperty, RuntimeType& type, Object& value);
    private static Object[] CreateAttributeArrayHelper(Type elementType, int elementCount);
}
internal class System.Reflection.CustomAttributeCtorParameter : ValueType {
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument CustomAttributeEncodedArgument { get; }
    public CustomAttributeCtorParameter(CustomAttributeType type);
    public CustomAttributeEncodedArgument get_CustomAttributeEncodedArgument();
}
public class System.Reflection.CustomAttributeData : object {
    private ConstructorInfo m_ctor;
    private RuntimeModule m_scope;
    private MemberInfo[] m_members;
    private CustomAttributeCtorParameter[] m_ctorParams;
    private CustomAttributeNamedParameter[] m_namedParams;
    private IList`1<CustomAttributeTypedArgument> m_typedCtorArgs;
    private IList`1<CustomAttributeNamedArgument> m_namedArgs;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    private CustomAttributeData(RuntimeModule scope, CustomAttributeRecord caRecord);
    internal CustomAttributeData(Attribute attribute);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeFieldInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeMethodInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeConstructorInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeEventInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimePropertyInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeModule target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeAssembly target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeParameterInfo target);
    private static CustomAttributeEncoding TypeToCustomAttributeEncoding(RuntimeType type);
    private static CustomAttributeType InitCustomAttributeType(RuntimeType parameterType);
    private static IList`1<CustomAttributeData> GetCustomAttributes(RuntimeModule module, int tkTarget);
    internal static CustomAttributeRecord[] GetCustomAttributeRecords(RuntimeModule module, int targetToken);
    internal static CustomAttributeTypedArgument Filter(IList`1<CustomAttributeData> attrs, Type caType, int parameter);
    private void Init(DllImportAttribute dllImport);
    private void Init(FieldOffsetAttribute fieldOffset);
    private void Init(MarshalAsAttribute marshalAs);
    private void Init(TypeForwardedToAttribute forwardedTo);
    private void Init(object pca);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
internal class System.Reflection.CustomAttributeEncodedArgument : ValueType {
    private long m_primitiveValue;
    private CustomAttributeEncodedArgument[] m_arrayValue;
    private string m_stringValue;
    private CustomAttributeType m_type;
    public CustomAttributeType CustomAttributeType { get; }
    public long PrimitiveValue { get; }
    public CustomAttributeEncodedArgument[] ArrayValue { get; }
    public string StringValue { get; }
    private static void ParseAttributeArguments(IntPtr pCa, int cCa, CustomAttributeCtorParameter[]& CustomAttributeCtorParameters, CustomAttributeNamedParameter[]& CustomAttributeTypedArgument, RuntimeAssembly assembly);
    internal static void ParseAttributeArguments(ConstArray attributeBlob, CustomAttributeCtorParameter[]& customAttributeCtorParameters, CustomAttributeNamedParameter[]& customAttributeNamedParameters, RuntimeModule customAttributeModule);
    public CustomAttributeType get_CustomAttributeType();
    public long get_PrimitiveValue();
    public CustomAttributeEncodedArgument[] get_ArrayValue();
    public string get_StringValue();
}
internal enum System.Reflection.CustomAttributeEncoding : Enum {
    public int value__;
    public static CustomAttributeEncoding Undefined;
    public static CustomAttributeEncoding Boolean;
    public static CustomAttributeEncoding Char;
    public static CustomAttributeEncoding SByte;
    public static CustomAttributeEncoding Byte;
    public static CustomAttributeEncoding Int16;
    public static CustomAttributeEncoding UInt16;
    public static CustomAttributeEncoding Int32;
    public static CustomAttributeEncoding UInt32;
    public static CustomAttributeEncoding Int64;
    public static CustomAttributeEncoding UInt64;
    public static CustomAttributeEncoding Float;
    public static CustomAttributeEncoding Double;
    public static CustomAttributeEncoding String;
    public static CustomAttributeEncoding Array;
    public static CustomAttributeEncoding Type;
    public static CustomAttributeEncoding Object;
    public static CustomAttributeEncoding Field;
    public static CustomAttributeEncoding Property;
    public static CustomAttributeEncoding Enum;
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private MemberInfo m_memberInfo;
    private CustomAttributeTypedArgument m_value;
    internal Type ArgumentType { get; }
    public MemberInfo MemberInfo { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public string MemberName { get; }
    public bool IsField { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal Type get_ArgumentType();
    public MemberInfo get_MemberInfo();
    public CustomAttributeTypedArgument get_TypedValue();
    public string get_MemberName();
    public bool get_IsField();
}
internal class System.Reflection.CustomAttributeNamedParameter : ValueType {
    private string m_argumentName;
    private CustomAttributeEncoding m_fieldOrProperty;
    private CustomAttributeEncoding m_padding;
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument EncodedArgument { get; }
    public CustomAttributeNamedParameter(string argumentName, CustomAttributeEncoding fieldOrProperty, CustomAttributeType type);
    public CustomAttributeEncodedArgument get_EncodedArgument();
}
internal class System.Reflection.CustomAttributeRecord : ValueType {
    internal ConstArray blob;
    internal MetadataToken tkCtor;
}
internal class System.Reflection.CustomAttributeType : ValueType {
    private string m_enumName;
    private CustomAttributeEncoding m_encodedType;
    private CustomAttributeEncoding m_encodedEnumType;
    private CustomAttributeEncoding m_encodedArrayType;
    private CustomAttributeEncoding m_padding;
    public CustomAttributeEncoding EncodedType { get; }
    public CustomAttributeEncoding EncodedEnumType { get; }
    public CustomAttributeEncoding EncodedArrayType { get; }
    public string EnumName { get; }
    public CustomAttributeType(CustomAttributeEncoding encodedType, CustomAttributeEncoding encodedArrayType, CustomAttributeEncoding encodedEnumType, string enumName);
    public CustomAttributeEncoding get_EncodedType();
    public CustomAttributeEncoding get_EncodedEnumType();
    public CustomAttributeEncoding get_EncodedArrayType();
    public string get_EnumName();
}
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object m_value;
    private Type m_argumentType;
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public CustomAttributeTypedArgument(object value);
    internal CustomAttributeTypedArgument(RuntimeModule scope, CustomAttributeEncodedArgument encodedArg);
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    private static Type CustomAttributeEncodingToType(CustomAttributeEncoding encodedType);
    private static object EncodedValueToRawValue(long val, CustomAttributeEncoding encodedType);
    private static RuntimeType ResolveType(RuntimeModule scope, string typeName);
    private static object CanonicalizeValue(object value);
    public virtual string ToString();
    internal string ToString(bool typed);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Type get_ArgumentType();
    public object get_Value();
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
internal class System.Reflection.Emit.__ExceptionInfo : object {
    internal static int None;
    internal static int Filter;
    internal static int Finally;
    internal static int Fault;
    internal static int PreserveStack;
    internal static int State_Try;
    internal static int State_Filter;
    internal static int State_Catch;
    internal static int State_Finally;
    internal static int State_Fault;
    internal static int State_Done;
    internal int m_startAddr;
    internal Int32[] m_filterAddr;
    internal Int32[] m_catchAddr;
    internal Int32[] m_catchEndAddr;
    internal Int32[] m_type;
    internal Type[] m_catchClass;
    internal Label m_endLabel;
    internal Label m_finallyEndLabel;
    internal int m_endAddr;
    internal int m_endFinally;
    internal int m_currentCatch;
    private int m_currentState;
    internal __ExceptionInfo(int startAddr, Label endLabel);
    private void MarkHelper(int catchorfilterAddr, int catchEndAddr, Type catchClass, int type);
    internal void MarkFilterAddr(int filterAddr);
    internal void MarkFaultAddr(int faultAddr);
    internal void MarkCatchAddr(int catchAddr, Type catchException);
    internal void MarkFinallyAddr(int finallyAddr, int endCatchAddr);
    internal void Done(int endAddr);
    internal int GetStartAddress();
    internal int GetEndAddress();
    internal int GetFinallyEndAddress();
    internal Label GetEndLabel();
    internal Int32[] GetFilterAddresses();
    internal Int32[] GetCatchAddresses();
    internal Int32[] GetCatchEndAddresses();
    internal Type[] GetCatchClass();
    internal int GetNumberOfCatches();
    internal Int32[] GetExceptionTypes();
    internal void SetFinallyEndLabel(Label lbl);
    internal Label GetFinallyEndLabel();
    internal bool IsInner(__ExceptionInfo exc);
    internal int GetCurrentState();
}
internal class System.Reflection.Emit.__FixupData : ValueType {
    internal Label m_fixupLabel;
    internal int m_fixupPos;
    internal int m_fixupInstSize;
}
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    internal AssemblyBuilderData m_assemblyData;
    private InternalAssemblyBuilder m_internalAssemblyBuilder;
    private ModuleBuilder m_manifestModuleBuilder;
    private bool m_fManifestModuleUsedAsDefinedModule;
    internal static string MANIFEST_MODULE_NAME;
    internal object SyncRoot { get; }
    internal InternalAssemblyBuilder InternalAssembly { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    internal AssemblyBuilder(AppDomain domain, AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes, SecurityContextSource securityContextSource);
    private static RuntimeModule GetInMemoryAssemblyModule(RuntimeAssembly assembly);
    private Module nGetInMemoryAssemblyModule();
    internal ModuleBuilder GetModuleBuilder(InternalModuleBuilder module);
    internal object get_SyncRoot();
    internal InternalAssemblyBuilder get_InternalAssembly();
    internal RuntimeAssembly GetNativeHandle();
    private void InitManifestModule();
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    private static Assembly nCreateDynamicAssembly(AppDomain domain, AssemblyName name, Evidence identity, StackCrawlMark& stackMark, Byte[] securityRulesBlob, Byte[] aptcaBlob, AssemblyBuilderAccess access, DynamicAssemblyFlags flags, SecurityContextSource securityContextSource);
    internal static AssemblyBuilder InternalDefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, string dir, Evidence evidence, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes, SecurityContextSource securityContextSource);
    public ModuleBuilder DefineDynamicModule(string name);
    public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
    private ModuleBuilder DefineDynamicModuleInternal(string name, bool emitSymbolInfo, StackCrawlMark& stackMark);
    private ModuleBuilder DefineDynamicModuleInternalNoLock(string name, bool emitSymbolInfo, StackCrawlMark& stackMark);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    public virtual string get_CodeBase();
    public virtual MethodInfo get_EntryPoint();
    public virtual Type[] GetExportedTypes();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual string get_FullName();
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module get_ManifestModule();
    public virtual bool get_ReflectionOnly();
    public virtual Module GetModule(string name);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual bool get_IsDynamic();
    public ModuleBuilder GetDynamicModule(string name);
    private ModuleBuilder GetDynamicModuleNoLock(string name);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private void SetCustomAttributeNoLock(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private void SetCustomAttributeNoLock(CustomAttributeBuilder customBuilder);
}
[FlagsAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess RunAndCollect;
}
internal class System.Reflection.Emit.AssemblyBuilderData : object {
    internal List`1<ModuleBuilder> m_moduleBuilderList;
    internal List`1<ResWriterData> m_resWriterList;
    internal string m_strAssemblyName;
    internal AssemblyBuilderAccess m_access;
    private InternalAssemblyBuilder m_assembly;
    internal Type[] m_publicComTypeList;
    internal int m_iPublicComTypeCount;
    internal bool m_isSaved;
    internal static int m_iInitialSize;
    internal string m_strDir;
    internal static int m_tkAssembly;
    internal CustomAttributeBuilder[] m_CABuilders;
    internal int m_iCABuilder;
    internal Byte[][] m_CABytes;
    internal ConstructorInfo[] m_CACons;
    internal int m_iCAs;
    internal PEFileKinds m_peFileKind;
    internal MethodInfo m_entryPointMethod;
    internal Assembly m_ISymWrapperAssembly;
    internal string m_strResourceFileName;
    internal Byte[] m_resourceBytes;
    internal NativeVersionInfo m_nativeVersion;
    internal bool m_hasUnmanagedVersionInfo;
    internal bool m_OverrideUnmanagedVersionInfo;
    internal AssemblyBuilderData(InternalAssemblyBuilder assembly, string strAssemblyName, AssemblyBuilderAccess access, string dir);
    internal void AddModule(ModuleBuilder dynModule);
    internal void AddCustomAttribute(CustomAttributeBuilder customBuilder);
    internal void AddCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    internal void CheckTypeNameConflict(string strTypeName, TypeBuilder enclosingType);
}
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    private MethodBuilder m_methodBuilder;
    internal bool m_isDefaultConstructor;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public CallingConventions CallingConvention { get; }
    public string Signature { get; }
    public bool InitLocals { get; public set; }
    internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers, ModuleBuilder mod, TypeBuilder type);
    internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, ModuleBuilder mod, TypeBuilder type);
    internal virtual Type[] GetParameterTypes();
    private TypeBuilder GetTypeBuilder();
    public virtual string ToString();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public MethodToken GetToken();
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual CallingConventions get_CallingConvention();
    public Module GetModule();
    internal virtual Type GetReturnType();
    public string get_Signature();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
}
internal class System.Reflection.Emit.ConstructorOnTypeBuilderInstantiation : ConstructorInfo {
    internal ConstructorInfo m_ctor;
    private TypeBuilderInstantiation m_type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    internal ConstructorOnTypeBuilderInstantiation(ConstructorInfo constructor, TypeBuilderInstantiation type);
    internal static ConstructorInfo GetConstructor(ConstructorInfo Constructor, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethod();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    internal ConstructorInfo m_con;
    internal Object[] m_constructorArgs;
    internal Byte[] m_blob;
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private bool ValidateType(Type t);
    internal void InitCustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private static void VerifyTypeAndPassedObjectType(Type type, Type passedType, string paramName);
    private void EmitType(BinaryWriter writer, Type type);
    private void EmitString(BinaryWriter writer, string str);
    private void EmitValue(BinaryWriter writer, Type type, object value);
    internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner);
    internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner, int tkAttrib, bool toDisk);
}
[FlagsAttribute]
internal enum System.Reflection.Emit.DynamicAssemblyFlags : Enum {
    public int value__;
    public static DynamicAssemblyFlags None;
    public static DynamicAssemblyFlags AllCritical;
    public static DynamicAssemblyFlags Aptca;
    public static DynamicAssemblyFlags Critical;
    public static DynamicAssemblyFlags Transparent;
    public static DynamicAssemblyFlags TreatAsSafe;
}
internal class System.Reflection.Emit.DynamicILGenerator : ILGenerator {
    internal DynamicScope m_scope;
    private int m_methodSigToken;
    internal DynamicILGenerator(DynamicMethod method, Byte[] methodSignature, int size);
    internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type type);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void UsingNamespace(string ns);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    private int GetMemberRefToken(MethodBase methodInfo, Type[] optionalParameterTypes);
    internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    internal virtual void RecordTokenFixup();
    private int GetTokenFor(RuntimeType rtType);
    private int GetTokenFor(RuntimeFieldInfo runtimeField);
    private int GetTokenFor(RuntimeFieldInfo runtimeField, RuntimeType rtType);
    private int GetTokenFor(RuntimeConstructorInfo rtMeth);
    private int GetTokenFor(RuntimeConstructorInfo rtMeth, RuntimeType rtType);
    private int GetTokenFor(RuntimeMethodInfo rtMeth);
    private int GetTokenFor(RuntimeMethodInfo rtMeth, RuntimeType rtType);
    private int GetTokenFor(DynamicMethod dm);
    private int GetTokenForVarArgMethod(RuntimeMethodInfo rtMeth, SignatureHelper sig);
    private int GetTokenForVarArgMethod(DynamicMethod dm, SignatureHelper sig);
    private int GetTokenForString(string s);
    private int GetTokenForSig(Byte[] sig);
}
internal class System.Reflection.Emit.DynamicILInfo : object {
    private DynamicMethod m_method;
    private DynamicScope m_scope;
    private Byte[] m_exceptions;
    private Byte[] m_code;
    private Byte[] m_localSignature;
    private int m_maxStackSize;
    private int m_methodSignature;
    internal Byte[] LocalSignature { get; }
    internal Byte[] Exceptions { get; }
    internal Byte[] Code { get; }
    internal int MaxStackSize { get; }
    public DynamicMethod DynamicMethod { get; }
    internal DynamicScope DynamicScope { get; }
    internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    internal Byte[] get_LocalSignature();
    internal Byte[] get_Exceptions();
    internal Byte[] get_Code();
    internal int get_MaxStackSize();
    public DynamicMethod get_DynamicMethod();
    internal DynamicScope get_DynamicScope();
}
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    private RuntimeType[] m_parameterTypes;
    internal IRuntimeMethodInfo m_methodHandle;
    private RuntimeType m_returnType;
    private DynamicILGenerator m_ilGenerator;
    private DynamicILInfo m_DynamicILInfo;
    private bool m_fInitLocals;
    private RuntimeModule m_module;
    internal bool m_skipVisibility;
    internal RuntimeType m_typeOwner;
    private RTDynamicMethod m_dynMethod;
    internal DynamicResolver m_resolver;
    internal bool m_restrictedSkipVisibility;
    private static InternalModuleBuilder modreq(System.Runtime.CompilerServices.IsVolatile) s_anonymouslyHostedDynamicMethodsModule;
    private static object s_anonymouslyHostedDynamicMethodsModuleLock;
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public bool InitLocals { get; public set; }
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    private static DynamicMethod();
    private static void CheckConsistency(MethodAttributes attributes, CallingConventions callingConvention);
    private static RuntimeModule GetDynamicMethodsModule();
    private void Init(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] signature, Type owner, Module m, bool skipVisibility, bool transparentMethod);
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    internal RuntimeMethodHandle GetMethodDescriptor();
    public virtual string ToString();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal MethodInfo GetMethodInfo();
}
internal class System.Reflection.Emit.DynamicResolver : Resolver {
    private __ExceptionInfo[] m_exceptions;
    private Byte[] m_exceptionHeader;
    private DynamicMethod m_method;
    private Byte[] m_code;
    private Byte[] m_localSignature;
    private int m_stackSize;
    private DynamicScope m_scope;
    internal DynamicResolver(DynamicILGenerator ilGenerator);
    internal DynamicResolver(DynamicILInfo dynamicILInfo);
    protected virtual override void Finalize();
    internal virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    private static int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal virtual Byte[] GetLocalsSignature();
    internal virtual Byte[] GetRawEHInfo();
    internal virtual void GetEHInfo(int excNumber, Void* exc);
    internal virtual string GetStringLiteral(int token);
    internal virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal virtual MethodInfo GetDynamicMethod();
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Emit.DynamicScope : object {
    internal List`1<object> m_tokens;
    internal object Item { get; }
    internal object get_Item(int token);
    internal int GetTokenFor(VarArgMethod varArgMethod);
    internal string GetString(int token);
    internal Byte[] ResolveSignature(int token, int fromMethod);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle typeContext);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle typeContext);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(Byte[] signature);
}
public class System.Reflection.Emit.EnumBuilder : TypeInfo {
    internal TypeBuilder m_typeBuilder;
    private FieldBuilder m_underlyingField;
    public TypeToken TypeToken { get; }
    public FieldBuilder UnderlyingField { get; }
    public string Name { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsSZArray { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal EnumBuilder(string name, Type underlyingType, TypeAttributes visibility, ModuleBuilder module);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    public TypeInfo CreateTypeInfo();
    public Type CreateType();
    public TypeToken get_TypeToken();
    public FieldBuilder get_UnderlyingField();
    public virtual string get_Name();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type GetEnumUnderlyingType();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
}
public class System.Reflection.Emit.EventBuilder : object {
    private string m_name;
    private EventToken m_evToken;
    private ModuleBuilder m_module;
    private EventAttributes m_attributes;
    private TypeBuilder m_type;
    internal EventBuilder(ModuleBuilder mod, string name, EventAttributes attr, TypeBuilder type, EventToken evToken);
    public EventToken GetEventToken();
    private void SetMethodSemantics(MethodBuilder mdBuilder, MethodSemanticsAttributes semantics);
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public class System.Reflection.Emit.EventToken : ValueType {
    public static EventToken Empty;
    internal int m_event;
    public int Token { get; }
    internal EventToken(int str);
    private static EventToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(EventToken obj);
    public static bool op_Equality(EventToken a, EventToken b);
    public static bool op_Inequality(EventToken a, EventToken b);
}
internal class System.Reflection.Emit.ExceptionHandler : ValueType {
    internal int m_exceptionClass;
    internal int m_tryStartOffset;
    internal int m_tryEndOffset;
    internal int m_filterOffset;
    internal int m_handlerStartOffset;
    internal int m_handlerEndOffset;
    internal ExceptionHandlingClauseOptions m_kind;
    internal ExceptionHandler(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken);
    private static bool IsValidKind(ExceptionHandlingClauseOptions kind);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExceptionHandler other);
    public static bool op_Equality(ExceptionHandler left, ExceptionHandler right);
    public static bool op_Inequality(ExceptionHandler left, ExceptionHandler right);
}
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    private int m_fieldTok;
    private FieldToken m_tkField;
    private TypeBuilder m_typeBuilder;
    private string m_fieldName;
    private FieldAttributes m_Attributes;
    private Type m_fieldType;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Type FieldType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    internal FieldBuilder(TypeBuilder typeBuilder, string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    internal void SetData(Byte[] data, int size);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public FieldToken GetToken();
    public void SetOffset(int iOffset);
    public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
internal class System.Reflection.Emit.FieldOnTypeBuilderInstantiation : FieldInfo {
    private FieldInfo m_field;
    private TypeBuilderInstantiation m_type;
    internal FieldInfo FieldInfo { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    internal FieldOnTypeBuilderInstantiation(FieldInfo field, TypeBuilderInstantiation type);
    internal static FieldInfo GetField(FieldInfo Field, TypeBuilderInstantiation type);
    internal FieldInfo get_FieldInfo();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual object GetValueDirect(TypedReference obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual FieldAttributes get_Attributes();
}
public class System.Reflection.Emit.FieldToken : ValueType {
    public static FieldToken Empty;
    internal int m_fieldTok;
    internal object m_class;
    public int Token { get; }
    internal FieldToken(int field, Type fieldClass);
    private static FieldToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(FieldToken obj);
    public static bool op_Equality(FieldToken a, FieldToken b);
    public static bool op_Inequality(FieldToken a, FieldToken b);
}
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal class System.Reflection.Emit.GenericFieldInfo : object {
    internal RuntimeFieldHandle m_fieldHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericFieldInfo(RuntimeFieldHandle fieldHandle, RuntimeTypeHandle context);
}
internal class System.Reflection.Emit.GenericMethodInfo : object {
    internal RuntimeMethodHandle m_methodHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericMethodInfo(RuntimeMethodHandle methodHandle, RuntimeTypeHandle context);
}
public class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    internal TypeBuilder m_type;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public MethodBase DeclaringMethod { get; }
    internal GenericTypeParameterBuilder(TypeBuilder type);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual bool get_ContainsGenericParameters();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] typeArguments);
    protected virtual bool IsValueTypeImpl();
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetBaseTypeConstraint(Type baseTypeConstraint);
    public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
}
public class System.Reflection.Emit.ILGenerator : object {
    private static int defaultSize;
    private static int DefaultFixupArraySize;
    private static int DefaultLabelArraySize;
    private static int DefaultExceptionArraySize;
    private int m_length;
    private Byte[] m_ILStream;
    private Int32[] m_labelList;
    private int m_labelCount;
    private __FixupData[] m_fixupData;
    private int m_fixupCount;
    private Int32[] m_RelocFixupList;
    private int m_RelocFixupCount;
    private int m_exceptionCount;
    private int m_currExcStackCount;
    private __ExceptionInfo[] m_exceptions;
    private __ExceptionInfo[] m_currExcStack;
    internal ScopeTree m_ScopeTree;
    internal LineNumberInfo m_LineNumberInfo;
    internal MethodInfo m_methodBuilder;
    internal int m_localCount;
    internal SignatureHelper m_localSignature;
    private int m_maxStackSize;
    private int m_maxMidStack;
    private int m_maxMidStackCur;
    internal int CurrExcStackCount { get; }
    internal __ExceptionInfo[] CurrExcStack { get; }
    public int ILOffset { get; }
    internal ILGenerator(MethodInfo methodBuilder);
    internal ILGenerator(MethodInfo methodBuilder, int size);
    internal static T[] EnlargeArray(T[] incoming);
    internal static T[] EnlargeArray(T[] incoming, int requiredSize);
    private static Byte[] EnlargeArray(Byte[] incoming);
    private static Byte[] EnlargeArray(Byte[] incoming, int requiredSize);
    internal int get_CurrExcStackCount();
    internal __ExceptionInfo[] get_CurrExcStack();
    internal virtual void RecordTokenFixup();
    internal void InternalEmit(OpCode opcode);
    internal void UpdateStackSize(OpCode opcode, int stackchange);
    private int GetMethodToken(MethodBase method, Type[] optionalParameterTypes, bool useMethodDef);
    internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    private SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes, int cGenericParameters);
    internal Byte[] BakeByteArray();
    internal __ExceptionInfo[] GetExceptions();
    internal void EnsureCapacity(int size);
    internal void PutInteger4(int value);
    private static int PutInteger4InArray(int value, int startPos, Byte[] array);
    private int GetLabelPos(Label lbl);
    private void AddFixup(Label lbl, int pos, int instSize);
    internal int GetMaxStackSize();
    private static void SortExceptions(__ExceptionInfo[] exceptions);
    internal Int32[] GetTokenFixups();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual Label BeginExceptionBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual Label DefineLabel();
    public virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    private static Type GetConsoleType();
    public virtual void EmitWriteLine(string value);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void UsingNamespace(string usingNamespace);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    public virtual int get_ILOffset();
}
internal class System.Reflection.Emit.InternalAssemblyBuilder : RuntimeAssembly {
    public string Location { get; }
    public string CodeBase { get; }
    public string ImageRuntimeVersion { get; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_CodeBase();
    public virtual Type[] GetExportedTypes();
    public virtual string get_ImageRuntimeVersion();
}
internal class System.Reflection.Emit.InternalModuleBuilder : RuntimeModule {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Reflection.Emit.Label : ValueType {
    internal int m_label;
    internal Label(int label);
    internal int GetLabelValue();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
internal class System.Reflection.Emit.LineNumberInfo : object {
    private int m_DocumentCount;
    private REDocument[] m_Documents;
    private static int InitialSize;
    private int m_iLastFound;
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    private int FindDocument(ISymbolDocumentWriter document);
    private void EnsureCapacity();
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    private int m_localIndex;
    private Type m_localType;
    private MethodInfo m_methodBuilder;
    private bool m_isPinned;
    public bool IsPinned { get; }
    public Type LocalType { get; }
    public int LocalIndex { get; }
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder);
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder, bool isPinned);
    internal int GetLocalIndex();
    internal MethodInfo GetMethodBuilder();
    public virtual bool get_IsPinned();
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public void SetLocalSymInfo(string name);
    public void SetLocalSymInfo(string name, int startOffset, int endOffset);
}
internal class System.Reflection.Emit.LocalSymInfo : object {
    internal String[] m_strName;
    internal Byte[][] m_ubSignature;
    internal Int32[] m_iLocalSlot;
    internal Int32[] m_iStartOffset;
    internal Int32[] m_iEndOffset;
    internal int m_iLocalSymCount;
    internal String[] m_namespace;
    internal int m_iNameSpaceCount;
    internal static int InitialSize;
    private void EnsureCapacityNamespace();
    private void EnsureCapacity();
    internal void AddLocalSymInfo(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespace(string strNamespace);
    internal virtual void EmitLocalSymInfo(ISymbolWriter symWriter);
}
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    internal string m_strName;
    private MethodToken m_tkMethod;
    private ModuleBuilder m_module;
    internal TypeBuilder m_containingType;
    private Int32[] m_mdMethodFixups;
    private Byte[] m_localSignature;
    internal LocalSymInfo m_localSymInfo;
    internal ILGenerator m_ilGenerator;
    private Byte[] m_ubBody;
    private ExceptionHandler[] m_exceptions;
    private static int DefaultMaxStack;
    private int m_maxStack;
    internal bool m_bIsBaked;
    private bool m_bIsGlobalMethod;
    private bool m_fInitLocals;
    private MethodAttributes m_iAttributes;
    private CallingConventions m_callingConvention;
    private MethodImplAttributes m_dwMethodImplFlags;
    private SignatureHelper m_signature;
    internal Type[] m_parameterTypes;
    private ParameterBuilder m_retParam;
    private Type m_returnType;
    private Type[] m_returnTypeRequiredCustomModifiers;
    private Type[] m_returnTypeOptionalCustomModifiers;
    private Type[][] m_parameterTypeRequiredCustomModifiers;
    private Type[][] m_parameterTypeOptionalCustomModifiers;
    private GenericTypeParameterBuilder[] m_inst;
    private bool m_bIsGenMethDef;
    private List`1<SymCustomAttr> m_symCustomAttrs;
    internal bool m_canBeRuntimeImpl;
    internal bool m_isDllImport;
    internal int ExceptionHandlerCount { get; }
    public string Name { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReflectedType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool InitLocals { get; public set; }
    public string Signature { get; }
    internal MethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    private void Init(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    internal void CreateMethodBodyHelper(ILGenerator il);
    internal void ReleaseBakedStructures();
    internal virtual Type[] GetParameterTypes();
    internal static Type GetMethodBaseReturnType(MethodBase method);
    internal Byte[] GetBody();
    internal Int32[] GetTokenFixups();
    internal SignatureHelper GetMethodSignature();
    internal Byte[] GetLocalSignature(Int32& signatureLength);
    internal int GetMaxStack();
    internal ExceptionHandler[] GetExceptionHandlers();
    internal int get_ExceptionHandlerCount();
    internal int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal bool IsTypeCreated();
    internal TypeBuilder GetTypeBuilder();
    internal ModuleBuilder GetModuleBuilder();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_Name();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Type get_ReflectedType();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo[] GetParameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    internal void ThrowIfGeneric();
    public MethodToken GetToken();
    private MethodToken GetTokenNoLock();
    public void SetParameters(Type[] parameterTypes);
    public void SetReturnType(Type returnType);
    public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    private void ThrowIfShouldNotHaveBody();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public Module GetModule();
    public string get_Signature();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private bool IsKnownCA(ConstructorInfo con);
    private void ParseCA(ConstructorInfo con, Byte[] blob);
}
internal class System.Reflection.Emit.MethodBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    private Type[] m_inst;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodBuilderInstantiation(MethodInfo method, Type[] inst);
    internal static MethodInfo MakeGenericMethod(MethodInfo method, Type[] inst);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] arguments);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
internal class System.Reflection.Emit.MethodOnTypeBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    private TypeBuilderInstantiation m_type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodOnTypeBuilderInstantiation(MethodInfo method, TypeBuilderInstantiation type);
    internal static MethodInfo GetMethod(MethodInfo method, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArgs);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
public class System.Reflection.Emit.MethodToken : ValueType {
    public static MethodToken Empty;
    internal int m_method;
    public int Token { get; }
    internal MethodToken(int str);
    private static MethodToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(MethodToken obj);
    public static bool op_Equality(MethodToken a, MethodToken b);
    public static bool op_Inequality(MethodToken a, MethodToken b);
}
public class System.Reflection.Emit.ModuleBuilder : Module {
    private Dictionary`2<string, Type> m_TypeBuilderDict;
    private ISymbolWriter m_iSymWriter;
    internal ModuleBuilderData m_moduleData;
    internal InternalModuleBuilder m_internalModuleBuilder;
    private AssemblyBuilder m_assemblyBuilder;
    internal AssemblyBuilder ContainingAssemblyBuilder { get; }
    internal object SyncRoot { get; }
    internal InternalModuleBuilder InternalModule { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    internal ModuleBuilder(AssemblyBuilder assemblyBuilder, InternalModuleBuilder internalModuleBuilder);
    internal static IntPtr nCreateISymWriterForDynamicModule(Module module, string filename);
    internal static string UnmangleTypeName(string typeName);
    internal AssemblyBuilder get_ContainingAssemblyBuilder();
    internal void AddType(string name, Type type);
    internal void CheckTypeNameConflict(string strTypeName, Type enclosingType);
    private Type GetType(string strFormat, Type baseType);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetTypeRef(RuntimeModule module, string strFullName, RuntimeModule refedModule, string strRefedModuleFileName, int tkResolution);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMemberRef(RuntimeModule module, RuntimeModule refedModule, int tr, int defToken);
    private int GetMemberRef(Module refedModule, int tr, int defToken);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMemberRefFromSignature(RuntimeModule module, int tr, string methodName, Byte[] signature, int length);
    private int GetMemberRefFromSignature(int tr, string methodName, Byte[] signature, int length);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMemberRefOfMethodInfo(RuntimeModule module, int tr, IRuntimeMethodInfo method);
    private int GetMemberRefOfMethodInfo(int tr, RuntimeMethodInfo method);
    private int GetMemberRefOfMethodInfo(int tr, RuntimeConstructorInfo method);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetMemberRefOfFieldInfo(RuntimeModule module, int tkType, RuntimeTypeHandle declaringType, int tkField);
    private int GetMemberRefOfFieldInfo(int tkType, RuntimeTypeHandle declaringType, RuntimeFieldInfo runtimeField);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetTokenFromTypeSpec(RuntimeModule pModule, Byte[] signature, int length);
    private int GetTokenFromTypeSpec(Byte[] signature, int length);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetArrayMethodToken(RuntimeModule module, int tkTypeSpec, string methodName, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetStringConstant(RuntimeModule module, string str, int length);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void SetFieldRVAContent(RuntimeModule module, int fdToken, Byte[] data, int length);
    internal virtual Type FindTypeBuilderWithName(string strTypeName, bool ignoreCase);
    private int GetTypeRefNested(Type type, Module refedModule, string strRefedModuleFileName);
    internal MethodToken InternalGetConstructorToken(ConstructorInfo con, bool usingRef);
    internal void Init(string strModuleName, string strFileName, int tkFile);
    internal void SetSymWriter(ISymbolWriter writer);
    internal object get_SyncRoot();
    internal InternalModuleBuilder get_InternalModule();
    protected virtual ModuleHandle GetModuleHandleImpl();
    internal RuntimeModule GetNativeHandle();
    private static RuntimeModule GetRuntimeModuleFromModule(Module m);
    private int GetMemberRefToken(MethodBase method, IEnumerable`1<Type> optionalParameterTypes);
    internal SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, IEnumerable`1<Type> optionalParameterTypes, int cGenericParameters);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetTypes();
    internal Type[] GetTypesNoLock();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    private Type GetTypeNoLock(string className, bool throwOnError, bool ignoreCase);
    public virtual string get_FullyQualifiedName();
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    private TypeBuilder DefineTypeNoLock(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    private TypeBuilder DefineTypeNoLock(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    private EnumBuilder DefineEnumNoLock(string name, TypeAttributes visibility, Type underlyingType);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    private MethodBuilder DefineGlobalMethodNoLock(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public void CreateGlobalFunctions();
    private void CreateGlobalFunctionsNoLock();
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    private FieldBuilder DefineInitializedDataNoLock(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineUninitializedDataNoLock(string name, int size, FieldAttributes attributes);
    internal TypeToken GetTypeTokenInternal(Type type);
    private TypeToken GetTypeTokenInternal(Type type, bool getGenericDefinition);
    public TypeToken GetTypeToken(Type type);
    private TypeToken GetTypeTokenWorkerNoLock(Type type, bool getGenericDefinition);
    public TypeToken GetTypeToken(string name);
    public MethodToken GetMethodToken(MethodInfo method);
    internal MethodToken GetMethodTokenInternal(MethodInfo method);
    private MethodToken GetMethodTokenNoLock(MethodInfo method, bool getGenericTypeDefinition);
    internal int GetMethodTokenInternal(MethodBase method, IEnumerable`1<Type> optionalParameterTypes, bool useMethodDef);
    public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    private MethodToken GetArrayMethodTokenNoLock(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodToken GetConstructorToken(ConstructorInfo con);
    public FieldToken GetFieldToken(FieldInfo field);
    private FieldToken GetFieldTokenNoLock(FieldInfo field);
    public StringToken GetStringConstant(string str);
    public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
    public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    internal ISymbolWriter GetSymWriter();
    public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    private ISymbolDocumentWriter DefineDocumentNoLock(string url, Guid language, Guid languageVendor, Guid documentType);
    public bool IsTransient();
}
internal class System.Reflection.Emit.ModuleBuilderData : object {
    internal string m_strModuleName;
    internal string m_strFileName;
    internal bool m_fGlobalBeenCreated;
    internal bool m_fHasGlobal;
    internal TypeBuilder m_globalTypeBuilder;
    internal ModuleBuilder m_module;
    private int m_tkFile;
    internal bool m_isSaved;
    internal static string MULTI_BYTE_VALUE_CLASS;
    internal string m_strResourceFileName;
    internal Byte[] m_resourceBytes;
    internal ModuleBuilderData(ModuleBuilder module, string strModuleName, string strFileName, int tkFile);
    private void InitNames(string strModuleName, string strFileName);
}
internal class System.Reflection.Emit.NativeVersionInfo : object {
    internal string m_strDescription;
    internal string m_strCompany;
    internal string m_strTitle;
    internal string m_strCopyright;
    internal string m_strTrademark;
    internal string m_strProduct;
    internal string m_strProductVersion;
    internal string m_strFileVersion;
    internal int m_lcid;
}
public class System.Reflection.Emit.OpCode : ValueType {
    internal static int OperandTypeMask;
    internal static int FlowControlShift;
    internal static int FlowControlMask;
    internal static int OpCodeTypeShift;
    internal static int OpCodeTypeMask;
    internal static int StackBehaviourPopShift;
    internal static int StackBehaviourPushShift;
    internal static int StackBehaviourMask;
    internal static int SizeShift;
    internal static int SizeMask;
    internal static int EndsUncondJmpBlkFlag;
    internal static int StackChangeShift;
    private OpCodeValues m_value;
    private int m_flags;
    private static String[] modreq(System.Runtime.CompilerServices.IsVolatile) g_nameCache;
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public int Size { get; }
    public short Value { get; }
    public string Name { get; }
    internal OpCode(OpCodeValues value, int flags);
    internal bool EndsUncondJmpBlk();
    internal int StackChange();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public int get_Size();
    public short get_Value();
    public string get_Name();
    public virtual bool Equals(object obj);
    public bool Equals(OpCode obj);
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum System.Reflection.Emit.OpCodeValues : Enum {
    public int value__;
    public static OpCodeValues Nop;
    public static OpCodeValues Break;
    public static OpCodeValues Ldarg_0;
    public static OpCodeValues Ldarg_1;
    public static OpCodeValues Ldarg_2;
    public static OpCodeValues Ldarg_3;
    public static OpCodeValues Ldloc_0;
    public static OpCodeValues Ldloc_1;
    public static OpCodeValues Ldloc_2;
    public static OpCodeValues Ldloc_3;
    public static OpCodeValues Stloc_0;
    public static OpCodeValues Stloc_1;
    public static OpCodeValues Stloc_2;
    public static OpCodeValues Stloc_3;
    public static OpCodeValues Ldarg_S;
    public static OpCodeValues Ldarga_S;
    public static OpCodeValues Starg_S;
    public static OpCodeValues Ldloc_S;
    public static OpCodeValues Ldloca_S;
    public static OpCodeValues Stloc_S;
    public static OpCodeValues Ldnull;
    public static OpCodeValues Ldc_I4_M1;
    public static OpCodeValues Ldc_I4_0;
    public static OpCodeValues Ldc_I4_1;
    public static OpCodeValues Ldc_I4_2;
    public static OpCodeValues Ldc_I4_3;
    public static OpCodeValues Ldc_I4_4;
    public static OpCodeValues Ldc_I4_5;
    public static OpCodeValues Ldc_I4_6;
    public static OpCodeValues Ldc_I4_7;
    public static OpCodeValues Ldc_I4_8;
    public static OpCodeValues Ldc_I4_S;
    public static OpCodeValues Ldc_I4;
    public static OpCodeValues Ldc_I8;
    public static OpCodeValues Ldc_R4;
    public static OpCodeValues Ldc_R8;
    public static OpCodeValues Dup;
    public static OpCodeValues Pop;
    public static OpCodeValues Jmp;
    public static OpCodeValues Call;
    public static OpCodeValues Calli;
    public static OpCodeValues Ret;
    public static OpCodeValues Br_S;
    public static OpCodeValues Brfalse_S;
    public static OpCodeValues Brtrue_S;
    public static OpCodeValues Beq_S;
    public static OpCodeValues Bge_S;
    public static OpCodeValues Bgt_S;
    public static OpCodeValues Ble_S;
    public static OpCodeValues Blt_S;
    public static OpCodeValues Bne_Un_S;
    public static OpCodeValues Bge_Un_S;
    public static OpCodeValues Bgt_Un_S;
    public static OpCodeValues Ble_Un_S;
    public static OpCodeValues Blt_Un_S;
    public static OpCodeValues Br;
    public static OpCodeValues Brfalse;
    public static OpCodeValues Brtrue;
    public static OpCodeValues Beq;
    public static OpCodeValues Bge;
    public static OpCodeValues Bgt;
    public static OpCodeValues Ble;
    public static OpCodeValues Blt;
    public static OpCodeValues Bne_Un;
    public static OpCodeValues Bge_Un;
    public static OpCodeValues Bgt_Un;
    public static OpCodeValues Ble_Un;
    public static OpCodeValues Blt_Un;
    public static OpCodeValues Switch;
    public static OpCodeValues Ldind_I1;
    public static OpCodeValues Ldind_U1;
    public static OpCodeValues Ldind_I2;
    public static OpCodeValues Ldind_U2;
    public static OpCodeValues Ldind_I4;
    public static OpCodeValues Ldind_U4;
    public static OpCodeValues Ldind_I8;
    public static OpCodeValues Ldind_I;
    public static OpCodeValues Ldind_R4;
    public static OpCodeValues Ldind_R8;
    public static OpCodeValues Ldind_Ref;
    public static OpCodeValues Stind_Ref;
    public static OpCodeValues Stind_I1;
    public static OpCodeValues Stind_I2;
    public static OpCodeValues Stind_I4;
    public static OpCodeValues Stind_I8;
    public static OpCodeValues Stind_R4;
    public static OpCodeValues Stind_R8;
    public static OpCodeValues Add;
    public static OpCodeValues Sub;
    public static OpCodeValues Mul;
    public static OpCodeValues Div;
    public static OpCodeValues Div_Un;
    public static OpCodeValues Rem;
    public static OpCodeValues Rem_Un;
    public static OpCodeValues And;
    public static OpCodeValues Or;
    public static OpCodeValues Xor;
    public static OpCodeValues Shl;
    public static OpCodeValues Shr;
    public static OpCodeValues Shr_Un;
    public static OpCodeValues Neg;
    public static OpCodeValues Not;
    public static OpCodeValues Conv_I1;
    public static OpCodeValues Conv_I2;
    public static OpCodeValues Conv_I4;
    public static OpCodeValues Conv_I8;
    public static OpCodeValues Conv_R4;
    public static OpCodeValues Conv_R8;
    public static OpCodeValues Conv_U4;
    public static OpCodeValues Conv_U8;
    public static OpCodeValues Callvirt;
    public static OpCodeValues Cpobj;
    public static OpCodeValues Ldobj;
    public static OpCodeValues Ldstr;
    public static OpCodeValues Newobj;
    public static OpCodeValues Castclass;
    public static OpCodeValues Isinst;
    public static OpCodeValues Conv_R_Un;
    public static OpCodeValues Unbox;
    public static OpCodeValues Throw;
    public static OpCodeValues Ldfld;
    public static OpCodeValues Ldflda;
    public static OpCodeValues Stfld;
    public static OpCodeValues Ldsfld;
    public static OpCodeValues Ldsflda;
    public static OpCodeValues Stsfld;
    public static OpCodeValues Stobj;
    public static OpCodeValues Conv_Ovf_I1_Un;
    public static OpCodeValues Conv_Ovf_I2_Un;
    public static OpCodeValues Conv_Ovf_I4_Un;
    public static OpCodeValues Conv_Ovf_I8_Un;
    public static OpCodeValues Conv_Ovf_U1_Un;
    public static OpCodeValues Conv_Ovf_U2_Un;
    public static OpCodeValues Conv_Ovf_U4_Un;
    public static OpCodeValues Conv_Ovf_U8_Un;
    public static OpCodeValues Conv_Ovf_I_Un;
    public static OpCodeValues Conv_Ovf_U_Un;
    public static OpCodeValues Box;
    public static OpCodeValues Newarr;
    public static OpCodeValues Ldlen;
    public static OpCodeValues Ldelema;
    public static OpCodeValues Ldelem_I1;
    public static OpCodeValues Ldelem_U1;
    public static OpCodeValues Ldelem_I2;
    public static OpCodeValues Ldelem_U2;
    public static OpCodeValues Ldelem_I4;
    public static OpCodeValues Ldelem_U4;
    public static OpCodeValues Ldelem_I8;
    public static OpCodeValues Ldelem_I;
    public static OpCodeValues Ldelem_R4;
    public static OpCodeValues Ldelem_R8;
    public static OpCodeValues Ldelem_Ref;
    public static OpCodeValues Stelem_I;
    public static OpCodeValues Stelem_I1;
    public static OpCodeValues Stelem_I2;
    public static OpCodeValues Stelem_I4;
    public static OpCodeValues Stelem_I8;
    public static OpCodeValues Stelem_R4;
    public static OpCodeValues Stelem_R8;
    public static OpCodeValues Stelem_Ref;
    public static OpCodeValues Ldelem;
    public static OpCodeValues Stelem;
    public static OpCodeValues Unbox_Any;
    public static OpCodeValues Conv_Ovf_I1;
    public static OpCodeValues Conv_Ovf_U1;
    public static OpCodeValues Conv_Ovf_I2;
    public static OpCodeValues Conv_Ovf_U2;
    public static OpCodeValues Conv_Ovf_I4;
    public static OpCodeValues Conv_Ovf_U4;
    public static OpCodeValues Conv_Ovf_I8;
    public static OpCodeValues Conv_Ovf_U8;
    public static OpCodeValues Refanyval;
    public static OpCodeValues Ckfinite;
    public static OpCodeValues Mkrefany;
    public static OpCodeValues Ldtoken;
    public static OpCodeValues Conv_U2;
    public static OpCodeValues Conv_U1;
    public static OpCodeValues Conv_I;
    public static OpCodeValues Conv_Ovf_I;
    public static OpCodeValues Conv_Ovf_U;
    public static OpCodeValues Add_Ovf;
    public static OpCodeValues Add_Ovf_Un;
    public static OpCodeValues Mul_Ovf;
    public static OpCodeValues Mul_Ovf_Un;
    public static OpCodeValues Sub_Ovf;
    public static OpCodeValues Sub_Ovf_Un;
    public static OpCodeValues Endfinally;
    public static OpCodeValues Leave;
    public static OpCodeValues Leave_S;
    public static OpCodeValues Stind_I;
    public static OpCodeValues Conv_U;
    public static OpCodeValues Prefix7;
    public static OpCodeValues Prefix6;
    public static OpCodeValues Prefix5;
    public static OpCodeValues Prefix4;
    public static OpCodeValues Prefix3;
    public static OpCodeValues Prefix2;
    public static OpCodeValues Prefix1;
    public static OpCodeValues Prefixref;
    public static OpCodeValues Arglist;
    public static OpCodeValues Ceq;
    public static OpCodeValues Cgt;
    public static OpCodeValues Cgt_Un;
    public static OpCodeValues Clt;
    public static OpCodeValues Clt_Un;
    public static OpCodeValues Ldftn;
    public static OpCodeValues Ldvirtftn;
    public static OpCodeValues Ldarg;
    public static OpCodeValues Ldarga;
    public static OpCodeValues Starg;
    public static OpCodeValues Ldloc;
    public static OpCodeValues Ldloca;
    public static OpCodeValues Stloc;
    public static OpCodeValues Localloc;
    public static OpCodeValues Endfilter;
    public static OpCodeValues Unaligned_;
    public static OpCodeValues Volatile_;
    public static OpCodeValues Tail_;
    public static OpCodeValues Initobj;
    public static OpCodeValues Constrained_;
    public static OpCodeValues Cpblk;
    public static OpCodeValues Initblk;
    public static OpCodeValues Rethrow;
    public static OpCodeValues Sizeof;
    public static OpCodeValues Refanytype;
    public static OpCodeValues Readonly_;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. http://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
public class System.Reflection.Emit.ParameterBuilder : object {
    private string m_strParamName;
    private int m_iPosition;
    private ParameterAttributes m_attributes;
    private MethodBuilder m_methodBuilder;
    private ParameterToken m_pdToken;
    public string Name { get; }
    public int Position { get; }
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsOptional { get; }
    internal ParameterBuilder(MethodBuilder methodBuilder, int sequence, ParameterAttributes attributes, string strParamName);
    public virtual void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual ParameterToken GetToken();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOut();
    public bool get_IsOptional();
}
public class System.Reflection.Emit.ParameterToken : ValueType {
    public static ParameterToken Empty;
    internal int m_tkParameter;
    public int Token { get; }
    internal ParameterToken(int tkParam);
    private static ParameterToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ParameterToken obj);
    public static bool op_Equality(ParameterToken a, ParameterToken b);
    public static bool op_Inequality(ParameterToken a, ParameterToken b);
}
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    private string m_name;
    private PropertyToken m_prToken;
    private int m_tkProperty;
    private ModuleBuilder m_moduleBuilder;
    private SignatureHelper m_signature;
    private PropertyAttributes m_attributes;
    private Type m_returnType;
    private MethodInfo m_getMethod;
    private MethodInfo m_setMethod;
    private TypeBuilder m_containingType;
    public PropertyToken PropertyToken { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal PropertyBuilder(ModuleBuilder mod, string name, SignatureHelper sig, PropertyAttributes attr, Type returnType, PropertyToken prToken, TypeBuilder containingType);
    public void SetConstant(object defaultValue);
    public PropertyToken get_PropertyToken();
    public virtual Module get_Module();
    private void SetMethodSemantics(MethodBuilder mdBuilder, MethodSemanticsAttributes semantics);
    public void SetGetMethod(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual Type get_PropertyType();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
}
public class System.Reflection.Emit.PropertyToken : ValueType {
    public static PropertyToken Empty;
    internal int m_property;
    public int Token { get; }
    internal PropertyToken(int str);
    private static PropertyToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PropertyToken obj);
    public static bool op_Equality(PropertyToken a, PropertyToken b);
    public static bool op_Inequality(PropertyToken a, PropertyToken b);
}
internal class System.Reflection.Emit.PunkSafeHandle : SafeHandle {
    private static DRelease m_Release;
    public bool IsInvalid { get; }
    private static PunkSafeHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    private static IntPtr nGetDReleaseTarget();
}
internal class System.Reflection.Emit.REDocument : object {
    private Int32[] m_iOffsets;
    private Int32[] m_iLines;
    private Int32[] m_iColumns;
    private Int32[] m_iEndLines;
    private Int32[] m_iEndColumns;
    internal ISymbolDocumentWriter m_document;
    private int m_iLineNumberCount;
    private static int InitialSize;
    internal REDocument(ISymbolDocumentWriter document);
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    private void EnsureCapacity();
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
internal class System.Reflection.Emit.ResWriterData : object {
    internal string m_strName;
    internal string m_strFileName;
    internal string m_strFullFileName;
    internal Stream m_memoryStream;
    internal ResWriterData m_nextResWriter;
    internal ResourceAttributes m_attribute;
}
internal enum System.Reflection.Emit.ScopeAction : Enum {
    public int value__;
    public static ScopeAction Open;
    public static ScopeAction Close;
}
internal class System.Reflection.Emit.ScopeTree : object {
    internal Int32[] m_iOffsets;
    internal ScopeAction[] m_ScopeActions;
    internal int m_iCount;
    internal int m_iOpenScopeCount;
    internal static int InitialSize;
    internal LocalSymInfo[] m_localSymInfos;
    internal int GetCurrentActiveScopeIndex();
    internal void AddLocalSymInfoToCurrentScope(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespaceToCurrentScope(string strNamespace);
    internal void AddScopeInfo(ScopeAction sa, int iOffset);
    internal void EnsureCapacity();
    internal void EmitScopeTree(ISymbolWriter symWriter);
}
public class System.Reflection.Emit.SignatureHelper : object {
    private static int NO_SIZE_IN_SIG;
    private Byte[] m_signature;
    private int m_currSig;
    private int m_sizeLoc;
    private ModuleBuilder m_module;
    private bool m_sigDone;
    private int m_argCount;
    internal int ArgumentCount { get; }
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention);
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention, int cGenericParameters, Type returnType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention, Type returnType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private SignatureHelper(Module mod, Type type);
    public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    internal static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType, int cGenericParam);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    internal static SignatureHelper GetMethodSpecSigHelper(Module scope, Type[] inst);
    internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, int cGenericParam, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    internal static SignatureHelper GetTypeSigToken(Module module, Type type);
    private void Init(Module mod);
    private void Init(Module mod, MdSigCallingConvention callingConvention);
    private void Init(Module mod, MdSigCallingConvention callingConvention, int cGenericParam);
    private void AddOneArgTypeHelper(Type argument, bool pinned);
    private void AddOneArgTypeHelper(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private void AddOneArgTypeHelper(Type clsArgument);
    private void AddOneArgTypeHelperWorker(Type clsArgument, bool lastWasGenericInst);
    private void AddData(int data);
    private void AddElementType(CorElementType cvt);
    private void AddToken(int token);
    private void InternalAddTypeToken(TypeToken clsToken, CorElementType CorType);
    private void InternalAddRuntimeType(Type type);
    private Byte[] ExpandArray(Byte[] inArray);
    private Byte[] ExpandArray(Byte[] inArray, int requiredLength);
    private void IncrementArgCounts();
    private void SetNumberOfSignatureElements(bool forceCopy);
    internal int get_ArgumentCount();
    internal static bool IsSimpleType(CorElementType type);
    internal Byte[] InternalGetSignature(Int32& length);
    internal Byte[] InternalGetSignatureArray();
    public void AddArgument(Type clsArgument);
    public void AddArgument(Type argument, bool pinned);
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddSentinel();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetSignature();
    internal Byte[] GetSignature(bool appendEndOfSig);
    public virtual string ToString();
}
public class System.Reflection.Emit.SignatureToken : ValueType {
    public static SignatureToken Empty;
    internal int m_signature;
    internal ModuleBuilder m_moduleBuilder;
    public int Token { get; }
    internal SignatureToken(int str, ModuleBuilder mod);
    private static SignatureToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SignatureToken obj);
    public static bool op_Equality(SignatureToken a, SignatureToken b);
    public static bool op_Inequality(SignatureToken a, SignatureToken b);
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
public class System.Reflection.Emit.StringToken : ValueType {
    internal int m_string;
    public int Token { get; }
    internal StringToken(int str);
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(StringToken obj);
    public static bool op_Equality(StringToken a, StringToken b);
    public static bool op_Inequality(StringToken a, StringToken b);
}
internal class System.Reflection.Emit.SymbolMethod : MethodInfo {
    private ModuleBuilder m_module;
    private Type m_containingType;
    private string m_name;
    private CallingConventions m_callingConvention;
    private Type m_returnType;
    private MethodToken m_mdMethod;
    private Type[] m_parameterTypes;
    private SignatureHelper m_signature;
    public Module Module { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal SymbolMethod(ModuleBuilder mod, MethodToken token, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    internal virtual Type[] GetParameterTypes();
    internal MethodToken GetToken(ModuleBuilder mod);
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public Module GetModule();
    public MethodToken GetToken();
}
internal class System.Reflection.Emit.SymbolType : TypeInfo {
    internal TypeKind m_typeKind;
    internal Type m_baseType;
    internal int m_cRank;
    internal Int32[] m_iaLowerBound;
    internal Int32[] m_iaUpperBound;
    private string m_format;
    private bool m_isSzArray;
    public bool IsSZArray { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    internal SymbolType(TypeKind typeKind);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type FormCompoundType(string format, Type baseType, int curIndex);
    internal void SetElementType(Type baseType);
    private void SetBounds(int lower, int upper);
    internal void SetFormat(string format, int curIndex, int length);
    public virtual bool get_IsSZArray();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual int GetArrayRank();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Emit.SymWrapperCore : object {
}
public class System.Reflection.Emit.TypeBuilder : TypeInfo {
    public static int UnspecifiedTypeSize;
    private List`1<CustAttr> m_ca;
    private TypeToken m_tdType;
    private ModuleBuilder m_module;
    private string m_strName;
    private string m_strNameSpace;
    private string m_strFullQualName;
    private Type m_typeParent;
    private List`1<Type> m_typeInterfaces;
    private TypeAttributes m_iAttr;
    private GenericParameterAttributes m_genParamAttributes;
    internal List`1<MethodBuilder> m_listMethods;
    internal int m_lastTokenizedMethod;
    private int m_constructorCount;
    private int m_iTypeSize;
    private PackingSize m_iPackingSize;
    private TypeBuilder m_DeclaringType;
    private Type m_enumUnderlyingType;
    internal bool m_isHiddenGlobalType;
    private bool m_hasBeenCreated;
    private RuntimeType m_bakedRuntimeType;
    private int m_genParamPos;
    private GenericTypeParameterBuilder[] m_inst;
    private bool m_bIsGenParam;
    private MethodBuilder m_declMeth;
    private TypeBuilder m_genTypeDef;
    internal object SyncRoot { get; }
    internal RuntimeType BakedRuntimeType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsSZArray { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type UnderlyingSystemType { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    public int Size { get; }
    public PackingSize PackingSize { get; }
    public TypeToken TypeToken { get; }
    internal TypeBuilder(ModuleBuilder module);
    internal TypeBuilder(string szName, int genParamPos, MethodBuilder declMeth);
    private TypeBuilder(string szName, int genParamPos, TypeBuilder declType);
    internal TypeBuilder(string name, TypeAttributes attr, Type parent, Type[] interfaces, ModuleBuilder module, PackingSize iPackingSize, int iTypeSize, TypeBuilder enclosingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    public static FieldInfo GetField(Type type, FieldInfo field);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void SetParentType(RuntimeModule module, int tdTypeDef, int tkParent);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddInterfaceImpl(RuntimeModule module, int tdTypeDef, int tkInterface);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineMethod(RuntimeModule module, int tkParent, string name, Byte[] signature, int sigLength, MethodAttributes attributes);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineMethodSpec(RuntimeModule module, int tkParent, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineField(RuntimeModule module, int tkParent, string name, Byte[] signature, int sigLength, FieldAttributes attributes);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void SetMethodIL(RuntimeModule module, int tk, bool isInitLocals, Byte[] body, int bodyLength, Byte[] LocalSig, int sigLength, int maxStackSize, ExceptionHandler[] exceptions, int numExceptions, Int32[] tokenFixups, int numTokenFixups);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void DefineCustomAttribute(RuntimeModule module, int tkAssociate, int tkConstructor, Byte[] attr, int attrLength, bool toDisk, bool updateCompilerFlags);
    internal static void DefineCustomAttribute(ModuleBuilder module, int tkAssociate, int tkConstructor, Byte[] attr, bool toDisk, bool updateCompilerFlags);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineProperty(RuntimeModule module, int tkParent, string name, PropertyAttributes attributes, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int DefineEvent(RuntimeModule module, int tkParent, string name, EventAttributes attributes, int tkEventType);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void DefineMethodSemantics(RuntimeModule module, int tkAssociation, MethodSemanticsAttributes semantics, int tkMethod);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void DefineMethodImpl(RuntimeModule module, int tkType, int tkBody, int tkDecl);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void SetMethodImpl(RuntimeModule module, int tkMethod, MethodImplAttributes MethodImplAttributes);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int SetParamInfo(RuntimeModule module, int tkMethod, int iSequence, ParameterAttributes iParamAttributes, string strParamName);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int GetTokenFromSig(RuntimeModule module, Byte[] signature, int sigLength);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void SetFieldLayoutOffset(RuntimeModule module, int fdToken, int iOffset);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void SetClassLayout(RuntimeModule module, int tk, PackingSize iPackingSize, int iTypeSize);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void SetConstantValue(RuntimeModule module, int tk, int corType, Void* pValue);
    internal static bool IsTypeEqual(Type t1, Type t2);
    internal static void SetConstantValue(ModuleBuilder module, int tk, Type destType, object value);
    private void InitAsGenericParam(string szName, int genParamPos);
    private void Init(string fullname, TypeAttributes attr, Type parent, Type[] interfaces, ModuleBuilder module, PackingSize iPackingSize, int iTypeSize, TypeBuilder enclosingType);
    private FieldBuilder DefineDataHelper(string name, Byte[] data, int size, FieldAttributes attributes);
    private void VerifyTypeAttributes(TypeAttributes attr);
    public bool IsCreated();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int DefineType(RuntimeModule module, string fullname, int tkParent, TypeAttributes attributes, int tkEnclosingType, Int32[] interfaceTokens);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int DefineGenericParam(RuntimeModule module, string name, int tkParent, GenericParameterAttributes attributes, int position, Int32[] constraints);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void TermCreateClass(RuntimeModule module, int tk, ObjectHandleOnStack type);
    internal void ThrowIfCreated();
    internal object get_SyncRoot();
    internal ModuleBuilder GetModuleBuilder();
    internal RuntimeType get_BakedRuntimeType();
    internal void SetGenParamAttributes(GenericParameterAttributes genericParameterAttributes);
    internal void SetGenParamCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    internal void SetGenParamCustomAttribute(CustomAttributeBuilder customBuilder);
    private void SetGenParamCustomAttributeNoLock(CustAttr ca);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual bool IsAssignableFrom(Type c);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    internal void SetInterfaces(Type[] interfaces);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    private void DefineMethodOverrideNoLock(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    private MethodBuilder DefineMethodNoLock(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ConstructorBuilder DefineTypeInitializer();
    private ConstructorBuilder DefineTypeInitializerNoLock();
    public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    private ConstructorBuilder DefineDefaultConstructorNoLock(MethodAttributes attributes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    private ConstructorBuilder DefineConstructorNoLock(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    private TypeBuilder DefineNestedTypeNoLock(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    private FieldBuilder DefineFieldNoLock(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    private FieldBuilder DefineInitializedDataNoLock(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineUninitializedDataNoLock(string name, int size, FieldAttributes attributes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    private PropertyBuilder DefinePropertyNoLock(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    private EventBuilder DefineEventNoLock(string name, EventAttributes attributes, Type eventtype);
    public TypeInfo CreateTypeInfo();
    public Type CreateType();
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    private TypeInfo CreateTypeNoLock();
    public int get_Size();
    public PackingSize get_PackingSize();
    public void SetParent(Type parent);
    public void AddInterfaceImplementation(Type interfaceType);
    public TypeToken get_TypeToken();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
internal class System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
    private Type m_type;
    private Type[] m_inst;
    private string m_strFullQualName;
    internal Hashtable m_hashtable;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    private TypeBuilderInstantiation(Type type, Type[] inst);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type MakeGenericType(Type type, Type[] typeArguments);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    private Type Substitute(Type[] substitutes);
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] inst);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal enum System.Reflection.Emit.TypeKind : Enum {
    public int value__;
    public static TypeKind IsArray;
    public static TypeKind IsPointer;
    public static TypeKind IsByRef;
}
internal class System.Reflection.Emit.TypeNameBuilder : object {
    private IntPtr m_typeNameBuilder;
    private TypeNameBuilder(IntPtr typeNameBuilder);
    [SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr CreateTypeNameBuilder();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void ReleaseTypeNameBuilder(IntPtr pAQN);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void OpenGenericArguments(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void CloseGenericArguments(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void OpenGenericArgument(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void CloseGenericArgument(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddName(IntPtr tnb, string name);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddPointer(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddByRef(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddSzArray(IntPtr tnb);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddArray(IntPtr tnb, int rank);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void AddAssemblySpec(IntPtr tnb, string assemblySpec);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void ToString(IntPtr tnb, StringHandleOnStack retString);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void Clear(IntPtr tnb);
    internal static string ToString(Type type, Format format);
    internal void Dispose();
    private void AddElementType(Type elementType);
    private void ConstructAssemblyQualifiedNameWorker(Type type, Format format);
    private void OpenGenericArguments();
    private void CloseGenericArguments();
    private void OpenGenericArgument();
    private void CloseGenericArgument();
    private void AddName(string name);
    private void AddPointer();
    private void AddByRef();
    private void AddSzArray();
    private void AddArray(int rank);
    private void AddAssemblySpec(string assemblySpec);
    public virtual string ToString();
    private void Clear();
}
public class System.Reflection.Emit.TypeToken : ValueType {
    public static TypeToken Empty;
    internal int m_class;
    public int Token { get; }
    internal TypeToken(int str);
    private static TypeToken();
    public int get_Token();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(TypeToken obj);
    public static bool op_Equality(TypeToken a, TypeToken b);
    public static bool op_Inequality(TypeToken a, TypeToken b);
}
internal class System.Reflection.Emit.VarArgMethod : object {
    internal RuntimeMethodInfo m_method;
    internal DynamicMethod m_dynamicMethod;
    internal SignatureHelper m_signature;
    internal VarArgMethod(DynamicMethod dm, SignatureHelper signature);
    internal VarArgMethod(RuntimeMethodInfo method, SignatureHelper signature);
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
    public static EventAttributes ReservedMask;
}
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public bool IsMulticast { get; }
    public Type EventHandlerType { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual EventAttributes get_Attributes();
    public bool get_IsSpecialName();
    public MethodInfo[] GetOtherMethods();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public MethodInfo GetAddMethod();
    public MethodInfo GetRemoveMethod();
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual bool get_IsMulticast();
    public virtual Type get_EventHandlerType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
}
public class System.Reflection.ExceptionHandlingClause : object {
    private MethodBody m_methodBody;
    private ExceptionHandlingClauseOptions m_flags;
    private int m_tryOffset;
    private int m_tryLength;
    private int m_handlerOffset;
    private int m_handlerLength;
    private int m_catchMetadataToken;
    private int m_filterOffset;
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes ReservedMask;
}
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public virtual MemberTypes get_MemberType();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual Type get_FieldType();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public abstract virtual object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public virtual object GetRawConstantValue();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
public class System.Reflection.InterfaceMapping : ValueType {
    public Type TargetType;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum System.Reflection.INVOCATION_FLAGS : Enum {
    public UInt32 value__;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_UNKNOWN;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_INITIALIZED;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NEED_SECURITY;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_CTOR_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_RISKY_METHOD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_DELEGATE_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONTAINS_STACK_POINTERS;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_SPECIAL_FIELD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_FIELD_SPECIAL_CAST;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONSTRUCTOR_INVOKE;
}
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
internal class System.Reflection.LoaderAllocator : object {
    private LoaderAllocatorScout m_scout;
    private Object[] m_slots;
    internal CerHashtable`2<RuntimeMethodInfo, RuntimeMethodInfo> m_methodInstantiations;
    private int m_slotsUsed;
}
internal class System.Reflection.LoaderAllocatorScout : object {
    internal IntPtr m_nativeLoaderAllocator;
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool Destroy(IntPtr nativeLoaderAllocator);
    protected virtual override void Finalize();
}
public class System.Reflection.LocalVariableInfo : object {
    private RuntimeType m_type;
    private int m_isPinned;
    private int m_localIndex;
    public Type LocalType { get; }
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public virtual string ToString();
    public virtual Type get_LocalType();
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
}
public class System.Reflection.ManifestResourceInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <ReferencedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceLocation <ResourceLocation>k__BackingField;
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    [CompilerGeneratedAttribute]
public virtual Assembly get_ReferencedAssembly();
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
public virtual ResourceLocation get_ResourceLocation();
}
internal static class System.Reflection.MdConstant : object {
    public static object GetValue(MetadataImport scope, int token, RuntimeTypeHandle fieldTypeHandle, bool raw);
}
internal class System.Reflection.MdFieldInfo : RuntimeFieldInfo {
    private int m_tkField;
    private string m_name;
    private RuntimeType m_fieldType;
    private FieldAttributes m_fieldAttributes;
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type FieldType { get; }
    internal MdFieldInfo(int tkField, FieldAttributes fieldAttributes, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    internal virtual bool CacheEquals(object o);
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    private object GetValue(bool raw);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual Type get_FieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
[FlagsAttribute]
internal enum System.Reflection.MdSigCallingConvention : Enum {
    public byte value__;
    public static MdSigCallingConvention CallConvMask;
    public static MdSigCallingConvention Default;
    public static MdSigCallingConvention C;
    public static MdSigCallingConvention StdCall;
    public static MdSigCallingConvention ThisCall;
    public static MdSigCallingConvention FastCall;
    public static MdSigCallingConvention Vararg;
    public static MdSigCallingConvention Field;
    public static MdSigCallingConvention LocalSig;
    public static MdSigCallingConvention Property;
    public static MdSigCallingConvention Unmgd;
    public static MdSigCallingConvention GenericInst;
    public static MdSigCallingConvention Generic;
    public static MdSigCallingConvention HasThis;
    public static MdSigCallingConvention ExplicitThis;
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    internal virtual bool CacheEquals(object o);
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
internal class System.Reflection.MemberInfoSerializationHolder : object {
    private string _memberName;
    private Type _reflectedType;
    private string _signature;
    private string _signature2;
    private MemberTypes _memberType;
    private SerializationInfo _info;
    public MemberInfoSerializationHolder(SerializationInfo info, StreamingContext context);
    public static void GetSerializationInfo(SerializationInfo info, FieldInfo f);
    public static void GetSerializationInfo(SerializationInfo info, EventInfo e);
    public static void GetSerializationInfo(SerializationInfo info, ConstructorInfo c);
    public static void GetSerializationInfo(SerializationInfo info, MethodInfo m);
    public static void GetSerializationInfo(SerializationInfo info, PropertyInfo p);
    private static void GetSerializationInfo(SerializationInfo info, string name, Type reflectedClass, string signature, MemberTypes type);
    private static void GetSerializationInfo(SerializationInfo info, string name, Type reflectedClass, string signature, string signature2, MemberTypes type, Type[] genericArguments);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual object GetRealObject(StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.AssemblyExtensions : object {
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool InternalTryGetRawMetadata(RuntimeAssembly assembly, Byte*& blob, Int32& length);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetRawMetadata(Assembly assembly, Byte*& blob, Int32& length);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.MetadataEnumResult : ValueType {
    private Int32[] largeResult;
    private int length;
    [FixedBufferAttribute("System.Int32", "16")]
private <smallResult>e__FixedBuffer smallResult;
    public int Length { get; }
    public int Item { get; }
    public int get_Length();
    public int get_Item(int index);
}
internal class System.Reflection.MetadataException : Exception {
    private int m_hr;
    internal MetadataException(int hr);
    public virtual string ToString();
}
internal class System.Reflection.MetadataImport : ValueType {
    private IntPtr m_metadataImport2;
    private object m_keepalive;
    internal static MetadataImport EmptyImport;
    internal MetadataImport(IntPtr metadataImport2, object keepalive);
    private static MetadataImport();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool Equals(MetadataImport import);
    private static void _GetMarshalAs(IntPtr pNativeType, int cNativeType, Int32& unmanagedType, Int32& safeArraySubType, String& safeArrayUserDefinedSubType, Int32& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void GetMarshalAs(ConstArray nativeType, UnmanagedType& unmanagedType, VarEnum& safeArraySubType, String& safeArrayUserDefinedSubType, UnmanagedType& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void ThrowError(int hResult);
    private static void _Enum(IntPtr scope, int type, int parent, MetadataEnumResult& result);
    public void Enum(MetadataTokenType type, int parent, MetadataEnumResult& result);
    public void EnumNestedTypes(int mdTypeDef, MetadataEnumResult& result);
    public void EnumCustomAttributes(int mdToken, MetadataEnumResult& result);
    public void EnumParams(int mdMethodDef, MetadataEnumResult& result);
    public void EnumFields(int mdTypeDef, MetadataEnumResult& result);
    public void EnumProperties(int mdTypeDef, MetadataEnumResult& result);
    public void EnumEvents(int mdTypeDef, MetadataEnumResult& result);
    private static string _GetDefaultValue(IntPtr scope, int mdToken, Int64& value, Int32& length, Int32& corElementType);
    public string GetDefaultValue(int mdToken, Int64& value, Int32& length, CorElementType& corElementType);
    private static void _GetUserString(IntPtr scope, int mdToken, Void** name, Int32& length);
    public string GetUserString(int mdToken);
    private static void _GetName(IntPtr scope, int mdToken, Void** name);
    public Utf8String GetName(int mdToken);
    private static void _GetNamespace(IntPtr scope, int mdToken, Void** namesp);
    public Utf8String GetNamespace(int mdToken);
    private static void _GetEventProps(IntPtr scope, int mdToken, Void** name, Int32& eventAttributes);
    public void GetEventProps(int mdToken, Void*& name, EventAttributes& eventAttributes);
    private static void _GetFieldDefProps(IntPtr scope, int mdToken, Int32& fieldAttributes);
    public void GetFieldDefProps(int mdToken, FieldAttributes& fieldAttributes);
    private static void _GetPropertyProps(IntPtr scope, int mdToken, Void** name, Int32& propertyAttributes, ConstArray& signature);
    public void GetPropertyProps(int mdToken, Void*& name, PropertyAttributes& propertyAttributes, ConstArray& signature);
    private static void _GetParentToken(IntPtr scope, int mdToken, Int32& tkParent);
    public int GetParentToken(int tkToken);
    private static void _GetParamDefProps(IntPtr scope, int parameterToken, Int32& sequence, Int32& attributes);
    public void GetParamDefProps(int parameterToken, Int32& sequence, ParameterAttributes& attributes);
    private static void _GetGenericParamProps(IntPtr scope, int genericParameter, Int32& flags);
    public void GetGenericParamProps(int genericParameter, GenericParameterAttributes& attributes);
    private static void _GetScopeProps(IntPtr scope, Guid& mvid);
    public void GetScopeProps(Guid& mvid);
    public ConstArray GetMethodSignature(MetadataToken token);
    private static void _GetSigOfMethodDef(IntPtr scope, int methodToken, ConstArray& signature);
    public ConstArray GetSigOfMethodDef(int methodToken);
    private static void _GetSignatureFromToken(IntPtr scope, int methodToken, ConstArray& signature);
    public ConstArray GetSignatureFromToken(int token);
    private static void _GetMemberRefProps(IntPtr scope, int memberTokenRef, ConstArray& signature);
    public ConstArray GetMemberRefProps(int memberTokenRef);
    private static void _GetCustomAttributeProps(IntPtr scope, int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    public void GetCustomAttributeProps(int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    private static void _GetClassLayout(IntPtr scope, int typeTokenDef, Int32& packSize, Int32& classSize);
    public void GetClassLayout(int typeTokenDef, Int32& packSize, Int32& classSize);
    private static bool _GetFieldOffset(IntPtr scope, int typeTokenDef, int fieldTokenDef, Int32& offset);
    public bool GetFieldOffset(int typeTokenDef, int fieldTokenDef, Int32& offset);
    private static void _GetSigOfFieldDef(IntPtr scope, int fieldToken, ConstArray& fieldMarshal);
    public ConstArray GetSigOfFieldDef(int fieldToken);
    private static void _GetFieldMarshal(IntPtr scope, int fieldToken, ConstArray& fieldMarshal);
    public ConstArray GetFieldMarshal(int fieldToken);
    private static void _GetPInvokeMap(IntPtr scope, int token, Int32& attributes, Void** importName, Void** importDll);
    public void GetPInvokeMap(int token, PInvokeAttributes& attributes, String& importName, String& importDll);
    private static bool _IsValidToken(IntPtr scope, int token);
    public bool IsValidToken(int token);
}
internal class System.Reflection.MetadataToken : ValueType {
    public int Value;
    public bool IsGlobalTypeDefToken { get; }
    public MetadataTokenType TokenType { get; }
    public bool IsTypeRef { get; }
    public bool IsTypeDef { get; }
    public bool IsFieldDef { get; }
    public bool IsMethodDef { get; }
    public bool IsMemberRef { get; }
    public bool IsEvent { get; }
    public bool IsProperty { get; }
    public bool IsParamDef { get; }
    public bool IsTypeSpec { get; }
    public bool IsMethodSpec { get; }
    public bool IsString { get; }
    public bool IsSignature { get; }
    public bool IsModule { get; }
    public bool IsAssembly { get; }
    public bool IsGenericPar { get; }
    public MetadataToken(int token);
    public static int op_Implicit(MetadataToken token);
    public static MetadataToken op_Implicit(int token);
    public static bool IsTokenOfType(int token, MetadataTokenType[] types);
    public static bool IsNullToken(int token);
    public bool get_IsGlobalTypeDefToken();
    public MetadataTokenType get_TokenType();
    public bool get_IsTypeRef();
    public bool get_IsTypeDef();
    public bool get_IsFieldDef();
    public bool get_IsMethodDef();
    public bool get_IsMemberRef();
    public bool get_IsEvent();
    public bool get_IsProperty();
    public bool get_IsParamDef();
    public bool get_IsTypeSpec();
    public bool get_IsMethodSpec();
    public bool get_IsString();
    public bool get_IsSignature();
    public bool get_IsModule();
    public bool get_IsAssembly();
    public bool get_IsGenericPar();
    public virtual string ToString();
}
internal enum System.Reflection.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldDef;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamDef;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType Permission;
    public static MetadataTokenType Signature;
    public static MetadataTokenType Event;
    public static MetadataTokenType Property;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType GenericPar;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType String;
    public static MetadataTokenType Name;
    public static MetadataTokenType BaseType;
    public static MetadataTokenType Invalid;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
public abstract class System.Reflection.MethodBase : MemberInfo {
    internal string FullName { get; }
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsAbstract { get; }
    public bool IsConstructor { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public static MethodBase GetCurrentMethod();
    private IntPtr GetMethodDesc();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    internal static string ConstructParameters(Type[] parameterTypes, CallingConventions callingConvention, bool serialization);
    internal string get_FullName();
    internal string FormatNameAndSig();
    internal virtual string FormatNameAndSig(bool serialization);
    internal virtual Type[] GetParameterTypes();
    internal Object[] CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig);
    public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodBody GetMethodBody();
    public virtual CallingConventions get_CallingConvention();
    public bool get_IsAbstract();
    public bool get_IsConstructor();
    public bool get_IsFinal();
    public bool get_IsHideBySig();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
}
public class System.Reflection.MethodBody : object {
    private Byte[] m_IL;
    private ExceptionHandlingClause[] m_exceptionHandlingClauses;
    private LocalVariableInfo[] m_localVariables;
    internal MethodBase m_methodBase;
    private int m_localSignatureMetadataToken;
    private int m_maxStackSize;
    private bool m_initLocals;
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
}
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodInfo GetBaseDefinition();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    public static bool op_Inequality(MethodInfo left, MethodInfo right);
}
[FlagsAttribute]
internal enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public class System.Reflection.Missing : object {
    public static Missing Value;
    private static Missing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    private static BindingFlags DefaultLookup;
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private static Module();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public ModuleHandle get_ModuleHandle();
    protected virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual bool IsResource();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual Type[] GetTypes();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual int get_MetadataToken();
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public virtual string ToString();
    private static bool FilterTypeNameImpl(Type cls, object filterCriteria);
    private static bool FilterTypeNameIgnoreCaseImpl(Type cls, object filterCriteria);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AssemblyIsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    [CompilerGeneratedAttribute]
public bool get_AssemblyIsPrivate();
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
}
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToMembers();
    [CompilerGeneratedAttribute]
public void set_ApplyToMembers(bool value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    protected Type ClassImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    protected string NameImpl;
    protected int PositionImpl;
    private static int MetadataToken_ParamDef;
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_MetadataToken();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    public bool Item { get; public set; }
    internal Boolean[] IsByRefArray { get; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    internal Boolean[] get_IsByRefArray();
}
[FlagsAttribute]
internal enum System.Reflection.PInvokeAttributes : Enum {
    public int value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    private Void* _ptr;
    private Type _ptrType;
    private Pointer(Void* ptr, Type ptrType);
    private Pointer(SerializationInfo info, StreamingContext context);
    public static object Box(Void* ptr, Type type);
    public static Void* Unbox(object ptr);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal Type GetPointerType();
    internal object GetPointerValue();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual Type get_PropertyType();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public bool get_IsSpecialName();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo get_GetMethod();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo get_SetMethod();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
}
internal static class System.Reflection.PseudoCustomAttribute : object {
    private static Dictionary`2<RuntimeType, RuntimeType> s_pca;
    private static int s_pcasCount;
    private static PseudoCustomAttribute();
    internal static void GetSecurityAttributes(RuntimeModule module, int token, bool assembly, Object[]& securityAttributes);
    [ConditionalAttribute("_DEBUG")]
private static void VerifyPseudoCustomAttribute(RuntimeType pca);
    internal static bool IsSecurityAttribute(RuntimeType type);
    internal static Attribute[] GetCustomAttributes(RuntimeType type, RuntimeType caType, bool includeSecCa, Int32& count);
    internal static bool IsDefined(RuntimeType type, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, bool includeSecCa, Int32& count);
    internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType, bool includeSecCa, Int32& count);
    internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeModule module, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType, bool includeSecCa, Int32& count);
    internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    internal static Attribute[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType, Int32& count);
    internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
}
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception[] <LoaderExceptions>k__BackingField;
    public Type[] Types { get; }
    public Exception[] LoaderExceptions { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    internal ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public Exception[] get_LoaderExceptions();
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
internal class System.Reflection.RtFieldInfo : RuntimeFieldInfo {
    private IntPtr m_fieldHandle;
    private FieldAttributes m_fieldAttributes;
    private string m_name;
    private RuntimeType m_fieldType;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    public string Name { get; }
    internal string FullName { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    internal RtFieldInfo(RuntimeFieldHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    private static void PerformVisibilityCheckOnField(IntPtr field, object target, RuntimeType declaringType, FieldAttributes attr, UInt32 invocationFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private RuntimeAssembly GetRuntimeAssembly();
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
    internal void CheckConsistency(object target);
    internal virtual bool CacheEquals(object o);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture, StackCrawlMark& stackMark);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object InternalGetValue(object obj, StackCrawlMark& stackMark);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object UnsafeGetValue(object obj);
    public virtual string get_Name();
    internal string get_FullName();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual RuntimeFieldHandle get_FieldHandle();
    internal IntPtr GetFieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_FieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
internal class System.Reflection.RuntimeAssembly : Assembly {
    private static UInt32 COR_E_LOADING_REFERENCE_ASSEMBLY;
    [CompilerGeneratedAttribute]
private ModuleResolveEventHandler _ModuleResolve;
    private string m_fullname;
    private object m_syncRoot;
    private IntPtr m_assembly;
    private ASSEMBLY_FLAGS m_flags;
    private static string s_localFilePrefix;
    private static String[] s_unsafeFrameworkAssemblyNames;
    private ASSEMBLY_FLAGS Flags { get; }
    internal object SyncRoot { get; }
    public string CodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    private static RuntimeAssembly();
    [CompilerGeneratedAttribute]
private void add__ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__ModuleResolve(ModuleResolveEventHandler value);
    private ASSEMBLY_FLAGS get_Flags();
    internal object get_SyncRoot();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetCodeBase(RuntimeAssembly assembly, bool copiedName, StringHandleOnStack retString);
    internal string GetCodeBase(bool copiedName);
    public virtual string get_CodeBase();
    internal RuntimeAssembly GetNativeHandle();
    public virtual AssemblyName GetName(bool copiedName);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetFullName(RuntimeAssembly assembly, StringHandleOnStack retString);
    public virtual string get_FullName();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetEntryPoint(RuntimeAssembly assembly, ObjectHandleOnStack retMethod);
    public virtual MethodInfo get_EntryPoint();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetType(RuntimeAssembly assembly, string name, bool throwOnError, bool ignoreCase, ObjectHandleOnStack type, ObjectHandleOnStack keepAlive);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetExportedTypes(RuntimeAssembly assembly, ObjectHandleOnStack retTypes);
    public virtual Type[] GetExportedTypes();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Module get_ManifestModule();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal static RuntimeAssembly InternalLoadFrom(string assemblyFile, Evidence securityEvidence, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm, bool forIntrospection, StackCrawlMark& stackMark);
    internal static RuntimeAssembly InternalLoad(string assemblyString, Evidence assemblySecurity, StackCrawlMark& stackMark, bool forIntrospection);
    internal static RuntimeAssembly InternalLoad(string assemblyString, Evidence assemblySecurity, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool forIntrospection);
    internal static AssemblyName CreateAssemblyName(string assemblyString, bool forIntrospection, RuntimeAssembly& assemblyFromResolveEvent);
    internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, bool throwOnFileNotFound, bool forIntrospection, IntPtr ptrLoadContextBinder);
    internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool throwOnFileNotFound, bool forIntrospection, IntPtr ptrLoadContextBinder);
    internal bool IsFrameworkAssembly();
    private static RuntimeAssembly _nLoad(AssemblyName fileName, string codeBase, Evidence assemblySecurity, RuntimeAssembly locationHint, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks, IntPtr ptrLoadContextBinder);
    private static RuntimeAssembly nLoad(AssemblyName fileName, string codeBase, Evidence assemblySecurity, RuntimeAssembly locationHint, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool throwOnFileNotFound, bool forIntrospection, IntPtr ptrLoadContextBinder);
    private static bool IsReflectionOnly(RuntimeAssembly assembly);
    public virtual bool get_ReflectionOnly();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetModule(RuntimeAssembly assembly, string name, ObjectHandleOnStack retModule);
    public virtual Module GetModule(string name);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    private static String[] GetManifestResourceNames(RuntimeAssembly assembly);
    public virtual String[] GetManifestResourceNames();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetExecutingAssembly(StackCrawlMarkHandle stackMark, ObjectHandleOnStack retAssembly);
    internal static RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark);
    private static AssemblyName[] GetReferencedAssemblies(RuntimeAssembly assembly);
    public virtual AssemblyName[] GetReferencedAssemblies();
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetManifestResourceInfo(RuntimeAssembly assembly, string resourceName, ObjectHandleOnStack assemblyRef, StringHandleOnStack retFileName, StackCrawlMarkHandle stackMark);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetLocation(RuntimeAssembly assembly, StringHandleOnStack retString);
    public virtual string get_Location();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetImageRuntimeVersion(RuntimeAssembly assembly, StringHandleOnStack retString);
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    private static string VerifyCodeBase(string codebase);
    internal Stream GetManifestResourceStream(Type type, string name, bool skipSecurityCheck, StackCrawlMark& stackMark);
    [SuppressUnmanagedCodeSecurityAttribute]
private static Byte* GetResource(RuntimeAssembly assembly, string resourceName, UInt64& length, StackCrawlMarkHandle stackMark, bool skipSecurityCheck);
    internal Stream GetManifestResourceStream(string name, StackCrawlMark& stackMark, bool skipSecurityCheck);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetVersion(RuntimeAssembly assembly, Int32& majVer, Int32& minVer, Int32& buildNum, Int32& revNum);
    internal Version GetVersion();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetLocale(RuntimeAssembly assembly, StringHandleOnStack retString);
    internal CultureInfo GetLocale();
    private static bool FCallIsDynamic(RuntimeAssembly assembly);
    public virtual bool get_IsDynamic();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetSimpleName(RuntimeAssembly assembly, StringHandleOnStack retSimpleName);
    internal string GetSimpleName();
    [SuppressUnmanagedCodeSecurityAttribute]
private static AssemblyHashAlgorithm GetHashAlgorithm(RuntimeAssembly assembly);
    private AssemblyHashAlgorithm GetHashAlgorithm();
    [SuppressUnmanagedCodeSecurityAttribute]
private static AssemblyNameFlags GetFlags(RuntimeAssembly assembly);
    private AssemblyNameFlags GetFlags();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetPublicKey(RuntimeAssembly assembly, ObjectHandleOnStack retPublicKey);
    internal Byte[] GetPublicKey();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsAllSecurityTransparent(RuntimeAssembly assembly);
    internal bool IsAllSecurityTransparent();
    private RuntimeModule OnModuleResolveEvent(string moduleName);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    internal Assembly InternalGetSatelliteAssembly(CultureInfo culture, Version version, StackCrawlMark& stackMark);
    internal RuntimeAssembly InternalGetSatelliteAssembly(string name, CultureInfo culture, Version version, bool throwOnFileNotFound, StackCrawlMark& stackMark);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetModules(RuntimeAssembly assembly, bool loadIfNotFound, bool getResourceModules, ObjectHandleOnStack retModuleHandles);
    private RuntimeModule[] GetModulesInternal(bool loadIfNotFound, bool getResourceModules);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    internal static RuntimeModule GetManifestModule(RuntimeAssembly assembly);
    internal static int GetToken(RuntimeAssembly assembly);
}
internal class System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
    private RuntimeType modreq(System.Runtime.CompilerServices.IsVolatile) m_declaringType;
    private RuntimeTypeCache m_reflectedTypeCache;
    private string m_toString;
    private ParameterInfo[] m_parameters;
    private object _empty1;
    private object _empty2;
    private object _empty3;
    private IntPtr m_handle;
    private MethodAttributes m_methodAttributes;
    private BindingFlags m_bindingFlags;
    private Signature modreq(System.Runtime.CompilerServices.IsVolatile) m_signature;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    private Signature Signature { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    internal BindingFlags BindingFlags { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeConstructorInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    internal virtual bool CacheEquals(object o);
    private Signature get_Signature();
    private RuntimeType get_ReflectedTypeInternal();
    private void CheckConsistency(object target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    internal RuntimeAssembly GetRuntimeAssembly();
    internal virtual Type GetReturnType();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    internal static void CheckCanCreateInstance(Type declaringType, bool isVarArg);
    internal void ThrowNoInvokeException();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodBody GetMethodBody();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
}
internal class System.Reflection.RuntimeEventInfo : EventInfo {
    private int m_token;
    private EventAttributes m_flags;
    private string m_name;
    private Void* m_utf8name;
    private RuntimeTypeCache m_reflectedTypeCache;
    private RuntimeMethodInfo m_addMethod;
    private RuntimeMethodInfo m_removeMethod;
    private RuntimeMethodInfo m_raiseMethod;
    private MethodInfo[] m_otherMethod;
    private RuntimeType m_declaringType;
    private BindingFlags m_bindingFlags;
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public EventAttributes Attributes { get; }
    internal RuntimeEventInfo(int tkEvent, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    internal virtual bool CacheEquals(object o);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    private RuntimeType get_ReflectedTypeInternal();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual EventAttributes get_Attributes();
}
internal abstract class System.Reflection.RuntimeFieldInfo : FieldInfo {
    private BindingFlags m_bindingFlags;
    protected RuntimeTypeCache m_reflectedTypeCache;
    protected RuntimeType m_declaringType;
    internal BindingFlags BindingFlags { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    protected RuntimeFieldInfo(RuntimeTypeCache reflectedTypeCache, RuntimeType declaringType, BindingFlags bindingFlags);
    internal BindingFlags get_BindingFlags();
    private RuntimeType get_ReflectedTypeInternal();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeType GetRuntimeType();
    internal abstract virtual RuntimeModule GetRuntimeModule();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Reflection.RuntimeMethodInfo : MethodInfo {
    private IntPtr m_handle;
    private RuntimeTypeCache m_reflectedTypeCache;
    private string m_name;
    private string m_toString;
    private ParameterInfo[] m_parameters;
    private ParameterInfo m_returnParameter;
    private BindingFlags m_bindingFlags;
    private MethodAttributes m_methodAttributes;
    private Signature m_signature;
    private RuntimeType m_declaringType;
    private object m_keepalive;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeMethodInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags, object keepalive);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    private RuntimeType get_ReflectedTypeInternal();
    private ParameterInfo[] FetchNonReturnParameters();
    private ParameterInfo FetchReturnParameter();
    internal virtual string FormatNameAndSig(bool serialization);
    internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal BindingFlags get_BindingFlags();
    internal RuntimeMethodInfo GetParentDefinition();
    internal RuntimeType GetDeclaringTypeInternal();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    internal RuntimeAssembly GetRuntimeAssembly();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodBody GetMethodBody();
    private void CheckConsistency(object target);
    private void ThrowNoInvokeException();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object UnsafeInvoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
private object UnsafeInvokeInternal(object obj, Object[] parameters, Object[] arguments);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
private Object[] InvokeArgumentsCheck(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    private Delegate CreateDelegateInternal(Type delegateType, object firstArgument, DelegateBindingFlags bindingFlags, StackCrawlMark& stackMark);
    public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
    internal static MethodBase InternalGetCurrentMethod(StackCrawlMark& stackMark);
}
internal class System.Reflection.RuntimeModule : Module {
    private RuntimeType m_runtimeType;
    private RuntimeAssembly m_runtimeAssembly;
    private IntPtr m_pRefClass;
    private IntPtr m_pData;
    private IntPtr m_pGlobals;
    private IntPtr m_pFields;
    public int MDStreamVersion { get; }
    internal RuntimeType RuntimeType { get; }
    internal MetadataImport MetadataImport { get; }
    public string FullyQualifiedName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetType(RuntimeModule module, string className, bool throwOnError, bool ignoreCase, ObjectHandleOnStack type, ObjectHandleOnStack keepAlive);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool nIsTransientInternal(RuntimeModule module);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetScopeName(RuntimeModule module, StringHandleOnStack retString);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetFullyQualifiedName(RuntimeModule module, StringHandleOnStack retString);
    private static RuntimeType[] GetTypes(RuntimeModule module);
    internal RuntimeType[] GetDefinedTypes();
    private static bool IsResource(RuntimeModule module);
    private static RuntimeTypeHandle[] ConvertToTypeHandleArray(Type[] genericArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    private FieldInfo ResolveLiteralField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal MethodInfo GetMethodInternal(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal RuntimeType get_RuntimeType();
    internal bool IsTransientInternal();
    internal MetadataImport get_MetadataImport();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    internal string GetFullyQualifiedName();
    public virtual string get_FullyQualifiedName();
    public virtual Type[] GetTypes();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    protected virtual ModuleHandle GetModuleHandleImpl();
    internal RuntimeModule GetNativeHandle();
}
internal class System.Reflection.RuntimeParameterInfo : ParameterInfo {
    private static Type s_DecimalConstantAttributeType;
    private static Type s_CustomConstantAttributeType;
    private int m_tkParamDef;
    private MetadataImport m_scope;
    private Signature m_signature;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_nameIsCached;
    private bool m_noMetadata;
    private bool m_noDefaultValue;
    private MethodBase m_originalMember;
    internal MethodBase DefiningMethod { get; }
    public Type ParameterType { get; }
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int MetadataToken { get; }
    internal RuntimeParameterInfo(RuntimeParameterInfo accessor, RuntimePropertyInfo property);
    private RuntimeParameterInfo(RuntimeParameterInfo accessor, MemberInfo member);
    private RuntimeParameterInfo(Signature signature, MetadataImport scope, int tkParamDef, int position, ParameterAttributes attributes, MemberInfo member);
    internal RuntimeParameterInfo(MethodInfo owner, string name, Type parameterType, int position);
    private static RuntimeParameterInfo();
    internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    internal static ParameterInfo GetReturnParameter(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo& returnParameter, bool fetchReturnParameter);
    internal MethodBase get_DefiningMethod();
    internal void SetName(string name);
    internal void SetAttributes(ParameterAttributes attributes);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Type get_ParameterType();
    public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    private object GetDefaultValue(bool raw);
    private object GetDefaultValueInternal(bool raw);
    internal RuntimeModule GetRuntimeModule();
    public virtual int get_MetadataToken();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class System.Reflection.RuntimePropertyInfo : PropertyInfo {
    private int m_token;
    private string m_name;
    private Void* m_utf8name;
    private PropertyAttributes m_flags;
    private RuntimeTypeCache m_reflectedTypeCache;
    private RuntimeMethodInfo m_getterMethod;
    private RuntimeMethodInfo m_setterMethod;
    private MethodInfo[] m_otherMethod;
    private RuntimeType m_declaringType;
    private BindingFlags m_bindingFlags;
    private Signature m_signature;
    private ParameterInfo[] m_parameters;
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal RuntimePropertyInfo(int tkProperty, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal bool EqualsSig(RuntimePropertyInfo target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    private string FormatNameAndSig(bool serialization);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    private RuntimeType get_ReflectedTypeInternal();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    internal object GetConstantValue(bool raw);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Type get_PropertyType();
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    internal ParameterInfo[] GetIndexParametersNoCopy();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj, Object[] index);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal string SerializationToString();
}
public class System.Reflection.StrongNameKeyPair : object {
    private bool _keyPairExported;
    private Byte[] _keyPairArray;
    private string _keyPairContainer;
    private Byte[] _publicKey;
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(FileStream keyPairFile);
    public StrongNameKeyPair(Byte[] keyPairArray);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    protected TargetException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    internal TargetInvocationException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    internal TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
}
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsSZArray { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.TypeInfo : Type {
    private static BindingFlags DeclaredOnlyLookup;
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<GetDeclaredMethods>d__10")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<get_DeclaredNestedTypes>d__22")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
}
internal class System.ReflectionOnlyType : RuntimeType {
    public RuntimeTypeHandle TypeHandle { get; }
    public virtual RuntimeTypeHandle get_TypeHandle();
}
internal static class System.ResId : object {
    internal static string Arg_ArrayLengthsDiffer;
    internal static string Argument_InvalidNumberOfMembers;
    internal static string Argument_UnequalMembers;
    internal static string Argument_SpecifyValueSize;
    internal static string Argument_UnmatchingSymScope;
    internal static string Argument_NotInExceptionBlock;
    internal static string Argument_NotExceptionType;
    internal static string Argument_InvalidLabel;
    internal static string Argument_UnclosedExceptionBlock;
    internal static string Argument_MissingDefaultConstructor;
    internal static string Argument_TooManyFinallyClause;
    internal static string Argument_NotInTheSameModuleBuilder;
    internal static string Argument_BadCurrentLocalVariable;
    internal static string Argument_DuplicateModuleName;
    internal static string Argument_BadPersistableModuleInTransientAssembly;
    internal static string Argument_HasToBeArrayClass;
    internal static string Argument_InvalidDirectory;
    internal static string MissingType;
    internal static string MissingModule;
    internal static string ArgumentOutOfRange_Index;
    internal static string ArgumentOutOfRange_Range;
    internal static string ExecutionEngine_YoureHosed;
    internal static string Format_NeedSingleChar;
    internal static string Format_StringZeroLength;
    internal static string InvalidOperation_EnumEnded;
    internal static string InvalidOperation_EnumFailedVersion;
    internal static string InvalidOperation_EnumNotStarted;
    internal static string InvalidOperation_EnumOpCantHappen;
    internal static string InvalidOperation_InternalState;
    internal static string InvalidOperation_ModifyRONumFmtInfo;
    internal static string InvalidOperation_MethodBaked;
    internal static string InvalidOperation_NotADebugModule;
    internal static string InvalidOperation_MethodHasBody;
    internal static string InvalidOperation_OpenLocalVariableScope;
    internal static string InvalidOperation_TypeHasBeenCreated;
    internal static string InvalidOperation_RefedAssemblyNotSaved;
    internal static string InvalidOperation_AssemblyHasBeenSaved;
    internal static string InvalidOperation_ModuleHasBeenSaved;
    internal static string InvalidOperation_CannotAlterAssembly;
    internal static string NotSupported_CannotSaveModuleIndividually;
    internal static string NotSupported_Constructor;
    internal static string NotSupported_Method;
    internal static string NotSupported_NYI;
    internal static string NotSupported_DynamicModule;
    internal static string NotSupported_NotDynamicModule;
    internal static string NotSupported_NotAllTypesAreBaked;
    internal static string NotSupported_SortedListNestedWrite;
    internal static string Serialization_ArrayInvalidLength;
    internal static string Serialization_ArrayNoLength;
    internal static string Serialization_CannotGetType;
    internal static string Serialization_InsufficientState;
    internal static string Serialization_InvalidID;
    internal static string Serialization_MalformedArray;
    internal static string Serialization_MultipleMembers;
    internal static string Serialization_NoID;
    internal static string Serialization_NoType;
    internal static string Serialization_NoBaseType;
    internal static string Serialization_NullSignature;
    internal static string Serialization_UnknownMember;
    internal static string Serialization_BadParameterInfo;
    internal static string Serialization_NoParameterInfo;
    internal static string WeakReference_NoLongerValid;
    internal static string Loader_InvalidPath;
}
public class System.ResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal abstract class System.Resolver : object {
    internal abstract virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    internal abstract virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal abstract virtual Byte[] GetLocalsSignature();
    internal abstract virtual void GetEHInfo(int EHNumber, Void* exception);
    internal abstract virtual Byte[] GetRawEHInfo();
    internal abstract virtual string GetStringLiteral(int token);
    internal abstract virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal abstract virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal abstract virtual MethodInfo GetDynamicMethod();
}
internal static class System.Resources.__HResults : object {
    public static int ERROR_MRM_MAP_NOT_FOUND;
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    private string FindResourceFile(CultureInfo culture, string fileName);
    private ResourceSet CreateResourceSet(string file);
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, StackCrawlMark& stackMark);
    private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture);
    internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    private Stream GetManifestResourceStream(RuntimeAssembly satellite, string fileName, StackCrawlMark& stackMark);
    private Stream CaseInsensitiveManifestResourceStreamLookup(RuntimeAssembly satellite, string name);
    private RuntimeAssembly GetSatelliteAssembly(CultureInfo lookForCulture, StackCrawlMark& stackMark);
    private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
    private string GetSatelliteAssemblyName();
    private void HandleSatelliteMissing();
    private void HandleResourceStreamMissing(string fileName);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static bool GetNeutralResourcesLanguageAttribute(RuntimeAssembly assemblyHandle, StringHandleOnStack cultureName, Int16& fallbackLocation);
}
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    private string _cultureName;
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
[AttributeUsageAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private UltimateResourceFallbackLocation <Location>k__BackingField;
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public UltimateResourceFallbackLocation get_Location();
}
[FriendAccessAllowedAttribute]
internal class System.Resources.PRIExceptionInfo : object {
    public string _PackageSimpleName;
    public string _ResWFile;
}
internal class System.Resources.ResourceFallbackManager : object {
    private CultureInfo m_startingCulture;
    private CultureInfo m_neutralResourcesCulture;
    private bool m_useParents;
    [ThreadStaticAttribute]
private static CultureInfo[] cachedOsFallbackArray;
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Resources.ResourceFallbackManager/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
internal class System.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
public class System.Resources.ResourceManager : object {
    protected string BaseNameField;
    [ObsoleteAttribute("call InternalGetResourceSet instead")]
internal Hashtable ResourceSets;
    private Dictionary`2<string, ResourceSet> _resourceSets;
    private string moduleDir;
    protected Assembly MainAssembly;
    private Type _locationInfo;
    private Type _userResourceSet;
    private CultureInfo _neutralResourcesCulture;
    private CultureNameResourceSetPair _lastUsedResourceCache;
    private bool _ignoreCase;
    private bool UseManifest;
    [OptionalFieldAttribute]
private bool UseSatelliteAssem;
    private static Hashtable modreq(System.Runtime.CompilerServices.IsVolatile) _installedSatelliteInfo;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _checkedConfigFile;
    [OptionalFieldAttribute]
private UltimateResourceFallbackLocation _fallbackLoc;
    [OptionalFieldAttribute]
private Version _satelliteContractVersion;
    [OptionalFieldAttribute]
private bool _lookedForSatelliteContractVersion;
    [OptionalFieldAttribute]
private Assembly _callingAssembly;
    [OptionalFieldAttribute]
private RuntimeAssembly m_callingAssembly;
    private IResourceGroveler resourceGroveler;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    private static Type _minResourceSet;
    internal static string ResReaderTypeName;
    internal static string ResSetTypeName;
    internal static string MscorlibName;
    internal static string ResFileExtension;
    internal static int ResFileExtensionLength;
    internal static int DEBUG;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_IsAppXModel;
    private bool _bUsingModernResourceManagement;
    private WindowsRuntimeResourceManagerBase _WinRTResourceManager;
    private bool _PRIonAppXInitialized;
    private PRIExceptionInfo _PRIExceptionInfo;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    private ResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    private void Init();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    private void CommonAssemblyInit();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    private ResourceSet InternalGetResourceSet(CultureInfo requestedCulture, bool createIfNotExists, bool tryParents, StackCrawlMark& stackMark);
    private static void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs);
    protected static Version GetSatelliteContractVersion(Assembly a);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2);
    private string GetStringFromPRI(string stringName, string startingCulture, string neutralResourcesCulture);
    internal static WindowsRuntimeResourceManagerBase GetWinRTResourceManager();
    private bool ShouldUseSatelliteAssemblyResourceLookupUnderAppX(RuntimeAssembly resourcesAssembly);
    private void SetAppXConfiguration();
    public virtual string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, CultureInfo culture);
    private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream);
    public UnmanagedMemoryStream GetStream(string name);
    public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    private bool TryLookingForSatellite(CultureInfo lookForCulture);
    private Hashtable GetSatelliteAssembliesFromConfig();
}
public class System.Resources.ResourceReader : object {
    private static int DefaultFileStreamBufferSize;
    private BinaryReader _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    private Int32* _namePositionsPtr;
    private RuntimeType[] _typeTable;
    private Int32[] _typeNamePositions;
    private int _numResources;
    private UnmanagedMemoryStream _ums;
    private int _version;
    public ResourceReader(string fileName);
    public ResourceReader(Stream stream);
    internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static int ReadUnalignedI4(Int32* p);
    private void SkipString();
    private int GetNameHash(int index);
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    private bool CompareStringEqualsName(string name);
    private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    private object _LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private void ReadResources();
    private void _ReadResources();
    private RuntimeType FindType(int typeIndex);
    public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
}
public class System.Resources.ResourceSet : object {
    protected IResourceReader Reader;
    internal Hashtable Table;
    private Hashtable _caseInsensitiveTable;
    internal ResourceSet(bool junk);
    public ResourceSet(string fileName);
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    private void CommonInit();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private object GetObjectInternal(string name);
    private object GetCaseInsensitiveObjectInternal(string name);
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
internal class System.Resources.RuntimeResourceSet : ResourceSet {
    internal static int Version;
    private Dictionary`2<string, ResourceLocator> _resCache;
    private ResourceReader _defaultReader;
    private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable;
    private bool _haveReadFromReader;
    internal RuntimeResourceSet(string fileName);
    internal RuntimeResourceSet(Stream stream);
    protected virtual void Dispose(bool disposing);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string key);
    public virtual string GetString(string key, bool ignoreCase);
    public virtual object GetObject(string key);
    public virtual object GetObject(string key, bool ignoreCase);
    private object GetObject(string key, bool ignoreCase, bool isString);
    private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<string, ResourceLocator> copyOfCache, bool keyInWrongCase);
}
[AttributeUsageAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
[FriendAccessAllowedAttribute]
internal class System.Resources.WindowsRuntimeResourceManagerBase : object {
    public CultureInfo GlobalResourceContextBestFitCultureInfo { get; }
    public virtual bool Initialize(string libpath, string reswFilename, PRIExceptionInfo& exceptionInfo);
    public virtual string GetString(string stringName, string startingCulture, string neutralResourcesCulture);
    public virtual CultureInfo get_GlobalResourceContextBestFitCultureInfo();
    public virtual bool SetGlobalResourceContextDefaultCulture(CultureInfo ci);
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
internal class System.Runtime.CompilerServices.ArrayPinningHelper : object {
    public IntPtr m_lengthAndPadding;
    public byte m_arrayData;
}
internal class System.Runtime.CompilerServices.AsyncMethodBuilderCore : ValueType {
    internal IAsyncStateMachine m_stateMachine;
    internal Action m_defaultContextAction;
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    internal Action GetCompletionAction(Task taskForTracing, MoveNextRunner& runnerToInitialize);
    private Action OutputAsyncCausalityEvents(Task innerTask, Action continuation);
    internal void PostBoxInitialization(IAsyncStateMachine stateMachine, MoveNextRunner runner, Task builtTask);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
    internal static Action CreateContinuationWrapper(Action continuation, Action invokeAction, Task innerTask);
    internal static Action TryGetStateMachineForDebugger(Action action);
    internal static Task TryGetContinuationTask(Action action);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
internal static class System.Runtime.CompilerServices.AsyncTaskCache : object {
    internal static Task`1<bool> TrueTask;
    internal static Task`1<bool> FalseTask;
    internal static Task`1[] Int32Tasks;
    internal static int INCLUSIVE_INT32_MIN;
    internal static int EXCLUSIVE_INT32_MAX;
    private static AsyncTaskCache();
    private static Task`1[] CreateInt32Tasks();
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private static Task`1<VoidTaskResult> s_cachedCompleted;
    private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder;
    public Task Task { get; }
    private object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder();
    public static AsyncTaskMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task get_Task();
    public void SetResult();
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    private object get_ObjectIdForDebugger();
}
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    internal static Task`1<TResult> s_defaultResultTask;
    private AsyncMethodBuilderCore m_coreState;
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    private object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder`1();
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task`1<TResult> get_Task();
    private Task`1<TResult> InitializeTask();
    public void SetResult(TResult result);
    private void SetExistingTaskResult(TResult result);
    private void LogExistingTaskCompletion();
    internal void SetResult(Task`1<TResult> completedTask);
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    private object get_ObjectIdForDebugger();
    private Task`1<TResult> GetTaskForResult(TResult result);
}
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private SynchronizationContext m_synchronizationContext;
    private AsyncMethodBuilderCore m_coreState;
    private Task m_task;
    private Task Task { get; }
    private object ObjectIdForDebugger { get; }
    public static AsyncVoidMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    private void NotifySynchronizationContextOfCompletion();
    private Task get_Task();
    private object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <CompilationRelaxations>k__BackingField;
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    [CompilerGeneratedAttribute]
public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    private static int InitialCapacity;
    private object _lock;
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private int _activeEnumeratorRefCount;
    internal ICollection`1<TKey> Keys { get; }
    internal ICollection`1<TValue> Values { get; }
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    private TValue GetValueLocked(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public TValue GetOrCreateValue(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [FriendAccessAllowedAttribute]
internal TKey FindEquivalentKeyUnsafe(TKey key, TValue& value);
    internal ICollection`1<TKey> get_Keys();
    internal ICollection`1<TValue> get_Values();
    private void CreateEntry(TKey key, TValue value);
    private static bool IsPowerOfTwo(int value);
}
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable(Task task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter GetAwaiter();
}
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
public static class System.Runtime.CompilerServices.ContractHelper : object {
    private static EventHandler`1 modreq(System.Runtime.CompilerServices.IsVolatile) contractFailedEvent;
    private static object lockObject;
    internal static int COR_E_CODECONTRACTFAILED;
    private static ContractHelper();
    [DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
private static void RaiseContractFailedEventImplementation(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException, String& resultFailureMessage);
    [DebuggerNonUserCodeAttribute]
private static void TriggerFailureImplementation(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    private static string GetResourceNameForFailure(ContractFailureKind failureKind);
    private static string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText);
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
    internal static object GetRawConstant(CustomAttributeData attr);
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    private DateTime date;
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
    internal static DateTime GetRawDateTimeConstant(CustomAttributeData attr);
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    private decimal dec;
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
    internal static decimal GetRawDecimalConstant(CustomAttributeData attr);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DependentAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public string get_DependentAssembly();
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
internal class System.Runtime.CompilerServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    public object GetPrimary();
    public void GetPrimaryAndSecondary(Object& primary, Object& secondary);
    public void SetPrimary(object primary);
    public void SetSecondary(object secondary);
    public void Free();
    private static void nInitialize(object primary, object secondary, IntPtr& dependentHandle);
    private static void nGetPrimary(IntPtr dependentHandle, Object& primary);
    private static void nGetPrimaryAndSecondary(IntPtr dependentHandle, Object& primary, Object& secondary);
    private static void nSetPrimary(IntPtr dependentHandle, object primary);
    private static void nSetSecondary(IntPtr dependentHandle, object secondary);
    private static void nFree(IntPtr dependentHandle);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] arguments);
}
[AttributeUsageAttribute("2044")]
[FriendAccessAllowedAttribute]
internal class System.Runtime.CompilerServices.FriendAccessAllowedAttribute : Attribute {
}
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
public interface System.Runtime.CompilerServices.ICastable {
    public abstract virtual bool IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    public abstract virtual RuntimeTypeHandle GetImplType(RuntimeTypeHandle interfaceType);
}
internal class System.Runtime.CompilerServices.ICastableHelpers : object {
    internal static bool IsInstanceOfInterface(ICastable castable, RuntimeType type, Exception& castError);
    internal static RuntimeType GetImplType(ICastable castable, RuntimeType interfaceType);
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllInternalsVisible>k__BackingField;
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public bool get_AllInternalsVisible();
    [CompilerGeneratedAttribute]
public void set_AllInternalsVisible(bool value);
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
[ExtensionAttribute]
[FriendAccessAllowedAttribute]
internal static class System.Runtime.CompilerServices.JitHelpers : object {
    internal static string QCall;
    internal static StringHandleOnStack GetStringHandleOnStack(String& s);
    internal static ObjectHandleOnStack GetObjectHandleOnStack(T& o);
    internal static StackCrawlMarkHandle GetStackCrawlMarkHandle(StackCrawlMark& stackMark);
    [FriendAccessAllowedAttribute]
internal static T UnsafeCast(object o);
    internal static int UnsafeEnumCast(T val);
    internal static long UnsafeEnumCastLong(T val);
    internal static IntPtr UnsafeCastToStackPointer(T& val);
    internal static void UnsafeSetArrayElement(Object[] target, int index, object element);
    internal static PinningHelper GetPinningHelper(object o);
    [ExtensionAttribute]
internal static Byte& GetRawSzArrayData(Array array);
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    internal MethodImplOptions _val;
    public MethodCodeType MethodCodeType;
    public MethodImplOptions Value { get; }
    internal MethodImplAttribute(MethodImplAttributes methodImplAttributes);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions InternalCall;
}
internal class System.Runtime.CompilerServices.ObjectHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal ObjectHandleOnStack(IntPtr pObject);
}
internal class System.Runtime.CompilerServices.PinningHelper : object {
    public byte m_data;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WrapNonExceptionThrows>k__BackingField;
    public bool WrapNonExceptionThrows { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WrapNonExceptionThrows();
    [CompilerGeneratedAttribute]
public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static bool IsSupported(string feature);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    public static object GetUninitializedObject(Type type);
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static object GetObjectValue(object obj);
    private static void _RunClassConstructor(RuntimeType type);
    public static void RunClassConstructor(RuntimeTypeHandle type);
    private static void _RunModuleConstructor(RuntimeModule module);
    public static void RunModuleConstructor(ModuleHandle module);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void _CompileMethod(IRuntimeMethodInfo method);
    public static void PrepareMethod(RuntimeMethodHandle method);
    public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareDelegate(Delegate d);
    public static int GetHashCode(object o);
    public static bool Equals(object o1, object o2);
    [NonVersionableAttribute]
public static int get_OffsetToStringData();
    public static void EnsureSufficientExecutionStack();
    public static bool TryEnsureSufficientExecutionStack();
    public static void ProbeForSufficientStack();
    public static void PrepareConstrainedRegions();
    public static void PrepareConstrainedRegionsNoOP();
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    internal static void ExecuteBackoutCodeHelper(object backoutCode, object userData, bool exceptionThrown);
    public static bool IsReferenceOrContainsReferences();
}
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    private object m_wrappedException;
    public object WrappedException { get; }
    private RuntimeWrappedException(object thrownObject);
    internal RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StackCrawlMarkHandle : ValueType {
    private IntPtr m_ptr;
    internal StackCrawlMarkHandle(IntPtr stackMark);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <StateMachineType>k__BackingField;
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StringHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal StringHandleOnStack(IntPtr pString);
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    private Task m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter(Task task);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public void GetResult();
    internal static void ValidateEnd(Task task);
    private static void HandleNonSuccessAndDebuggerNotification(Task task);
    private static void ThrowForNonSuccess(Task task);
    internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
    private static Action OutputWaitEtwEvents(Task task, Action continuation);
}
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter`1(Task`1<TResult> task);
    public bool get_IsCompleted();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
    public TResult GetResult();
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("11148")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("1036")]
internal class System.Runtime.CompilerServices.TypeDependencyAttribute : Attribute {
    private string typeName;
    public TypeDependencyAttribute(string typeName);
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Destination>k__BackingField;
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    [CompilerGeneratedAttribute]
public Type get_Destination();
}
internal static class System.Runtime.CompilerServices.Unsafe : object {
    [NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [NonVersionableAttribute]
public static int SizeOf();
    [NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [NonVersionableAttribute]
public static T& AddByteOffset(T& source, ulong byteOffset);
    [NonVersionableAttribute]
public static bool AreSame(T& left, T& right);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static T ReadUnaligned(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [NonVersionableAttribute]
public static void WriteUnaligned(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Byte& destination, T value);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("96")]
internal class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Consistency <ConsistencyGuarantee>k__BackingField;
    [CompilerGeneratedAttribute]
private Cer <Cer>k__BackingField;
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    [CompilerGeneratedAttribute]
public Consistency get_ConsistencyGuarantee();
    [CompilerGeneratedAttribute]
public Cer get_Cer();
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    private Exception m_Exception;
    private string m_remoteStackTrace;
    private object m_stackTrace;
    private object m_dynamicMethods;
    private UIntPtr m_IPForWatsonBuckets;
    private object m_WatsonBuckets;
    internal UIntPtr IPForWatsonBuckets { get; }
    internal object WatsonBuckets { get; }
    internal object BinaryStackTraceArray { get; }
    internal object DynamicMethodArray { get; }
    internal string RemoteStackTrace { get; }
    public Exception SourceException { get; }
    private ExceptionDispatchInfo(Exception exception);
    internal UIntPtr get_IPForWatsonBuckets();
    internal object get_WatsonBuckets();
    internal object get_BinaryStackTraceArray();
    internal object get_DynamicMethodArray();
    internal string get_RemoteStackTrace();
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    public void Throw();
    public static void Throw(Exception source);
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    private Exception m_Exception;
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static bool IsServerGC { get; }
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
    public static bool get_IsServerGC();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private object m_array;
    private int m_offset;
    private int m_count;
    public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
    private int CalculateCount();
}
[AttributeUsageAttribute("1037")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    internal bool _bestFitMapping;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    public bool get_BestFitMapping();
}
public class System.Runtime.InteropServices.BStrWrapper : object {
    private string m_WrappedObject;
    public string WrappedObject { get; }
    public BStrWrapper(string value);
    public BStrWrapper(object value);
    public string get_WrappedObject();
}
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    internal ClassInterfaceType _val;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    public ClassInterfaceType get_Value();
}
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    internal Type _CoClass;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    public Type get_CoClass();
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    internal Type _val;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    public Type get_Value();
}
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
    internal static object UnwrapIfTransparentProxy(object rcw);
}
internal class System.Runtime.InteropServices.ComEventsInfo : object {
    private ComEventsSink _sinks;
    private object _rcw;
    private ComEventsInfo(object rcw);
    protected virtual override void Finalize();
    internal static ComEventsInfo Find(object rcw);
    internal static ComEventsInfo FromObject(object rcw);
    internal ComEventsSink FindSink(Guid& iid);
    internal ComEventsSink AddSink(Guid& iid);
    internal ComEventsSink RemoveSink(ComEventsSink sink);
}
internal class System.Runtime.InteropServices.ComEventsMethod : object {
    private DelegateWrapper[] _delegateWrappers;
    private int _dispid;
    private ComEventsMethod _next;
    internal bool Empty { get; }
    internal ComEventsMethod(int dispid);
    internal static ComEventsMethod Find(ComEventsMethod methods, int dispid);
    internal static ComEventsMethod Add(ComEventsMethod methods, ComEventsMethod method);
    internal static ComEventsMethod Remove(ComEventsMethod methods, ComEventsMethod method);
    internal bool get_Empty();
    internal void AddDelegate(Delegate d);
    internal void RemoveDelegate(Delegate d);
}
internal class System.Runtime.InteropServices.ComEventsSink : object {
    private Guid _iidSourceItf;
    private IConnectionPoint _connectionPoint;
    private int _cookie;
    private ComEventsMethod _methods;
    private ComEventsSink _next;
    private static Guid IID_IManagedObject;
    internal ComEventsSink(object rcw, Guid iid);
    private static ComEventsSink();
    internal static ComEventsSink Find(ComEventsSink sinks, Guid& iid);
    internal static ComEventsSink Add(ComEventsSink sinks, ComEventsSink sink);
    internal static ComEventsSink RemoveAll(ComEventsSink sinks);
    internal static ComEventsSink Remove(ComEventsSink sinks, ComEventsSink sink);
    public ComEventsMethod RemoveMethod(ComEventsMethod method);
    public ComEventsMethod FindMethod(int dispid);
    public ComEventsMethod AddMethod(int dispid);
    private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    private void Advise(object rcw);
    private void Unadvise();
}
public class System.Runtime.InteropServices.COMException : ExternalException {
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    protected COMException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
}
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    public static ComInterfaceType InterfaceIsIInspectable;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    public string get_Value();
}
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    public object pUnk;
    public int dwCookie;
}
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    [CompilerGeneratedAttribute]
public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private bool _isClosed;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    protected virtual override void Finalize();
    private void Cleanup();
    private void FireCustomerDebugProbe();
    protected void SetHandle(IntPtr handle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    private decimal m_WrappedObject;
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    public CurrencyWrapper(object obj);
    public decimal get_WrappedObject();
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    internal CharSet _CharSet;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    internal DllImportSearchPath _paths;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    public DllImportSearchPath get_Paths();
}
public class System.Runtime.InteropServices.DispatchWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public DispatchWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    public int get_Value();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    internal string _val;
    public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public bool PreserveSig;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    internal DllImportAttribute(string dllName, string entryPoint, CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar);
    public DllImportAttribute(string dllName);
    internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
    internal static bool IsDefined(RuntimeMethodInfo method);
    public string get_Value();
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
public class System.Runtime.InteropServices.ErrorWrapper : object {
    private int m_ErrorCode;
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public ErrorWrapper(Exception e);
    public int get_ErrorCode();
}
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.Expando.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual void RemoveMember(MemberInfo m);
}
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    internal static bool IsDefined(RuntimeFieldInfo field);
    public int get_Value();
}
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private static GCHandleType MaxHandleType;
    private IntPtr m_handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    internal GCHandle(object value, GCHandleType type);
    internal GCHandle(IntPtr handle);
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public void Free();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public bool get_IsAllocated();
    public static GCHandle op_Explicit(IntPtr value);
    public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static IntPtr ToIntPtr(GCHandle value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    internal IntPtr GetHandleValue();
    private static IntPtr GetHandleValue(IntPtr handle);
    internal bool IsPinned();
    internal static IntPtr InternalAlloc(object value, GCHandleType type);
    internal static void InternalFree(IntPtr handle);
    internal static object InternalGet(IntPtr handle);
    internal static void InternalSet(IntPtr handle, object value, bool isPinned);
    internal static object InternalCompareExchange(IntPtr handle, object value, object oldValue, bool isPinned);
    internal static IntPtr InternalAddrOfPinnedObject(IntPtr handle);
    private void ValidateHandle();
    private static void ValidateHandle(IntPtr handle);
    private static void ThrowArgumentOutOfRangeException_ArgumentOutOfRange_Enum();
    private static void ThrowInvalidOperationException_HandleIsNotInitialized();
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("5149")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public GuidAttribute(string guid);
    public string get_Value();
}
public class System.Runtime.InteropServices.HandleRef : ValueType {
    internal object m_wrapper;
    internal IntPtr m_handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    internal ComInterfaceType _val;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    public ComInterfaceType get_Value();
}
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    internal int _val;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    public int get_Value();
}
public static class System.Runtime.InteropServices.Marshal : object {
    private static int LMEM_FIXED;
    private static int LMEM_MOVEABLE;
    private static long HIWORDMASK;
    private static Guid IID_IUnknown;
    public static int SystemDefaultCharSize;
    public static int SystemMaxDBCSCharSize;
    private static string s_strConvertedTypeInfoAssemblyName;
    private static string s_strConvertedTypeInfoAssemblyTitle;
    private static string s_strConvertedTypeInfoAssemblyDesc;
    private static string s_strConvertedTypeInfoNameSpace;
    internal static Guid ManagedNameGuid;
    private static Marshal();
    private static bool IsWin32Atom(IntPtr ptr);
    private static bool IsNotWin32Atom(IntPtr ptr);
    private static int GetSystemMaxDBCSCharSize();
    public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr, int len);
    public static string PtrToStringAuto(IntPtr ptr, int len);
    public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringAuto(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    public static int SizeOf(object structure);
    public static int SizeOf(T structure);
    public static int SizeOf(Type t);
    public static int SizeOf();
    internal static UInt32 AlignedSizeOf();
    internal static UInt32 SizeOfType(Type type);
    private static UInt32 AlignedSizeOfType(Type type);
    internal static int SizeOfHelper(Type t, bool throwIfNotMarshalable);
    public static IntPtr OffsetOf(Type t, string fieldName);
    public static IntPtr OffsetOf(string fieldName);
    private static IntPtr OffsetOfHelper(IRuntimeFieldInfo f);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    private static void CopyToNative(object source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    private static void CopyToManaged(IntPtr source, object destination, int startIndex, int length);
    public static byte ReadByte(object ptr, int ofs);
    public static byte ReadByte(IntPtr ptr, int ofs);
    public static byte ReadByte(IntPtr ptr);
    public static short ReadInt16(object ptr, int ofs);
    public static short ReadInt16(IntPtr ptr, int ofs);
    public static short ReadInt16(IntPtr ptr);
    public static int ReadInt32(object ptr, int ofs);
    public static int ReadInt32(IntPtr ptr, int ofs);
    public static int ReadInt32(IntPtr ptr);
    public static IntPtr ReadIntPtr(object ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr);
    public static long ReadInt64(object ptr, int ofs);
    public static long ReadInt64(IntPtr ptr, int ofs);
    public static long ReadInt64(IntPtr ptr);
    public static void WriteByte(IntPtr ptr, int ofs, byte val);
    public static void WriteByte(object ptr, int ofs, byte val);
    public static void WriteByte(IntPtr ptr, byte val);
    public static void WriteInt16(IntPtr ptr, int ofs, short val);
    public static void WriteInt16(object ptr, int ofs, short val);
    public static void WriteInt16(IntPtr ptr, short val);
    public static void WriteInt16(IntPtr ptr, int ofs, char val);
    public static void WriteInt16(object ptr, int ofs, char val);
    public static void WriteInt16(IntPtr ptr, char val);
    public static void WriteInt32(IntPtr ptr, int ofs, int val);
    public static void WriteInt32(object ptr, int ofs, int val);
    public static void WriteInt32(IntPtr ptr, int val);
    public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    public static void WriteInt64(IntPtr ptr, int ofs, long val);
    public static void WriteInt64(object ptr, int ofs, long val);
    public static void WriteInt64(IntPtr ptr, long val);
    public static int GetLastWin32Error();
    internal static void SetLastWin32Error(int error);
    public static int GetHRForLastWin32Error();
    public static void Prelink(MethodInfo m);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void InternalPrelink(IRuntimeMethodInfo m);
    public static void PrelinkAll(Type c);
    public static IntPtr GetExceptionPointers();
    public static int GetExceptionCode();
    [ReliabilityContractAttribute("3", "1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    public static void PtrToStructure(IntPtr ptr, object structure);
    public static void PtrToStructure(IntPtr ptr, T structure);
    public static object PtrToStructure(IntPtr ptr, Type structureType);
    public static T PtrToStructure(IntPtr ptr);
    private static void PtrToStructureHelper(IntPtr ptr, object structure, bool allowValueClasses);
    public static void DestroyStructure(IntPtr ptr, Type structuretype);
    public static void DestroyStructure(IntPtr ptr);
    public static IntPtr GetHINSTANCE(Module m);
    [SuppressUnmanagedCodeSecurityAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr GetHINSTANCE(RuntimeModule m);
    public static void ThrowExceptionForHR(int errorCode);
    public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    internal static void ThrowExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    public static Exception GetExceptionForHR(int errorCode);
    public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    internal static Exception GetExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static IntPtr AllocHGlobal(int cb);
    public static void FreeHGlobal(IntPtr hglobal);
    public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    public static IntPtr StringToHGlobalAnsi(string s);
    public static IntPtr StringToHGlobalUni(string s);
    public static IntPtr StringToHGlobalAuto(string s);
    public static int GetHRForException(Exception e);
    internal static int GetHRForException_WinRT(Exception e);
    public static string GetTypeInfoName(ITypeInfo typeInfo);
    public static Type GetTypeFromCLSID(Guid clsid);
    public static IntPtr GetIUnknownForObject(object o);
    private static IntPtr GetIUnknownForObjectNative(object o, bool onlyInContext);
    internal static IntPtr GetRawIUnknownForComObjectNoAddRef(object o);
    public static IntPtr GetIDispatchForObject(object o);
    public static IntPtr GetComInterfaceForObject(object o, Type T);
    public static IntPtr GetComInterfaceForObject(T o);
    public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    private static IntPtr GetComInterfaceForObjectNative(object o, Type t, bool onlyInContext, bool fEnalbeCustomizedQueryInterface);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    public static void CleanupUnusedObjectsInCurrentContext();
    public static bool AreComObjectsAvailableForCleanup();
    public static bool IsComObject(object o);
    public static IntPtr AllocCoTaskMem(int cb);
    public static IntPtr StringToCoTaskMemUni(string s);
    public static IntPtr StringToCoTaskMemUTF8(string s);
    public static IntPtr StringToCoTaskMemAuto(string s);
    public static IntPtr StringToCoTaskMemAnsi(string s);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    public static void FreeBSTR(IntPtr ptr);
    public static IntPtr StringToBSTR(string s);
    public static string PtrToStringBSTR(IntPtr ptr);
    public static int ReleaseComObject(object o);
    internal static int InternalReleaseComObject(object o);
    public static int FinalReleaseComObject(object o);
    internal static void InternalFinalReleaseComObject(object o);
    public static object GetComObjectData(object obj, object key);
    public static bool SetComObjectData(object obj, object key, object data);
    public static object CreateWrapperOfType(object o, Type t);
    public static TWrapper CreateWrapperOfType(T o);
    private static object InternalCreateWrapperOfType(object o, Type t);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int AddRef(IntPtr pUnk);
    public static int Release(IntPtr pUnk);
    public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static int GetStartComSlot(Type t);
    public static Guid GenerateGuidForType(Type type);
    public static string GenerateProgIdForType(Type type);
    public static object BindToMoniker(string monikerName);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void CreateBindCtx(UInt32 reserved, IBindCtx& ppbc);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void MkParseDisplayName(IBindCtx pbc, string szUserName, UInt32& pchEaten, IMoniker& ppmk);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void BindMoniker(IMoniker pmk, UInt32 grfOpt, Guid& iidResult, Object& ppvResult);
    private static IntPtr LoadLicenseManager();
    public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    internal static void InitializeWrapperForWinRT(object o, IntPtr& pUnk);
    internal static void InitializeManagedWinRTFactoryObject(object o, RuntimeType runtimeClassType);
    internal static object GetNativeActivationFactory(Type type);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    internal static Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t);
    public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    internal static IntPtr GetFunctionPointerForDelegateInternal(Delegate d);
    public static IntPtr SecureStringToBSTR(SecureString s);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static void ZeroFreeBSTR(IntPtr s);
    public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
}
[AttributeUsageAttribute("10496")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    internal UnmanagedType _val;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int IidParameterIndex;
    public UnmanagedType ArraySubType;
    public short SizeParamIndex;
    public int SizeConst;
    public string MarshalType;
    public Type MarshalTypeRef;
    public string MarshalCookie;
    public UnmanagedType Value { get; }
    internal MarshalAsAttribute(UnmanagedType val, VarEnum safeArraySubType, RuntimeType safeArrayUserDefinedSubType, UnmanagedType arraySubType, short sizeParamIndex, int sizeConst, string marshalType, RuntimeType marshalTypeRef, string marshalCookie, int iidParamIndex);
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public MarshalAsAttribute(short unmanagedType);
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
    internal static Attribute GetCustomAttribute(RuntimeFieldInfo field);
    internal static bool IsDefined(RuntimeFieldInfo field);
    internal static Attribute GetCustomAttribute(int token, RuntimeModule scope);
    public UnmanagedType get_Value();
}
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
    public CallingConvention CallingConvention;
    public string EntryPoint;
}
internal static class System.Runtime.InteropServices.NativeMethods : object {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeParameterInfo parameter);
    internal static bool IsDefined(RuntimeParameterInfo parameter);
}
internal enum System.Runtime.InteropServices.PInvokeMap : Enum {
    public int value__;
    public static PInvokeMap NoMangle;
    public static PInvokeMap CharSetMask;
    public static PInvokeMap CharSetNotSpec;
    public static PInvokeMap CharSetAnsi;
    public static PInvokeMap CharSetUnicode;
    public static PInvokeMap CharSetAuto;
    public static PInvokeMap PinvokeOLE;
    public static PInvokeMap SupportsLastError;
    public static PInvokeMap BestFitMask;
    public static PInvokeMap BestFitEnabled;
    public static PInvokeMap BestFitDisabled;
    public static PInvokeMap BestFitUseAsm;
    public static PInvokeMap ThrowOnUnmappableCharMask;
    public static PInvokeMap ThrowOnUnmappableCharEnabled;
    public static PInvokeMap ThrowOnUnmappableCharDisabled;
    public static PInvokeMap ThrowOnUnmappableCharUseAsm;
    public static PInvokeMap CallConvMask;
    public static PInvokeMap CallConvWinapi;
    public static PInvokeMap CallConvCdecl;
    public static PInvokeMap CallConvStdcall;
    public static PInvokeMap CallConvThiscall;
    public static PInvokeMap CallConvFastcall;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
    internal static bool IsDefined(RuntimeMethodInfo method);
}
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    internal string _val;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    public string get_Value();
}
internal static class System.Runtime.InteropServices.RuntimeEnvironment : object {
    internal static string GetModuleFileName();
    public static string GetSystemVersion();
}
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    private static UIntPtr Uninitialized;
    private UIntPtr _numBytes;
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static SafeBuffer();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    public ulong get_ByteLength();
    private void SpaceCheck(Byte* ptr, ulong sizeInBytes);
    private static void NotEnoughRoom();
    private static InvalidOperationException NotInitialized();
    internal static void GenericPtrToStructure(Byte* ptr, T& structure, UInt32 sizeofT);
    private static void PtrToStructureNative(Byte* ptr, TypedReference structure, UInt32 sizeofT);
    internal static void GenericStructureToPtr(T& structure, Byte* ptr, UInt32 sizeofT);
    private static void StructureToPtrNative(TypedReference structure, Byte* ptr, UInt32 sizeofT);
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private int _state;
    private bool _ownsHandle;
    private bool _fullyInitialized;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual override void Finalize();
    private void InternalFinalize();
    protected void SetHandle(IntPtr handle);
    public IntPtr DangerousGetHandle();
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void InternalDispose();
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
    public void DangerousAddRef(Boolean& success);
    public void DangerousRelease();
}
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
[DefaultMemberAttribute("Item")]
internal class System.Runtime.InteropServices.StringBuffer : ValueType {
    private Char[] _buffer;
    private int _length;
    public char Item { get; public set; }
    public Char[] UnderlyingArray { get; }
    public int Capacity { get; }
    public int Length { get; public set; }
    public StringBuffer(int initialCapacity);
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public Char[] get_UnderlyingArray();
    public int get_Capacity();
    public void EnsureCapacity(int minCapacity);
    public int get_Length();
    public void set_Length(int value);
    public bool Contains(char value);
    public bool StartsWith(string value);
    public bool SubstringEquals(string value, int startIndex, int count);
    public void Append(StringBuffer& value, int startIndex);
    public void Append(StringBuffer& value, int startIndex, int count);
    public void CopyTo(int bufferIndex, StringBuffer& destination, int destinationIndex, int count);
    public void CopyFrom(int bufferIndex, string source, int sourceIndex, int count);
    public void TrimEnd(Char[] values);
    public virtual string ToString();
    public string Substring(int startIndex, int count);
    public void Free();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    private static int DEFAULT_PACKING_SIZE;
    internal LayoutKind _val;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    internal StructLayoutAttribute(LayoutKind layoutKind, int pack, int size, CharSet charSet);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
    public LayoutKind get_Value();
}
[AttributeUsageAttribute("5144")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    internal string Scope_;
    internal string Identifier_;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    public string get_Scope();
    public string get_Identifier();
}
public class System.Runtime.InteropServices.UnknownWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    public object get_WrappedObject();
}
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    public bool BestFitMapping;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public CharSet CharSet;
    [CompilerGeneratedAttribute]
private CallingConvention <CallingConvention>k__BackingField;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public CallingConvention get_CallingConvention();
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    public static UnmanagedType IDispatch;
    public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    public static UnmanagedType VBByRefStr;
    public static UnmanagedType AnsiBStr;
    public static UnmanagedType TBStr;
    public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType IInspectable;
    public static UnmanagedType HString;
    public static UnmanagedType LPUTF8Str;
}
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
public class System.Runtime.InteropServices.VariantWrapper : object {
    private object m_WrappedObject;
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    public object get_WrappedObject();
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableIterableToEnumerableAdapter : object {
    internal IEnumerator GetEnumerator_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableVectorToCollectionAdapter : object {
    internal int Count();
    internal bool IsSynchronized();
    internal object SyncRoot();
    internal void CopyTo(Array array, int arrayIndex);
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableVectorToListAdapter : object {
    internal object Indexer_Get(int index);
    internal void Indexer_Set(int index, object value);
    internal int Add(object value);
    internal bool Contains(object item);
    internal void Clear();
    internal bool IsFixedSize();
    internal bool IsReadOnly();
    internal int IndexOf(object item);
    internal void Insert(int index, object item);
    internal void Remove(object item);
    internal void RemoveAt(int index);
    private static object GetAt(IBindableVector _this, UInt32 index);
    private static void SetAt(IBindableVector _this, UInt32 index, object value);
    private static void InsertAtHelper(IBindableVector _this, UInt32 index, object item);
    private static void RemoveAtHelper(IBindableVector _this, UInt32 index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIKeyValuePairImpl`2 : object {
    private KeyValuePair`2<K, V> _pair;
    public K Key { get; }
    public V Value { get; }
    public CLRIKeyValuePairImpl`2(KeyValuePair`2& pair);
    public sealed virtual K get_Key();
    public sealed virtual V get_Value();
    internal static object BoxHelper(object pair);
    internal static object UnboxHelper(object wrapper);
    public virtual string ToString();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIPropertyValueImpl : object {
    private PropertyType _type;
    private object _data;
    private static Tuple`2[] modreq(System.Runtime.CompilerServices.IsVolatile) s_numericScalarTypes;
    private static Tuple`2[] NumericScalarTypes { get; }
    public PropertyType Type { get; }
    public bool IsNumericScalar { get; }
    internal CLRIPropertyValueImpl(PropertyType type, object data);
    private static Tuple`2[] get_NumericScalarTypes();
    public sealed virtual PropertyType get_Type();
    public sealed virtual bool get_IsNumericScalar();
    public virtual string ToString();
    public sealed virtual byte GetUInt8();
    public sealed virtual short GetInt16();
    public sealed virtual ushort GetUInt16();
    public sealed virtual int GetInt32();
    public sealed virtual UInt32 GetUInt32();
    public sealed virtual long GetInt64();
    public sealed virtual ulong GetUInt64();
    public sealed virtual float GetSingle();
    public sealed virtual double GetDouble();
    public sealed virtual char GetChar16();
    public sealed virtual bool GetBoolean();
    public sealed virtual string GetString();
    public sealed virtual Guid GetGuid();
    public sealed virtual DateTimeOffset GetDateTime();
    public sealed virtual TimeSpan GetTimeSpan();
    public sealed virtual Point GetPoint();
    public sealed virtual Size GetSize();
    public sealed virtual Rect GetRect();
    public sealed virtual Byte[] GetUInt8Array();
    public sealed virtual Int16[] GetInt16Array();
    public sealed virtual UInt16[] GetUInt16Array();
    public sealed virtual Int32[] GetInt32Array();
    public sealed virtual UInt32[] GetUInt32Array();
    public sealed virtual Int64[] GetInt64Array();
    public sealed virtual UInt64[] GetUInt64Array();
    public sealed virtual Single[] GetSingleArray();
    public sealed virtual Double[] GetDoubleArray();
    public sealed virtual Char[] GetChar16Array();
    public sealed virtual Boolean[] GetBooleanArray();
    public sealed virtual String[] GetStringArray();
    public sealed virtual Object[] GetInspectableArray();
    public sealed virtual Guid[] GetGuidArray();
    public sealed virtual DateTimeOffset[] GetDateTimeArray();
    public sealed virtual TimeSpan[] GetTimeSpanArray();
    public sealed virtual Point[] GetPointArray();
    public sealed virtual Size[] GetSizeArray();
    public sealed virtual Rect[] GetRectArray();
    private T[] CoerceArrayValue(PropertyType unboxType);
    private T CoerceScalarValue(PropertyType unboxType);
    private static T CoerceScalarValue(PropertyType type, object value);
    private static bool IsCoercable(PropertyType type, object data);
    private static bool IsNumericScalarImpl(PropertyType type, object data);
    private T Unbox(Type expectedBoxedType);
    private T[] UnboxArray(Type expectedArrayElementType);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIReferenceArrayImpl`1 : CLRIPropertyValueImpl {
    private T[] _value;
    private IList _list;
    public T[] Value { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public CLRIReferenceArrayImpl`1(PropertyType type, T[] obj);
    public sealed virtual T[] get_Value();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    [FriendAccessAllowedAttribute]
internal static object UnboxHelper(object wrapper);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIReferenceImpl`1 : CLRIPropertyValueImpl {
    private T _value;
    public T Value { get; }
    public CLRIReferenceImpl`1(PropertyType type, T obj);
    public sealed virtual T get_Value();
    public virtual string ToString();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    [FriendAccessAllowedAttribute]
internal static object UnboxHelper(object wrapper);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ConstantSplittableMap`2 : object {
    private static KeyValuePairComparator<TKey, TValue> keyValuePairComparator;
    private KeyValuePair`2[] items;
    private int firstItemIndex;
    private int lastItemIndex;
    public int Count { get; }
    public UInt32 Size { get; }
    internal ConstantSplittableMap`2(IReadOnlyDictionary`2<TKey, TValue> data);
    private ConstantSplittableMap`2(KeyValuePair`2[] items, int firstItemIndex, int lastItemIndex);
    private static ConstantSplittableMap`2();
    private KeyValuePair`2[] CreateKeyValueArray(int count, IEnumerator`1<KeyValuePair`2<TKey, TValue>> data);
    public int get_Count();
    public sealed virtual UInt32 get_Size();
    public sealed virtual TValue Lookup(TKey key);
    public sealed virtual bool HasKey(TKey key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IIterator`1<IKeyValuePair`2<TKey, TValue>> First();
    public sealed virtual IEnumerator`1<IKeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual void Split(IMapView`2& firstPartition, IMapView`2& secondPartition);
    public bool TryGetValue(TKey key, TValue& value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CustomPropertyImpl : object {
    private PropertyInfo m_property;
    public string Name { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type Type { get; }
    public CustomPropertyImpl(PropertyInfo propertyInfo);
    public sealed virtual string get_Name();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual object GetValue(object target);
    public sealed virtual object GetValue(object target, object indexValue);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual void SetValue(object target, object value, object indexValue);
    private object InvokeInternal(object target, Object[] args, bool getValue);
    public sealed virtual Type get_Type();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.DefaultInterfaceAttribute : Attribute {
    private Type m_defaultInterface;
    public Type DefaultInterface { get; }
    public DefaultInterfaceAttribute(Type defaultInterface);
    public Type get_DefaultInterface();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs : EventArgs {
    private string _NamespaceName;
    private Collection`1<string> _ResolvedAssemblyFiles;
    public Collection`1<string> ResolvedAssemblyFiles { get; }
    public DesignerNamespaceResolveEventArgs(string namespaceName);
    public Collection`1<string> get_ResolvedAssemblyFiles();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryKeyCollection`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
    public DictionaryKeyCollection`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void CopyTo(TKey[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Clear();
    public sealed virtual bool Contains(TKey item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryKeyEnumerator`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public DictionaryKeyEnumerator`2(IDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryToMapAdapter : object {
    internal V Lookup(K key);
    internal UInt32 Size();
    internal bool HasKey(K key);
    internal IReadOnlyDictionary`2<K, V> GetView();
    internal bool Insert(K key, V value);
    internal void Remove(K key);
    internal void Clear();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryValueCollection`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
    public DictionaryValueCollection`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void CopyTo(TValue[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Clear();
    public sealed virtual bool Contains(TValue item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryValueEnumerator`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public DictionaryValueEnumerator`2(IDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumerableToBindableIterableAdapter : object {
    internal IBindableIterator First_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumerableToIterableAdapter : object {
    internal IIterator`1<T> First_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumeratorToIteratorAdapter`1 : object {
    private IEnumerator`1<T> m_enumerator;
    private bool m_firstItem;
    private bool m_hasCurrent;
    public T Current { get; }
    private object System.Runtime.InteropServices.WindowsRuntime.IBindableIterator.Current { get; }
    public bool HasCurrent { get; }
    internal EnumeratorToIteratorAdapter`1(IEnumerator`1<T> enumerator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableIterator.get_Current();
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    public sealed virtual int GetMany(T[] items);
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken : ValueType {
    internal ulong m_value;
    internal ulong Value { get; }
    internal EventRegistrationToken(ulong value);
    internal ulong get_Value();
    public static bool op_Equality(EventRegistrationToken left, EventRegistrationToken right);
    public static bool op_Inequality(EventRegistrationToken left, EventRegistrationToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable`1 : object {
    private Dictionary`2<EventRegistrationToken, T> m_tokens;
    private T modreq(System.Runtime.CompilerServices.IsVolatile) m_invokeList;
    public T InvocationList { get; public set; }
    public T get_InvocationList();
    public void set_InvocationList(T value);
    public EventRegistrationToken AddEventHandler(T handler);
    private EventRegistrationToken AddEventHandlerNoLock(T handler);
    [FriendAccessAllowedAttribute]
internal T ExtractHandler(EventRegistrationToken token);
    private static EventRegistrationToken GetPreferredToken(T handler);
    public void RemoveEventHandler(EventRegistrationToken token);
    public void RemoveEventHandler(T handler);
    private void RemoveEventHandlerNoLock(EventRegistrationToken token);
    public static EventRegistrationTokenTable`1<T> GetOrCreateEventRegistrationTokenTable(EventRegistrationTokenTable`1& refEventTable);
}
internal class System.Runtime.InteropServices.WindowsRuntime.GetEnumerator_Delegate`1 : MulticastDelegate {
    public GetEnumerator_Delegate`1(object object, IntPtr method);
    public virtual IEnumerator`1<T> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IEnumerator`1<T> EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.WindowsRuntime.HSTRING_HEADER : ValueType {
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactory {
    public abstract virtual object ActivateInstance();
}
[GuidAttribute("036d2c08-df29-41af-8aa2-d774be62ba6f")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableIterable {
    public abstract virtual IBindableIterator First();
}
[GuidAttribute("6a1d6c07-076d-49f2-8314-f52c9c9a8331")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableIterator {
    public object Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
}
[GuidAttribute("393de7de-6fd0-4c0d-bb71-47244a113e93")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableVector {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IBindableVectorView GetView();
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, object value);
    public abstract virtual void InsertAt(UInt32 index, object value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(object value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
}
[GuidAttribute("346dd6e7-976e-4bc3-815d-ece243bc0f33")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool IndexOf(object value, UInt32& index);
}
[GuidAttribute("30d5a829-7fa4-4026-83bb-d75bae4ea99e")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IClosable {
    public abstract virtual void Close();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IClosableToIDisposableAdapter : object {
    private void Dispose();
}
[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal interface System.Runtime.InteropServices.WindowsRuntime.ICustomProperty {
    public Type Type { get; }
    public string Name { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public abstract virtual Type get_Type();
    public abstract virtual string get_Name();
    public abstract virtual object GetValue(object target);
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target, object indexValue);
    public abstract virtual void SetValue(object target, object value, object indexValue);
    public abstract virtual bool get_CanWrite();
    public abstract virtual bool get_CanRead();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProviderImpl : object {
    internal static ICustomProperty CreateProperty(object target, string propertyName);
    internal static ICustomProperty CreateIndexedProperty(object target, string propertyName, TypeNameNative* pIndexedParamType);
    internal static ICustomProperty CreateIndexedProperty(object target, string propertyName, Type indexedParamType);
    internal static void GetType(object target, TypeNameNative* pIndexedParamType);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProviderProxy`2 : object {
    private object _target;
    private InterfaceForwardingSupport _flags;
    private UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Size { get; }
    private UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.Size { get; }
    internal ICustomPropertyProviderProxy`2(object target, InterfaceForwardingSupport flags);
    internal static object CreateInstance(object target);
    public virtual string ToString();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    public sealed virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableVector.GetAt(UInt32 index);
    private sealed virtual override UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVector.get_Size();
    private sealed virtual override IBindableVectorView System.Runtime.InteropServices.WindowsRuntime.IBindableVector.GetView();
    private sealed virtual override bool System.Runtime.InteropServices.WindowsRuntime.IBindableVector.IndexOf(object value, UInt32& index);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.SetAt(UInt32 index, object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.InsertAt(UInt32 index, object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.RemoveAt(UInt32 index);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Append(object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.RemoveAtEnd();
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Clear();
    private IBindableVector GetIBindableVectorNoThrow();
    private IVector_Raw`1<T1> GetVectorOfT();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.GetAt(UInt32 index);
    private sealed virtual override UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.get_Size();
    private sealed virtual override bool System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.IndexOf(object value, UInt32& index);
    private sealed virtual override IBindableIterator System.Runtime.InteropServices.WindowsRuntime.IBindableIterable.First();
    private IBindableVectorView GetIBindableVectorViewNoThrow();
    private IVectorView`1<T2> GetVectorViewOfT();
    private static T ConvertTo(object value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.IDisposableToIClosableAdapter : object {
    public void Close();
}
internal interface System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget {
    public abstract virtual object GetTarget();
}
[GuidAttribute("faa585ea-6214-4217-afda-7f46de5869b3")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IIterable`1 {
    public abstract virtual IIterator`1<T> First();
}
[GuidAttribute("6a79e863-4300-459a-9966-cbb660963ee1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IIterator`1 {
    public T Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual T get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
    public abstract virtual int GetMany(T[] items);
}
[GuidAttribute("02b51929-c1c4-4a7e-8940-0312b5c18500")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IKeyValuePair`2 {
    public K Key { get; }
    public V Value { get; }
    public abstract virtual K get_Key();
    public abstract virtual V get_Value();
}
[GuidAttribute("60D27C8D-5F61-4CCE-B751-690FAE66AA53")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory {
    public abstract virtual void RunClassConstructor();
}
[GuidAttribute("3c2925fe-8519-45c1-aa79-197b6718c1c1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IMap`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool HasKey(K key);
    public abstract virtual IReadOnlyDictionary`2<K, V> GetView();
    public abstract virtual bool Insert(K key, V value);
    public abstract virtual void Remove(K key);
    public abstract virtual void Clear();
}
[GuidAttribute("e480ce40-a338-4ada-adcf-272272e48cb9")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IMapView`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool HasKey(K key);
    public abstract virtual void Split(IMapView`2& first, IMapView`2& second);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IMapViewToIReadOnlyDictionaryAdapter : object {
    internal V Indexer_Get(K key);
    internal IEnumerable`1<K> Keys();
    internal IEnumerable`1<V> Values();
    internal bool ContainsKey(K key);
    internal bool TryGetValue(K key, V& value);
    private static V Lookup(IMapView`2<K, V> _this, K key);
}
internal class System.Runtime.InteropServices.WindowsRuntime.Indexer_Get_Delegate`1 : MulticastDelegate {
    public Indexer_Get_Delegate`1(object object, IntPtr method);
    public virtual T Invoke(int index);
    public virtual IAsyncResult BeginInvoke(int index, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.WindowsRuntime.InterfaceForwardingSupport : Enum {
    public int value__;
    public static InterfaceForwardingSupport None;
    public static InterfaceForwardingSupport IBindableVector;
    public static InterfaceForwardingSupport IVector;
    public static InterfaceForwardingSupport IBindableVectorView;
    public static InterfaceForwardingSupport IVectorView;
    public static InterfaceForwardingSupport IBindableIterableOrIIterable;
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.WindowsRuntime.InterfaceImplementedInVersionAttribute : Attribute {
    private Type m_interfaceType;
    private byte m_majorVersion;
    private byte m_minorVersion;
    private byte m_buildVersion;
    private byte m_revisionVersion;
    public Type InterfaceType { get; }
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public byte BuildVersion { get; }
    public byte RevisionVersion { get; }
    public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
    public Type get_InterfaceType();
    public byte get_MajorVersion();
    public byte get_MinorVersion();
    public byte get_BuildVersion();
    public byte get_RevisionVersion();
}
[GuidAttribute("4bd682dd-7554-40e9-9a9b-82654ede7e62")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IPropertyValue {
    public PropertyType Type { get; }
    public bool IsNumericScalar { get; }
    public abstract virtual PropertyType get_Type();
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual byte GetUInt8();
    public abstract virtual short GetInt16();
    public abstract virtual ushort GetUInt16();
    public abstract virtual int GetInt32();
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual long GetInt64();
    public abstract virtual ulong GetUInt64();
    public abstract virtual float GetSingle();
    public abstract virtual double GetDouble();
    public abstract virtual char GetChar16();
    public abstract virtual bool GetBoolean();
    public abstract virtual string GetString();
    public abstract virtual Guid GetGuid();
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual Point GetPoint();
    public abstract virtual Size GetSize();
    public abstract virtual Rect GetRect();
    public abstract virtual Byte[] GetUInt8Array();
    public abstract virtual Int16[] GetInt16Array();
    public abstract virtual UInt16[] GetUInt16Array();
    public abstract virtual Int32[] GetInt32Array();
    public abstract virtual UInt32[] GetUInt32Array();
    public abstract virtual Int64[] GetInt64Array();
    public abstract virtual UInt64[] GetUInt64Array();
    public abstract virtual Single[] GetSingleArray();
    public abstract virtual Double[] GetDoubleArray();
    public abstract virtual Char[] GetChar16Array();
    public abstract virtual Boolean[] GetBooleanArray();
    public abstract virtual String[] GetStringArray();
    public abstract virtual Object[] GetInspectableArray();
    public abstract virtual Guid[] GetGuidArray();
    public abstract virtual DateTimeOffset[] GetDateTimeArray();
    public abstract virtual TimeSpan[] GetTimeSpanArray();
    public abstract virtual Point[] GetPointArray();
    public abstract virtual Size[] GetSizeArray();
    public abstract virtual Rect[] GetRectArray();
}
[DebuggerDisplayAttribute("Size = {Size}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyDictionaryToIMapViewAdapter : object {
    internal V Lookup(K key);
    internal UInt32 Size();
    internal bool HasKey(K key);
    internal void Split(IMapView`2& first, IMapView`2& second);
}
[DebuggerDisplayAttribute("Size = {Size}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyListToIVectorViewAdapter : object {
    internal T GetAt(UInt32 index);
    internal UInt32 Size();
    internal bool IndexOf(T value, UInt32& index);
    internal UInt32 GetMany(UInt32 startIndex, T[] items);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
}
[GuidAttribute("61c17706-2d65-11e0-9ae8-d48564015472")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IReference`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[GuidAttribute("61c17707-2d65-11e0-9ae8-d48564015472")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IReferenceArray`1 {
    public T[] Value { get; }
    public abstract virtual T[] get_Value();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.IReferenceFactory : object {
    internal static Type s_pointType;
    internal static Type s_rectType;
    internal static Type s_sizeType;
    private static IReferenceFactory();
    internal static object CreateIReference(object obj);
    internal static object CreateIReferenceArray(Array obj);
}
[FriendAccessAllowedAttribute]
[GuidAttribute("82BA7092-4C88-427D-A7BC-16DD93FEB67E")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo {
    public abstract virtual void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid);
    public abstract virtual void GetReference(String& reference);
}
[GuidAttribute("96369f54-8eb6-48f0-abce-c1b211e627c3")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IStringable {
    public abstract virtual string ToString();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IStringableHelper : object {
    internal static string ToString(object obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.IterableToEnumerableAdapter : object {
    internal IEnumerator`1<T> GetEnumerator_Stub();
    internal IEnumerator`1<T> GetEnumerator_Variance_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IteratorToEnumeratorAdapter`1 : object {
    private IIterator`1<T> m_iterator;
    private bool m_hadCurrent;
    private T m_current;
    private bool m_isInitialized;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal IteratorToEnumeratorAdapter`1(IIterator`1<T> iterator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[GuidAttribute("913337e9-11a1-4345-a3a2-4e7f956e222d")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVector_Raw`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IVectorView`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
}
[GuidAttribute("913337e9-11a1-4345-a3a2-4e7f956e222d")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVector`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IReadOnlyList`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
    public abstract virtual void ReplaceAll(T[] items);
}
[GuidAttribute("bbe1fa4c-b0e3-4583-baef-1f1b2e483e56")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVectorView`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IVectorViewToIReadOnlyListAdapter : object {
    internal T Indexer_Get(int index);
    internal T Indexer_Get_Variance(int index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToBindableVectorAdapter : object {
    internal object GetAt(UInt32 index);
    internal UInt32 Size();
    internal IBindableVectorView GetView();
    internal bool IndexOf(object value, UInt32& index);
    internal void SetAt(UInt32 index, object value);
    internal void InsertAt(UInt32 index, object value);
    internal void RemoveAt(UInt32 index);
    internal void Append(object value);
    internal void RemoveAtEnd();
    internal void Clear();
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToBindableVectorViewAdapter : object {
    private IList list;
    public UInt32 Size { get; }
    internal ListToBindableVectorViewAdapter(IList list);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
    public sealed virtual IBindableIterator First();
    public sealed virtual object GetAt(UInt32 index);
    public sealed virtual UInt32 get_Size();
    public sealed virtual bool IndexOf(object value, UInt32& index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToVectorAdapter : object {
    internal T GetAt(UInt32 index);
    internal UInt32 Size();
    internal IReadOnlyList`1<T> GetView();
    internal bool IndexOf(T value, UInt32& index);
    internal void SetAt(UInt32 index, T value);
    internal void InsertAt(UInt32 index, T value);
    internal void RemoveAt(UInt32 index);
    internal void Append(T value);
    internal void RemoveAtEnd();
    internal void Clear();
    internal UInt32 GetMany(UInt32 startIndex, T[] items);
    internal void ReplaceAll(T[] items);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
    private static UInt32 GetManyHelper(IList`1<T> sourceList, UInt32 startIndex, T[] items);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
internal class System.Runtime.InteropServices.WindowsRuntime.ManagedActivationFactory : object {
    private Type m_type;
    internal ManagedActivationFactory(Type type);
    public sealed virtual object ActivateInstance();
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory.RunClassConstructor();
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapToCollectionAdapter : object {
    internal int Count();
    internal bool IsReadOnly();
    internal void Add(KeyValuePair`2<K, V> item);
    internal void Clear();
    internal bool Contains(KeyValuePair`2<K, V> item);
    internal void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    internal bool Remove(KeyValuePair`2<K, V> item);
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapToDictionaryAdapter : object {
    internal V Indexer_Get(K key);
    internal void Indexer_Set(K key, V value);
    internal ICollection`1<K> Keys();
    internal ICollection`1<V> Values();
    internal bool ContainsKey(K key);
    internal void Add(K key, V value);
    internal bool Remove(K key);
    internal bool TryGetValue(K key, V& value);
    private static V Lookup(IMap`2<K, V> _this, K key);
    private static bool Insert(IMap`2<K, V> _this, K key, V value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapViewToReadOnlyCollectionAdapter : object {
    internal int Count();
}
internal class System.Runtime.InteropServices.WindowsRuntime.Point : ValueType {
}
internal enum System.Runtime.InteropServices.WindowsRuntime.PropertyType : Enum {
    public int value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType Other;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherArray;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyArrayAttribute : Attribute {
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryKeyCollection`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    public ReadOnlyDictionaryKeyCollection`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryKeyEnumerator`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public ReadOnlyDictionaryKeyEnumerator`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryValueCollection`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    public ReadOnlyDictionaryValueCollection`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryValueEnumerator`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public ReadOnlyDictionaryValueEnumerator`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.Rect : ValueType {
}
[AttributeUsageAttribute("12288")]
public class System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute : Attribute {
    private string m_Name;
    public string Name { get; }
    public ReturnValueNameAttribute(string name);
    public string get_Name();
}
internal abstract class System.Runtime.InteropServices.WindowsRuntime.RuntimeClass : __ComObject {
    internal IntPtr GetRedirectedGetHashCodeMD();
    internal int RedirectGetHashCode(IntPtr pMD);
    public virtual int GetHashCode();
    internal IntPtr GetRedirectedToStringMD();
    internal string RedirectToString(IntPtr pMD);
    public virtual string ToString();
    internal IntPtr GetRedirectedEqualsMD();
    internal bool RedirectEquals(object obj, IntPtr pMD);
    public virtual bool Equals(object obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.Size : ValueType {
}
internal static class System.Runtime.InteropServices.WindowsRuntime.UnsafeNativeMethods : object {
    [SuppressUnmanagedCodeSecurityAttribute]
internal static IRestrictedErrorInfo GetRestrictedErrorInfo();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static bool RoOriginateLanguageException(int error, string message, IntPtr languageException);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void RoReportUnhandledError(IRestrictedErrorInfo error);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int WindowsCreateString(string sourceString, int length, IntPtr* hstring);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int WindowsCreateStringReference(Char* sourceString, int length, HSTRING_HEADER* hstringHeader, IntPtr* hstring);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int WindowsDeleteString(IntPtr hstring);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorToCollectionAdapter : object {
    internal int Count();
    internal bool IsReadOnly();
    internal void Add(T item);
    internal void Clear();
    internal bool Contains(T item);
    internal void CopyTo(T[] array, int arrayIndex);
    internal bool Remove(T item);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorToListAdapter : object {
    internal T Indexer_Get(int index);
    internal void Indexer_Set(int index, T value);
    internal int IndexOf(T item);
    internal void Insert(int index, T item);
    internal void RemoveAt(int index);
    internal static T GetAt(IVector`1<T> _this, UInt32 index);
    private static void SetAt(IVector`1<T> _this, UInt32 index, T value);
    private static void InsertAtHelper(IVector`1<T> _this, UInt32 index, T item);
    internal static void RemoveAtHelper(IVector`1<T> _this, UInt32 index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorViewToReadOnlyCollectionAdapter : object {
    internal int Count();
}
[GuidAttribute("9de1c535-6ae1-11e0-84e1-18a905bcc53f")]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsFoundationEventHandler`1 : MulticastDelegate {
    public WindowsFoundationEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, T args);
    public virtual IAsyncResult BeginInvoke(object sender, T args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferHelper : object {
    [SuppressUnmanagedCodeSecurityAttribute]
private static void StoreOverlappedPtrInCCW(ObjectHandleOnStack windowsRuntimeBuffer, NativeOverlapped* overlapped);
    [FriendAccessAllowedAttribute]
internal static void StoreOverlappedInCCW(object windowsRuntimeBuffer, NativeOverlapped* overlapped);
}
[AttributeUsageAttribute("5148")]
[FriendAccessAllowedAttribute]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeImportAttribute : Attribute {
}
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal : object {
    private static bool s_haveBlueErrorApis;
    private static Guid s_iidIErrorInfo;
    private static WindowsRuntimeMarshal();
    public static void AddEventHandler(Func`2<T, EventRegistrationToken> addMethod, Action`1<EventRegistrationToken> removeMethod, T handler);
    public static void RemoveEventHandler(Action`1<EventRegistrationToken> removeMethod, T handler);
    public static void RemoveAllEventHandlers(Action`1<EventRegistrationToken> removeMethod);
    internal static int GetRegistrationTokenCacheSize();
    internal static void CallRemoveMethods(Action`1<EventRegistrationToken> removeMethod, List`1<EventRegistrationToken> tokensToRemove);
    internal static string HStringToString(IntPtr hstring);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException, string messageResource);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException);
    private static bool RoOriginateLanguageException(int error, string message, IntPtr languageException);
    private static void RoReportUnhandledError(IRestrictedErrorInfo error);
    [FriendAccessAllowedAttribute]
internal static bool ReportUnhandledError(Exception e);
    internal static IntPtr GetActivationFactoryForType(Type type);
    internal static ManagedActivationFactory GetManagedActivationFactory(Type type);
    public static IActivationFactory GetActivationFactory(Type type);
    public static IntPtr StringToHString(string s);
    public static string PtrToStringHString(IntPtr ptr);
    public static void FreeHString(IntPtr ptr);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMetadata : object {
    private static EventHandler`1<DesignerNamespaceResolveEventArgs> DesignerNamespaceResolve;
    internal static String[] OnDesignerNamespaceResolveEvent(AppDomain appDomain, string namespaceName);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.WriteOnlyArrayAttribute : Attribute {
}
internal class System.Runtime.Loader.AppPathAssemblyLoadContext : AssemblyLoadContext {
    protected virtual Assembly Load(AssemblyName assemblyName);
}
public abstract class System.Runtime.Loader.AssemblyLoadContext : object {
    [CompilerGeneratedAttribute]
private Func`3<AssemblyLoadContext, AssemblyName, Assembly> Resolving;
    [CompilerGeneratedAttribute]
private Action`1<AssemblyLoadContext> Unloading;
    private IntPtr m_pNativeAssemblyLoadContext;
    private static AssemblyLoadContext modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultAssemblyLoadContext;
    private static object s_initLock;
    public static AssemblyLoadContext Default { get; }
    internal AssemblyLoadContext(bool fRepresentsTPALoadContext);
    private static AssemblyLoadContext();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool CanUseAppPathAssemblyLoadContextInCurrentDomain();
    [SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr InitializeAssemblyLoadContext(IntPtr ptrAssemblyLoadContext, bool fRepresentsTPALoadContext);
    [SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr LoadFromStream(IntPtr ptrNativeAssemblyLoadContext, IntPtr ptrAssemblyArray, int iAssemblyArrayLen, IntPtr ptrSymbols, int iSymbolArrayLen, ObjectHandleOnStack retAssembly);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void InternalSetProfileRoot(string directoryPath);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void InternalStartProfile(string profile, IntPtr ptrNativeAssemblyLoadContext);
    private void InitializeLoadContext(bool fRepresentsTPALoadContext);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void LoadFromPath(IntPtr ptrNativeAssemblyLoadContext, string ilPath, string niPath, ObjectHandleOnStack retAssembly);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetLoadedAssembliesInternal(ObjectHandleOnStack assemblies);
    public static Assembly[] GetLoadedAssemblies();
    public Assembly LoadFromAssemblyPath(string assemblyPath);
    public Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath);
    public Assembly LoadFromStream(Stream assembly);
    public Assembly LoadFromStream(Stream assembly, Stream assemblySymbols);
    protected abstract virtual Assembly Load(AssemblyName assemblyName);
    private static Assembly Resolve(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private static Assembly ResolveUsingResolvingEvent(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private Assembly GetFirstResolvedAssembly(AssemblyName assemblyName);
    private Assembly ValidateAssemblyNameWithSimpleName(Assembly assembly, string requestedSimpleName);
    private Assembly ResolveUsingLoad(AssemblyName assemblyName);
    private Assembly ResolveUsingEvent(AssemblyName assemblyName);
    public Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    [SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr InternalLoadUnmanagedDllFromPath(string unmanagedDllPath);
    protected IntPtr LoadUnmanagedDllFromPath(string unmanagedDllPath);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    private static IntPtr ResolveUnmanagedDll(string unmanagedDllName, IntPtr gchManagedAssemblyLoadContext);
    public static AssemblyLoadContext get_Default();
    public static AssemblyName GetAssemblyName(string assemblyPath);
    [SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr GetLoadContextForAssembly(RuntimeAssembly assembly);
    public static AssemblyLoadContext GetLoadContext(Assembly assembly);
    public void SetProfileOptimizationRoot(string directoryPath);
    public void StartProfileOptimization(string profile);
    private void OnAppContextUnloading(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public void add_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
public void remove_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
public void add_Unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
public void remove_Unloading(Action`1<AssemblyLoadContext> value);
    public static void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public static void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public static void add_TypeResolve(ResolveEventHandler value);
    public static void remove_TypeResolve(ResolveEventHandler value);
    public static void add_ResourceResolve(ResolveEventHandler value);
    public static void remove_ResourceResolve(ResolveEventHandler value);
    public static void add_AssemblyResolve(ResolveEventHandler value);
    public static void remove_AssemblyResolve(ResolveEventHandler value);
}
internal class System.Runtime.Loader.IndividualAssemblyLoadContext : AssemblyLoadContext {
    protected virtual Assembly Load(AssemblyName assemblyName);
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    private static ulong TopOfMemory;
    private static long hiddenLastKnownFreeAddressSpace;
    private static long hiddenLastTimeCheckingAddressSpace;
    private static int CheckThreshold;
    private static int LowMemoryFudgeFactor;
    private static int MemoryCheckGranularity;
    private static ulong GCSegmentSize;
    private ulong _reservedMemory;
    private bool _mustSubtractReservation;
    private static long LastKnownFreeAddressSpace { get; private set; }
    private static long LastTimeCheckingAddressSpace { get; private set; }
    private static MemoryFailPoint();
    public MemoryFailPoint(int sizeInMegabytes);
    private static long get_LastKnownFreeAddressSpace();
    private static void set_LastKnownFreeAddressSpace(long value);
    private static long AddToLastKnownFreeAddressSpace(long addend);
    private static long get_LastTimeCheckingAddressSpace();
    private static void set_LastTimeCheckingAddressSpace(long value);
    private static void CheckForAvailableMemory(UInt64& availPageFile, UInt64& totalAddressSpaceFree);
    private static bool CheckForFreeAddressSpace(ulong size, bool shouldThrow);
    private static ulong MemFreeAfterAddress(Void* address, ulong size);
    private static void GetMemorySettings(UInt64& maxGCSegmentSize, UInt64& topOfMemory);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class System.Runtime.Remoting.ObjectHandle : object {
    private object WrappedObject;
    internal ObjectHandle(object o);
    internal object Unwrap();
}
public class System.Runtime.RuntimeImports : object {
    internal static void RhZeroMemory(Byte& b, ulong byteLength);
    private static void RhZeroMemory(Byte* b, ulong byteLength);
    internal static void RhBulkMoveWithWriteBarrier(Byte& destination, Byte& source, ulong byteCount);
}
internal class System.Runtime.Serialization.FormatterConverter : object {
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual char ToChar(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual sbyte ToSByte(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual short ToInt16(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ushort ToUInt16(object value);
    public sealed virtual int ToInt32(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual long ToInt64(object value);
    [CLSCompliantAttribute("False")]
public sealed virtual ulong ToUInt64(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual string ToString(object value);
}
internal static class System.Runtime.Serialization.FormatterServices : object {
    public static object GetUninitializedObject(Type type);
    private static object nativeGetUninitializedObject(RuntimeType type);
}
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    private int _versionAdded;
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    private List`1<object> _serializedStates;
    [CompilerGeneratedAttribute]
private StreamingContext <StreamingContext>k__BackingField;
    public StreamingContext StreamingContext { get; }
    public void AddSerializedState(ISafeSerializationData serializedState);
    [CompilerGeneratedAttribute]
public StreamingContext get_StreamingContext();
}
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private string _name;
    private object _value;
    private Type _type;
    public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
public class System.Runtime.Serialization.SerializationException : SystemException {
    private static string s_nullMessage;
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
    private static SerializationException();
}
public class System.Runtime.Serialization.SerializationInfo : object {
    private static int defaultSize;
    private static string s_mscorlibAssemblySimpleName;
    private static string s_mscorlibFileName;
    internal String[] m_members;
    internal Object[] m_data;
    internal Type[] m_types;
    private Dictionary`2<string, int> m_nameToIndex;
    internal int m_currMember;
    internal IFormatterConverter m_converter;
    private string m_fullTypeName;
    private string m_assemName;
    private Type objectType;
    private bool isFullTypeNameSetExplicit;
    private bool isAssemblyNameSetExplicit;
    private bool requireSameTokenInPartialTrust;
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public bool IsAssemblyNameSetExplicit { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public void SetType(Type type);
    internal static void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
    public int get_MemberCount();
    public Type get_ObjectType();
    public bool get_IsFullTypeNameSetExplicit();
    public bool get_IsAssemblyNameSetExplicit();
    public SerializationInfoEnumerator GetEnumerator();
    private void ExpandArrays();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValueInternal(string name, object value, Type type);
    public void UpdateValue(string name, object value, Type type);
    private int FindElement(string name);
    private object GetElement(string name, Type& foundType);
    private object GetElementNoThrow(string name, Type& foundType);
    public object GetValue(string name, Type type);
    internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
}
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private String[] _members;
    private Object[] _data;
    private Type[] _types;
    private int _numItems;
    private int _currItem;
    private bool _current;
    private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    public object get_Value();
    public Type get_ObjectType();
}
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _additionalContext;
    private StreamingContextStates _state;
    public StreamingContextStates State { get; }
    public object Context { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
    public object get_Context();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    private string _frameworkName;
    private string _frameworkDisplayName;
    public string FrameworkName { get; }
    public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
}
public class System.RuntimeArgumentHandle : ValueType {
    private IntPtr m_ptr;
    internal IntPtr Value { get; }
    internal IntPtr get_Value();
}
public class System.RuntimeFieldHandle : ValueType {
    private IRuntimeFieldInfo m_ptr;
    public IntPtr Value { get; }
    internal RuntimeFieldHandle(IRuntimeFieldInfo fieldInfo);
    private RuntimeFieldHandle(SerializationInfo info, StreamingContext context);
    internal RuntimeFieldHandle GetNativeHandle();
    internal IRuntimeFieldInfo GetRuntimeFieldInfo();
    public IntPtr get_Value();
    internal bool IsNullHandle();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    internal static string GetName(RtFieldInfo field);
    private static Void* _GetUtf8Name(RuntimeFieldHandleInternal field);
    internal static Utf8String GetUtf8Name(RuntimeFieldHandleInternal field);
    internal static bool MatchesNameHash(RuntimeFieldHandleInternal handle, UInt32 hash);
    internal static FieldAttributes GetAttributes(RuntimeFieldHandleInternal field);
    internal static RuntimeType GetApproxDeclaringType(RuntimeFieldHandleInternal field);
    internal static RuntimeType GetApproxDeclaringType(IRuntimeFieldInfo field);
    internal static int GetToken(RtFieldInfo field);
    internal static object GetValue(RtFieldInfo field, object instance, RuntimeType fieldType, RuntimeType declaringType, Boolean& domainInitialized);
    internal static object GetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType);
    internal static void SetValue(RtFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, Boolean& domainInitialized);
    internal static void SetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType);
    internal static RuntimeFieldHandleInternal GetStaticFieldForGenericType(RuntimeFieldHandleInternal field, RuntimeType declaringType);
    internal static bool AcquiresContextFromThis(RuntimeFieldHandleInternal field);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsSecurityCritical(RuntimeFieldHandle fieldHandle);
    internal bool IsSecurityCritical();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsSecuritySafeCritical(RuntimeFieldHandle fieldHandle);
    internal bool IsSecuritySafeCritical();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsSecurityTransparent(RuntimeFieldHandle fieldHandle);
    internal bool IsSecurityTransparent();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void CheckAttributeAccess(RuntimeFieldHandle fieldHandle, RuntimeModule decoratedTarget);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.RuntimeFieldHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal IntPtr Value { get; }
    internal RuntimeFieldHandleInternal(IntPtr value);
    internal bool IsNullHandle();
    internal IntPtr get_Value();
}
internal class System.RuntimeFieldInfoStub : object {
    private object m_keepalive;
    private object m_c;
    private object m_d;
    private int m_b;
    private object m_e;
    private RuntimeFieldHandleInternal m_fieldHandle;
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
}
public class System.RuntimeMethodHandle : ValueType {
    private IRuntimeMethodInfo m_value;
    public IntPtr Value { get; }
    internal RuntimeMethodHandle(IRuntimeMethodInfo method);
    private RuntimeMethodHandle(SerializationInfo info, StreamingContext context);
    internal static IRuntimeMethodInfo EnsureNonNullMethodInfo(IRuntimeMethodInfo method);
    internal IRuntimeMethodInfo GetMethodInfo();
    private static IntPtr GetValueInternal(RuntimeMethodHandle rmh);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public bool Equals(RuntimeMethodHandle handle);
    internal bool IsNullHandle();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr GetFunctionPointer(RuntimeMethodHandleInternal handle);
    public IntPtr GetFunctionPointer();
    internal static void CheckLinktimeDemands(IRuntimeMethodInfo method, RuntimeModule module, bool isDecoratedTargetSecurityTransparent);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static bool IsCAVisibleFromDecoratedType(RuntimeTypeHandle attrTypeHandle, IRuntimeMethodInfo attrCtor, RuntimeTypeHandle sourceTypeHandle, RuntimeModule sourceModule);
    private static IRuntimeMethodInfo _GetCurrentMethod(StackCrawlMark& stackMark);
    internal static IRuntimeMethodInfo GetCurrentMethod(StackCrawlMark& stackMark);
    internal static MethodAttributes GetAttributes(RuntimeMethodHandleInternal method);
    internal static MethodAttributes GetAttributes(IRuntimeMethodInfo method);
    internal static MethodImplAttributes GetImplAttributes(IRuntimeMethodInfo method);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void ConstructInstantiation(IRuntimeMethodInfo method, TypeNameFormatFlags format, StringHandleOnStack retString);
    internal static string ConstructInstantiation(IRuntimeMethodInfo method, TypeNameFormatFlags format);
    internal static RuntimeType GetDeclaringType(RuntimeMethodHandleInternal method);
    internal static RuntimeType GetDeclaringType(IRuntimeMethodInfo method);
    internal static int GetSlot(RuntimeMethodHandleInternal method);
    internal static int GetSlot(IRuntimeMethodInfo method);
    internal static int GetMethodDef(IRuntimeMethodInfo method);
    internal static string GetName(RuntimeMethodHandleInternal method);
    internal static string GetName(IRuntimeMethodInfo method);
    private static Void* _GetUtf8Name(RuntimeMethodHandleInternal method);
    internal static Utf8String GetUtf8Name(RuntimeMethodHandleInternal method);
    internal static bool MatchesNameHash(RuntimeMethodHandleInternal method, UInt32 hash);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal static object InvokeMethod(object target, Object[] arguments, Signature sig, bool constructor);
    internal static INVOCATION_FLAGS GetSecurityFlags(IRuntimeMethodInfo handle);
    internal static UInt32 GetSpecialSecurityFlags(IRuntimeMethodInfo method);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetMethodInstantiation(RuntimeMethodHandleInternal method, ObjectHandleOnStack types, bool fAsRuntimeTypeArray);
    internal static RuntimeType[] GetMethodInstantiationInternal(IRuntimeMethodInfo method);
    internal static RuntimeType[] GetMethodInstantiationInternal(RuntimeMethodHandleInternal method);
    internal static Type[] GetMethodInstantiationPublic(IRuntimeMethodInfo method);
    internal static bool HasMethodInstantiation(RuntimeMethodHandleInternal method);
    internal static bool HasMethodInstantiation(IRuntimeMethodInfo method);
    internal static RuntimeMethodHandleInternal GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation);
    internal static RuntimeMethodHandleInternal GetMethodFromCanonical(RuntimeMethodHandleInternal method, RuntimeType declaringType);
    internal static bool IsGenericMethodDefinition(RuntimeMethodHandleInternal method);
    internal static bool IsGenericMethodDefinition(IRuntimeMethodInfo method);
    internal static bool IsTypicalMethodDefinition(IRuntimeMethodInfo method);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetTypicalMethodDefinition(IRuntimeMethodInfo method, ObjectHandleOnStack outMethod);
    internal static IRuntimeMethodInfo GetTypicalMethodDefinition(IRuntimeMethodInfo method);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void StripMethodInstantiation(IRuntimeMethodInfo method, ObjectHandleOnStack outMethod);
    internal static IRuntimeMethodInfo StripMethodInstantiation(IRuntimeMethodInfo method);
    internal static bool IsDynamicMethod(RuntimeMethodHandleInternal method);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void Destroy(RuntimeMethodHandleInternal method);
    internal static Resolver GetResolver(RuntimeMethodHandleInternal method);
    internal static MethodBody GetMethodBody(IRuntimeMethodInfo method, RuntimeType declaringType);
    internal static bool IsConstructor(RuntimeMethodHandleInternal method);
    internal static LoaderAllocator GetLoaderAllocator(RuntimeMethodHandleInternal method);
}
internal class System.RuntimeMethodHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal static RuntimeMethodHandleInternal EmptyHandle { get; }
    internal IntPtr Value { get; }
    internal RuntimeMethodHandleInternal(IntPtr value);
    internal static RuntimeMethodHandleInternal get_EmptyHandle();
    internal bool IsNullHandle();
    internal IntPtr get_Value();
}
internal class System.RuntimeMethodInfoStub : object {
    private object m_keepalive;
    private object m_a;
    private object m_b;
    private object m_c;
    private object m_d;
    private object m_e;
    private object m_f;
    private object m_g;
    public RuntimeMethodHandleInternal m_value;
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    public RuntimeMethodInfoStub(RuntimeMethodHandleInternal methodHandleValue, object keepalive);
    public RuntimeMethodInfoStub(IntPtr methodHandleValue, object keepalive);
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
}
internal class System.RuntimeType : TypeInfo {
    private object m_keepalive;
    private IntPtr m_cache;
    internal IntPtr m_handle;
    internal static RuntimeType ValueType;
    internal static RuntimeType EnumType;
    private static RuntimeType ObjectType;
    private static RuntimeType StringType;
    private static RuntimeType DelegateType;
    private static BindingFlags MemberBindingMask;
    private static BindingFlags InvocationMask;
    private static BindingFlags BinderNonCreateInstance;
    private static BindingFlags BinderGetSetProperty;
    private static BindingFlags BinderSetInvokeProperty;
    private static BindingFlags BinderGetSetField;
    private static BindingFlags BinderSetInvokeField;
    private static BindingFlags BinderNonFieldGetSet;
    private static BindingFlags ClassicBindingMask;
    private static RuntimeType s_typedRef;
    private static ActivatorCache modreq(System.Runtime.CompilerServices.IsVolatile) s_ActivatorCache;
    internal object GenericCache { get; internal set; }
    internal bool DomainInitialized { get; internal set; }
    private RuntimeTypeCache Cache { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public MethodBase DeclaringMethod { get; }
    public Type BaseType { get; }
    public Type UnderlyingSystemType { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Guid GUID { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSZArray { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool ContainsGenericParameters { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    private static RuntimeType();
    internal static RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark);
    internal static MethodBase GetMethodBase(RuntimeModule scope, int typeMetadataToken);
    internal static MethodBase GetMethodBase(IRuntimeMethodInfo methodHandle);
    internal static MethodBase GetMethodBase(RuntimeType reflectedType, IRuntimeMethodInfo methodHandle);
    internal static MethodBase GetMethodBase(RuntimeType reflectedType, RuntimeMethodHandleInternal methodHandle);
    internal object get_GenericCache();
    internal void set_GenericCache(object value);
    internal bool get_DomainInitialized();
    internal void set_DomainInitialized(bool value);
    internal static FieldInfo GetFieldInfo(IRuntimeFieldInfo fieldHandle);
    internal static FieldInfo GetFieldInfo(RuntimeType reflectedType, IRuntimeFieldInfo field);
    private static PropertyInfo GetPropertyInfo(RuntimeType reflectedType, int tkProperty);
    private static void ThrowIfTypeNeverValidGenericArgument(RuntimeType type);
    internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters);
    internal static void ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e);
    private static void SplitName(string fullname, String& name, String& ns);
    internal static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, bool allowPrefixLookup, Boolean& prefixLookup, Boolean& ignoreCase, MemberListType& listType);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, Boolean& ignoreCase, MemberListType& listType);
    private static bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase);
    private static bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
    private static bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
    private static bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags methodFlags, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    internal virtual bool CacheEquals(object o);
    private RuntimeTypeCache get_Cache();
    private string GetDefaultMemberName();
    private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetInterfaces();
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type ifaceType);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual Type GetInterface(string fullname, bool ignoreCase);
    public virtual Type GetNestedType(string fullname, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    internal sealed virtual RuntimeTypeHandle GetTypeHandleInternal();
    internal bool IsCollectible();
    protected virtual TypeCode GetTypeCodeImpl();
    public virtual MethodBase get_DeclaringMethod();
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsSubclassOf(Type type);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    public virtual Type get_BaseType();
    private RuntimeType GetBaseType();
    public virtual Type get_UnderlyingSystemType();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_Namespace();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Guid get_GUID();
    private void GetGUID(Guid& result);
    protected virtual bool IsContextfulImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    internal virtual bool IsWindowsRuntimeObjectImpl();
    internal virtual bool IsExportedToWindowsRuntimeImpl();
    private static bool IsWindowsRuntimeObjectType(RuntimeType type);
    private static bool IsTypeExportedToWindowsRuntime(RuntimeType type);
    internal bool IsDelegate();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool HasElementTypeImpl();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    public virtual int GetArrayRank();
    public virtual Type GetElementType();
    public virtual String[] GetEnumNames();
    public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual Type MakeGenericType(Type[] instantiation);
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    private static bool CanValueSpecialCast(RuntimeType valueType, RuntimeType targetType);
    private static object AllocateValueType(RuntimeType type, object value, bool fForceTypeChange);
    internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    private object TryChangeType(object value, Binder binder, CultureInfo culture, bool needsSpecialCast);
    public virtual MemberInfo[] GetDefaultMembers();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual object Clone();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    internal virtual string FormatTypeName(bool serialization);
    private string GetCachedName(TypeNameKind kind);
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    private void CreateInstanceCheckThis();
    internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark);
    internal object CreateInstanceSlow(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark& stackMark);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark& stackMark);
    internal void InvalidateCachedNestedType();
    internal bool IsGenericCOMObjectImpl();
    private static object _CreateEnum(RuntimeType enumType, long value);
    internal static object CreateEnum(RuntimeType enumType, long value);
    private object InvokeDispMethod(string name, BindingFlags invokeAttr, object target, Object[] args, Boolean[] byrefModifiers, int culture, String[] namedParameters);
    internal static Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError);
    internal static Type GetTypeFromCLSIDImpl(Guid clsid, string server, bool throwOnError);
}
public class System.RuntimeTypeHandle : ValueType {
    private RuntimeType m_type;
    public IntPtr Value { get; }
    internal RuntimeTypeHandle(RuntimeType type);
    private RuntimeTypeHandle(SerializationInfo info, StreamingContext context);
    internal RuntimeTypeHandle GetNativeHandle();
    internal RuntimeType GetTypeChecked();
    internal static bool IsInstanceOfType(RuntimeType type, object o);
    internal static Type GetTypeHelper(Type typeStart, Type[] genericArgs, IntPtr pModifiers, int cModifiers);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public IntPtr get_Value();
    internal static IntPtr GetValueInternal(RuntimeTypeHandle handle);
    internal static bool IsPrimitive(RuntimeType type);
    internal static bool IsByRef(RuntimeType type);
    internal static bool IsPointer(RuntimeType type);
    internal static bool IsArray(RuntimeType type);
    internal static bool IsSZArray(RuntimeType type);
    internal static bool HasElementType(RuntimeType type);
    internal static IntPtr[] CopyRuntimeTypeHandles(RuntimeTypeHandle[] inHandles, Int32& length);
    internal static IntPtr[] CopyRuntimeTypeHandles(Type[] inHandles, Int32& length);
    internal static object CreateInstance(RuntimeType type, bool publicOnly, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor);
    internal static object CreateCaInstance(RuntimeType type, IRuntimeMethodInfo ctor);
    internal static object Allocate(RuntimeType type);
    internal static object CreateInstanceForAnotherGenericParameter(RuntimeType type, RuntimeType genericParameter);
    internal RuntimeType GetRuntimeType();
    internal static CorElementType GetCorElementType(RuntimeType type);
    internal static RuntimeAssembly GetAssembly(RuntimeType type);
    internal static RuntimeModule GetModule(RuntimeType type);
    [CLSCompliantAttribute("False")]
public ModuleHandle GetModuleHandle();
    internal static RuntimeType GetBaseType(RuntimeType type);
    internal static TypeAttributes GetAttributes(RuntimeType type);
    internal static RuntimeType GetElementType(RuntimeType type);
    internal static bool CompareCanonicalHandles(RuntimeType left, RuntimeType right);
    internal static int GetArrayRank(RuntimeType type);
    internal static int GetToken(RuntimeType type);
    internal static RuntimeMethodHandleInternal GetMethodAt(RuntimeType type, int slot);
    internal static IntroducedMethodEnumerator GetIntroducedMethods(RuntimeType type);
    private static RuntimeMethodHandleInternal GetFirstIntroducedMethod(RuntimeType type);
    private static void GetNextIntroducedMethod(RuntimeMethodHandleInternal& method);
    internal static bool GetFields(RuntimeType type, IntPtr* result, Int32* count);
    internal static Type[] GetInterfaces(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetConstraints(RuntimeTypeHandle handle, ObjectHandleOnStack types);
    internal Type[] GetConstraints();
    [SuppressUnmanagedCodeSecurityAttribute]
private static IntPtr GetGCHandle(RuntimeTypeHandle handle, GCHandleType type);
    internal IntPtr GetGCHandle(GCHandleType type);
    internal static int GetNumVirtuals(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void VerifyInterfaceIsImplemented(RuntimeTypeHandle handle, RuntimeTypeHandle interfaceHandle);
    internal void VerifyInterfaceIsImplemented(RuntimeTypeHandle interfaceHandle);
    [SuppressUnmanagedCodeSecurityAttribute]
private static int GetInterfaceMethodImplementationSlot(RuntimeTypeHandle handle, RuntimeTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    internal int GetInterfaceMethodImplementationSlot(RuntimeTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
    internal static bool IsInterface(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool _IsVisible(RuntimeTypeHandle typeHandle);
    internal static bool IsVisible(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsSecurityCritical(RuntimeTypeHandle typeHandle);
    internal bool IsSecurityCritical();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsSecuritySafeCritical(RuntimeTypeHandle typeHandle);
    internal bool IsSecuritySafeCritical();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool IsSecurityTransparent(RuntimeTypeHandle typeHandle);
    internal bool IsSecurityTransparent();
    internal static bool IsValueType(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void ConstructName(RuntimeTypeHandle handle, TypeNameFormatFlags formatFlags, StringHandleOnStack retString);
    internal string ConstructName(TypeNameFormatFlags formatFlags);
    private static Void* _GetUtf8Name(RuntimeType type);
    internal static Utf8String GetUtf8Name(RuntimeType type);
    internal static bool CanCastTo(RuntimeType type, RuntimeType target);
    internal static RuntimeType GetDeclaringType(RuntimeType type);
    internal static IRuntimeMethodInfo GetDeclaringMethod(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetDefaultConstructor(RuntimeTypeHandle handle, ObjectHandleOnStack method);
    internal IRuntimeMethodInfo GetDefaultConstructor();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMarkHandle stackMark, IntPtr pPrivHostBinder, bool loadTypeFromPartialName, ObjectHandleOnStack type, ObjectHandleOnStack keepalive);
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, bool loadTypeFromPartialName);
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, bool reflectionOnly, StackCrawlMark& stackMark, IntPtr pPrivHostBinder, bool loadTypeFromPartialName);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetTypeByNameUsingCARules(string name, RuntimeModule scope, ObjectHandleOnStack type);
    internal static RuntimeType GetTypeByNameUsingCARules(string name, RuntimeModule scope);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetInstantiation(RuntimeTypeHandle type, ObjectHandleOnStack types, bool fAsRuntimeTypeArray);
    internal RuntimeType[] GetInstantiationInternal();
    internal Type[] GetInstantiationPublic();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, int numGenericArgs, ObjectHandleOnStack type);
    internal RuntimeType Instantiate(Type[] inst);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void MakeArray(RuntimeTypeHandle handle, int rank, ObjectHandleOnStack type);
    internal RuntimeType MakeArray(int rank);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void MakeSZArray(RuntimeTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakeSZArray();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void MakeByRef(RuntimeTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakeByRef();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void MakePointer(RuntimeTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakePointer();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static bool IsCollectible(RuntimeTypeHandle handle);
    internal static bool HasInstantiation(RuntimeType type);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetGenericTypeDefinition(RuntimeTypeHandle type, ObjectHandleOnStack retType);
    internal static RuntimeType GetGenericTypeDefinition(RuntimeType type);
    internal static bool IsGenericTypeDefinition(RuntimeType type);
    internal static bool IsGenericVariable(RuntimeType type);
    private static int GetGenericVariableIndex(RuntimeType type);
    internal int GetGenericVariableIndex();
    internal static bool ContainsGenericVariables(RuntimeType handle);
    internal bool ContainsGenericVariables();
    private static bool SatisfiesConstraints(RuntimeType paramType, IntPtr* pTypeContext, int typeContextLength, IntPtr* pMethodContext, int methodContextLength, RuntimeType toType);
    internal static bool SatisfiesConstraints(RuntimeType paramType, RuntimeType[] typeContext, RuntimeType[] methodContext, RuntimeType toType);
    private static IntPtr _GetMetadataImport(RuntimeType type);
    internal static MetadataImport GetMetadataImport(RuntimeType type);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.SafeTypeNameParserHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _ReleaseTypeNameParser(IntPtr pTypeNameParser);
    protected virtual bool ReleaseHandle();
}
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    private sbyte m_value;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    private string ToString(string format, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    private static sbyte Parse(string s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    private static bool TryParse(string s, NumberStyles style, NumberFormatInfo info, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
internal enum System.Security.AccessControl.EventWaitHandleRights : Enum {
    public int value__;
}
internal class System.Security.AccessControl.EventWaitHandleSecurity : object {
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PartialTrustVisibilityLevel <PartialTrustVisibilityLevel>k__BackingField;
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    [CompilerGeneratedAttribute]
public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    [CompilerGeneratedAttribute]
public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    public CryptographicException(string message);
    public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("96")]
internal class System.Security.DynamicSecurityMethodAttribute : Attribute {
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
internal class System.Security.Policy.ApplicationTrust : object {
}
internal class System.Security.Policy.Evidence : object {
}
internal class System.Security.SafeBSTRHandle : SafeBuffer {
    internal UInt32 Length { get; }
    internal static SafeBSTRHandle Allocate(UInt32 lenInChars);
    protected virtual bool ReleaseHandle();
    internal void ClearBuffer();
    internal UInt32 get_Length();
    internal static void Copy(SafeBSTRHandle source, SafeBSTRHandle target, UInt32 bytesToCopy);
}
public class System.Security.SecureString : object {
    private static int MaxLength;
    private object _methodLock;
    private bool _readOnly;
    private int _decryptedLength;
    private static int BlockSize;
    private SafeBSTRHandle _buffer;
    private bool _encrypted;
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    internal SecureString(SecureString str);
    public int get_Length();
    public void AppendChar(char c);
    public void Clear();
    public SecureString Copy();
    public sealed virtual void Dispose();
    public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    public void RemoveAt(int index);
    public void SetAt(int index, char c);
    private void EnsureNotReadOnly();
    internal IntPtr MarshalToString(bool globalAlloc, bool unicode);
    private static void MarshalFree(IntPtr ptr, bool globalAlloc);
    private void InitializeSecureString(Char* value, int length);
    private void AppendCharCore(char c);
    private void ClearCore();
    private void DisposeCore();
    private void InsertAtCore(int index, char c);
    private void RemoveAtCore(int index);
    private void SetAtCore(int index, char c);
    internal IntPtr MarshalToBSTR();
    internal IntPtr MarshalToStringCore(bool globalAlloc, bool unicode);
    private void EnsureNotDisposed();
    private void AllocateBuffer(UInt32 size);
    private static UInt32 GetAlignedSize(UInt32 size);
    private void EnsureCapacity(int capacity);
    private void ProtectMemory();
    private void UnprotectMemory();
}
internal enum System.Security.SecurityContextSource : Enum {
    public int value__;
    public static SecurityContextSource CurrentAppDomain;
    public static SecurityContextSource CurrentAssembly;
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityCriticalScope <Scope>k__BackingField;
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    [CompilerGeneratedAttribute]
public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
public class System.Security.SecurityException : SystemException {
    [CompilerGeneratedAttribute]
private object <Demanded>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DenySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <FailedAssemblyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GrantedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PermissionType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <PermitOnlySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefusedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    protected SecurityException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_Demanded();
    [CompilerGeneratedAttribute]
public void set_Demanded(object value);
    [CompilerGeneratedAttribute]
public object get_DenySetInstance();
    [CompilerGeneratedAttribute]
public void set_DenySetInstance(object value);
    [CompilerGeneratedAttribute]
public AssemblyName get_FailedAssemblyInfo();
    [CompilerGeneratedAttribute]
public void set_FailedAssemblyInfo(AssemblyName value);
    [CompilerGeneratedAttribute]
public string get_GrantedSet();
    [CompilerGeneratedAttribute]
public void set_GrantedSet(string value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public string get_PermissionState();
    [CompilerGeneratedAttribute]
public void set_PermissionState(string value);
    [CompilerGeneratedAttribute]
public Type get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(Type value);
    [CompilerGeneratedAttribute]
public object get_PermitOnlySetInstance();
    [CompilerGeneratedAttribute]
public void set_PermitOnlySetInstance(object value);
    [CompilerGeneratedAttribute]
public string get_RefusedSet();
    [CompilerGeneratedAttribute]
public void set_RefusedSet(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipVerificationInFullTrust>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityRuleSet <RuleSet>k__BackingField;
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    [CompilerGeneratedAttribute]
public bool get_SkipVerificationInFullTrust();
    [CompilerGeneratedAttribute]
public void set_SkipVerificationInFullTrust(bool value);
    [CompilerGeneratedAttribute]
public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    protected VerificationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
    internal static Attribute GetCustomAttribute(RuntimeType type);
    internal static bool IsDefined(RuntimeType type);
}
internal class System.SharedStatics : object {
    private static SharedStatics _sharedStatics;
    private long _memFailPointReservedMemory;
    internal static ulong MemoryFailPointReservedMemory { get; }
    internal static long AddMemoryFailPointReservation(long size);
    internal static ulong get_MemoryFailPointReservedMemory();
}
internal class System.Signature : object {
    internal RuntimeType[] m_arguments;
    internal RuntimeType m_declaringType;
    internal RuntimeType m_returnTypeORfieldType;
    internal object m_keepalive;
    internal Void* m_sig;
    internal int m_managedCallingConventionAndArgIteratorFlags;
    internal int m_nSizeOfArgStack;
    internal int m_csig;
    internal RuntimeMethodHandleInternal m_pMethod;
    internal CallingConventions CallingConvention { get; }
    internal RuntimeType[] Arguments { get; }
    internal RuntimeType ReturnType { get; }
    internal RuntimeType FieldType { get; }
    public Signature(IRuntimeMethodInfo method, RuntimeType[] arguments, RuntimeType returnType, CallingConventions callingConvention);
    public Signature(IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    public Signature(IRuntimeFieldInfo fieldHandle, RuntimeType declaringType);
    public Signature(Void* pCorSig, int cCorSig, RuntimeType declaringType);
    private void GetSignature(Void* pCorSig, int cCorSig, RuntimeFieldHandleInternal fieldHandle, IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    internal CallingConventions get_CallingConvention();
    internal RuntimeType[] get_Arguments();
    internal RuntimeType get_ReturnType();
    internal RuntimeType get_FieldType();
    internal static bool CompareSig(Signature sig1, Signature sig2);
    internal Type[] GetCustomModifiers(int position, bool required);
}
public class System.Single : ValueType {
    internal float m_value;
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    internal static float NegativeZero;
    private static Single();
    [NonVersionableAttribute]
public static bool IsInfinity(float f);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNaN(float f);
    internal static bool IsNegative(float f);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    [NonVersionableAttribute]
public static bool op_Equality(float left, float right);
    [NonVersionableAttribute]
public static bool op_Inequality(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(float left, float right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, IFormatProvider provider);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    private static float Parse(string s, NumberStyles style, NumberFormatInfo info);
    public static bool TryParse(string s, Single& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    private static bool TryParse(string s, NumberStyles style, NumberFormatInfo info, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[ExtensionAttribute]
public static class System.Span : object {
    [ExtensionAttribute]
public static Span`1<byte> AsBytes(Span`1<T> source);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> source);
    [ExtensionAttribute]
public static Span`1<TTo> NonPortableCast(Span`1<TFrom> source);
    [ExtensionAttribute]
public static ReadOnlySpan`1<TTo> NonPortableCast(ReadOnlySpan`1<TFrom> source);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    internal static void CopyTo(T& destination, T& source, int elementsCount);
    internal static void ClearWithoutReferences(Byte& b, ulong byteLength);
    internal static void ClearWithReferences(IntPtr& ip, ulong pointerSizeLength);
}
[DefaultMemberAttribute("Item")]
public class System.Span`1 : ValueType {
    private ByReference`1<T> _pointer;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public T& Item { get; }
    public static Span`1<T> Empty { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start);
    public Span`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(T& ptr, int length);
    public static Span`1<T> DangerousCreate(object obj, T& objectData, int length);
    public T& DangerousGetPinnableReference();
    public int get_Length();
    public bool get_IsEmpty();
    public T& get_Item(int index);
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> arraySegment);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    public static Span`1<T> get_Empty();
}
internal static class System.SR : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool _resourceManagerInited;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; private set; }
    internal static string Acc_CreateAbst { get; }
    internal static string Acc_CreateAbstEx { get; }
    internal static string Acc_CreateArgIterator { get; }
    internal static string Acc_CreateGeneric { get; }
    internal static string Acc_CreateGenericEx { get; }
    internal static string Acc_CreateInterface { get; }
    internal static string Acc_CreateInterfaceEx { get; }
    internal static string Acc_CreateVoid { get; }
    internal static string Acc_NotClassInit { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string Acc_RvaStatic { get; }
    internal static string Access_Void { get; }
    internal static string AggregateException_ctor_DefaultMessage { get; }
    internal static string AggregateException_ctor_InnerExceptionNull { get; }
    internal static string AggregateException_DeserializationFailure { get; }
    internal static string AggregateException_ToString { get; }
    internal static string AppDomain_AppBaseNotSet { get; }
    internal static string Arg_AccessException { get; }
    internal static string Arg_AccessViolationException { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string Arg_AppDomainUnloadedException { get; }
    internal static string Arg_ApplicationException { get; }
    internal static string Arg_ArgumentException { get; }
    internal static string Arg_ArgumentOutOfRangeException { get; }
    internal static string Arg_ArithmeticException { get; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_ArrayTypeMismatchException { get; }
    internal static string Arg_ArrayZeroError { get; }
    internal static string Arg_BadDecimal { get; }
    internal static string Arg_BadImageFormatException { get; }
    internal static string Arg_BadLiteralFormat { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string Arg_CannotBeNaN { get; }
    internal static string Arg_CannotHaveNegativeValue { get; }
    internal static string Arg_CATypeResolutionFailed { get; }
    internal static string Arg_COMAccess { get; }
    internal static string Arg_COMException { get; }
    internal static string Arg_COMPropSetPut { get; }
    internal static string Arg_CreatInstAccess { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_CustomAttributeFormatException { get; }
    internal static string Arg_DataMisalignedException { get; }
    internal static string Arg_DateTimeRange { get; }
    internal static string Arg_DecBitCtor { get; }
    internal static string Arg_DirectoryNotFoundException { get; }
    internal static string Arg_DivideByZero { get; }
    internal static string Arg_DlgtNullInst { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_DlgtTypeMis { get; }
    internal static string Arg_DllNotFoundException { get; }
    internal static string Arg_DriveNotFoundException { get; }
    internal static string Arg_DuplicateWaitObjectException { get; }
    internal static string Arg_EHClauseNotClause { get; }
    internal static string Arg_EHClauseNotFilter { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EndOfStreamException { get; }
    internal static string Arg_EntryPointNotFoundException { get; }
    internal static string Arg_EnumAndObjectMustBeSameType { get; }
    internal static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_EnumLitValueNotFound { get; }
    internal static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumValueNotFound { get; }
    internal static string Arg_ExecutionEngineException { get; }
    internal static string Arg_ExternalException { get; }
    internal static string Arg_FieldAccessException { get; }
    internal static string Arg_FieldDeclTarget { get; }
    internal static string Arg_FldGetArgErr { get; }
    internal static string Arg_FldGetPropSet { get; }
    internal static string Arg_FldSetArgErr { get; }
    internal static string Arg_FldSetGet { get; }
    internal static string Arg_FldSetInvoke { get; }
    internal static string Arg_FldSetPropGet { get; }
    internal static string Arg_FormatException { get; }
    internal static string Arg_GenericParameter { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_GuidArrayCtor { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string Arg_HandleNotSync { get; }
    internal static string Arg_HexStyleNotSupported { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_IndexMustBeInt { get; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_InsufficientExecutionStackException { get; }
    internal static string Arg_InvalidANSIString { get; }
    internal static string Arg_InvalidBase { get; }
    internal static string Arg_InvalidCastException { get; }
    internal static string Arg_InvalidComObjectException { get; }
    internal static string Arg_InvalidFilterCriteriaException { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidHexStyle { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc { get; }
    internal static string Arg_InvalidOleVariantTypeException { get; }
    internal static string Arg_InvalidOperationException { get; }
    internal static string Arg_InvalidSearchPattern { get; }
    internal static string Arg_InvalidTypeInRetType { get; }
    internal static string Arg_InvalidTypeInSignature { get; }
    internal static string Arg_InvalidUTF8String { get; }
    internal static string Arg_IOException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_LongerThanDestArray { get; }
    internal static string Arg_LongerThanSrcArray { get; }
    internal static string Arg_LongerThanSrcString { get; }
    internal static string Arg_LowerBoundsMustMatch { get; }
    internal static string Arg_MarshalAsAnyRestriction { get; }
    internal static string Arg_MarshalDirectiveException { get; }
    internal static string Arg_MethodAccessException { get; }
    internal static string Arg_MethodAccessException_WithMethodName { get; }
    internal static string Arg_MissingFieldException { get; }
    internal static string Arg_MissingManifestResourceException { get; }
    internal static string Arg_MissingMemberException { get; }
    internal static string Arg_MissingMethodException { get; }
    internal static string Arg_MulticastNotSupportedException { get; }
    internal static string Arg_MustBeBoolean { get; }
    internal static string Arg_MustBeByte { get; }
    internal static string Arg_MustBeChar { get; }
    internal static string Arg_MustBeDateTime { get; }
    internal static string Arg_MustBeDateTimeOffset { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeDelegate { get; }
    internal static string Arg_MustBeDouble { get; }
    internal static string Arg_MustBeEnum { get; }
    internal static string Arg_MustBeEnumBaseTypeOrEnum { get; }
    internal static string Arg_MustBeGuid { get; }
    internal static string Arg_MustBeInt16 { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeInt64 { get; }
    internal static string Arg_MustBeInterface { get; }
    internal static string Arg_MustBePointer { get; }
    internal static string Arg_MustBePrimArray { get; }
    internal static string Arg_MustBeSByte { get; }
    internal static string Arg_MustBeSingle { get; }
    internal static string Arg_MustBeStatic { get; }
    internal static string Arg_MustBeString { get; }
    internal static string Arg_MustBeStringPtrNotAtom { get; }
    internal static string Arg_MustBeTimeSpan { get; }
    internal static string Arg_MustBeType { get; }
    internal static string Arg_MustBeUInt16 { get; }
    internal static string Arg_MustBeUInt32 { get; }
    internal static string Arg_MustBeUInt64 { get; }
    internal static string Arg_MustBeVersion { get; }
    internal static string Arg_MustContainEnumInfo { get; }
    internal static string Arg_NamedParamNull { get; }
    internal static string Arg_NamedParamTooBig { get; }
    internal static string Arg_NDirectBadObject { get; }
    internal static string Arg_Need1DArray { get; }
    internal static string Arg_Need2DArray { get; }
    internal static string Arg_Need3DArray { get; }
    internal static string Arg_NeedAtLeast1Rank { get; }
    internal static string Arg_NegativeArgCount { get; }
    internal static string Arg_NoAccessSpec { get; }
    internal static string Arg_NoDefCTor { get; }
    internal static string Arg_NoITypeInfo { get; }
    internal static string Arg_NoITypeLib { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_NoStaticVirtual { get; }
    internal static string Arg_NotFiniteNumberException { get; }
    internal static string Arg_NotFoundIFace { get; }
    internal static string Arg_NotGenericMethodDefinition { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_NotGenericTypeDefinition { get; }
    internal static string Arg_NotImplementedException { get; }
    internal static string Arg_NotSupportedException { get; }
    internal static string Arg_NullIndex { get; }
    internal static string Arg_NullReferenceException { get; }
    internal static string Arg_ObjObj { get; }
    internal static string Arg_ObjObjEx { get; }
    internal static string Arg_OleAutDateInvalid { get; }
    internal static string Arg_OleAutDateScale { get; }
    internal static string Arg_OverflowException { get; }
    internal static string Arg_ParamName_Name { get; }
    internal static string Arg_ParmArraySize { get; }
    internal static string Arg_ParmCnt { get; }
    internal static string Arg_PathIllegal { get; }
    internal static string Arg_PathIllegalUNC { get; }
    internal static string Arg_PlatformNotSupported { get; }
    internal static string Arg_PrimWiden { get; }
    internal static string Arg_PropSetGet { get; }
    internal static string Arg_PropSetInvoke { get; }
    internal static string Arg_RankException { get; }
    internal static string Arg_RankIndices { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_RanksAndBounds { get; }
    internal static string Arg_ReflectionOnlyCA { get; }
    internal static string Arg_ReflectionOnlyField { get; }
    internal static string Arg_ReflectionOnlyInvoke { get; }
    internal static string Arg_RegBadKeyKind { get; }
    internal static string Arg_RegGetOverflowBug { get; }
    internal static string Arg_RegInvalidKeyName { get; }
    internal static string Arg_RegKeyNotFound { get; }
    internal static string Arg_RegKeyStrLenBug { get; }
    internal static string Arg_RegSetBadArrType { get; }
    internal static string Arg_RegSetMismatchedKind { get; }
    internal static string Arg_RegSetStrArrNull { get; }
    internal static string Arg_RegSubKeyValueAbsent { get; }
    internal static string Arg_RegValStrLenBug { get; }
    internal static string Arg_RemoveArgNotFound { get; }
    internal static string Arg_ResMgrNotResSet { get; }
    internal static string Arg_ResourceFileUnsupportedVersion { get; }
    internal static string Arg_ResourceNameNotExist { get; }
    internal static string Arg_SafeArrayRankMismatchException { get; }
    internal static string Arg_SafeArrayTypeMismatchException { get; }
    internal static string Arg_SecurityException { get; }
    internal static string SerializationException { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_StackOverflowException { get; }
    internal static string Arg_SurrogatesNotAllowedAsSingleChar { get; }
    internal static string Arg_SynchronizationLockException { get; }
    internal static string Arg_SystemException { get; }
    internal static string Arg_TargetInvocationException { get; }
    internal static string Arg_TargetParameterCountException { get; }
    internal static string Arg_ThreadStartException { get; }
    internal static string Arg_ThreadStateException { get; }
    internal static string Arg_TimeoutException { get; }
    internal static string Arg_TypeAccessException { get; }
    internal static string Arg_TypedReference_Null { get; }
    internal static string Arg_TypeLoadException { get; }
    internal static string Arg_TypeLoadNullStr { get; }
    internal static string Arg_TypeRefPrimitve { get; }
    internal static string Arg_TypeUnloadedException { get; }
    internal static string Arg_UnauthorizedAccessException { get; }
    internal static string Arg_UnboundGenField { get; }
    internal static string Arg_UnboundGenParam { get; }
    internal static string Arg_UnknownTypeCode { get; }
    internal static string Arg_VarMissNull { get; }
    internal static string Arg_VersionString { get; }
    internal static string Arg_WrongAsyncResult { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AbsolutePathRequired { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_AdjustmentRulesNoNulls { get; }
    internal static string Argument_AdjustmentRulesOutOfOrder { get; }
    internal static string Argument_AlreadyACCW { get; }
    internal static string Argument_AlreadyBoundOrSyncHandle { get; }
    internal static string Argument_ArgumentZero { get; }
    internal static string Argument_ArrayGetInterfaceMap { get; }
    internal static string Argument_ArraysInvalid { get; }
    internal static string Argument_BadAttributeOnInterfaceMethod { get; }
    internal static string Argument_BadConstantValue { get; }
    internal static string Argument_BadConstructor { get; }
    internal static string Argument_BadConstructorCallConv { get; }
    internal static string Argument_BadExceptionCodeGen { get; }
    internal static string Argument_BadFieldForConstructorBuilder { get; }
    internal static string Argument_BadFieldSig { get; }
    internal static string Argument_BadFieldType { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_BadImageFormatExceptionResolve { get; }
    internal static string Argument_BadLabel { get; }
    internal static string Argument_BadLabelContent { get; }
    internal static string Argument_BadNestedTypeFlags { get; }
    internal static string Argument_BadObjRef { get; }
    internal static string Argument_BadParameterCountsForConstructor { get; }
    internal static string Argument_BadParameterTypeForCAB { get; }
    internal static string Argument_BadPropertyForConstructorBuilder { get; }
    internal static string Argument_BadSigFormat { get; }
    internal static string Argument_BadSizeForData { get; }
    internal static string Argument_BadTypeAttrInvalidLayout { get; }
    internal static string Argument_BadTypeAttrNestedVisibilityOnNonNestedType { get; }
    internal static string Argument_BadTypeAttrNonNestedVisibilityNestedType { get; }
    internal static string Argument_BadTypeAttrReservedBitsSet { get; }
    internal static string Argument_BadTypeInCustomAttribute { get; }
    internal static string Argument_CannotCreateTypedReference { get; }
    internal static string Argument_CannotGetTypeTokenForByRef { get; }
    internal static string Argument_CannotSetParentToInterface { get; }
    internal static string Argument_CantCallSecObjFunc { get; }
    internal static string Argument_CodepageNotSupported { get; }
    internal static string Argument_CompareOptionOrdinal { get; }
    internal static string Argument_ConflictingDateTimeRoundtripStyles { get; }
    internal static string Argument_ConflictingDateTimeStyles { get; }
    internal static string Argument_ConstantDoesntMatch { get; }
    internal static string Argument_ConstantNotSupported { get; }
    internal static string Argument_ConstantNull { get; }
    internal static string Argument_ConstructorNeedGenericDeclaringType { get; }
    internal static string Argument_ConversionOverflow { get; }
    internal static string Argument_ConvertMismatch { get; }
    internal static string Argument_CORDBBadMethod { get; }
    internal static string Argument_CORDBBadVarArgCallConv { get; }
    internal static string Argument_CultureIetfNotSupported { get; }
    internal static string Argument_CultureInvalidIdentifier { get; }
    internal static string Argument_CultureIsNeutral { get; }
    internal static string Argument_CultureNotSupported { get; }
    internal static string Argument_CustomAssemblyLoadContextRequestedNameMismatch { get; }
    internal static string Argument_CustomCultureCannotBePassedByNumber { get; }
    internal static string Argument_DateTimeBadBinaryData { get; }
    internal static string Argument_DateTimeHasTicks { get; }
    internal static string Argument_DateTimeHasTimeOfDay { get; }
    internal static string Argument_DateTimeIsInvalid { get; }
    internal static string Argument_DateTimeIsNotAmbiguous { get; }
    internal static string Argument_DateTimeKindMustBeUnspecified { get; }
    internal static string Argument_DateTimeKindMustBeUnspecifiedOrUtc { get; }
    internal static string Argument_DateTimeOffsetInvalidDateTimeStyles { get; }
    internal static string Argument_DateTimeOffsetIsNotAmbiguous { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_DuplicateTypeName { get; }
    internal static string Argument_EmitWriteLineType { get; }
    internal static string Argument_EmptyDecString { get; }
    internal static string Argument_EmptyFileName { get; }
    internal static string Argument_EmptyName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_EmptyWaithandleArray { get; }
    internal static string Argument_EncoderFallbackNotEmpty { get; }
    internal static string Argument_EncodingConversionOverflowBytes { get; }
    internal static string Argument_EncodingConversionOverflowChars { get; }
    internal static string Argument_EncodingNotSupported { get; }
    internal static string Argument_EnumTypeDoesNotMatch { get; }
    internal static string Argument_FallbackBufferNotEmpty { get; }
    internal static string Argument_FieldDeclaringTypeGeneric { get; }
    internal static string Argument_FieldNeedGenericDeclaringType { get; }
    internal static string Argument_GenConstraintViolation { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_GenericsInvalid { get; }
    internal static string Argument_GlobalFunctionHasToBeStatic { get; }
    internal static string Argument_HandleLeak { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string Argument_IdnBadBidi { get; }
    internal static string Argument_IdnBadLabelSize { get; }
    internal static string Argument_IdnBadNameSize { get; }
    internal static string Argument_IdnBadPunycode { get; }
    internal static string Argument_IdnBadStd3 { get; }
    internal static string Argument_IdnIllegalName { get; }
    internal static string Argument_IllegalEnvVarName { get; }
    internal static string Argument_IllegalName { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string Argument_IndexOutOfArrayBounds { get; }
    internal static string Argument_InsufficientSpaceToCopyCollection { get; }
    internal static string Argument_InterfaceMap { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string Argument_InvalidArgumentForComparison { get; }
    internal static string Argument_InvalidArrayLength { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string Argument_InvalidAssemblyName { get; }
    internal static string Argument_InvalidCalendar { get; }
    internal static string Argument_InvalidCharSequence { get; }
    internal static string Argument_InvalidCharSequenceNoIndex { get; }
    internal static string Argument_InvalidCodePageBytesIndex { get; }
    internal static string Argument_InvalidCodePageConversionIndex { get; }
    internal static string Argument_InvalidConstructorDeclaringType { get; }
    internal static string Argument_InvalidConstructorInfo { get; }
    internal static string Argument_InvalidCultureName { get; }
    internal static string Argument_InvalidDateTimeKind { get; }
    internal static string Argument_InvalidDateTimeStyles { get; }
    internal static string Argument_InvalidDigitSubstitution { get; }
    internal static string Argument_InvalidEnum { get; }
    internal static string Argument_InvalidEnumValue { get; }
    internal static string Argument_InvalidFieldDeclaringType { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidGenericArg { get; }
    internal static string Argument_InvalidGenericInstArray { get; }
    internal static string Argument_InvalidGroupSize { get; }
    internal static string Argument_InvalidHandle { get; }
    internal static string Argument_InvalidHighSurrogate { get; }
    internal static string Argument_InvalidId { get; }
    internal static string Argument_InvalidKindOfTypeForCA { get; }
    internal static string Argument_InvalidLabel { get; }
    internal static string Argument_InvalidLowSurrogate { get; }
    internal static string Argument_InvalidMemberForNamedArgument { get; }
    internal static string Argument_InvalidMethodDeclaringType { get; }
    internal static string Argument_InvalidName { get; }
    internal static string Argument_InvalidNativeDigitCount { get; }
    internal static string Argument_InvalidNativeDigitValue { get; }
    internal static string Argument_InvalidNeutralRegionName { get; }
    internal static string Argument_InvalidNormalizationForm { get; }
    internal static string Argument_InvalidNumberStyles { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOpCodeOnDynamicMethod { get; }
    internal static string Argument_InvalidParameterInfo { get; }
    internal static string Argument_InvalidParamInfo { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidREG_TZI_FORMAT { get; }
    internal static string Argument_InvalidRegistryViewCheck { get; }
    internal static string Argument_InvalidResourceCultureName { get; }
    internal static string Argument_InvalidSafeBufferOffLen { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSerializedString { get; }
    internal static string Argument_InvalidTimeSpanStyles { get; }
    internal static string Argument_InvalidToken { get; }
    internal static string Argument_InvalidTypeForCA { get; }
    internal static string Argument_InvalidTypeForDynamicMethod { get; }
    internal static string Argument_InvalidTypeName { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_InvalidUnity { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string Argument_LargeInteger { get; }
    internal static string Argument_LongEnvVarValue { get; }
    internal static string Argument_MethodDeclaringTypeGeneric { get; }
    internal static string Argument_MethodDeclaringTypeGenericLcg { get; }
    internal static string Argument_MethodNeedGenericDeclaringType { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string Argument_MismatchedArrays { get; }
    internal static string Argument_MissingDefaultConstructor { get; }
    internal static string Argument_MustBeFalse { get; }
    internal static string Argument_MustBeRuntimeAssembly { get; }
    internal static string Argument_MustBeRuntimeFieldInfo { get; }
    internal static string Argument_MustBeRuntimeMethodInfo { get; }
    internal static string Argument_MustBeRuntimeModule { get; }
    internal static string Argument_MustBeRuntimeReflectionObject { get; }
    internal static string Argument_MustBeRuntimeType { get; }
    internal static string Argument_MustBeTypeBuilder { get; }
    internal static string Argument_MustHaveAttributeBaseClass { get; }
    internal static string Argument_MustHaveLayoutOrBeBlittable { get; }
    internal static string Argument_NativeOverlappedAlreadyFree { get; }
    internal static string Argument_NativeOverlappedWrongBoundHandle { get; }
    internal static string Argument_NeedGenericMethodDefinition { get; }
    internal static string Argument_NeedNonGenericObject { get; }
    internal static string Argument_NeedNonGenericType { get; }
    internal static string Argument_NeedStructWithNoRefs { get; }
    internal static string Argument_NeverValidGenericArgument { get; }
    internal static string Argument_NoDomainManager { get; }
    internal static string Argument_NoEra { get; }
    internal static string Argument_NoModuleFileExtension { get; }
    internal static string Argument_NoRegionInvariantCulture { get; }
    internal static string Argument_NotATP { get; }
    internal static string Argument_NotAWritableProperty { get; }
    internal static string Argument_NotEnoughBytesToRead { get; }
    internal static string Argument_NotEnoughBytesToWrite { get; }
    internal static string Argument_NotEnoughGenArguments { get; }
    internal static string Argument_NotExceptionType { get; }
    internal static string Argument_NotInExceptionBlock { get; }
    internal static string Argument_NotMethodCallOpcode { get; }
    internal static string Argument_NotSerializable { get; }
    internal static string Argument_NoUnderlyingCCW { get; }
    internal static string Argument_NoUninitializedStrings { get; }
    internal static string Argument_ObjIsWinRTObject { get; }
    internal static string Argument_ObjNotComObject { get; }
    internal static string Argument_OffsetAndCapacityOutOfBounds { get; }
    internal static string Argument_OffsetAndLengthOutOfBounds { get; }
    internal static string Argument_OffsetLocalMismatch { get; }
    internal static string Argument_OffsetOfFieldNotFound { get; }
    internal static string Argument_OffsetOutOfRange { get; }
    internal static string Argument_OffsetPrecision { get; }
    internal static string Argument_OffsetUtcMismatch { get; }
    internal static string Argument_OneOfCulturesNotSupported { get; }
    internal static string Argument_OnlyMscorlib { get; }
    internal static string Argument_OutOfOrderDateTimes { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string Argument_PathFormatNotSupported { get; }
    internal static string Argument_PreAllocatedAlreadyAllocated { get; }
    internal static string Argument_RecursiveFallback { get; }
    internal static string Argument_RecursiveFallbackBytes { get; }
    internal static string Argument_RedefinedLabel { get; }
    internal static string Argument_ResolveField { get; }
    internal static string Argument_ResolveFieldHandle { get; }
    internal static string Argument_ResolveMember { get; }
    internal static string Argument_ResolveMethod { get; }
    internal static string Argument_ResolveMethodHandle { get; }
    internal static string Argument_ResolveModuleType { get; }
    internal static string Argument_ResolveString { get; }
    internal static string Argument_ResolveType { get; }
    internal static string Argument_ResultCalendarRange { get; }
    internal static string Argument_SemaphoreInitialMaximum { get; }
    internal static string Argument_ShouldNotSpecifyExceptionType { get; }
    internal static string Argument_ShouldOnlySetVisibilityFlags { get; }
    internal static string Argument_SigIsFinalized { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Argument_StringFirstCharIsZero { get; }
    internal static string Argument_StringZeroLength { get; }
    internal static string Argument_StructMustNotBeValueClass { get; }
    internal static string Argument_TimeSpanHasSeconds { get; }
    internal static string Argument_TimeZoneInfoBadTZif { get; }
    internal static string Argument_TimeZoneInfoInvalidTZif { get; }
    internal static string Argument_ToExclusiveLessThanFromExclusive { get; }
    internal static string Argument_TooManyFinallyClause { get; }
    internal static string Argument_TransitionTimesAreIdentical { get; }
    internal static string Argument_TypedReferenceInvalidField { get; }
    internal static string Argument_TypeIsWinRTType { get; }
    internal static string Argument_TypeMustBeVisibleFromCom { get; }
    internal static string Argument_TypeMustNotBeComImport { get; }
    internal static string Argument_TypeNameTooLong { get; }
    internal static string Argument_TypeNotActivatableViaWindowsRuntime { get; }
    internal static string Argument_TypeNotComObject { get; }
    internal static string Argument_TypeNotValid { get; }
    internal static string Argument_UnclosedExceptionBlock { get; }
    internal static string Argument_Unexpected_TypeSource { get; }
    internal static string Argument_UnknownUnmanagedCallConv { get; }
    internal static string Argument_UnmanagedMemAccessorWrapAround { get; }
    internal static string Argument_UnmatchedMethodForLocal { get; }
    internal static string Argument_UnmatchingSymScope { get; }
    internal static string Argument_UnrecognizedLoaderOptimization { get; }
    internal static string Argument_UTCOutOfRange { get; }
    internal static string Argument_VerStringTooLong { get; }
    internal static string Argument_WaitHandleNameTooLong { get; }
    internal static string Argument_WinRTSystemRuntimeType { get; }
    internal static string ArgumentException_BadMethodImplBody { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string ArgumentException_TupleIncorrectType { get; }
    internal static string ArgumentException_TupleLastArgumentNotATuple { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    internal static string ArgumentNull_Array { get; }
    internal static string ArgumentNull_ArrayElement { get; }
    internal static string ArgumentNull_ArrayValue { get; }
    internal static string ArgumentNull_Assembly { get; }
    internal static string ArgumentNull_AssemblyName { get; }
    internal static string ArgumentNull_AssemblyNameName { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentNull_Collection { get; }
    internal static string ArgumentNull_FileName { get; }
    internal static string ArgumentNull_Generic { get; }
    internal static string ArgumentNull_GUID { get; }
    internal static string ArgumentNull_Key { get; }
    internal static string ArgumentNull_Obj { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentNull_SafeHandle { get; }
    internal static string ArgumentNull_Stream { get; }
    internal static string ArgumentNull_String { get; }
    internal static string ArgumentNull_Type { get; }
    internal static string ArgumentNull_TypedRefType { get; }
    internal static string ArgumentNull_Waithandles { get; }
    internal static string ArgumentNull_WithParamName { get; }
    internal static string ArgumentOutOfRange_ActualValue { get; }
    internal static string ArgumentOutOfRange_AddressSpace { get; }
    internal static string ArgumentOutOfRange_AddValue { get; }
    internal static string ArgumentOutOfRange_ArrayLB { get; }
    internal static string ArgumentOutOfRange_ArrayLBAndLength { get; }
    internal static string ArgumentOutOfRange_ArrayListInsert { get; }
    internal static string ArgumentOutOfRange_BadHourMinuteSecond { get; }
    internal static string ArgumentOutOfRange_BadYearMonthDay { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_BinaryReaderFillBuffer { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper { get; }
    internal static string ArgumentOutOfRange_CalendarRange { get; }
    internal static string ArgumentOutOfRange_Capacity { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_DateArithmetic { get; }
    internal static string ArgumentOutOfRange_DateTimeBadMonths { get; }
    internal static string ArgumentOutOfRange_DateTimeBadTicks { get; }
    internal static string ArgumentOutOfRange_DateTimeBadYears { get; }
    internal static string ArgumentOutOfRange_Day { get; }
    internal static string ArgumentOutOfRange_DayOfWeek { get; }
    internal static string ArgumentOutOfRange_DayParam { get; }
    internal static string ArgumentOutOfRange_DecimalRound { get; }
    internal static string ArgumentOutOfRange_DecimalScale { get; }
    internal static string ArgumentOutOfRange_EndIndexStartIndex { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_Era { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string ArgumentOutOfRange_FileTimeInvalid { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_GetByteCountOverflow { get; }
    internal static string ArgumentOutOfRange_GetCharCountOverflow { get; }
    internal static string ArgumentOutOfRange_HashtableLoadFactor { get; }
    internal static string ArgumentOutOfRange_HugeArrayNotSupported { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_IndexCount { get; }
    internal static string ArgumentOutOfRange_IndexCountBuffer { get; }
    internal static string ArgumentOutOfRange_IndexLargerThanMaxValue { get; }
    internal static string ArgumentOutOfRange_IndexLength { get; }
    internal static string ArgumentOutOfRange_IndexString { get; }
    internal static string ArgumentOutOfRange_InvalidEraValue { get; }
    internal static string ArgumentOutOfRange_InvalidHighSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidLowSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidUTF32 { get; }
    internal static string ArgumentOutOfRange_Length { get; }
    internal static string ArgumentOutOfRange_LengthGreaterThanCapacity { get; }
    internal static string ArgumentOutOfRange_LengthTooLarge { get; }
    internal static string ArgumentOutOfRange_LessEqualToIntegerMaxVal { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_Month { get; }
    internal static string ArgumentOutOfRange_MonthParam { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegInt32 { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string ArgumentOutOfRange_NegativeCapacity { get; }
    internal static string ArgumentOutOfRange_NegativeCount { get; }
    internal static string ArgumentOutOfRange_NegativeLength { get; }
    internal static string ArgumentOutOfRange_OffsetLength { get; }
    internal static string ArgumentOutOfRange_OffsetOut { get; }
    internal static string ArgumentOutOfRange_ParamSequence { get; }
    internal static string ArgumentOutOfRange_PartialWCHAR { get; }
    internal static string ArgumentOutOfRange_PeriodTooLarge { get; }
    internal static string ArgumentOutOfRange_PositionLessThanCapacityRequired { get; }
    internal static string ArgumentOutOfRange_Range { get; }
    internal static string ArgumentOutOfRange_RoundingDigits { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string ArgumentOutOfRange_SmallMaxCapacity { get; }
    internal static string ArgumentOutOfRange_StartIndex { get; }
    internal static string ArgumentOutOfRange_StartIndexLargerThanLength { get; }
    internal static string ArgumentOutOfRange_StartIndexLessThanLength { get; }
    internal static string ArgumentOutOfRange_StreamLength { get; }
    internal static string ArgumentOutOfRange_TimeoutTooLarge { get; }
    internal static string ArgumentOutOfRange_UIntPtrMax { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamLength { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround { get; }
    internal static string ArgumentOutOfRange_UtcOffset { get; }
    internal static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta { get; }
    internal static string ArgumentOutOfRange_Version { get; }
    internal static string ArgumentOutOfRange_Week { get; }
    internal static string ArgumentOutOfRange_Year { get; }
    internal static string Arithmetic_NaN { get; }
    internal static string ArrayTypeMismatch_CantAssignType { get; }
    internal static string ArrayTypeMismatch_ConstrainedCopy { get; }
    internal static string Arugment_EmitMixedContext1 { get; }
    internal static string Arugment_EmitMixedContext2 { get; }
    internal static string AssertionFailed { get; }
    internal static string AssertionFailed_Cnd { get; }
    internal static string AssumptionFailed { get; }
    internal static string AssumptionFailed_Cnd { get; }
    internal static string AsyncMethodBuilder_InstanceNotInitialized { get; }
    internal static string BadImageFormat_BadILFormat { get; }
    internal static string BadImageFormat_InvalidType { get; }
    internal static string BadImageFormat_NegativeStringLength { get; }
    internal static string BadImageFormat_ParameterSignatureMismatch { get; }
    internal static string BadImageFormat_ResourceDataLengthInvalid { get; }
    internal static string BadImageFormat_ResourceNameCorrupted { get; }
    internal static string BadImageFormat_ResourceNameCorrupted_NameIndex { get; }
    internal static string BadImageFormat_ResourcesDataInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesHeaderCorrupted { get; }
    internal static string BadImageFormat_ResourcesIndexTooLong { get; }
    internal static string BadImageFormat_ResourcesNameInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesNameTooLong { get; }
    internal static string BadImageFormat_TypeMismatch { get; }
    internal static string CancellationToken_CreateLinkedToken_TokensIsEmpty { get; }
    internal static string CancellationToken_SourceDisposed { get; }
    internal static string CancellationTokenSource_Disposed { get; }
    internal static string ConcurrentCollection_SyncRoot_NotSupported { get; }
    internal static string ConcurrentDictionary_ArrayIncorrectType { get; }
    internal static string ConcurrentDictionary_ArrayNotLargeEnough { get; }
    internal static string ConcurrentDictionary_CapacityMustNotBeNegative { get; }
    internal static string ConcurrentDictionary_ConcurrencyLevelMustBePositive { get; }
    internal static string ConcurrentDictionary_IndexIsNegative { get; }
    internal static string ConcurrentDictionary_ItemKeyIsNull { get; }
    internal static string ConcurrentDictionary_KeyAlreadyExisted { get; }
    internal static string ConcurrentDictionary_TypeOfKeyIncorrect { get; }
    internal static string ConcurrentDictionary_TypeOfValueIncorrect { get; }
    internal static string event_Barrier_PhaseFinished { get; }
    internal static string event_ConcurrentBag_TryPeekSteals { get; }
    internal static string event_ConcurrentBag_TryTakeSteals { get; }
    internal static string event_ConcurrentDictionary_AcquiringAllLocks { get; }
    internal static string event_ConcurrentStack_FastPopFailed { get; }
    internal static string event_ConcurrentStack_FastPushFailed { get; }
    internal static string event_ParallelFork { get; }
    internal static string event_ParallelInvokeBegin { get; }
    internal static string event_ParallelInvokeEnd { get; }
    internal static string event_ParallelJoin { get; }
    internal static string event_ParallelLoopBegin { get; }
    internal static string event_ParallelLoopEnd { get; }
    internal static string event_SpinLock_FastPathFailed { get; }
    internal static string event_SpinWait_NextSpinWillYield { get; }
    internal static string event_TaskCompleted { get; }
    internal static string event_TaskScheduled { get; }
    internal static string event_TaskStarted { get; }
    internal static string event_TaskWaitBegin { get; }
    internal static string event_TaskWaitEnd { get; }
    internal static string EventSource_AbstractMustNotDeclareEventMethods { get; }
    internal static string EventSource_AbstractMustNotDeclareKTOC { get; }
    internal static string EventSource_AddScalarOutOfRange { get; }
    internal static string EventSource_ChannelTypeDoesNotMatchEventChannelValue { get; }
    internal static string EventSource_DataDescriptorsOutOfRange { get; }
    internal static string EventSource_DuplicateStringKey { get; }
    internal static string EventSource_EnumKindMismatch { get; }
    internal static string EventSource_EventChannelOutOfRange { get; }
    internal static string EventSource_EventIdReused { get; }
    internal static string EventSource_EventMustHaveTaskIfNonDefaultOpcode { get; }
    internal static string EventSource_EventMustNotBeExplicitImplementation { get; }
    internal static string EventSource_EventNameDoesNotEqualTaskPlusOpcode { get; }
    internal static string EventSource_EventNameReused { get; }
    internal static string EventSource_EventParametersMismatch { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_EventWithAdminChannelMustHaveMessage { get; }
    internal static string EventSource_IllegalKeywordsValue { get; }
    internal static string EventSource_IllegalOpcodeValue { get; }
    internal static string EventSource_IllegalTaskValue { get; }
    internal static string EventSource_IncorrentlyAuthoredTypeInfo { get; }
    internal static string EventSource_InvalidCommand { get; }
    internal static string EventSource_InvalidEventFormat { get; }
    internal static string EventSource_KeywordCollision { get; }
    internal static string EventSource_KeywordNeedPowerOfTwo { get; }
    internal static string EventSource_ListenerCreatedInsideCallback { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_MaxChannelExceeded { get; }
    internal static string EventSource_MismatchIdToWriteEvent { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedPositiveId { get; }
    internal static string EventSource_NoFreeBuffers { get; }
    internal static string EventSource_NonCompliantTypeError { get; }
    internal static string EventSource_NoRelatedActivityId { get; }
    internal static string EventSource_NotSupportedArrayOfBinary { get; }
    internal static string EventSource_NotSupportedArrayOfNil { get; }
    internal static string EventSource_NotSupportedArrayOfNullTerminatedString { get; }
    internal static string EventSource_NotSupportedCustomSerializedData { get; }
    internal static string EventSource_NotSupportedNestedArraysEnums { get; }
    internal static string EventSource_NullInput { get; }
    internal static string EventSource_OpcodeCollision { get; }
    internal static string EventSource_PinArrayOutOfRange { get; }
    internal static string EventSource_RecursiveTypeDefinition { get; }
    internal static string EventSource_SessionIdError { get; }
    internal static string EventSource_StopsFollowStarts { get; }
    internal static string EventSource_TaskCollision { get; }
    internal static string EventSource_TaskOpcodePairReused { get; }
    internal static string EventSource_TooManyArgs { get; }
    internal static string EventSource_TooManyFields { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_TypeMustBeSealedOrAbstract { get; }
    internal static string EventSource_TypeMustDeriveFromEventSource { get; }
    internal static string EventSource_UndefinedChannel { get; }
    internal static string EventSource_UndefinedKeyword { get; }
    internal static string EventSource_UndefinedOpcode { get; }
    internal static string EventSource_UnsupportedEventTypeInManifest { get; }
    internal static string EventSource_UnsupportedMessageProperty { get; }
    internal static string EventSource_VarArgsParameterMismatch { get; }
    internal static string Exception_EndOfInnerExceptionStack { get; }
    internal static string Exception_EndStackTraceFromPreviousThrow { get; }
    internal static string Exception_WasThrown { get; }
    internal static string ExecutionContext_ExceptionInAsyncLocalNotification { get; }
    internal static string FieldAccess_InitOnly { get; }
    internal static string FileNotFound_ResolveAssembly { get; }
    internal static string Format_AttributeUsage { get; }
    internal static string Format_Bad7BitInt32 { get; }
    internal static string Format_BadBase { get; }
    internal static string Format_BadBase64Char { get; }
    internal static string Format_BadBase64CharArrayLength { get; }
    internal static string Format_BadBoolean { get; }
    internal static string Format_BadDatePattern { get; }
    internal static string Format_BadDateTime { get; }
    internal static string Format_BadDateTimeCalendar { get; }
    internal static string Format_BadDayOfWeek { get; }
    internal static string Format_BadFormatSpecifier { get; }
    internal static string Format_BadQuote { get; }
    internal static string Format_BadTimeSpan { get; }
    internal static string Format_DateOutOfRange { get; }
    internal static string Format_EmptyInputString { get; }
    internal static string Format_ExtraJunkAtEnd { get; }
    internal static string Format_GuidBrace { get; }
    internal static string Format_GuidBraceAfterLastNumber { get; }
    internal static string Format_GuidComma { get; }
    internal static string Format_GuidDashes { get; }
    internal static string Format_GuidEndBrace { get; }
    internal static string Format_GuidHexPrefix { get; }
    internal static string Format_GuidInvalidChar { get; }
    internal static string Format_GuidInvLen { get; }
    internal static string Format_GuidUnrecognized { get; }
    internal static string Format_IndexOutOfRange { get; }
    internal static string Format_InvalidEnumFormatSpecification { get; }
    internal static string Format_InvalidGuidFormatSpecification { get; }
    internal static string Format_InvalidString { get; }
    internal static string Format_MissingIncompleteDate { get; }
    internal static string Format_NeedSingleChar { get; }
    internal static string Format_NoParsibleDigits { get; }
    internal static string Format_OffsetOutOfRange { get; }
    internal static string Format_RepeatDateTimePattern { get; }
    internal static string Format_StringZeroLength { get; }
    internal static string Format_UnknowDateTimeWord { get; }
    internal static string Format_UTCOutOfRange { get; }
    internal static string Globalization_cp_1200 { get; }
    internal static string Globalization_cp_12000 { get; }
    internal static string Globalization_cp_12001 { get; }
    internal static string Globalization_cp_1201 { get; }
    internal static string Globalization_cp_20127 { get; }
    internal static string Globalization_cp_28591 { get; }
    internal static string Globalization_cp_65000 { get; }
    internal static string Globalization_cp_65001 { get; }
    internal static string IndexOutOfRange_ArrayRankIndex { get; }
    internal static string IndexOutOfRange_IORaceCondition { get; }
    internal static string IndexOutOfRange_UMSPosition { get; }
    internal static string InsufficientMemory_MemFailPoint { get; }
    internal static string InsufficientMemory_MemFailPoint_TooBig { get; }
    internal static string InsufficientMemory_MemFailPoint_VAFrag { get; }
    internal static string Interop_COM_TypeMismatch { get; }
    internal static string Interop_Marshal_Unmappable_Char { get; }
    internal static string InvalidCast_CannotCastNullToValueType { get; }
    internal static string InvalidCast_CannotCoerceByRefVariant { get; }
    internal static string InvalidCast_DBNull { get; }
    internal static string InvalidCast_DownCastArrayElement { get; }
    internal static string InvalidCast_Empty { get; }
    internal static string InvalidCast_FromDBNull { get; }
    internal static string InvalidCast_FromTo { get; }
    internal static string InvalidCast_IConvertible { get; }
    internal static string InvalidCast_OATypeMismatch { get; }
    internal static string InvalidCast_StoreArrayElement { get; }
    internal static string InvalidCast_WinRTIPropertyValueArrayCoersion { get; }
    internal static string InvalidCast_WinRTIPropertyValueCoersion { get; }
    internal static string InvalidCast_WinRTIPropertyValueElement { get; }
    internal static string InvalidOperation_AsyncFlowCtrlCtxMismatch { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string InvalidOperation_BadEmptyMethodBody { get; }
    internal static string InvalidOperation_BadILGeneratorUsage { get; }
    internal static string InvalidOperation_BadInstructionOrIndexOutOfBound { get; }
    internal static string InvalidOperation_BadInterfaceNotAbstract { get; }
    internal static string InvalidOperation_BadMethodBody { get; }
    internal static string InvalidOperation_BadTypeAttributesNotAbstract { get; }
    internal static string InvalidOperation_CalledTwice { get; }
    internal static string InvalidOperation_CannotImportGlobalFromDifferentModule { get; }
    internal static string InvalidOperation_CannotRemoveLastFromEmptyCollection { get; }
    internal static string InvalidOperation_CannotRestoreUnsupressedFlow { get; }
    internal static string InvalidOperation_CannotSupressFlowMultipleTimes { get; }
    internal static string InvalidOperation_CannotUseAFCMultiple { get; }
    internal static string InvalidOperation_CannotUseAFCOtherThread { get; }
    internal static string InvalidOperation_CantInstantiateAbstractClass { get; }
    internal static string InvalidOperation_CantInstantiateFunctionPointer { get; }
    internal static string InvalidOperation_CollectionBackingDictionaryTooLarge { get; }
    internal static string InvalidOperation_CollectionBackingListTooLarge { get; }
    internal static string InvalidOperation_CollectionCorrupted { get; }
    internal static string InvalidOperation_ConstructorNotAllowedOnInterface { get; }
    internal static string InvalidOperation_CriticalTransparentAreMutuallyExclusive { get; }
    internal static string InvalidOperation_DateTimeParsing { get; }
    internal static string InvalidOperation_DebuggerLaunchFailed { get; }
    internal static string InvalidOperation_DefaultConstructorILGen { get; }
    internal static string InvalidOperation_EndReadCalledMultiple { get; }
    internal static string InvalidOperation_EndWriteCalledMultiple { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_EventInfoNotAvailable { get; }
    internal static string InvalidOperation_EventTokenTableRequiresDelegate { get; }
    internal static string InvalidOperation_GenericParametersAlreadySet { get; }
    internal static string InvalidOperation_GetVersion { get; }
    internal static string InvalidOperation_GlobalsHaveBeenCreated { get; }
    internal static string InvalidOperation_HandleIsNotInitialized { get; }
    internal static string InvalidOperation_HandleIsNotPinned { get; }
    internal static string InvalidOperation_HashInsertFailed { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string InvalidOperation_MethodBaked { get; }
    internal static string InvalidOperation_MethodBuilderBaked { get; }
    internal static string InvalidOperation_MethodHasBody { get; }
    internal static string InvalidOperation_MustCallInitialize { get; }
    internal static string InvalidOperation_NativeOverlappedReused { get; }
    internal static string InvalidOperation_NoMultiModuleAssembly { get; }
    internal static string InvalidOperation_NoPublicAddMethod { get; }
    internal static string InvalidOperation_NoPublicRemoveMethod { get; }
    internal static string InvalidOperation_NotADebugModule { get; }
    internal static string InvalidOperation_NotAllowedInDynamicMethod { get; }
    internal static string InvalidOperation_NotAllowedInReflectionOnly { get; }
    internal static string InvalidOperation_NotAVarArgCallingConvention { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string InvalidOperation_NotSupportedOnWinRTEvent { get; }
    internal static string InvalidOperation_NotWithConcurrentGC { get; }
    internal static string InvalidOperation_NoUnderlyingTypeOnEnum { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static string InvalidOperation_NullArray { get; }
    internal static string InvalidOperation_NullContext { get; }
    internal static string InvalidOperation_NullModuleHandle { get; }
    internal static string InvalidOperation_OpenLocalVariableScope { get; }
    internal static string InvalidOperation_Overlapped_Pack { get; }
    internal static string InvalidOperation_PropertyInfoNotAvailable { get; }
    internal static string InvalidOperation_ReadOnly { get; }
    internal static string InvalidOperation_ResMgrBadResSet_Type { get; }
    internal static string InvalidOperation_ResourceNotStream_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Type { get; }
    internal static string InvalidOperation_SetData_OnlyOnce { get; }
    internal static string InvalidOperation_ShouldNotHaveMethodBody { get; }
    internal static string InvalidOperation_StrongNameKeyPairRequired { get; }
    internal static string InvalidOperation_ThreadWrongThreadStart { get; }
    internal static string InvalidOperation_TimeoutsNotSupported { get; }
    internal static string InvalidOperation_TypeCannotBeBoxed { get; }
    internal static string InvalidOperation_TypeHasBeenCreated { get; }
    internal static string InvalidOperation_TypeNotCreated { get; }
    internal static string InvalidOperation_UnknownEnumType { get; }
    internal static string InvalidOperation_WriteOnce { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple { get; }
    internal static string InvalidProgram_Default { get; }
    internal static string InvalidTimeZone_InvalidFileData { get; }
    internal static string InvalidTimeZone_InvalidRegistryData { get; }
    internal static string InvalidTimeZone_JulianDayNotSupported { get; }
    internal static string InvalidTimeZone_NoTTInfoStructures { get; }
    internal static string InvalidTimeZone_UnparseablePosixMDateString { get; }
    internal static string InvariantFailed { get; }
    internal static string InvariantFailed_Cnd { get; }
    internal static string IO_DriveNotFound_Drive { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileLoad { get; }
    internal static string IO_FileName_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_BindHandleFailed { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileStreamHandlePosition { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_FileTooLongOrHandleNotSync { get; }
    internal static string IO_FixedCapacity { get; }
    internal static string IO_InvalidStringLen_Len { get; }
    internal static string IO_NoPermissionToDirectoryName { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_StreamTooLong { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string Lazy_CreateValue_NoParameterlessCtorForT { get; }
    internal static string Lazy_ctor_ModeInvalid { get; }
    internal static string Lazy_StaticInit_InvalidOperation { get; }
    internal static string Lazy_ToString_ValueNotCreated { get; }
    internal static string Lazy_Value_RecursiveCallsToValue { get; }
    internal static string Loader_ContextPolicies { get; }
    internal static string Loader_Name { get; }
    internal static string Loader_NoContextPolicies { get; }
    internal static string ManualResetEventSlim_ctor_SpinCountOutOfRange { get; }
    internal static string ManualResetEventSlim_ctor_TooManyWaiters { get; }
    internal static string ManualResetEventSlim_Disposed { get; }
    internal static string Marshaler_StringTooLong { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MissingField { get; }
    internal static string MissingField_Name { get; }
    internal static string MissingManifestResource_LooselyLinked { get; }
    internal static string MissingManifestResource_MultipleBlobs { get; }
    internal static string MissingManifestResource_NoNeutralAsm { get; }
    internal static string MissingManifestResource_NoNeutralDisk { get; }
    internal static string MissingManifestResource_NoPRIresources { get; }
    internal static string MissingManifestResource_ResWFileNotLoaded { get; }
    internal static string MissingMember { get; }
    internal static string MissingMember_Name { get; }
    internal static string MissingMemberNestErr { get; }
    internal static string MissingMemberTypeRef { get; }
    internal static string MissingMethod_Name { get; }
    internal static string MissingSatelliteAssembly_Culture_Name { get; }
    internal static string MissingSatelliteAssembly_Default { get; }
    internal static string Multicast_Combine { get; }
    internal static string MustUseCCRewrite { get; }
    internal static string NotImplemented_ResourcesLongerThanInt64Max { get; }
    internal static string NotSupported_AbstractNonCLS { get; }
    internal static string NotSupported_ActivAttr { get; }
    internal static string NotSupported_AppX { get; }
    internal static string NotSupported_AssemblyLoadFromHash { get; }
    internal static string NotSupported_ByRefLike { get; }
    internal static string NotSupported_ByRefLikeArray { get; }
    internal static string NotSupported_ByRefReturn { get; }
    internal static string NotSupported_CallToVarArg { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string NotSupported_ChangeType { get; }
    internal static string NotSupported_CollectibleAssemblyResolve { get; }
    internal static string NotSupported_CollectibleBoundNonCollectible { get; }
    internal static string NotSupported_CollectibleCOM { get; }
    internal static string NotSupported_CollectibleDelegateMarshal { get; }
    internal static string NotSupported_Constructor { get; }
    internal static string NotSupported_CreateInstanceWithTypeBuilder { get; }
    internal static string NotSupported_DBNullSerial { get; }
    internal static string NotSupported_DelegateMarshalToWrongDomain { get; }
    internal static string NotSupported_DelegateSerHolderSerial { get; }
    internal static string NotSupported_DynamicAssembly { get; }
    internal static string NotSupported_DynamicAssemblyNoRunAccess { get; }
    internal static string NotSupported_DynamicMethodFlags { get; }
    internal static string NotSupported_DynamicModule { get; }
    internal static string NotSupported_FileStreamOnNonFiles { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string NotSupported_GenericMethod { get; }
    internal static string NotSupported_GlobalMethodSerialization { get; }
    internal static string NotSupported_IDispInvokeDefaultMemberWithNamedArgs { get; }
    internal static string NotSupported_IllegalOneByteBranch { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ManagedActivation { get; }
    internal static string NotSupported_MaxWaitHandles { get; }
    internal static string NotSupported_MemStreamNotExpandable { get; }
    internal static string NotSupported_MustBeModuleBuilder { get; }
    internal static string NotSupported_NativeCallableTarget { get; }
    internal static string NotSupported_NoCodepageData { get; }
    internal static string NotSupported_NonBlittableTypes { get; }
    internal static string NotSupported_NonReflectedType { get; }
    internal static string NotSupported_NonStaticMethod { get; }
    internal static string NotSupported_NoParentDefaultConstructor { get; }
    internal static string NotSupported_NoTypeInfo { get; }
    internal static string NotSupported_NYI { get; }
    internal static string NotSupported_ObsoleteResourcesFile { get; }
    internal static string NotSupported_OleAutBadVarType { get; }
    internal static string NotSupported_OpenType { get; }
    internal static string NotSupported_OutputStreamUsingTypeBuilder { get; }
    internal static string NotSupported_PIAInAppxProcess { get; }
    internal static string NotSupported_Reading { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string NotSupported_ResourceObjectSerialization { get; }
    internal static string NotSupported_SignalAndWaitSTAThread { get; }
    internal static string NotSupported_StringComparison { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string NotSupported_SymbolMethod { get; }
    internal static string NotSupported_TooManyArgs { get; }
    internal static string NotSupported_Type { get; }
    internal static string NotSupported_TypeCannotDeserialized { get; }
    internal static string NotSupported_TypeNotYetCreated { get; }
    internal static string NotSupported_UmsSafeBuffer { get; }
    internal static string NotSupported_UnitySerHolder { get; }
    internal static string NotSupported_UnknownTypeCode { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string NotSupported_ValueClassCM { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string NotSupported_VoidArray { get; }
    internal static string NotSupported_WinRT_PartialTrust { get; }
    internal static string NotSupported_Writing { get; }
    internal static string NotSupported_WrongResourceReader_Type { get; }
    internal static string NullReference_This { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string ObjectDisposed_Generic { get; }
    internal static string ObjectDisposed_ObjectName_Name { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ObjectDisposed_RegKeyClosed { get; }
    internal static string ObjectDisposed_ResourceSet { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string ObjectDisposed_ViewAccessorClosed { get; }
    internal static string OperationCanceled { get; }
    internal static string OutOfMemory_GCHandleMDA { get; }
    internal static string Overflow_Byte { get; }
    internal static string Overflow_Char { get; }
    internal static string Overflow_Currency { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Double { get; }
    internal static string Overflow_Duration { get; }
    internal static string Overflow_Int16 { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_NegateTwosCompNum { get; }
    internal static string Overflow_NegativeUnsigned { get; }
    internal static string Overflow_SByte { get; }
    internal static string Overflow_Single { get; }
    internal static string Overflow_TimeSpanElementTooLarge { get; }
    internal static string Overflow_TimeSpanTooLong { get; }
    internal static string Overflow_UInt16 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string PlatformNotSupported_ArgIterator { get; }
    internal static string PlatformNotSupported_ComInterop { get; }
    internal static string PlatformNotSupported_NamedSynchronizationPrimitives { get; }
    internal static string PlatformNotSupported_NamedSyncObjectWaitAnyWaitAll { get; }
    internal static string PlatformNotSupported_OSXFileLocking { get; }
    internal static string PlatformNotSupported_ReflectionOnly { get; }
    internal static string PlatformNotSupported_Remoting { get; }
    internal static string PlatformNotSupported_SecureBinarySerialization { get; }
    internal static string PlatformNotSupported_StrongNameSigning { get; }
    internal static string PlatformNotSupported_WinRT { get; }
    internal static string Policy_CannotLoadSemiTrustAssembliesDuringInit { get; }
    internal static string PostconditionFailed { get; }
    internal static string PostconditionFailed_Cnd { get; }
    internal static string PostconditionOnExceptionFailed { get; }
    internal static string PostconditionOnExceptionFailed_Cnd { get; }
    internal static string PreconditionFailed { get; }
    internal static string PreconditionFailed_Cnd { get; }
    internal static string Rank_MultiDimNotSupported { get; }
    internal static string Rank_MustMatch { get; }
    internal static string ReflectionTypeLoad_LoadFailed { get; }
    internal static string Remoting_AppDomainUnloaded_ThreadUnwound { get; }
    internal static string ResourceReaderIsClosed { get; }
    internal static string Resources_StreamNotValid { get; }
    internal static string RFLCT_AmbigCust { get; }
    internal static string RFLCT_Ambiguous { get; }
    internal static string InvalidFilterCriteriaException_CritInt { get; }
    internal static string InvalidFilterCriteriaException_CritString { get; }
    internal static string RFLCT_InvalidFieldFail { get; }
    internal static string RFLCT_InvalidPropFail { get; }
    internal static string RFLCT_Targ_ITargMismatch { get; }
    internal static string RFLCT_Targ_StatFldReqTarg { get; }
    internal static string RFLCT_Targ_StatMethReqTarg { get; }
    internal static string RuntimeWrappedException { get; }
    internal static string Security_CannotReadFileData { get; }
    internal static string Security_CannotReadRegistryData { get; }
    internal static string Security_RegistryPermission { get; }
    internal static string SemaphoreSlim_ctor_InitialCountWrong { get; }
    internal static string SemaphoreSlim_ctor_MaxCountWrong { get; }
    internal static string SemaphoreSlim_Disposed { get; }
    internal static string SemaphoreSlim_Release_CountWrong { get; }
    internal static string SemaphoreSlim_Wait_TimeoutWrong { get; }
    internal static string Serialization_BadParameterInfo { get; }
    internal static string Serialization_CorruptField { get; }
    internal static string Serialization_DateTimeTicksOutOfRange { get; }
    internal static string Serialization_InsufficientDeserializationState { get; }
    internal static string Serialization_InsufficientState { get; }
    internal static string Serialization_InvalidData { get; }
    internal static string Serialization_InvalidDelegateType { get; }
    internal static string Serialization_InvalidEscapeSequence { get; }
    internal static string Serialization_InvalidFieldState { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_InvalidPtrValue { get; }
    internal static string Serialization_InvalidType { get; }
    internal static string Serialization_KeyValueDifferentSizes { get; }
    internal static string Serialization_MemberOutOfRange { get; }
    internal static string Serialization_MemberTypeNotRecognized { get; }
    internal static string Serialization_MissField { get; }
    internal static string Serialization_MissingDateTimeData { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Serialization_NonSerType { get; }
    internal static string Serialization_NoParameterInfo { get; }
    internal static string Serialization_NotFound { get; }
    internal static string Serialization_NullKey { get; }
    internal static string Serialization_NullSignature { get; }
    internal static string Serialization_OptionalFieldVersionValue { get; }
    internal static string Serialization_SameNameTwice { get; }
    internal static string Serialization_StringBuilderCapacity { get; }
    internal static string Serialization_StringBuilderMaxCapacity { get; }
    internal static string Serialization_UnableToFindModule { get; }
    internal static string Serialization_UnknownMember { get; }
    internal static string SpinLock_Exit_SynchronizationLockException { get; }
    internal static string SpinLock_IsHeldByCurrentThread { get; }
    internal static string SpinLock_TryEnter_ArgumentOutOfRange { get; }
    internal static string SpinLock_TryEnter_LockRecursionException { get; }
    internal static string SpinLock_TryReliableEnter_ArgumentException { get; }
    internal static string SpinWait_SpinUntil_ArgumentNull { get; }
    internal static string SpinWait_SpinUntil_TimeoutWrong { get; }
    internal static string StackTrace_InFileLineNumber { get; }
    internal static string Task_ContinueWith_ESandLR { get; }
    internal static string Task_ContinueWith_NotOnAnything { get; }
    internal static string Task_Delay_InvalidDelay { get; }
    internal static string Task_Delay_InvalidMillisecondsDelay { get; }
    internal static string Task_Dispose_NotCompleted { get; }
    internal static string Task_FromAsync_LongRunning { get; }
    internal static string Task_FromAsync_PreferFairness { get; }
    internal static string Task_MultiTaskContinuation_EmptyTaskList { get; }
    internal static string Task_MultiTaskContinuation_FireOptions { get; }
    internal static string Task_MultiTaskContinuation_NullTask { get; }
    internal static string Task_RunSynchronously_AlreadyStarted { get; }
    internal static string Task_RunSynchronously_Continuation { get; }
    internal static string Task_RunSynchronously_Promise { get; }
    internal static string Task_RunSynchronously_TaskCompleted { get; }
    internal static string Task_Start_AlreadyStarted { get; }
    internal static string Task_Start_ContinuationTask { get; }
    internal static string Task_Start_Promise { get; }
    internal static string Task_Start_TaskCompleted { get; }
    internal static string Task_ThrowIfDisposed { get; }
    internal static string Task_WaitMulti_NullTask { get; }
    internal static string TaskCanceledException_ctor_DefaultMessage { get; }
    internal static string TaskCompletionSourceT_TrySetException_NoExceptions { get; }
    internal static string TaskCompletionSourceT_TrySetException_NullException { get; }
    internal static string TaskExceptionHolder_UnhandledException { get; }
    internal static string TaskExceptionHolder_UnknownExceptionType { get; }
    internal static string TaskScheduler_ExecuteTask_WrongTaskScheduler { get; }
    internal static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent { get; }
    internal static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline { get; }
    internal static string TaskSchedulerException_ctor_DefaultMessage { get; }
    internal static string TaskT_DebuggerNoResult { get; }
    internal static string TaskT_TransitionToFinal_AlreadyCompleted { get; }
    internal static string Threading_AbandonedMutexException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle { get; }
    internal static string Threading_WaitHandleTooManyPosts { get; }
    internal static string Threading_SemaphoreFullException { get; }
    internal static string ThreadLocal_Disposed { get; }
    internal static string ThreadLocal_Value_RecursiveCallsToValue { get; }
    internal static string ThreadLocal_ValuesNotAvailable { get; }
    internal static string TimeZoneNotFound_MissingData { get; }
    internal static string TypeInitialization_Default { get; }
    internal static string TypeInitialization_Type { get; }
    internal static string TypeLoad_ResolveNestedType { get; }
    internal static string TypeLoad_ResolveType { get; }
    internal static string TypeLoad_ResolveTypeFromAssembly { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string UnauthorizedAccess_RegistryKeyGeneric_Key { get; }
    internal static string UnauthorizedAccess_RegistryNoWrite { get; }
    internal static string UnauthorizedAccess_SystemDomain { get; }
    internal static string UnknownError_Num { get; }
    internal static string Verification_Exception { get; }
    internal static string Word_At { get; }
    internal static string DebugAssertBanner { get; }
    internal static string DebugAssertLongMessage { get; }
    internal static string DebugAssertShortMessage { get; }
    internal static string LockRecursionException_ReadAfterWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveReadNotAllowed { get; }
    internal static string LockRecursionException_RecursiveWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveUpgradeNotAllowed { get; }
    internal static string LockRecursionException_WriteAfterReadNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedUpgrade { get; }
    internal static string SynchronizationLockException_MisMatchedRead { get; }
    internal static string SynchronizationLockException_IncorrectDispose { get; }
    internal static string LockRecursionException_UpgradeAfterReadNotAllowed { get; }
    internal static string LockRecursionException_UpgradeAfterWriteNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedWrite { get; }
    internal static Type ResourceType { get; }
    private static SR();
    [CompilerGeneratedAttribute]
private static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
private static void set_ResourceManager(ResourceManager value);
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_Acc_CreateAbst();
    internal static string get_Acc_CreateAbstEx();
    internal static string get_Acc_CreateArgIterator();
    internal static string get_Acc_CreateGeneric();
    internal static string get_Acc_CreateGenericEx();
    internal static string get_Acc_CreateInterface();
    internal static string get_Acc_CreateInterfaceEx();
    internal static string get_Acc_CreateVoid();
    internal static string get_Acc_NotClassInit();
    internal static string get_Acc_ReadOnly();
    internal static string get_Acc_RvaStatic();
    internal static string get_Access_Void();
    internal static string get_AggregateException_ctor_DefaultMessage();
    internal static string get_AggregateException_ctor_InnerExceptionNull();
    internal static string get_AggregateException_DeserializationFailure();
    internal static string get_AggregateException_ToString();
    internal static string get_AppDomain_AppBaseNotSet();
    internal static string get_Arg_AccessException();
    internal static string get_Arg_AccessViolationException();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_Arg_AppDomainUnloadedException();
    internal static string get_Arg_ApplicationException();
    internal static string get_Arg_ArgumentException();
    internal static string get_Arg_ArgumentOutOfRangeException();
    internal static string get_Arg_ArithmeticException();
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_ArrayTypeMismatchException();
    internal static string get_Arg_ArrayZeroError();
    internal static string get_Arg_BadDecimal();
    internal static string get_Arg_BadImageFormatException();
    internal static string get_Arg_BadLiteralFormat();
    internal static string get_Arg_BogusIComparer();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_Arg_CannotBeNaN();
    internal static string get_Arg_CannotHaveNegativeValue();
    internal static string get_Arg_CATypeResolutionFailed();
    internal static string get_Arg_COMAccess();
    internal static string get_Arg_COMException();
    internal static string get_Arg_COMPropSetPut();
    internal static string get_Arg_CreatInstAccess();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_CustomAttributeFormatException();
    internal static string get_Arg_DataMisalignedException();
    internal static string get_Arg_DateTimeRange();
    internal static string get_Arg_DecBitCtor();
    internal static string get_Arg_DirectoryNotFoundException();
    internal static string get_Arg_DivideByZero();
    internal static string get_Arg_DlgtNullInst();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_DlgtTypeMis();
    internal static string get_Arg_DllNotFoundException();
    internal static string get_Arg_DriveNotFoundException();
    internal static string get_Arg_DuplicateWaitObjectException();
    internal static string get_Arg_EHClauseNotClause();
    internal static string get_Arg_EHClauseNotFilter();
    internal static string get_Arg_EmptyArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EndOfStreamException();
    internal static string get_Arg_EntryPointNotFoundException();
    internal static string get_Arg_EnumAndObjectMustBeSameType();
    internal static string get_Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_EnumLitValueNotFound();
    internal static string get_Arg_EnumUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumValueNotFound();
    internal static string get_Arg_ExecutionEngineException();
    internal static string get_Arg_ExternalException();
    internal static string get_Arg_FieldAccessException();
    internal static string get_Arg_FieldDeclTarget();
    internal static string get_Arg_FldGetArgErr();
    internal static string get_Arg_FldGetPropSet();
    internal static string get_Arg_FldSetArgErr();
    internal static string get_Arg_FldSetGet();
    internal static string get_Arg_FldSetInvoke();
    internal static string get_Arg_FldSetPropGet();
    internal static string get_Arg_FormatException();
    internal static string get_Arg_GenericParameter();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_GuidArrayCtor();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_Arg_HandleNotSync();
    internal static string get_Arg_HexStyleNotSupported();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_IndexMustBeInt();
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_InsufficientExecutionStackException();
    internal static string get_Arg_InvalidANSIString();
    internal static string get_Arg_InvalidBase();
    internal static string get_Arg_InvalidCastException();
    internal static string get_Arg_InvalidComObjectException();
    internal static string get_Arg_InvalidFilterCriteriaException();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidHexStyle();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_Asm_Culture();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_FallbackLoc();
    internal static string get_Arg_InvalidOleVariantTypeException();
    internal static string get_Arg_InvalidOperationException();
    internal static string get_Arg_InvalidSearchPattern();
    internal static string get_Arg_InvalidTypeInRetType();
    internal static string get_Arg_InvalidTypeInSignature();
    internal static string get_Arg_InvalidUTF8String();
    internal static string get_Arg_IOException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_LongerThanDestArray();
    internal static string get_Arg_LongerThanSrcArray();
    internal static string get_Arg_LongerThanSrcString();
    internal static string get_Arg_LowerBoundsMustMatch();
    internal static string get_Arg_MarshalAsAnyRestriction();
    internal static string get_Arg_MarshalDirectiveException();
    internal static string get_Arg_MethodAccessException();
    internal static string get_Arg_MethodAccessException_WithMethodName();
    internal static string get_Arg_MissingFieldException();
    internal static string get_Arg_MissingManifestResourceException();
    internal static string get_Arg_MissingMemberException();
    internal static string get_Arg_MissingMethodException();
    internal static string get_Arg_MulticastNotSupportedException();
    internal static string get_Arg_MustBeBoolean();
    internal static string get_Arg_MustBeByte();
    internal static string get_Arg_MustBeChar();
    internal static string get_Arg_MustBeDateTime();
    internal static string get_Arg_MustBeDateTimeOffset();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeDelegate();
    internal static string get_Arg_MustBeDouble();
    internal static string get_Arg_MustBeEnum();
    internal static string get_Arg_MustBeEnumBaseTypeOrEnum();
    internal static string get_Arg_MustBeGuid();
    internal static string get_Arg_MustBeInt16();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeInt64();
    internal static string get_Arg_MustBeInterface();
    internal static string get_Arg_MustBePointer();
    internal static string get_Arg_MustBePrimArray();
    internal static string get_Arg_MustBeSByte();
    internal static string get_Arg_MustBeSingle();
    internal static string get_Arg_MustBeStatic();
    internal static string get_Arg_MustBeString();
    internal static string get_Arg_MustBeStringPtrNotAtom();
    internal static string get_Arg_MustBeTimeSpan();
    internal static string get_Arg_MustBeType();
    internal static string get_Arg_MustBeUInt16();
    internal static string get_Arg_MustBeUInt32();
    internal static string get_Arg_MustBeUInt64();
    internal static string get_Arg_MustBeVersion();
    internal static string get_Arg_MustContainEnumInfo();
    internal static string get_Arg_NamedParamNull();
    internal static string get_Arg_NamedParamTooBig();
    internal static string get_Arg_NDirectBadObject();
    internal static string get_Arg_Need1DArray();
    internal static string get_Arg_Need2DArray();
    internal static string get_Arg_Need3DArray();
    internal static string get_Arg_NeedAtLeast1Rank();
    internal static string get_Arg_NegativeArgCount();
    internal static string get_Arg_NoAccessSpec();
    internal static string get_Arg_NoDefCTor();
    internal static string get_Arg_NoITypeInfo();
    internal static string get_Arg_NoITypeLib();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_NoStaticVirtual();
    internal static string get_Arg_NotFiniteNumberException();
    internal static string get_Arg_NotFoundIFace();
    internal static string get_Arg_NotGenericMethodDefinition();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_NotGenericTypeDefinition();
    internal static string get_Arg_NotImplementedException();
    internal static string get_Arg_NotSupportedException();
    internal static string get_Arg_NullIndex();
    internal static string get_Arg_NullReferenceException();
    internal static string get_Arg_ObjObj();
    internal static string get_Arg_ObjObjEx();
    internal static string get_Arg_OleAutDateInvalid();
    internal static string get_Arg_OleAutDateScale();
    internal static string get_Arg_OverflowException();
    internal static string get_Arg_ParamName_Name();
    internal static string get_Arg_ParmArraySize();
    internal static string get_Arg_ParmCnt();
    internal static string get_Arg_PathIllegal();
    internal static string get_Arg_PathIllegalUNC();
    internal static string get_Arg_PlatformNotSupported();
    internal static string get_Arg_PrimWiden();
    internal static string get_Arg_PropSetGet();
    internal static string get_Arg_PropSetInvoke();
    internal static string get_Arg_RankException();
    internal static string get_Arg_RankIndices();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_RanksAndBounds();
    internal static string get_Arg_ReflectionOnlyCA();
    internal static string get_Arg_ReflectionOnlyField();
    internal static string get_Arg_ReflectionOnlyInvoke();
    internal static string get_Arg_RegBadKeyKind();
    internal static string get_Arg_RegGetOverflowBug();
    internal static string get_Arg_RegInvalidKeyName();
    internal static string get_Arg_RegKeyNotFound();
    internal static string get_Arg_RegKeyStrLenBug();
    internal static string get_Arg_RegSetBadArrType();
    internal static string get_Arg_RegSetMismatchedKind();
    internal static string get_Arg_RegSetStrArrNull();
    internal static string get_Arg_RegSubKeyValueAbsent();
    internal static string get_Arg_RegValStrLenBug();
    internal static string get_Arg_RemoveArgNotFound();
    internal static string get_Arg_ResMgrNotResSet();
    internal static string get_Arg_ResourceFileUnsupportedVersion();
    internal static string get_Arg_ResourceNameNotExist();
    internal static string get_Arg_SafeArrayRankMismatchException();
    internal static string get_Arg_SafeArrayTypeMismatchException();
    internal static string get_Arg_SecurityException();
    internal static string get_SerializationException();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_StackOverflowException();
    internal static string get_Arg_SurrogatesNotAllowedAsSingleChar();
    internal static string get_Arg_SynchronizationLockException();
    internal static string get_Arg_SystemException();
    internal static string get_Arg_TargetInvocationException();
    internal static string get_Arg_TargetParameterCountException();
    internal static string get_Arg_ThreadStartException();
    internal static string get_Arg_ThreadStateException();
    internal static string get_Arg_TimeoutException();
    internal static string get_Arg_TypeAccessException();
    internal static string get_Arg_TypedReference_Null();
    internal static string get_Arg_TypeLoadException();
    internal static string get_Arg_TypeLoadNullStr();
    internal static string get_Arg_TypeRefPrimitve();
    internal static string get_Arg_TypeUnloadedException();
    internal static string get_Arg_UnauthorizedAccessException();
    internal static string get_Arg_UnboundGenField();
    internal static string get_Arg_UnboundGenParam();
    internal static string get_Arg_UnknownTypeCode();
    internal static string get_Arg_VarMissNull();
    internal static string get_Arg_VersionString();
    internal static string get_Arg_WrongAsyncResult();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AbsolutePathRequired();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_AdjustmentRulesNoNulls();
    internal static string get_Argument_AdjustmentRulesOutOfOrder();
    internal static string get_Argument_AlreadyACCW();
    internal static string get_Argument_AlreadyBoundOrSyncHandle();
    internal static string get_Argument_ArgumentZero();
    internal static string get_Argument_ArrayGetInterfaceMap();
    internal static string get_Argument_ArraysInvalid();
    internal static string get_Argument_BadAttributeOnInterfaceMethod();
    internal static string get_Argument_BadConstantValue();
    internal static string get_Argument_BadConstructor();
    internal static string get_Argument_BadConstructorCallConv();
    internal static string get_Argument_BadExceptionCodeGen();
    internal static string get_Argument_BadFieldForConstructorBuilder();
    internal static string get_Argument_BadFieldSig();
    internal static string get_Argument_BadFieldType();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_BadImageFormatExceptionResolve();
    internal static string get_Argument_BadLabel();
    internal static string get_Argument_BadLabelContent();
    internal static string get_Argument_BadNestedTypeFlags();
    internal static string get_Argument_BadObjRef();
    internal static string get_Argument_BadParameterCountsForConstructor();
    internal static string get_Argument_BadParameterTypeForCAB();
    internal static string get_Argument_BadPropertyForConstructorBuilder();
    internal static string get_Argument_BadSigFormat();
    internal static string get_Argument_BadSizeForData();
    internal static string get_Argument_BadTypeAttrInvalidLayout();
    internal static string get_Argument_BadTypeAttrNestedVisibilityOnNonNestedType();
    internal static string get_Argument_BadTypeAttrNonNestedVisibilityNestedType();
    internal static string get_Argument_BadTypeAttrReservedBitsSet();
    internal static string get_Argument_BadTypeInCustomAttribute();
    internal static string get_Argument_CannotCreateTypedReference();
    internal static string get_Argument_CannotGetTypeTokenForByRef();
    internal static string get_Argument_CannotSetParentToInterface();
    internal static string get_Argument_CantCallSecObjFunc();
    internal static string get_Argument_CodepageNotSupported();
    internal static string get_Argument_CompareOptionOrdinal();
    internal static string get_Argument_ConflictingDateTimeRoundtripStyles();
    internal static string get_Argument_ConflictingDateTimeStyles();
    internal static string get_Argument_ConstantDoesntMatch();
    internal static string get_Argument_ConstantNotSupported();
    internal static string get_Argument_ConstantNull();
    internal static string get_Argument_ConstructorNeedGenericDeclaringType();
    internal static string get_Argument_ConversionOverflow();
    internal static string get_Argument_ConvertMismatch();
    internal static string get_Argument_CORDBBadMethod();
    internal static string get_Argument_CORDBBadVarArgCallConv();
    internal static string get_Argument_CultureIetfNotSupported();
    internal static string get_Argument_CultureInvalidIdentifier();
    internal static string get_Argument_CultureIsNeutral();
    internal static string get_Argument_CultureNotSupported();
    internal static string get_Argument_CustomAssemblyLoadContextRequestedNameMismatch();
    internal static string get_Argument_CustomCultureCannotBePassedByNumber();
    internal static string get_Argument_DateTimeBadBinaryData();
    internal static string get_Argument_DateTimeHasTicks();
    internal static string get_Argument_DateTimeHasTimeOfDay();
    internal static string get_Argument_DateTimeIsInvalid();
    internal static string get_Argument_DateTimeIsNotAmbiguous();
    internal static string get_Argument_DateTimeKindMustBeUnspecified();
    internal static string get_Argument_DateTimeKindMustBeUnspecifiedOrUtc();
    internal static string get_Argument_DateTimeOffsetInvalidDateTimeStyles();
    internal static string get_Argument_DateTimeOffsetIsNotAmbiguous();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_DuplicateTypeName();
    internal static string get_Argument_EmitWriteLineType();
    internal static string get_Argument_EmptyDecString();
    internal static string get_Argument_EmptyFileName();
    internal static string get_Argument_EmptyName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_EmptyWaithandleArray();
    internal static string get_Argument_EncoderFallbackNotEmpty();
    internal static string get_Argument_EncodingConversionOverflowBytes();
    internal static string get_Argument_EncodingConversionOverflowChars();
    internal static string get_Argument_EncodingNotSupported();
    internal static string get_Argument_EnumTypeDoesNotMatch();
    internal static string get_Argument_FallbackBufferNotEmpty();
    internal static string get_Argument_FieldDeclaringTypeGeneric();
    internal static string get_Argument_FieldNeedGenericDeclaringType();
    internal static string get_Argument_GenConstraintViolation();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_GenericsInvalid();
    internal static string get_Argument_GlobalFunctionHasToBeStatic();
    internal static string get_Argument_HandleLeak();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_Argument_IdnBadBidi();
    internal static string get_Argument_IdnBadLabelSize();
    internal static string get_Argument_IdnBadNameSize();
    internal static string get_Argument_IdnBadPunycode();
    internal static string get_Argument_IdnBadStd3();
    internal static string get_Argument_IdnIllegalName();
    internal static string get_Argument_IllegalEnvVarName();
    internal static string get_Argument_IllegalName();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_Argument_IndexOutOfArrayBounds();
    internal static string get_Argument_InsufficientSpaceToCopyCollection();
    internal static string get_Argument_InterfaceMap();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_Argument_InvalidArgumentForComparison();
    internal static string get_Argument_InvalidArrayLength();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_Argument_InvalidAssemblyName();
    internal static string get_Argument_InvalidCalendar();
    internal static string get_Argument_InvalidCharSequence();
    internal static string get_Argument_InvalidCharSequenceNoIndex();
    internal static string get_Argument_InvalidCodePageBytesIndex();
    internal static string get_Argument_InvalidCodePageConversionIndex();
    internal static string get_Argument_InvalidConstructorDeclaringType();
    internal static string get_Argument_InvalidConstructorInfo();
    internal static string get_Argument_InvalidCultureName();
    internal static string get_Argument_InvalidDateTimeKind();
    internal static string get_Argument_InvalidDateTimeStyles();
    internal static string get_Argument_InvalidDigitSubstitution();
    internal static string get_Argument_InvalidEnum();
    internal static string get_Argument_InvalidEnumValue();
    internal static string get_Argument_InvalidFieldDeclaringType();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidGenericArg();
    internal static string get_Argument_InvalidGenericInstArray();
    internal static string get_Argument_InvalidGroupSize();
    internal static string get_Argument_InvalidHandle();
    internal static string get_Argument_InvalidHighSurrogate();
    internal static string get_Argument_InvalidId();
    internal static string get_Argument_InvalidKindOfTypeForCA();
    internal static string get_Argument_InvalidLabel();
    internal static string get_Argument_InvalidLowSurrogate();
    internal static string get_Argument_InvalidMemberForNamedArgument();
    internal static string get_Argument_InvalidMethodDeclaringType();
    internal static string get_Argument_InvalidName();
    internal static string get_Argument_InvalidNativeDigitCount();
    internal static string get_Argument_InvalidNativeDigitValue();
    internal static string get_Argument_InvalidNeutralRegionName();
    internal static string get_Argument_InvalidNormalizationForm();
    internal static string get_Argument_InvalidNumberStyles();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOpCodeOnDynamicMethod();
    internal static string get_Argument_InvalidParameterInfo();
    internal static string get_Argument_InvalidParamInfo();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidREG_TZI_FORMAT();
    internal static string get_Argument_InvalidRegistryViewCheck();
    internal static string get_Argument_InvalidResourceCultureName();
    internal static string get_Argument_InvalidSafeBufferOffLen();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSerializedString();
    internal static string get_Argument_InvalidTimeSpanStyles();
    internal static string get_Argument_InvalidToken();
    internal static string get_Argument_InvalidTypeForCA();
    internal static string get_Argument_InvalidTypeForDynamicMethod();
    internal static string get_Argument_InvalidTypeName();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_InvalidUnity();
    internal static string get_Argument_InvalidValue();
    internal static string get_Argument_LargeInteger();
    internal static string get_Argument_LongEnvVarValue();
    internal static string get_Argument_MethodDeclaringTypeGeneric();
    internal static string get_Argument_MethodDeclaringTypeGenericLcg();
    internal static string get_Argument_MethodNeedGenericDeclaringType();
    internal static string get_Argument_MinMaxValue();
    internal static string get_Argument_MismatchedArrays();
    internal static string get_Argument_MissingDefaultConstructor();
    internal static string get_Argument_MustBeFalse();
    internal static string get_Argument_MustBeRuntimeAssembly();
    internal static string get_Argument_MustBeRuntimeFieldInfo();
    internal static string get_Argument_MustBeRuntimeMethodInfo();
    internal static string get_Argument_MustBeRuntimeModule();
    internal static string get_Argument_MustBeRuntimeReflectionObject();
    internal static string get_Argument_MustBeRuntimeType();
    internal static string get_Argument_MustBeTypeBuilder();
    internal static string get_Argument_MustHaveAttributeBaseClass();
    internal static string get_Argument_MustHaveLayoutOrBeBlittable();
    internal static string get_Argument_NativeOverlappedAlreadyFree();
    internal static string get_Argument_NativeOverlappedWrongBoundHandle();
    internal static string get_Argument_NeedGenericMethodDefinition();
    internal static string get_Argument_NeedNonGenericObject();
    internal static string get_Argument_NeedNonGenericType();
    internal static string get_Argument_NeedStructWithNoRefs();
    internal static string get_Argument_NeverValidGenericArgument();
    internal static string get_Argument_NoDomainManager();
    internal static string get_Argument_NoEra();
    internal static string get_Argument_NoModuleFileExtension();
    internal static string get_Argument_NoRegionInvariantCulture();
    internal static string get_Argument_NotATP();
    internal static string get_Argument_NotAWritableProperty();
    internal static string get_Argument_NotEnoughBytesToRead();
    internal static string get_Argument_NotEnoughBytesToWrite();
    internal static string get_Argument_NotEnoughGenArguments();
    internal static string get_Argument_NotExceptionType();
    internal static string get_Argument_NotInExceptionBlock();
    internal static string get_Argument_NotMethodCallOpcode();
    internal static string get_Argument_NotSerializable();
    internal static string get_Argument_NoUnderlyingCCW();
    internal static string get_Argument_NoUninitializedStrings();
    internal static string get_Argument_ObjIsWinRTObject();
    internal static string get_Argument_ObjNotComObject();
    internal static string get_Argument_OffsetAndCapacityOutOfBounds();
    internal static string get_Argument_OffsetAndLengthOutOfBounds();
    internal static string get_Argument_OffsetLocalMismatch();
    internal static string get_Argument_OffsetOfFieldNotFound();
    internal static string get_Argument_OffsetOutOfRange();
    internal static string get_Argument_OffsetPrecision();
    internal static string get_Argument_OffsetUtcMismatch();
    internal static string get_Argument_OneOfCulturesNotSupported();
    internal static string get_Argument_OnlyMscorlib();
    internal static string get_Argument_OutOfOrderDateTimes();
    internal static string get_Argument_PathEmpty();
    internal static string get_Argument_PathFormatNotSupported();
    internal static string get_Argument_PreAllocatedAlreadyAllocated();
    internal static string get_Argument_RecursiveFallback();
    internal static string get_Argument_RecursiveFallbackBytes();
    internal static string get_Argument_RedefinedLabel();
    internal static string get_Argument_ResolveField();
    internal static string get_Argument_ResolveFieldHandle();
    internal static string get_Argument_ResolveMember();
    internal static string get_Argument_ResolveMethod();
    internal static string get_Argument_ResolveMethodHandle();
    internal static string get_Argument_ResolveModuleType();
    internal static string get_Argument_ResolveString();
    internal static string get_Argument_ResolveType();
    internal static string get_Argument_ResultCalendarRange();
    internal static string get_Argument_SemaphoreInitialMaximum();
    internal static string get_Argument_ShouldNotSpecifyExceptionType();
    internal static string get_Argument_ShouldOnlySetVisibilityFlags();
    internal static string get_Argument_SigIsFinalized();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Argument_StringFirstCharIsZero();
    internal static string get_Argument_StringZeroLength();
    internal static string get_Argument_StructMustNotBeValueClass();
    internal static string get_Argument_TimeSpanHasSeconds();
    internal static string get_Argument_TimeZoneInfoBadTZif();
    internal static string get_Argument_TimeZoneInfoInvalidTZif();
    internal static string get_Argument_ToExclusiveLessThanFromExclusive();
    internal static string get_Argument_TooManyFinallyClause();
    internal static string get_Argument_TransitionTimesAreIdentical();
    internal static string get_Argument_TypedReferenceInvalidField();
    internal static string get_Argument_TypeIsWinRTType();
    internal static string get_Argument_TypeMustBeVisibleFromCom();
    internal static string get_Argument_TypeMustNotBeComImport();
    internal static string get_Argument_TypeNameTooLong();
    internal static string get_Argument_TypeNotActivatableViaWindowsRuntime();
    internal static string get_Argument_TypeNotComObject();
    internal static string get_Argument_TypeNotValid();
    internal static string get_Argument_UnclosedExceptionBlock();
    internal static string get_Argument_Unexpected_TypeSource();
    internal static string get_Argument_UnknownUnmanagedCallConv();
    internal static string get_Argument_UnmanagedMemAccessorWrapAround();
    internal static string get_Argument_UnmatchedMethodForLocal();
    internal static string get_Argument_UnmatchingSymScope();
    internal static string get_Argument_UnrecognizedLoaderOptimization();
    internal static string get_Argument_UTCOutOfRange();
    internal static string get_Argument_VerStringTooLong();
    internal static string get_Argument_WaitHandleNameTooLong();
    internal static string get_Argument_WinRTSystemRuntimeType();
    internal static string get_ArgumentException_BadMethodImplBody();
    internal static string get_ArgumentException_BufferNotFromPool();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_ArgumentException_TupleIncorrectType();
    internal static string get_ArgumentException_TupleLastArgumentNotATuple();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
    internal static string get_ArgumentNull_Array();
    internal static string get_ArgumentNull_ArrayElement();
    internal static string get_ArgumentNull_ArrayValue();
    internal static string get_ArgumentNull_Assembly();
    internal static string get_ArgumentNull_AssemblyName();
    internal static string get_ArgumentNull_AssemblyNameName();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentNull_Collection();
    internal static string get_ArgumentNull_FileName();
    internal static string get_ArgumentNull_Generic();
    internal static string get_ArgumentNull_GUID();
    internal static string get_ArgumentNull_Key();
    internal static string get_ArgumentNull_Obj();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentNull_SafeHandle();
    internal static string get_ArgumentNull_Stream();
    internal static string get_ArgumentNull_String();
    internal static string get_ArgumentNull_Type();
    internal static string get_ArgumentNull_TypedRefType();
    internal static string get_ArgumentNull_Waithandles();
    internal static string get_ArgumentNull_WithParamName();
    internal static string get_ArgumentOutOfRange_ActualValue();
    internal static string get_ArgumentOutOfRange_AddressSpace();
    internal static string get_ArgumentOutOfRange_AddValue();
    internal static string get_ArgumentOutOfRange_ArrayLB();
    internal static string get_ArgumentOutOfRange_ArrayLBAndLength();
    internal static string get_ArgumentOutOfRange_ArrayListInsert();
    internal static string get_ArgumentOutOfRange_BadHourMinuteSecond();
    internal static string get_ArgumentOutOfRange_BadYearMonthDay();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_BinaryReaderFillBuffer();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper();
    internal static string get_ArgumentOutOfRange_CalendarRange();
    internal static string get_ArgumentOutOfRange_Capacity();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_DateArithmetic();
    internal static string get_ArgumentOutOfRange_DateTimeBadMonths();
    internal static string get_ArgumentOutOfRange_DateTimeBadTicks();
    internal static string get_ArgumentOutOfRange_DateTimeBadYears();
    internal static string get_ArgumentOutOfRange_Day();
    internal static string get_ArgumentOutOfRange_DayOfWeek();
    internal static string get_ArgumentOutOfRange_DayParam();
    internal static string get_ArgumentOutOfRange_DecimalRound();
    internal static string get_ArgumentOutOfRange_DecimalScale();
    internal static string get_ArgumentOutOfRange_EndIndexStartIndex();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_Era();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_ArgumentOutOfRange_FileTimeInvalid();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_GetByteCountOverflow();
    internal static string get_ArgumentOutOfRange_GetCharCountOverflow();
    internal static string get_ArgumentOutOfRange_HashtableLoadFactor();
    internal static string get_ArgumentOutOfRange_HugeArrayNotSupported();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_IndexCount();
    internal static string get_ArgumentOutOfRange_IndexCountBuffer();
    internal static string get_ArgumentOutOfRange_IndexLargerThanMaxValue();
    internal static string get_ArgumentOutOfRange_IndexLength();
    internal static string get_ArgumentOutOfRange_IndexString();
    internal static string get_ArgumentOutOfRange_InvalidEraValue();
    internal static string get_ArgumentOutOfRange_InvalidHighSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidLowSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidUTF32();
    internal static string get_ArgumentOutOfRange_Length();
    internal static string get_ArgumentOutOfRange_LengthGreaterThanCapacity();
    internal static string get_ArgumentOutOfRange_LengthTooLarge();
    internal static string get_ArgumentOutOfRange_LessEqualToIntegerMaxVal();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_Month();
    internal static string get_ArgumentOutOfRange_MonthParam();
    internal static string get_ArgumentOutOfRange_MustBeNonNegInt32();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_ArgumentOutOfRange_NegativeCapacity();
    internal static string get_ArgumentOutOfRange_NegativeCount();
    internal static string get_ArgumentOutOfRange_NegativeLength();
    internal static string get_ArgumentOutOfRange_OffsetLength();
    internal static string get_ArgumentOutOfRange_OffsetOut();
    internal static string get_ArgumentOutOfRange_ParamSequence();
    internal static string get_ArgumentOutOfRange_PartialWCHAR();
    internal static string get_ArgumentOutOfRange_PeriodTooLarge();
    internal static string get_ArgumentOutOfRange_PositionLessThanCapacityRequired();
    internal static string get_ArgumentOutOfRange_Range();
    internal static string get_ArgumentOutOfRange_RoundingDigits();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_ArgumentOutOfRange_SmallMaxCapacity();
    internal static string get_ArgumentOutOfRange_StartIndex();
    internal static string get_ArgumentOutOfRange_StartIndexLargerThanLength();
    internal static string get_ArgumentOutOfRange_StartIndexLessThanLength();
    internal static string get_ArgumentOutOfRange_StreamLength();
    internal static string get_ArgumentOutOfRange_TimeoutTooLarge();
    internal static string get_ArgumentOutOfRange_UIntPtrMax();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamLength();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamWrapAround();
    internal static string get_ArgumentOutOfRange_UtcOffset();
    internal static string get_ArgumentOutOfRange_UtcOffsetAndDaylightDelta();
    internal static string get_ArgumentOutOfRange_Version();
    internal static string get_ArgumentOutOfRange_Week();
    internal static string get_ArgumentOutOfRange_Year();
    internal static string get_Arithmetic_NaN();
    internal static string get_ArrayTypeMismatch_CantAssignType();
    internal static string get_ArrayTypeMismatch_ConstrainedCopy();
    internal static string get_Arugment_EmitMixedContext1();
    internal static string get_Arugment_EmitMixedContext2();
    internal static string get_AssertionFailed();
    internal static string get_AssertionFailed_Cnd();
    internal static string get_AssumptionFailed();
    internal static string get_AssumptionFailed_Cnd();
    internal static string get_AsyncMethodBuilder_InstanceNotInitialized();
    internal static string get_BadImageFormat_BadILFormat();
    internal static string get_BadImageFormat_InvalidType();
    internal static string get_BadImageFormat_NegativeStringLength();
    internal static string get_BadImageFormat_ParameterSignatureMismatch();
    internal static string get_BadImageFormat_ResourceDataLengthInvalid();
    internal static string get_BadImageFormat_ResourceNameCorrupted();
    internal static string get_BadImageFormat_ResourceNameCorrupted_NameIndex();
    internal static string get_BadImageFormat_ResourcesDataInvalidOffset();
    internal static string get_BadImageFormat_ResourcesHeaderCorrupted();
    internal static string get_BadImageFormat_ResourcesIndexTooLong();
    internal static string get_BadImageFormat_ResourcesNameInvalidOffset();
    internal static string get_BadImageFormat_ResourcesNameTooLong();
    internal static string get_BadImageFormat_TypeMismatch();
    internal static string get_CancellationToken_CreateLinkedToken_TokensIsEmpty();
    internal static string get_CancellationToken_SourceDisposed();
    internal static string get_CancellationTokenSource_Disposed();
    internal static string get_ConcurrentCollection_SyncRoot_NotSupported();
    internal static string get_ConcurrentDictionary_ArrayIncorrectType();
    internal static string get_ConcurrentDictionary_ArrayNotLargeEnough();
    internal static string get_ConcurrentDictionary_CapacityMustNotBeNegative();
    internal static string get_ConcurrentDictionary_ConcurrencyLevelMustBePositive();
    internal static string get_ConcurrentDictionary_IndexIsNegative();
    internal static string get_ConcurrentDictionary_ItemKeyIsNull();
    internal static string get_ConcurrentDictionary_KeyAlreadyExisted();
    internal static string get_ConcurrentDictionary_TypeOfKeyIncorrect();
    internal static string get_ConcurrentDictionary_TypeOfValueIncorrect();
    internal static string get_event_Barrier_PhaseFinished();
    internal static string get_event_ConcurrentBag_TryPeekSteals();
    internal static string get_event_ConcurrentBag_TryTakeSteals();
    internal static string get_event_ConcurrentDictionary_AcquiringAllLocks();
    internal static string get_event_ConcurrentStack_FastPopFailed();
    internal static string get_event_ConcurrentStack_FastPushFailed();
    internal static string get_event_ParallelFork();
    internal static string get_event_ParallelInvokeBegin();
    internal static string get_event_ParallelInvokeEnd();
    internal static string get_event_ParallelJoin();
    internal static string get_event_ParallelLoopBegin();
    internal static string get_event_ParallelLoopEnd();
    internal static string get_event_SpinLock_FastPathFailed();
    internal static string get_event_SpinWait_NextSpinWillYield();
    internal static string get_event_TaskCompleted();
    internal static string get_event_TaskScheduled();
    internal static string get_event_TaskStarted();
    internal static string get_event_TaskWaitBegin();
    internal static string get_event_TaskWaitEnd();
    internal static string get_EventSource_AbstractMustNotDeclareEventMethods();
    internal static string get_EventSource_AbstractMustNotDeclareKTOC();
    internal static string get_EventSource_AddScalarOutOfRange();
    internal static string get_EventSource_ChannelTypeDoesNotMatchEventChannelValue();
    internal static string get_EventSource_DataDescriptorsOutOfRange();
    internal static string get_EventSource_DuplicateStringKey();
    internal static string get_EventSource_EnumKindMismatch();
    internal static string get_EventSource_EventChannelOutOfRange();
    internal static string get_EventSource_EventIdReused();
    internal static string get_EventSource_EventMustHaveTaskIfNonDefaultOpcode();
    internal static string get_EventSource_EventMustNotBeExplicitImplementation();
    internal static string get_EventSource_EventNameDoesNotEqualTaskPlusOpcode();
    internal static string get_EventSource_EventNameReused();
    internal static string get_EventSource_EventParametersMismatch();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_EventWithAdminChannelMustHaveMessage();
    internal static string get_EventSource_IllegalKeywordsValue();
    internal static string get_EventSource_IllegalOpcodeValue();
    internal static string get_EventSource_IllegalTaskValue();
    internal static string get_EventSource_IncorrentlyAuthoredTypeInfo();
    internal static string get_EventSource_InvalidCommand();
    internal static string get_EventSource_InvalidEventFormat();
    internal static string get_EventSource_KeywordCollision();
    internal static string get_EventSource_KeywordNeedPowerOfTwo();
    internal static string get_EventSource_ListenerCreatedInsideCallback();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_MaxChannelExceeded();
    internal static string get_EventSource_MismatchIdToWriteEvent();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedPositiveId();
    internal static string get_EventSource_NoFreeBuffers();
    internal static string get_EventSource_NonCompliantTypeError();
    internal static string get_EventSource_NoRelatedActivityId();
    internal static string get_EventSource_NotSupportedArrayOfBinary();
    internal static string get_EventSource_NotSupportedArrayOfNil();
    internal static string get_EventSource_NotSupportedArrayOfNullTerminatedString();
    internal static string get_EventSource_NotSupportedCustomSerializedData();
    internal static string get_EventSource_NotSupportedNestedArraysEnums();
    internal static string get_EventSource_NullInput();
    internal static string get_EventSource_OpcodeCollision();
    internal static string get_EventSource_PinArrayOutOfRange();
    internal static string get_EventSource_RecursiveTypeDefinition();
    internal static string get_EventSource_SessionIdError();
    internal static string get_EventSource_StopsFollowStarts();
    internal static string get_EventSource_TaskCollision();
    internal static string get_EventSource_TaskOpcodePairReused();
    internal static string get_EventSource_TooManyArgs();
    internal static string get_EventSource_TooManyFields();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_TypeMustBeSealedOrAbstract();
    internal static string get_EventSource_TypeMustDeriveFromEventSource();
    internal static string get_EventSource_UndefinedChannel();
    internal static string get_EventSource_UndefinedKeyword();
    internal static string get_EventSource_UndefinedOpcode();
    internal static string get_EventSource_UnsupportedEventTypeInManifest();
    internal static string get_EventSource_UnsupportedMessageProperty();
    internal static string get_EventSource_VarArgsParameterMismatch();
    internal static string get_Exception_EndOfInnerExceptionStack();
    internal static string get_Exception_EndStackTraceFromPreviousThrow();
    internal static string get_Exception_WasThrown();
    internal static string get_ExecutionContext_ExceptionInAsyncLocalNotification();
    internal static string get_FieldAccess_InitOnly();
    internal static string get_FileNotFound_ResolveAssembly();
    internal static string get_Format_AttributeUsage();
    internal static string get_Format_Bad7BitInt32();
    internal static string get_Format_BadBase();
    internal static string get_Format_BadBase64Char();
    internal static string get_Format_BadBase64CharArrayLength();
    internal static string get_Format_BadBoolean();
    internal static string get_Format_BadDatePattern();
    internal static string get_Format_BadDateTime();
    internal static string get_Format_BadDateTimeCalendar();
    internal static string get_Format_BadDayOfWeek();
    internal static string get_Format_BadFormatSpecifier();
    internal static string get_Format_BadQuote();
    internal static string get_Format_BadTimeSpan();
    internal static string get_Format_DateOutOfRange();
    internal static string get_Format_EmptyInputString();
    internal static string get_Format_ExtraJunkAtEnd();
    internal static string get_Format_GuidBrace();
    internal static string get_Format_GuidBraceAfterLastNumber();
    internal static string get_Format_GuidComma();
    internal static string get_Format_GuidDashes();
    internal static string get_Format_GuidEndBrace();
    internal static string get_Format_GuidHexPrefix();
    internal static string get_Format_GuidInvalidChar();
    internal static string get_Format_GuidInvLen();
    internal static string get_Format_GuidUnrecognized();
    internal static string get_Format_IndexOutOfRange();
    internal static string get_Format_InvalidEnumFormatSpecification();
    internal static string get_Format_InvalidGuidFormatSpecification();
    internal static string get_Format_InvalidString();
    internal static string get_Format_MissingIncompleteDate();
    internal static string get_Format_NeedSingleChar();
    internal static string get_Format_NoParsibleDigits();
    internal static string get_Format_OffsetOutOfRange();
    internal static string get_Format_RepeatDateTimePattern();
    internal static string get_Format_StringZeroLength();
    internal static string get_Format_UnknowDateTimeWord();
    internal static string get_Format_UTCOutOfRange();
    internal static string get_Globalization_cp_1200();
    internal static string get_Globalization_cp_12000();
    internal static string get_Globalization_cp_12001();
    internal static string get_Globalization_cp_1201();
    internal static string get_Globalization_cp_20127();
    internal static string get_Globalization_cp_28591();
    internal static string get_Globalization_cp_65000();
    internal static string get_Globalization_cp_65001();
    internal static string get_IndexOutOfRange_ArrayRankIndex();
    internal static string get_IndexOutOfRange_IORaceCondition();
    internal static string get_IndexOutOfRange_UMSPosition();
    internal static string get_InsufficientMemory_MemFailPoint();
    internal static string get_InsufficientMemory_MemFailPoint_TooBig();
    internal static string get_InsufficientMemory_MemFailPoint_VAFrag();
    internal static string get_Interop_COM_TypeMismatch();
    internal static string get_Interop_Marshal_Unmappable_Char();
    internal static string get_InvalidCast_CannotCastNullToValueType();
    internal static string get_InvalidCast_CannotCoerceByRefVariant();
    internal static string get_InvalidCast_DBNull();
    internal static string get_InvalidCast_DownCastArrayElement();
    internal static string get_InvalidCast_Empty();
    internal static string get_InvalidCast_FromDBNull();
    internal static string get_InvalidCast_FromTo();
    internal static string get_InvalidCast_IConvertible();
    internal static string get_InvalidCast_OATypeMismatch();
    internal static string get_InvalidCast_StoreArrayElement();
    internal static string get_InvalidCast_WinRTIPropertyValueArrayCoersion();
    internal static string get_InvalidCast_WinRTIPropertyValueCoersion();
    internal static string get_InvalidCast_WinRTIPropertyValueElement();
    internal static string get_InvalidOperation_AsyncFlowCtrlCtxMismatch();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_InvalidOperation_BadEmptyMethodBody();
    internal static string get_InvalidOperation_BadILGeneratorUsage();
    internal static string get_InvalidOperation_BadInstructionOrIndexOutOfBound();
    internal static string get_InvalidOperation_BadInterfaceNotAbstract();
    internal static string get_InvalidOperation_BadMethodBody();
    internal static string get_InvalidOperation_BadTypeAttributesNotAbstract();
    internal static string get_InvalidOperation_CalledTwice();
    internal static string get_InvalidOperation_CannotImportGlobalFromDifferentModule();
    internal static string get_InvalidOperation_CannotRemoveLastFromEmptyCollection();
    internal static string get_InvalidOperation_CannotRestoreUnsupressedFlow();
    internal static string get_InvalidOperation_CannotSupressFlowMultipleTimes();
    internal static string get_InvalidOperation_CannotUseAFCMultiple();
    internal static string get_InvalidOperation_CannotUseAFCOtherThread();
    internal static string get_InvalidOperation_CantInstantiateAbstractClass();
    internal static string get_InvalidOperation_CantInstantiateFunctionPointer();
    internal static string get_InvalidOperation_CollectionBackingDictionaryTooLarge();
    internal static string get_InvalidOperation_CollectionBackingListTooLarge();
    internal static string get_InvalidOperation_CollectionCorrupted();
    internal static string get_InvalidOperation_ConstructorNotAllowedOnInterface();
    internal static string get_InvalidOperation_CriticalTransparentAreMutuallyExclusive();
    internal static string get_InvalidOperation_DateTimeParsing();
    internal static string get_InvalidOperation_DebuggerLaunchFailed();
    internal static string get_InvalidOperation_DefaultConstructorILGen();
    internal static string get_InvalidOperation_EndReadCalledMultiple();
    internal static string get_InvalidOperation_EndWriteCalledMultiple();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_EventInfoNotAvailable();
    internal static string get_InvalidOperation_EventTokenTableRequiresDelegate();
    internal static string get_InvalidOperation_GenericParametersAlreadySet();
    internal static string get_InvalidOperation_GetVersion();
    internal static string get_InvalidOperation_GlobalsHaveBeenCreated();
    internal static string get_InvalidOperation_HandleIsNotInitialized();
    internal static string get_InvalidOperation_HandleIsNotPinned();
    internal static string get_InvalidOperation_HashInsertFailed();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_InvalidOperation_MethodBaked();
    internal static string get_InvalidOperation_MethodBuilderBaked();
    internal static string get_InvalidOperation_MethodHasBody();
    internal static string get_InvalidOperation_MustCallInitialize();
    internal static string get_InvalidOperation_NativeOverlappedReused();
    internal static string get_InvalidOperation_NoMultiModuleAssembly();
    internal static string get_InvalidOperation_NoPublicAddMethod();
    internal static string get_InvalidOperation_NoPublicRemoveMethod();
    internal static string get_InvalidOperation_NotADebugModule();
    internal static string get_InvalidOperation_NotAllowedInDynamicMethod();
    internal static string get_InvalidOperation_NotAllowedInReflectionOnly();
    internal static string get_InvalidOperation_NotAVarArgCallingConvention();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_InvalidOperation_NotSupportedOnWinRTEvent();
    internal static string get_InvalidOperation_NotWithConcurrentGC();
    internal static string get_InvalidOperation_NoUnderlyingTypeOnEnum();
    internal static string get_InvalidOperation_NoValue();
    internal static string get_InvalidOperation_NullArray();
    internal static string get_InvalidOperation_NullContext();
    internal static string get_InvalidOperation_NullModuleHandle();
    internal static string get_InvalidOperation_OpenLocalVariableScope();
    internal static string get_InvalidOperation_Overlapped_Pack();
    internal static string get_InvalidOperation_PropertyInfoNotAvailable();
    internal static string get_InvalidOperation_ReadOnly();
    internal static string get_InvalidOperation_ResMgrBadResSet_Type();
    internal static string get_InvalidOperation_ResourceNotStream_Name();
    internal static string get_InvalidOperation_ResourceNotString_Name();
    internal static string get_InvalidOperation_ResourceNotString_Type();
    internal static string get_InvalidOperation_SetData_OnlyOnce();
    internal static string get_InvalidOperation_ShouldNotHaveMethodBody();
    internal static string get_InvalidOperation_StrongNameKeyPairRequired();
    internal static string get_InvalidOperation_ThreadWrongThreadStart();
    internal static string get_InvalidOperation_TimeoutsNotSupported();
    internal static string get_InvalidOperation_TypeCannotBeBoxed();
    internal static string get_InvalidOperation_TypeHasBeenCreated();
    internal static string get_InvalidOperation_TypeNotCreated();
    internal static string get_InvalidOperation_UnknownEnumType();
    internal static string get_InvalidOperation_WriteOnce();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple();
    internal static string get_InvalidProgram_Default();
    internal static string get_InvalidTimeZone_InvalidFileData();
    internal static string get_InvalidTimeZone_InvalidRegistryData();
    internal static string get_InvalidTimeZone_JulianDayNotSupported();
    internal static string get_InvalidTimeZone_NoTTInfoStructures();
    internal static string get_InvalidTimeZone_UnparseablePosixMDateString();
    internal static string get_InvariantFailed();
    internal static string get_InvariantFailed_Cnd();
    internal static string get_IO_DriveNotFound_Drive();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileLoad();
    internal static string get_IO_FileName_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_BindHandleFailed();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileStreamHandlePosition();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_FileTooLongOrHandleNotSync();
    internal static string get_IO_FixedCapacity();
    internal static string get_IO_InvalidStringLen_Len();
    internal static string get_IO_NoPermissionToDirectoryName();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_StreamTooLong();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_UnknownFileName();
    internal static string get_Lazy_CreateValue_NoParameterlessCtorForT();
    internal static string get_Lazy_ctor_ModeInvalid();
    internal static string get_Lazy_StaticInit_InvalidOperation();
    internal static string get_Lazy_ToString_ValueNotCreated();
    internal static string get_Lazy_Value_RecursiveCallsToValue();
    internal static string get_Loader_ContextPolicies();
    internal static string get_Loader_Name();
    internal static string get_Loader_NoContextPolicies();
    internal static string get_ManualResetEventSlim_ctor_SpinCountOutOfRange();
    internal static string get_ManualResetEventSlim_ctor_TooManyWaiters();
    internal static string get_ManualResetEventSlim_Disposed();
    internal static string get_Marshaler_StringTooLong();
    internal static string get_MissingConstructor_Name();
    internal static string get_MissingField();
    internal static string get_MissingField_Name();
    internal static string get_MissingManifestResource_LooselyLinked();
    internal static string get_MissingManifestResource_MultipleBlobs();
    internal static string get_MissingManifestResource_NoNeutralAsm();
    internal static string get_MissingManifestResource_NoNeutralDisk();
    internal static string get_MissingManifestResource_NoPRIresources();
    internal static string get_MissingManifestResource_ResWFileNotLoaded();
    internal static string get_MissingMember();
    internal static string get_MissingMember_Name();
    internal static string get_MissingMemberNestErr();
    internal static string get_MissingMemberTypeRef();
    internal static string get_MissingMethod_Name();
    internal static string get_MissingSatelliteAssembly_Culture_Name();
    internal static string get_MissingSatelliteAssembly_Default();
    internal static string get_Multicast_Combine();
    internal static string get_MustUseCCRewrite();
    internal static string get_NotImplemented_ResourcesLongerThanInt64Max();
    internal static string get_NotSupported_AbstractNonCLS();
    internal static string get_NotSupported_ActivAttr();
    internal static string get_NotSupported_AppX();
    internal static string get_NotSupported_AssemblyLoadFromHash();
    internal static string get_NotSupported_ByRefLike();
    internal static string get_NotSupported_ByRefLikeArray();
    internal static string get_NotSupported_ByRefReturn();
    internal static string get_NotSupported_CallToVarArg();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_NotSupported_ChangeType();
    internal static string get_NotSupported_CollectibleAssemblyResolve();
    internal static string get_NotSupported_CollectibleBoundNonCollectible();
    internal static string get_NotSupported_CollectibleCOM();
    internal static string get_NotSupported_CollectibleDelegateMarshal();
    internal static string get_NotSupported_Constructor();
    internal static string get_NotSupported_CreateInstanceWithTypeBuilder();
    internal static string get_NotSupported_DBNullSerial();
    internal static string get_NotSupported_DelegateMarshalToWrongDomain();
    internal static string get_NotSupported_DelegateSerHolderSerial();
    internal static string get_NotSupported_DynamicAssembly();
    internal static string get_NotSupported_DynamicAssemblyNoRunAccess();
    internal static string get_NotSupported_DynamicMethodFlags();
    internal static string get_NotSupported_DynamicModule();
    internal static string get_NotSupported_FileStreamOnNonFiles();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_NotSupported_GenericMethod();
    internal static string get_NotSupported_GlobalMethodSerialization();
    internal static string get_NotSupported_IDispInvokeDefaultMemberWithNamedArgs();
    internal static string get_NotSupported_IllegalOneByteBranch();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ManagedActivation();
    internal static string get_NotSupported_MaxWaitHandles();
    internal static string get_NotSupported_MemStreamNotExpandable();
    internal static string get_NotSupported_MustBeModuleBuilder();
    internal static string get_NotSupported_NativeCallableTarget();
    internal static string get_NotSupported_NoCodepageData();
    internal static string get_NotSupported_NonBlittableTypes();
    internal static string get_NotSupported_NonReflectedType();
    internal static string get_NotSupported_NonStaticMethod();
    internal static string get_NotSupported_NoParentDefaultConstructor();
    internal static string get_NotSupported_NoTypeInfo();
    internal static string get_NotSupported_NYI();
    internal static string get_NotSupported_ObsoleteResourcesFile();
    internal static string get_NotSupported_OleAutBadVarType();
    internal static string get_NotSupported_OpenType();
    internal static string get_NotSupported_OutputStreamUsingTypeBuilder();
    internal static string get_NotSupported_PIAInAppxProcess();
    internal static string get_NotSupported_Reading();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_NotSupported_ResourceObjectSerialization();
    internal static string get_NotSupported_SignalAndWaitSTAThread();
    internal static string get_NotSupported_StringComparison();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_NotSupported_SymbolMethod();
    internal static string get_NotSupported_TooManyArgs();
    internal static string get_NotSupported_Type();
    internal static string get_NotSupported_TypeCannotDeserialized();
    internal static string get_NotSupported_TypeNotYetCreated();
    internal static string get_NotSupported_UmsSafeBuffer();
    internal static string get_NotSupported_UnitySerHolder();
    internal static string get_NotSupported_UnknownTypeCode();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_NotSupported_ValueClassCM();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_NotSupported_VoidArray();
    internal static string get_NotSupported_WinRT_PartialTrust();
    internal static string get_NotSupported_Writing();
    internal static string get_NotSupported_WrongResourceReader_Type();
    internal static string get_NullReference_This();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_ObjectDisposed_Generic();
    internal static string get_ObjectDisposed_ObjectName_Name();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ObjectDisposed_RegKeyClosed();
    internal static string get_ObjectDisposed_ResourceSet();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_ObjectDisposed_ViewAccessorClosed();
    internal static string get_OperationCanceled();
    internal static string get_OutOfMemory_GCHandleMDA();
    internal static string get_Overflow_Byte();
    internal static string get_Overflow_Char();
    internal static string get_Overflow_Currency();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Double();
    internal static string get_Overflow_Duration();
    internal static string get_Overflow_Int16();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_NegateTwosCompNum();
    internal static string get_Overflow_NegativeUnsigned();
    internal static string get_Overflow_SByte();
    internal static string get_Overflow_Single();
    internal static string get_Overflow_TimeSpanElementTooLarge();
    internal static string get_Overflow_TimeSpanTooLong();
    internal static string get_Overflow_UInt16();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_PlatformNotSupported_ArgIterator();
    internal static string get_PlatformNotSupported_ComInterop();
    internal static string get_PlatformNotSupported_NamedSynchronizationPrimitives();
    internal static string get_PlatformNotSupported_NamedSyncObjectWaitAnyWaitAll();
    internal static string get_PlatformNotSupported_OSXFileLocking();
    internal static string get_PlatformNotSupported_ReflectionOnly();
    internal static string get_PlatformNotSupported_Remoting();
    internal static string get_PlatformNotSupported_SecureBinarySerialization();
    internal static string get_PlatformNotSupported_StrongNameSigning();
    internal static string get_PlatformNotSupported_WinRT();
    internal static string get_Policy_CannotLoadSemiTrustAssembliesDuringInit();
    internal static string get_PostconditionFailed();
    internal static string get_PostconditionFailed_Cnd();
    internal static string get_PostconditionOnExceptionFailed();
    internal static string get_PostconditionOnExceptionFailed_Cnd();
    internal static string get_PreconditionFailed();
    internal static string get_PreconditionFailed_Cnd();
    internal static string get_Rank_MultiDimNotSupported();
    internal static string get_Rank_MustMatch();
    internal static string get_ReflectionTypeLoad_LoadFailed();
    internal static string get_Remoting_AppDomainUnloaded_ThreadUnwound();
    internal static string get_ResourceReaderIsClosed();
    internal static string get_Resources_StreamNotValid();
    internal static string get_RFLCT_AmbigCust();
    internal static string get_RFLCT_Ambiguous();
    internal static string get_InvalidFilterCriteriaException_CritInt();
    internal static string get_InvalidFilterCriteriaException_CritString();
    internal static string get_RFLCT_InvalidFieldFail();
    internal static string get_RFLCT_InvalidPropFail();
    internal static string get_RFLCT_Targ_ITargMismatch();
    internal static string get_RFLCT_Targ_StatFldReqTarg();
    internal static string get_RFLCT_Targ_StatMethReqTarg();
    internal static string get_RuntimeWrappedException();
    internal static string get_Security_CannotReadFileData();
    internal static string get_Security_CannotReadRegistryData();
    internal static string get_Security_RegistryPermission();
    internal static string get_SemaphoreSlim_ctor_InitialCountWrong();
    internal static string get_SemaphoreSlim_ctor_MaxCountWrong();
    internal static string get_SemaphoreSlim_Disposed();
    internal static string get_SemaphoreSlim_Release_CountWrong();
    internal static string get_SemaphoreSlim_Wait_TimeoutWrong();
    internal static string get_Serialization_BadParameterInfo();
    internal static string get_Serialization_CorruptField();
    internal static string get_Serialization_DateTimeTicksOutOfRange();
    internal static string get_Serialization_InsufficientDeserializationState();
    internal static string get_Serialization_InsufficientState();
    internal static string get_Serialization_InvalidData();
    internal static string get_Serialization_InvalidDelegateType();
    internal static string get_Serialization_InvalidEscapeSequence();
    internal static string get_Serialization_InvalidFieldState();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_InvalidPtrValue();
    internal static string get_Serialization_InvalidType();
    internal static string get_Serialization_KeyValueDifferentSizes();
    internal static string get_Serialization_MemberOutOfRange();
    internal static string get_Serialization_MemberTypeNotRecognized();
    internal static string get_Serialization_MissField();
    internal static string get_Serialization_MissingDateTimeData();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_MissingValues();
    internal static string get_Serialization_NonSerType();
    internal static string get_Serialization_NoParameterInfo();
    internal static string get_Serialization_NotFound();
    internal static string get_Serialization_NullKey();
    internal static string get_Serialization_NullSignature();
    internal static string get_Serialization_OptionalFieldVersionValue();
    internal static string get_Serialization_SameNameTwice();
    internal static string get_Serialization_StringBuilderCapacity();
    internal static string get_Serialization_StringBuilderMaxCapacity();
    internal static string get_Serialization_UnableToFindModule();
    internal static string get_Serialization_UnknownMember();
    internal static string get_SpinLock_Exit_SynchronizationLockException();
    internal static string get_SpinLock_IsHeldByCurrentThread();
    internal static string get_SpinLock_TryEnter_ArgumentOutOfRange();
    internal static string get_SpinLock_TryEnter_LockRecursionException();
    internal static string get_SpinLock_TryReliableEnter_ArgumentException();
    internal static string get_SpinWait_SpinUntil_ArgumentNull();
    internal static string get_SpinWait_SpinUntil_TimeoutWrong();
    internal static string get_StackTrace_InFileLineNumber();
    internal static string get_Task_ContinueWith_ESandLR();
    internal static string get_Task_ContinueWith_NotOnAnything();
    internal static string get_Task_Delay_InvalidDelay();
    internal static string get_Task_Delay_InvalidMillisecondsDelay();
    internal static string get_Task_Dispose_NotCompleted();
    internal static string get_Task_FromAsync_LongRunning();
    internal static string get_Task_FromAsync_PreferFairness();
    internal static string get_Task_MultiTaskContinuation_EmptyTaskList();
    internal static string get_Task_MultiTaskContinuation_FireOptions();
    internal static string get_Task_MultiTaskContinuation_NullTask();
    internal static string get_Task_RunSynchronously_AlreadyStarted();
    internal static string get_Task_RunSynchronously_Continuation();
    internal static string get_Task_RunSynchronously_Promise();
    internal static string get_Task_RunSynchronously_TaskCompleted();
    internal static string get_Task_Start_AlreadyStarted();
    internal static string get_Task_Start_ContinuationTask();
    internal static string get_Task_Start_Promise();
    internal static string get_Task_Start_TaskCompleted();
    internal static string get_Task_ThrowIfDisposed();
    internal static string get_Task_WaitMulti_NullTask();
    internal static string get_TaskCanceledException_ctor_DefaultMessage();
    internal static string get_TaskCompletionSourceT_TrySetException_NoExceptions();
    internal static string get_TaskCompletionSourceT_TrySetException_NullException();
    internal static string get_TaskExceptionHolder_UnhandledException();
    internal static string get_TaskExceptionHolder_UnknownExceptionType();
    internal static string get_TaskScheduler_ExecuteTask_WrongTaskScheduler();
    internal static string get_TaskScheduler_FromCurrentSynchronizationContext_NoCurrent();
    internal static string get_TaskScheduler_InconsistentStateAfterTryExecuteTaskInline();
    internal static string get_TaskSchedulerException_ctor_DefaultMessage();
    internal static string get_TaskT_DebuggerNoResult();
    internal static string get_TaskT_TransitionToFinal_AlreadyCompleted();
    internal static string get_Threading_AbandonedMutexException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException_InvalidHandle();
    internal static string get_Threading_WaitHandleTooManyPosts();
    internal static string get_Threading_SemaphoreFullException();
    internal static string get_ThreadLocal_Disposed();
    internal static string get_ThreadLocal_Value_RecursiveCallsToValue();
    internal static string get_ThreadLocal_ValuesNotAvailable();
    internal static string get_TimeZoneNotFound_MissingData();
    internal static string get_TypeInitialization_Default();
    internal static string get_TypeInitialization_Type();
    internal static string get_TypeLoad_ResolveNestedType();
    internal static string get_TypeLoad_ResolveType();
    internal static string get_TypeLoad_ResolveTypeFromAssembly();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_UnauthorizedAccess_RegistryKeyGeneric_Key();
    internal static string get_UnauthorizedAccess_RegistryNoWrite();
    internal static string get_UnauthorizedAccess_SystemDomain();
    internal static string get_UnknownError_Num();
    internal static string get_Verification_Exception();
    internal static string get_Word_At();
    internal static string get_DebugAssertBanner();
    internal static string get_DebugAssertLongMessage();
    internal static string get_DebugAssertShortMessage();
    internal static string get_LockRecursionException_ReadAfterWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveReadNotAllowed();
    internal static string get_LockRecursionException_RecursiveWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveUpgradeNotAllowed();
    internal static string get_LockRecursionException_WriteAfterReadNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedUpgrade();
    internal static string get_SynchronizationLockException_MisMatchedRead();
    internal static string get_SynchronizationLockException_IncorrectDispose();
    internal static string get_LockRecursionException_UpgradeAfterReadNotAllowed();
    internal static string get_LockRecursionException_UpgradeAfterWriteNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedWrite();
    internal static Type get_ResourceType();
}
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    internal StackOverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    private int m_stringLength;
    private char m_firstChar;
    public static string Empty;
    internal char FirstChar { get; }
    public char Chars { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public String(Char* value);
    [CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public String(Char[] value, int startIndex, int length);
    public String(Char[] value);
    public String(char c, int count);
    internal char get_FirstChar();
    internal static string SmallCharToUpper(string strIn);
    public char get_Chars(int index);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    public int get_Length();
    private static string CreateString(SByte* value, int startIndex, int length, Encoding enc);
    internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    internal static string CreateFromChar(char c);
    internal int GetBytesFromEncoding(Byte* pbNativeBuffer, int cbNativeBuffer, Encoding encoding);
    internal int ConvertToAnsi(Byte* pbNativeBuffer, int cbNativeBuffer, bool fBestFit, bool fThrowOnUnmappableChar);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    internal static string FastAllocateString(int length);
    internal static void wstrcpy(Char* dmem, Char* smem, int charCount);
    private string CtorCharArray(Char[] value);
    private string CtorCharArrayStartLength(Char[] value, int startIndex, int length);
    private string CtorCharCount(char c, int count);
    internal static int wcslen(Char* ptr);
    private string CtorCharPtr(Char* ptr);
    private string CtorCharPtrStartLength(Char* ptr, int startIndex, int length);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual object Clone();
    public static string Copy(string str);
    public static string Intern(string str);
    public static string IsInterned(string str);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal bool IsFastSort();
    internal bool IsAscii();
    internal void SetTrailByte(byte data);
    internal bool TryGetTrailByte(Byte& data);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static void InternalCopy(string src, IntPtr dest, int len);
    internal Char& GetRawStringData();
    private static int CompareOrdinalIgnoreCaseHelper(string strA, string strB);
    internal static int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
    internal static int nativeCompareOrdinalIgnoreCaseWC(string strA, SByte* strBBytes);
    private static bool EqualsHelper(string strA, string strB);
    private static bool EqualsIgnoreCaseAsciiHelper(string strA, string strB);
    private static bool StartsWithOrdinalHelper(string str, string startsWith);
    private static int CompareOrdinalHelper(string strA, string strB);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, string strB);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(string strB);
    public bool EndsWith(string value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public bool Equals(string value, StringComparison comparisonType);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public static bool op_Equality(string a, string b);
    public static bool op_Inequality(string a, string b);
    internal static int InternalMarvin32HashString(string s, int strLen, long additionalEntropy);
    internal static bool UseRandomizedHashing();
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool InternalUseRandomizedHashing();
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    internal int GetLegacyNonRandomizedHashCode();
    public bool StartsWith(string value);
    public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    private static void FillStringChecked(string dest, int destPos, string src);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    [CLSCompliantAttribute("False")]
public static string Concat(object arg0, object arg1, object arg2, object arg3);
    public static string Concat(Object[] args);
    public static string Concat(IEnumerable`1<T> values);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    private static string FormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public string Insert(int startIndex, string value);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, String[] value, int startIndex, int count);
    private static string JoinCore(Char* separator, int separatorLength, Object[] values);
    private static string JoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private static string JoinCore(Char* separator, int separatorLength, String[] value, int startIndex, int count);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    private string ReplaceCore(string oldValue, string newValue, CultureInfo culture, CompareOptions options);
    public string Replace(char oldChar, char newChar);
    private string ReplaceInternal(string oldValue, string newValue);
    public string Replace(string oldValue, string newValue);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(Char* separators, int separatorsLength, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, String[] separators, int count, StringSplitOptions options);
    private String[] SplitKeepEmptyEntries(Int32[] sepList, Int32[] lengthList, int defaultLength, int numReplaces, int count);
    private String[] SplitOmitEmptyEntries(Int32[] sepList, Int32[] lengthList, int defaultLength, int numReplaces, int count);
    private int MakeSeparatorList(Char* separators, int separatorsLength, Int32[] sepList);
    private int MakeSeparatorList(string separator, Int32[] sepList);
    private int MakeSeparatorList(String[] separators, Int32[] sepList, Int32[] lengthList);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private string InternalSubString(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    private string TrimWhiteSpaceHelper(TrimType trimType);
    private string TrimHelper(Char* trimChars, int trimCharsLength, TrimType trimType);
    private string CreateTrimmedString(int start, int end);
    public bool Contains(string value);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
}
public abstract class System.StringComparer : object {
    private static CultureAwareComparer s_invariantCulture;
    private static CultureAwareComparer s_invariantCultureIgnoreCase;
    private static OrdinalComparer s_ordinal;
    private static OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    private static StringComparer();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public sealed virtual int Compare(object x, object y);
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    public abstract virtual int Compare(string x, string y);
    public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
internal static class System.StubHelpers.AnsiBSTRMarshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.AnsiCharMarshaler : object {
    internal static Byte[] DoAnsiConversion(string str, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cbLength);
    internal static byte ConvertToNative(char managedChar, bool fBestFit, bool fThrowOnUnmappableChar);
    internal static char ConvertToManaged(byte nativeChar);
}
internal class System.StubHelpers.AsAnyMarshaler : ValueType {
    private static ushort VTHACK_ANSICHAR;
    private static ushort VTHACK_WINBOOL;
    private IntPtr pvArrayMarshaler;
    private BackPropAction backPropAction;
    private Type layoutType;
    private CleanupWorkList cleanupWorkList;
    internal AsAnyMarshaler(IntPtr pvArrayMarshaler);
    private static bool IsIn(int dwFlags);
    private static bool IsOut(int dwFlags);
    private static bool IsAnsi(int dwFlags);
    private static bool IsThrowOn(int dwFlags);
    private static bool IsBestFit(int dwFlags);
    private IntPtr ConvertArrayToNative(object pManagedHome, int dwFlags);
    private static IntPtr ConvertStringToNative(string pManagedHome, int dwFlags);
    private IntPtr ConvertStringBuilderToNative(StringBuilder pManagedHome, int dwFlags);
    private IntPtr ConvertLayoutToNative(object pManagedHome, int dwFlags);
    internal IntPtr ConvertToNative(object pManagedHome, int dwFlags);
    internal void ConvertToManaged(object pManagedHome, IntPtr pNativeHome);
    internal void ClearNative(IntPtr pNativeHome);
}
internal static class System.StubHelpers.BSTRMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal class System.StubHelpers.CleanupWorkList : object {
    private List`1<CleanupWorkListElement> m_list;
    public void Add(CleanupWorkListElement elem);
    public void Destroy();
}
internal class System.StubHelpers.CleanupWorkListElement : object {
    public SafeHandle m_handle;
    public bool m_owned;
    public CleanupWorkListElement(SafeHandle handle);
}
internal static class System.StubHelpers.CSTRMarshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr cstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.DateMarshaler : object {
    internal static double ConvertToNative(DateTime managedDate);
    internal static long ConvertToManaged(double nativeDate);
}
internal class System.StubHelpers.DateTimeNative : ValueType {
    public long UniversalTime;
}
internal static class System.StubHelpers.DateTimeOffsetMarshaler : object {
    private static long ManagedUtcTicksAtNativeZero;
    internal static void ConvertToNative(DateTimeOffset& managedDTO, DateTimeNative& dateTime);
    internal static void ConvertToManaged(DateTimeOffset& managedLocalDTO, DateTimeNative& nativeTicks);
}
[FriendAccessAllowedAttribute]
internal static class System.StubHelpers.EventArgsMarshaler : object {
    [FriendAccessAllowedAttribute]
internal static IntPtr CreateNativeNCCEventArgsInstance(int action, object newItems, object oldItems, int newIndex, int oldIndex);
    [FriendAccessAllowedAttribute]
[SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr CreateNativePCEventArgsInstance(string name);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static IntPtr CreateNativeNCCEventArgsInstanceHelper(int action, IntPtr newItem, IntPtr oldItem, int newIndex, int oldIndex);
}
internal static class System.StubHelpers.HResultExceptionMarshaler : object {
    internal static int ConvertToNative(Exception ex);
    internal static Exception ConvertToManaged(int hr);
}
internal static class System.StubHelpers.HStringMarshaler : object {
    internal static IntPtr ConvertToNative(string managed);
    internal static IntPtr ConvertToNativeReference(string managed, HSTRING_HEADER* hstringHeader);
    internal static string ConvertToManaged(IntPtr hstring);
    internal static void ClearNative(IntPtr hstring);
}
[FriendAccessAllowedAttribute]
internal static class System.StubHelpers.InterfaceMarshaler : object {
    internal static IntPtr ConvertToNative(object objSrc, IntPtr itfMT, IntPtr classMT, int flags);
    internal static object ConvertToManaged(IntPtr pUnk, IntPtr itfMT, IntPtr classMT, int flags);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void ClearNative(IntPtr pUnk);
    [FriendAccessAllowedAttribute]
internal static object ConvertToManagedWithoutUnboxing(IntPtr pNative);
}
internal static class System.StubHelpers.KeyValuePairMarshaler : object {
    internal static IntPtr ConvertToNative(KeyValuePair`2& pair);
    internal static KeyValuePair`2<K, V> ConvertToManaged(IntPtr pInsp);
    internal static object ConvertToManagedBox(IntPtr pInsp);
}
internal static class System.StubHelpers.MngdHiddenLengthArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, IntPtr cbElementSize, ushort vt);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_DateTime(DateTimeOffset[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_Type(Type[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_Exception(Exception[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_Nullable(Nullable`1[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_KeyValuePair(KeyValuePair`2[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int elementCount);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_DateTime(DateTimeOffset[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_Type(Type[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_Exception(Exception[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_Nullable(Nullable`1[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_KeyValuePair(KeyValuePair`2[]& managedArray, IntPtr pNativeHome);
    internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    internal static void ClearNativeContents_Type(IntPtr pNativeHome, int cElements);
}
internal static class System.StubHelpers.MngdNativeArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int dwFlags);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int cElements);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
}
internal static class System.StubHelpers.MngdRefCustomMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pCMHelper);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
internal static class System.StubHelpers.MngdSafeArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int iRank, int dwFlags);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, object pOriginalManaged);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
internal class System.StubHelpers.NativeVariant : ValueType {
    private ushort vt;
    private ushort wReserved1;
    private ushort wReserved2;
    private ushort wReserved3;
    private IntPtr data1;
    private IntPtr data2;
}
internal static class System.StubHelpers.NullableMarshaler : object {
    internal static IntPtr ConvertToNative(Nullable`1& pManaged);
    internal static void ConvertToManagedRetVoid(IntPtr pNative, Nullable`1& retObj);
    internal static Nullable`1<T> ConvertToManaged(IntPtr pNative);
}
internal static class System.StubHelpers.ObjectMarshaler : object {
    internal static void ConvertToNative(object objSrc, IntPtr pDstVariant);
    internal static object ConvertToManaged(IntPtr pSrcVariant);
    internal static void ClearNative(IntPtr pVariant);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class System.StubHelpers.StubHelpers : object {
    internal static bool IsQCall(IntPtr pMD);
    internal static void InitDeclaringType(IntPtr pMD);
    internal static IntPtr GetNDirectTarget(IntPtr pMD);
    internal static IntPtr GetDelegateTarget(Delegate pThis, IntPtr& pStubArg);
    internal static void ClearLastError();
    internal static void SetLastError();
    internal static void ThrowInteropParamException(int resID, int paramIdx);
    internal static IntPtr AddToCleanupList(CleanupWorkList& pCleanupWorkList, SafeHandle handle);
    internal static void DestroyCleanupList(CleanupWorkList& pCleanupWorkList);
    internal static Exception GetHRExceptionObject(int hr);
    internal static Exception InternalGetHRExceptionObject(int hr);
    internal static Exception GetCOMHRExceptionObject(int hr, IntPtr pCPCMD, object pThis);
    internal static Exception GetCOMHRExceptionObject_WinRT(int hr, IntPtr pCPCMD, object pThis);
    internal static Exception InternalGetCOMHRExceptionObject(int hr, IntPtr pCPCMD, object pThis, bool fForWinRT);
    internal static IntPtr CreateCustomMarshalerHelper(IntPtr pMD, int paramToken, IntPtr hndManagedType);
    internal static IntPtr SafeHandleAddRef(SafeHandle pHandle, Boolean& success);
    internal static void SafeHandleRelease(SafeHandle pHandle);
    internal static IntPtr GetCOMIPFromRCW(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget, Boolean& pfNeedsRelease);
    internal static IntPtr GetCOMIPFromRCW_WinRT(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    internal static IntPtr GetCOMIPFromRCW_WinRTSharedGeneric(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    internal static IntPtr GetCOMIPFromRCW_WinRTDelegate(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    internal static bool ShouldCallWinRTInterface(object objSrc, IntPtr pCPCMD);
    internal static Delegate GetTargetForAmbiguousVariantCall(object objSrc, IntPtr pMT, Boolean& fUseString);
    internal static void StubRegisterRCW(object pThis);
    internal static void StubUnregisterRCW(object pThis);
    internal static IntPtr GetDelegateInvokeMethod(Delegate pThis);
    internal static object GetWinRTFactoryObject(IntPtr pCPCMD);
    internal static IntPtr GetWinRTFactoryReturnValue(object pThis, IntPtr pCtorEntry);
    internal static IntPtr GetOuterInspectable(object pThis, IntPtr pCtorMD);
    internal static IntPtr ProfilerBeginTransitionCallback(IntPtr pSecretParam, IntPtr pThread, object pThis);
    internal static void ProfilerEndTransitionCallback(IntPtr pMD, IntPtr pThread);
    internal static void CheckStringLength(int length);
    internal static void CheckStringLength(UInt32 length);
    internal static int strlen(SByte* ptr);
    internal static void DecimalCanonicalizeInternal(Decimal& dec);
    internal static void FmtClassUpdateNativeInternal(object obj, Byte* pNative, CleanupWorkList& pCleanupWorkList);
    internal static void FmtClassUpdateCLRInternal(object obj, Byte* pNative);
    internal static void LayoutDestroyNativeInternal(Byte* pNative, IntPtr pMT);
    internal static object AllocateInternal(IntPtr typeHandle);
    internal static void MarshalToUnmanagedVaListInternal(IntPtr va_list, UInt32 vaListSize, IntPtr pArgIterator);
    internal static void MarshalToManagedVaListInternal(IntPtr va_list, IntPtr pArgIterator);
    internal static UInt32 CalcVaListSize(IntPtr va_list);
    internal static void ValidateObject(object obj, IntPtr pMD, object pThis);
    internal static void LogPinnedArgument(IntPtr localDesc, IntPtr nativeArg);
    internal static void ValidateByref(IntPtr byref, IntPtr pMD, object pThis);
    internal static IntPtr GetStubContext();
    internal static IntPtr GetStubContextAddr();
    internal static void ArrayTypeCheck(object o, Object[] arr);
}
internal static class System.StubHelpers.SystemTypeMarshaler : object {
    internal static void ConvertToNative(Type managedType, TypeNameNative* pNativeType);
    internal static void ConvertToManaged(TypeNameNative* pNativeType, Type& managedType);
    internal static void ClearNative(TypeNameNative* pNativeType);
}
internal enum System.StubHelpers.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Projection;
}
internal class System.StubHelpers.TypeNameNative : ValueType {
    internal IntPtr typeName;
    internal TypeKind typeKind;
}
internal static class System.StubHelpers.UriMarshaler : object {
    internal static string GetRawUriFromNative(IntPtr pUri);
    internal static IntPtr CreateNativeUriInstanceHelper(Char* rawUri, int strLen);
    internal static IntPtr CreateNativeUriInstance(string rawUri);
}
internal static class System.StubHelpers.UTF8BufferMarshaler : object {
    internal static IntPtr ConvertToNative(StringBuilder sb, IntPtr pNativeBuffer, int flags);
    internal static void ConvertToManaged(StringBuilder sb, IntPtr pNative);
}
internal static class System.StubHelpers.UTF8Marshaler : object {
    private static int MAX_UTF8_CHAR_SIZE;
    internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr cstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.ValueClassMarshaler : object {
    internal static void ConvertToNative(IntPtr dst, IntPtr src, IntPtr pMT, CleanupWorkList& pCleanupWorkList);
    internal static void ConvertToManaged(IntPtr dst, IntPtr src, IntPtr pMT);
    internal static void ClearNative(IntPtr dst, IntPtr pMT);
}
internal static class System.StubHelpers.VBByValStrMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cch);
    internal static string ConvertToManaged(IntPtr pNative, int cch);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.WinRTTypeNameConverter : object {
    internal static string ConvertToWinRTTypeName(Type managedType, Boolean& isPrimitive);
    internal static Type GetTypeFromWinRTTypeName(string typeName, Boolean& isPrimitive);
}
internal static class System.StubHelpers.WSTRBufferMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal class System.SwitchStructure : ValueType {
    internal string name;
    internal int value;
    internal SwitchStructure(string n, int v);
}
internal class System.System_LazyDebugView`1 : object {
    private Lazy`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Nullable`1<LazyThreadSafetyMode> Mode { get; }
    public bool IsValueFaulted { get; }
    public System_LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public Nullable`1<LazyThreadSafetyMode> get_Mode();
    public bool get_IsValueFaulted();
}
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    protected SystemException(SerializationInfo info, StreamingContext context);
}
internal class System.SZArrayHelper : object {
    internal IEnumerator`1<T> GetEnumerator();
    private void CopyTo(T[] array, int index);
    internal int get_Count();
    internal T get_Item(int index);
    internal void set_Item(int index, T value);
    private void Add(T value);
    private bool Contains(T value);
    private bool get_IsReadOnly();
    private void Clear();
    private int IndexOf(T value);
    private void Insert(int index, T value);
    private bool Remove(T value);
    private void RemoveAt(int index);
}
public class System.Text.ASCIIEncoding : Encoding {
    internal static ASCIIEncodingSealed s_default;
    public bool IsSingleByte { get; }
    private static ASCIIEncoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
public abstract class System.Text.Decoder : object {
    internal DecoderFallback m_fallback;
    internal DecoderFallbackBuffer m_fallbackBuffer;
    public DecoderFallback Fallback { get; public set; }
    public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    internal void SerializeDecoder(SerializationInfo info);
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    private void Throw(Byte[] bytesUnknown, int index);
}
public abstract class System.Text.DecoderFallback : object {
    internal bool bIsMicrosoftBestFitFallback;
    private static DecoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) replacementFallback;
    private static DecoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) exceptionFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    private static object get_InternalSyncObject();
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    internal Byte* byteStart;
    internal Char* charEnd;
    public int Remaining { get; }
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
public class System.Text.DecoderFallbackException : ArgumentException {
    private Byte[] bytesUnknown;
    private int index;
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    internal DecoderFallbackException(SerializationInfo info, StreamingContext context);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    protected Encoding m_encoding;
    protected bool m_mustFlush;
    internal bool m_throwOnOverflow;
    internal int m_bytesUsed;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal DecoderNLS(SerializationInfo info, StreamingContext context);
    internal DecoderNLS(Encoding encoding);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    private string strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    private string strDefault;
    private int fallbackCount;
    private int fallbackIndex;
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
public abstract class System.Text.Encoder : object {
    internal EncoderFallback m_fallback;
    internal EncoderFallbackBuffer m_fallbackBuffer;
    public EncoderFallback Fallback { get; public set; }
    public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    internal void SerializeEncoder(SerializationInfo info);
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
public abstract class System.Text.EncoderFallback : object {
    internal bool bIsMicrosoftBestFitFallback;
    private static EncoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) replacementFallback;
    private static EncoderFallback modreq(System.Runtime.CompilerServices.IsVolatile) exceptionFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    private static object get_InternalSyncObject();
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    internal Char* charStart;
    internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    private static int iMaxRecursion;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal char InternalGetNextChar();
    internal virtual bool InternalFallback(char ch, Char*& chars);
    internal void ThrowLastCharRecursive(int charRecursive);
}
public class System.Text.EncoderFallbackException : ArgumentException {
    private char charUnknown;
    private char charUnknownHigh;
    private char charUnknownLow;
    private int index;
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(SerializationInfo info, StreamingContext context);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char charLeftOver;
    protected Encoding m_encoding;
    protected bool m_mustFlush;
    internal bool m_throwOnOverflow;
    internal int m_charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal EncoderNLS(SerializationInfo info, StreamingContext context);
    internal EncoderNLS(Encoding encoding);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    private string strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    private string strDefault;
    private int fallbackCount;
    private int fallbackIndex;
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
}
public abstract class System.Text.Encoding : object {
    private static UTF8EncodingSealed s_defaultEncoding;
    internal static int MIMECONTF_MAILNEWS;
    internal static int MIMECONTF_BROWSER;
    internal static int MIMECONTF_SAVABLE_MAILNEWS;
    internal static int MIMECONTF_SAVABLE_BROWSER;
    private static int CodePageDefault;
    private static int CodePageNoOEM;
    private static int CodePageNoMac;
    private static int CodePageNoThread;
    private static int CodePageNoSymbol;
    private static int CodePageUnicode;
    private static int CodePageBigEndian;
    private static int CodePageWindows1252;
    private static int CodePageMacGB2312;
    private static int CodePageGB2312;
    private static int CodePageMacKorean;
    private static int CodePageDLLKorean;
    private static int ISO2022JP;
    private static int ISO2022JPESC;
    private static int ISO2022JPSISO;
    private static int ISOKorean;
    private static int ISOSimplifiedCN;
    private static int EUCJP;
    private static int ChineseHZ;
    private static int DuplicateEUCCN;
    private static int EUCCN;
    private static int EUCKR;
    internal static int CodePageASCII;
    internal static int ISO_8859_1;
    private static int ISCIIAssemese;
    private static int ISCIIBengali;
    private static int ISCIIDevanagari;
    private static int ISCIIGujarathi;
    private static int ISCIIKannada;
    private static int ISCIIMalayalam;
    private static int ISCIIOriya;
    private static int ISCIIPanjabi;
    private static int ISCIITamil;
    private static int ISCIITelugu;
    private static int GB18030;
    private static int ISO_8859_8I;
    private static int ISO_8859_8_Visual;
    private static int ENC50229;
    private static int CodePageUTF7;
    private static int CodePageUTF8;
    private static int CodePageUTF32;
    private static int CodePageUTF32BE;
    internal int m_codePage;
    internal CodePageDataItem dataItem;
    internal bool m_deserializedFromEverett;
    [OptionalFieldAttribute]
private bool m_isReadOnly;
    [OptionalFieldAttribute]
internal EncoderFallback encoderFallback;
    [OptionalFieldAttribute]
internal DecoderFallback decoderFallback;
    public static Encoding Default { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsSingleByte { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public DecoderFallback DecoderFallback { get; public set; }
    public bool IsReadOnly { get; }
    public static Encoding ASCII { get; }
    private static Encoding Latin1 { get; }
    public int CodePage { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    private static Encoding BigEndianUTF32 { get; }
    protected Encoding(int codePage);
    protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    private static Encoding();
    public static Encoding get_Default();
    internal virtual void SetDefaultFallbacks();
    internal void OnDeserializing();
    internal void OnDeserialized();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    internal void DeserializeEncoding(SerializationInfo info, StreamingContext context);
    internal void SerializeEncoding(SerializationInfo info, StreamingContext context);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public static void RegisterProvider(EncodingProvider provider);
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    private void GetDataItem();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public virtual object Clone();
    public bool get_IsReadOnly();
    public static Encoding get_ASCII();
    private static Encoding get_Latin1();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public int GetByteCount(string s, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    [CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    public virtual int get_CodePage();
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    private static Encoding get_BigEndianUTF32();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal virtual Char[] GetBestFitUnicodeToBytesData();
    internal virtual Char[] GetBestFitBytesToUnicodeData();
    internal void ThrowBytesOverflow();
    internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    internal void ThrowCharsOverflow();
    internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
}
public class System.Text.EncodingInfo : object {
    private int iCodePage;
    private string strEncodingName;
    private string strDisplayName;
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    internal EncodingInfo(int codePage, string name, string displayName);
    public int get_CodePage();
    public string get_Name();
    public string get_DisplayName();
    public Encoding GetEncoding();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal abstract class System.Text.EncodingNLS : Encoding {
    protected EncodingNLS(int codePage);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
public abstract class System.Text.EncodingProvider : object {
    private static object s_InternalSyncObject;
    private static EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    private static EncodingProvider();
    public abstract virtual Encoding GetEncoding(string name);
    public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    internal static void AddProvider(EncodingProvider provider);
    internal static Encoding GetEncodingFromProvider(int codepage);
    internal static Encoding GetEncodingFromProvider(string encodingName);
    internal static Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec);
    internal static Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec);
}
internal enum System.Text.ExtendedNormalizationForms : Enum {
    public int value__;
    public static ExtendedNormalizationForms FormC;
    public static ExtendedNormalizationForms FormD;
    public static ExtendedNormalizationForms FormKC;
    public static ExtendedNormalizationForms FormKD;
    public static ExtendedNormalizationForms FormIdna;
    public static ExtendedNormalizationForms FormCDisallowUnassigned;
    public static ExtendedNormalizationForms FormDDisallowUnassigned;
    public static ExtendedNormalizationForms FormKCDisallowUnassigned;
    public static ExtendedNormalizationForms FormKDDisallowUnassigned;
    public static ExtendedNormalizationForms FormIdnaDisallowUnassigned;
}
internal class System.Text.InternalDecoderBestFitFallback : DecoderFallback {
    internal Encoding encoding;
    internal Char[] arrayBestFit;
    internal char cReplacement;
    public int MaxCharCount { get; }
    internal InternalDecoderBestFitFallback(Encoding encoding);
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
    internal char cBestFit;
    internal int iCount;
    internal int iSize;
    private InternalDecoderBestFitFallback oFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalDecoderBestFitFallbackBuffer(InternalDecoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    private char TryBestFit(Byte[] bytesCheck);
}
internal class System.Text.InternalEncoderBestFitFallback : EncoderFallback {
    internal Encoding encoding;
    internal Char[] arrayBestFit;
    public int MaxCharCount { get; }
    internal InternalEncoderBestFitFallback(Encoding encoding);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
    private char cBestFit;
    private InternalEncoderBestFitFallback oFallback;
    private int iCount;
    private int iSize;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalEncoderBestFitFallbackBuffer(InternalEncoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    private char TryBestFit(char cUnknown);
}
internal class System.Text.Latin1Encoding : EncodingNLS {
    internal static Latin1Encoding s_default;
    private static Char[] arrayCharBestFit;
    public bool IsSingleByte { get; }
    internal Latin1Encoding(SerializationInfo info, StreamingContext context);
    private static Latin1Encoding();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    internal virtual Char[] GetBestFitUnicodeToBytesData();
}
internal class System.Text.Normalization : object {
    internal static bool IsNormalized(string strInput, NormalizationForm normForm);
    internal static string Normalize(string strInput, NormalizationForm normForm);
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
[DefaultMemberAttribute("Chars")]
public class System.Text.StringBuilder : object {
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    internal static int DefaultCapacity;
    private static string CapacityField;
    private static string MaxCapacityField;
    private static string StringValueField;
    private static string ThreadIDField;
    internal static int MaxChunkSize;
    private static int Index_Limit;
    private static int Width_Limit;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    public StringBuilder(int capacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    private StringBuilder(SerializationInfo info, StreamingContext context);
    private StringBuilder(StringBuilder from);
    private StringBuilder(int size, int maxCapacity, StringBuilder previousBlock);
    internal void ReplaceBufferInternal(Char* newBuffer, int newLength);
    internal void ReplaceBufferAnsiInternal(SByte* newBuffer, int newLength);
    internal void InternalCopy(IntPtr dest, int len);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [ConditionalAttribute("_DEBUG")]
private void VerifyClassInvariant();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(string value);
    private void AppendHelper(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    public StringBuilder Append(object value);
    public StringBuilder Append(Char[] value);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, T[] values);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    private static void FormatError();
    internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public StringBuilder Replace(string oldValue, string newValue);
    public bool Equals(StringBuilder sb);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    private void Insert(int index, Char* value, int valueCount);
    private void ReplaceAllInChunk(Int32[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value);
    private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
    private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char* value, int count);
    private static void ThreadSafeCopy(Char* sourcePtr, Char[] destination, int destinationIndex, int count);
    private static void ThreadSafeCopy(Char[] source, int sourceIndex, Char[] destination, int destinationIndex, int count);
    private StringBuilder FindChunkForIndex(int index);
    private StringBuilder FindChunkForByte(int byteIndex);
    private StringBuilder Next(StringBuilder chunk);
    private void ExpandByABlock(int minBlockCharCount);
    private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doneMoveFollowingChars);
    private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk);
}
internal static class System.Text.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    [ThreadStaticAttribute]
private static StringBuilder CachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.Text.UnicodeEncoding : Encoding {
    internal static UnicodeEncoding s_bigEndianDefault;
    internal static UnicodeEncoding s_littleEndianDefault;
    [OptionalFieldAttribute]
internal bool isThrowException;
    internal bool bigEndian;
    internal bool byteOrderMark;
    public static int CharSize;
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    private static UnicodeEncoding();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF32Encoding : Encoding {
    internal static UTF32Encoding s_default;
    internal static UTF32Encoding s_bigEndianDefault;
    private bool _emitUTF32ByteOrderMark;
    private bool _isThrowException;
    private bool _bigEndian;
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    private static UTF32Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private UInt32 GetSurrogate(char cHigh, char cLow);
    private char GetHighSurrogate(UInt32 iChar);
    private char GetLowSurrogate(UInt32 iChar);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.UTF7Encoding : Encoding {
    private static string base64Chars;
    private static string directChars;
    private static string optionalChars;
    internal static UTF7Encoding s_default;
    private Byte[] base64Bytes;
    private SByte[] base64Values;
    private Boolean[] directEncode;
    [OptionalFieldAttribute]
private bool m_allowOptionals;
    private static int UTF7_CODEPAGE;
    public UTF7Encoding(bool allowOptionals);
    private static UTF7Encoding();
    private void MakeTables();
    internal virtual void SetDefaultFallbacks();
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
public class System.Text.UTF8Encoding : Encoding {
    private static int UTF8_CODEPAGE;
    internal static UTF8EncodingSealed s_default;
    private bool _emitUTF8Identifier;
    private bool _isThrowException;
    private static int FinalByte;
    private static int SupplimentarySeq;
    private static int ThreeByteSeq;
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    private static UTF8Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
    private static bool InRange(int ch, int start, int end);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private bool FallbackInvalidByteSequence(Byte*& pSrc, int ch, DecoderFallbackBuffer fallback, Char*& pTarget);
    private int FallbackInvalidByteSequence(Byte* pSrc, int ch, DecoderFallbackBuffer fallback);
    private Byte[] GetBytesUnknown(Byte*& pSrc, int ch);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Threading._IOCompletionCallback : object {
    private IOCompletionCallback _ioCompletionCallback;
    private ExecutionContext _executionContext;
    private UInt32 _errorCode;
    private UInt32 _numBytes;
    private NativeOverlapped* _pOVERLAP;
    internal static ContextCallback _ccb;
    internal _IOCompletionCallback(IOCompletionCallback ioCompletionCallback);
    private static _IOCompletionCallback();
    internal static void IOCompletionCallback_Context(object state);
    internal static void PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
}
internal static class System.Threading._ThreadPoolWaitCallback : object {
    internal static bool PerformWaitCallback();
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    private WaitOrTimerCallback _waitOrTimerCallback;
    private ExecutionContext _executionContext;
    private object _state;
    private static ContextCallback _ccbt;
    private static ContextCallback _ccbf;
    internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool compressStack);
    private static _ThreadPoolWaitOrTimerCallback();
    private static void WaitOrTimerCallback_Context_t(object state);
    private static void WaitOrTimerCallback_Context_f(object state);
    private static void WaitOrTimerCallback_Context(object state, bool timedOut);
    internal static void PerformWaitOrTimerCallback(object state, bool timedOut);
}
public class System.Threading.AbandonedMutexException : SystemException {
    private int _mutexIndex;
    private Mutex _mutex;
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    private void SetupException(int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private Thread _thread;
    internal void Initialize(Thread currentThread);
    public void Undo();
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
public class System.Threading.AsyncLocal`1 : object {
    private Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler;
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
    private sealed virtual override void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
}
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadContextChanged>k__BackingField;
    public T PreviousValue { get; private set; }
    public T CurrentValue { get; private set; }
    public bool ThreadContextChanged { get; private set; }
    internal AsyncLocalValueChangedArgs`1(T previousValue, T currentValue, bool contextChanged);
    [CompilerGeneratedAttribute]
public T get_PreviousValue();
    [CompilerGeneratedAttribute]
private void set_PreviousValue(T value);
    [CompilerGeneratedAttribute]
public T get_CurrentValue();
    [CompilerGeneratedAttribute]
private void set_CurrentValue(T value);
    [CompilerGeneratedAttribute]
public bool get_ThreadContextChanged();
    [CompilerGeneratedAttribute]
private void set_ThreadContextChanged(bool value);
}
internal static class System.Threading.AsyncLocalValueMap : object {
    [CompilerGeneratedAttribute]
private static IAsyncLocalValueMap <Empty>k__BackingField;
    public static IAsyncLocalValueMap Empty { get; }
    private static AsyncLocalValueMap();
    [CompilerGeneratedAttribute]
public static IAsyncLocalValueMap get_Empty();
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
internal class System.Threading.CancellationCallbackCoreWorkArguments : ValueType {
    internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> m_currArrayFragment;
    internal int m_currArrayIndex;
    public CancellationCallbackCoreWorkArguments(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
}
internal class System.Threading.CancellationCallbackInfo : object {
    internal Action`1<object> Callback;
    internal object StateForCallback;
    internal ExecutionContext TargetExecutionContext;
    internal CancellationTokenSource CancellationTokenSource;
    private static ContextCallback s_executionContextCallback;
    internal CancellationCallbackInfo(Action`1<object> callback, object stateForCallback, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource);
    internal void ExecuteCallback();
    private static void ExecutionContextCallback(object obj);
}
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource m_source;
    private static Action`1<object> s_ActionToActionObjShunt;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    private static void ActionToActionObjShunt(object obj);
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
    private CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
    public bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    internal void ThrowIfSourceDisposed();
    private void ThrowOperationCanceledException();
    private static void ThrowObjectDisposedException();
    private void InitializeDefaultSource();
}
public class System.Threading.CancellationTokenRegistration : ValueType {
    private CancellationCallbackInfo m_callbackInfo;
    private SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo;
    internal CancellationTokenRegistration(CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo);
    [FriendAccessAllowedAttribute]
internal bool TryDeregister();
    public sealed virtual void Dispose();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
}
public class System.Threading.CancellationTokenSource : object {
    private static CancellationTokenSource _staticSource_Set;
    private static CancellationTokenSource _staticSource_NotCancelable;
    private static int s_nLists;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_kernelEvent;
    private SparselyPopulatedArray`1[] modreq(System.Runtime.CompilerServices.IsVolatile) m_registeredCallbacksLists;
    private static int CANNOT_BE_CANCELED;
    private static int NOT_CANCELED;
    private static int NOTIFYING;
    private static int NOTIFYINGCOMPLETE;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_threadIDExecutingCallbacks;
    private bool m_disposed;
    private CancellationCallbackInfo modreq(System.Runtime.CompilerServices.IsVolatile) m_executingCallback;
    private Timer modreq(System.Runtime.CompilerServices.IsVolatile) m_timer;
    private static TimerCallback s_timerCallback;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal bool IsDisposed { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal bool CanBeCanceled { get; }
    internal WaitHandle WaitHandle { get; }
    internal CancellationCallbackInfo ExecutingCallback { get; }
    private CancellationTokenSource(bool set);
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal bool get_IsDisposed();
    internal void set_ThreadIDExecutingCallbacks(int value);
    internal int get_ThreadIDExecutingCallbacks();
    public CancellationToken get_Token();
    internal bool get_CanBeCanceled();
    internal WaitHandle get_WaitHandle();
    internal CancellationCallbackInfo get_ExecutingCallback();
    private void InitializeWithTimer(int millisecondsDelay);
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    private static void TimerCallbackLogic(object obj);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ThrowIfDisposed();
    private static void ThrowObjectDisposedException();
    internal static CancellationTokenSource InternalGetStaticSource(bool set);
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    private void CancellationCallbackCoreWork_OnSyncContext(object obj);
    private void CancellationCallbackCoreWork(CancellationCallbackCoreWorkArguments args);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    internal static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo);
}
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.DeferredDisposableLifetime`1 : ValueType {
    private int _count;
    public bool AddRef(T obj);
    public void Release(T obj);
    public void Dispose(T obj);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
[ComVisibleAttribute("True")]
public class System.Threading.EventWaitHandle : WaitHandle {
    public EventWaitHandle(bool initialState, EventResetMode mode);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    internal EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew, EventWaitHandleSecurity eventSecurity);
    private EventWaitHandle(SafeWaitHandle handle);
    public static EventWaitHandle OpenExisting(string name);
    internal static EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights);
    public static bool TryOpenExisting(string name, EventWaitHandle& result);
    private static OpenExistingResult OpenExistingWorker(string name, EventWaitHandleRights rights, EventWaitHandle& result);
    public bool Reset();
    public bool Set();
}
public class System.Threading.ExecutionContext : object {
    internal static ExecutionContext Default;
    private IAsyncLocalValueMap m_localValues;
    private IAsyncLocal[] m_localChangeNotifications;
    private bool m_isFlowSuppressed;
    private ExecutionContext(IAsyncLocalValueMap localValues, IAsyncLocal[] localChangeNotifications, bool isFlowSuppressed);
    private ExecutionContext(SerializationInfo info, StreamingContext context);
    private static ExecutionContext();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static ExecutionContext Capture();
    private ExecutionContext ShallowClone(bool isFlowSuppressed);
    public static AsyncFlowControl SuppressFlow();
    public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void Restore(Thread currentThread, ExecutionContext executionContext);
    internal static void EstablishCopyOnWriteScope(Thread currentThread, ExecutionContextSwitcher& ecsw);
    private static void OnContextChanged(ExecutionContext previous, ExecutionContext current);
    internal static object GetLocalValue(IAsyncLocal local);
    internal static void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications);
    public ExecutionContext CreateCopy();
    public sealed virtual void Dispose();
}
internal class System.Threading.ExecutionContextSwitcher : ValueType {
    internal ExecutionContext m_ec;
    internal SynchronizationContext m_sc;
    internal void Undo(Thread currentThread);
}
internal class System.Threading.FastRandom : ValueType {
    private UInt32 _w;
    private UInt32 _x;
    private UInt32 _y;
    private UInt32 _z;
    public FastRandom(int seed);
    public int Next(int maxValue);
}
internal interface System.Threading.IAsyncLocal {
    public abstract virtual void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
}
internal interface System.Threading.IAsyncLocalValueMap {
    public abstract virtual bool TryGetValue(IAsyncLocal key, Object& value);
    public abstract virtual IAsyncLocalValueMap Set(IAsyncLocal key, object value);
}
internal interface System.Threading.IDeferredDisposable {
    public abstract virtual void OnFinalRelease(bool disposed);
}
public static class System.Threading.Interlocked : object {
    public static int Increment(Int32& location);
    public static long Increment(Int64& location);
    public static int Decrement(Int32& location);
    public static long Decrement(Int64& location);
    public static int Exchange(Int32& location1, int value);
    public static long Exchange(Int64& location1, long value);
    public static float Exchange(Single& location1, float value);
    public static double Exchange(Double& location1, double value);
    public static object Exchange(Object& location1, object value);
    public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    public static T Exchange(T& location1, T value);
    private static void _Exchange(TypedReference location1, TypedReference value);
    public static int CompareExchange(Int32& location1, int value, int comparand);
    public static long CompareExchange(Int64& location1, long value, long comparand);
    public static float CompareExchange(Single& location1, float value, float comparand);
    public static double CompareExchange(Double& location1, double value, double comparand);
    public static object CompareExchange(Object& location1, object value, object comparand);
    public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    public static T CompareExchange(T& location1, T value, T comparand);
    private static void _CompareExchange(TypedReference location1, TypedReference value, object comparand);
    internal static int CompareExchange(Int32& location1, int value, int comparand, Boolean& succeeded);
    internal static int ExchangeAdd(Int32& location1, int value);
    internal static long ExchangeAdd(Int64& location1, long value);
    public static int Add(Int32& location1, int value);
    public static long Add(Int64& location1, long value);
    public static long Read(Int64& location);
    public static void MemoryBarrier();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _MemoryBarrierProcessWide();
    public static void MemoryBarrierProcessWide();
}
internal class System.Threading.InternalCrossContextDelegate : MulticastDelegate {
    public InternalCrossContextDelegate(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal interface System.Threading.IThreadPoolWorkItem {
    public abstract virtual void ExecuteWorkItem();
    public abstract virtual void MarkAborted(ThreadAbortException tae);
}
internal static class System.Threading.LazyHelpers`1 : object {
    internal static Func`1<T> s_activatorFactorySelector;
    private static LazyHelpers`1();
    private static T ActivatorFactorySelector();
}
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static object EnsureLockInitialized(Object& syncLock);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Object& syncLock, Func`1<T> valueFactory);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
    protected LockRecursionException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private static int DEFAULT_SPIN_SP;
    private static int DEFAULT_SPIN_MP;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static int SignalledState_BitMask;
    private static int SignalledState_ShiftCount;
    private static int Dispose_BitMask;
    private static int SpinCountState_BitMask;
    private static int SpinCountState_ShiftCount;
    private static int SpinCountState_MaxValue;
    private static int NumWaitersState_BitMask;
    private static int NumWaitersState_ShiftCount;
    private static int NumWaitersState_MaxValue;
    private static Action`1<object> s_cancellationTokenCallback;
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private bool LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
}
public static class System.Threading.Monitor : object {
    public static void Enter(object obj);
    public static void Enter(object obj, Boolean& lockTaken);
    private static void ThrowLockTakenException();
    private static void ReliableEnter(object obj, Boolean& lockTaken);
    public static void Exit(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    private static int MillisecondsTimeoutFromTimeSpan(TimeSpan timeout);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    private static void ReliableEnterTimeout(object obj, int timeout, Boolean& lockTaken);
    public static bool IsEntered(object obj);
    private static bool IsEnteredNative(object obj);
    private static bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
    public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj);
    private static void ObjPulse(object obj);
    public static void Pulse(object obj);
    private static void ObjPulseAll(object obj);
    public static void PulseAll(object obj);
}
public class System.Threading.Mutex : WaitHandle {
    private static bool dummyBool;
    public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    internal Mutex(bool initiallyOwned, string name, Boolean& createdNew, MutexSecurity mutexSecurity);
    public Mutex(bool initiallyOwned, string name);
    public Mutex(bool initiallyOwned);
    private Mutex(SafeWaitHandle handle);
    internal void CreateMutexWithGuaranteedCleanup(bool initiallyOwned, string name, Boolean& createdNew, SECURITY_ATTRIBUTES secAttrs);
    private void MutexCleanupCode(object userData, bool exceptionThrown);
    public static Mutex OpenExisting(string name);
    internal static Mutex OpenExisting(string name, MutexRights rights);
    public static bool TryOpenExisting(string name, Mutex& result);
    private static OpenExistingResult OpenExistingWorker(string name, MutexRights rights, Mutex& result);
    public void ReleaseMutex();
    private static int CreateMutexHandle(bool initiallyOwned, string name, SECURITY_ATTRIBUTES securityAttribute, SafeWaitHandle& mutexHandle);
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
public class System.Threading.Overlapped : object {
    private OverlappedData m_overlappedData;
    private static PinnableBufferCache s_overlappedDataCache;
    public IAsyncResult AsyncResult { get; public set; }
    public int OffsetLow { get; public set; }
    public int OffsetHigh { get; public set; }
    [ObsoleteAttribute("This property is not 64-bit compatible.  Use EventHandleIntPtr instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public int EventHandle { get; public set; }
    public IntPtr EventHandleIntPtr { get; public set; }
    internal _IOCompletionCallback iocbHelper { get; }
    internal IOCompletionCallback UserCallback { get; }
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [ObsoleteAttribute("This constructor is not 64-bit compatible.  Use the constructor that takes an IntPtr for the event handle.  http://go.microsoft.com/fwlink/?linkid=14202")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    private static Overlapped();
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    internal _IOCompletionCallback get_iocbHelper();
    internal IOCompletionCallback get_UserCallback();
    [ObsoleteAttribute("This method is not safe.  Use Pack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [ObsoleteAttribute("This method is not safe.  Use UnsafePack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
}
internal class System.Threading.OverlappedData : object {
    internal IAsyncResult m_asyncResult;
    internal IOCompletionCallback m_iocb;
    internal _IOCompletionCallback m_iocbHelper;
    internal Overlapped m_overlapped;
    private object m_userObject;
    private IntPtr m_pinSelf;
    private IntPtr m_userObjectInternal;
    private int m_AppDomainId;
    private byte m_isArray;
    private byte m_toBeCleaned;
    internal NativeOverlapped m_nativeOverlapped;
    internal IntPtr UserHandle { get; internal set; }
    internal void ReInitialize();
    internal NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    internal NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    internal IntPtr get_UserHandle();
    internal void set_UserHandle(IntPtr value);
    private NativeOverlapped* AllocateNativeOverlapped();
    internal static void FreeNativeOverlapped(NativeOverlapped* nativeOverlappedPtr);
    internal static OverlappedData GetOverlappedFromNative(NativeOverlapped* nativeOverlappedPtr);
    internal static void CheckVMForIOPacket(NativeOverlapped*& pOVERLAP, UInt32& errorCode, UInt32& numBytes);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.PlatformHelper : object {
    private static int PROCESSOR_COUNT_REFRESH_INTERVAL_MS;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_lastProcessorCountRefreshTicks;
    internal static int ProcessorCount { get; }
    internal static bool IsSingleProcessor { get; }
    internal static int get_ProcessorCount();
    internal static bool get_IsSingleProcessor();
}
public class System.Threading.PreAllocatedOverlapped : object {
    internal ThreadPoolBoundHandleOverlapped _overlapped;
    private DeferredDisposableLifetime`1<PreAllocatedOverlapped> _lifetime;
    [CLSCompliantAttribute("False")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    internal bool AddRef();
    internal void Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.QueueUserWorkItemCallback : object {
    private WaitCallback callback;
    private ExecutionContext context;
    private object state;
    internal static ContextCallback ccb;
    internal QueueUserWorkItemCallback(WaitCallback waitCallback, object stateObj, ExecutionContext ec);
    private static QueueUserWorkItemCallback();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    private static void WaitCallback_Context(object state);
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext : object {
    private WaitCallback callback;
    private object state;
    internal static ContextCallback ccb;
    internal QueueUserWorkItemCallbackDefaultContext(WaitCallback waitCallback, object stateObj);
    private static QueueUserWorkItemCallbackDefaultContext();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    private static void WaitCallback_Context(object state);
}
internal class System.Threading.ReaderWriterCount : object {
    public long lockID;
    public int readercount;
    public int writercount;
    public int upgradecount;
    public ReaderWriterCount next;
}
public class System.Threading.ReaderWriterLockSlim : object {
    private bool _fIsReentrant;
    private int _myLock;
    private static int LockSpinCycles;
    private static int LockSpinCount;
    private static int LockSleep0Count;
    private UInt32 _numWriteWaiters;
    private UInt32 _numReadWaiters;
    private UInt32 _numWriteUpgradeWaiters;
    private UInt32 _numUpgradeWaiters;
    private bool _fNoWaiters;
    private int _upgradeLockOwnerId;
    private int _writeLockOwnerId;
    private EventWaitHandle _writeEvent;
    private EventWaitHandle _readEvent;
    private EventWaitHandle _upgradeEvent;
    private EventWaitHandle _waitUpgradeEvent;
    private static long s_nextLockID;
    private long _lockID;
    [ThreadStaticAttribute]
private static ReaderWriterCount t_rwc;
    private bool _fUpgradeThreadHoldingRead;
    private static int MaxSpinCount;
    private UInt32 _owners;
    private static UInt32 WRITER_HELD;
    private static UInt32 WAITING_WRITERS;
    private static UInt32 WAITING_UPGRADER;
    private static UInt32 MAX_READER;
    private static UInt32 READER_MASK;
    private bool _fDisposed;
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    private void InitializeThreadCounts();
    private static bool IsRWEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRWCount(bool dontAllocate);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(EventWaitHandle& waitEvent, bool makeAutoResetEvent);
    private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, bool isWriteWaiter);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private void ExitAndWakeUpAppropriateReadWaiters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private void EnterMyLock();
    private void EnterMyLockSpin();
    private void ExitMyLock();
    private static void SpinWait(int SpinCount);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    private RegisteredWaitHandleSafe internalRegisteredWait;
    internal void SetHandle(IntPtr handle);
    internal void SetWaitObject(WaitHandle waitObject);
    public bool Unregister(WaitHandle waitObject);
}
internal class System.Threading.RegisteredWaitHandleSafe : CriticalFinalizerObject {
    private IntPtr registeredWaitHandle;
    private WaitHandle m_internalWaitObject;
    private bool bReleaseNeeded;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private static IntPtr InvalidHandle { get; }
    private static IntPtr get_InvalidHandle();
    internal IntPtr GetHandle();
    internal void SetHandle(IntPtr handle);
    internal void SetWaitObject(WaitHandle waitObject);
    internal bool Unregister(WaitHandle waitObject);
    private bool ValidHandle();
    protected virtual override void Finalize();
    private static void WaitHandleCleanupNative(IntPtr handle);
    private static bool UnregisterWaitNative(IntPtr handle, SafeHandle waitObject);
}
public class System.Threading.Semaphore : WaitHandle {
    public Semaphore(int initialCount, int maximumCount);
    public Semaphore(int initialCount, int maximumCount, string name);
    public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private Semaphore(SafeWaitHandle handle);
    private static SafeWaitHandle CreateSemaphone(int initialCount, int maximumCount, string name);
    public static Semaphore OpenExisting(string name);
    public static bool TryOpenExisting(string name, Semaphore& result);
    private static OpenExistingResult OpenExistingWorker(string name, Semaphore& result);
    public int Release();
    public int Release(int releaseCount);
}
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
public class System.Threading.SemaphoreSlim : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_waitCount;
    private object m_lockObj;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle;
    private TaskNode m_asyncHead;
    private TaskNode m_asyncTail;
    private static Task`1<bool> s_trueTask;
    private static Task`1<bool> s_falseTask;
    private static int NO_MAXIMUM;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    private TaskNode CreateAndAddAsyncWaiter();
    private bool RemoveAsyncWaiter(TaskNode task);
    [AsyncStateMachineAttribute("System.Threading.SemaphoreSlim/<WaitUntilCountOrTimeoutAsync>d__32")]
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    private static void QueueWaiterTask(TaskNode waiterTask);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
    private static string GetResourceString(string str);
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.SparselyPopulatedArray`1 : object {
    private SparselyPopulatedArrayFragment`1<T> m_head;
    private SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    internal SparselyPopulatedArrayFragment`1<T> Tail { get; }
    internal SparselyPopulatedArray`1(int initialSize);
    internal SparselyPopulatedArrayFragment`1<T> get_Tail();
    internal SparselyPopulatedArrayAddInfo`1<T> Add(T element);
}
internal class System.Threading.SparselyPopulatedArrayAddInfo`1 : ValueType {
    private SparselyPopulatedArrayFragment`1<T> m_source;
    private int m_index;
    internal SparselyPopulatedArrayFragment`1<T> Source { get; }
    internal int Index { get; }
    internal SparselyPopulatedArrayAddInfo`1(SparselyPopulatedArrayFragment`1<T> source, int index);
    internal SparselyPopulatedArrayFragment`1<T> get_Source();
    internal int get_Index();
}
[DefaultMemberAttribute("Item")]
internal class System.Threading.SparselyPopulatedArrayFragment`1 : object {
    internal T[] m_elements;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_freeCount;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_next;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_prev;
    internal T Item { get; }
    internal int Length { get; }
    internal SparselyPopulatedArrayFragment`1<T> Prev { get; }
    internal SparselyPopulatedArrayFragment`1(int size);
    internal SparselyPopulatedArrayFragment`1(int size, SparselyPopulatedArrayFragment`1<T> prev);
    internal T get_Item(int index);
    internal int get_Length();
    internal SparselyPopulatedArrayFragment`1<T> get_Prev();
    internal T SafeAtomicRemove(int index, T expectedElement);
}
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
public class System.Threading.SpinLock : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_owner;
    private static int SPINNING_FACTOR;
    private static int SLEEP_ONE_FREQUENCY;
    private static int SLEEP_ZERO_FREQUENCY;
    private static int TIMEOUT_CHECK_FREQUENCY;
    private static int LOCK_ID_DISABLE_MASK;
    private static int LOCK_ANONYMOUS_OWNED;
    private static int WAITERS_MASK;
    private static int ID_DISABLED_AND_ANONYMOUS_OWNED;
    private static int LOCK_UNOWNED;
    private static int MAXIMUM_WAITERS;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static SpinLock();
    private int CompareExchange(Int32& location, int value, int comparand, Boolean& success);
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken);
    public void Exit();
    public void Exit(bool useMemoryBarrier);
    private void ExitSlowPath(bool useMemoryBarrier);
    public bool get_IsHeld();
    public bool get_IsHeldByCurrentThread();
    public bool get_IsThreadOwnerTrackingEnabled();
}
public class System.Threading.SpinWait : ValueType {
    internal static int YIELD_THRESHOLD;
    internal static int SLEEP_0_EVERY_HOW_MANY_TIMES;
    internal static int SLEEP_1_EVERY_HOW_MANY_TIMES;
    private int m_count;
    public int Count { get; }
    public bool NextSpinWillYield { get; }
    public int get_Count();
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal enum System.Threading.StackCrawlMark : Enum {
    public int value__;
    public static StackCrawlMark LookForMe;
    public static StackCrawlMark LookForMyCaller;
    public static StackCrawlMark LookForMyCallersCaller;
    public static StackCrawlMark LookForThread;
}
public class System.Threading.SynchronizationContext : object {
    private SynchronizationContextProperties _props;
    private static Type s_cachedPreparedType1;
    private static Type s_cachedPreparedType2;
    private static Type s_cachedPreparedType3;
    private static Type s_cachedPreparedType4;
    private static Type s_cachedPreparedType5;
    private static WinRTSynchronizationContextFactoryBase s_winRTContextFactory;
    public static SynchronizationContext Current { get; }
    internal static SynchronizationContext CurrentNoFlow { get; }
    protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [CLSCompliantAttribute("False")]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
private static int WaitHelperNative(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    public static void SetSynchronizationContext(SynchronizationContext syncContext);
    public static SynchronizationContext get_Current();
    [FriendAccessAllowedAttribute]
internal static SynchronizationContext get_CurrentNoFlow();
    private static SynchronizationContext GetWinRTContext();
    private static WinRTSynchronizationContextFactoryBase GetWinRTSynchronizationContextFactory();
    [SuppressUnmanagedCodeSecurityAttribute]
private static object GetWinRTDispatcherForCurrentThread();
    public virtual SynchronizationContext CreateCopy();
    private static int InvokeWaitMethodHelper(SynchronizationContext syncContext, IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
}
[FlagsAttribute]
internal enum System.Threading.SynchronizationContextProperties : Enum {
    public int value__;
    public static SynchronizationContextProperties None;
    public static SynchronizationContextProperties RequireWaitNotification;
}
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> m_tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
[FriendAccessAllowedAttribute]
internal enum System.Threading.Tasks.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Error;
    public static AsyncCausalityStatus Started;
}
[FriendAccessAllowedAttribute]
internal static class System.Threading.Tasks.AsyncCausalityTracer : object {
    private static Guid s_PlatformId;
    private static CausalitySource s_CausalitySource;
    private static IAsyncCausalityTracerStatics s_TracerFactory;
    private static Loggers f_LoggingOn;
    [FriendAccessAllowedAttribute]
internal static bool LoggingOn { get; }
    private static AsyncCausalityTracer();
    internal static void EnableToETW(bool enabled);
    [FriendAccessAllowedAttribute]
internal static bool get_LoggingOn();
    private static void TracingStatusChangedHandler(object sender, TracingStatusChangedEventArgs args);
    [FriendAccessAllowedAttribute]
internal static void TraceOperationCreation(CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext);
    [FriendAccessAllowedAttribute]
internal static void TraceOperationCompletion(CausalityTraceLevel traceLevel, int taskId, AsyncCausalityStatus status);
    internal static void TraceOperationRelation(CausalityTraceLevel traceLevel, int taskId, CausalityRelation relation);
    internal static void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, int taskId, CausalitySynchronousWork work);
    internal static void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work);
    private static void LogAndDisable(Exception ex);
    private static ulong GetOperationId(UInt32 taskId);
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    private ExecutionContext m_capturedContext;
    protected Action m_action;
    protected int m_continuationId;
    private static ContextCallback s_invokeActionCallback;
    internal static bool IsValidLocationForInlining { get; }
    internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    internal virtual void Run(Task task, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    private void ExecuteWorkItemHelper();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    private static void InvokeAction(object state);
    protected static ContextCallback GetInvokeActionCallback();
    protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    internal static void RunOrScheduleAction(Action action, bool allowInlining, Task& currentTask);
    internal static void UnsafeScheduleAction(Action action, Task task);
    protected static void ThrowAsyncIfNecessary(Exception exc);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal enum System.Threading.Tasks.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum System.Threading.Tasks.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
[FriendAccessAllowedAttribute]
internal enum System.Threading.Tasks.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
internal class System.Threading.Tasks.CompletionActionInvoker : object {
    private ITaskCompletionAction m_action;
    private Task m_completingTask;
    internal CompletionActionInvoker(ITaskCompletionAction action, Task completingTask);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
}
[DebuggerDisplayAttribute("Concurrent={ConcurrentTaskCountForDebugger}, Exclusive={ExclusiveTaskCountForDebugger}, Mode={ModeForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    private ConcurrentDictionary`2<int, ProcessingMode> m_threadProcessingMapping;
    private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
    private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
    private TaskScheduler m_underlyingTaskScheduler;
    private int m_maxConcurrencyLevel;
    private int m_maxItemsPerTask;
    private int m_processingCount;
    private CompletionState m_completionState;
    private static int UNLIMITED_PROCESSING;
    private static int EXCLUSIVE_PROCESSING_SENTINEL;
    private static int DEFAULT_MAXITEMSPERTASK;
    private static int DefaultMaxConcurrencyLevel { get; }
    private object ValueLock { get; }
    public Task Completion { get; }
    private bool CompletionRequested { get; }
    private bool ReadyToComplete { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    private int ConcurrentTaskCountForDebugger { get; }
    private int ExclusiveTaskCountForDebugger { get; }
    private ProcessingMode ModeForDebugger { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    private static int get_DefaultMaxConcurrencyLevel();
    private object get_ValueLock();
    public void Complete();
    public Task get_Completion();
    private CompletionState EnsureCompletionStateInitialized();
    private bool get_CompletionRequested();
    private void RequestCompletion();
    private void CleanupStateIfCompletingAndQuiesced();
    private bool get_ReadyToComplete();
    private void CompleteTaskAsync();
    private void FaultWithTask(Task faultedTask);
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    private int get_ConcurrentTaskCountForDebugger();
    private int get_ExclusiveTaskCountForDebugger();
    private void ProcessAsyncIfNecessary(bool fairly);
    private void ProcessExclusiveTasks();
    private void ProcessConcurrentTasks();
    private ProcessingMode get_ModeForDebugger();
    [ConditionalAttribute("DEBUG")]
internal static void ContractAssertMonitorStatus(object syncObj, bool held);
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    private Task m_antecedent;
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    private Task m_antecedent;
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal static class System.Threading.Tasks.GenericDelegateCache`2 : object {
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate;
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate;
    private static GenericDelegateCache`2();
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public bool InvokeMayRunArbitraryCode { get; }
    public abstract virtual void Invoke(Task completingTask);
    public abstract virtual bool get_InvokeMayRunArbitraryCode();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
}
internal class System.Threading.Tasks.PaddingFor32 : ValueType {
}
internal static class System.Threading.Tasks.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
internal class System.Threading.Tasks.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private static int INIT_SEGMENT_SIZE;
    private static int MAX_SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
internal class System.Threading.Tasks.StackGuard : object {
    private int m_inliningDepth;
    private static int MAX_UNCHECKED_INLINING_DEPTH;
    internal bool TryBeginInliningScope();
    internal void EndInliningScope();
    private bool CheckForSufficientStack();
}
internal class System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    private TaskScheduler m_taskScheduler;
    internal StandardTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    private static SendOrPostCallback s_postCallback;
    private static ContextCallback s_postActionCallback;
    private SynchronizationContext m_syncContext;
    internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext);
    private static SynchronizationContextAwaitTaskContinuation();
    internal sealed virtual void Run(Task task, bool canInlineContinuationTask);
    private static void PostAction(object state);
    private static Action GetActionLogDelegate(int continuationId, Action action);
    private static ContextCallback GetPostActionCallback();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
public class System.Threading.Tasks.Task : object {
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    [ThreadStaticAttribute]
private static StackGuard t_stackGuard;
    internal static int s_taskIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskId;
    internal Delegate m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    private static int OptionsMask;
    internal static int TASK_STATE_STARTED;
    internal static int TASK_STATE_DELEGATE_INVOKED;
    internal static int TASK_STATE_DISPOSED;
    internal static int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT;
    internal static int TASK_STATE_CANCELLATIONACKNOWLEDGED;
    internal static int TASK_STATE_FAULTED;
    internal static int TASK_STATE_CANCELED;
    internal static int TASK_STATE_WAITING_ON_CHILDREN;
    internal static int TASK_STATE_RAN_TO_COMPLETION;
    internal static int TASK_STATE_WAITINGFORACTIVATION;
    internal static int TASK_STATE_COMPLETION_RESERVED;
    internal static int TASK_STATE_THREAD_WAS_ABORTED;
    internal static int TASK_STATE_WAIT_COMPLETION_NOTIFICATION;
    internal static int TASK_STATE_EXECUTIONCONTEXT_IS_NULL;
    internal static int TASK_STATE_TASKSCHEDULED_WAS_FIRED;
    private static int TASK_STATE_COMPLETED_MASK;
    private static int CANCELLATION_REQUESTED;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject;
    private static object s_taskCompletionSentinel;
    [FriendAccessAllowedAttribute]
internal static bool s_asyncDebuggingEnabled;
    private static Dictionary`2<int, Task> s_currentActiveTasks;
    private static object s_activeTasksLock;
    internal ContingentProperties m_contingentProperties;
    private static Action`1<object> s_taskCancelCallback;
    [CompilerGeneratedAttribute]
private static TaskFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    private static Predicate`1<Task> s_IsExceptionObservedByParentPredicate;
    private static ContextCallback s_ecCallback;
    private static Predicate`1<object> s_IsTaskContinuationNullPredicate;
    private Task ParentForDebugger { get; }
    private int StateFlagsForDebugger { get; }
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    internal bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    internal static Task InternalCurrent { get; }
    internal static StackGuard CurrentStackGuard { get; }
    public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    public static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    private Task get_ParentForDebugger();
    private int get_StateFlagsForDebugger();
    [FriendAccessAllowedAttribute]
internal static bool AddToActiveTasks(Task task);
    [FriendAccessAllowedAttribute]
internal static void RemoveFromActiveTasks(int taskId);
    internal void TaskConstructorCore(Delegate action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
    private static void TaskCancelCallback(object o);
    private string get_DebuggerDisplayMethodDescription();
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    private bool AtomicStateUpdateSlow(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    private void NotifyDebuggerOfWaitCompletion();
    internal bool MarkStarted();
    internal bool FireTaskScheduledIfNeeded(TaskScheduler ts);
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions);
    internal static int NewId();
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    internal static StackGuard get_CurrentStackGuard();
    public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized();
    internal ContingentProperties EnsureContingentPropertiesInitializedUnsafe();
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    private static bool IsCompletedMethod(int flags);
    public bool get_IsCompletedSuccessfully();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    [CompilerGeneratedAttribute]
public static TaskFactory get_Factory();
    [CompilerGeneratedAttribute]
public static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool userDelegateExecute);
    private void FinishSlow(bool userDelegateExecute);
    private void FinishStageTwo();
    internal void FinishStageThree();
    internal void NotifyParentIfPotentiallyAttachedTask();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren(ContingentProperties props);
    internal void FinishThreadAbortedTask(bool delegateRan);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    internal bool ExecuteEntry();
    internal void ExecuteEntryUnsafe();
    internal void ExecuteEntryCancellationRequestedOrCanceled();
    private void ExecuteWithThreadLocal(Task& currentTaskSlot);
    internal virtual void InnerInvoke();
    private void HandleException(Exception unhandledException);
    public TaskAwaiter GetAwaiter();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinWait(int millisecondsTimeout);
    internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    internal void FinishContinuations();
    private void RunContinuations(object continuationObject);
    private void LogFinishCompletionNotification();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action);
    private void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
    private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
    private bool AddTaskContinuation(object tc, bool addBeforeOthers);
    internal void RemoveContinuation(object continuationObject);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static void AddToList(T item, List`1& list, int initSize);
    private static bool WaitAllBlockingCore(List`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void AddExceptionsForCompletedTask(List`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    internal static Task`1<TResult> FromCancellation(OperationCanceledException exception);
    [FriendAccessAllowedAttribute]
internal static Task FromCancellation(CancellationToken cancellationToken);
    [FriendAccessAllowedAttribute]
internal static Task`1<TResult> FromCancellation(CancellationToken cancellationToken);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    private static Task InternalWhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    private static Task`1<TResult[]> InternalWhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    [FriendAccessAllowedAttribute]
internal static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    internal static Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
    private static Task GetActiveTaskFromId(int taskId);
    private static Task[] GetActiveTasks();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
public class System.Threading.Tasks.Task`1 : Task {
    internal TResult m_result;
    private static TaskFactory`1<TResult> s_Factory;
    internal static Func`2<Task`1<Task>, Task`1<TResult>> TaskWhenAnyCast;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task`1();
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    public TResult get_Result();
    internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    internal bool TrySetException(object exceptionObject);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task m_canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(Task task);
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    private void SpinUntilCompleted();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public void SetCanceled();
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool bCanInlineContinuationTask);
    protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
    internal abstract virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private static bool s_failFastOnUnobservedException;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) s_domainUnloadStarted;
    private static EventHandler modreq(System.Runtime.CompilerServices.IsVolatile) s_adUnloadEventHandler;
    private Task m_task;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions;
    private ExceptionDispatchInfo m_cancellationException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled;
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    private static TaskExceptionHolder();
    private static bool ShouldFailFastOnUnobservedException();
    private static void EnsureADUnloadCallbackRegistered();
    private static void AppDomainUnloadCallback(object sender, EventArgs e);
    protected virtual override void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject, bool representsCancellation);
    private void SetCancellationException(object exceptionObject);
    private void AddFaultException(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks);
    internal static void CommonCWAnyLogicCleanup(Task`1<Task> continuation);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[DebuggerDisplayAttribute("Id={Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers;
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId;
    private static EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException;
    private static object _unobservedTaskExceptionLockObject;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    protected internal abstract virtual void QueueTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    internal void InternalQueueTask(Task task);
    private void AddToActiveTaskSchedulers();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    protected bool TryExecuteTask(Task task);
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    internal Task[] GetScheduledTasksForDebugger();
    internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    private TaskScheduler m_scheduler;
    internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [IteratorStateMachineAttribute("System.Threading.Tasks.ThreadPoolTaskScheduler/<FilterTasksFromWorkItems>d__6")]
private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<IThreadPoolWorkItem> tpwItems);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
[EventSourceAttribute]
internal class System.Threading.Tasks.TplEtwProvider : EventSource {
    internal bool TasksSetActivityIds;
    internal bool Debug;
    private bool DebugActivityId;
    public static TplEtwProvider Log;
    private static EventKeywords ALL_KEYWORDS;
    private static int PARALLELLOOPBEGIN_ID;
    private static int PARALLELLOOPEND_ID;
    private static int PARALLELINVOKEBEGIN_ID;
    private static int PARALLELINVOKEEND_ID;
    private static int PARALLELFORK_ID;
    private static int PARALLELJOIN_ID;
    private static int TASKSCHEDULED_ID;
    private static int TASKSTARTED_ID;
    private static int TASKCOMPLETED_ID;
    private static int TASKWAITBEGIN_ID;
    private static int TASKWAITEND_ID;
    private static int AWAITTASKCONTINUATIONSCHEDULED_ID;
    private static int TASKWAITCONTINUATIONCOMPLETE_ID;
    private static int TASKWAITCONTINUATIONSTARTED_ID;
    private static int TRACEOPERATIONSTART_ID;
    private static int TRACEOPERATIONSTOP_ID;
    private static int TRACEOPERATIONRELATION_ID;
    private static int TRACESYNCHRONOUSWORKSTART_ID;
    private static int TRACESYNCHRONOUSWORKSTOP_ID;
    private static TplEtwProvider();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [EventAttribute("7")]
public void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions, int appDomain);
    [EventAttribute("8")]
public void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("9")]
public void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
    [EventAttribute("10")]
public void TaskWaitBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, TaskWaitBehavior Behavior, int ContinueWithTaskID);
    [EventAttribute("11")]
public void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("13")]
public void TaskWaitContinuationComplete(int TaskID);
    [EventAttribute("19")]
public void TaskWaitContinuationStarted(int TaskID);
    [EventAttribute("12")]
public void AwaitTaskContinuationScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ContinuwWithTaskId);
    [EventAttribute("14")]
public void TraceOperationBegin(int TaskID, string OperationName, long RelatedContext);
    [EventAttribute("16")]
public void TraceOperationRelation(int TaskID, CausalityRelation Relation);
    [EventAttribute("15")]
public void TraceOperationEnd(int TaskID, AsyncCausalityStatus Status);
    [EventAttribute("17")]
public void TraceSynchronousWorkBegin(int TaskID, CausalitySynchronousWork Work);
    [EventAttribute("18")]
public void TraceSynchronousWorkEnd(CausalitySynchronousWork Work);
    [NonEventAttribute]
public void RunningContinuation(int TaskID, object Object);
    [EventAttribute("20")]
private void RunningContinuation(int TaskID, long Object);
    [NonEventAttribute]
public void RunningContinuationList(int TaskID, int Index, object Object);
    [EventAttribute("21")]
public void RunningContinuationList(int TaskID, int Index, long Object);
    [EventAttribute("23")]
public void DebugFacilityMessage(string Facility, string Message);
    [EventAttribute("24")]
public void DebugFacilityMessage1(string Facility, string Message, string Value1);
    [EventAttribute("25")]
public void SetActivityId(Guid NewId);
    [EventAttribute("26")]
public void NewID(int TaskID);
    internal static Guid CreateGuidForTaskID(int taskID);
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    private static byte STATE_WAITING_ON_OUTER_TASK;
    private static byte STATE_WAITING_ON_INNER_TASK;
    private static byte STATE_DONE;
    private byte _state;
    private bool _lookForOce;
    public bool InvokeMayRunArbitraryCode { get; }
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
    private void InvokeCore(Task completingTask);
    private void InvokeCoreAsync(Task completingTask);
    private void ProcessCompletedOuterTask(Task task);
    private bool TrySetFromTask(Task task, bool lookForOce);
    private void ProcessInnerTask(Task task);
    public sealed virtual bool get_InvokeMayRunArbitraryCode();
}
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
internal class System.Threading.Thread : RuntimeThread {
    private ExecutionContext m_ExecutionContext;
    private SynchronizationContext m_SynchronizationContext;
    private string m_Name;
    private Delegate m_Delegate;
    private object m_ThreadStartArg;
    private IntPtr DONT_USE_InternalThread;
    private int m_Priority;
    private int m_ManagedThreadId;
    private bool m_ExecutionContextBelongsToOuterScope;
    [ThreadStaticAttribute]
internal static CultureInfo m_CurrentCulture;
    [ThreadStaticAttribute]
internal static CultureInfo m_CurrentUICulture;
    public int ManagedThreadId { get; }
    internal ExecutionContext ExecutionContext { get; internal set; }
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    public static Thread CurrentThread { get; }
    public CultureInfo CurrentUICulture { get; public set; }
    public CultureInfo CurrentCulture { get; public set; }
    public string Name { get; public set; }
    public Thread(ThreadStart start);
    internal Thread(ThreadStart start, int maxStackSize);
    public Thread(ParameterizedThreadStart start);
    internal Thread(ParameterizedThreadStart start, int maxStackSize);
    public virtual int GetHashCode();
    public int get_ManagedThreadId();
    internal ThreadHandle GetNativeHandle();
    public void Start();
    public void Start(object parameter);
    private void Start(StackCrawlMark& stackMark);
    internal ExecutionContext get_ExecutionContext();
    internal void set_ExecutionContext(ExecutionContext value);
    internal SynchronizationContext get_SynchronizationContext();
    internal void set_SynchronizationContext(SynchronizationContext value);
    private void StartInternal(StackCrawlMark& stackMark);
    internal static IntPtr InternalGetCurrentThread();
    private static void SleepInternal(int millisecondsTimeout);
    public static void Sleep(int millisecondsTimeout);
    public static void Sleep(TimeSpan timeout);
    private static void SpinWaitInternal(int iterations);
    public static void SpinWait(int iterations);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool YieldInternal();
    internal static bool Yield();
    public static Thread get_CurrentThread();
    [ReliabilityContractAttribute("3", "1")]
private static Thread GetCurrentThreadNative();
    private void SetStartHelper(Delegate start, int maxStackSize);
    private void SetStart(Delegate start, int maxStackSize);
    protected virtual override void Finalize();
    private void InternalFinalize();
    private void StartupSetApartmentStateInternal();
    public CultureInfo get_CurrentUICulture();
    public void set_CurrentUICulture(CultureInfo value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void nativeInitCultureAccessors();
    private static AppDomain GetDomainInternal();
    private static AppDomain GetFastDomainInternal();
    internal static AppDomain GetDomain();
    internal static int GetDomainID();
    public string get_Name();
    public void set_Name(string value);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void InformThreadNameChange(ThreadHandle t, string name, int len);
}
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    internal ThreadAbortException(SerializationInfo info, StreamingContext context);
    public object get_ExceptionState();
}
internal class System.Threading.ThreadHandle : ValueType {
    private IntPtr m_ptr;
    internal ThreadHandle(IntPtr pThread);
}
internal class System.Threading.ThreadHelper : object {
    private Delegate _start;
    private object _startArg;
    private ExecutionContext _executionContext;
    internal static ContextCallback _ccb;
    internal ThreadHelper(Delegate start);
    private static ThreadHelper();
    internal void SetExecutionContextHelper(ExecutionContext ec);
    private static void ThreadStart_Context(object state);
    internal void ThreadStart(object obj);
    internal void ThreadStart();
}
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}, Count={ValuesCountForDebugDisplay}")]
public class System.Threading.ThreadLocal`1 : object {
    private Func`1<T> m_valueFactory;
    [ThreadStaticAttribute]
private static LinkedSlotVolatile[] ts_slotArray;
    [ThreadStaticAttribute]
private static FinalizationHelper<T> ts_finalizationHelper;
    private int m_idComplement;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_initialized;
    private static IdManager<T> s_idManager;
    private LinkedSlot<T> m_linkedSlot;
    private bool m_trackAllValues;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    private int ValuesCountForDebugDisplay { get; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    private void Initialize(Func`1<T> valueFactory, bool trackAllValues);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private T GetValueSlow();
    private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray);
    private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value);
    public IList`1<T> get_Values();
    private List`1<T> GetValuesAsList();
    private int get_ValuesCountForDebugDisplay();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
    private void GrowTable(LinkedSlotVolatile[]& table, int minLength);
    private static int GetNewTableSize(int minSize);
}
public static class System.Threading.ThreadPool : object {
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    private static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, StackCrawlMark& stackMark, bool compressStack);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static bool QueueUserWorkItem(WaitCallback callBack);
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    internal static void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal);
    internal static bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem);
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetQueuedWorkItems>d__19")]
internal static IEnumerable`1<IThreadPoolWorkItem> GetQueuedWorkItems();
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetLocallyQueuedWorkItems>d__20")]
internal static IEnumerable`1<IThreadPoolWorkItem> GetLocallyQueuedWorkItems();
    internal static IEnumerable`1<IThreadPoolWorkItem> GetGloballyQueuedWorkItems();
    private static Object[] ToObjectArray(IEnumerable`1<IThreadPoolWorkItem> workitems);
    internal static Object[] GetQueuedWorkItemsForDebugger();
    internal static Object[] GetGloballyQueuedWorkItemsForDebugger();
    internal static Object[] GetLocallyQueuedWorkItemsForDebugger();
    [SuppressUnmanagedCodeSecurityAttribute]
internal static bool RequestWorkerThread();
    private static bool PostQueuedCompletionStatus(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    private static void EnsureVMInitialized();
    private static void EnsureVMInitializedCore();
    private static bool SetMinThreadsNative(int workerThreads, int completionPortThreads);
    private static bool SetMaxThreadsNative(int workerThreads, int completionPortThreads);
    private static void GetMinThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    private static void GetMaxThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    private static void GetAvailableThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    internal static bool NotifyWorkItemComplete();
    internal static void ReportThreadStatus(bool isWorking);
    internal static void NotifyWorkItemProgress();
    internal static void NotifyWorkItemProgressNative();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void InitializeVMTp(Boolean& enableWorkerTracking);
    private static IntPtr RegisterWaitForSingleObjectNative(WaitHandle waitHandle, object state, UInt32 timeOutInterval, bool executeOnlyOnce, RegisteredWaitHandle registeredWaitHandle, StackCrawlMark& stackMark, bool compressStack);
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
public static bool BindHandle(IntPtr osHandle);
    public static bool BindHandle(SafeHandle osHandle);
    private static bool BindIOCompletionCallbackNative(IntPtr fileHandle);
}
public class System.Threading.ThreadPoolBoundHandle : object {
    private SafeHandle _handle;
    private bool _isDisposed;
    public SafeHandle Handle { get; }
    private ThreadPoolBoundHandle(SafeHandle handle);
    public SafeHandle get_Handle();
    public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
    private static ThreadPoolBoundHandleOverlapped GetOverlappedWrapper(NativeOverlapped* overlapped, ThreadPoolBoundHandle expectedBoundHandle);
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
}
internal class System.Threading.ThreadPoolBoundHandleOverlapped : Overlapped {
    private static IOCompletionCallback s_completionCallback;
    private IOCompletionCallback _userCallback;
    internal object _userState;
    internal PreAllocatedOverlapped _preAllocated;
    internal NativeOverlapped* _nativeOverlapped;
    internal ThreadPoolBoundHandle _boundHandle;
    internal bool _completed;
    public ThreadPoolBoundHandleOverlapped(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    private static ThreadPoolBoundHandleOverlapped();
    private static void CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
}
internal static class System.Threading.ThreadPoolGlobals : object {
    public static UInt32 TP_QUANTUM;
    public static int processorCount;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) vmTpInitialized;
    public static bool enableWorkerTracking;
    public static ThreadPoolWorkQueue workQueue;
    private static ThreadPoolGlobals();
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    internal bool loggingEnabled;
    internal ConcurrentQueue`1<IThreadPoolWorkItem> workItems;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numOutstandingThreadRequests;
    public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
    internal void EnsureThreadRequested();
    internal void MarkThreadRequestSatisfied();
    public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal);
    internal bool LocalFindAndPop(IThreadPoolWorkItem callback);
    public IThreadPoolWorkItem Dequeue(ThreadPoolWorkQueueThreadLocals tl, Boolean& missedSteal);
    internal static bool Dispatch();
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public FastRandom random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    private void CleanUp();
    protected virtual override void Finalize();
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(Exception reason);
    internal ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
public static class System.Threading.Timeout : object {
    public static TimeSpan InfiniteTimeSpan;
    public static int Infinite;
    internal static UInt32 UnsignedInfinite;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
public class System.Threading.Timer : MarshalByRefObject {
    private static UInt32 MAX_SUPPORTED_TIMEOUT;
    private TimerHolder m_timer;
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback);
    private void TimerSetup(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public bool Change(int dueTime, int period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public bool Change(long dueTime, long period);
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual void Dispose();
    internal void KeepRootedWhileScheduled();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.TimerHolder : object {
    internal TimerQueueTimer m_timer;
    public TimerHolder(TimerQueueTimer timer);
    protected virtual override void Finalize();
    public void Close();
    public bool Close(WaitHandle notifyObject);
}
internal class System.Threading.TimerQueue : object {
    private static TimerQueue s_queue;
    private AppDomainTimerSafeHandle m_appDomainTimer;
    private bool m_isAppDomainTimerScheduled;
    private int m_currentAppDomainTimerStartTicks;
    private UInt32 m_currentAppDomainTimerDuration;
    private TimerQueueTimer m_timers;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_pauseTicks;
    private static WaitCallback s_fireQueuedTimerCompletion;
    public static TimerQueue Instance { get; }
    private static int TickCount { get; }
    private static TimerQueue();
    public static TimerQueue get_Instance();
    private static int get_TickCount();
    private bool EnsureAppDomainTimerFiresBy(UInt32 requestedDuration);
    internal static void AppDomainTimerCallback();
    [SuppressUnmanagedCodeSecurityAttribute]
private static AppDomainTimerSafeHandle CreateAppDomainTimer(UInt32 dueTime);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool ChangeAppDomainTimer(AppDomainTimerSafeHandle handle, UInt32 dueTime);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool DeleteAppDomainTimer(IntPtr handle);
    private void FireNextTimers();
    private static void QueueTimerCompletion(TimerQueueTimer timer);
    private static void FireQueuedTimerCompletion(object state);
    public bool UpdateTimer(TimerQueueTimer timer, UInt32 dueTime, UInt32 period);
    public void DeleteTimer(TimerQueueTimer timer);
}
internal class System.Threading.TimerQueueTimer : object {
    internal TimerQueueTimer m_next;
    internal TimerQueueTimer m_prev;
    internal int m_startTicks;
    internal UInt32 m_dueTime;
    internal UInt32 m_period;
    private TimerCallback m_timerCallback;
    private object m_state;
    private ExecutionContext m_executionContext;
    private int m_callbacksRunning;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_canceled;
    private WaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) m_notifyWhenNoCallbacksRunning;
    private static ContextCallback s_callCallbackInContext;
    internal TimerQueueTimer(TimerCallback timerCallback, object state, UInt32 dueTime, UInt32 period);
    private static TimerQueueTimer();
    internal bool Change(UInt32 dueTime, UInt32 period);
    public void Close();
    public bool Close(WaitHandle toSignal);
    internal void Fire();
    internal void SignalNoCallbacksRunning();
    internal void CallCallback();
}
public static class System.Threading.Volatile : object {
    [NonVersionableAttribute]
public static bool Read(Boolean& location);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Read(SByte& location);
    [NonVersionableAttribute]
public static byte Read(Byte& location);
    [NonVersionableAttribute]
public static short Read(Int16& location);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Read(UInt16& location);
    [NonVersionableAttribute]
public static int Read(Int32& location);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Read(UInt32& location);
    [NonVersionableAttribute]
public static long Read(Int64& location);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Read(UInt64& location);
    [NonVersionableAttribute]
public static IntPtr Read(IntPtr& location);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UIntPtr Read(UIntPtr& location);
    [NonVersionableAttribute]
public static float Read(Single& location);
    [NonVersionableAttribute]
public static double Read(Double& location);
    [NonVersionableAttribute]
public static T Read(T& location);
    [NonVersionableAttribute]
public static void Write(Boolean& location, bool value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(SByte& location, sbyte value);
    [NonVersionableAttribute]
public static void Write(Byte& location, byte value);
    [NonVersionableAttribute]
public static void Write(Int16& location, short value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(UInt16& location, ushort value);
    [NonVersionableAttribute]
public static void Write(Int32& location, int value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(UInt32& location, UInt32 value);
    [NonVersionableAttribute]
public static void Write(Int64& location, long value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(UInt64& location, ulong value);
    [NonVersionableAttribute]
public static void Write(IntPtr& location, IntPtr value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(UIntPtr& location, UIntPtr value);
    [NonVersionableAttribute]
public static void Write(Single& location, float value);
    [NonVersionableAttribute]
public static void Write(Double& location, double value);
    [NonVersionableAttribute]
public static void Write(T& location, T value);
}
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    public static int WaitTimeout;
    private static int MAX_WAITHANDLES;
    private IntPtr waitHandle;
    internal SafeWaitHandle modreq(System.Runtime.CompilerServices.IsVolatile) safeWaitHandle;
    internal bool hasThreadAffinity;
    protected static IntPtr InvalidHandle;
    private static int WAIT_OBJECT_0;
    private static int WAIT_ABANDONED;
    private static int WAIT_FAILED;
    private static int ERROR_TOO_MANY_POSTS;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    private static IntPtr GetInvalidHandle();
    private void Init();
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    internal void SetHandleInternal(SafeWaitHandle handle);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(TimeSpan timeout);
    private bool WaitOne(long timeout, bool exitContext);
    internal static bool InternalWaitOne(SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    internal bool WaitOneWithoutFAS();
    private static int WaitOneNative(SafeHandle waitableSafeHandle, UInt32 millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    private static int WaitMultiple(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    private static int SignalAndWaitOne(SafeWaitHandle waitHandleToSignal, SafeWaitHandle waitHandleToWaitOn, int millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    private static void ThrowAbandonedMutexException();
    private static void ThrowAbandonedMutexException(int location, WaitHandle handle);
    public virtual void Close();
    protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
}
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal class System.Threading.WinRTSynchronizationContextFactoryBase : object {
    public virtual SynchronizationContext Create(object coreDispatcher);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
internal static class System.ThrowHelper : object {
    internal static void ThrowArrayTypeMismatchException();
    internal static void ThrowInvalidTypeWithPointersNotSupported(Type targetType);
    internal static void ThrowIndexOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException();
    internal static void ThrowArgumentException_DestinationTooShort();
    internal static void ThrowArgumentOutOfRange_IndexException();
    internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    internal static void ThrowWrongKeyTypeArgumentException(object key, Type targetType);
    internal static void ThrowWrongValueTypeArgumentException(object value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    internal static void ThrowAddingDuplicateWithKeyArgumentException(object key);
    internal static void ThrowKeyNotFoundException();
    internal static void ThrowArgumentException(ExceptionResource resource);
    internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentNullException(ExceptionResource resource);
    internal static void ThrowArgumentNullException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    internal static void ThrowSerializationException(ExceptionResource resource);
    internal static void ThrowSecurityException(ExceptionResource resource);
    internal static void ThrowRankException(ExceptionResource resource);
    internal static void ThrowNotSupportedException(ExceptionResource resource);
    internal static void ThrowUnauthorizedAccessException(ExceptionResource resource);
    internal static void ThrowObjectDisposedException(string objectName, ExceptionResource resource);
    internal static void ThrowObjectDisposedException(ExceptionResource resource);
    internal static void ThrowNotSupportedException();
    internal static void ThrowAggregateException(List`1<Exception> exceptions);
    internal static void ThrowArgumentException_Argument_InvalidArrayType();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    internal static void ThrowArraySegmentCtorValidationFailedExceptions(Array array, int offset, int count);
    private static Exception GetArraySegmentCtorValidationFailedException(Array array, int offset, int count);
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    internal static InvalidOperationException GetInvalidOperationException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    internal static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    private static ArgumentException GetArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    protected TimeoutException(SerializationInfo info, StreamingContext context);
}
public class System.TimeSpan : ValueType {
    public static long TicksPerMillisecond;
    private static double MillisecondsPerTick;
    public static long TicksPerSecond;
    private static double SecondsPerTick;
    public static long TicksPerMinute;
    private static double MinutesPerTick;
    public static long TicksPerHour;
    private static double HoursPerTick;
    public static long TicksPerDay;
    private static double DaysPerTick;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    internal static long MaxSeconds;
    internal static long MinSeconds;
    internal static long MaxMilliSeconds;
    internal static long MinMilliSeconds;
    internal static long TicksPerTenthSecond;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _legacyConfigChecked;
    private static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _legacyMode;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    private static bool LegacyMode { get; }
    public TimeSpan(long ticks);
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    private static TimeSpan Interval(double value, int scale);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    public TimeSpan Multiply(double factor);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
    private static bool GetLegacyFormatMode();
    private static bool get_LegacyMode();
}
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    private static TimeZone modreq(System.Runtime.CompilerServices.IsVolatile) currentTimeZone;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static TimeZone();
    private static object get_InternalSyncObject();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
}
public class System.TimeZoneInfo : object {
    private string _id;
    private string _displayName;
    private string _standardDisplayName;
    private string _daylightDisplayName;
    private TimeSpan _baseUtcOffset;
    private bool _supportsDaylightSavingTime;
    private AdjustmentRule[] _adjustmentRules;
    private static string UtcId;
    private static string LocalId;
    private static TimeZoneInfo s_utcTimeZone;
    private static CachedData s_cachedData;
    private static DateTime s_maxDateOnly;
    private static DateTime s_minDateOnly;
    private static string TimeZonesRegistryHive;
    private static string DisplayValue;
    private static string DaylightValue;
    private static string StandardValue;
    private static string MuiDisplayValue;
    private static string MuiDaylightValue;
    private static string MuiStandardValue;
    private static string TimeZoneInfoValue;
    private static string FirstEntryValue;
    private static string LastEntryValue;
    private static int MaxKeyLength;
    private static int RegByteLength;
    public string Id { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private TimeZoneInfo(SerializationInfo info, StreamingContext context);
    private TimeZoneInfo(TimeZoneInformation zone, bool dstDisabled);
    private static TimeZoneInfo();
    public string get_Id();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    private AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(DateTime adjustedTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetPreviousAdjustmentRule(AdjustmentRule rule, Nullable`1<int> ruleIndex);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    private TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    private bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    private static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags, CachedData cachedData);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, bool dateTimeisUtc, Nullable`1& ruleIndex);
    private int CompareAdjustmentRuleToDateTime(AdjustmentRule rule, AdjustmentRule previousRule, DateTime dateTime, DateTime dateOnly, bool dateTimeisUtc);
    private DateTime ConvertToUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertToFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta, bool convertToUtc);
    private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone, Boolean& isAmbiguousLocalDst);
    private DaylightTimeStruct GetDaylightTime(int year, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime, TimeZoneInfoOptions flags);
    private TimeSpan GetDaylightSavingsStartOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private TimeSpan GetDaylightSavingsEndOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule);
    private static bool GetIsDaylightSavingsFromUtc(DateTime time, int year, TimeSpan utc, AdjustmentRule rule, Nullable`1<int> ruleIndex, Boolean& isAmbiguousLocalDst, TimeZoneInfo zone);
    private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment, AdjustmentRule rule);
    private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone, TimeZoneInfoOptions flags);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime);
    private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
    private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst);
    public AdjustmentRule[] GetAdjustmentRules();
    private static void PopulateAllSystemTimeZones(CachedData cachedData);
    private static bool CheckDaylightSavingTimeNotSupported(TimeZoneInformation timeZone);
    private static AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(RegistryTimeZoneInformation timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset);
    private static string FindIdFromTimeZoneInformation(TimeZoneInformation timeZone, Boolean& dstDisabled);
    private static TimeZoneInfo GetLocalTimeZone(CachedData cachedData);
    private static TimeZoneInfo GetLocalTimeZoneFromWin32Data(TimeZoneInformation timeZoneInformation, bool dstDisabled);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    private static bool TransitionTimeFromTimeZoneInformation(RegistryTimeZoneInformation timeZoneInformation, TransitionTime& transitionTime, bool readStartDate);
    private static bool TryCreateAdjustmentRules(string id, RegistryTimeZoneInformation defaultTimeZoneInformation, AdjustmentRule[]& rules, Exception& e, int defaultBaseUtcOffset);
    private static bool TryCompareStandardDate(TimeZoneInformation timeZone, RegistryTimeZoneInformation registryTimeZoneInfo);
    private static bool TryCompareTimeZoneInformationToRegistry(TimeZoneInformation timeZone, string id, Boolean& dstDisabled);
    private static string TryGetLocalizedNameByMuiNativeResource(string resource);
    private static string TryGetLocalizedNameByNativeResource(string filePath, int resource);
    private static bool TryGetLocalizedNamesByRegistryKey(RegistryKey key, String& displayName, String& standardName, String& daylightName);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, TimeZoneInfo& value, Exception& e);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
public class System.Tuple`1 : object {
    private T1 m_Item1;
    public T1 Item1 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
public abstract class System.Type : MemberInfo {
    private static Binder modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultBinder;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static object Missing;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    private static BindingFlags DefaultLookup;
    public bool IsInterface { get; }
    internal bool IsWindowsRuntimeObject { get; }
    internal bool IsExportedToWindowsRuntime { get; }
    internal bool NeedsReflectionSecurityCheck { get; }
    public MemberTypes MemberType { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public string FullName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public bool IsNested { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type ReflectedType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool HasElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public TypeAttributes Attributes { get; }
    public bool IsAbstract { get; }
    public bool IsImport { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsClass { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsAutoLayout { get; }
    public bool IsExplicitLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsAnsiClass { get; }
    public bool IsAutoClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsCOMObject { get; }
    public bool IsContextful { get; }
    public bool IsEnum { get; }
    public bool IsMarshalByRef { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public ConstructorInfo TypeInitializer { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Guid GUID { get; }
    public Type BaseType { get; }
    public static Binder DefaultBinder { get; }
    public bool IsSerializable { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsVisible { get; }
    private static Type();
    public bool get_IsInterface();
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    internal virtual RuntimeTypeHandle GetTypeHandleInternal();
    internal static RuntimeType GetTypeFromHandleUnsafe(IntPtr handle);
    public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    internal bool get_IsWindowsRuntimeObject();
    internal bool get_IsExportedToWindowsRuntime();
    internal virtual bool IsWindowsRuntimeObjectImpl();
    internal virtual bool IsExportedToWindowsRuntimeImpl();
    internal bool get_NeedsReflectionSecurityCheck();
    internal string FormatTypeName();
    internal virtual string FormatTypeName(bool serialization);
    public static bool op_Equality(Type left, Type right);
    public static bool op_Inequality(Type left, Type right);
    internal bool IsRuntimeImplemented();
    public virtual MemberTypes get_MemberType();
    public Type GetType();
    public abstract virtual string get_Namespace();
    public abstract virtual string get_AssemblyQualifiedName();
    public abstract virtual string get_FullName();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Module get_Module();
    public bool get_IsNested();
    public virtual Type get_DeclaringType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_ReflectedType();
    public abstract virtual Type get_UnderlyingSystemType();
    public bool get_IsArray();
    protected abstract virtual bool IsArrayImpl();
    public bool get_IsByRef();
    protected abstract virtual bool IsByRefImpl();
    public bool get_IsPointer();
    protected abstract virtual bool IsPointerImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public bool get_HasElementType();
    protected abstract virtual bool HasElementTypeImpl();
    public abstract virtual Type GetElementType();
    public virtual int GetArrayRank();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type[] GetGenericArguments();
    public virtual int get_GenericParameterPosition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Type[] GetGenericParameterConstraints();
    public TypeAttributes get_Attributes();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public bool get_IsAbstract();
    public bool get_IsImport();
    public bool get_IsSealed();
    public bool get_IsSpecialName();
    public bool get_IsClass();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPublic();
    public bool get_IsAutoLayout();
    public bool get_IsExplicitLayout();
    public bool get_IsLayoutSequential();
    public bool get_IsAnsiClass();
    public bool get_IsAutoClass();
    public bool get_IsUnicodeClass();
    public bool get_IsCOMObject();
    protected abstract virtual bool IsCOMObjectImpl();
    public bool get_IsContextful();
    protected virtual bool IsContextfulImpl();
    public virtual bool get_IsEnum();
    public bool get_IsMarshalByRef();
    protected virtual bool IsMarshalByRefImpl();
    public bool get_IsPrimitive();
    protected abstract virtual bool IsPrimitiveImpl();
    public bool get_IsValueType();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public ConstructorInfo get_TypeInitializer();
    public ConstructorInfo GetConstructor(Type[] types);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name, Type returnType);
    public PropertyInfo GetProperty(string name, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    public static Type[] GetTypeArray(Object[] args);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    public static Type GetTypeFromCLSID(Guid clsid);
    public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    public static Type GetTypeFromCLSID(Guid clsid, string server);
    public static Type GetTypeFromProgID(string progID);
    public static Type GetTypeFromProgID(string progID, bool throwOnError);
    public static Type GetTypeFromProgID(string progID, string server);
    public abstract virtual Type get_BaseType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsEquivalentTo(Type other);
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool Equals(Type o);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public static Binder get_DefaultBinder();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    private Array GetEnumRawConstantValues();
    private void GetEnumData(String[]& enumNames, Array& enumValues);
    private static int BinarySearch(Array array, object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSerializable();
    public virtual bool get_ContainsGenericParameters();
    internal Type GetRootElementType();
    public bool get_IsVisible();
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual bool IsSubclassOf(Type c);
    public virtual bool IsAssignableFrom(Type c);
    internal bool ImplementInterface(Type ifaceType);
    private static bool FilterAttributeImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameIgnoreCaseImpl(MemberInfo m, object filterCriteria);
}
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public class System.TypedReference : ValueType {
    private IntPtr Value;
    private IntPtr Type;
    internal bool IsNull { get; }
    [CLSCompliantAttribute("False")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    private static void InternalMakeTypedReference(Void* result, object target, IntPtr[] flds, RuntimeType lastFieldType);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static object ToObject(TypedReference value);
    internal static object InternalToObject(Void* value);
    internal bool get_IsNull();
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    [CLSCompliantAttribute("False")]
public static void SetTypedReference(TypedReference target, object value);
    internal static void InternalSetTypedReference(Void* target, object value);
}
public class System.TypeInitializationException : SystemException {
    private string _typeName;
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(string message);
    internal TypeInitializationException(string fullTypeName, string message, Exception innerException);
    internal TypeInitializationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
}
public class System.TypeLoadException : SystemException {
    private string ClassName;
    private string AssemblyName;
    private string MessageArg;
    internal int ResourceId;
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    private TypeLoadException(string className, string assemblyName, string messageArg, int resourceId);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    private void SetMessageField();
    public string get_TypeName();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void GetTypeLoadExceptionMessage(int resourceId, StringHandleOnStack retString);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum System.TypeNameFormatFlags : Enum {
    public int value__;
    public static TypeNameFormatFlags FormatBasic;
    public static TypeNameFormatFlags FormatNamespace;
    public static TypeNameFormatFlags FormatFullInst;
    public static TypeNameFormatFlags FormatAssembly;
    public static TypeNameFormatFlags FormatSignature;
    public static TypeNameFormatFlags FormatNoVersion;
    public static TypeNameFormatFlags FormatAngleBrackets;
    public static TypeNameFormatFlags FormatStubInfo;
    public static TypeNameFormatFlags FormatGenericParam;
    public static TypeNameFormatFlags FormatSerialization;
}
internal enum System.TypeNameKind : Enum {
    public int value__;
    public static TypeNameKind Name;
    public static TypeNameKind ToString;
    public static TypeNameKind SerializationName;
    public static TypeNameKind FullName;
}
internal class System.TypeNameParser : object {
    private SafeTypeNameParserHandle m_NativeParser;
    private static Char[] SPECIAL_CHARS;
    private TypeNameParser(SafeTypeNameParserHandle handle);
    private static TypeNameParser();
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _CreateTypeNameParser(string typeName, ObjectHandleOnStack retHandle, bool throwOnError);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _GetNames(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _GetTypeArguments(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _GetModifiers(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void _GetAssemblyName(SafeTypeNameParserHandle pTypeNameParser, StringHandleOnStack retString);
    internal static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    public sealed virtual void Dispose();
    private Type ConstructType(Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static Assembly ResolveAssembly(string asmName, Func`2<AssemblyName, Assembly> assemblyResolver, bool throwOnError, StackCrawlMark& stackMark);
    private static Type ResolveType(Assembly assembly, String[] names, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static string EscapeTypeName(string name);
    private static SafeTypeNameParserHandle CreateTypeNameParser(string typeName, bool throwOnError);
    private String[] GetNames();
    private SafeTypeNameParserHandle[] GetTypeArguments();
    private Int32[] GetModifiers();
    private string GetAssemblyName();
}
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    private ushort m_value;
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    private static ushort Parse(string s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    private static bool TryParse(string s, NumberStyles style, NumberFormatInfo info, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
public class System.UInt32 : ValueType {
    private UInt32 m_value;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
public class System.UInt64 : ValueType {
    private ulong m_value;
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    private Void* m_value;
    public static UIntPtr Zero;
    public static int Size { get; }
    [NonVersionableAttribute]
public UIntPtr(UInt32 value);
    [NonVersionableAttribute]
public UIntPtr(ulong value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public UIntPtr(Void* value);
    private UIntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
public UInt32 ToUInt32();
    [NonVersionableAttribute]
public ulong ToUInt64();
    public virtual string ToString();
    [NonVersionableAttribute]
public static UIntPtr op_Explicit(UInt32 value);
    [NonVersionableAttribute]
public static UIntPtr op_Explicit(ulong value);
    [NonVersionableAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
public static ulong op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UIntPtr op_Explicit(Void* value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static Void* op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static UIntPtr Add(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static int get_Size();
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public Void* ToPointer();
}
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
public class System.UnhandledExceptionEventArgs : EventArgs {
    private object _exception;
    private bool _isTerminating;
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.UnitySerializationHolder : object {
    internal static int EmptyUnity;
    internal static int NullUnity;
    internal static int MissingUnity;
    internal static int RuntimeTypeUnity;
    public static int ModuleUnity;
    public static int AssemblyUnity;
    internal static int GenericParameterTypeUnity;
    internal static int PartialInstantiationTypeUnity;
    internal static int Pointer;
    internal static int Array;
    internal static int SzArray;
    internal static int ByRef;
    private Type[] _instantiation;
    private Int32[] _elementTypes;
    private int _genericParameterPosition;
    private Type _declaringType;
    private MethodBase _declaringMethod;
    private string _data;
    private string _assemblyName;
    private int _unityType;
    public UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, Missing missing);
    internal static Type AddElementTypes(SerializationInfo info, Type type);
    internal Type MakeElementTypes(Type type);
    public static void GetUnitySerializationInfo(SerializationInfo info, Type type);
    public static void GetUnitySerializationInfo(SerializationInfo info, int unityType, string data, Assembly assembly);
    private void ThrowInsufficientInformation(string field);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual object GetRealObject(StreamingContext context);
}
internal class System.Utf8String : ValueType {
    private Void* m_pStringHeap;
    private int m_StringHeapByteLength;
    internal Utf8String(Void* pStringHeap);
    internal Utf8String(Void* pUtf8String, int cUtf8String);
    private static bool EqualsCaseSensitive(Void* szLhs, Void* szRhs, int cSz);
    [SuppressUnmanagedCodeSecurityAttribute]
private static bool EqualsCaseInsensitive(Void* szLhs, Void* szRhs, int cSz);
    [SuppressUnmanagedCodeSecurityAttribute]
private static UInt32 HashCaseInsensitive(Void* sz, int cSz);
    private static int GetUtf8StringByteLength(Void* pUtf8String);
    internal bool Equals(Utf8String s);
    internal bool EqualsCaseInsensitive(Utf8String s);
    internal UInt32 HashCaseInsensitive();
    public virtual string ToString();
}
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
public class System.ValueTuple`1 : ValueType {
    public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`1(T1 item1);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public abstract class System.ValueType : object {
    public virtual bool Equals(object obj);
    private static bool CanCompareBits(object obj);
    private static bool FastEqualsCheck(object a, object b);
    public virtual int GetHashCode();
    internal static int GetHashCodeOfPtr(IntPtr ptr);
    public virtual string ToString();
}
internal class System.Variant : ValueType {
    private object m_objref;
    private int m_data1;
    private int m_data2;
    private int m_flags;
    internal static int CV_EMPTY;
    internal static int CV_VOID;
    internal static int CV_BOOLEAN;
    internal static int CV_CHAR;
    internal static int CV_I1;
    internal static int CV_U1;
    internal static int CV_I2;
    internal static int CV_U2;
    internal static int CV_I4;
    internal static int CV_U4;
    internal static int CV_I8;
    internal static int CV_U8;
    internal static int CV_R4;
    internal static int CV_R8;
    internal static int CV_STRING;
    internal static int CV_PTR;
    internal static int CV_DATETIME;
    internal static int CV_TIMESPAN;
    internal static int CV_OBJECT;
    internal static int CV_DECIMAL;
    internal static int CV_ENUM;
    internal static int CV_MISSING;
    internal static int CV_NULL;
    internal static int CV_LAST;
    internal static int TypeCodeBitMask;
    internal static int VTBitMask;
    internal static int VTBitShift;
    internal static int ArrayBitMask;
    internal static int EnumI1;
    internal static int EnumU1;
    internal static int EnumI2;
    internal static int EnumU2;
    internal static int EnumI4;
    internal static int EnumU4;
    internal static int EnumI8;
    internal static int EnumU8;
    internal static int EnumMask;
    internal static Type[] ClassTypes;
    internal static Variant Empty;
    internal static Variant Missing;
    internal static Variant DBNull;
    internal int CVType { get; }
    internal Variant(int flags, object or, int data1, int data2);
    public Variant(bool val);
    public Variant(sbyte val);
    public Variant(byte val);
    public Variant(short val);
    public Variant(ushort val);
    public Variant(char val);
    public Variant(int val);
    public Variant(UInt32 val);
    public Variant(long val);
    public Variant(ulong val);
    public Variant(float val);
    public Variant(double val);
    public Variant(DateTime val);
    public Variant(decimal val);
    public Variant(object obj);
    private static Variant();
    internal double GetR8FromVar();
    internal float GetR4FromVar();
    internal void SetFieldsR4(float val);
    internal void SetFieldsR8(double val);
    internal void SetFieldsObject(object val);
    internal long GetI8FromVar();
    internal int get_CVType();
    public object ToObject();
    private object BoxEnum();
    internal static void MarshalHelperConvertObjectToVariant(object o, Variant& v);
    internal static object MarshalHelperConvertVariantToObject(Variant& v);
    internal static void MarshalHelperCastVariant(object pValue, int vt, Variant& v);
}
public class System.Version : object {
    private int _Major;
    private int _Minor;
    private int _Build;
    private int _Revision;
    private static int ZERO_CHAR_VALUE;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    public Version(string version);
    private Version(Version version);
    public sealed virtual object Clone();
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(int fieldCount);
    private static void AppendPositiveNumber(int num, StringBuilder sb);
    public static Version Parse(string input);
    public static bool TryParse(string input, Version& result);
    private static bool TryParseVersion(string version, VersionResult& result);
    private static bool TryParseComponent(string component, string componentName, VersionResult& result, Int32& parsedComponent);
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
}
public class System.Void : ValueType {
}
public class System.WeakReference : object {
    internal IntPtr m_handle;
    public bool IsAlive { get; }
    public bool TrackResurrection { get; }
    public object Target { get; public set; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual bool get_TrackResurrection();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    protected virtual override void Finalize();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private void Create(object target, bool trackResurrection);
    private bool IsTrackResurrection();
}
public class System.WeakReference`1 : object {
    internal IntPtr m_handle;
    private T Target { get; private set; }
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    internal WeakReference`1(SerializationInfo info, StreamingContext context);
    public bool TryGetTarget(T& target);
    public void SetTarget(T target);
    private T get_Target();
    private void set_Target(T value);
    protected virtual override void Finalize();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private void Create(T target, bool trackResurrection);
    private bool IsTrackResurrection();
}
internal static class ThisAssembly : object {
    internal static string Version;
    internal static int DailyBuildNumber;
}
internal enum Windows.Foundation.Diagnostics.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Error;
    public static AsyncCausalityStatus Started;
}
internal enum Windows.Foundation.Diagnostics.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum Windows.Foundation.Diagnostics.CausalitySource : Enum {
    public int value__;
    public static CausalitySource Application;
    public static CausalitySource Library;
    public static CausalitySource System;
}
internal enum Windows.Foundation.Diagnostics.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
internal enum Windows.Foundation.Diagnostics.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
[GuidAttribute("50850B26-267E-451B-A890-AB6A370245EE")]
internal interface Windows.Foundation.Diagnostics.IAsyncCausalityTracerStatics {
    public abstract virtual void TraceOperationCreation(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, string operationName, ulong relatedContext);
    public abstract virtual void TraceOperationCompletion(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, AsyncCausalityStatus status);
    public abstract virtual void TraceOperationRelation(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, CausalityRelation relation);
    public abstract virtual void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, CausalitySynchronousWork work);
    public abstract virtual void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySource source, CausalitySynchronousWork work);
    public abstract virtual EventRegistrationToken add_TracingStatusChanged(EventHandler`1<TracingStatusChangedEventArgs> eventHandler);
    public abstract virtual void remove_TracingStatusChanged(EventRegistrationToken token);
}
[GuidAttribute("410B7711-FF3B-477F-9C9A-D2EFDA302DC3")]
internal interface Windows.Foundation.Diagnostics.ITracingStatusChangedEventArgs {
    public bool Enabled { get; }
    public CausalityTraceLevel TraceLevel { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual CausalityTraceLevel get_TraceLevel();
}
[GuidAttribute("410B7711-FF3B-477F-9C9A-D2EFDA302DC3")]
internal class Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs : object {
    public bool Enabled { get; }
    public CausalityTraceLevel TraceLevel { get; }
    public sealed virtual bool get_Enabled();
    public sealed virtual CausalityTraceLevel get_TraceLevel();
}
