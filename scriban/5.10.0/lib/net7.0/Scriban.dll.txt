[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Scriban.Functions.ArrayFunctions : ScriptObject {
    private static ListProcessor EachProcessor;
    private static ListProcessor FilterProcessor;
    private static ArrayFunctions();
    public static IEnumerable Add(IEnumerable list, object value);
    public static IEnumerable AddRange(IEnumerable list1, IEnumerable list2);
    public static IEnumerable Compact(IEnumerable list);
    public static IEnumerable Concat(IEnumerable list1, IEnumerable list2);
    public static object Cycle(TemplateContext context, SourceSpan span, IList list, object group);
    public static ScriptRange Each(TemplateContext context, SourceSpan span, IEnumerable list, object function);
    [IteratorStateMachineAttribute("Scriban.Functions.ArrayFunctions/<EachInternal>d__6")]
private static IEnumerable EachInternal(TemplateContext context, ScriptNode callerContext, SourceSpan span, IEnumerable list, IScriptCustomFunction function, Type destType);
    public static ScriptRange Filter(TemplateContext context, SourceSpan span, IEnumerable list, object function);
    [IteratorStateMachineAttribute("Scriban.Functions.ArrayFunctions/<FilterInternal>d__9")]
private static IEnumerable FilterInternal(TemplateContext context, ScriptNode callerContext, SourceSpan span, IEnumerable list, IScriptCustomFunction function, Type destType);
    public static object First(IEnumerable list);
    public static IEnumerable InsertAt(IEnumerable list, int index, object value);
    public static string Join(TemplateContext context, SourceSpan span, IEnumerable list, string delimiter, object function);
    public static object Last(IEnumerable list);
    public static IEnumerable Limit(IEnumerable list, int count);
    public static IEnumerable Map(TemplateContext context, SourceSpan span, object list, string member);
    [IteratorStateMachineAttribute("Scriban.Functions.ArrayFunctions/<MapImpl>d__17")]
private static IEnumerable MapImpl(TemplateContext context, SourceSpan span, object list, string member);
    public static IEnumerable Offset(IEnumerable list, int index);
    public static IList RemoveAt(IList list, int index);
    public static IEnumerable Reverse(IEnumerable list);
    public static int Size(IEnumerable list);
    public static IEnumerable Sort(TemplateContext context, SourceSpan span, object list, string member);
    public static IEnumerable Uniq(IEnumerable list);
    public static bool Contains(IEnumerable list, object item);
    private static bool CompareEnum(Enum e, object item);
    private static ScriptRange ApplyFunction(TemplateContext context, SourceSpan span, IEnumerable list, object function, ListProcessor impl);
}
public class Scriban.Functions.BuiltinFunctions : ScriptObject {
    [NullableAttribute("1")]
internal static ScriptObject Default;
    private static BuiltinFunctions();
}
public class Scriban.Functions.DateTimeFunctions : ScriptObject {
    private static string FormatKey;
    public static string DefaultFormat;
    [ScriptMemberIgnoreAttribute]
public static ScriptVariable DateVariable;
    private static Dictionary`2<char, ValueTuple`2<Func`3<DateTime, CultureInfo, string>, string>> Formats;
    private static Regex PlusFollowedByNumberRegex;
    private static string Parameter1Name;
    public string Format { get; public set; }
    public int RequiredParameterCount { get; }
    public int ParameterCount { get; }
    public ScriptVarParamKind VarParamKind { get; }
    public Type ReturnType { get; }
    private static DateTimeFunctions();
    public string get_Format();
    public void set_Format(string value);
    public static DateTime Now();
    public static DateTime AddDays(DateTime date, double days);
    public static DateTime AddMonths(DateTime date, int months);
    public static DateTime AddYears(DateTime date, int years);
    public static DateTime AddHours(DateTime date, double hours);
    public static DateTime AddMinutes(DateTime date, double minutes);
    public static DateTime AddSeconds(DateTime date, double seconds);
    public static DateTime AddMilliseconds(DateTime date, double millis);
    public static Nullable`1<DateTime> Parse(TemplateContext context, string text, string pattern, string culture);
    public virtual IScriptObject Clone(bool deep);
    public virtual string ToString(Nullable`1<DateTime> datetime, string pattern, CultureInfo culture);
    public virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public sealed virtual int get_RequiredParameterCount();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ScriptVarParamKind get_VarParamKind();
    public sealed virtual Type get_ReturnType();
    public sealed virtual ScriptParameterInfo GetParameterInfo(int index);
    public sealed virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    private void CreateImportFunctions();
    private string ToStringTrampoline(TemplateContext context, Nullable`1<DateTime> date, string pattern, string culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Functions.HtmlFunctions : ScriptObject {
    private static string RegexMatchHtml;
    public static string Strip(TemplateContext context, string text);
    public static string Escape(string text);
    public static string UrlEncode(string text);
    public static string UrlEscape(string text);
}
public class Scriban.Functions.IncludeFunction : object {
    public int RequiredParameterCount { get; }
    public int ParameterCount { get; }
    public ScriptVarParamKind VarParamKind { get; }
    public Type ReturnType { get; }
    public sealed virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public sealed virtual int get_RequiredParameterCount();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ScriptVarParamKind get_VarParamKind();
    public sealed virtual Type get_ReturnType();
    public sealed virtual ScriptParameterInfo GetParameterInfo(int index);
    public int GetParameterIndexByName(string name);
    [AsyncStateMachineAttribute("Scriban.Functions.IncludeFunction/<InvokeAsync>d__12")]
public sealed virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
}
public class Scriban.Functions.LiquidBuiltinsFunctions : ScriptObject {
    private static DefaultBuiltins Default;
    private static LiquidBuiltinsFunctions();
    public static bool TryLiquidToScriban(string liquidBuiltin, String& target, String& member);
}
public class Scriban.Functions.MathFunctions : ScriptObject {
    private static string RandomTagKey;
    public static object Abs(TemplateContext context, SourceSpan span, object value);
    public static double Ceil(double value);
    public static object DividedBy(TemplateContext context, SourceSpan span, double value, object divisor);
    public static double Floor(double value);
    public static string Format(TemplateContext context, SourceSpan span, object value, string format, string culture);
    public static bool IsNumber(object value);
    public static object Minus(TemplateContext context, SourceSpan span, object value, object with);
    public static object Modulo(TemplateContext context, SourceSpan span, object value, object with);
    public static object Plus(TemplateContext context, SourceSpan span, object value, object with);
    public static double Round(double value, int precision);
    public static object Times(TemplateContext context, SourceSpan span, object value, object with);
    public static string Uuid();
    public static object Random(TemplateContext context, SourceSpan span, int minValue, int maxValue);
}
public class Scriban.Functions.ObjectFunctions : ScriptObject {
    public static object Default(object value, object default);
    public static object Eval(TemplateContext context, SourceSpan span, object value);
    public static object EvalTemplate(TemplateContext context, SourceSpan span, object value);
    public static string Format(TemplateContext context, SourceSpan span, object value, string format, string culture);
    public static bool HasKey(IDictionary`2<string, object> value, string key);
    public static bool HasValue(IDictionary`2<string, object> value, string key);
    public static ScriptArray Keys(TemplateContext context, object value);
    public static int Size(object value);
    public static string Typeof(object value);
    public static string Kind(TemplateContext context, object value);
    public static ScriptArray Values(TemplateContext context, object value);
    public static object FromJson(TemplateContext context, string json);
    public static string ToJson(TemplateContext context, object value);
    [CompilerGeneratedAttribute]
internal static void <ToJson>g__WriteValue|12_0(TemplateContext context, Utf8JsonWriter writer, object value);
}
public class Scriban.Functions.RegexFunctions : ScriptObject {
    public static string Escape(string pattern);
    public static ScriptArray Match(TemplateContext context, string text, string pattern, string options);
    public static ScriptArray Matches(TemplateContext context, string text, string pattern, string options);
    public static string Replace(TemplateContext context, string text, string pattern, string replace, string options);
    public static ScriptArray Split(TemplateContext context, string text, string pattern, string options);
    public static string Unescape(string pattern);
    private static RegexOptions GetOptions(string options);
}
public class Scriban.Functions.StringFunctions : ScriptObject {
    [ThreadStaticAttribute]
private static StringBuilder _tlsBuilder;
    private static StringBuilder GetTempStringBuilder();
    private static void ReleaseBuilder(StringBuilder builder);
    public static string Escape(string text);
    public static string Append(string text, string with);
    public static string Capitalize(string text);
    public static string Capitalizewords(string text);
    public static bool Contains(string text, string value);
    public static bool Empty(string text);
    public static bool Whitespace(string text);
    public static string Downcase(string text);
    public static bool EndsWith(string text, string value);
    public static bool EqualsIgnoreCase(string text, string value);
    public static string Handleize(string text);
    public static string Literal(string text);
    public static string LStrip(string text);
    public static string Pluralize(int number, string singular, string plural);
    public static string Prepend(string text, string by);
    public static string Remove(string text, string remove);
    public static string RemoveFirst(string text, string remove);
    public static string RemoveLast(string text, string remove);
    public static string Replace(string text, string match, string replace);
    public static string ReplaceFirst(string text, string match, string replace, bool fromEnd);
    public static string RStrip(string text);
    public static int Size(string text);
    public static string Slice(string text, int start, Nullable`1<int> length);
    public static string Slice1(string text, int start, int length);
    public static IEnumerable Split(string text, string match);
    public static bool StartsWith(string text, string value);
    public static string Strip(string text);
    public static string StripNewlines(string text);
    public static object ToInt(TemplateContext context, string text);
    public static object ToLong(TemplateContext context, string text);
    public static object ToFloat(TemplateContext context, string text);
    public static object ToDouble(TemplateContext context, string text);
    public static string Truncate(string text, int length, string ellipsis);
    public static string Truncatewords(string text, int count, string ellipsis);
    public static string Upcase(string text);
    public static string Md5(string text);
    public static string Sha1(string text);
    public static string Sha256(string text);
    public static string HmacSha1(string text, string secretKey);
    public static string HmacSha256(string text, string secretKey);
    private static string Hash(HashAlgorithm algo, string text);
    public static string PadLeft(string text, int width);
    public static string PadRight(string text, int width);
    public static string Base64Encode(string text);
    public static string Base64Decode(string text);
    public static int IndexOf(string text, string search, Nullable`1<int> startIndex, Nullable`1<int> count, string stringComparison);
    private static StringComparison GetComparison(string stringComparison, StringComparison defaultValue, bool throwExceptions);
}
public class Scriban.Functions.TimeSpanFunctions : ScriptObject {
    public static TimeSpan Zero { get; }
    public static TimeSpan get_Zero();
    public static TimeSpan FromDays(double days);
    public static TimeSpan FromHours(double hours);
    public static TimeSpan FromMinutes(double minutes);
    public static TimeSpan FromSeconds(double seconds);
    public static TimeSpan FromMilliseconds(double millis);
    [NullableContextAttribute("1")]
public static TimeSpan Parse(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Scriban.Helpers.BoxHelper : object {
    public static object TrueObject;
    public static object FalseObject;
    private static BoxHelper();
}
public class Scriban.Helpers.CharHelper : object {
    public static bool IsHexa(char c);
    public static bool TryParseDigit(char c, Int32& value);
    public static bool TryHexaToInt(char c, Int32& value);
    public static bool IsBinary(char c);
}
internal enum Scriban.Helpers.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument parent;
    public static ExceptionArgument index;
    public static ExceptionArgument element;
    public static ExceptionArgument item;
    public static ExceptionArgument array;
    public static ExceptionArgument value;
    public static ExceptionArgument builder;
    public static ExceptionArgument capacity;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument collection;
    public static ExceptionArgument Arg_ArrayPlusOffTooSmall;
    public static ExceptionArgument key;
    public static ExceptionArgument min;
    public static ExceptionArgument handle;
}
internal class Scriban.Helpers.FastStack`1 : ValueType {
    private T[] _array;
    private int _size;
    private static int DefaultCapacity;
    public int Count { get; }
    public T[] Items { get; }
    public FastStack`1(int capacity);
    public int get_Count();
    public T[] get_Items();
    public void Clear();
    public T Peek();
    public T Pop();
    public void Push(T item);
    private void ThrowForEmptyStack();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Scriban.Helpers.InlineList`1/DebugListView")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Scriban.Helpers.InlineList`1 : ValueType {
    private static int DefaultCapacity;
    public int Count;
    public T[] Items;
    public int Capacity { get; public set; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public InlineList`1(int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public static InlineList`1<T> Create();
    public static InlineList`1<T> Create(int capacity);
    public void Ensure();
    public bool get_IsReadOnly();
    public void Clear();
    public InlineList`1<T> Clone();
    public bool Contains(T item);
    public void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    public void Reset();
    public void Add(T child);
    public void AddByRef(T& child);
    public void Insert(int index, T item);
    public T& InsertReturnRef(int index, T item);
    public void InsertByRef(int index, T& item);
    public bool Remove(T element);
    public int IndexOf(T element);
    public T RemoveAt(int index);
    public T get_Item(int index);
    public void set_Item(int index, T value);
    private void EnsureCapacity(int min);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Scriban.Helpers.ReflectionHelper : object {
    [ExtensionAttribute]
public static bool IsPrimitiveOrDecimal(Type type);
    [ExtensionAttribute]
public static bool IsNumber(Type type);
    [ExtensionAttribute]
internal static Type GetBaseOrInterface(Type type, Type lookInterfaceType);
    [ExtensionAttribute]
public static string ScriptPrettyName(Type type);
}
[ExtensionAttribute]
internal static class Scriban.Helpers.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string TrimEndKeepNewLine(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Scriban.Helpers.ThrowHelper : object {
    public static void ThrowArgumentOutOfRangeException(ExceptionArgument ex);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument);
    public static ArgumentOutOfRangeException GetIndexNegativeArgumentOutOfRangeException();
    public static ArgumentOutOfRangeException GetIndexArgumentOutOfRangeException(int maxValue);
    public static InvalidOperationException GetExpectingNoParentException();
    private static string GetArgumentName(ExceptionArgument argument);
}
public class Scriban.LiquidTemplateContext : TemplateContext {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count: {Count}")]
public class Scriban.LogMessageBag : object {
    private List`1<LogMessage> _messages;
    [CompilerGeneratedAttribute]
private bool <HasErrors>k__BackingField;
    public int Count { get; }
    public LogMessage Item { get; }
    public bool HasErrors { get; private set; }
    public sealed virtual int get_Count();
    public sealed virtual LogMessage get_Item(int index);
    [CompilerGeneratedAttribute]
public bool get_HasErrors();
    [CompilerGeneratedAttribute]
private void set_HasErrors(bool value);
    public void Add(LogMessage message);
    public void AddRange(IEnumerable`1<LogMessage> messages);
    public sealed virtual IEnumerator`1<LogMessage> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
public class Scriban.Parsing.Lexer : object {
    private TextPosition _position;
    private int _textLength;
    private Token _token;
    private char c;
    private BlockType _blockType;
    private bool _isLiquidTagBlock;
    private List`1<LogMessage> _errors;
    private int _openBraceCount;
    private int _escapeRawCharCount;
    private bool _isExpectingFrontMatter;
    private bool _isLiquid;
    private Stack`1<char> _openingStringChars;
    private bool _interpJustOpened;
    private bool _interpJustClosed;
    private char _stripWhiteSpaceFullSpecialChar;
    private char _stripWhiteSpaceRestrictedSpecialChar;
    private static char RawEscapeSpecialChar;
    private Queue`1<Token> _pendingTokens;
    private TryMatchCustomTokenDelegate _tryMatchCustomToken;
    public LexerOptions Options;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    private bool AnyInterpolationOpen { get; }
    public string Text { get; }
    public string SourcePath { get; private set; }
    public bool HasErrors { get; }
    public IEnumerable`1<LogMessage> Errors { get; }
    public Lexer(string text, string sourcePath, Nullable`1<LexerOptions> options);
    private bool get_AnyInterpolationOpen();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
private void set_SourcePath(string value);
    public bool get_HasErrors();
    public IEnumerable`1<LogMessage> get_Errors();
    public Enumerator GetEnumerator();
    private bool MoveNext();
    private bool TryParseFrontMatterMarker();
    private bool IsCodeEnterOrEscape(TokenType& whitespaceMode);
    private void ReadCodeEnterOrEscape();
    private bool TryReadLiquidCommentOrRaw(TextPosition codeEnterStart, TextPosition codeEnterEnd);
    private void SkipSpaces();
    private void PeekSkipSpaces(Int32& i);
    private bool TryMatchPeek(string text, int offset, Int32& offsetOut);
    private bool TryMatch(string text);
    private bool IsCodeExit();
    private void ReadCodeExitOrEscape();
    private bool ReadRaw();
    private bool ReadCode();
    private bool TryMatchCustomToken(TextPosition start);
    private bool ReadCodeLiquid();
    private bool ConsumeWhitespace(bool stopAtNewLine, TextPosition& lastSpace, bool keepNewLine);
    private static bool IsNewLine(char c);
    private void ReadIdentifier(bool special);
    private static bool IsFirstIdentifierLetter(char c);
    private bool IsIdentifierLetter(char c);
    private void ReadNumber();
    private static bool IsNumberPostFix(char c);
    private void ReadHexa(TextPosition start);
    private void ReadBinary(TextPosition start);
    private void ReadString();
    private void ReadVerbatimString();
    private void ReadInterpolatedString();
    private void ReadComment();
    private char PeekChar(int count);
    private void NextChar();
    private sealed virtual override IEnumerator`1<Token> System.Collections.Generic.IEnumerable<Scriban.Parsing.Token>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void AddError(string message, TextPosition start, TextPosition end);
    private void Reset();
    private static bool IsWhitespace(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Parsing.LexerOptions : ValueType {
    public static string DefaultFrontMatterMarker;
    public static LexerOptions Default;
    [CompilerGeneratedAttribute]
private ScriptMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptLang <Lang>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrontMatterMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableIncludeImplicitString>k__BackingField;
    [CompilerGeneratedAttribute]
private TextPosition <StartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepTrivia>k__BackingField;
    [CompilerGeneratedAttribute]
private TryMatchCustomTokenDelegate <TryMatchCustomToken>k__BackingField;
    public ScriptMode Mode { get; public set; }
    public ScriptLang Lang { get; public set; }
    public string FrontMatterMarker { get; public set; }
    public bool EnableIncludeImplicitString { get; public set; }
    public TextPosition StartPosition { get; public set; }
    public bool KeepTrivia { get; public set; }
    public TryMatchCustomTokenDelegate TryMatchCustomToken { get; public set; }
    private static LexerOptions();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ScriptMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(ScriptMode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ScriptLang get_Lang();
    [CompilerGeneratedAttribute]
public void set_Lang(ScriptLang value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FrontMatterMarker();
    [CompilerGeneratedAttribute]
public void set_FrontMatterMarker(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_EnableIncludeImplicitString();
    [CompilerGeneratedAttribute]
public void set_EnableIncludeImplicitString(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextPosition get_StartPosition();
    [CompilerGeneratedAttribute]
public void set_StartPosition(TextPosition value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_KeepTrivia();
    [CompilerGeneratedAttribute]
public void set_KeepTrivia(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TryMatchCustomTokenDelegate get_TryMatchCustomToken();
    [CompilerGeneratedAttribute]
public void set_TryMatchCustomToken(TryMatchCustomTokenDelegate value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Parsing.LogMessage : object {
    [CompilerGeneratedAttribute]
private ParserMessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public ParserMessageType Type { get; public set; }
    public SourceSpan Span { get; public set; }
    public string Message { get; public set; }
    public LogMessage(ParserMessageType type, SourceSpan span, string message);
    [CompilerGeneratedAttribute]
public ParserMessageType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(ParserMessageType value);
    [CompilerGeneratedAttribute]
public SourceSpan get_Span();
    [CompilerGeneratedAttribute]
public void set_Span(SourceSpan value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public virtual string ToString();
}
public class Scriban.Parsing.Parser : object {
    private Lexer _lexer;
    private bool _isLiquid;
    private Enumerator _tokenIt;
    private List`1<Token> _tokensPreview;
    private int _tokensPreviewStart;
    private Token _previousToken;
    private Token _token;
    private bool _inCodeSection;
    private bool _isLiquidTagSection;
    private int _blockLevel;
    private bool _inFrontMatter;
    private bool _isExpressionDepthLimitReached;
    private int _expressionDepth;
    private bool _hasFatalError;
    private bool _isScientific;
    private bool _isKeepTrivia;
    private List`1<ScriptTrivia> _trivias;
    private Queue`1<ScriptStatement> _pendingStatements;
    private IScriptTerminal _lastTerminalWithTrivias;
    private Stack`1<char> _interpolatedNestedStringChars;
    public ParserOptions Options;
    private ScriptFrontMatter _frontmatter;
    [CompilerGeneratedAttribute]
private LogMessageBag <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<ScriptNode> <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptMode <CurrentParsingMode>k__BackingField;
    private int _allowNewLineLevel;
    private int _expressionLevel;
    internal static int PrecedenceOfAdd;
    internal static int PrecedenceOfMultiply;
    private ScriptBlockStatement _currentBlockStatement;
    public LogMessageBag Messages { get; private set; }
    public bool HasErrors { get; private set; }
    private Stack`1<ScriptNode> Blocks { get; }
    private Token Current { get; }
    private Token Previous { get; }
    private bool AnyInterpolation { get; }
    public SourceSpan CurrentSpan { get; }
    private ScriptMode CurrentParsingMode { get; private set; }
    private ScriptStringSlice CurrentStringSlice { get; }
    public int ExpressionLevel { get; }
    public Parser(Lexer lexer, Nullable`1<ParserOptions> options);
    [CompilerGeneratedAttribute]
public LogMessageBag get_Messages();
    [CompilerGeneratedAttribute]
private void set_Messages(LogMessageBag value);
    [CompilerGeneratedAttribute]
public bool get_HasErrors();
    [CompilerGeneratedAttribute]
private void set_HasErrors(bool value);
    [CompilerGeneratedAttribute]
private Stack`1<ScriptNode> get_Blocks();
    private Token get_Current();
    private Token get_Previous();
    private bool get_AnyInterpolation();
    public SourceSpan get_CurrentSpan();
    [CompilerGeneratedAttribute]
private ScriptMode get_CurrentParsingMode();
    [CompilerGeneratedAttribute]
private void set_CurrentParsingMode(ScriptMode value);
    public ScriptPage Run();
    private void PushTokenToTrivia();
    private ScriptStringSlice get_CurrentStringSlice();
    private ScriptStringSlice GetAsStringSlice(Token token);
    private T Open(T element);
    private T Open();
    private void FlushTrivias(IScriptTerminal element, bool isBefore);
    private T Close(T node);
    private void FlushTriviasToLastTerminal();
    private string GetAsText(Token localToken);
    private bool MatchText(Token localToken, string text);
    private void NextToken();
    private void PushTrivia(Token token);
    private Token PeekToken();
    private ScriptIdentifier ParseIdentifier();
    private bool IsHidden(TokenType tokenType);
    private void LogError(string text, bool isFatal);
    private void LogError(Token tokenArg, string text, bool isFatal);
    private SourceSpan GetSpanForToken(Token tokenArg);
    private void LogError(SourceSpan span, string text, bool isFatal);
    private void LogError(ScriptNode node, string message, bool isFatal);
    private void LogError(ScriptNode node, SourceSpan span, string message, bool isFatal);
    private void Log(LogMessage logMessage, bool isFatal);
    public int get_ExpressionLevel();
    private bool TryBinaryOperator(ScriptBinaryOperator& binaryOperator, Int32& precedence);
    private ScriptExpression ParseExpressionAsVariableOrStringOrExpression(ScriptNode parentNode);
    private ScriptExpression ParseExpression(ScriptNode parentNode, ScriptExpression parentExpression, int precedence, ParseExpressionMode mode, bool allowAssignment);
    private ScriptExpression ParseArrayInitializer();
    private ScriptExpression ParseObjectInitializer();
    private ScriptExpression ParseParenthesis();
    private ScriptExpression ParseInterpolatedExpression();
    private ScriptToken ParseToken(TokenType tokenType);
    private void ExpectAndParseTokenTo(ScriptToken existingToken, TokenType expectedTokenType);
    private ScriptKeyword ExpectAndParseKeywordTo(ScriptKeyword existingKeyword);
    private ScriptExpression ParseIncrementDecrementExpression();
    private ScriptExpression ParseUnaryExpression();
    private ScriptExpression TransformKeyword(ScriptExpression leftOperand);
    private void TransformLiquidFunctionCallToScriban(ScriptFunctionCall functionCall);
    private void EnterExpression();
    private ScriptExpression ExpectAndParseExpression(ScriptNode parentNode, ScriptExpression parentExpression, int newPrecedence, string message, ParseExpressionMode mode, bool allowAssignment);
    private ScriptExpression ExpectAndParseExpressionAndAnonymous(ScriptNode parentNode, ParseExpressionMode mode);
    public bool IsStartOfExpression();
    private bool TryGetCompoundAssignmentOperator(ScriptToken& scriptToken, TokenType& tokenType);
    private bool IsStartingAsUnaryExpression();
    private bool TryLiquidBinaryOperator(ScriptBinaryOperator& binaryOperator, Int32& precedence);
    internal static int GetDefaultBinaryOperatorPrecedence(ScriptBinaryOperator op);
    private static int GetDefaultUnaryOperatorPrecedence(ScriptUnaryOperator op);
    private bool IsPreviousCharWhitespace();
    private bool IsNextCharWhitespace();
    private void LeaveExpression();
    private ScriptBlockStatement ParseBlockStatement(ScriptNode parentStatement, bool parseEndOfStatementAfterEnd);
    private bool TryParseStatement(ScriptNode parent, bool parseEndOfStatementAfterEnd, ScriptStatement& statement, Boolean& hasEnd);
    private ScriptCaptureStatement ParseCaptureStatement();
    private ScriptEscapeStatement ParseEscapeStatement();
    private ScriptCaseStatement ParseCaseStatement();
    private ScriptConditionStatement ParseElseStatement(bool isElseIf);
    private ScriptStatement ParseExpressionStatement();
    private T ParseForStatement();
    private ScriptIfStatement ParseIfStatement(bool invert, ScriptKeyword elseKeyword);
    private ScriptRawStatement ParseRawStatement();
    private ScriptWhenStatement ParseWhenStatement();
    private void CheckNotInCase(ScriptNode parent, Token token);
    private ScriptVariable ExpectAndParseVariable(ScriptNode parentNode);
    private bool ExpectEndOfStatement();
    private ScriptStatement FindFirstStatementExpectingEnd();
    private static bool ExpectStatementEnd(ScriptNode scriptNode);
    private void ParseLiquidStatement(string identifier, ScriptNode parent, ScriptStatement& statement, Boolean& hasEnd, Boolean& nextStatement);
    private ScriptExpressionStatement ParseLiquidCycleStatement();
    private ScriptStatement ParseLiquidExpressionStatement(ScriptNode parent);
    private ScriptStatement ParseLiquidIfChanged();
    private ScriptStatement ParseLiquidIncDecStatement(bool isDec);
    private ScriptStatement ParseLiquidIncludeStatement();
    private void ParseScribanStatement(string identifier, ScriptNode parent, bool parseEndOfStatementAfterEnd, ScriptStatement& statement, Boolean& hasEnd, Boolean& nextStatement);
    private ScriptEndStatement ParseEndStatement(bool parseEndOfStatementAfterEnd);
    private ScriptFunction ParseFunctionStatement(bool isAnonymous);
    private ScriptImportStatement ParseImportStatement();
    private ScriptReadOnlyStatement ParseReadOnlyStatement();
    private ScriptReturnStatement ParseReturnStatement();
    private ScriptWhileStatement ParseWhileStatement();
    private ScriptWithStatement ParseWithStatement();
    private ScriptWrapStatement ParseWrapStatement();
    private void FixRawStatementAfterFrontMatter(ScriptPage page);
    private static bool IsScribanKeyword(string text);
    private ScriptExpression ParseVariableOrLiteral();
    private ScriptLiteral ParseFloat();
    private ScriptLiteral ParseImplicitString();
    private ScriptLiteral ParseInteger();
    private ScriptLiteral ParseHexaInteger();
    private ScriptLiteral ParseBinaryInteger();
    private ScriptLiteral ParseString();
    private ScriptLiteral ParseInterpolatedString();
    private ScriptExpression ParseVariable();
    private ScriptLiteral ParseVerbatimString();
    private static string ConvertFromUtf32(int utf32);
    private static bool IsVariableOrLiteral(Token token);
}
public enum Scriban.Parsing.ParserMessageType : Enum {
    public int value__;
    public static ParserMessageType Error;
    public static ParserMessageType Warning;
}
public class Scriban.Parsing.ParserOptions : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExpressionDepthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LiquidFunctionsToScriban>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParseFloatAsDecimal>k__BackingField;
    public Nullable`1<int> ExpressionDepthLimit { get; public set; }
    public bool LiquidFunctionsToScriban { get; public set; }
    public bool ParseFloatAsDecimal { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_ExpressionDepthLimit();
    [CompilerGeneratedAttribute]
public void set_ExpressionDepthLimit(Nullable`1<int> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_LiquidFunctionsToScriban();
    [CompilerGeneratedAttribute]
public void set_LiquidFunctionsToScriban(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ParseFloatAsDecimal();
    [CompilerGeneratedAttribute]
public void set_ParseFloatAsDecimal(bool value);
}
public enum Scriban.Parsing.ScriptLang : Enum {
    public int value__;
    public static ScriptLang Default;
    public static ScriptLang Liquid;
    public static ScriptLang Scientific;
}
public enum Scriban.Parsing.ScriptMode : Enum {
    public int value__;
    public static ScriptMode Default;
    public static ScriptMode FrontMatterOnly;
    public static ScriptMode FrontMatterAndContent;
    public static ScriptMode ScriptOnly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Parsing.SourceSpan : ValueType {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private TextPosition <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private TextPosition <End>k__BackingField;
    public string FileName { get; public set; }
    public bool IsEmpty { get; }
    public TextPosition Start { get; public set; }
    public TextPosition End { get; public set; }
    public int Length { get; }
    public SourceSpan(string fileName, TextPosition start, TextPosition end);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    public bool get_IsEmpty();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextPosition get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(TextPosition value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextPosition get_End();
    [CompilerGeneratedAttribute]
public void set_End(TextPosition value);
    public int get_Length();
    public virtual string ToString();
    public string ToStringSimple();
}
public class Scriban.Parsing.TextPosition : ValueType {
    public static TextPosition Eof;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    public int Offset { get; public set; }
    public int Column { get; public set; }
    public int Line { get; public set; }
    public TextPosition(int offset, int line, int column);
    private static TextPosition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    public TextPosition NextColumn(int offset);
    public TextPosition NextLine(int offset);
    public virtual string ToString();
    public string ToStringSimple();
    public sealed virtual bool Equals(TextPosition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextPosition left, TextPosition right);
    public static bool op_Inequality(TextPosition left, TextPosition right);
}
public class Scriban.Parsing.Token : ValueType {
    public static Token Eof;
    public TokenType Type;
    public TextPosition Start;
    public TextPosition End;
    public Token(TokenType type, TextPosition start, TextPosition end);
    private static Token();
    public virtual string ToString();
    public string GetText(string text);
    public bool Match(string textToMatch, string lexerText);
    public sealed virtual bool Equals(Token other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Token left, Token right);
    public static bool op_Inequality(Token left, Token right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
internal class Scriban.Parsing.TokenTextAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public TokenTextAttribute(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
}
public enum Scriban.Parsing.TokenType : Enum {
    public int value__;
    public static TokenType Invalid;
    public static TokenType FrontMatterMarker;
    public static TokenType CodeEnter;
    public static TokenType LiquidTagEnter;
    public static TokenType CodeExit;
    public static TokenType LiquidTagExit;
    public static TokenType Raw;
    public static TokenType Escape;
    public static TokenType EscapeEnter;
    public static TokenType EscapeExit;
    public static TokenType NewLine;
    public static TokenType Whitespace;
    public static TokenType WhitespaceFull;
    public static TokenType Comment;
    public static TokenType CommentMulti;
    public static TokenType IdentifierSpecial;
    public static TokenType Identifier;
    public static TokenType Integer;
    public static TokenType HexaInteger;
    public static TokenType BinaryInteger;
    public static TokenType Float;
    public static TokenType String;
    public static TokenType InterpolatedString;
    public static TokenType BeginInterpolatedString;
    public static TokenType ContinuationInterpolatedString;
    public static TokenType EndingInterpolatedString;
    public static TokenType ImplicitString;
    public static TokenType VerbatimString;
    public static TokenType SemiColon;
    public static TokenType Arroba;
    public static TokenType Caret;
    public static TokenType DoubleCaret;
    public static TokenType Colon;
    public static TokenType Equal;
    public static TokenType VerticalBar;
    public static TokenType PipeGreater;
    public static TokenType Exclamation;
    public static TokenType DoubleAmp;
    public static TokenType DoubleVerticalBar;
    public static TokenType Amp;
    public static TokenType Question;
    public static TokenType DoubleQuestion;
    public static TokenType QuestionDot;
    public static TokenType QuestionExclamation;
    public static TokenType DoubleEqual;
    public static TokenType ExclamationEqual;
    public static TokenType Less;
    public static TokenType Greater;
    public static TokenType LessEqual;
    public static TokenType GreaterEqual;
    public static TokenType Divide;
    public static TokenType DivideEqual;
    public static TokenType DoubleDivide;
    public static TokenType DoubleDivideEqual;
    public static TokenType Asterisk;
    public static TokenType AsteriskEqual;
    public static TokenType Plus;
    public static TokenType PlusEqual;
    public static TokenType DoublePlus;
    public static TokenType Minus;
    public static TokenType MinusEqual;
    public static TokenType DoubleMinus;
    public static TokenType Percent;
    public static TokenType PercentEqual;
    public static TokenType DoubleLessThan;
    public static TokenType DoubleGreaterThan;
    public static TokenType Comma;
    public static TokenType Dot;
    public static TokenType DoubleDot;
    public static TokenType TripleDot;
    public static TokenType DoubleDotLess;
    public static TokenType OpenParen;
    public static TokenType CloseParen;
    public static TokenType OpenBrace;
    public static TokenType CloseBrace;
    public static TokenType OpenBracket;
    public static TokenType CloseBracket;
    public static TokenType OpenInterpolatedBrace;
    public static TokenType CloseInterpolatedBrace;
    public static TokenType Custom;
    public static TokenType Custom1;
    public static TokenType Custom2;
    public static TokenType Custom3;
    public static TokenType Custom4;
    public static TokenType Custom5;
    public static TokenType Custom6;
    public static TokenType Custom7;
    public static TokenType Custom8;
    public static TokenType Custom9;
    public static TokenType Eof;
}
[ExtensionAttribute]
public static class Scriban.Parsing.TokenTypeExtensions : object {
    [ExtensionAttribute]
public static bool HasText(TokenType type);
    [ExtensionAttribute]
public static string ToText(TokenType type);
    [ExtensionAttribute]
public static bool IsStringToken(TokenType token);
    [ExtensionAttribute]
public static bool IsInterpolationStringToken(TokenType token);
}
public class Scriban.Parsing.TryMatchCustomTokenDelegate : MulticastDelegate {
    public TryMatchCustomTokenDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(string text, TextPosition position, Int32& length, TokenType& tokenType);
    public virtual IAsyncResult BeginInvoke(string text, TextPosition position, Int32& length, TokenType& tokenType, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Int32& length, TokenType& tokenType, IAsyncResult result);
}
[ExtensionAttribute]
internal static class Scriban.Parsing.Util : object {
    [ExtensionAttribute]
public static bool IsHex(char c);
    [ExtensionAttribute]
public static int HexToInt(char c);
}
public class Scriban.Runtime.Accessors.ArrayAccessor : object {
    public static ArrayAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static ArrayAccessor();
    public sealed virtual int GetLength(TemplateContext context, SourceSpan span, object target);
    public sealed virtual object GetValue(TemplateContext context, SourceSpan span, object target, int index);
    public sealed virtual void SetValue(TemplateContext context, SourceSpan span, object target, int index, object value);
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.ArrayAccessor/<GetMembers>d__6")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
public class Scriban.Runtime.Accessors.DictionaryAccessor : object {
    public static DictionaryAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static DictionaryAccessor();
    public static bool TryGet(object target, IObjectAccessor& accessor);
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.DictionaryAccessor/<GetMembers>d__4")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
internal class Scriban.Runtime.Accessors.DictionaryStringObjectAccessor : GenericDictionaryAccessor`2<string, object> {
    public static DictionaryStringObjectAccessor Default;
    private static DictionaryStringObjectAccessor();
}
internal class Scriban.Runtime.Accessors.GenericDictionaryAccessor`2 : object {
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.GenericDictionaryAccessor`2/<GetMembers>d__2")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object value, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    private TKey TransformToKey(TemplateContext context, string member);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
public class Scriban.Runtime.Accessors.ListAccessor : object {
    public static ListAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static ListAccessor();
    public sealed virtual int GetLength(TemplateContext context, SourceSpan span, object target);
    public sealed virtual object GetValue(TemplateContext context, SourceSpan span, object target, int index);
    public sealed virtual void SetValue(TemplateContext context, SourceSpan span, object target, int index, object value);
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.ListAccessor/<GetMembers>d__6")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
public class Scriban.Runtime.Accessors.NullAccessor : object {
    public static NullAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static NullAccessor();
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.NullAccessor/<GetMembers>d__2")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
internal class Scriban.Runtime.Accessors.PrimitiveAccessor : object {
    public static PrimitiveAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static PrimitiveAccessor();
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.PrimitiveAccessor/<GetMembers>d__3")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
    public sealed virtual int GetLength(TemplateContext context, SourceSpan span, object target);
    public sealed virtual object GetValue(TemplateContext context, SourceSpan span, object target, int index);
    public sealed virtual void SetValue(TemplateContext context, SourceSpan span, object target, int index, object value);
}
public class Scriban.Runtime.Accessors.ScriptObjectAccessor : object {
    public static IObjectAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static ScriptObjectAccessor();
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
public class Scriban.Runtime.Accessors.StringAccessor : object {
    public static StringAccessor Default;
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    private static StringAccessor();
    public sealed virtual int GetLength(TemplateContext context, SourceSpan span, object target);
    public sealed virtual object GetValue(TemplateContext context, SourceSpan span, object target, int index);
    public sealed virtual void SetValue(TemplateContext context, SourceSpan span, object target, int index, object value);
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    [IteratorStateMachineAttribute("Scriban.Runtime.Accessors.StringAccessor/<GetMembers>d__6")]
public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual Type get_IndexType();
}
public class Scriban.Runtime.Accessors.TypedObjectAccessor : object {
    private MemberFilterDelegate _filter;
    private Type _type;
    private MemberRenamerDelegate _renamer;
    private Dictionary`2<string, MemberInfo> _members;
    private PropertyInfo _indexer;
    [CompilerGeneratedAttribute]
private Type <IndexType>k__BackingField;
    public Type IndexType { get; private set; }
    public bool HasIndexer { get; }
    public TypedObjectAccessor(Type targetType, MemberFilterDelegate filter, MemberRenamerDelegate renamer);
    public TypedObjectAccessor(Type targetType, IEqualityComparer`1<string> keyComparer, MemberFilterDelegate filter, MemberRenamerDelegate renamer);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_IndexType();
    [CompilerGeneratedAttribute]
private void set_IndexType(Type value);
    public sealed virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    public sealed virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public sealed virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public sealed virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public sealed virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public sealed virtual bool get_HasIndexer();
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    private void PrepareMembers();
    private string Rename(MemberInfo member);
}
public class Scriban.Runtime.DelegateCustomAction : DelegateCustomFunction {
    [CompilerGeneratedAttribute]
private Action <Func>k__BackingField;
    public Action Func { get; }
    public DelegateCustomAction(Action func);
    [CompilerGeneratedAttribute]
public Action get_Func();
    protected virtual object InvokeImpl(TemplateContext context, SourceSpan span, Object[] arguments);
}
public class Scriban.Runtime.DelegateCustomFunction : DynamicCustomFunction {
    private Delegate _del;
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    public object Target { get; }
    public DelegateCustomFunction(Delegate del);
    public DelegateCustomFunction(object target, MethodInfo method);
    [CompilerGeneratedAttribute]
public object get_Target();
    public virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray scriptArguments, ScriptBlockStatement blockStatement);
    [AsyncStateMachineAttribute("Scriban.Runtime.DelegateCustomFunction/<InvokeAsync>d__7")]
public virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray scriptArguments, ScriptBlockStatement blockStatement);
    public static DelegateCustomFunction Create(Action action);
    public static DelegateCustomFunction Create(Action`1<T> action);
    public static DelegateCustomFunction Create(Action`2<T1, T2> action);
    public static DelegateCustomFunction Create(Action`3<T1, T2, T3> action);
    public static DelegateCustomFunction Create(Action`4<T1, T2, T3, T4> action);
    public static DelegateCustomFunction Create(Action`5<T1, T2, T3, T4, T5> action);
    public static DelegateCustomFunction CreateFunc(Func`1<TResult> func);
    public static DelegateCustomFunction CreateFunc(Func`2<T1, TResult> func);
    public static DelegateCustomFunction CreateFunc(Func`3<T1, T2, TResult> func);
    public static DelegateCustomFunction CreateFunc(Func`4<T1, T2, T3, TResult> func);
    public static DelegateCustomFunction CreateFunc(Func`5<T1, T2, T3, T4, TResult> func);
    public static DelegateCustomFunction CreateFunc(Func`6<T1, T2, T3, T4, T5, TResult> func);
    protected virtual object InvokeImpl(TemplateContext context, SourceSpan span, Object[] arguments);
    private Object[] PrepareArguments(TemplateContext context, ScriptNode callerContext, ScriptArray scriptArguments, Array& paramsArguments);
}
public abstract class Scriban.Runtime.DynamicCustomFunction : object {
    private static Dictionary`2<MethodInfo, Func`2<MethodInfo, DynamicCustomFunction>> BuiltinFunctionDelegates;
    public MethodInfo Method;
    protected ParameterInfo[] Parameters;
    private Type _returnType;
    private ScriptParameterInfo[] _parameterInfos;
    protected bool IsAwaitable;
    protected ScriptVarParamKind _varParamKind;
    protected int _paramsIndex;
    protected bool _hasTemplateContext;
    protected bool _hasSpan;
    protected int _optionalParameterCount;
    protected Type _paramsElementType;
    protected int _expectedNumberOfParameters;
    protected int _minimumRequiredParameters;
    protected int _firstIndexOfUserParameters;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public int RequiredParameterCount { get; }
    public int ParameterCount { get; }
    public ScriptVarParamKind VarParamKind { get; }
    public Type ReturnType { get; }
    public object Tag { get; public set; }
    private static DynamicCustomFunction();
    protected DynamicCustomFunction(MethodInfo method);
    [AsyncStateMachineAttribute("Scriban.Runtime.DynamicCustomFunction/<ConfigureAwait>d__66")]
protected ValueTask`1<object> ConfigureAwait(object result);
    protected ArgumentValue GetValueFromNamedArgument(TemplateContext context, ScriptNode callerContext, ScriptNamedArgument namedArg);
    public abstract virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public sealed virtual int get_RequiredParameterCount();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ScriptVarParamKind get_VarParamKind();
    public sealed virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public object get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(object value);
    public sealed virtual ScriptParameterInfo GetParameterInfo(int index);
    public virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public static DynamicCustomFunction Create(object target, MethodInfo method);
    public static DynamicCustomFunction Create(Delegate del);
    [AsyncStateMachineAttribute("Scriban.Runtime.DynamicCustomFunction/<GetValueFromNamedArgumentAsync>d__87")]
protected ValueTask`1<ArgumentValue> GetValueFromNamedArgumentAsync(TemplateContext context, ScriptNode callerContext, ScriptNamedArgument namedArg);
}
[DebuggerDisplayAttribute("<empty object>")]
public class Scriban.Runtime.EmptyScriptObject : object {
    public static EmptyScriptObject Default;
    public int Count { get; }
    public bool IsReadOnly { get; public set; }
    private static EmptyScriptObject();
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("Scriban.Runtime.EmptyScriptObject/<GetMembers>d__4")]
public sealed virtual IEnumerable`1<string> GetMembers();
    public sealed virtual bool Contains(string member);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void set_IsReadOnly(bool value);
    public sealed virtual bool TryGetValue(TemplateContext context, SourceSpan span, string member, Object& value);
    public sealed virtual bool CanWrite(string member);
    public sealed virtual bool TrySetValue(TemplateContext context, SourceSpan span, string member, object value, bool readOnly);
    public sealed virtual bool Remove(string member);
    public sealed virtual void SetReadOnly(string member, bool readOnly);
    public sealed virtual IScriptObject Clone(bool deep);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface Scriban.Runtime.IListAccessor {
    public abstract virtual int GetLength(TemplateContext context, SourceSpan span, object target);
    public abstract virtual object GetValue(TemplateContext context, SourceSpan span, object target, int index);
    public abstract virtual void SetValue(TemplateContext context, SourceSpan span, object target, int index, object value);
}
[NullableContextAttribute("1")]
public interface Scriban.Runtime.IObjectAccessor {
    public bool HasIndexer { get; }
    public Type IndexType { get; }
    public abstract virtual int GetMemberCount(TemplateContext context, SourceSpan span, object target);
    public abstract virtual IEnumerable`1<string> GetMembers(TemplateContext context, SourceSpan span, object target);
    public abstract virtual bool HasMember(TemplateContext context, SourceSpan span, object target, string member);
    public abstract virtual bool TryGetValue(TemplateContext context, SourceSpan span, object target, string member, Object& value);
    public abstract virtual bool TrySetValue(TemplateContext context, SourceSpan span, object target, string member, object value);
    public abstract virtual bool TryGetItem(TemplateContext context, SourceSpan span, object target, object index, Object& value);
    public abstract virtual bool TrySetItem(TemplateContext context, SourceSpan span, object target, object index, object value);
    public abstract virtual bool get_HasIndexer();
    public abstract virtual Type get_IndexType();
}
public interface Scriban.Runtime.IScriptCustomFunction {
    public abstract virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public abstract virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
}
public interface Scriban.Runtime.IScriptFunctionInfo {
    public int RequiredParameterCount { get; }
    public int ParameterCount { get; }
    public ScriptVarParamKind VarParamKind { get; }
    public Type ReturnType { get; }
    public abstract virtual int get_RequiredParameterCount();
    public abstract virtual int get_ParameterCount();
    public abstract virtual ScriptVarParamKind get_VarParamKind();
    public abstract virtual Type get_ReturnType();
    public abstract virtual ScriptParameterInfo GetParameterInfo(int index);
}
[NullableContextAttribute("1")]
public interface Scriban.Runtime.IScriptObject {
    public int Count { get; }
    public bool IsReadOnly { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<string> GetMembers();
    public abstract virtual bool Contains(string member);
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void set_IsReadOnly(bool value);
    public abstract virtual bool TryGetValue(TemplateContext context, SourceSpan span, string member, Object& value);
    public abstract virtual bool CanWrite(string member);
    public abstract virtual bool TrySetValue(TemplateContext context, SourceSpan span, string member, object value, bool readOnly);
    public abstract virtual bool Remove(string member);
    public abstract virtual void SetReadOnly(string member, bool readOnly);
    public abstract virtual IScriptObject Clone(bool deep);
}
[NullableContextAttribute("1")]
public interface Scriban.Runtime.IScriptOutput {
    public abstract virtual void Write(string text, int offset, int count);
    public abstract virtual ValueTask WriteAsync(string text, int offset, int count, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Scriban.Runtime.IScriptTransformable {
    public Type ElementType { get; }
    public abstract virtual Type get_ElementType();
    public abstract virtual bool CanTransform(Type transformType);
    public abstract virtual bool Visit(TemplateContext context, SourceSpan span, Func`2<object, bool> visit);
    public abstract virtual object Transform(TemplateContext context, SourceSpan span, Func`2<object, object> apply, Type destType);
}
[NullableContextAttribute("1")]
public interface Scriban.Runtime.ITemplateLoader {
    public abstract virtual string GetPath(TemplateContext context, SourceSpan callerSpan, string templateName);
    public abstract virtual string Load(TemplateContext context, SourceSpan callerSpan, string templatePath);
    public abstract virtual ValueTask`1<string> LoadAsync(TemplateContext context, SourceSpan callerSpan, string templatePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Scriban.Runtime.JsonElementExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static object ToScriban(JsonElement model);
    [ExtensionAttribute]
internal static IScriptObject CopyToScriptObject(JsonElement json, IScriptObject obj);
    [ExtensionAttribute]
internal static ScriptArray CopyToScriptArray(JsonElement json, ScriptArray array);
}
public class Scriban.Runtime.MemberFilterDelegate : MulticastDelegate {
    public MemberFilterDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(MemberInfo member);
    public virtual IAsyncResult BeginInvoke(MemberInfo member, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Scriban.Runtime.MemberRenamerDelegate : MulticastDelegate {
    public MemberRenamerDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(MemberInfo member);
    public virtual IAsyncResult BeginInvoke(MemberInfo member, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Scriban.Runtime.ScriptArray : ScriptArray`1<object> {
    public ScriptArray(int capacity);
    public ScriptArray(IEnumerable`1<object> values);
    public ScriptArray(IEnumerable values);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Scriban.Runtime.ScriptArray`1/DebugListView")]
public class Scriban.Runtime.ScriptArray`1 : object {
    private List`1<T> _values;
    private bool _isReadOnly;
    private ScriptObject _script;
    public int Capacity { get; public set; }
    public bool IsReadOnly { get; public set; }
    public ScriptObject ScriptObject { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public Type ElementType { get; }
    public ScriptArray`1(int capacity);
    public ScriptArray`1(T[] array);
    public ScriptArray`1(IEnumerable`1<T> values);
    public ScriptArray`1(IEnumerable values);
    public int get_Capacity();
    public void set_Capacity(int value);
    public virtual bool get_IsReadOnly();
    public virtual void set_IsReadOnly(bool value);
    public virtual IScriptObject Clone(bool deep);
    public ScriptObject get_ScriptObject();
    public sealed virtual int get_Count();
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public virtual void Add(T item);
    public void AddRange(IEnumerable`1<T> items);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public virtual void Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public virtual int IndexOf(T item);
    public virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public virtual bool Remove(T item);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptArray`1/<GetMembers>d__54")]
public sealed virtual IEnumerable`1<string> GetMembers();
    public virtual bool Contains(string member);
    public virtual bool TryGetValue(TemplateContext context, SourceSpan span, string member, Object& value);
    public virtual bool CanWrite(string member);
    public virtual bool TrySetValue(TemplateContext context, SourceSpan span, string member, object value, bool readOnly);
    public virtual bool Remove(string member);
    public virtual void SetReadOnly(string member, bool readOnly);
    public sealed virtual bool TryEvaluate(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object leftValue, SourceSpan rightSpan, object rightValue, Object& result);
    private static ScriptArray`1<T> TryGetArray(object rightValue);
    private static bool CompareTo(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, ScriptArray`1<T> left, ScriptArray`1<T> right);
    public sealed virtual Type get_ElementType();
    public virtual bool CanTransform(Type transformType);
    public virtual bool Visit(TemplateContext context, SourceSpan span, Func`2<object, bool> visit);
    public virtual object Transform(TemplateContext context, SourceSpan span, Func`2<object, object> apply, Type destType);
}
[ExtensionAttribute]
public static class Scriban.Runtime.ScriptFunctionInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsParameterType(IScriptFunctionInfo functionInfo, int index);
}
public class Scriban.Runtime.ScriptLazy`1 : object {
    private Lazy`1<T> _lazy;
    public int RequiredParameterCount { get; }
    public int ParameterCount { get; }
    public ScriptVarParamKind VarParamKind { get; }
    public Type ReturnType { get; }
    public ScriptLazy`1(Func`1<T> valueFactory);
    public sealed virtual int get_RequiredParameterCount();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ScriptVarParamKind get_VarParamKind();
    public sealed virtual Type get_ReturnType();
    public sealed virtual ScriptParameterInfo GetParameterInfo(int index);
    public sealed virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public sealed virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
}
[AttributeUsageAttribute("448")]
public class Scriban.Runtime.ScriptMemberIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum Scriban.Runtime.ScriptMemberImportFlags : Enum {
    public int value__;
    public static ScriptMemberImportFlags Field;
    public static ScriptMemberImportFlags Property;
    public static ScriptMemberImportFlags Method;
    [ObsoleteAttribute("Importing Method Instance is actually not supported - This flag will be removed in a future release")]
public static ScriptMemberImportFlags MethodInstance;
    public static ScriptMemberImportFlags All;
}
[DefaultMemberAttribute("Item")]
public class Scriban.Runtime.ScriptObject : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, InternalValue> <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    internal Dictionary`2<string, InternalValue> Store { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsReadOnly { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection`1<object> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    public ScriptObject(IEqualityComparer`1<string> keyComparer);
    public ScriptObject(int capacity);
    public ScriptObject(int capacity, IEqualityComparer`1<string> keyComparer);
    public ScriptObject(int capacity, Nullable`1<bool> autoImportStaticsFromThisType);
    public ScriptObject(int capacity, Nullable`1<bool> autoImportStaticsFromThisType, IEqualityComparer`1<string> keyComparer);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, InternalValue> get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(Dictionary`2<string, InternalValue> value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public virtual void set_IsReadOnly(bool value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual IEnumerable`1<string> GetMembers();
    public virtual bool Contains(string member);
    public virtual bool TryGetValue(TemplateContext context, SourceSpan span, string member, Object& value);
    public T GetSafeValue(string name, T defaultValue);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public virtual bool CanWrite(string member);
    public virtual bool TrySetValue(TemplateContext context, SourceSpan span, string member, object value, bool readOnly);
    public void SetValue(string member, object value, bool readOnly);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public virtual bool Remove(string member);
    public virtual void SetReadOnly(string member, bool readOnly);
    private static bool IsSimpleKey(string key);
    public virtual string ToString(string format, IFormatProvider formatProvider);
    public string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString();
    public virtual void CopyTo(ScriptObject dest);
    public virtual IScriptObject Clone(bool deep);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptObject/<GetEnumerator>d__60")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ScriptMemberIgnoreAttribute]
public static ScriptObject From(object obj);
    [ScriptMemberIgnoreAttribute]
public static bool IsImportable(object obj);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
}
[ExtensionAttribute]
public static class Scriban.Runtime.ScriptObjectExtensions : object {
    [ExtensionAttribute]
public static void AssertNotReadOnly(IScriptObject scriptObject);
    [ExtensionAttribute]
public static void Import(IScriptObject script, object obj, MemberFilterDelegate filter, MemberRenamerDelegate renamer);
    [ExtensionAttribute]
public static void Import(IScriptObject script, JsonElement json);
    [ExtensionAttribute]
public static bool TryGetValue(IScriptObject this, string key, Object& value);
    [ExtensionAttribute]
public static void SetValue(IScriptObject this, string member, object value, bool readOnly);
    [ExtensionAttribute]
public static void Import(IScriptObject this, IScriptObject other);
    [ExtensionAttribute]
private static void ImportDictionary(IScriptObject this, IDictionary dictionary);
    [ExtensionAttribute]
public static ScriptObject GetScriptObject(IScriptObject this);
    [ExtensionAttribute]
public static void ImportMember(IScriptObject script, object obj, string memberName, string exportName);
    [ExtensionAttribute]
public static void Import(IScriptObject script, object obj, ScriptMemberImportFlags flags, MemberFilterDelegate filter, MemberRenamerDelegate renamer);
    [ExtensionAttribute]
public static void Import(IScriptObject script, string member, Delegate function);
    private static object ConvertValue(object value);
}
[ExtensionAttribute]
public static class Scriban.Runtime.ScriptOutputExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Write(IScriptOutput scriptOutput, string text);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Write(IScriptOutput scriptOutput, ScriptStringSlice text);
    [AsyncStateMachineAttribute("Scriban.Runtime.ScriptOutputExtensions/<WriteAsync>d__2")]
[ExtensionAttribute]
public static ValueTask WriteAsync(IScriptOutput scriptOutput, string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Scriban.Runtime.ScriptOutputExtensions/<WriteAsync>d__3")]
[ExtensionAttribute]
public static ValueTask WriteAsync(IScriptOutput scriptOutput, ScriptStringSlice text, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{ParameterType} {Name}")]
public class Scriban.Runtime.ScriptParameterInfo : ValueType {
    public Type ParameterType;
    public string Name;
    public bool HasDefaultValue;
    public object DefaultValue;
    public ScriptParameterInfo(Type parameterType, string name);
    public ScriptParameterInfo(Type parameterType, string name, object defaultValue);
    public sealed virtual bool Equals(ScriptParameterInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ScriptParameterInfo left, ScriptParameterInfo right);
    public static bool op_Inequality(ScriptParameterInfo left, ScriptParameterInfo right);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Scriban.Runtime.ScriptPipeArguments : Stack`1<ScriptExpression> {
    public ScriptPipeArguments(int capacity);
}
[DefaultMemberAttribute("Item")]
public class Scriban.Runtime.ScriptRange : object {
    private IEnumerable _values;
    public IEnumerable Values { get; }
    public Type ElementType { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public object Item { get; public set; }
    public ScriptRange(IEnumerable values);
    public IEnumerable get_Values();
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Type get_ElementType();
    public sealed virtual bool CanTransform(Type transformType);
    public virtual bool Visit(TemplateContext context, SourceSpan span, Func`2<object, bool> visit);
    public virtual object Transform(TemplateContext context, SourceSpan span, Func`2<object, object> apply, Type destType);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<TransformImpl>d__12")]
private IEnumerable TransformImpl(Func`2<object, object> apply);
    public static ScriptRange Offset(IEnumerable list, int index);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<OffsetImpl>d__14")]
private static IEnumerable OffsetImpl(IEnumerable list, int index);
    public static ScriptRange Limit(IEnumerable list, int count);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<LimitImpl>d__16")]
private static IEnumerable LimitImpl(IEnumerable list, int count);
    public static ScriptRange Compact(IEnumerable list);
    public static ScriptRange Uniq(IEnumerable list);
    public static ScriptRange Reverse(IEnumerable list);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<CompactImpl>d__20")]
private static IEnumerable CompactImpl(IEnumerable list);
    public static ScriptRange BinaryOr(IEnumerable`1<object> left, IEnumerable`1<object> right);
    public static ScriptRange BinaryAnd(IEnumerable`1<object> left, IEnumerable`1<object> right);
    public static ScriptRange ShiftLeft(IEnumerable left, object value);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<ShiftLeftImpl>d__24")]
private static IEnumerable ShiftLeftImpl(IEnumerable left, object value);
    public static ScriptRange ShiftRight(object value, IEnumerable right);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<ShiftRightImpl>d__26")]
private static IEnumerable ShiftRightImpl(object value, IEnumerable right);
    public static ScriptRange Multiply(IEnumerable left, int count);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<MultiplyImpl>d__28")]
private static IEnumerable MultiplyImpl(IEnumerable left, int count);
    public static ScriptRange Divide(IEnumerable left, int count);
    public static ScriptRange Modulus(IEnumerable left, int count);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<DivideImpl>d__31")]
private static IEnumerable DivideImpl(IEnumerable left, int count);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<ModulusImpl>d__32")]
private static IEnumerable ModulusImpl(IEnumerable left, int modulus);
    public static ScriptRange Concat(IEnumerable left, IEnumerable right);
    [IteratorStateMachineAttribute("Scriban.Runtime.ScriptRange/<ConcatImpl>d__34")]
private static IEnumerable ConcatImpl(IEnumerable left, IEnumerable right);
    public sealed virtual bool TryEvaluate(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object leftValue, SourceSpan rightSpan, object rightValue, Object& result);
    private static IEnumerable`1<object> TryGetRange(object rightValue);
    private static bool CompareTo(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, IEnumerable`1<object> left, IEnumerable`1<object> right);
    public sealed virtual void Add(object item);
    private int AddImpl(object item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object item);
    public sealed virtual void CopyTo(Object[] array, int arrayIndex);
    public sealed virtual bool Remove(object item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(object item);
    public sealed virtual void Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
}
public enum Scriban.Runtime.ScriptVarParamKind : Enum {
    public int value__;
    public static ScriptVarParamKind None;
    public static ScriptVarParamKind Direct;
    public static ScriptVarParamKind LastParameter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Runtime.StandardMemberRenamer : object {
    public static MemberRenamerDelegate Default;
    private static StandardMemberRenamer();
    public static string Rename(MemberInfo member);
    public static string Rename(string name);
}
public class Scriban.Runtime.StringBuilderOutput : object {
    [ThreadStaticAttribute]
private static StringBuilder TlsBuilder;
    [CompilerGeneratedAttribute]
private StringBuilder <Builder>k__BackingField;
    public StringBuilder Builder { get; }
    public StringBuilderOutput(StringBuilder builder);
    [CompilerGeneratedAttribute]
public StringBuilder get_Builder();
    public sealed virtual void Write(string text, int offset, int count);
    public static StringBuilderOutput GetThreadInstance();
    public sealed virtual ValueTask WriteAsync(string text, int offset, int count, CancellationToken cancellationToken);
    public virtual string ToString();
}
public class Scriban.Runtime.TextWriterOutput : object {
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    public TextWriter Writer { get; }
    public TextWriterOutput(TextWriter writer);
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    public sealed virtual void Write(string text, int offset, int count);
    [AsyncStateMachineAttribute("Scriban.Runtime.TextWriterOutput/<WriteAsync>d__6")]
public sealed virtual ValueTask WriteAsync(string text, int offset, int count, CancellationToken cancellationToken);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.ScriptPrinter : object {
    private IScriptOutput _output;
    private bool _isScriptOnly;
    private bool _isInCode;
    private bool _expectSpace;
    private bool _expectEndOfStatement;
    private bool _previousHasSpace;
    private bool _hasEndOfStatement;
    private bool _hasComma;
    [NullableAttribute("0")]
private FastStack`1<bool> _isWhileLoop;
    public ScriptPrinterOptions Options;
    public bool PreviousHasSpace { get; }
    public bool IsInWhileLoop { get; }
    public ScriptPrinter(IScriptOutput output, ScriptPrinterOptions options);
    public bool get_PreviousHasSpace();
    public bool get_IsInWhileLoop();
    public ScriptPrinter Write(ScriptNode node);
    public ScriptPrinter Write(string text);
    public ScriptPrinter Write(ScriptStringSlice slice);
    public ScriptPrinter ExpectEos();
    public ScriptPrinter ExpectSpace();
    public ScriptPrinter WriteListWithCommas(IList`1<T> list);
    public ScriptPrinter WriteEnterCode(int escape);
    public ScriptPrinter WriteExitCode(int escape);
    private void WriteBegin(ScriptNode node);
    private void WriteEnd(ScriptNode node);
    private static bool IsFrontMarker(ScriptNode node);
    private void HandleEos(ScriptNode node);
    private static bool IsBlockOrPage(ScriptNode node);
    private void WriteTrivias(ScriptNode node, bool before);
}
public class Scriban.ScriptPrinterOptions : ValueType {
    public ScriptMode Mode;
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptConvertibleFrom {
    public abstract virtual bool TryConvertFrom(TemplateContext context, SourceSpan span, object value);
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptConvertibleTo {
    public abstract virtual bool TryConvertTo(TemplateContext context, SourceSpan span, Type type, Object& value);
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptCustomBinaryOperation {
    public abstract virtual bool TryEvaluate(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object leftValue, SourceSpan rightSpan, object rightValue, Object& result);
}
public interface Scriban.Syntax.IScriptCustomImplicitMultiplyPrecedence {
}
public interface Scriban.Syntax.IScriptCustomType {
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptCustomTypeInfo {
    public string TypeName { get; }
    public abstract virtual string get_TypeName();
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptCustomUnaryOperation {
    public abstract virtual bool TryEvaluate(TemplateContext context, SourceSpan span, ScriptUnaryOperator op, object rightValue, Object& result);
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptNamedArgumentContainer {
    public ScriptList`1<ScriptNamedArgument> NamedArguments { get; public set; }
    public abstract virtual ScriptList`1<ScriptNamedArgument> get_NamedArguments();
    public abstract virtual void set_NamedArguments(ScriptList`1<ScriptNamedArgument> value);
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptTerminal {
    public ScriptTrivias Trivias { get; public set; }
    public abstract virtual ScriptTrivias get_Trivias();
    public abstract virtual void set_Trivias(ScriptTrivias value);
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptVariablePath {
    public abstract virtual object GetValue(TemplateContext context);
    public abstract virtual void SetValue(TemplateContext context, object valueToSet);
    public abstract virtual string GetFirstPath();
    public abstract virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    public abstract virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
}
[NullableContextAttribute("1")]
public interface Scriban.Syntax.IScriptVisitorContext {
    public ScriptNode Current { get; }
    public ScriptNode Parent { get; }
    public IEnumerable`1<ScriptNode> Ancestors { get; }
    public abstract virtual ScriptNode get_Current();
    public abstract virtual ScriptNode get_Parent();
    public abstract virtual IEnumerable`1<ScriptNode> get_Ancestors();
}
internal class Scriban.Syntax.ScientificFunctionCallRewriter : object {
    private static int ImplicitFunctionCallPrecedence;
    [AsyncStateMachineAttribute("Scriban.Syntax.ScientificFunctionCallRewriter/<FlattenBinaryExpressionsAsync>d__0")]
private static ValueTask FlattenBinaryExpressionsAsync(TemplateContext context, ScriptExpression expression, List`1<BinaryExpressionOrOperator> expressions);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScientificFunctionCallRewriter/<GetFunctionCallKindAsync>d__1")]
private static ValueTask`1<FunctionCallKind> GetFunctionCallKindAsync(TemplateContext context, ScriptExpression expression);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScientificFunctionCallRewriter/<RewriteAsync>d__2")]
public static ValueTask`1<ScriptExpression> RewriteAsync(TemplateContext context, ScriptBinaryExpression binaryExpression);
    public static ScriptExpression Rewrite(TemplateContext context, ScriptBinaryExpression binaryExpression);
    private static bool HasImplicitBinaryExpression(ScriptExpression expression);
    private static void FlattenBinaryExpressions(TemplateContext context, ScriptExpression expression, List`1<BinaryExpressionOrOperator> expressions);
    private static ScriptExpression ParseBinaryExpressionTree(BinaryExpressionIterator it, int precedence, bool isExpectingExpression);
    private static FunctionCallKind GetFunctionCallKind(TemplateContext context, ScriptExpression expression);
}
public class Scriban.Syntax.ScriptAbortException : ScriptRuntimeException {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public ScriptAbortException(SourceSpan span, CancellationToken cancellationToken);
    public ScriptAbortException(SourceSpan span, string message, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Scriban.Syntax.ScriptAnonymousFunction : ScriptExpression {
    private ScriptFunction _function;
    public int ChildrenCount { get; }
    public ScriptFunction Function { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptFunction get_Function();
    public void set_Function(ScriptFunction value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Syntax.ScriptArgumentBinary : ScriptExpression {
    private ScriptToken _operatorToken;
    [CompilerGeneratedAttribute]
private ScriptBinaryOperator <Operator>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptBinaryOperator Operator { get; public set; }
    public ScriptToken OperatorToken { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ScriptBinaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(ScriptBinaryOperator value);
    public ScriptToken get_OperatorToken();
    public void set_OperatorToken(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Syntax.ScriptArgumentException : Exception {
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    public int ArgumentIndex { get; }
    [NullableContextAttribute("1")]
public ScriptArgumentException(int argumentIndex, string message);
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
}
[ScriptSyntaxAttribute("array initializer", "[item1, item2,...]")]
public class Scriban.Syntax.ScriptArrayInitializerExpression : ScriptExpression {
    private ScriptList`1<ScriptExpression> _values;
    private ScriptToken _openBracketToken;
    private ScriptToken _closeBracketToken;
    public int ChildrenCount { get; }
    public ScriptToken OpenBracketToken { get; public set; }
    public ScriptList`1<ScriptExpression> Values { get; public set; }
    public ScriptToken CloseBracketToken { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptArrayInitializerExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptToken get_OpenBracketToken();
    public void set_OpenBracketToken(ScriptToken value);
    public ScriptList`1<ScriptExpression> get_Values();
    public void set_Values(ScriptList`1<ScriptExpression> value);
    public ScriptToken get_CloseBracketToken();
    public void set_CloseBracketToken(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("assign expression", "<target_expression> = <value_expression>")]
public class Scriban.Syntax.ScriptAssignExpression : ScriptExpression {
    private ScriptExpression _target;
    private ScriptToken _equalToken;
    private ScriptExpression _value;
    public int ChildrenCount { get; }
    public ScriptExpression Target { get; public set; }
    public ScriptToken EqualToken { get; public set; }
    public ScriptExpression Value { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptAssignExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptAssignExpression/<GetValueToSetAsync>d__1")]
private ValueTask`1<object> GetValueToSetAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Target();
    public void set_Target(ScriptExpression value);
    public ScriptToken get_EqualToken();
    public void set_EqualToken(ScriptToken value);
    public ScriptExpression get_Value();
    public void set_Value(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    private object GetValueToSet(TemplateContext context);
    public virtual bool CanHaveLeadingTrivia();
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("binary expression", "<expression> operator <expression>")]
public class Scriban.Syntax.ScriptBinaryExpression : ScriptExpression {
    private ScriptExpression _left;
    private ScriptToken _operatorToken;
    private ScriptExpression _right;
    [CompilerGeneratedAttribute]
private ScriptBinaryOperator <Operator>k__BackingField;
    private static BigInteger MaxBigInteger;
    public int ChildrenCount { get; }
    public ScriptExpression Left { get; public set; }
    public ScriptBinaryOperator Operator { get; public set; }
    public ScriptToken OperatorToken { get; public set; }
    public string OperatorAsText { get; }
    public ScriptExpression Right { get; public set; }
    private static ScriptBinaryExpression();
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptBinaryExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Left();
    public void set_Left(ScriptExpression value);
    [CompilerGeneratedAttribute]
public ScriptBinaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(ScriptBinaryOperator value);
    public ScriptToken get_OperatorToken();
    public void set_OperatorToken(ScriptToken value);
    public string get_OperatorAsText();
    public ScriptExpression get_Right();
    public void set_Right(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual bool CanHaveLeadingTrivia();
    public static object Evaluate(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, object leftValue, object rightValue);
    public static object Evaluate(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object leftValue, SourceSpan rightSpan, object rightValue);
    private static object CalculateEmpty(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object leftValue, SourceSpan rightSpan, object rightValue);
    private static object CalculateToString(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object left, SourceSpan rightSpan, object right);
    [IteratorStateMachineAttribute("Scriban.Syntax.ScriptBinaryExpression/<RangeInclude>d__31")]
private static IEnumerable`1<object> RangeInclude(long left, long right);
    [IteratorStateMachineAttribute("Scriban.Syntax.ScriptBinaryExpression/<RangeExclude>d__32")]
private static IEnumerable`1<object> RangeExclude(long left, long right);
    [IteratorStateMachineAttribute("Scriban.Syntax.ScriptBinaryExpression/<RangeInclude>d__33")]
private static IEnumerable`1<object> RangeInclude(BigInteger left, BigInteger right);
    [IteratorStateMachineAttribute("Scriban.Syntax.ScriptBinaryExpression/<RangeExclude>d__34")]
private static IEnumerable`1<object> RangeExclude(BigInteger left, BigInteger right);
    private static object CalculateOthers(TemplateContext context, SourceSpan span, ScriptBinaryOperator op, SourceSpan leftSpan, object leftValue, SourceSpan rightSpan, object rightValue);
    private static object CalculateInt(ScriptBinaryOperator op, SourceSpan span, int left, int right);
    private static object FitToBestInteger(object value);
    private static object FitToBestInteger(long longValue);
    private static object FitToBestInteger(BigInteger bigInt);
    private static object CalculateLongWithInt(ScriptBinaryOperator op, SourceSpan span, int leftInt, int rightInt);
    private static object CalculateLong(ScriptBinaryOperator op, SourceSpan span, long left, long right);
    private static object CalculateLong(ScriptBinaryOperator op, SourceSpan span, ulong left, ulong right);
    private static object CalculateBigInteger(ScriptBinaryOperator op, SourceSpan span, BigInteger left, BigInteger right);
    private static object CalculateBigIntegerNoFit(ScriptBinaryOperator op, SourceSpan span, BigInteger left, BigInteger right);
    private static object CalculateDouble(ScriptBinaryOperator op, SourceSpan span, double left, double right);
    private static object CalculateDecimal(ScriptBinaryOperator op, SourceSpan span, decimal left, decimal right);
    private static object CalculateFloat(ScriptBinaryOperator op, SourceSpan span, float left, float right);
    private static object CalculateDateTime(ScriptBinaryOperator op, SourceSpan span, DateTime left, DateTime right);
    private static object CalculateDateTime(ScriptBinaryOperator op, SourceSpan span, DateTime left, TimeSpan right);
    private static object CalculateBool(ScriptBinaryOperator op, SourceSpan span, bool left, bool right);
}
public enum Scriban.Syntax.ScriptBinaryOperator : Enum {
    public int value__;
    public static ScriptBinaryOperator None;
    public static ScriptBinaryOperator EmptyCoalescing;
    public static ScriptBinaryOperator NotEmptyCoalescing;
    public static ScriptBinaryOperator Or;
    public static ScriptBinaryOperator And;
    public static ScriptBinaryOperator BinaryOr;
    public static ScriptBinaryOperator BinaryAnd;
    public static ScriptBinaryOperator CompareEqual;
    public static ScriptBinaryOperator CompareNotEqual;
    public static ScriptBinaryOperator CompareLessOrEqual;
    public static ScriptBinaryOperator CompareGreaterOrEqual;
    public static ScriptBinaryOperator CompareLess;
    public static ScriptBinaryOperator CompareGreater;
    public static ScriptBinaryOperator LiquidContains;
    public static ScriptBinaryOperator LiquidStartsWith;
    public static ScriptBinaryOperator LiquidEndsWith;
    public static ScriptBinaryOperator LiquidHasKey;
    public static ScriptBinaryOperator LiquidHasValue;
    public static ScriptBinaryOperator Add;
    public static ScriptBinaryOperator Subtract;
    [ObsoleteAttribute]
public static ScriptBinaryOperator Substract;
    public static ScriptBinaryOperator Multiply;
    public static ScriptBinaryOperator Divide;
    public static ScriptBinaryOperator DivideRound;
    public static ScriptBinaryOperator Modulus;
    public static ScriptBinaryOperator ShiftLeft;
    public static ScriptBinaryOperator ShiftRight;
    public static ScriptBinaryOperator Power;
    public static ScriptBinaryOperator RangeInclude;
    public static ScriptBinaryOperator RangeExclude;
    public static ScriptBinaryOperator OpenInterpolated;
    public static ScriptBinaryOperator CloseInterpolated;
    public static ScriptBinaryOperator Custom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptBinaryOperatorExtensions : object {
    [ExtensionAttribute]
public static ScriptToken ToToken(ScriptBinaryOperator op);
    [ExtensionAttribute]
public static TokenType ToTokenType(ScriptBinaryOperator op);
    [ExtensionAttribute]
public static string ToText(ScriptBinaryOperator op);
}
[ScriptSyntaxAttribute("block statement", "<statement>...end")]
public class Scriban.Syntax.ScriptBlockStatement : ScriptStatement {
    private ScriptList`1<ScriptStatement> _statements;
    public int ChildrenCount { get; }
    public ScriptList`1<ScriptStatement> Statements { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptBlockStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptList`1<ScriptStatement> get_Statements();
    public void set_Statements(ScriptList`1<ScriptStatement> value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual bool CanHaveLeadingTrivia();
}
[ScriptSyntaxAttribute("break statement", "break")]
public class Scriban.Syntax.ScriptBreakStatement : ScriptStatement {
    private ScriptKeyword _breakKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword BreakKeyword { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_BreakKeyword();
    public void set_BreakKeyword(ScriptKeyword value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("capture statement", "capture <variable> ... end")]
public class Scriban.Syntax.ScriptCaptureStatement : ScriptStatement {
    private ScriptExpression _target;
    private ScriptBlockStatement _body;
    private ScriptKeyword _captureKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword CaptureKeyword { get; public set; }
    public ScriptExpression Target { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptCaptureStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_CaptureKeyword();
    public void set_CaptureKeyword(ScriptKeyword value);
    public ScriptExpression get_Target();
    public void set_Target(ScriptExpression value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("case statement", "case <expression> ... end|when|else")]
public class Scriban.Syntax.ScriptCaseStatement : ScriptConditionStatement {
    private ScriptKeyword _caseKeyword;
    private ScriptExpression _value;
    private ScriptBlockStatement _body;
    public int ChildrenCount { get; }
    public ScriptKeyword CaseKeyword { get; public set; }
    public ScriptExpression Value { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptCaseStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_CaseKeyword();
    public void set_CaseKeyword(ScriptKeyword value);
    public ScriptExpression get_Value();
    public void set_Value(ScriptExpression value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scriban.Syntax.ScriptCloner : ScriptRewriter {
    public static ScriptCloner Instance;
    public static ScriptCloner WithTrivias;
    private static ScriptCloner();
}
[ScriptSyntaxAttribute("conditional expression", "<condition> ? <then_value> : <else_value>")]
public class Scriban.Syntax.ScriptConditionalExpression : ScriptExpression {
    private ScriptExpression _condition;
    private ScriptToken _questionToken;
    private ScriptExpression _thenValue;
    private ScriptToken _colonToken;
    private ScriptExpression _elseValue;
    public int ChildrenCount { get; }
    public ScriptExpression Condition { get; public set; }
    public ScriptToken QuestionToken { get; public set; }
    public ScriptExpression ThenValue { get; public set; }
    public ScriptToken ColonToken { get; public set; }
    public ScriptExpression ElseValue { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptConditionalExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Condition();
    public void set_Condition(ScriptExpression value);
    public ScriptToken get_QuestionToken();
    public void set_QuestionToken(ScriptToken value);
    public ScriptExpression get_ThenValue();
    public void set_ThenValue(ScriptExpression value);
    public ScriptToken get_ColonToken();
    public void set_ColonToken(ScriptToken value);
    public ScriptExpression get_ElseValue();
    public void set_ElseValue(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual bool CanHaveLeadingTrivia();
}
public abstract class Scriban.Syntax.ScriptConditionStatement : ScriptStatement {
}
[ScriptSyntaxAttribute("continue statement", "continue")]
public class Scriban.Syntax.ScriptContinueStatement : ScriptStatement {
    private ScriptKeyword _continueKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword ContinueKeyword { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ContinueKeyword();
    public void set_ContinueKeyword(ScriptKeyword value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("else statement", "else | else if <expression> ... end|else|else if")]
public class Scriban.Syntax.ScriptElseStatement : ScriptConditionStatement {
    private ScriptKeyword _elseKeyword;
    private ScriptBlockStatement _body;
    public int ChildrenCount { get; }
    public ScriptKeyword ElseKeyword { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptElseStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ElseKeyword();
    public void set_ElseKeyword(ScriptKeyword value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("end statement", "end")]
public class Scriban.Syntax.ScriptEndStatement : ScriptStatement {
    private ScriptKeyword _endKeyword;
    [CompilerGeneratedAttribute]
private bool <ExpectEos>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptKeyword EndKeyword { get; public set; }
    public bool ExpectEos { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_EndKeyword();
    public void set_EndKeyword(ScriptKeyword value);
    [CompilerGeneratedAttribute]
public bool get_ExpectEos();
    [CompilerGeneratedAttribute]
public void set_ExpectEos(bool value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("{{ or }}", "{{ or }}")]
public class Scriban.Syntax.ScriptEscapeStatement : ScriptStatement {
    [CompilerGeneratedAttribute]
private ScriptTrivias <Trivias>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptWhitespaceMode <WhitespaceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEntering>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EscapeCount>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptTrivias Trivias { get; public set; }
    public ScriptWhitespaceMode WhitespaceMode { get; public set; }
    public string Indent { get; public set; }
    public bool IsEntering { get; public set; }
    public bool IsClosing { get; }
    public int EscapeCount { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public sealed virtual ScriptTrivias get_Trivias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Trivias(ScriptTrivias value);
    [CompilerGeneratedAttribute]
public ScriptWhitespaceMode get_WhitespaceMode();
    [CompilerGeneratedAttribute]
public void set_WhitespaceMode(ScriptWhitespaceMode value);
    [CompilerGeneratedAttribute]
public string get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(string value);
    [CompilerGeneratedAttribute]
public bool get_IsEntering();
    [CompilerGeneratedAttribute]
public void set_IsEntering(bool value);
    public bool get_IsClosing();
    [CompilerGeneratedAttribute]
public int get_EscapeCount();
    [CompilerGeneratedAttribute]
public void set_EscapeCount(int value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    private void WriteWhitespaceMode(ScriptPrinter printer);
}
public abstract class Scriban.Syntax.ScriptExpression : ScriptNode {
}
[ScriptSyntaxAttribute("expression statement", "<expression>")]
public class Scriban.Syntax.ScriptExpressionStatement : ScriptStatement {
    private ScriptExpression _expression;
    public int ChildrenCount { get; }
    public ScriptExpression Expression { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptExpressionStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Expression();
    public void set_Expression(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public enum Scriban.Syntax.ScriptFlowState : Enum {
    public int value__;
    public static ScriptFlowState None;
    public static ScriptFlowState Break;
    public static ScriptFlowState Continue;
    public static ScriptFlowState Return;
}
public class Scriban.Syntax.ScriptFormatter : ScriptRewriter {
    private TemplateContext _context;
    private ScriptFormatterFlags _flags;
    private bool _isScientific;
    private CompressWhitespacesVisitor _compressWhitespacesVisitor;
    public ScriptFormatterOptions Options;
    public ScriptFormatter(ScriptFormatterOptions options);
    public ScriptNode Format(ScriptNode node);
    public virtual ScriptNode Visit(ScriptNode node);
    public virtual ScriptNode Visit(ScriptAssignExpression node);
    public virtual ScriptNode Visit(ScriptPipeCall node);
    public virtual ScriptNode Visit(ScriptBinaryExpression node);
    public virtual ScriptNode Visit(ScriptExpressionStatement node);
    public virtual ScriptNode Visit(ScriptFunctionCall node);
    public virtual ScriptNode Visit(ScriptFunction node);
    private ScriptExpression DeNestExpression(ScriptExpression expr);
    private static bool HasSimilarPrecedenceThanMultiply(ScriptBinaryOperator op);
}
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptFormatterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ScriptNode Format(ScriptNode node, ScriptFormatterOptions options);
    [ExtensionAttribute]
public static bool HasFlags(ScriptFormatterFlags input, ScriptFormatterFlags flags);
}
[FlagsAttribute]
public enum Scriban.Syntax.ScriptFormatterFlags : Enum {
    public int value__;
    public static ScriptFormatterFlags None;
    public static ScriptFormatterFlags ExplicitParenthesis;
    public static ScriptFormatterFlags AddSpaceBetweenOperators;
    public static ScriptFormatterFlags RemoveExistingTrivias;
    public static ScriptFormatterFlags CompressSpaces;
    public static ScriptFormatterFlags MinimizeParenthesisNesting;
    public static ScriptFormatterFlags Clean;
    public static ScriptFormatterFlags ExplicitClean;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Lang: {Language} Flags: {Flags}")]
public class Scriban.Syntax.ScriptFormatterOptions : ValueType {
    public ScriptLang Language;
    public ScriptFormatterFlags Flags;
    public TemplateContext Context;
    public ScriptFormatterOptions(ScriptFormatterFlags flags);
    public ScriptFormatterOptions(TemplateContext context, ScriptLang language, ScriptFormatterFlags flags);
}
[ScriptSyntaxAttribute("for statement", "for <variable> in <expression> ... end")]
public class Scriban.Syntax.ScriptForStatement : ScriptLoopStatementBase {
    private ScriptKeyword _forOrTableRowKeyword;
    private ScriptExpression _variable;
    private ScriptKeyword _inKeyword;
    private ScriptExpression _iterator;
    private ScriptList`1<ScriptNamedArgument> _namedArguments;
    private ScriptBlockStatement _body;
    private ScriptElseStatement _else;
    [CompilerGeneratedAttribute]
private bool <SetContinue>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptKeyword ForOrTableRowKeyword { get; public set; }
    public ScriptExpression Variable { get; public set; }
    public ScriptKeyword InKeyword { get; public set; }
    public ScriptExpression Iterator { get; public set; }
    public ScriptList`1<ScriptNamedArgument> NamedArguments { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    public ScriptElseStatement Else { get; public set; }
    public bool SetContinue { get; public set; }
    internal ScriptNode IteratorOrLastParameter { get; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptForStatement/<EvaluateImplAsync>d__0")]
protected virtual ValueTask`1<object> EvaluateImplAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptForStatement/<LoopItemAsync>d__1")]
protected virtual ValueTask`1<object> LoopItemAsync(TemplateContext context, LoopState state);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ForOrTableRowKeyword();
    public void set_ForOrTableRowKeyword(ScriptKeyword value);
    public ScriptExpression get_Variable();
    public void set_Variable(ScriptExpression value);
    public ScriptKeyword get_InKeyword();
    public void set_InKeyword(ScriptKeyword value);
    public ScriptExpression get_Iterator();
    public void set_Iterator(ScriptExpression value);
    public sealed virtual ScriptList`1<ScriptNamedArgument> get_NamedArguments();
    public sealed virtual void set_NamedArguments(ScriptList`1<ScriptNamedArgument> value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public ScriptElseStatement get_Else();
    public void set_Else(ScriptElseStatement value);
    [CompilerGeneratedAttribute]
public bool get_SetContinue();
    [CompilerGeneratedAttribute]
public void set_SetContinue(bool value);
    internal ScriptNode get_IteratorOrLastParameter();
    protected virtual object LoopItem(TemplateContext context, LoopState state);
    protected virtual ScriptVariable GetLoopVariable(TemplateContext context);
    protected virtual object EvaluateImpl(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    protected virtual void ProcessArgument(TemplateContext context, ScriptNamedArgument argument);
    protected virtual ValueTask ProcessArgumentAsync(TemplateContext context, ScriptNamedArgument argument);
}
public class Scriban.Syntax.ScriptFrontMatter : ScriptStatement {
    private ScriptToken _startMarker;
    private ScriptToken _endMarker;
    private ScriptBlockStatement _statements;
    public TextPosition TextPositionAfterEndMarker;
    public int ChildrenCount { get; }
    public ScriptToken StartMarker { get; public set; }
    public ScriptBlockStatement Statements { get; public set; }
    public ScriptToken EndMarker { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptFrontMatter/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptToken get_StartMarker();
    public void set_StartMarker(ScriptToken value);
    public ScriptBlockStatement get_Statements();
    public void set_Statements(ScriptBlockStatement value);
    public ScriptToken get_EndMarker();
    public void set_EndMarker(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("function statement", "func <variable> ... end")]
public class Scriban.Syntax.ScriptFunction : ScriptStatement {
    private ScriptKeyword _funcToken;
    private ScriptNode _nameOrDoToken;
    private ScriptToken _openParen;
    private ScriptList`1<ScriptParameter> _parameters;
    private ScriptToken _closeParen;
    private ScriptToken _equalToken;
    private ScriptStatement _body;
    private bool _hasReturnType;
    private ScriptVarParamKind _varParamKind;
    private int _requiredParameterCount;
    public int ChildrenCount { get; }
    public ScriptKeyword FuncToken { get; public set; }
    public ScriptNode NameOrDoToken { get; public set; }
    public ScriptToken OpenParen { get; public set; }
    public ScriptList`1<ScriptParameter> Parameters { get; public set; }
    public ScriptToken CloseParen { get; public set; }
    public ScriptToken EqualToken { get; public set; }
    public ScriptStatement Body { get; public set; }
    public bool IsAnonymous { get; }
    public bool HasParameters { get; }
    public int RequiredParameterCount { get; }
    public int ParameterCount { get; }
    public ScriptVarParamKind VarParamKind { get; }
    public Type ReturnType { get; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptFunction/<InvokeAsync>d__0")]
public sealed virtual ValueTask`1<object> InvokeAsync(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_FuncToken();
    public void set_FuncToken(ScriptKeyword value);
    public ScriptNode get_NameOrDoToken();
    public void set_NameOrDoToken(ScriptNode value);
    public ScriptToken get_OpenParen();
    public void set_OpenParen(ScriptToken value);
    public ScriptList`1<ScriptParameter> get_Parameters();
    public void set_Parameters(ScriptList`1<ScriptParameter> value);
    public ScriptToken get_CloseParen();
    public void set_CloseParen(ScriptToken value);
    public ScriptToken get_EqualToken();
    public void set_EqualToken(ScriptToken value);
    public ScriptStatement get_Body();
    public void set_Body(ScriptStatement value);
    public void UpdateReturnType();
    public bool get_IsAnonymous();
    public bool get_HasParameters();
    public virtual object Evaluate(TemplateContext context);
    public virtual bool CanHaveLeadingTrivia();
    public virtual void PrintTo(ScriptPrinter printer);
    public sealed virtual object Invoke(TemplateContext context, ScriptNode callerContext, ScriptArray arguments, ScriptBlockStatement blockStatement);
    public sealed virtual int get_RequiredParameterCount();
    public sealed virtual int get_ParameterCount();
    public sealed virtual ScriptVarParamKind get_VarParamKind();
    public sealed virtual Type get_ReturnType();
    public sealed virtual ScriptParameterInfo GetParameterInfo(int index);
}
[ScriptSyntaxAttribute("function call expression", "<target_expression> <arguemnt[0]> ... <arguement[n]>")]
public class Scriban.Syntax.ScriptFunctionCall : ScriptExpression {
    private ScriptExpression _target;
    private ScriptToken _openParent;
    private ScriptList`1<ScriptExpression> _arguments;
    private ScriptToken _closeParen;
    public static int MaximumParameterCount;
    [CompilerGeneratedAttribute]
private bool <ExplicitCall>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptExpression Target { get; public set; }
    public ScriptToken OpenParent { get; public set; }
    public ScriptList`1<ScriptExpression> Arguments { get; public set; }
    public ScriptToken CloseParen { get; public set; }
    public bool ExplicitCall { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptFunctionCall/<CallAsync>d__0")]
public static ValueTask`1<object> CallAsync(TemplateContext context, ScriptNode callerContext, object functionObject, bool processPipeArguments, IReadOnlyList`1<ScriptExpression> arguments);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptFunctionCall/<CallAsync>d__1")]
public static ValueTask`1<object> CallAsync(TemplateContext context, ScriptNode callerContext, IScriptCustomFunction function, ScriptArray arguments);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptFunctionCall/<EvaluateAsync>d__2")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptFunctionCall/<ProcessArgumentsAsync>d__3")]
private static ValueTask`1<ulong> ProcessArgumentsAsync(TemplateContext context, ScriptNode callerContext, IReadOnlyList`1<ScriptExpression> arguments, IScriptCustomFunction function, ScriptFunction scriptFunction, ScriptArray argumentValues);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Target();
    public void set_Target(ScriptExpression value);
    public ScriptToken get_OpenParent();
    public void set_OpenParent(ScriptToken value);
    public ScriptList`1<ScriptExpression> get_Arguments();
    public void set_Arguments(ScriptList`1<ScriptExpression> value);
    public ScriptToken get_CloseParen();
    public void set_CloseParen(ScriptToken value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitCall();
    [CompilerGeneratedAttribute]
public void set_ExplicitCall(bool value);
    public bool TryGetFunctionDeclaration(ScriptFunction& function);
    public void AddArgument(ScriptExpression argument);
    [ObsoleteAttribute("This method has no effect and will be deleted in a future version")]
public ScriptExpression GetScientificExpression(TemplateContext context);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual bool CanHaveLeadingTrivia();
    public static bool IsFunction(object target);
    public static object Call(TemplateContext context, ScriptNode callerContext, object functionObject, bool processPipeArguments, IReadOnlyList`1<ScriptExpression> arguments);
    public static object Call(TemplateContext context, ScriptNode callerContext, IScriptCustomFunction function, ScriptArray arguments);
    private static ulong ProcessArguments(TemplateContext context, ScriptNode callerContext, IReadOnlyList`1<ScriptExpression> arguments, IScriptCustomFunction function, ScriptFunction scriptFunction, ScriptArray argumentValues);
    private static void SetArgumentValue(int index, object value, IScriptCustomFunction function, UInt64& argMask, ScriptArray argumentValues, int parameterCount);
    private static void FillRemainingOptionalArguments(UInt64& argMask, int startIndex, int endIndex, IScriptCustomFunction function, ScriptArray argumentValues);
    private static int GetParameterIndexByName(IScriptFunctionInfo functionInfo, string name);
}
public class Scriban.Syntax.ScriptIdentifier : ScriptVerbatim {
    public int ChildrenCount { get; }
    [NullableContextAttribute("1")]
public ScriptIdentifier(string value);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
}
[ScriptSyntaxAttribute("if statement", "if <expression> ... end|else|else if")]
public class Scriban.Syntax.ScriptIfStatement : ScriptConditionStatement {
    private ScriptExpression _condition;
    private ScriptBlockStatement _then;
    private ScriptConditionStatement _else;
    private ScriptKeyword _ifKeyword;
    private ScriptKeyword _elseKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword ElseKeyword { get; public set; }
    public ScriptKeyword IfKeyword { get; public set; }
    public ScriptExpression Condition { get; public set; }
    public ScriptBlockStatement Then { get; public set; }
    public ScriptConditionStatement Else { get; public set; }
    public bool IsElseIf { get; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIfStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ElseKeyword();
    public void set_ElseKeyword(ScriptKeyword value);
    public ScriptKeyword get_IfKeyword();
    public void set_IfKeyword(ScriptKeyword value);
    public ScriptExpression get_Condition();
    public void set_Condition(ScriptExpression value);
    public ScriptBlockStatement get_Then();
    public void set_Then(ScriptBlockStatement value);
    public ScriptConditionStatement get_Else();
    public void set_Else(ScriptConditionStatement value);
    public bool get_IsElseIf();
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("import statement", "import <expression>")]
public class Scriban.Syntax.ScriptImportStatement : ScriptStatement {
    private ScriptKeyword _importKeyword;
    private ScriptExpression _expression;
    public int ChildrenCount { get; }
    public ScriptKeyword ImportKeyword { get; public set; }
    public ScriptExpression Expression { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptImportStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ImportKeyword();
    public void set_ImportKeyword(ScriptKeyword value);
    public ScriptExpression get_Expression();
    public void set_Expression(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("increment/decrement expression", "<operator> <expression> or <expression> <operator>")]
public class Scriban.Syntax.ScriptIncrementDecrementExpression : ScriptUnaryExpression {
    [CompilerGeneratedAttribute]
private bool <Post>k__BackingField;
    public int ChildrenCount { get; }
    public bool Post { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIncrementDecrementExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public bool get_Post();
    [CompilerGeneratedAttribute]
public void set_Post(bool value);
    [NullableContextAttribute("1")]
public virtual object Evaluate(TemplateContext context);
    [NullableContextAttribute("1")]
public virtual void PrintTo(ScriptPrinter printer);
    [NullableContextAttribute("1")]
private void PrintOperator(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("indexer expression", "<expression>[<index_expression>]")]
public class Scriban.Syntax.ScriptIndexerExpression : ScriptExpression {
    private ScriptExpression _target;
    private ScriptToken _openBracket;
    private ScriptExpression _index;
    private ScriptToken _closeBracket;
    public int ChildrenCount { get; }
    public ScriptExpression Target { get; public set; }
    public ScriptToken OpenBracket { get; public set; }
    public ScriptExpression Index { get; public set; }
    public ScriptToken CloseBracket { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIndexerExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIndexerExpression/<GetOrSetValueAsync>d__1")]
private ValueTask`1<object> GetOrSetValueAsync(TemplateContext context, object valueToSet, bool setter);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIndexerExpression/<GetValueAsync>d__2")]
public sealed virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIndexerExpression/<SetValueAsync>d__3")]
public sealed virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Target();
    public void set_Target(ScriptExpression value);
    public ScriptToken get_OpenBracket();
    public void set_OpenBracket(ScriptToken value);
    public ScriptExpression get_Index();
    public void set_Index(ScriptExpression value);
    public ScriptToken get_CloseBracket();
    public void set_CloseBracket(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual bool CanHaveLeadingTrivia();
    public virtual void PrintTo(ScriptPrinter printer);
    public sealed virtual object GetValue(TemplateContext context);
    public sealed virtual void SetValue(TemplateContext context, object valueToSet);
    public sealed virtual string GetFirstPath();
    private object GetOrSetValue(TemplateContext context, object valueToSet, bool setter);
}
[ScriptSyntaxAttribute("interpolated expression", "{<expression>}")]
public class Scriban.Syntax.ScriptInterpolatedExpression : ScriptExpression {
    private ScriptExpression _expression;
    private ScriptToken _openBrace;
    private ScriptToken _closeBrace;
    public int ChildrenCount { get; }
    public ScriptToken OpenBrace { get; public set; }
    public ScriptExpression Expression { get; public set; }
    public ScriptToken CloseBrace { get; public set; }
    public ScriptInterpolatedExpression(ScriptExpression expression);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptInterpolatedExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptInterpolatedExpression/<GetValueAsync>d__1")]
public sealed virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptInterpolatedExpression/<SetValueAsync>d__2")]
public sealed virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public static ScriptInterpolatedExpression Wrap(ScriptExpression expression, bool transferTrivia);
    public ScriptToken get_OpenBrace();
    public void set_OpenBrace(ScriptToken value);
    public ScriptExpression get_Expression();
    public void set_Expression(ScriptExpression value);
    public ScriptToken get_CloseBrace();
    public void set_CloseBrace(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public sealed virtual object GetValue(TemplateContext context);
    public sealed virtual void SetValue(TemplateContext context, object valueToSet);
    public sealed virtual string GetFirstPath();
}
[ScriptSyntaxAttribute("empty expression", "<expression>.empty?")]
public class Scriban.Syntax.ScriptIsEmptyExpression : ScriptMemberExpression {
    private ScriptToken _questionToken;
    public int ChildrenCount { get; }
    public ScriptToken QuestionToken { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIsEmptyExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIsEmptyExpression/<GetTargetObjectAsync>d__1")]
private ValueTask`1<object> GetTargetObjectAsync(TemplateContext context, bool isSet);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptIsEmptyExpression/<GetValueAsync>d__2")]
public virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptToken get_QuestionToken();
    public void set_QuestionToken(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual bool CanHaveLeadingTrivia();
    public virtual object GetValue(TemplateContext context);
    public virtual void SetValue(TemplateContext context, object valueToSet);
    public virtual string GetFirstPath();
    private object GetTargetObject(TemplateContext context, bool isSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Syntax.ScriptKeyword : ScriptVerbatim {
    public int ChildrenCount { get; }
    public ScriptKeyword(string value);
    public virtual int get_ChildrenCount();
    [NullableContextAttribute("0")]
protected virtual ScriptNode GetChildrenImpl(int index);
    [NullableContextAttribute("0")]
public virtual void Accept(ScriptVisitor visitor);
    [NullableContextAttribute("0")]
public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public static ScriptKeyword This();
    public static ScriptKeyword Func();
    public static ScriptKeyword Do();
    public static ScriptKeyword Break();
    public static ScriptKeyword Capture();
    public static ScriptKeyword Case();
    public static ScriptKeyword Continue();
    public static ScriptKeyword Else();
    public static ScriptKeyword End();
    public static ScriptKeyword If();
    public static ScriptKeyword In();
    public static ScriptKeyword For();
    public static ScriptKeyword Import();
    public static ScriptKeyword ReadOnly();
    public static ScriptKeyword Ret();
    public static ScriptKeyword TableRow();
    public static ScriptKeyword When();
    public static ScriptKeyword While();
    public static ScriptKeyword With();
    public static ScriptKeyword Wrap();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Scriban.Syntax.ScriptList/ScriptListDebug")]
public abstract class Scriban.Syntax.ScriptList : ScriptNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal InlineList`1<ScriptNode> _children;
    public int Count { get; }
    public int ChildrenCount { get; }
    public ScriptNode Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual int get_ChildrenCount();
    public ScriptNode get_Item(int index);
    protected virtual ScriptNode GetChildrenImpl(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Scriban.Syntax.ScriptList`1/DebugListView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class Scriban.Syntax.ScriptList`1 : ScriptList {
    public bool IsReadOnly { get; }
    public TScriptNode Item { get; public set; }
    public sealed virtual void Add(TScriptNode node);
    public void AddRange(IEnumerable`1<TScriptNode> nodes);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TScriptNode item);
    public sealed virtual void CopyTo(TScriptNode[] array, int arrayIndex);
    public sealed virtual bool Remove(TScriptNode item);
    public sealed virtual bool get_IsReadOnly();
    public virtual object Evaluate(TemplateContext context);
    public TScriptNode GetChildren(int index);
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [NullableContextAttribute("0")]
public Enumerator<TScriptNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TScriptNode> System.Collections.Generic.IEnumerable<TScriptNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(TScriptNode item);
    public sealed virtual void Insert(int index, TScriptNode item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual TScriptNode get_Item(int index);
    public sealed virtual void set_Item(int index, TScriptNode value);
    private void AssertNoParent(ScriptNode node);
}
[ScriptSyntaxAttribute("literal", "<value>")]
public class Scriban.Syntax.ScriptLiteral : ScriptExpression {
    [CompilerGeneratedAttribute]
private ScriptTrivias <Trivias>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptLiteralStringQuoteType <StringQuoteType>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenType <StringTokenType>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptTrivias Trivias { get; public set; }
    public object Value { get; public set; }
    public ScriptLiteralStringQuoteType StringQuoteType { get; public set; }
    public TokenType StringTokenType { get; public set; }
    public ScriptLiteral(object value);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public sealed virtual ScriptTrivias get_Trivias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Trivias(ScriptTrivias value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public ScriptLiteralStringQuoteType get_StringQuoteType();
    [CompilerGeneratedAttribute]
public void set_StringQuoteType(ScriptLiteralStringQuoteType value);
    [CompilerGeneratedAttribute]
public TokenType get_StringTokenType();
    [CompilerGeneratedAttribute]
public void set_StringTokenType(TokenType value);
    public virtual object Evaluate(TemplateContext context);
    public bool IsPositiveInteger();
    public virtual void PrintTo(ScriptPrinter printer);
    private static string ToLiteral(ScriptLiteralStringQuoteType quoteType, TokenType stringTokenType, string input);
    private static string AppendDecimalPoint(string text, bool hasNaN);
}
public enum Scriban.Syntax.ScriptLiteralStringQuoteType : Enum {
    public int value__;
    public static ScriptLiteralStringQuoteType DoubleQuote;
    public static ScriptLiteralStringQuoteType SimpleQuote;
    public static ScriptLiteralStringQuoteType Verbatim;
}
public abstract class Scriban.Syntax.ScriptLoopStatementBase : ScriptStatement {
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptLoopStatementBase/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    protected virtual void BeforeLoop(TemplateContext context);
    protected abstract virtual object LoopItem(TemplateContext context, LoopState state);
    protected virtual LoopState CreateLoopState();
    protected bool ContinueLoop(TemplateContext context);
    protected virtual void AfterLoop(TemplateContext context);
    public virtual object Evaluate(TemplateContext context);
    protected abstract virtual object EvaluateImpl(TemplateContext context);
    protected abstract virtual ValueTask`1<object> EvaluateImplAsync(TemplateContext context);
    protected abstract virtual ValueTask`1<object> LoopItemAsync(TemplateContext context, LoopState state);
    protected virtual ValueTask BeforeLoopAsync(TemplateContext context);
    protected virtual ValueTask AfterLoopAsync(TemplateContext context);
}
[ScriptSyntaxAttribute("member expression", "<expression>.<variable_name>")]
public class Scriban.Syntax.ScriptMemberExpression : ScriptExpression {
    private ScriptExpression _target;
    private ScriptToken _dotToken;
    private ScriptVariable _member;
    public int ChildrenCount { get; }
    public ScriptExpression Target { get; public set; }
    public ScriptToken DotToken { get; public set; }
    public ScriptVariable Member { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptMemberExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptMemberExpression/<GetTargetObjectAsync>d__1")]
private ValueTask`1<object> GetTargetObjectAsync(TemplateContext context, bool isSet);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptMemberExpression/<GetValueAsync>d__2")]
public virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptMemberExpression/<SetValueAsync>d__3")]
public virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Target();
    public void set_Target(ScriptExpression value);
    public ScriptToken get_DotToken();
    public void set_DotToken(ScriptToken value);
    public ScriptVariable get_Member();
    public void set_Member(ScriptVariable value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public virtual bool CanHaveLeadingTrivia();
    public virtual object GetValue(TemplateContext context);
    public virtual void SetValue(TemplateContext context, object valueToSet);
    public virtual string GetFirstPath();
    private object GetTargetObject(TemplateContext context, bool isSet);
}
public class Scriban.Syntax.ScriptNamedArgument : ScriptExpression {
    private ScriptVariable _name;
    private ScriptToken _colonToken;
    private ScriptExpression _value;
    public int ChildrenCount { get; }
    public ScriptVariable Name { get; public set; }
    public ScriptToken ColonToken { get; public set; }
    public ScriptExpression Value { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptNamedArgument/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptVariable get_Name();
    public void set_Name(ScriptVariable value);
    public ScriptToken get_ColonToken();
    public void set_ColonToken(ScriptToken value);
    public ScriptExpression get_Value();
    public void set_Value(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("nested expression", "(<expression>)")]
public class Scriban.Syntax.ScriptNestedExpression : ScriptExpression {
    private ScriptExpression _expression;
    private ScriptToken _openParen;
    private ScriptToken _closeParen;
    public int ChildrenCount { get; }
    public ScriptToken OpenParen { get; public set; }
    public ScriptExpression Expression { get; public set; }
    public ScriptToken CloseParen { get; public set; }
    public ScriptNestedExpression(ScriptExpression expression);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptNestedExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptNestedExpression/<GetValueAsync>d__1")]
public sealed virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptNestedExpression/<SetValueAsync>d__2")]
public sealed virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public static ScriptNestedExpression Wrap(ScriptExpression expression, bool transferTrivia);
    public ScriptToken get_OpenParen();
    public void set_OpenParen(ScriptToken value);
    public ScriptExpression get_Expression();
    public void set_Expression(ScriptExpression value);
    public ScriptToken get_CloseParen();
    public void set_CloseParen(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public sealed virtual object GetValue(TemplateContext context);
    public sealed virtual void SetValue(TemplateContext context, object valueToSet);
    public sealed virtual string GetFirstPath();
}
public abstract class Scriban.Syntax.ScriptNode : object {
    public SourceSpan Span;
    [CompilerGeneratedAttribute]
private ScriptNode <Parent>k__BackingField;
    public ScriptNode Parent { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
public int ChildrenCount { get; }
    [DebuggerBrowsableAttribute("0")]
public IEnumerable`1<ScriptNode> Children { get; }
    [CompilerGeneratedAttribute]
public ScriptNode get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ScriptNode value);
    public abstract virtual object Evaluate(TemplateContext context);
    public virtual int get_ChildrenCount();
    public ScriptNode Clone();
    public ScriptNode Clone(bool withTrivias);
    public ScriptNode GetChildren(int index);
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual bool CanHaveLeadingTrivia();
    public abstract virtual void PrintTo(ScriptPrinter printer);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [IteratorStateMachineAttribute("Scriban.Syntax.ScriptNode/<get_Children>d__18")]
public IEnumerable`1<ScriptNode> get_Children();
    protected void ParentToThis(TSyntaxNode& set, TSyntaxNode node);
    public sealed virtual string ToString();
}
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptNodeExtensions : object {
    [ExtensionAttribute]
public static ScriptNode FindFirstTerminal(ScriptNode node);
    [ExtensionAttribute]
public static ScriptNode FindLastTerminal(ScriptNode node);
    [ExtensionAttribute]
public static T RemoveLeadingSpace(T node);
    [ExtensionAttribute]
public static T RemoveTrailingSpace(T node);
    [ExtensionAttribute]
public static void MoveLeadingTriviasTo(ScriptNode node, T destinationNode);
    [ExtensionAttribute]
public static void MoveTrailingTriviasTo(ScriptNode node, T destinationNode, bool before);
    [ExtensionAttribute]
public static void AddLeadingSpace(IScriptTerminal node);
    [ExtensionAttribute]
public static void AddCommaAfter(IScriptTerminal node);
    [ExtensionAttribute]
public static void AddSemiColonAfter(IScriptTerminal node);
    [ExtensionAttribute]
public static void AddSpaceAfter(IScriptTerminal node);
    [ExtensionAttribute]
public static void AddTrivia(IScriptTerminal node, ScriptTrivia trivia, bool before);
    [ExtensionAttribute]
public static void InsertTrivia(IScriptTerminal node, ScriptTrivia trivia, bool before);
    [ExtensionAttribute]
public static void AddTrivias(IScriptTerminal node, T trivias, bool before);
    [ExtensionAttribute]
public static bool HasLeadingSpaceTrivias(IScriptTerminal node);
    [ExtensionAttribute]
public static bool HasTrailingSpaceTrivias(IScriptTerminal node);
    [ExtensionAttribute]
public static bool HasTrivia(IScriptTerminal node, ScriptTriviaType triviaType, bool before);
    [ExtensionAttribute]
public static bool HasTriviaEndOfStatement(IScriptTerminal node, bool before);
}
public class Scriban.Syntax.ScriptNopStatement : ScriptStatement {
    public int ChildrenCount { get; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("object initializer expression", "{ member1: <expression>, member2: ... }")]
public class Scriban.Syntax.ScriptObjectInitializerExpression : ScriptExpression {
    private ScriptToken _openBrace;
    private ScriptList`1<ScriptObjectMember> _members;
    private ScriptToken _closeBrace;
    public int ChildrenCount { get; }
    public ScriptToken OpenBrace { get; public set; }
    public ScriptList`1<ScriptObjectMember> Members { get; public set; }
    public ScriptToken CloseBrace { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptObjectInitializerExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptToken get_OpenBrace();
    public void set_OpenBrace(ScriptToken value);
    public ScriptList`1<ScriptObjectMember> get_Members();
    public void set_Members(ScriptList`1<ScriptObjectMember> value);
    public ScriptToken get_CloseBrace();
    public void set_CloseBrace(ScriptToken value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Syntax.ScriptObjectMember : ScriptNode {
    private ScriptExpression _name;
    private ScriptExpression _value;
    private ScriptToken _colonToken;
    public int ChildrenCount { get; }
    public ScriptExpression Name { get; public set; }
    public ScriptToken ColonToken { get; public set; }
    public ScriptExpression Value { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptObjectMember/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_Name();
    public void set_Name(ScriptExpression value);
    public ScriptToken get_ColonToken();
    public void set_ColonToken(ScriptToken value);
    public ScriptExpression get_Value();
    public void set_Value(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Syntax.ScriptPage : ScriptNode {
    private ScriptFrontMatter _frontMatter;
    private ScriptBlockStatement _body;
    public int ChildrenCount { get; }
    public ScriptFrontMatter FrontMatter { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptPage/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptFrontMatter get_FrontMatter();
    public void set_FrontMatter(ScriptFrontMatter value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Syntax.ScriptParameter : ScriptNode {
    private ScriptVariable _name;
    private ScriptToken _equalOrTripleDotToken;
    private ScriptLiteral _defaultValue;
    public int ChildrenCount { get; }
    public ScriptVariable Name { get; public set; }
    public ScriptToken EqualOrTripleDotToken { get; public set; }
    public ScriptLiteral DefaultValue { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptVariable get_Name();
    public void set_Name(ScriptVariable value);
    public ScriptToken get_EqualOrTripleDotToken();
    public void set_EqualOrTripleDotToken(ScriptToken value);
    public ScriptLiteral get_DefaultValue();
    public void set_DefaultValue(ScriptLiteral value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptParameterContainerExtensions : object {
    [ExtensionAttribute]
public static void AddParameter(IScriptNamedArgumentContainer container, ScriptNamedArgument argument);
    [ExtensionAttribute]
public static void Write(ScriptPrinter printer, List`1<ScriptNamedArgument> parameters);
}
public class Scriban.Syntax.ScriptParserRuntimeException : ScriptRuntimeException {
    [CompilerGeneratedAttribute]
private LogMessageBag <ParserMessages>k__BackingField;
    public LogMessageBag ParserMessages { get; }
    public string Message { get; }
    public ScriptParserRuntimeException(SourceSpan span, string message, LogMessageBag parserMessages);
    public ScriptParserRuntimeException(SourceSpan span, string message, LogMessageBag parserMessages, Exception innerException);
    [CompilerGeneratedAttribute]
public LogMessageBag get_ParserMessages();
    public virtual string get_Message();
}
[ScriptSyntaxAttribute("pipe expression", "<expression> | <expression>")]
public class Scriban.Syntax.ScriptPipeCall : ScriptExpression {
    private ScriptExpression _from;
    private ScriptToken _pipeToken;
    private ScriptExpression _to;
    public int ChildrenCount { get; }
    public ScriptExpression From { get; public set; }
    public ScriptToken PipeToken { get; public set; }
    public ScriptExpression To { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptPipeCall/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptExpression get_From();
    public void set_From(ScriptExpression value);
    public ScriptToken get_PipeToken();
    public void set_PipeToken(ScriptToken value);
    public ScriptExpression get_To();
    public void set_To(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual bool CanHaveLeadingTrivia();
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("raw statement", "<raw_text>")]
public class Scriban.Syntax.ScriptRawStatement : ScriptStatement {
    [CompilerGeneratedAttribute]
private ScriptStringSlice <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEscape>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptStringSlice Text { get; public set; }
    public bool IsEscape { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptRawStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ScriptStringSlice get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(ScriptStringSlice value);
    [CompilerGeneratedAttribute]
public bool get_IsEscape();
    [CompilerGeneratedAttribute]
public void set_IsEscape(bool value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("readonly statement", "readonly <variable>")]
public class Scriban.Syntax.ScriptReadOnlyStatement : ScriptStatement {
    private ScriptVariable _variable;
    private ScriptKeyword _readOnlyKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword ReadOnlyKeyword { get; public set; }
    public ScriptVariable Variable { get; public set; }
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ReadOnlyKeyword();
    public void set_ReadOnlyKeyword(ScriptKeyword value);
    public ScriptVariable get_Variable();
    public void set_Variable(ScriptVariable value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("return statement", "return <expression>?")]
public class Scriban.Syntax.ScriptReturnStatement : ScriptStatement {
    private ScriptExpression _expression;
    private ScriptKeyword _retKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword RetKeyword { get; public set; }
    public ScriptExpression Expression { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptReturnStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_RetKeyword();
    public void set_RetKeyword(ScriptKeyword value);
    public ScriptExpression get_Expression();
    public void set_Expression(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public abstract class Scriban.Syntax.ScriptRewriter : ScriptVisitor`1<ScriptNode> {
    [CompilerGeneratedAttribute]
private bool <CopyTrivias>k__BackingField;
    public bool CopyTrivias { get; public set; }
    public virtual ScriptNode Visit(ScriptAnonymousFunction node);
    public virtual ScriptNode Visit(ScriptArgumentBinary node);
    public virtual ScriptNode Visit(ScriptArrayInitializerExpression node);
    public virtual ScriptNode Visit(ScriptAssignExpression node);
    public virtual ScriptNode Visit(ScriptBinaryExpression node);
    public virtual ScriptNode Visit(ScriptBlockStatement node);
    public virtual ScriptNode Visit(ScriptBreakStatement node);
    public virtual ScriptNode Visit(ScriptCaptureStatement node);
    public virtual ScriptNode Visit(ScriptCaseStatement node);
    public virtual ScriptNode Visit(ScriptConditionalExpression node);
    public virtual ScriptNode Visit(ScriptContinueStatement node);
    public virtual ScriptNode Visit(ScriptElseStatement node);
    public virtual ScriptNode Visit(ScriptEndStatement node);
    public virtual ScriptNode Visit(ScriptEscapeStatement node);
    public virtual ScriptNode Visit(ScriptExpressionStatement node);
    public virtual ScriptNode Visit(ScriptForStatement node);
    public virtual ScriptNode Visit(ScriptFrontMatter node);
    public virtual ScriptNode Visit(ScriptFunction node);
    public virtual ScriptNode Visit(ScriptFunctionCall node);
    public virtual ScriptNode Visit(ScriptIdentifier node);
    public virtual ScriptNode Visit(ScriptIfStatement node);
    public virtual ScriptNode Visit(ScriptImportStatement node);
    public virtual ScriptNode Visit(ScriptIncrementDecrementExpression node);
    public virtual ScriptNode Visit(ScriptIndexerExpression node);
    public virtual ScriptNode Visit(ScriptInterpolatedExpression node);
    public virtual ScriptNode Visit(ScriptIsEmptyExpression node);
    public virtual ScriptNode Visit(ScriptKeyword node);
    public virtual ScriptNode Visit(ScriptLiteral node);
    public virtual ScriptNode Visit(ScriptMemberExpression node);
    public virtual ScriptNode Visit(ScriptNamedArgument node);
    public virtual ScriptNode Visit(ScriptNestedExpression node);
    public virtual ScriptNode Visit(ScriptNopStatement node);
    public virtual ScriptNode Visit(ScriptObjectInitializerExpression node);
    public virtual ScriptNode Visit(ScriptObjectMember node);
    public virtual ScriptNode Visit(ScriptPage node);
    public virtual ScriptNode Visit(ScriptParameter node);
    public virtual ScriptNode Visit(ScriptPipeCall node);
    public virtual ScriptNode Visit(ScriptRawStatement node);
    public virtual ScriptNode Visit(ScriptReadOnlyStatement node);
    public virtual ScriptNode Visit(ScriptReturnStatement node);
    public virtual ScriptNode Visit(ScriptTableRowStatement node);
    public virtual ScriptNode Visit(ScriptThisExpression node);
    public virtual ScriptNode Visit(ScriptToken node);
    public virtual ScriptNode Visit(ScriptUnaryExpression node);
    public virtual ScriptNode Visit(ScriptWhenStatement node);
    public virtual ScriptNode Visit(ScriptWhileStatement node);
    public virtual ScriptNode Visit(ScriptWithStatement node);
    public virtual ScriptNode Visit(ScriptWrapStatement node);
    [CompilerGeneratedAttribute]
public bool get_CopyTrivias();
    [CompilerGeneratedAttribute]
public void set_CopyTrivias(bool value);
    public virtual ScriptNode Visit(ScriptNode node);
    public virtual ScriptNode Visit(ScriptVariableGlobal node);
    public virtual ScriptNode Visit(ScriptVariableLocal node);
    protected ScriptList`1<TNode> VisitAll(ScriptList`1<TNode> nodes);
}
public class Scriban.Syntax.ScriptRuntimeException : Exception {
    [CompilerGeneratedAttribute]
private SourceSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <EnableDisplayInnerException>k__BackingField;
    public SourceSpan Span { get; }
    public string Message { get; }
    public static bool EnableDisplayInnerException { get; public set; }
    public string OriginalMessage { get; }
    public ScriptRuntimeException(SourceSpan span, string message);
    public ScriptRuntimeException(SourceSpan span, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public SourceSpan get_Span();
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public static bool get_EnableDisplayInnerException();
    [CompilerGeneratedAttribute]
public static void set_EnableDisplayInnerException(bool value);
    public string get_OriginalMessage();
    public virtual string ToString();
}
public abstract class Scriban.Syntax.ScriptStatement : ScriptNode {
    [CompilerGeneratedAttribute]
private bool <CanSkipEvaluation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanOutput>k__BackingField;
    public bool CanSkipEvaluation { get; protected set; }
    public bool CanOutput { get; protected set; }
    [CompilerGeneratedAttribute]
public bool get_CanSkipEvaluation();
    [CompilerGeneratedAttribute]
protected void set_CanSkipEvaluation(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanOutput();
    [CompilerGeneratedAttribute]
protected void set_CanOutput(bool value);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{ToString()}")]
public class Scriban.Syntax.ScriptStringSlice : ValueType {
    public static ScriptStringSlice Empty;
    public string FullText;
    public int Index;
    public int Length;
    public char Item { get; }
    public ScriptStringSlice(string fullText);
    public ScriptStringSlice(string fullText, int index, int length);
    private static ScriptStringSlice();
    public char get_Item(int index);
    public string Substring(int index);
    public virtual string ToString();
    public sealed virtual bool Equals(ScriptStringSlice other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ScriptStringSlice left, ScriptStringSlice right);
    public static bool op_Inequality(ScriptStringSlice left, ScriptStringSlice right);
    public static bool op_Equality(ScriptStringSlice left, string right);
    public static bool op_Inequality(ScriptStringSlice left, string right);
    public static bool op_Equality(string left, ScriptStringSlice right);
    public static bool op_Inequality(string left, ScriptStringSlice right);
    public sealed virtual int CompareTo(ScriptStringSlice other);
    public sealed virtual int CompareTo(string other);
    public static ScriptStringSlice op_Explicit(string text);
    public static string op_Explicit(ScriptStringSlice slice);
    public ScriptStringSlice TrimStart();
    public ScriptStringSlice TrimEnd();
    public ScriptStringSlice TrimEndKeepNewLine();
}
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptStringSliceExtensions : object {
    [ExtensionAttribute]
public static ScriptStringSlice Slice(string text, int index);
    [ExtensionAttribute]
public static ScriptStringSlice Slice(string text, int index, int length);
}
[AttributeUsageAttribute("28")]
public class Scriban.Syntax.ScriptSyntaxAttribute : ScriptTypeNameAttribute {
    [CompilerGeneratedAttribute]
private string <Example>k__BackingField;
    public string Example { get; }
    public ScriptSyntaxAttribute(string typeName, string example);
    [CompilerGeneratedAttribute]
public string get_Example();
    public static ScriptSyntaxAttribute Get(object obj);
    public static ScriptSyntaxAttribute Get(Type type);
}
public class Scriban.Syntax.ScriptTableRowStatement : ScriptForStatement {
    private int _columnsCount;
    public int ChildrenCount { get; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptTableRowStatement/<AfterLoopAsync>d__0")]
protected virtual ValueTask AfterLoopAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptTableRowStatement/<BeforeLoopAsync>d__1")]
protected virtual ValueTask BeforeLoopAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptTableRowStatement/<LoopItemAsync>d__2")]
protected virtual ValueTask`1<object> LoopItemAsync(TemplateContext context, LoopState state);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptTableRowStatement/<ProcessArgumentAsync>d__3")]
protected virtual ValueTask ProcessArgumentAsync(TemplateContext context, ScriptNamedArgument argument);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [NullableContextAttribute("1")]
protected virtual ScriptVariable GetLoopVariable(TemplateContext context);
    [NullableContextAttribute("1")]
protected virtual void ProcessArgument(TemplateContext context, ScriptNamedArgument argument);
    [NullableContextAttribute("1")]
protected virtual void BeforeLoop(TemplateContext context);
    [NullableContextAttribute("1")]
protected virtual void AfterLoop(TemplateContext context);
    [NullableContextAttribute("1")]
protected virtual object LoopItem(TemplateContext context, LoopState state);
    [NullableContextAttribute("1")]
protected virtual LoopState CreateLoopState();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<object> <>n__0(TemplateContext context, LoopState state);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__1(TemplateContext context, ScriptNamedArgument argument);
}
[ScriptSyntaxAttribute("this expression", "this")]
public class Scriban.Syntax.ScriptThisExpression : ScriptExpression {
    private ScriptKeyword _thisKeyword;
    public int ChildrenCount { get; }
    public ScriptKeyword ThisKeyword { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptThisExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_ThisKeyword();
    public void set_ThisKeyword(ScriptKeyword value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public sealed virtual object GetValue(TemplateContext context);
    public sealed virtual void SetValue(TemplateContext context, object valueToSet);
    public sealed virtual string GetFirstPath();
    public sealed virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    public sealed virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Syntax.ScriptToken : ScriptVerbatim {
    [CompilerGeneratedAttribute]
private TokenType <TokenType>k__BackingField;
    public int ChildrenCount { get; }
    public TokenType TokenType { get; public set; }
    public ScriptToken(TokenType type);
    public virtual int get_ChildrenCount();
    [NullableContextAttribute("0")]
protected virtual ScriptNode GetChildrenImpl(int index);
    [NullableContextAttribute("0")]
public virtual void Accept(ScriptVisitor visitor);
    [NullableContextAttribute("0")]
public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public static ScriptToken SemiColon();
    public static ScriptToken Arroba();
    public static ScriptToken Caret();
    public static ScriptToken DoubleCaret();
    public static ScriptToken Colon();
    public static ScriptToken Equal();
    public static ScriptToken Pipe();
    public static ScriptToken PipeGreater();
    public static ScriptToken Exclamation();
    public static ScriptToken DoubleAmp();
    public static ScriptToken DoublePipe();
    public static ScriptToken Amp();
    public static ScriptToken Question();
    public static ScriptToken DoubleQuestion();
    public static ScriptToken QuestionExclamation();
    public static ScriptToken CompareEqual();
    public static ScriptToken CompareNotEqual();
    public static ScriptToken CompareLess();
    public static ScriptToken CompareGreater();
    public static ScriptToken CompareLessOrEqual();
    public static ScriptToken CompareGreaterOrEqual();
    public static ScriptToken Divide();
    public static ScriptToken DivideEqual();
    public static ScriptToken DoubleDivide();
    public static ScriptToken DoubleDivideEqual();
    public static ScriptToken Star();
    public static ScriptToken StarEqual();
    public static ScriptToken Plus();
    public static ScriptToken PlusEqual();
    public static ScriptToken Minus();
    public static ScriptToken MinusEqual();
    public static ScriptToken Modulus();
    public static ScriptToken ModulusEqual();
    public static ScriptToken DoubleLess();
    public static ScriptToken DoubleGreater();
    public static ScriptToken Comma();
    public static ScriptToken Dot();
    public static ScriptToken DoubleDot();
    public static ScriptToken TripleDot();
    public static ScriptToken DoubleDotLess();
    public static ScriptToken OpenParen();
    public static ScriptToken CloseParen();
    public static ScriptToken OpenBrace();
    public static ScriptToken CloseBrace();
    public static ScriptToken OpenBracket();
    public static ScriptToken CloseBracket();
    public static ScriptToken OpenInterpBrace();
    public static ScriptToken CloseInterpBrace();
    [CompilerGeneratedAttribute]
public TokenType get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(TokenType value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Scriban.Syntax.ScriptTrivia : ValueType {
    public static ScriptTrivia Space;
    public static ScriptTrivia Comma;
    public static ScriptTrivia SemiColon;
    public SourceSpan Span;
    public ScriptTriviaType Type;
    public ScriptStringSlice Text;
    public ScriptTrivia(SourceSpan span, ScriptTriviaType type, ScriptStringSlice text);
    private static ScriptTrivia();
    public ScriptTrivia WithText(ScriptStringSlice text);
    public void Write(ScriptPrinter printer);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scriban.Syntax.ScriptTrivias : object {
    [CompilerGeneratedAttribute]
private List`1<ScriptTrivia> <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ScriptTrivia> <After>k__BackingField;
    public List`1<ScriptTrivia> Before { get; }
    public List`1<ScriptTrivia> After { get; }
    [CompilerGeneratedAttribute]
public List`1<ScriptTrivia> get_Before();
    [CompilerGeneratedAttribute]
public List`1<ScriptTrivia> get_After();
}
public enum Scriban.Syntax.ScriptTriviaType : Enum {
    public int value__;
    public static ScriptTriviaType Empty;
    public static ScriptTriviaType Whitespace;
    public static ScriptTriviaType WhitespaceFull;
    public static ScriptTriviaType Comment;
    public static ScriptTriviaType Comma;
    public static ScriptTriviaType CommentMulti;
    public static ScriptTriviaType NewLine;
    public static ScriptTriviaType SemiColon;
}
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptTriviaTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsSpace(ScriptTriviaType triviaType);
    [ExtensionAttribute]
public static bool IsNewLine(ScriptTriviaType triviaType);
    [ExtensionAttribute]
public static bool IsSpaceOrNewLine(ScriptTriviaType triviaType);
}
[AttributeUsageAttribute("28")]
public class Scriban.Syntax.ScriptTypeNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public ScriptTypeNameAttribute(string typeName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
}
[ScriptSyntaxAttribute("unary expression", "<operator> <expression>")]
public class Scriban.Syntax.ScriptUnaryExpression : ScriptExpression {
    private ScriptToken _operatorToken;
    private ScriptExpression _right;
    [CompilerGeneratedAttribute]
private ScriptUnaryOperator <Operator>k__BackingField;
    public int ChildrenCount { get; }
    public ScriptUnaryOperator Operator { get; public set; }
    public ScriptToken OperatorToken { get; public set; }
    public string OperatorAsText { get; }
    public ScriptExpression Right { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptUnaryExpression/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
public ScriptUnaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(ScriptUnaryOperator value);
    public ScriptToken get_OperatorToken();
    public void set_OperatorToken(ScriptToken value);
    public string get_OperatorAsText();
    public ScriptExpression get_Right();
    public void set_Right(ScriptExpression value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
    public static object Evaluate(TemplateContext context, SourceSpan span, ScriptUnaryOperator op, object value);
    public static ScriptUnaryExpression Wrap(ScriptUnaryOperator unaryOperator, ScriptToken unaryToken, ScriptExpression expression, bool transferTrivia);
}
public enum Scriban.Syntax.ScriptUnaryOperator : Enum {
    public int value__;
    public static ScriptUnaryOperator None;
    public static ScriptUnaryOperator Not;
    public static ScriptUnaryOperator Negate;
    public static ScriptUnaryOperator Plus;
    public static ScriptUnaryOperator FunctionAlias;
    public static ScriptUnaryOperator FunctionParametersExpand;
    public static ScriptUnaryOperator Increment;
    public static ScriptUnaryOperator Decrement;
    public static ScriptUnaryOperator Custom;
}
[ExtensionAttribute]
public static class Scriban.Syntax.ScriptUnaryOperatorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToText(ScriptUnaryOperator op);
}
[ScriptSyntaxAttribute("variable", "<variable_name>")]
public abstract class Scriban.Syntax.ScriptVariable : ScriptExpression {
    private int _hashCode;
    public static ScriptVariableLocal Arguments;
    public static ScriptVariableLocal BlockDelegate;
    public static ScriptVariableLocal Continue;
    public static ScriptVariableGlobal ForObject;
    public static ScriptVariableGlobal TablerowObject;
    public static ScriptVariableGlobal WhileObject;
    [CompilerGeneratedAttribute]
private ScriptTrivias <Trivias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptVariableScope <Scope>k__BackingField;
    public ScriptTrivias Trivias { get; public set; }
    public string BaseName { get; }
    public string Name { get; }
    public ScriptVariableScope Scope { get; }
    protected ScriptVariable(string name, ScriptVariableScope scope);
    private static ScriptVariable();
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptVariable/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptVariable/<GetValueAsync>d__1")]
public virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    [CompilerGeneratedAttribute]
public sealed virtual ScriptTrivias get_Trivias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Trivias(ScriptTrivias value);
    public static ScriptVariable Create(string name, ScriptVariableScope scope);
    [CompilerGeneratedAttribute]
public string get_BaseName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ScriptVariableScope get_Scope();
    public sealed virtual string GetFirstPath();
    public sealed virtual ValueTask SetValueAsync(TemplateContext context, object valueToSet);
    public virtual bool Equals(ScriptVariable other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ScriptVariable left, ScriptVariable right);
    public static bool op_Inequality(ScriptVariable left, ScriptVariable right);
    public virtual object Evaluate(TemplateContext context);
    public virtual object GetValue(TemplateContext context);
    public sealed virtual void SetValue(TemplateContext context, object valueToSet);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Syntax.ScriptVariableGlobal : ScriptVariable {
    public int ChildrenCount { get; }
    public ScriptVariableGlobal(string name);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptVariableGlobal/<GetValueAsync>d__0")]
public virtual ValueTask`1<object> GetValueAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public virtual object GetValue(TemplateContext context);
}
public class Scriban.Syntax.ScriptVariableLocal : ScriptVariable {
    public int ChildrenCount { get; }
    public ScriptVariableLocal(string name);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
}
public enum Scriban.Syntax.ScriptVariableScope : Enum {
    public int value__;
    public static ScriptVariableScope Global;
    public static ScriptVariableScope Local;
}
public abstract class Scriban.Syntax.ScriptVerbatim : ScriptNode {
    [CompilerGeneratedAttribute]
private ScriptTrivias <Trivias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public ScriptTrivias Trivias { get; public set; }
    public string Value { get; public set; }
    protected ScriptVerbatim(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ScriptTrivias get_Trivias();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Trivias(ScriptTrivias value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public abstract class Scriban.Syntax.ScriptVisitor : object {
    public virtual void Visit(ScriptAnonymousFunction node);
    public virtual void Visit(ScriptArgumentBinary node);
    public virtual void Visit(ScriptArrayInitializerExpression node);
    public virtual void Visit(ScriptAssignExpression node);
    public virtual void Visit(ScriptBinaryExpression node);
    public virtual void Visit(ScriptBlockStatement node);
    public virtual void Visit(ScriptBreakStatement node);
    public virtual void Visit(ScriptCaptureStatement node);
    public virtual void Visit(ScriptCaseStatement node);
    public virtual void Visit(ScriptConditionalExpression node);
    public virtual void Visit(ScriptContinueStatement node);
    public virtual void Visit(ScriptElseStatement node);
    public virtual void Visit(ScriptEndStatement node);
    public virtual void Visit(ScriptEscapeStatement node);
    public virtual void Visit(ScriptExpressionStatement node);
    public virtual void Visit(ScriptForStatement node);
    public virtual void Visit(ScriptFrontMatter node);
    public virtual void Visit(ScriptFunction node);
    public virtual void Visit(ScriptFunctionCall node);
    public virtual void Visit(ScriptIdentifier node);
    public virtual void Visit(ScriptIfStatement node);
    public virtual void Visit(ScriptImportStatement node);
    public virtual void Visit(ScriptIncrementDecrementExpression node);
    public virtual void Visit(ScriptIndexerExpression node);
    public virtual void Visit(ScriptInterpolatedExpression node);
    public virtual void Visit(ScriptIsEmptyExpression node);
    public virtual void Visit(ScriptKeyword node);
    public virtual void Visit(ScriptLiteral node);
    public virtual void Visit(ScriptMemberExpression node);
    public virtual void Visit(ScriptNamedArgument node);
    public virtual void Visit(ScriptNestedExpression node);
    public virtual void Visit(ScriptNopStatement node);
    public virtual void Visit(ScriptObjectInitializerExpression node);
    public virtual void Visit(ScriptObjectMember node);
    public virtual void Visit(ScriptPage node);
    public virtual void Visit(ScriptParameter node);
    public virtual void Visit(ScriptPipeCall node);
    public virtual void Visit(ScriptRawStatement node);
    public virtual void Visit(ScriptReadOnlyStatement node);
    public virtual void Visit(ScriptReturnStatement node);
    public virtual void Visit(ScriptTableRowStatement node);
    public virtual void Visit(ScriptThisExpression node);
    public virtual void Visit(ScriptToken node);
    public virtual void Visit(ScriptUnaryExpression node);
    public virtual void Visit(ScriptVariableGlobal node);
    public virtual void Visit(ScriptVariableLocal node);
    public virtual void Visit(ScriptWhenStatement node);
    public virtual void Visit(ScriptWhileStatement node);
    public virtual void Visit(ScriptWithStatement node);
    public virtual void Visit(ScriptWrapStatement node);
    public virtual void Visit(ScriptNode node);
    public virtual void Visit(ScriptList list);
    protected virtual void DefaultVisit(ScriptNode node);
}
public abstract class Scriban.Syntax.ScriptVisitor`1 : object {
    public virtual TResult Visit(ScriptAnonymousFunction node);
    public virtual TResult Visit(ScriptArgumentBinary node);
    public virtual TResult Visit(ScriptArrayInitializerExpression node);
    public virtual TResult Visit(ScriptAssignExpression node);
    public virtual TResult Visit(ScriptBinaryExpression node);
    public virtual TResult Visit(ScriptBlockStatement node);
    public virtual TResult Visit(ScriptBreakStatement node);
    public virtual TResult Visit(ScriptCaptureStatement node);
    public virtual TResult Visit(ScriptCaseStatement node);
    public virtual TResult Visit(ScriptConditionalExpression node);
    public virtual TResult Visit(ScriptContinueStatement node);
    public virtual TResult Visit(ScriptElseStatement node);
    public virtual TResult Visit(ScriptEndStatement node);
    public virtual TResult Visit(ScriptEscapeStatement node);
    public virtual TResult Visit(ScriptExpressionStatement node);
    public virtual TResult Visit(ScriptForStatement node);
    public virtual TResult Visit(ScriptFrontMatter node);
    public virtual TResult Visit(ScriptFunction node);
    public virtual TResult Visit(ScriptFunctionCall node);
    public virtual TResult Visit(ScriptIdentifier node);
    public virtual TResult Visit(ScriptIfStatement node);
    public virtual TResult Visit(ScriptImportStatement node);
    public virtual TResult Visit(ScriptIncrementDecrementExpression node);
    public virtual TResult Visit(ScriptIndexerExpression node);
    public virtual TResult Visit(ScriptInterpolatedExpression node);
    public virtual TResult Visit(ScriptIsEmptyExpression node);
    public virtual TResult Visit(ScriptKeyword node);
    public virtual TResult Visit(ScriptLiteral node);
    public virtual TResult Visit(ScriptMemberExpression node);
    public virtual TResult Visit(ScriptNamedArgument node);
    public virtual TResult Visit(ScriptNestedExpression node);
    public virtual TResult Visit(ScriptNopStatement node);
    public virtual TResult Visit(ScriptObjectInitializerExpression node);
    public virtual TResult Visit(ScriptObjectMember node);
    public virtual TResult Visit(ScriptPage node);
    public virtual TResult Visit(ScriptParameter node);
    public virtual TResult Visit(ScriptPipeCall node);
    public virtual TResult Visit(ScriptRawStatement node);
    public virtual TResult Visit(ScriptReadOnlyStatement node);
    public virtual TResult Visit(ScriptReturnStatement node);
    public virtual TResult Visit(ScriptTableRowStatement node);
    public virtual TResult Visit(ScriptThisExpression node);
    public virtual TResult Visit(ScriptToken node);
    public virtual TResult Visit(ScriptUnaryExpression node);
    public virtual TResult Visit(ScriptVariableGlobal node);
    public virtual TResult Visit(ScriptVariableLocal node);
    public virtual TResult Visit(ScriptWhenStatement node);
    public virtual TResult Visit(ScriptWhileStatement node);
    public virtual TResult Visit(ScriptWithStatement node);
    public virtual TResult Visit(ScriptWrapStatement node);
    public virtual TResult Visit(ScriptNode node);
    protected virtual TResult DefaultVisit(ScriptNode node);
}
[ScriptSyntaxAttribute("when statement", "when <expression> ... end|when|else")]
public class Scriban.Syntax.ScriptWhenStatement : ScriptConditionStatement {
    private ScriptKeyword _whenKeyword;
    private ScriptList`1<ScriptExpression> _values;
    private ScriptBlockStatement _body;
    private ScriptConditionStatement _next;
    public int ChildrenCount { get; }
    public ScriptKeyword WhenKeyword { get; public set; }
    public ScriptList`1<ScriptExpression> Values { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    public ScriptConditionStatement Next { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptWhenStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_WhenKeyword();
    public void set_WhenKeyword(ScriptKeyword value);
    public ScriptList`1<ScriptExpression> get_Values();
    public void set_Values(ScriptList`1<ScriptExpression> value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public ScriptConditionStatement get_Next();
    public void set_Next(ScriptConditionStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("while statement", "while <expression> ... end")]
public class Scriban.Syntax.ScriptWhileStatement : ScriptLoopStatementBase {
    private ScriptKeyword _whileKeyword;
    private ScriptExpression _condition;
    private ScriptBlockStatement _body;
    public int ChildrenCount { get; }
    public ScriptKeyword WhileKeyword { get; public set; }
    public ScriptExpression Condition { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptWhileStatement/<EvaluateImplAsync>d__0")]
protected virtual ValueTask`1<object> EvaluateImplAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptWhileStatement/<LoopItemAsync>d__1")]
protected virtual ValueTask`1<object> LoopItemAsync(TemplateContext context, LoopState state);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_WhileKeyword();
    public void set_WhileKeyword(ScriptKeyword value);
    public ScriptExpression get_Condition();
    public void set_Condition(ScriptExpression value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    protected virtual object LoopItem(TemplateContext context, LoopState state);
    protected virtual object EvaluateImpl(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public enum Scriban.Syntax.ScriptWhitespaceMode : Enum {
    public int value__;
    public static ScriptWhitespaceMode None;
    public static ScriptWhitespaceMode Greedy;
    public static ScriptWhitespaceMode NonGreedy;
}
[ScriptSyntaxAttribute("with statement", "with <variable> ... end")]
public class Scriban.Syntax.ScriptWithStatement : ScriptStatement {
    private ScriptKeyword _withKeyword;
    private ScriptExpression _name;
    private ScriptBlockStatement _body;
    public int ChildrenCount { get; }
    public ScriptKeyword WithKeyword { get; public set; }
    public ScriptExpression Name { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptWithStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_WithKeyword();
    public void set_WithKeyword(ScriptKeyword value);
    public ScriptExpression get_Name();
    public void set_Name(ScriptExpression value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
[ScriptSyntaxAttribute("wrap statement", "wrap <function_call> ... end")]
public class Scriban.Syntax.ScriptWrapStatement : ScriptStatement {
    private ScriptKeyword _wrapKeyword;
    private ScriptExpression _target;
    private ScriptBlockStatement _body;
    public int ChildrenCount { get; }
    public ScriptKeyword WrapKeyword { get; public set; }
    public ScriptExpression Target { get; public set; }
    public ScriptBlockStatement Body { get; public set; }
    [AsyncStateMachineAttribute("Scriban.Syntax.ScriptWrapStatement/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(TemplateContext context);
    public virtual int get_ChildrenCount();
    protected virtual ScriptNode GetChildrenImpl(int index);
    public virtual void Accept(ScriptVisitor visitor);
    public virtual TResult Accept(ScriptVisitor`1<TResult> visitor);
    public ScriptKeyword get_WrapKeyword();
    public void set_WrapKeyword(ScriptKeyword value);
    public ScriptExpression get_Target();
    public void set_Target(ScriptExpression value);
    public ScriptBlockStatement get_Body();
    public void set_Body(ScriptBlockStatement value);
    public virtual object Evaluate(TemplateContext context);
    public virtual void PrintTo(ScriptPrinter printer);
}
public class Scriban.Template : object {
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptPage <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private LogMessageBag <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ParserOptions <ParserOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private LexerOptions <LexerOptions>k__BackingField;
    public string SourceFilePath { get; }
    public ScriptPage Page { get; private set; }
    public bool HasErrors { get; private set; }
    public LogMessageBag Messages { get; }
    public ParserOptions ParserOptions { get; }
    public LexerOptions LexerOptions { get; }
    private Template(Nullable`1<ParserOptions> parserOptions, Nullable`1<LexerOptions> lexerOptions, string sourceFilePath);
    [AsyncStateMachineAttribute("Scriban.Template/<EvaluateAndRenderAsync>d__0")]
private ValueTask`1<object> EvaluateAndRenderAsync(TemplateContext context, bool render);
    [AsyncStateMachineAttribute("Scriban.Template/<EvaluateAsync>d__1")]
public ValueTask`1<object> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Template/<EvaluateAsync>d__2")]
public static ValueTask`1<object> EvaluateAsync(string expression, TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Template/<EvaluateAsync>d__3")]
public ValueTask`1<object> EvaluateAsync(object model, MemberRenamerDelegate memberRenamer, MemberFilterDelegate memberFilter);
    [AsyncStateMachineAttribute("Scriban.Template/<EvaluateAsync>d__4")]
public static ValueTask`1<object> EvaluateAsync(string expression, object model, MemberRenamerDelegate memberRenamer, MemberFilterDelegate memberFilter);
    [AsyncStateMachineAttribute("Scriban.Template/<RenderAsync>d__5")]
public ValueTask`1<string> RenderAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Scriban.Template/<RenderAsync>d__6")]
public ValueTask`1<string> RenderAsync(object model, MemberRenamerDelegate memberRenamer, MemberFilterDelegate memberFilter);
    [CompilerGeneratedAttribute]
public string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public ScriptPage get_Page();
    [CompilerGeneratedAttribute]
private void set_Page(ScriptPage value);
    [CompilerGeneratedAttribute]
public bool get_HasErrors();
    [CompilerGeneratedAttribute]
private void set_HasErrors(bool value);
    [CompilerGeneratedAttribute]
public LogMessageBag get_Messages();
    [CompilerGeneratedAttribute]
public ParserOptions get_ParserOptions();
    [CompilerGeneratedAttribute]
public LexerOptions get_LexerOptions();
    public static Template Parse(string text, string sourceFilePath, Nullable`1<ParserOptions> parserOptions, Nullable`1<LexerOptions> lexerOptions);
    public static Template ParseLiquid(string text, string sourceFilePath, Nullable`1<ParserOptions> parserOptions, Nullable`1<LexerOptions> lexerOptions);
    public static object Evaluate(string expression, TemplateContext context);
    public static object Evaluate(string expression, object model, MemberRenamerDelegate memberRenamer, MemberFilterDelegate memberFilter);
    public object Evaluate(TemplateContext context);
    public object Evaluate(object model, MemberRenamerDelegate memberRenamer, MemberFilterDelegate memberFilter);
    public string Render(TemplateContext context);
    public string Render(object model, MemberRenamerDelegate memberRenamer, MemberFilterDelegate memberFilter);
    public string ToText(ScriptPrinterOptions options);
    private object EvaluateAndRender(TemplateContext context, bool render);
    private void CheckErrors();
    private void ParseInternal(string text, string sourceFilePath);
}
public class Scriban.TemplateContext : object {
    private FastStack`1<ScriptObject> _availableStores;
    internal FastStack`1<ScriptBlockStatement> BlockDelegates;
    private FastStack`1<VariableContext> _globalContexts;
    private FastStack`1<CultureInfo> _cultures;
    private Dictionary`2<Type, IListAccessor> _listAccessors;
    private FastStack`1<ScriptLoopStatementBase> _loops;
    private Dictionary`2<Type, IObjectAccessor> _memberAccessors;
    private FastStack`1<IScriptOutput> _outputs;
    private FastStack`1<VariableContext> _localContexts;
    private VariableContext _currentLocalContext;
    private IScriptOutput _output;
    private FastStack`1<string> _sourceFiles;
    private FastStack`1<object> _caseValues;
    private int _callDepth;
    private bool _isFunctionCallDisabled;
    private int _loopStep;
    private int _getOrSetValueLevel;
    private FastStack`1<VariableContext> _availableGlobalContexts;
    private FastStack`1<VariableContext> _availableLocalContexts;
    private FastStack`1<ScriptPipeArguments> _availablePipeArguments;
    private FastStack`1<ScriptPipeArguments> _pipeArguments;
    private FastStack`1<List`1<ScriptExpression>> _availableScriptExpressionLists;
    private Object[][] _availableReflectionArguments;
    private FastStack`1<Dictionary`2<object, object>> _availableTags;
    private ScriptPipeArguments _currentPipeArguments;
    private bool _previousTextWasNewLine;
    private IEqualityComparer`1<string> _keyComparer;
    public static RenderRuntimeExceptionDelegate RenderRuntimeExceptionDefault;
    [CompilerGeneratedAttribute]
private ITemplateLoader <TemplateLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLiquid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LimitToString>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ObjectRecursionLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptLang <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ParserOptions <TemplateLoaderParserOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private LexerOptions <TemplateLoaderLexerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberRenamerDelegate <MemberRenamer>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberFilterDelegate <MemberFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoopLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LoopLimitQueryable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecursiveLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseScientific>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorForStatementFunctionAsExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptObject <BuiltinObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Template> <CachedTemplates>k__BackingField;
    [CompilerGeneratedAttribute]
private TryGetVariableDelegate <TryGetVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private RenderRuntimeExceptionDelegate <RenderRuntimeException>k__BackingField;
    [CompilerGeneratedAttribute]
private TryGetMemberDelegate <TryGetMember>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, object> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptFlowState <FlowState>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RegexTimeOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableBreakAndContinueAsReturnOutsideLoop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableRelaxedTargetAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableRelaxedMemberAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableRelaxedFunctionAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableRelaxedIndexerAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNullIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptNode <CurrentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExceptionsWhileRewritingScientific>k__BackingField;
    private static object TrueObject;
    private static object FalseObject;
    private int _objectToStringLevel;
    private int _currentToStringLength;
    internal bool AllowPipeArguments { get; }
    public CultureInfo CurrentCulture { get; }
    public ITemplateLoader TemplateLoader { get; public set; }
    public bool IsLiquid { get; protected set; }
    public bool AutoIndent { get; public set; }
    [ObsoleteAttribute("Use AutoIndent instead. Note that AutoIndent is true by default.")]
public bool IndentWithInclude { get; public set; }
    public int LimitToString { get; public set; }
    public int ObjectRecursionLimit { get; public set; }
    public string NewLine { get; public set; }
    public ScriptLang Language { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public ParserOptions TemplateLoaderParserOptions { get; public set; }
    public LexerOptions TemplateLoaderLexerOptions { get; public set; }
    public MemberRenamerDelegate MemberRenamer { get; public set; }
    public MemberFilterDelegate MemberFilter { get; public set; }
    public int LoopLimit { get; public set; }
    public Nullable`1<int> LoopLimitQueryable { get; public set; }
    public int RecursiveLimit { get; public set; }
    public bool EnableOutput { get; public set; }
    public IScriptOutput Output { get; }
    public bool UseScientific { get; public set; }
    public bool ErrorForStatementFunctionAsExpression { get; public set; }
    public ScriptObject BuiltinObject { get; }
    public IScriptObject CurrentGlobal { get; }
    public Dictionary`2<string, Template> CachedTemplates { get; }
    public string CurrentSourceFile { get; }
    public TryGetVariableDelegate TryGetVariable { get; public set; }
    public RenderRuntimeExceptionDelegate RenderRuntimeException { get; public set; }
    public TryGetMemberDelegate TryGetMember { get; public set; }
    public Dictionary`2<object, object> Tags { get; }
    internal ScriptPipeArguments CurrentPipeArguments { get; }
    public int GlobalCount { get; }
    public int OutputCount { get; }
    public int CultureCount { get; }
    public int SourceFileCount { get; }
    internal ScriptFlowState FlowState { get; internal set; }
    public TimeSpan RegexTimeOut { get; public set; }
    public bool StrictVariables { get; public set; }
    public bool EnableBreakAndContinueAsReturnOutsideLoop { get; public set; }
    public bool EnableRelaxedTargetAccess { get; public set; }
    public bool EnableRelaxedMemberAccess { get; public set; }
    public bool EnableRelaxedFunctionAccess { get; public set; }
    public bool EnableRelaxedIndexerAccess { get; public set; }
    public bool EnableNullIndexer { get; public set; }
    public ScriptNode CurrentNode { get; private set; }
    public SourceSpan CurrentSpan { get; }
    public string CurrentIndent { get; public set; }
    internal bool IsInLoop { get; }
    internal bool IgnoreExceptionsWhileRewritingScientific { get; internal set; }
    public TemplateContext(ScriptObject builtin);
    public TemplateContext(IEqualityComparer`1<string> keyComparer);
    public TemplateContext(ScriptObject builtin, IEqualityComparer`1<string> keyComparer);
    private static TemplateContext();
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<EvaluateAsync>d__0")]
public virtual ValueTask`1<object> EvaluateAsync(ScriptNode scriptNode, bool aliasReturnedFunction);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<EvaluateAsync>d__1")]
public ValueTask`1<object> EvaluateAsync(ScriptNode scriptNode);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<GetOrSetValueAsync>d__2")]
private ValueTask`1<object> GetOrSetValueAsync(ScriptExpression targetExpression, object valueToSet, bool setter);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<GetValueAsync>d__3")]
public ValueTask`1<object> GetValueAsync(ScriptExpression target);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<SetValueAsync>d__4")]
public ValueTask SetValueAsync(ScriptExpression target, object value);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<WriteAsync>d__5")]
public ValueTask`1<TemplateContext> WriteAsync(string text, int startIndex, int count);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<WriteAsync>d__6")]
public ValueTask`1<TemplateContext> WriteAsync(string text);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<WriteAsync>d__7")]
public ValueTask`1<TemplateContext> WriteAsync(ScriptStringSlice slice);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<WriteAsync>d__8")]
public virtual ValueTask`1<TemplateContext> WriteAsync(SourceSpan span, object textAsObject);
    [AsyncStateMachineAttribute("Scriban.TemplateContext/<WriteLineAsync>d__9")]
public ValueTask`1<TemplateContext> WriteLineAsync();
    internal bool get_AllowPipeArguments();
    public CultureInfo get_CurrentCulture();
    [CompilerGeneratedAttribute]
public ITemplateLoader get_TemplateLoader();
    [CompilerGeneratedAttribute]
public void set_TemplateLoader(ITemplateLoader value);
    [CompilerGeneratedAttribute]
public bool get_IsLiquid();
    [CompilerGeneratedAttribute]
protected void set_IsLiquid(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoIndent();
    [CompilerGeneratedAttribute]
public void set_AutoIndent(bool value);
    public bool get_IndentWithInclude();
    public void set_IndentWithInclude(bool value);
    [CompilerGeneratedAttribute]
public int get_LimitToString();
    [CompilerGeneratedAttribute]
public void set_LimitToString(int value);
    [CompilerGeneratedAttribute]
public int get_ObjectRecursionLimit();
    [CompilerGeneratedAttribute]
public void set_ObjectRecursionLimit(int value);
    [CompilerGeneratedAttribute]
public string get_NewLine();
    [CompilerGeneratedAttribute]
public void set_NewLine(string value);
    [CompilerGeneratedAttribute]
public ScriptLang get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(ScriptLang value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public ParserOptions get_TemplateLoaderParserOptions();
    [CompilerGeneratedAttribute]
public void set_TemplateLoaderParserOptions(ParserOptions value);
    [CompilerGeneratedAttribute]
public LexerOptions get_TemplateLoaderLexerOptions();
    [CompilerGeneratedAttribute]
public void set_TemplateLoaderLexerOptions(LexerOptions value);
    [CompilerGeneratedAttribute]
public MemberRenamerDelegate get_MemberRenamer();
    [CompilerGeneratedAttribute]
public void set_MemberRenamer(MemberRenamerDelegate value);
    [CompilerGeneratedAttribute]
public MemberFilterDelegate get_MemberFilter();
    [CompilerGeneratedAttribute]
public void set_MemberFilter(MemberFilterDelegate value);
    [CompilerGeneratedAttribute]
public int get_LoopLimit();
    [CompilerGeneratedAttribute]
public void set_LoopLimit(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LoopLimitQueryable();
    [CompilerGeneratedAttribute]
public void set_LoopLimitQueryable(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_RecursiveLimit();
    [CompilerGeneratedAttribute]
public void set_RecursiveLimit(int value);
    [CompilerGeneratedAttribute]
public bool get_EnableOutput();
    [CompilerGeneratedAttribute]
public void set_EnableOutput(bool value);
    public IScriptOutput get_Output();
    [CompilerGeneratedAttribute]
public bool get_UseScientific();
    [CompilerGeneratedAttribute]
public void set_UseScientific(bool value);
    [CompilerGeneratedAttribute]
public bool get_ErrorForStatementFunctionAsExpression();
    [CompilerGeneratedAttribute]
public void set_ErrorForStatementFunctionAsExpression(bool value);
    [CompilerGeneratedAttribute]
public ScriptObject get_BuiltinObject();
    public IScriptObject get_CurrentGlobal();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Template> get_CachedTemplates();
    public string get_CurrentSourceFile();
    [CompilerGeneratedAttribute]
public TryGetVariableDelegate get_TryGetVariable();
    [CompilerGeneratedAttribute]
public void set_TryGetVariable(TryGetVariableDelegate value);
    [CompilerGeneratedAttribute]
public RenderRuntimeExceptionDelegate get_RenderRuntimeException();
    [CompilerGeneratedAttribute]
public void set_RenderRuntimeException(RenderRuntimeExceptionDelegate value);
    [CompilerGeneratedAttribute]
public TryGetMemberDelegate get_TryGetMember();
    [CompilerGeneratedAttribute]
public void set_TryGetMember(TryGetMemberDelegate value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, object> get_Tags();
    internal ScriptPipeArguments get_CurrentPipeArguments();
    public int get_GlobalCount();
    public int get_OutputCount();
    public int get_CultureCount();
    public int get_SourceFileCount();
    [CompilerGeneratedAttribute]
internal ScriptFlowState get_FlowState();
    [CompilerGeneratedAttribute]
internal void set_FlowState(ScriptFlowState value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RegexTimeOut();
    [CompilerGeneratedAttribute]
public void set_RegexTimeOut(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_StrictVariables();
    [CompilerGeneratedAttribute]
public void set_StrictVariables(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableBreakAndContinueAsReturnOutsideLoop();
    [CompilerGeneratedAttribute]
public void set_EnableBreakAndContinueAsReturnOutsideLoop(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableRelaxedTargetAccess();
    [CompilerGeneratedAttribute]
public void set_EnableRelaxedTargetAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableRelaxedMemberAccess();
    [CompilerGeneratedAttribute]
public void set_EnableRelaxedMemberAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableRelaxedFunctionAccess();
    [CompilerGeneratedAttribute]
public void set_EnableRelaxedFunctionAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableRelaxedIndexerAccess();
    [CompilerGeneratedAttribute]
public void set_EnableRelaxedIndexerAccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableNullIndexer();
    [CompilerGeneratedAttribute]
public void set_EnableNullIndexer(bool value);
    [CompilerGeneratedAttribute]
public ScriptNode get_CurrentNode();
    [CompilerGeneratedAttribute]
private void set_CurrentNode(ScriptNode value);
    public SourceSpan get_CurrentSpan();
    [CompilerGeneratedAttribute]
public string get_CurrentIndent();
    [CompilerGeneratedAttribute]
public void set_CurrentIndent(string value);
    internal bool get_IsInLoop();
    [CompilerGeneratedAttribute]
internal bool get_IgnoreExceptionsWhileRewritingScientific();
    [CompilerGeneratedAttribute]
internal void set_IgnoreExceptionsWhileRewritingScientific(bool value);
    public void CheckAbort();
    public void PushCulture(CultureInfo culture);
    public CultureInfo PopCulture();
    internal void PushPipeArguments();
    internal void ClearPipeArguments();
    internal List`1<ScriptExpression> GetOrCreateListOfScriptExpressions(int capacity);
    internal void ReleaseListOfScriptExpressions(List`1<ScriptExpression> list);
    internal Object[] GetOrCreateReflectionArguments(int length);
    internal void ReleaseReflectionArguments(Object[] reflectionArguments);
    internal void PopPipeArguments();
    public void PushSourceFile(string sourceFile);
    public string PopSourceFile();
    public object GetValue(ScriptExpression target);
    public void SetValue(ScriptVariable variable, bool value);
    public virtual void Import(SourceSpan span, object objectToImport);
    public void SetValue(ScriptExpression target, object value);
    public void PushOutput();
    public void PushOutput(IScriptOutput output);
    public IScriptOutput PopOutput();
    public virtual TemplateContext Write(SourceSpan span, object textAsObject);
    public TemplateContext Write(string text);
    public TemplateContext WriteLine();
    public TemplateContext Write(ScriptStringSlice slice);
    public TemplateContext Write(string text, int startIndex, int count);
    public object Evaluate(ScriptNode scriptNode);
    public virtual object Evaluate(ScriptNode scriptNode, bool aliasReturnedFunction);
    public IObjectAccessor GetMemberAccessor(object target);
    public virtual void Reset();
    protected virtual IObjectAccessor GetMemberAccessorImpl(object target);
    public static ScriptObject GetDefaultBuiltinObject();
    public void EnterRecursive(ScriptNode node);
    public void ExitRecursive(ScriptNode node);
    internal void EnterFunction(ScriptNode caller);
    internal void ExitFunction(ScriptNode caller);
    internal void EnterLoop(ScriptLoopStatementBase loop);
    protected virtual void OnEnterLoop(ScriptLoopStatementBase loop);
    internal void ExitLoop(ScriptLoopStatementBase loop);
    protected virtual void OnExitLoop(ScriptLoopStatementBase loop);
    internal bool StepLoop(ScriptLoopStatementBase loop, LoopType loopType);
    protected virtual bool OnStepLoop(ScriptLoopStatementBase loop);
    internal void PushCase(object caseValue);
    internal object PeekCase();
    internal object PopCase();
    private object GetOrSetValue(ScriptExpression targetExpression, object valueToSet, bool setter);
    public IListAccessor GetListAccessor(object target);
    protected virtual IListAccessor GetListAccessorImpl(object target, Type type);
    internal void ResetPreviousNewLine();
    public sealed virtual object GetFormat(Type formatType);
    public virtual object IsEmpty(SourceSpan span, object against);
    public virtual IList ToList(SourceSpan span, object value);
    public virtual string ObjectToString(object value, bool nested);
    private string ObjectToStringImpl(object value, bool nested);
    public virtual bool ToBool(SourceSpan span, object value);
    public virtual int ToInt(SourceSpan span, object value);
    public virtual string GetTypeName(object value);
    public T ToObject(SourceSpan span, object value);
    public virtual object ToObject(SourceSpan span, object value, Type destinationType);
    public void PushGlobal(IScriptObject scriptObject);
    internal void PushGlobalOnly(IScriptObject scriptObject);
    private VariableContext GetOrCreateGlobalContext(IScriptObject globalObject);
    internal IScriptObject PopGlobalOnly();
    public IScriptObject PopGlobal();
    public void PushLocal();
    public void PopLocal();
    public void SetValue(ScriptVariable variable, object value, bool asReadOnly);
    public void SetValue(ScriptVariable variable, object value, bool asReadOnly, bool force);
    public void DeleteValue(ScriptVariable variable);
    public void SetReadOnly(ScriptVariable variable, bool isReadOnly);
    public virtual void SetLoopVariable(ScriptVariable variable, object value);
    private void PushLocalContext(ScriptObject locals);
    private ScriptObject PopLocalContext();
    public object GetValue(ScriptVariable variable);
    public object GetValue(ScriptVariableGlobal variable);
    public ValueTask`1<object> GetValueAsync(ScriptVariableGlobal variable);
    public ValueTask`1<object> GetValueAsync(ScriptVariable variable);
    public ValueTask SetValueAsync(ScriptVariable variable, object value, bool asReadOnly);
    private IScriptObject GetStoreForWrite(ScriptVariable variable);
    [IteratorStateMachineAttribute("Scriban.TemplateContext/<GetStoreForRead>d__295")]
private IEnumerable`1<IScriptObject> GetStoreForRead(ScriptVariable variable);
    private void CheckVariableFound(ScriptVariable variable, bool found);
    private void PushVariableScope(VariableScope scope);
    private void PopVariableScope(VariableScope scope);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<bool, Type> <ToObject>g__GetNullableInfo|274_0(Type destinationType);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
