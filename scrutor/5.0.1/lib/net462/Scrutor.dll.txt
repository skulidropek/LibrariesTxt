[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ServiceCollectionExtensions : object {
    private static string DecoratedServiceKeySuffix;
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services, Type serviceType, Type decoratorType);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services, Type serviceType, Type decoratorType);
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services, Func`2<TService, TService> decorator);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services, Func`2<TService, TService> decorator);
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services, Func`3<TService, IServiceProvider, TService> decorator);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services, Func`3<TService, IServiceProvider, TService> decorator);
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services, Type serviceType, Func`2<object, object> decorator);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services, Type serviceType, Func`2<object, object> decorator);
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services, Type serviceType, Func`3<object, IServiceProvider, object> decorator);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services, Type serviceType, Func`3<object, IServiceProvider, object> decorator);
    [ExtensionAttribute]
public static IServiceCollection Decorate(IServiceCollection services, DecorationStrategy strategy);
    [ExtensionAttribute]
public static bool TryDecorate(IServiceCollection services, DecorationStrategy strategy);
    private static string GetDecoratorKey(ServiceDescriptor descriptor);
    private static bool IsDecorated(ServiceDescriptor descriptor);
    [ExtensionAttribute]
public static IServiceCollection Scan(IServiceCollection services, Action`1<ITypeSourceSelector> action);
    [ExtensionAttribute]
private static IServiceCollection Populate(IServiceCollection services, ISelector selector, RegistrationStrategy registrationStrategy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Extensions.Internal.TypeNameHelper : object {
    private static char DefaultNestedTypeDelimiter;
    private static Dictionary`2<Type, string> _builtInTypeNames;
    private static TypeNameHelper();
    public static string GetTypeDisplayName(object item, bool fullName);
    public static string GetTypeDisplayName(Type type, bool fullName, bool includeGenericParameterNames, bool includeGenericParameters, char nestedTypeDelimiter);
    private static void ProcessType(StringBuilder builder, Type type, DisplayNameOptions& options);
    private static void ProcessArrayType(StringBuilder builder, Type type, DisplayNameOptions& options);
    private static void ProcessGenericType(StringBuilder builder, Type type, Type[] genericArguments, int length, DisplayNameOptions& options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.AttributeSelector : object {
    [CompilerGeneratedAttribute]
private ISet`1<Type> <Types>k__BackingField;
    private ISet`1<Type> Types { get; }
    public AttributeSelector(ISet`1<Type> types);
    [CompilerGeneratedAttribute]
private ISet`1<Type> get_Types();
    private sealed virtual override void Scrutor.ISelector.Populate(IServiceCollection services, RegistrationStrategy registrationStrategy);
    private static IEnumerable`1<ServiceDescriptorAttribute> GetDuplicates(IEnumerable`1<ServiceDescriptorAttribute> attributes);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Scrutor.ClosedTypeDecorationStrategy : DecorationStrategy {
    [CompilerGeneratedAttribute]
private Type <DecoratorType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`3<object, IServiceProvider, object> <DecoratorFactory>k__BackingField;
    private Type DecoratorType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<object, IServiceProvider, object> DecoratorFactory { get; }
    public ClosedTypeDecorationStrategy(Type serviceType, string serviceKey, Type decoratorType, Func`3<object, IServiceProvider, object> decoratorFactory);
    [CompilerGeneratedAttribute]
private Type get_DecoratorType();
    [CompilerGeneratedAttribute]
private Func`3<object, IServiceProvider, object> get_DecoratorFactory();
    [NullableContextAttribute("1")]
protected virtual bool CanDecorate(Type serviceType);
    [NullableContextAttribute("1")]
public virtual Func`3<IServiceProvider, object, object> CreateDecorator(Type serviceType, string serviceKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scrutor.DecorationException : MissingTypeRegistrationException {
    [CompilerGeneratedAttribute]
private DecorationStrategy <Strategy>k__BackingField;
    public DecorationStrategy Strategy { get; }
    public DecorationException(DecorationStrategy strategy);
    [CompilerGeneratedAttribute]
public DecorationStrategy get_Strategy();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Scrutor.DecorationStrategy : object {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ServiceKey>k__BackingField;
    public Type ServiceType { get; }
    [NullableAttribute("2")]
public string ServiceKey { get; }
    protected DecorationStrategy(Type serviceType, string serviceKey);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ServiceKey();
    public virtual bool CanDecorate(ServiceDescriptor descriptor);
    protected abstract virtual bool CanDecorate(Type serviceType);
    public abstract virtual Func`3<IServiceProvider, object, object> CreateDecorator(Type serviceType, string serviceKey);
    internal static DecorationStrategy WithType(Type serviceType, string serviceKey, Type decoratorType);
    internal static DecorationStrategy WithFactory(Type serviceType, string serviceKey, Func`3<object, IServiceProvider, object> decoratorFactory);
    protected static Func`3<IServiceProvider, object, object> TypeDecorator(Type serviceType, string serviceKey, Type decoratorType);
    protected static Func`3<IServiceProvider, object, object> FactoryDecorator(Type serviceType, string serviceKey, Func`3<object, IServiceProvider, object> decoratorFactory);
    private static DecorationStrategy Create(Type serviceType, string serviceKey, Type decoratorType, Func`3<object, IServiceProvider, object> decoratorFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scrutor.DuplicateTypeRegistrationException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    public DuplicateTypeRegistrationException(Type serviceType);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
}
[ExtensionAttribute]
internal static class Scrutor.EnumerableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ISet`1<T> ToHashSet(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
public interface Scrutor.IAssemblySelector {
    public abstract virtual IImplementationTypeSelector FromCallingAssembly();
    public abstract virtual IImplementationTypeSelector FromExecutingAssembly();
    public abstract virtual IImplementationTypeSelector FromEntryAssembly();
    public abstract virtual IImplementationTypeSelector FromApplicationDependencies();
    public abstract virtual IImplementationTypeSelector FromApplicationDependencies(Func`2<Assembly, bool> predicate);
    public abstract virtual IImplementationTypeSelector FromAssemblyDependencies(Assembly assembly);
    public abstract virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context);
    public abstract virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context, Func`2<Assembly, bool> predicate);
    public abstract virtual IImplementationTypeSelector FromAssemblyOf();
    public abstract virtual IImplementationTypeSelector FromAssembliesOf(Type[] types);
    public abstract virtual IImplementationTypeSelector FromAssembliesOf(IEnumerable`1<Type> types);
    public abstract virtual IImplementationTypeSelector FromAssemblies(Assembly[] assemblies);
    public abstract virtual IImplementationTypeSelector FromAssemblies(IEnumerable`1<Assembly> assemblies);
}
[NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public interface Scrutor.IFluentInterface {
    [NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
public interface Scrutor.IImplementationTypeFilter {
    public abstract virtual IImplementationTypeFilter AssignableTo();
    public abstract virtual IImplementationTypeFilter AssignableTo(Type type);
    public abstract virtual IImplementationTypeFilter AssignableToAny(Type[] types);
    public abstract virtual IImplementationTypeFilter AssignableToAny(IEnumerable`1<Type> types);
    public abstract virtual IImplementationTypeFilter WithAttribute();
    public abstract virtual IImplementationTypeFilter WithAttribute(Type attributeType);
    public abstract virtual IImplementationTypeFilter WithAttribute(Func`2<T, bool> predicate);
    public abstract virtual IImplementationTypeFilter WithoutAttribute();
    public abstract virtual IImplementationTypeFilter WithoutAttribute(Type attributeType);
    public abstract virtual IImplementationTypeFilter WithoutAttribute(Func`2<T, bool> predicate);
    public abstract virtual IImplementationTypeFilter InNamespaceOf();
    public abstract virtual IImplementationTypeFilter InNamespaceOf(Type[] types);
    public abstract virtual IImplementationTypeFilter InNamespaces(String[] namespaces);
    public abstract virtual IImplementationTypeFilter InExactNamespaceOf();
    public abstract virtual IImplementationTypeFilter InExactNamespaceOf(Type[] types);
    public abstract virtual IImplementationTypeFilter InExactNamespaces(String[] namespaces);
    public abstract virtual IImplementationTypeFilter InNamespaces(IEnumerable`1<string> namespaces);
    public abstract virtual IImplementationTypeFilter NotInNamespaceOf();
    public abstract virtual IImplementationTypeFilter NotInNamespaceOf(Type[] types);
    public abstract virtual IImplementationTypeFilter NotInNamespaces(String[] namespaces);
    public abstract virtual IImplementationTypeFilter NotInNamespaces(IEnumerable`1<string> namespaces);
    public abstract virtual IImplementationTypeFilter Where(Func`2<Type, bool> predicate);
}
[NullableContextAttribute("1")]
public interface Scrutor.IImplementationTypeSelector {
    public abstract virtual IServiceTypeSelector AddClasses();
    public abstract virtual IServiceTypeSelector AddClasses(bool publicOnly);
    public abstract virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action);
    public abstract virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action, bool publicOnly);
}
public interface Scrutor.ILifetimeSelector {
    [NullableContextAttribute("1")]
public abstract virtual IImplementationTypeSelector WithSingletonLifetime();
    [NullableContextAttribute("1")]
public abstract virtual IImplementationTypeSelector WithScopedLifetime();
    [NullableContextAttribute("1")]
public abstract virtual IImplementationTypeSelector WithTransientLifetime();
    [NullableContextAttribute("1")]
public abstract virtual IImplementationTypeSelector WithLifetime(ServiceLifetime lifetime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.ImplementationTypeFilter : object {
    [CompilerGeneratedAttribute]
private ISet`1<Type> <Types>k__BackingField;
    internal ISet`1<Type> Types { get; private set; }
    public ImplementationTypeFilter(ISet`1<Type> types);
    [CompilerGeneratedAttribute]
internal ISet`1<Type> get_Types();
    [CompilerGeneratedAttribute]
private void set_Types(ISet`1<Type> value);
    public sealed virtual IImplementationTypeFilter AssignableTo();
    public sealed virtual IImplementationTypeFilter AssignableTo(Type type);
    public sealed virtual IImplementationTypeFilter AssignableToAny(Type[] types);
    public sealed virtual IImplementationTypeFilter AssignableToAny(IEnumerable`1<Type> types);
    public sealed virtual IImplementationTypeFilter WithAttribute();
    public sealed virtual IImplementationTypeFilter WithAttribute(Type attributeType);
    public sealed virtual IImplementationTypeFilter WithAttribute(Func`2<T, bool> predicate);
    public sealed virtual IImplementationTypeFilter WithoutAttribute();
    public sealed virtual IImplementationTypeFilter WithoutAttribute(Type attributeType);
    public sealed virtual IImplementationTypeFilter WithoutAttribute(Func`2<T, bool> predicate);
    public sealed virtual IImplementationTypeFilter InNamespaceOf();
    public sealed virtual IImplementationTypeFilter InNamespaceOf(Type[] types);
    public sealed virtual IImplementationTypeFilter InNamespaces(String[] namespaces);
    public sealed virtual IImplementationTypeFilter InExactNamespaceOf();
    public sealed virtual IImplementationTypeFilter InExactNamespaceOf(Type[] types);
    public sealed virtual IImplementationTypeFilter InExactNamespaces(String[] namespaces);
    public sealed virtual IImplementationTypeFilter InNamespaces(IEnumerable`1<string> namespaces);
    public sealed virtual IImplementationTypeFilter NotInNamespaceOf();
    public sealed virtual IImplementationTypeFilter NotInNamespaceOf(Type[] types);
    public sealed virtual IImplementationTypeFilter NotInNamespaces(String[] namespaces);
    public sealed virtual IImplementationTypeFilter NotInNamespaces(IEnumerable`1<string> namespaces);
    public sealed virtual IImplementationTypeFilter Where(Func`2<Type, bool> predicate);
    private sealed virtual override Type Scrutor.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.ImplementationTypeSelector : object {
    [CompilerGeneratedAttribute]
private ITypeSourceSelector <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Type> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISelector> <Selectors>k__BackingField;
    private ITypeSourceSelector Inner { get; }
    private ISet`1<Type> Types { get; }
    private List`1<ISelector> Selectors { get; }
    public ImplementationTypeSelector(ITypeSourceSelector inner, ISet`1<Type> types);
    [CompilerGeneratedAttribute]
private ITypeSourceSelector get_Inner();
    [CompilerGeneratedAttribute]
private ISet`1<Type> get_Types();
    [CompilerGeneratedAttribute]
private List`1<ISelector> get_Selectors();
    public sealed virtual IServiceTypeSelector AddClasses();
    public sealed virtual IServiceTypeSelector AddClasses(bool publicOnly);
    public sealed virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action);
    public sealed virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action, bool publicOnly);
    public sealed virtual IImplementationTypeSelector FromCallingAssembly();
    public sealed virtual IImplementationTypeSelector FromExecutingAssembly();
    public sealed virtual IImplementationTypeSelector FromEntryAssembly();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies(Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyDependencies(Assembly assembly);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context, Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyOf();
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(Type[] types);
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(IEnumerable`1<Type> types);
    public sealed virtual IImplementationTypeSelector FromAssemblies(Assembly[] assemblies);
    public sealed virtual IImplementationTypeSelector FromAssemblies(IEnumerable`1<Assembly> assemblies);
    private sealed virtual override void Scrutor.ISelector.Populate(IServiceCollection services, RegistrationStrategy registrationStrategy);
    private IServiceTypeSelector AddSelector(IEnumerable`1<Type> types);
    private ISet`1<Type> GetNonAbstractClasses(bool publicOnly);
    private sealed virtual override Type Scrutor.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
public interface Scrutor.ISelector {
    public abstract virtual void Populate(IServiceCollection services, RegistrationStrategy options);
}
[NullableContextAttribute("1")]
public interface Scrutor.IServiceTypeSelector {
    public abstract virtual ILifetimeSelector AsSelf();
    public abstract virtual ILifetimeSelector As();
    public abstract virtual ILifetimeSelector As(Type[] types);
    public abstract virtual ILifetimeSelector As(IEnumerable`1<Type> types);
    public abstract virtual ILifetimeSelector AsImplementedInterfaces();
    public abstract virtual ILifetimeSelector AsImplementedInterfaces(Func`2<Type, bool> predicate);
    public abstract virtual ILifetimeSelector AsSelfWithInterfaces();
    public abstract virtual ILifetimeSelector AsSelfWithInterfaces(Func`2<Type, bool> predicate);
    public abstract virtual ILifetimeSelector AsMatchingInterface();
    public abstract virtual ILifetimeSelector AsMatchingInterface(Action`2<Type, IImplementationTypeFilter> action);
    public abstract virtual ILifetimeSelector As(Func`2<Type, IEnumerable`1<Type>> selector);
    public abstract virtual IImplementationTypeSelector UsingAttributes();
    public abstract virtual IServiceTypeSelector UsingRegistrationStrategy(RegistrationStrategy registrationStrategy);
}
[NullableContextAttribute("1")]
public interface Scrutor.ITypeSelector {
    public abstract virtual IServiceTypeSelector FromTypes(Type[] types);
    public abstract virtual IServiceTypeSelector FromTypes(IEnumerable`1<Type> types);
}
public interface Scrutor.ITypeSourceSelector {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.LifetimeSelector : object {
    [CompilerGeneratedAttribute]
private ServiceTypeSelector <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeMap> <TypeMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeFactoryMap> <TypeFactoryMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ServiceLifetime> <Lifetime>k__BackingField;
    private ServiceTypeSelector Inner { get; }
    private IEnumerable`1<TypeMap> TypeMaps { get; }
    private IEnumerable`1<TypeFactoryMap> TypeFactoryMaps { get; }
    public Nullable`1<ServiceLifetime> Lifetime { get; public set; }
    public LifetimeSelector(ServiceTypeSelector inner, IEnumerable`1<TypeMap> typeMaps, IEnumerable`1<TypeFactoryMap> typeFactoryMaps);
    [CompilerGeneratedAttribute]
private ServiceTypeSelector get_Inner();
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeMap> get_TypeMaps();
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeFactoryMap> get_TypeFactoryMaps();
    [CompilerGeneratedAttribute]
public Nullable`1<ServiceLifetime> get_Lifetime();
    [CompilerGeneratedAttribute]
public void set_Lifetime(Nullable`1<ServiceLifetime> value);
    public sealed virtual IImplementationTypeSelector WithSingletonLifetime();
    public sealed virtual IImplementationTypeSelector WithScopedLifetime();
    public sealed virtual IImplementationTypeSelector WithTransientLifetime();
    public sealed virtual IImplementationTypeSelector WithLifetime(ServiceLifetime lifetime);
    public sealed virtual IImplementationTypeSelector FromCallingAssembly();
    public sealed virtual IImplementationTypeSelector FromExecutingAssembly();
    public sealed virtual IImplementationTypeSelector FromEntryAssembly();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies(Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyDependencies(Assembly assembly);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context, Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyOf();
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(Type[] types);
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(IEnumerable`1<Type> types);
    public sealed virtual IImplementationTypeSelector FromAssemblies(Assembly[] assemblies);
    public sealed virtual IImplementationTypeSelector FromAssemblies(IEnumerable`1<Assembly> assemblies);
    public sealed virtual IServiceTypeSelector AddClasses();
    public sealed virtual IServiceTypeSelector AddClasses(bool publicOnly);
    public sealed virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action);
    public sealed virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action, bool publicOnly);
    public sealed virtual ILifetimeSelector AsSelf();
    public sealed virtual ILifetimeSelector As();
    public sealed virtual ILifetimeSelector As(Type[] types);
    public sealed virtual ILifetimeSelector As(IEnumerable`1<Type> types);
    public sealed virtual ILifetimeSelector AsImplementedInterfaces();
    public sealed virtual ILifetimeSelector AsImplementedInterfaces(Func`2<Type, bool> predicate);
    public sealed virtual ILifetimeSelector AsSelfWithInterfaces();
    public sealed virtual ILifetimeSelector AsSelfWithInterfaces(Func`2<Type, bool> predicate);
    public sealed virtual ILifetimeSelector AsMatchingInterface();
    public sealed virtual ILifetimeSelector AsMatchingInterface(Action`2<Type, IImplementationTypeFilter> action);
    public sealed virtual ILifetimeSelector As(Func`2<Type, IEnumerable`1<Type>> selector);
    public sealed virtual IImplementationTypeSelector UsingAttributes();
    public sealed virtual IServiceTypeSelector UsingRegistrationStrategy(RegistrationStrategy registrationStrategy);
    private sealed virtual override void Scrutor.ISelector.Populate(IServiceCollection services, RegistrationStrategy strategy);
    private sealed virtual override Type Scrutor.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scrutor.MissingTypeRegistrationException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    public MissingTypeRegistrationException(Type serviceType);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Scrutor.OpenGenericDecorationStrategy : DecorationStrategy {
    [CompilerGeneratedAttribute]
private Type <DecoratorType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`3<object, IServiceProvider, object> <DecoratorFactory>k__BackingField;
    private Type DecoratorType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<object, IServiceProvider, object> DecoratorFactory { get; }
    public OpenGenericDecorationStrategy(Type serviceType, string serviceKey, Type decoratorType, Func`3<object, IServiceProvider, object> decoratorFactory);
    [CompilerGeneratedAttribute]
private Type get_DecoratorType();
    [CompilerGeneratedAttribute]
private Func`3<object, IServiceProvider, object> get_DecoratorFactory();
    [NullableContextAttribute("1")]
protected virtual bool CanDecorate(Type serviceType);
    [NullableContextAttribute("1")]
public virtual Func`3<IServiceProvider, object, object> CreateDecorator(Type serviceType, string serviceKey);
}
[DebuggerStepThroughAttribute]
internal static class Scrutor.Preconditions : object {
    [NullableContextAttribute("1")]
public static T NotNull(T value, string parameterName);
    [NullableContextAttribute("1")]
public static string NotEmpty(string value, string parameterName);
    public static TEnum IsDefined(TEnum value, string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Scrutor.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsNonAbstractClass(Type type, bool publicOnly);
    [IteratorStateMachineAttribute("Scrutor.ReflectionExtensions/<GetBaseTypes>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetBaseTypes(Type type);
    [ExtensionAttribute]
public static bool IsInNamespace(Type type, string namespace);
    [ExtensionAttribute]
public static bool IsInExactNamespace(Type type, string namespace);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, Type attributeType);
    [ExtensionAttribute]
public static bool HasAttribute(Type type);
    [ExtensionAttribute]
public static bool HasAttribute(Type type, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool IsBasedOn(Type type, Type otherType);
    [ExtensionAttribute]
private static bool IsAssignableToGenericTypeDefinition(Type type, Type genericType);
    [IteratorStateMachineAttribute("Scrutor.ReflectionExtensions/<FindMatchingInterface>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<Type> FindMatchingInterface(Type type, Action`2<Type, IImplementationTypeFilter> action);
    private static IEnumerable`1<Type> GetImplementedInterfacesToMap(Type type);
    [IteratorStateMachineAttribute("Scrutor.ReflectionExtensions/<FilterMatchingGenericInterfaces>d__11")]
private static IEnumerable`1<Type> FilterMatchingGenericInterfaces(Type type);
    private static bool GenericParametersMatch(IReadOnlyList`1<Type> parameters, IReadOnlyList`1<Type> interfaceArguments);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<Type> GetLoadableTypes(Assembly assembly);
    [ExtensionAttribute]
public static string ToFriendlyName(Type type);
    [ExtensionAttribute]
public static bool IsOpenGeneric(Type type);
    [ExtensionAttribute]
public static bool HasMatchingGenericArity(Type interfaceType, Type type);
    [ExtensionAttribute]
public static bool HasCompatibleGenericArguments(Type type, Type genericTypeDefinition);
    [ExtensionAttribute]
public static Type GetRegistrationType(Type interfaceType, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Scrutor.RegistrationStrategy : object {
    public static RegistrationStrategy Skip;
    public static RegistrationStrategy Append;
    public static RegistrationStrategy Throw;
    private static RegistrationStrategy();
    public static RegistrationStrategy Replace();
    public static RegistrationStrategy Replace(ReplacementBehavior behavior);
    public abstract virtual void Apply(IServiceCollection services, ServiceDescriptor descriptor);
}
[FlagsAttribute]
public enum Scrutor.ReplacementBehavior : Enum {
    public int value__;
    public static ReplacementBehavior Default;
    public static ReplacementBehavior ServiceType;
    public static ReplacementBehavior ImplementationType;
    public static ReplacementBehavior All;
}
[ExtensionAttribute]
internal static class Scrutor.ServiceCollectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasRegistration(IServiceCollection services, Type serviceType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Scrutor.ServiceDescriptorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceLifetime <Lifetime>k__BackingField;
    public Type ServiceType { get; }
    public ServiceLifetime Lifetime { get; }
    public ServiceDescriptorAttribute(Type serviceType);
    public ServiceDescriptorAttribute(Type serviceType, ServiceLifetime lifetime);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public ServiceLifetime get_Lifetime();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Scrutor.ServiceDescriptorAttribute/<GetServiceTypes>d__9")]
public IEnumerable`1<Type> GetServiceTypes(Type fallbackType);
}
[AttributeUsageAttribute("4")]
public class Scrutor.ServiceDescriptorAttribute`1 : ServiceDescriptorAttribute {
    public ServiceDescriptorAttribute`1(ServiceLifetime lifetime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Scrutor.ServiceDescriptorExtensions : object {
    [ExtensionAttribute]
public static ServiceDescriptor WithImplementationFactory(ServiceDescriptor descriptor, Func`3<IServiceProvider, object, object> implementationFactory);
    [ExtensionAttribute]
public static ServiceDescriptor WithServiceKey(ServiceDescriptor descriptor, string serviceKey);
    private static ServiceDescriptor ReplaceServiceKey(ServiceDescriptor descriptor, string serviceKey);
    private static ServiceDescriptor AddServiceKey(ServiceDescriptor descriptor, string serviceKey);
    private static Func`3<IServiceProvider, object, object> DiscardServiceKey(Func`2<IServiceProvider, object> factory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.ServiceTypeSelector : object {
    [CompilerGeneratedAttribute]
private IImplementationTypeSelector <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<Type> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISelector> <Selectors>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RegistrationStrategy <RegistrationStrategy>k__BackingField;
    private IImplementationTypeSelector Inner { get; }
    private ISet`1<Type> Types { get; }
    private List`1<ISelector> Selectors { get; }
    [NullableAttribute("2")]
private RegistrationStrategy RegistrationStrategy { get; private set; }
    public ServiceTypeSelector(IImplementationTypeSelector inner, ISet`1<Type> types);
    [CompilerGeneratedAttribute]
private IImplementationTypeSelector get_Inner();
    [CompilerGeneratedAttribute]
private ISet`1<Type> get_Types();
    [CompilerGeneratedAttribute]
private List`1<ISelector> get_Selectors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private RegistrationStrategy get_RegistrationStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_RegistrationStrategy(RegistrationStrategy value);
    public sealed virtual ILifetimeSelector AsSelf();
    public sealed virtual ILifetimeSelector As();
    public sealed virtual ILifetimeSelector As(Type[] types);
    public sealed virtual ILifetimeSelector As(IEnumerable`1<Type> types);
    public sealed virtual ILifetimeSelector AsImplementedInterfaces();
    public sealed virtual ILifetimeSelector AsImplementedInterfaces(Func`2<Type, bool> predicate);
    public sealed virtual ILifetimeSelector AsSelfWithInterfaces();
    public sealed virtual ILifetimeSelector AsSelfWithInterfaces(Func`2<Type, bool> predicate);
    public sealed virtual ILifetimeSelector AsMatchingInterface();
    public sealed virtual ILifetimeSelector AsMatchingInterface(Action`2<Type, IImplementationTypeFilter> action);
    public sealed virtual ILifetimeSelector As(Func`2<Type, IEnumerable`1<Type>> selector);
    public sealed virtual IImplementationTypeSelector UsingAttributes();
    public sealed virtual IServiceTypeSelector UsingRegistrationStrategy(RegistrationStrategy registrationStrategy);
    public sealed virtual IImplementationTypeSelector FromCallingAssembly();
    public sealed virtual IImplementationTypeSelector FromExecutingAssembly();
    public sealed virtual IImplementationTypeSelector FromEntryAssembly();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies(Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyDependencies(Assembly assembly);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context, Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyOf();
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(Type[] types);
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(IEnumerable`1<Type> types);
    public sealed virtual IImplementationTypeSelector FromAssemblies(Assembly[] assemblies);
    public sealed virtual IImplementationTypeSelector FromAssemblies(IEnumerable`1<Assembly> assemblies);
    public sealed virtual IServiceTypeSelector AddClasses();
    public sealed virtual IServiceTypeSelector AddClasses(bool publicOnly);
    public sealed virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action);
    public sealed virtual IServiceTypeSelector AddClasses(Action`1<IImplementationTypeFilter> action, bool publicOnly);
    internal void PropagateLifetime(ServiceLifetime lifetime);
    private sealed virtual override void Scrutor.ISelector.Populate(IServiceCollection services, RegistrationStrategy registrationStrategy);
    private static IEnumerable`1<Type> GetInterfaces(Type type);
    private static bool ShouldRegister(Type serviceType, Type implementationType);
    private ILifetimeSelector AddSelector(IEnumerable`1<TypeMap> types, IEnumerable`1<TypeFactoryMap> factories);
    private sealed virtual override Type Scrutor.IFluentInterface.GetType();
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Type> <AsSelfWithInterfaces>g__Selector|21_2(Type type, Func`2<Type, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.TypeFactoryMap : ValueType {
    [CompilerGeneratedAttribute]
private Func`2<IServiceProvider, object> <ImplementationFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <ServiceTypes>k__BackingField;
    public Func`2<IServiceProvider, object> ImplementationFactory { get; }
    public IEnumerable`1<Type> ServiceTypes { get; }
    public TypeFactoryMap(Func`2<IServiceProvider, object> implementationFactory, IEnumerable`1<Type> serviceTypes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Func`2<IServiceProvider, object> get_ImplementationFactory();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_ServiceTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Scrutor.TypeMap : ValueType {
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <ServiceTypes>k__BackingField;
    public Type ImplementationType { get; }
    public IEnumerable`1<Type> ServiceTypes { get; }
    public TypeMap(Type implementationType, IEnumerable`1<Type> serviceTypes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_ServiceTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Scrutor.TypeSelectorExtensions : object {
    [ExtensionAttribute]
public static IServiceTypeSelector FromType(ITypeSelector selector);
    [ExtensionAttribute]
public static IServiceTypeSelector FromTypes(ITypeSelector selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IServiceTypeSelector FromTypes(ITypeSelector selector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Scrutor.TypeSourceSelector : object {
    [CompilerGeneratedAttribute]
private List`1<ISelector> <Selectors>k__BackingField;
    private static Assembly EntryAssembly { get; }
    private List`1<ISelector> Selectors { get; }
    private static Assembly get_EntryAssembly();
    [CompilerGeneratedAttribute]
private List`1<ISelector> get_Selectors();
    public sealed virtual IImplementationTypeSelector FromAssemblyOf();
    [ObsoleteAttribute("Misleading, as it might not always determine the correct assembly that called Scrutor. Will be removed in a future release")]
public sealed virtual IImplementationTypeSelector FromCallingAssembly();
    [ObsoleteAttribute("Misleading, as it always uses Scrutor's assembly. Will be removed in a future release")]
public sealed virtual IImplementationTypeSelector FromExecutingAssembly();
    public sealed virtual IImplementationTypeSelector FromEntryAssembly();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies();
    public sealed virtual IImplementationTypeSelector FromApplicationDependencies(Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context);
    public sealed virtual IImplementationTypeSelector FromDependencyContext(DependencyContext context, Func`2<Assembly, bool> predicate);
    public sealed virtual IImplementationTypeSelector FromAssemblyDependencies(Assembly assembly);
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(Type[] types);
    public sealed virtual IImplementationTypeSelector FromAssembliesOf(IEnumerable`1<Type> types);
    public sealed virtual IImplementationTypeSelector FromAssemblies(Assembly[] assemblies);
    public sealed virtual IImplementationTypeSelector FromAssemblies(IEnumerable`1<Assembly> assemblies);
    public sealed virtual IServiceTypeSelector FromTypes(Type[] types);
    public sealed virtual IServiceTypeSelector FromTypes(IEnumerable`1<Type> types);
    public sealed virtual void Populate(IServiceCollection services, RegistrationStrategy registrationStrategy);
    private IImplementationTypeSelector InternalFromAssembliesOf(IEnumerable`1<Type> types);
    private IImplementationTypeSelector InternalFromAssemblies(IEnumerable`1<Assembly> assemblies);
    private static ISet`1<Assembly> LoadAssemblies(ISet`1<AssemblyName> assemblyNames);
    private IImplementationTypeSelector AddSelector(IEnumerable`1<Type> types);
    private sealed virtual override Type Scrutor.IFluentInterface.GetType();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
