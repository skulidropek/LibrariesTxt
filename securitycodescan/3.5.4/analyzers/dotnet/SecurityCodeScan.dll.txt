public abstract class SecurityCodeScan.Analyzers.Analyzers : DiagnosticAnalyzer {
    internal Lazy`1<List`1<SecurityAnalyzer>> Workers;
    private Lazy`1<ImmutableArray`1<DiagnosticDescriptor>> Diagnostics;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal Analyzers(IEnumerable`1<SecurityAnalyzer> analyzers);
    internal Analyzers(SecurityAnalyzer analyzer);
    internal List`1<SecurityAnalyzer> InitWorkers(string language);
    private ImmutableArray`1<DiagnosticDescriptor> InitDiagnostics();
    public virtual void Initialize(AnalysisContext analysisContext);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
internal class SecurityCodeScan.Analyzers.CompilationAnalyzer : object {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Rule;
    private static CompilationAnalyzer();
    public void OnCompilationAction(CompilationAnalysisContext ctx);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class SecurityCodeScan.Analyzers.CSharpAnalyzers : Analyzers {
    internal CSharpAnalyzers(SecurityAnalyzer[] analyzers);
    internal CSharpAnalyzers(SecurityAnalyzer analyzer);
    [CompilerGeneratedAttribute]
private List`1<SecurityAnalyzer> <.ctor>b__2_0();
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.CsrfTokenDiagnosticAnalyzer : SecurityAnalyzer {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CsrfTokenDiagnosticAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
internal class SecurityCodeScan.Analyzers.DebugAnalyzer : DiagnosticAnalyzer {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void VisitMethods(SyntaxNodeAnalysisContext ctx);
    private static void VisitNodeRecursively(SyntaxNode node, int indent, SyntaxNodeAnalysisContext ctx);
}
internal class SecurityCodeScan.Analyzers.DeprecationAnalyzer : object {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Rule;
    private static DeprecationAnalyzer();
    public void OnCompilationAction(CompilationAnalysisContext ctx);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.HtmlValidateRequestAnalyzer : SecurityAnalyzer {
    public static DiagnosticDescriptor RuleValidateRequest;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static Regex Regex;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static HtmlValidateRequestAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationAction(CompilationAnalysisContext ctx);
    public sealed virtual void AnalyzeFile(AdditionalText file, CompilationAnalysisContext context);
}
internal interface SecurityCodeScan.Analyzers.IExternalFileAnalyzer {
    public abstract virtual void AnalyzeFile(AdditionalText file, CompilationAnalysisContext context);
}
internal class SecurityCodeScan.Analyzers.InsecureCookieAnalyzer : object {
    public static string DiagnosticIdSecure;
    private static DiagnosticDescriptor RuleSecure;
    public static string DiagnosticIdHttpOnly;
    private static DiagnosticDescriptor RuleHttpOnly;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InsecureCookieAnalyzer();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public void CheckState(ExecutionState state, Configuration configuration);
    private void CheckState(VariableState variableState, ExecutionState state, HashSet`1<VariableState> visited, Configuration configuration);
}
internal class SecurityCodeScan.Analyzers.InsecureCookieAnalyzerCSharp : TaintAnalyzerExtensionCSharp {
    private InsecureCookieAnalyzer Analyzer;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
}
internal class SecurityCodeScan.Analyzers.InsecureCookieAnalyzerVisualBasic : TaintAnalyzerExtensionVisualBasic {
    private InsecureCookieAnalyzer Analyzer;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
}
internal interface SecurityCodeScan.Analyzers.ISecurityAnalysisContext {
    public abstract virtual void RegisterCompilationStartAction(Action`2<CompilationStartAnalysisContext, Configuration> action);
    public abstract virtual void RegisterCompilationAction(Action`1<CompilationAnalysisContext> action);
    public abstract virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, SymbolKind kind);
}
internal class SecurityCodeScan.Analyzers.Locale.LocaleUtil : object {
    private static Lazy`1<YamlResourceManager> ResourceManagerCached;
    private static YamlResourceManager ResourceManager { get; }
    private static LocaleUtil();
    private static YamlResourceManager get_ResourceManager();
    public static DiagnosticDescriptor GetDescriptor(string id, string titleId, string descriptionId, DiagnosticSeverity severity, String[] args);
    public static DiagnosticDescriptor GetDescriptorByText(string id, string localTitle, string localDesc, DiagnosticSeverity severity, String[] args);
    public static IEnumerable`1<DiagnosticDescriptor> GetAllAvailableDescriptors();
    private static LocalizableString GetLocalString(string id);
}
internal class SecurityCodeScan.Analyzers.Locale.YamlResourceManager : ResourceManager {
    private static string MessagesFileName;
    private IDictionary`2<string, string> LocaleString;
    private List`1<string> _LocaleKeyIds;
    public IReadOnlyList`1<string> LocaleKeyIds { get; }
    public IReadOnlyList`1<string> get_LocaleKeyIds();
    private void Load();
    public string GetString(string name);
    public virtual string GetString(string name, CultureInfo culture);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.OutputCacheAnnotationAnalyzer : SecurityAnalyzer {
    public static string DiagnosticId;
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OutputCacheAnnotationAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(ISecurityAnalysisContext context);
    private bool HasOutputCacheAttribute(ISymbol symbol, Int32& duration, bool method);
    private void VisitClass(SymbolAnalysisContext ctx);
}
internal abstract class SecurityCodeScan.Analyzers.RequestValidationAnalyzer : SecurityAnalyzer {
    private static DiagnosticDescriptor Rule;
    private static DiagnosticDescriptor InheritanceRule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RequestValidationAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(ISecurityAnalysisContext context);
    protected void CheckAllowHtml(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    protected void CheckUnvalidated(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    protected void CheckValidateInput(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    protected void CheckValidateInputInheritance(SymbolAnalysisContext ctx);
    private Nullable`1<bool> GetValidateInputAttributeParameterValue(ISymbol symbol);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.RequestValidationAnalyzerCSharp : RequestValidationAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_1(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_2(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_3(SyntaxNodeAnalysisContext ctx);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.RequestValidationAnalyzerVisualBasic : RequestValidationAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_1(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_2(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_3(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_4(SyntaxNodeAnalysisContext ctx);
}
internal class SecurityCodeScan.Analyzers.SecurityAnalysisContext : object {
    private CompilationAnalyzer FinalAnalyzer;
    private DeprecationAnalyzer DeprecationAnalyzer;
    private List`1<Action`2<CompilationStartAnalysisContext, Configuration>> OnCompilationStartActions;
    private Configuration ProjectConfiguration;
    private List`1<Action`1<CompilationAnalysisContext>> OnCompilationActions;
    private Dictionary`2<SymbolKind, List`1<Action`1<SymbolAnalysisContext>>> OnSymbolActions;
    public void Initialize(AnalysisContext analysisContext, IEnumerable`1<SecurityAnalyzer> workers);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context);
    public sealed virtual void RegisterCompilationStartAction(Action`2<CompilationStartAnalysisContext, Configuration> action);
    private void OnCompilationAction(CompilationAnalysisContext context);
    public sealed virtual void RegisterCompilationAction(Action`1<CompilationAnalysisContext> action);
    private void OnSymbolAction(SymbolAnalysisContext context);
    public sealed virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, SymbolKind kind);
}
internal abstract class SecurityCodeScan.Analyzers.SecurityAnalyzer : object {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public abstract virtual void Initialize(ISecurityAnalysisContext context);
    public abstract virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
[AttributeUsageAttribute("4")]
internal class SecurityCodeScan.Analyzers.SecurityAnalyzerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public String[] Languages { get; }
    public SecurityAnalyzerAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
internal enum SecurityCodeScan.Analyzers.Taint.ArgumentIndex : Enum {
    public int value__;
    public static ArgumentIndex Returns;
    public static ArgumentIndex This;
}
internal class SecurityCodeScan.Analyzers.Taint.Condition : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, object> <If>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, PostCondition> <Then>k__BackingField;
    public IReadOnlyDictionary`2<int, object> If { get; }
    public IReadOnlyDictionary`2<int, PostCondition> Then { get; }
    public Condition(IReadOnlyDictionary`2<int, object> if, IReadOnlyDictionary`2<int, PostCondition> then);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, object> get_If();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, PostCondition> get_Then();
}
internal class SecurityCodeScan.Analyzers.Taint.CSharpCodeEvaluation : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TaintAnalyzerExtensionCSharp> <Extensions>k__BackingField;
    private Configuration ProjectConfiguration;
    private SyntaxNodeHelper SyntaxNodeHelper;
    private IEnumerable`1<TaintAnalyzerExtensionCSharp> Extensions { get; }
    public CSharpCodeEvaluation(SyntaxNodeHelper syntaxHelper, Configuration projectConfiguration, IEnumerable`1<TaintAnalyzerExtensionCSharp> extensions);
    [CompilerGeneratedAttribute]
private IEnumerable`1<TaintAnalyzerExtensionCSharp> get_Extensions();
    public void VisitMethods(SyntaxNodeAnalysisContext ctx);
    private VariableState VisitBlock(BlockSyntax node, ExecutionState state);
    private VariableState VisitStatements(SyntaxList`1<StatementSyntax> statements, ExecutionState state, VariableState lastState);
    private void TaintParameters(BaseMethodDeclarationSyntax node, ExecutionState state);
    private VariableState VisitMethodDeclaration(BaseMethodDeclarationSyntax node, ExecutionState state);
    private VariableState VisitForEach(ForEachStatementSyntax node, ExecutionState state);
    private VariableState VisitNode(SyntaxNode node, ExecutionState state);
    private VariableState VisitPropertyDeclaration(PropertyDeclarationSyntax propertyDeclarationSyntax, ExecutionState state);
    private VariableState VisitFromClause(FromClauseSyntax fromClauseSyntax, ExecutionState state);
    private VariableState VisitSwitch(SwitchStatementSyntax switchStatementSyntax, ExecutionState state);
    private VariableState VisitIf(IfStatementSyntax ifStatementSyntax, ExecutionState state);
    private VariableState VisitLocalDeclaration(LocalDeclarationStatementSyntax declaration, ExecutionState state);
    private VariableState VisitVariableDeclaration(VariableDeclarationSyntax declaration, ExecutionState state);
    private string ResolveIdentifier(SyntaxToken syntaxToken);
    private VariableState VisitExpression(ExpressionSyntax expression, ExecutionState state);
    private VariableState VisitInterpolatedString(InterpolatedStringExpressionSyntax interpolatedString, ExecutionState state);
    private VariableState VisitElementAccess(ElementAccessExpressionSyntax elementAccess, BracketedArgumentListSyntax argumentList, ExecutionState state);
    private VariableState VisitExpressionStatement(ExpressionStatementSyntax node, ExecutionState state);
    private VariableState VisitMethodInvocation(InvocationExpressionSyntax node, ExecutionState state);
    private VariableState VisitObjectCreation(ObjectCreationExpressionSyntax node, ExecutionState state);
    private VariableState VisitArrayCreation(SyntaxNode node, InitializerExpressionSyntax arrayInit, ExecutionState state);
    private string GetMethodName(ExpressionSyntax node);
    private IReadOnlyDictionary`2<int, PostCondition> GetPostConditions(MethodBehavior behavior, bool isExtensionMethod, ArgumentListSyntax argList, ExecutionState state);
    private bool CheckPrecondition(IReadOnlyDictionary`2<int, object> condition, bool isExtensionMethod, ArgumentListSyntax argList, ExecutionState state);
    private Dictionary`2<int, VariableState> CreateArgStatesMapIfNeeded(ArgumentListSyntax argList, IMethodSymbol methodSymbol, IReadOnlyDictionary`2<int, PostCondition> postConditions);
    private VariableState CreateInitialReturnState(Nullable`1<VariableTaint> initialTaint, ISymbol symbol, ExpressionSyntax node, ArgumentListSyntax argList, MethodBehavior behavior);
    private VariableState VisitInvocationAndCreation(ExpressionSyntax node, ArgumentListSyntax argList, ExecutionState state, Nullable`1<VariableTaint> initialTaint, VariableState memberVariableState);
    private bool BehaviorApplies(IReadOnlyDictionary`2<object, object> condition, IMethodSymbol methodSymbol, Nullable`1<SeparatedSyntaxList`1<ArgumentSyntax>> args, ExecutionState state);
    private VariableState VisitAssignment(AssignmentExpressionSyntax node, ExecutionState state);
    private VariableState GetVariableState(ExpressionSyntax expression, ExecutionState state);
    private VariableState MergeVariableState(ExpressionSyntax expression, VariableState newVariableState, ExecutionState state, VariableState currentScope);
    private VariableState VisitIdentifierName(ExpressionSyntax expression, ExecutionState state);
    private VariableState VisitMemberAccessExpression(MemberAccessExpressionSyntax expression, ExecutionState state);
    private VariableState CheckIfTaintSource(ExpressionSyntax expression, ExecutionState state);
    private VariableState ResolveVariableState(ArrowExpressionClauseSyntax arrowExpressionClauseSyntax, ExpressionSyntax expression, SemanticModel possiblyOtherSemanticModel, HashSet`1& visited);
    private VariableState ResolveVariableState(ExpressionSyntax expression, ExecutionState state, SemanticModel semanticModel, HashSet`1<ExpressionSyntax> visited);
    private bool AllReturnConstant(ImmutableArray`1<SyntaxNode> exitPoints, SemanticModel semanticModel, HashSet`1<ExpressionSyntax> visited);
    private VariableState VisitBinaryExpression(ExpressionSyntax expression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, ExecutionState state);
    private bool IsSafeTypeAsString(ExecutionState state, ExpressionSyntax expression);
}
internal class SecurityCodeScan.Analyzers.Taint.ExecutionState : object {
    [CompilerGeneratedAttribute]
private SyntaxNodeAnalysisContext <AnalysisContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, VariableState> <Variables>k__BackingField;
    private Lazy`1<INamedTypeSymbol> ObjectTypeCached;
    private Lazy`1<INamedTypeSymbol> StringTypeCached;
    public SyntaxNodeAnalysisContext AnalysisContext { get; private set; }
    public IReadOnlyDictionary`2<string, VariableState> VariableStates { get; }
    private Dictionary`2<string, VariableState> Variables { get; private set; }
    public INamedTypeSymbol ObjectType { get; }
    public INamedTypeSymbol StringType { get; }
    public ExecutionState(SyntaxNodeAnalysisContext ctx);
    public ExecutionState(ExecutionState other);
    [CompilerGeneratedAttribute]
public SyntaxNodeAnalysisContext get_AnalysisContext();
    [CompilerGeneratedAttribute]
private void set_AnalysisContext(SyntaxNodeAnalysisContext value);
    public IReadOnlyDictionary`2<string, VariableState> get_VariableStates();
    [CompilerGeneratedAttribute]
private Dictionary`2<string, VariableState> get_Variables();
    [CompilerGeneratedAttribute]
private void set_Variables(Dictionary`2<string, VariableState> value);
    public INamedTypeSymbol get_ObjectType();
    public INamedTypeSymbol get_StringType();
    private void CollectVariableStates(Dictionary`2<VariableState, VariableState> otherVariableStateToNew, VariableState other);
    private void MergeCachedTypes(ExecutionState state);
    public void Replace(ExecutionState other);
    public void Merge(ExecutionState other);
    public void AddNewValue(string identifier, VariableState value);
    public void AddOrUpdateValue(string identifier, VariableState value);
    public ISymbol GetSymbol(SyntaxNode node);
}
internal class SecurityCodeScan.Analyzers.Taint.InjectableArgument : object {
    public bool Not;
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <RequiredTaintBits>k__BackingField;
    public string Locale { get; }
    public ulong RequiredTaintBits { get; }
    public InjectableArgument(ulong taint, string locale, bool not);
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public ulong get_RequiredTaintBits();
}
internal class SecurityCodeScan.Analyzers.Taint.MethodBehavior : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<object, object> <AppliesUnderCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, InjectableArgument> <InjectableArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Condition> <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, PostCondition> <PostConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private InjectableArgument <InjectableField>k__BackingField;
    private InjectableArgument NotInjectableArgument;
    public IReadOnlyDictionary`2<object, object> AppliesUnderCondition { get; }
    public IReadOnlyDictionary`2<int, InjectableArgument> InjectableArguments { get; }
    public IReadOnlyList`1<Condition> Conditions { get; }
    public IReadOnlyDictionary`2<int, PostCondition> PostConditions { get; }
    public InjectableArgument InjectableField { get; }
    public MethodBehavior(IReadOnlyDictionary`2<object, object> appliesUnderCondition, IReadOnlyList`1<Condition> preConditions, IReadOnlyDictionary`2<int, PostCondition> postConditions, IReadOnlyDictionary`2<int, InjectableArgument> injectableArguments, InjectableArgument injectableField);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<object, object> get_AppliesUnderCondition();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, InjectableArgument> get_InjectableArguments();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Condition> get_Conditions();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, PostCondition> get_PostConditions();
    [CompilerGeneratedAttribute]
public InjectableArgument get_InjectableField();
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Taint.MethodBehaviorHelper : object {
    private static string VbIndexerName;
    private static string CsIndexerName;
    private static SymbolDisplayFormat MethodFormat;
    private static MethodBehaviorHelper();
    public static string GetMethodBehaviorKey(string nameSpace, string className, string name, string argTypes);
    [ExtensionAttribute]
public static bool IsTaintEntryPoint(ISymbol symbol, ReadOnlyHashSet`1<string> entryPoints);
    [ExtensionAttribute]
public static bool IsTaintType(ITypeSymbol symbol, IReadOnlyDictionary`2<string, MethodBehavior> behaviors);
    [ExtensionAttribute]
public static MethodBehavior GetMethodBehavior(ISymbol symbol, IReadOnlyDictionary`2<string, MethodBehavior> behaviors);
    private static string ExtractGenericParameterSignature(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static string <GetMethodBehavior>g__GetNameSpaceWithClass|5_0(<>c__DisplayClass5_0& );
}
internal class SecurityCodeScan.Analyzers.Taint.PostCondition : object {
    [CompilerGeneratedAttribute]
private ulong <Taint>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<int> <TaintFromArguments>k__BackingField;
    public ulong Taint { get; }
    public ImmutableHashSet`1<int> TaintFromArguments { get; }
    public PostCondition(ulong taint, ImmutableHashSet`1<int> taintFromArguments);
    [CompilerGeneratedAttribute]
public ulong get_Taint();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<int> get_TaintFromArguments();
}
internal abstract class SecurityCodeScan.Analyzers.Taint.TaintAnalyzer`1 : SecurityAnalyzer {
    protected IEnumerable`1<T> Extensions;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected TaintAnalyzer`1(IEnumerable`1<T> extensions);
    protected TaintAnalyzer`1(T extension);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.Taint.TaintAnalyzerCSharp : TaintAnalyzer`1<TaintAnalyzerExtensionCSharp> {
    public TaintAnalyzerCSharp(TaintAnalyzerExtensionCSharp extension);
    public TaintAnalyzerCSharp(TaintAnalyzerExtensionCSharp[] extensions);
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
internal abstract class SecurityCodeScan.Analyzers.Taint.TaintAnalyzerExtension : object {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public abstract virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
internal abstract class SecurityCodeScan.Analyzers.Taint.TaintAnalyzerExtensionCSharp : TaintAnalyzerExtension {
    public virtual void VisitBegin(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitStatement(StatementSyntax node, ExecutionState state, VariableState statementState, Configuration projectConfiguration);
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node, ExecutionState state, VariableState statementState, Configuration projectConfiguration);
    public virtual void VisitInvocationAndCreation(ExpressionSyntax node, ArgumentListSyntax argList, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitAssignment(AssignmentExpressionSyntax node, ExecutionState state, MethodBehavior behavior, ISymbol symbol, VariableState variableRightState, Configuration projectConfiguration);
}
internal abstract class SecurityCodeScan.Analyzers.Taint.TaintAnalyzerExtensionVisualBasic : TaintAnalyzerExtension {
    public virtual void VisitBegin(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitStatement(StatementSyntax node, ExecutionState state, VariableState statementState, Configuration projectConfiguration);
    public virtual void VisitInvocationAndCreation(ExpressionSyntax node, ArgumentListSyntax argList, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitAssignment(VisualBasicSyntaxNode node, ExecutionState state, MethodBehavior behavior, ISymbol symbol, VariableState variableRightState, Configuration projectConfiguration);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.Taint.TaintAnalyzerVisualBasic : TaintAnalyzer`1<TaintAnalyzerExtensionVisualBasic> {
    public TaintAnalyzerVisualBasic(TaintAnalyzerExtensionVisualBasic extension);
    public TaintAnalyzerVisualBasic(TaintAnalyzerExtensionVisualBasic[] extensions);
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
internal class SecurityCodeScan.Analyzers.Taint.VariableState : object {
    [CompilerGeneratedAttribute]
private VariableTaint <Taint>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, VariableState> <Properties>k__BackingField;
    public VariableTaint Taint { get; private set; }
    public object Value { get; private set; }
    public SyntaxNode Node { get; private set; }
    public IReadOnlyDictionary`2<string, VariableState> PropertyStates { get; }
    private Dictionary`2<string, VariableState> Properties { get; private set; }
    public VariableState(SyntaxNode node, VariableTaint taint, object value);
    [CompilerGeneratedAttribute]
public VariableTaint get_Taint();
    [CompilerGeneratedAttribute]
private void set_Taint(VariableTaint value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(SyntaxNode value);
    public IReadOnlyDictionary`2<string, VariableState> get_PropertyStates();
    [CompilerGeneratedAttribute]
private Dictionary`2<string, VariableState> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, VariableState> value);
    public static void Merge(Queue`1<KeyValuePair`2<VariableState, VariableState>> queue, Dictionary`2<VariableState, VariableState> otherToSelf);
    public void ApplyTaint(ulong newTaint);
    public void MergeTaint(VariableTaint newTaint, object value);
    public void Replace(VariableState secondState);
    public void AddOrMergeProperty(string identifier, VariableState secondState);
    public void AddProperty(string identifier, VariableState secondState);
}
[FlagsAttribute]
internal enum SecurityCodeScan.Analyzers.Taint.VariableTaint : Enum {
    public ulong value__;
    public static VariableTaint Unset;
    public static VariableTaint Unknown;
    public static VariableTaint Tainted;
    public static VariableTaint Constant;
    public static VariableTaint Safe;
}
internal class SecurityCodeScan.Analyzers.Taint.VbCodeEvaluation : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TaintAnalyzerExtensionVisualBasic> <Extensions>k__BackingField;
    private Configuration ProjectConfiguration;
    private SyntaxNodeHelper SyntaxNodeHelper;
    private IEnumerable`1<TaintAnalyzerExtensionVisualBasic> Extensions { get; }
    public VbCodeEvaluation(SyntaxNodeHelper syntaxHelper, Configuration projectConfiguration, IEnumerable`1<TaintAnalyzerExtensionVisualBasic> extensions);
    [CompilerGeneratedAttribute]
private IEnumerable`1<TaintAnalyzerExtensionVisualBasic> get_Extensions();
    public void VisitMethods(SyntaxNodeAnalysisContext ctx);
    private VariableState VisitBlock(MethodBlockBaseSyntax node, ExecutionState state);
    private VariableState VisitStatements(SyntaxList`1<StatementSyntax> statements, ExecutionState state, VariableState lastState);
    private void TaintParameters(MethodBlockBaseSyntax node, ParameterListSyntax parameterList, ExecutionState state);
    private VariableState VisitMethodDeclaration(MethodBlockBaseSyntax node, ParameterListSyntax parameterList, ExecutionState state);
    private VariableState VisitForEach(ForEachStatementSyntax node, ExecutionState state);
    private VariableState VisitNode(SyntaxNode node, ExecutionState state);
    private VariableState VisitSelectClause(SelectClauseSyntax selectClauseSyntax, ExecutionState state);
    private VariableState VisitFromClause(FromClauseSyntax fromClauseSyntax, ExecutionState state);
    private VariableState VisitPropertyBlock(PropertyBlockSyntax propertyBlockSyntax, ExecutionState state);
    private VariableState VisitAssignmentStatement(AssignmentStatementSyntax assignment, ExecutionState state);
    private VariableState VisitCollectionRangeVariable(CollectionRangeVariableSyntax collectionRangeVariableSyntax, ExecutionState state);
    private VariableState VisitSelectBlock(SelectBlockSyntax selectBlockSyntax, ExecutionState state);
    private VariableState VisitSingleLineIfStatement(SingleLineIfStatementSyntax singleLineIfStatementSyntax, ExecutionState state);
    private VariableState VisitMultiLineIfBlock(MultiLineIfBlockSyntax multiLineIfBlockSyntax, ExecutionState state);
    private VariableState VisitLocalDeclaration(LocalDeclarationStatementSyntax declaration, ExecutionState state);
    private VariableState VisitVariableDeclaration(VariableDeclaratorSyntax declaration, ExecutionState state);
    private VariableState VisitExpression(ExpressionSyntax expression, ExecutionState state);
    private VariableState VisitInterpolatedString(InterpolatedStringExpressionSyntax interpolatedString, ExecutionState state);
    private VariableState VisitMethodInvocation(InvocationExpressionSyntax node, ExecutionState state);
    private string GetMethodName(ExpressionSyntax node);
    private IReadOnlyDictionary`2<int, PostCondition> GetPostConditions(MethodBehavior behavior, bool isExtensionMethod, ArgumentListSyntax argList, ExecutionState state);
    private bool CheckPrecondition(IReadOnlyDictionary`2<int, object> condition, bool isExtensionMethod, ArgumentListSyntax argList, ExecutionState state);
    private Dictionary`2<int, VariableState> CreateArgStatesMapIfNeeded(ArgumentListSyntax argList, IMethodSymbol methodSymbol, IReadOnlyDictionary`2<int, PostCondition> postConditions);
    private VariableState CreateInitialReturnState(Nullable`1<VariableTaint> initialTaint, ISymbol symbol, ExpressionSyntax node, ArgumentListSyntax argList, MethodBehavior behavior);
    private VariableState VisitInvocationAndCreation(ExpressionSyntax node, ArgumentListSyntax argList, ExecutionState state, Nullable`1<VariableTaint> initialTaint, VariableState memberVariableState);
    private bool BehaviorApplies(IReadOnlyDictionary`2<object, object> condition, IMethodSymbol methodSymbol, Nullable`1<SeparatedSyntaxList`1<ArgumentSyntax>> args, ExecutionState state);
    private VariableState VisitNamedFieldInitializer(NamedFieldInitializerSyntax node, ExecutionState state, VariableState currentScope);
    private VariableState VisitAssignment(VisualBasicSyntaxNode node, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, ExecutionState state);
    private VariableState VisitObjectCreation(ObjectCreationExpressionSyntax node, ExecutionState state);
    private VariableState VisitBinaryExpression(ExpressionSyntax expression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, ExecutionState state);
    private VariableState VisitIdentifierName(ExpressionSyntax expression, ExecutionState state);
    private VariableState VisitMemberAccessExpression(MemberAccessExpressionSyntax expression, ExecutionState state);
    private VariableState CheckIfTaintSource(ExpressionSyntax expression, ExecutionState state);
    private VariableState ResolveVariableState(ExpressionSyntax expression, ExecutionState state, SemanticModel semanticModel, HashSet`1<ExpressionSyntax> visited);
    private bool AllReturnConstant(ImmutableArray`1<SyntaxNode> exitPoints, SemanticModel semanticModel, HashSet`1<ExpressionSyntax> visited);
    private VariableState VisitExpressionStatement(ExpressionStatementSyntax node, ExecutionState state);
    private VariableState VisitArrayCreation(SyntaxNode node, CollectionInitializerSyntax arrayInit, ExecutionState state);
    private VariableState GetVariableState(ExpressionSyntax expression, ExecutionState state);
    private VariableState MergeVariableState(ExpressionSyntax expression, VariableState newVariableState, ExecutionState state, VariableState currentScope);
    private string ResolveIdentifier(SyntaxToken syntaxToken);
    private bool IsSafeTypeAsString(ExecutionState state, ExpressionSyntax expression);
}
internal abstract class SecurityCodeScan.Analyzers.UnknownPasswordApiAnalyzer : SecurityAnalyzer {
    public static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private Configuration Config;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnknownPasswordApiAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected void OnCompilationStartAction(Configuration config);
    private bool IsPasswordField(string name, ImmutableArray`1<AdditionalText> additionalTexts);
    protected void VisitAssignment(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.UnknownPasswordApiAnalyzerCSharp : UnknownPasswordApiAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_1(SyntaxNodeAnalysisContext ctx);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.UnknownPasswordApiAnalyzerVisualBasic : UnknownPasswordApiAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_1(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_2(SyntaxNodeAnalysisContext ctx);
}
internal abstract class SecurityCodeScan.Analyzers.UnsafeDeserializationAnalyzer : SecurityAnalyzer {
    private static DiagnosticDescriptor TypeNameHandlingRule;
    private static DiagnosticDescriptor JavaScriptSerializerRule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UnsafeDeserializationAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected void VisitAttributeArgument(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    protected void VisitAssignment(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    private void ReportIfTypeNameHandlingIsNotNone(SyntaxNodeAnalysisContext ctx, SyntaxNode expression);
    protected void VisitObjectCreation(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.UnsafeDeserializationAnalyzerCSharp : UnsafeDeserializationAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_1(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_2(SyntaxNodeAnalysisContext ctx);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.UnsafeDeserializationAnalyzerVisualBasic : UnsafeDeserializationAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_1(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_2(SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_3(SyntaxNodeAnalysisContext ctx);
}
internal class SecurityCodeScan.Analyzers.Utils.CodeFixUtil : object {
    public static SyntaxTriviaList KeepLastLine(SyntaxTriviaList leadingTrivia);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.CompilationExtensions : object {
    private static Nullable`1<bool> IsTypeDeclaredInExpectedAssembly(Compilation compilation, string typeName, string assemblyName);
    [ExtensionAttribute]
public static Version GetDotNetFrameworkVersion(Compilation compilation);
}
internal class SecurityCodeScan.Analyzers.Utils.CSharpSyntaxNodeHelper : SyntaxNodeHelper {
    [CompilerGeneratedAttribute]
private static CSharpSyntaxNodeHelper <Default>k__BackingField;
    public static CSharpSyntaxNodeHelper Default { get; }
    private static CSharpSyntaxNodeHelper();
    [CompilerGeneratedAttribute]
public static CSharpSyntaxNodeHelper get_Default();
    public virtual ITypeSymbol GetClassDeclarationTypeSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual SyntaxNode GetAssignmentLeftNode(SyntaxNode node);
    public virtual string GetAssignmentLeftNodeName(SyntaxNode node);
    public virtual SyntaxNode GetAssignmentRightNode(SyntaxNode node);
    public virtual SyntaxNode GetMemberAccessNameNode(SyntaxNode node);
    public virtual SyntaxNode GetMemberAccessExpressionNode(SyntaxNode node);
    public virtual SyntaxNode GetInvocationExpressionNode(SyntaxNode node);
    public virtual SyntaxNode GetDefaultValueForAnOptionalParameter(SyntaxNode declNode, int paramIndex);
    public virtual SyntaxNode GetAttributeArgumentExpressionNode(SyntaxNode node);
    protected virtual IEnumerable`1<SyntaxNode> GetCallArgumentExpressionNodes(SyntaxNode node, CallKind callKind);
    public virtual IEnumerable`1<SyntaxNode> GetObjectInitializerExpressionNodes(SyntaxNode node);
    public virtual bool IsMethodInvocationNode(SyntaxNode node);
    public virtual bool IsSimpleMemberAccessExpressionNode(SyntaxNode node);
    public virtual bool IsObjectCreationExpressionNode(SyntaxNode node);
    public virtual IMethodSymbol GetCalleeMethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual IMethodSymbol GetCallerMethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual ITypeSymbol GetEnclosingTypeSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual IEnumerable`1<SyntaxNode> GetDescendantAssignmentExpressionNodes(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> GetDescendantMemberAccessExpressionNodes(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> GetDeclarationAttributeNodes(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> GetAttributeArgumentNodes(SyntaxNode node);
    public virtual bool IsObjectCreationExpressionUnderFieldDeclaration(SyntaxNode node);
    public virtual SyntaxNode GetVariableDeclaratorOfAFieldDeclarationNode(SyntaxNode node);
    public virtual bool IsObjectConstructionForTemporaryObject(SyntaxNode node);
    public virtual bool IsAttributeArgument(SyntaxNode node);
    public virtual SyntaxNode GetAttributeArgumentNode(SyntaxNode node);
}
internal static class SecurityCodeScan.Analyzers.Utils.EmptyArray`1 : object {
    public static T[] Value;
    private static EmptyArray`1();
}
internal static class SecurityCodeScan.Analyzers.Utils.EmptyDictionary`2 : object {
    public static IReadOnlyDictionary`2<TKey, TVal> Value;
    private static EmptyDictionary`2();
}
internal static class SecurityCodeScan.Analyzers.Utils.EmptyList`1 : object {
    public static IReadOnlyList`1<T> Value;
    private static EmptyList`1();
}
internal static class SecurityCodeScan.Analyzers.Utils.ExternalDiagnostic : object {
    public static Diagnostic Create(DiagnosticDescriptor descriptor, string path, int line, string source);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.IntExtensions : object {
    [ExtensionAttribute]
public static string ToNthString(int i);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.IReadOnlyDictionaryExtensions : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(IReadOnlyDictionary`2<TKey, TValue> readOnlyDictionary, IEqualityComparer`1<TKey> comparer);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.ISymbolExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> FindArgumentIndex(IMethodSymbol method, int sourceIndex, ArgumentSyntax arg);
    [ExtensionAttribute]
public static Nullable`1<int> FindArgumentIndex(IMethodSymbol method, int sourceIndex, ArgumentSyntax arg);
    [ExtensionAttribute]
public static Nullable`1<int> FindArgumentIndexByName(IMethodSymbol method, string argName);
    [ExtensionAttribute]
public static bool IsType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAccessorMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPublic(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static bool MatchMemberDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMemberByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldByName(ISymbol member, INamedTypeSymbol type, string name);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsPrimitiveType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool Inherits(ITypeSymbol type, ITypeSymbol possibleBase);
    [IteratorStateMachineAttribute("SecurityCodeScan.Analyzers.Utils.ITypeSymbolExtensions/<GetBaseTypes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type);
    [IteratorStateMachineAttribute("SecurityCodeScan.Analyzers.Utils.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol symbol, INamedTypeSymbol candidateBaseType, bool baseTypesOnly);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableAttributes(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
}
internal class SecurityCodeScan.Analyzers.Utils.Logger : object {
    [CompilerGeneratedAttribute]
private static Action`1<string> <LoggerHandler>k__BackingField;
    public static Action`1<string> LoggerHandler { get; public set; }
    [CompilerGeneratedAttribute]
public static Action`1<string> get_LoggerHandler();
    [CompilerGeneratedAttribute]
public static void set_LoggerHandler(Action`1<string> value);
    public static bool IsConfigured();
    public static void Log(string message, bool includeCallerInfo, string memberName, string sourceFilePath, int sourceLineNumber);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.ObjectExtensions : object {
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TBaseType, TResult> defaultFunc);
}
internal class SecurityCodeScan.Analyzers.Utils.ReadOnlyHashSet`1 : object {
    private HashSet`1<T> Set;
    public int Count { get; }
    public ReadOnlyHashSet`1(HashSet`1<T> set);
    public bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.SymbolExtensions : object {
    private static SymbolDisplayFormat SymbolDisplayFormat;
    private static SymbolExtensions();
    [ExtensionAttribute]
public static bool IsType(ISymbol symbol, string type);
    [ExtensionAttribute]
public static string GetTypeName(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsTypeOrDerivedFrom(ITypeSymbol symbol, IEnumerable`1<string> types);
    [ExtensionAttribute]
public static bool IsTypeOrDerivedFrom(ITypeSymbol symbol, IEnumerable`1<string> types, String& foundType);
    [ExtensionAttribute]
public static bool IsDerivedFrom(ITypeSymbol symbol, string type);
    [ExtensionAttribute]
public static bool IsDerivedFrom(ITypeSymbol symbol, IEnumerable`1<string> types);
    [ExtensionAttribute]
public static bool IsDerivedFrom(ITypeSymbol symbol, IEnumerable`1<string> types, String& foundType);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, Func`2<AttributeData, bool> condition);
    [ExtensionAttribute]
public static AttributeData GetAttribute(ISymbol symbol, Func`2<AttributeData, bool> condition);
    [ExtensionAttribute]
public static bool HasDerivedClassAttribute(ITypeSymbol symbol, Func`2<AttributeData, bool> condition);
    [ExtensionAttribute]
public static bool HasDerivedMethodAttribute(IMethodSymbol symbol, Func`2<AttributeData, bool> condition);
}
internal enum SecurityCodeScan.Analyzers.Utils.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
}
internal abstract class SecurityCodeScan.Analyzers.Utils.SyntaxNodeHelper : object {
    public abstract virtual IMethodSymbol GetCallerMethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    public abstract virtual ITypeSymbol GetEnclosingTypeSymbol(SyntaxNode node, SemanticModel semanticModel);
    public abstract virtual ITypeSymbol GetClassDeclarationTypeSymbol(SyntaxNode node, SemanticModel semanticModel);
    public abstract virtual SyntaxNode GetAssignmentLeftNode(SyntaxNode node);
    public abstract virtual string GetAssignmentLeftNodeName(SyntaxNode node);
    public abstract virtual SyntaxNode GetAssignmentRightNode(SyntaxNode node);
    public abstract virtual SyntaxNode GetMemberAccessNameNode(SyntaxNode node);
    public abstract virtual SyntaxNode GetMemberAccessExpressionNode(SyntaxNode node);
    public abstract virtual SyntaxNode GetInvocationExpressionNode(SyntaxNode node);
    public abstract virtual SyntaxNode GetDefaultValueForAnOptionalParameter(SyntaxNode declNode, int paramIndex);
    public abstract virtual SyntaxNode GetAttributeArgumentExpressionNode(SyntaxNode node);
    public abstract virtual IEnumerable`1<SyntaxNode> GetObjectInitializerExpressionNodes(SyntaxNode node);
    public abstract virtual bool IsMethodInvocationNode(SyntaxNode node);
    public abstract virtual bool IsSimpleMemberAccessExpressionNode(SyntaxNode node);
    public abstract virtual bool IsObjectCreationExpressionNode(SyntaxNode node);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetCallArgumentExpressionNodes(SyntaxNode node, CallKind callKind);
    public abstract virtual IEnumerable`1<SyntaxNode> GetDescendantAssignmentExpressionNodes(SyntaxNode node);
    public abstract virtual IEnumerable`1<SyntaxNode> GetDescendantMemberAccessExpressionNodes(SyntaxNode node);
    public abstract virtual IEnumerable`1<SyntaxNode> GetDeclarationAttributeNodes(SyntaxNode node);
    public abstract virtual IEnumerable`1<SyntaxNode> GetAttributeArgumentNodes(SyntaxNode node);
    public abstract virtual bool IsAttributeArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetAttributeArgumentNode(SyntaxNode node);
    public abstract virtual bool IsObjectCreationExpressionUnderFieldDeclaration(SyntaxNode node);
    public abstract virtual SyntaxNode GetVariableDeclaratorOfAFieldDeclarationNode(SyntaxNode objectCreationExpression);
    public abstract virtual bool IsObjectConstructionForTemporaryObject(SyntaxNode node);
    public ISymbol GetEnclosingConstructSymbol(SyntaxNode node, SemanticModel semanticModel);
    public IEnumerable`1<SyntaxNode> GetCallArgumentExpressionNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetInvocationArgumentExpressionNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetObjectCreationArgumentExpressionNodes(SyntaxNode node);
    public abstract virtual IMethodSymbol GetCalleeMethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    [IteratorStateMachineAttribute("SecurityCodeScan.Analyzers.Utils.SyntaxNodeHelper/<GetCandidateCalleeMethodSymbols>d__31")]
public static IEnumerable`1<IMethodSymbol> GetCandidateCalleeMethodSymbols(SyntaxNode node, SemanticModel semanticModel);
    public IEnumerable`1<IMethodSymbol> GetCalleeMethodSymbols(SyntaxNode node, SemanticModel semanticModel);
    public static IPropertySymbol GetCalleePropertySymbol(SyntaxNode node, SemanticModel semanticModel);
    public static IFieldSymbol GetCalleeFieldSymbol(SyntaxNode node, SemanticModel semanticModel);
    public static ISymbol GetSymbol(SyntaxNode node, SemanticModel semanticModel);
    public static ISymbol GetDeclaredSymbol(SyntaxNode node, SemanticModel semanticModel);
    public static ISymbol GetReferencedSymbol(SyntaxNode node, SemanticModel semanticModel);
    public static IEnumerable`1<ISymbol> GetCandidateReferencedSymbols(SyntaxNode node, SemanticModel semanticModel);
    public static bool NodeHasConstantValueNull(SyntaxNode node, SemanticModel model);
    public static bool NodeHasConstantValue(SyntaxNode node, SemanticModel model, T expectedValue);
    public static ISymbol GetDeclaredOrReferencedSymbol(SyntaxNode node, SemanticModel model);
}
internal class SecurityCodeScan.Analyzers.Utils.VBSyntaxNodeHelper : SyntaxNodeHelper {
    [CompilerGeneratedAttribute]
private static VBSyntaxNodeHelper <Default>k__BackingField;
    public static VBSyntaxNodeHelper Default { get; }
    private static VBSyntaxNodeHelper();
    [CompilerGeneratedAttribute]
public static VBSyntaxNodeHelper get_Default();
    public virtual ITypeSymbol GetClassDeclarationTypeSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual SyntaxNode GetAssignmentLeftNode(SyntaxNode node);
    public virtual string GetAssignmentLeftNodeName(SyntaxNode node);
    public virtual SyntaxNode GetAssignmentRightNode(SyntaxNode node);
    public virtual SyntaxNode GetMemberAccessNameNode(SyntaxNode node);
    public virtual SyntaxNode GetMemberAccessExpressionNode(SyntaxNode node);
    public virtual SyntaxNode GetInvocationExpressionNode(SyntaxNode node);
    public virtual SyntaxNode GetAttributeArgumentExpressionNode(SyntaxNode node);
    public virtual SyntaxNode GetDefaultValueForAnOptionalParameter(SyntaxNode declNode, int paramIndex);
    protected virtual IEnumerable`1<SyntaxNode> GetCallArgumentExpressionNodes(SyntaxNode node, CallKind callKind);
    public virtual IEnumerable`1<SyntaxNode> GetObjectInitializerExpressionNodes(SyntaxNode node);
    public virtual bool IsMethodInvocationNode(SyntaxNode node);
    public virtual bool IsSimpleMemberAccessExpressionNode(SyntaxNode node);
    public virtual bool IsObjectCreationExpressionNode(SyntaxNode node);
    public virtual IMethodSymbol GetCalleeMethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual IMethodSymbol GetCallerMethodSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual ITypeSymbol GetEnclosingTypeSymbol(SyntaxNode node, SemanticModel semanticModel);
    public virtual IEnumerable`1<SyntaxNode> GetDescendantAssignmentExpressionNodes(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> GetDescendantMemberAccessExpressionNodes(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> GetDeclarationAttributeNodes(SyntaxNode node);
    public virtual IEnumerable`1<SyntaxNode> GetAttributeArgumentNodes(SyntaxNode node);
    public virtual bool IsObjectCreationExpressionUnderFieldDeclaration(SyntaxNode node);
    public virtual SyntaxNode GetVariableDeclaratorOfAFieldDeclarationNode(SyntaxNode objectCreationExpression);
    public virtual bool IsObjectConstructionForTemporaryObject(SyntaxNode node);
    public virtual bool IsAttributeArgument(SyntaxNode node);
    public virtual SyntaxNode GetAttributeArgumentNode(SyntaxNode node);
}
[ExtensionAttribute]
internal static class SecurityCodeScan.Analyzers.Utils.XElementExtensions : object {
    [ExtensionAttribute]
public static string ToStringStartElement(XElement e);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
public class SecurityCodeScan.Analyzers.VBasicAnalyzers : Analyzers {
    internal VBasicAnalyzers(SecurityAnalyzer[] analyzers);
    internal VBasicAnalyzers(SecurityAnalyzer analyzer);
    [CompilerGeneratedAttribute]
private List`1<SecurityAnalyzer> <.ctor>b__2_0();
}
internal abstract class SecurityCodeScan.Analyzers.WeakCertificateValidationAnalyzer : SecurityAnalyzer {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private Configuration Config;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WeakCertificateValidationAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual SyntaxNode GetBody(SyntaxNode rightNode, SyntaxNodeAnalysisContext ctx);
    protected void OnCompilationStartAction(Configuration config);
    protected void VisitSyntaxNode(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    private static bool IsMatch(ISymbol symbolMemberAccess);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakCertificateValidationAnalyzerCSharp : WeakCertificateValidationAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    protected virtual SyntaxNode GetBody(SyntaxNode rightNode, SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakCertificateValidationAnalyzerVisualBasic : WeakCertificateValidationAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    protected virtual SyntaxNode GetBody(SyntaxNode rightNode, SyntaxNodeAnalysisContext ctx);
    [CompilerGeneratedAttribute]
private void <OnCompilationStartAction>b__1_0(SyntaxNodeAnalysisContext ctx);
}
internal abstract class SecurityCodeScan.Analyzers.WeakCipherAnalyzer : SecurityAnalyzer {
    private static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<string> BadCipherCreate;
    private static ImmutableArray`1<string> BadCipherProvider;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WeakCipherAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static void VisitSyntaxNode(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakCipherAnalyzerCSharp : WeakCipherAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakCipherAnalyzerVisualBasic : WeakCipherAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
internal abstract class SecurityCodeScan.Analyzers.WeakCipherModeAnalyzer : SecurityAnalyzer {
    private static DiagnosticDescriptor RuleCBC;
    private static DiagnosticDescriptor RuleECB;
    private static DiagnosticDescriptor RuleGeneric;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WeakCipherModeAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static void VisitSyntaxNode(SyntaxNodeAnalysisContext ctx);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakCipherModeAnalyzerCSharp : WeakCipherModeAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakCipherModeAnalyzerVisualBasic : WeakCipherModeAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
internal abstract class SecurityCodeScan.Analyzers.WeakHashingAnalyzer : SecurityAnalyzer {
    public static DiagnosticDescriptor Md5Rule;
    public static DiagnosticDescriptor Sha1Rule;
    public static DiagnosticDescriptor UnknownHashRule;
    public static string Sha1TypeName;
    public static string Md5TypeName;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static String[] TypeNames;
    public static Dictionary`2<string, DiagnosticDescriptor> Rules;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WeakHashingAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakHashingAnalyzerCSharp : WeakHashingAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext ctx, Configuration config);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakHashingAnalyzerVisualBasic : WeakHashingAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext ctx, Configuration config);
}
internal class SecurityCodeScan.Analyzers.WeakHashingCompilationAnalyzer : object {
    private ConcurrentDictionary`2<Diagnostic, byte> Diagnostics;
    private Configuration Config;
    public WeakHashingCompilationAnalyzer(Configuration config);
    private void Report(Diagnostic diagnostic, SyntaxNodeAnalysisContext ctx);
    public void VisitObjectCreationSyntaxNode(SyntaxNodeAnalysisContext ctx);
    private bool CheckSymbol(ITypeSymbol symbol, SyntaxNodeAnalysisContext ctx);
    public void VisitMemberAccessSyntaxNode(SyntaxNodeAnalysisContext ctx);
    public void VisitInvocationSyntaxNode(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
    private DiagnosticDescriptor CheckParameter(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
}
internal class SecurityCodeScan.Analyzers.WeakHashingDiagnosticGroup : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticDescriptor <Rule>k__BackingField;
    public string TypeName { get; }
    public DiagnosticDescriptor Rule { get; }
    public WeakHashingDiagnosticGroup(string typeName, DiagnosticDescriptor rule);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public DiagnosticDescriptor get_Rule();
}
internal class SecurityCodeScan.Analyzers.WeakPasswordValidatorPropertyAnalyzer : object {
    private static DiagnosticDescriptor RulePasswordLength;
    private static DiagnosticDescriptor RulePasswordValidators;
    private static DiagnosticDescriptor RuleRequiredPasswordValidators;
    private static String[] BoolPropertyNames;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WeakPasswordValidatorPropertyAnalyzer();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public void CheckState(ExecutionState state, Configuration configuration);
    private void CheckState(VariableState variableState, ExecutionState state, HashSet`1<VariableState> visited, Configuration configuration);
}
internal class SecurityCodeScan.Analyzers.WeakPasswordValidatorPropertyAnalyzerCSharp : TaintAnalyzerExtensionCSharp {
    private WeakPasswordValidatorPropertyAnalyzer Analyzer;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration configuration);
}
internal class SecurityCodeScan.Analyzers.WeakPasswordValidatorPropertyAnalyzerVisualBasic : TaintAnalyzerExtensionVisualBasic {
    private WeakPasswordValidatorPropertyAnalyzer Analyzer;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration configuration);
}
internal abstract class SecurityCodeScan.Analyzers.WeakRandomAnalyzer : SecurityAnalyzer {
    private static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WeakRandomAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static void VisitSyntaxNode(SyntaxNodeAnalysisContext ctx, SyntaxNodeHelper nodeHelper);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakRandomAnalyzerCSharp : WeakRandomAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WeakRandomAnalyzerVisualBasic : WeakRandomAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.WebConfigAnalyzer : SecurityAnalyzer {
    public static DiagnosticDescriptor RuleValidateRequest;
    public static DiagnosticDescriptor RuleRequestValidationMode;
    public static DiagnosticDescriptor RuleEnableEventValidation;
    public static DiagnosticDescriptor RuleViewStateEncryptionMode;
    public static DiagnosticDescriptor RuleEnableViewStateMac;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private Configuration Config;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WebConfigAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
    private void OnCompilationAction(CompilationAnalysisContext ctx);
    private string CheckAttribute(XElement element, string attributeName, string defaultValue, Func`2<string, bool> isGoodValue, DiagnosticDescriptor diagnosticDescriptor, XElement lastFoundElement, AdditionalText file, CompilationAnalysisContext context);
    private void CheckMainConfigAndLocations(string attribute, string defaultValue, Func`2<string, bool> isGoodValue, DiagnosticDescriptor diagnosticDescriptor, XElement systemWeb, XElement lastFoundElement, string subElement, XDocument doc, AdditionalText file, CompilationAnalysisContext context);
    private XElement GetElement(XElement element, XElement& lastFoundElement, String[] elements);
    public sealed virtual void AnalyzeFile(AdditionalText file, CompilationAnalysisContext context);
}
internal static class SecurityCodeScan.Analyzers.XssPreventionAnalyzer : object {
    public static string DiagnosticId;
    public static DiagnosticDescriptor Rule;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public static ConcurrentDictionary`2<ExecutionState, ExecutionState> ExecutionStates;
    public static String[] ControllerNames;
    public static ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static XssPreventionAnalyzer();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public static void Check(SyntaxNode node, ExecutionState state, Configuration projectConfiguration, IEnumerable`1<SyntaxNode> returnStatements, bool performDataFlowAnalysis);
}
internal class SecurityCodeScan.Analyzers.XssPreventionAnalyzerCSharp : TaintAnalyzerExtensionCSharp {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void VisitBegin(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitStatement(StatementSyntax node, ExecutionState state, VariableState statementState, Configuration projectConfiguration);
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node, ExecutionState state, VariableState statementState, Configuration projectConfiguration);
}
internal class SecurityCodeScan.Analyzers.XssPreventionAnalyzerVisualBasic : TaintAnalyzerExtensionVisualBasic {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void VisitBegin(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitEnd(SyntaxNode node, ExecutionState state, Configuration projectConfiguration);
    public virtual void VisitStatement(StatementSyntax node, ExecutionState state, VariableState statementState, Configuration projectConfiguration);
}
internal class SecurityCodeScan.Analyzers.XxeAnalyzer : object {
    private XxeSecurityTypes XmlTypes;
    private bool AreDefaultsSecure;
    private SyntaxNodeHelper SyntaxNodeHelper;
    private HashSet`1<SyntaxNode> OjectCreationOperationsAnalyzed;
    private Dictionary`2<ISymbol, XmlDocumentEnvironment> XmlDocumentEnvironments;
    private Dictionary`2<SyntaxNode, XmlDocumentEnvironment> TempXmlDocumentEnvironments;
    private Dictionary`2<ISymbol, XmlTextReaderEnvironment> XmlTextReaderEnvironments;
    private Dictionary`2<SyntaxNode, XmlTextReaderEnvironment> TempXmlTextReaderEnvironments;
    private Dictionary`2<ISymbol, XmlReaderSettingsEnvironment> XmlReaderSettingsEnvironments;
    private Dictionary`2<SyntaxNode, XmlReaderSettingsEnvironment> TempXmlReaderSettingsEnvironments;
    protected XxeAnalyzer(XxeSecurityTypes xmlTypes, SyntaxNodeHelper helper, Version frameworkVersion);
    public void AnalyzeCodeBlockEnd(CodeBlockAnalysisContext context);
    protected void AnalyzeAssignment(SyntaxNode node, SemanticModel model, Action`1<Diagnostic> reportDiagnostic);
    protected void AnalyzeVariableDeclaration(SyntaxNode node, SemanticModel model, Action`1<Diagnostic> reportDiagnostic);
    private T GetEnvironment(ISymbol symbol, SyntaxNode node, Dictionary`2<ISymbol, T> permanentEnvironments, Dictionary`2<SyntaxNode, T> temporaryEnvironments);
    private void AnalyzePropertyAssignment(IPropertySymbol symbol, SyntaxNode lhs, SyntaxNode rhs, SemanticModel model);
    protected void AnalyzeObjectCreation(ISymbol variableSymbol, SyntaxNode objectCreationNode, SemanticModel model, Action`1<Diagnostic> reportDiagnostic);
    private XmlDocumentEnvironment AnalyzeObjectCreationForXmlDocument(ISymbol symbol, SyntaxNode node, SemanticModel model);
    private XmlReaderSettingsEnvironment AnalyzeObjectCreationForXmlReaderSettings(SyntaxNode node, SemanticModel model);
    private XmlTextReaderEnvironment AnalyzeObjectCreationForXmlTextReader(IMethodSymbol symbol, SyntaxNode node, SemanticModel model);
    protected void AnalyzeInvocation(SyntaxNode node, SemanticModel model, Action`1<Diagnostic> reportDiagnostic);
}
internal class SecurityCodeScan.Analyzers.XxeAnalyzerCSharp : XxeAnalyzer {
    public XxeAnalyzerCSharp(XxeSecurityTypes xmlTypes, Version frameworkVersion);
    public void RegisterSyntaxNodeAction(CodeBlockStartAnalysisContext`1<SyntaxKind> c);
    private void VisitSyntaxNode(SyntaxNodeAnalysisContext ctx);
}
internal class SecurityCodeScan.Analyzers.XxeAnalyzerVBasic : XxeAnalyzer {
    public XxeAnalyzerVBasic(XxeSecurityTypes xmlTypes, Version frameworkVersion);
    public void RegisterSyntaxNodeAction(CodeBlockStartAnalysisContext`1<SyntaxKind> c);
    private void VisitSyntaxNode(SyntaxNodeAnalysisContext ctx);
}
internal abstract class SecurityCodeScan.Analyzers.XxeDiagnosticAnalyzer : SecurityAnalyzer {
    internal static DiagnosticDescriptor Rule;
    private static ImmutableArray`1<DiagnosticDescriptor> Rules;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static XxeDiagnosticAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
[SecurityAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.XxeDiagnosticAnalyzerCSharp : XxeDiagnosticAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
[SecurityAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class SecurityCodeScan.Analyzers.XxeDiagnosticAnalyzerVisualBasic : XxeDiagnosticAnalyzer {
    public virtual void Initialize(ISecurityAnalysisContext context);
    private void OnCompilationStartAction(CompilationStartAnalysisContext context, Configuration config);
}
internal class SecurityCodeScan.Analyzers.XxeSecurityTypes : object {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlDataDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ConfigXmlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlFileInfoDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlTransformableDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XPathDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlTextReader>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlReader>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlReaderSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlSecureResolver>k__BackingField;
    public INamedTypeSymbol XmlDocument { get; }
    public INamedTypeSymbol XmlDataDocument { get; }
    public INamedTypeSymbol ConfigXmlDocument { get; }
    public INamedTypeSymbol XmlFileInfoDocument { get; }
    public INamedTypeSymbol XmlTransformableDocument { get; }
    public INamedTypeSymbol XPathDocument { get; }
    public INamedTypeSymbol XmlSchema { get; }
    public INamedTypeSymbol XmlTextReader { get; }
    public INamedTypeSymbol XmlReader { get; }
    public INamedTypeSymbol XmlReaderSettings { get; }
    public INamedTypeSymbol XmlSecureResolver { get; }
    public XxeSecurityTypes(Compilation compilation);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlDocument();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlDataDocument();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ConfigXmlDocument();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlFileInfoDocument();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlTransformableDocument();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XPathDocument();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlSchema();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlTextReader();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlReader();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlReaderSettings();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlSecureResolver();
    public bool IsAnyTypeReferenced();
}
internal class SecurityCodeScan.Config.ConditionData : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<object, object> <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, object> <Then>k__BackingField;
    public Dictionary`2<object, object> Condition { get; public set; }
    public Dictionary`2<object, object> Then { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<object, object> get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(Dictionary`2<object, object> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, object> get_Then();
    [CompilerGeneratedAttribute]
public void set_Then(Dictionary`2<object, object> value);
}
internal class SecurityCodeScan.Config.ConfigData : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReportAnalysisCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AuditMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PasswordValidatorRequiredLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumPasswordValidatorProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PasswordValidatorRequiredProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Behavior>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, TaintEntryPointData> <TaintEntryPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CsrfProtectionData> <CsrfProtection>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <PasswordFields>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebConfigFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ConstantFields>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <TaintTypes>k__BackingField;
    public Nullable`1<bool> ReportAnalysisCompletion { get; public set; }
    public Nullable`1<bool> AuditMode { get; public set; }
    public Nullable`1<int> PasswordValidatorRequiredLength { get; public set; }
    public Nullable`1<int> MinimumPasswordValidatorProperties { get; public set; }
    public List`1<string> PasswordValidatorRequiredProperties { get; public set; }
    public Dictionary`2<string, object> Behavior { get; public set; }
    public Dictionary`2<string, TaintEntryPointData> TaintEntryPoints { get; public set; }
    public List`1<CsrfProtectionData> CsrfProtection { get; public set; }
    public List`1<string> PasswordFields { get; public set; }
    public string WebConfigFiles { get; public set; }
    public List`1<string> ConstantFields { get; public set; }
    public List`1<string> TaintTypes { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReportAnalysisCompletion();
    [CompilerGeneratedAttribute]
public void set_ReportAnalysisCompletion(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AuditMode();
    [CompilerGeneratedAttribute]
public void set_AuditMode(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PasswordValidatorRequiredLength();
    [CompilerGeneratedAttribute]
public void set_PasswordValidatorRequiredLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumPasswordValidatorProperties();
    [CompilerGeneratedAttribute]
public void set_MinimumPasswordValidatorProperties(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_PasswordValidatorRequiredProperties();
    [CompilerGeneratedAttribute]
public void set_PasswordValidatorRequiredProperties(List`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Behavior();
    [CompilerGeneratedAttribute]
public void set_Behavior(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, TaintEntryPointData> get_TaintEntryPoints();
    [CompilerGeneratedAttribute]
public void set_TaintEntryPoints(Dictionary`2<string, TaintEntryPointData> value);
    [CompilerGeneratedAttribute]
public List`1<CsrfProtectionData> get_CsrfProtection();
    [CompilerGeneratedAttribute]
public void set_CsrfProtection(List`1<CsrfProtectionData> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_PasswordFields();
    [CompilerGeneratedAttribute]
public void set_PasswordFields(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_WebConfigFiles();
    [CompilerGeneratedAttribute]
public void set_WebConfigFiles(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ConstantFields();
    [CompilerGeneratedAttribute]
public void set_ConstantFields(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_TaintTypes();
    [CompilerGeneratedAttribute]
public void set_TaintTypes(List`1<string> value);
}
internal class SecurityCodeScan.Config.Configuration : object {
    [CompilerGeneratedAttribute]
private bool <ReportAnalysisCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AuditMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PasswordValidatorRequiredLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumPasswordValidatorProperties>k__BackingField;
    private HashSet`1<string> _PasswordValidatorRequiredProperties;
    [CompilerGeneratedAttribute]
private ReadOnlyHashSet`1<string> <PasswordValidatorRequiredProperties>k__BackingField;
    private HashSet`1<string> _TaintEntryPoints;
    [CompilerGeneratedAttribute]
private ReadOnlyHashSet`1<string> <TaintEntryPoints>k__BackingField;
    private HashSet`1<string> _PasswordFields;
    [CompilerGeneratedAttribute]
private ReadOnlyHashSet`1<string> <PasswordFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <WebConfigFilesRegex>k__BackingField;
    private HashSet`1<string> _ConstantFields;
    [CompilerGeneratedAttribute]
private ReadOnlyHashSet`1<string> <ConstantFields>k__BackingField;
    private Dictionary`2<string, ulong> _TaintTypeNameToBit;
    private Dictionary`2<string, KeyValuePair`2<string, MethodBehavior>> ConfigurationBehavior;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, MethodBehavior> <Behavior>k__BackingField;
    private LinkedList`1<CsrfNamedGroup> _CsrfGroupsList;
    private Dictionary`2<string, LinkedListNode`1<CsrfNamedGroup>> _CsrfGroups;
    private Char[] Parenthesis;
    public bool ReportAnalysisCompletion { get; private set; }
    public bool AuditMode { get; private set; }
    public int PasswordValidatorRequiredLength { get; private set; }
    public int MinimumPasswordValidatorProperties { get; private set; }
    public ReadOnlyHashSet`1<string> PasswordValidatorRequiredProperties { get; }
    public ReadOnlyHashSet`1<string> TaintEntryPoints { get; }
    public ReadOnlyHashSet`1<string> PasswordFields { get; }
    public Regex WebConfigFilesRegex { get; private set; }
    public ReadOnlyHashSet`1<string> ConstantFields { get; }
    public IReadOnlyDictionary`2<string, ulong> TaintTypeNameToBit { get; }
    public IReadOnlyDictionary`2<string, MethodBehavior> Behavior { get; private set; }
    public IReadOnlyCollection`1<CsrfNamedGroup> CsrfGoups { get; }
    public Configuration(Configuration config);
    public Configuration(ConfigData configData);
    [CompilerGeneratedAttribute]
public bool get_ReportAnalysisCompletion();
    [CompilerGeneratedAttribute]
private void set_ReportAnalysisCompletion(bool value);
    [CompilerGeneratedAttribute]
public bool get_AuditMode();
    [CompilerGeneratedAttribute]
private void set_AuditMode(bool value);
    [CompilerGeneratedAttribute]
public int get_PasswordValidatorRequiredLength();
    [CompilerGeneratedAttribute]
private void set_PasswordValidatorRequiredLength(int value);
    [CompilerGeneratedAttribute]
public int get_MinimumPasswordValidatorProperties();
    [CompilerGeneratedAttribute]
private void set_MinimumPasswordValidatorProperties(int value);
    [CompilerGeneratedAttribute]
public ReadOnlyHashSet`1<string> get_PasswordValidatorRequiredProperties();
    [CompilerGeneratedAttribute]
public ReadOnlyHashSet`1<string> get_TaintEntryPoints();
    [CompilerGeneratedAttribute]
public ReadOnlyHashSet`1<string> get_PasswordFields();
    [CompilerGeneratedAttribute]
public Regex get_WebConfigFilesRegex();
    [CompilerGeneratedAttribute]
private void set_WebConfigFilesRegex(Regex value);
    [CompilerGeneratedAttribute]
public ReadOnlyHashSet`1<string> get_ConstantFields();
    public IReadOnlyDictionary`2<string, ulong> get_TaintTypeNameToBit();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, MethodBehavior> get_Behavior();
    [CompilerGeneratedAttribute]
private void set_Behavior(IReadOnlyDictionary`2<string, MethodBehavior> value);
    public IReadOnlyCollection`1<CsrfNamedGroup> get_CsrfGoups();
    public void MergeWith(ConfigData config);
    public void PrepareForQueries();
    private void RegisterTaintTypes(List`1<string> typeNames);
    private IReadOnlyList`1<Condition> GetPreConditions(Dictionary`2<object, object> ifSection, IReadOnlyDictionary`2<int, PostCondition> mainPostConditions);
    private ulong GetTaintBits(IEnumerable`1<object> taintTypes);
    private ulong GetTaintBits(string taintType, Boolean& negate);
    private IReadOnlyDictionary`2<int, ulong> GetArguments(IReadOnlyList`1<object> arguments);
    private IReadOnlyDictionary`2<int, InjectableArgument> GetInjectableArguments(IReadOnlyList`1<object> arguments);
    private IReadOnlyDictionary`2<int, PostCondition> GetPostConditions(IReadOnlyDictionary`2<object, object> arguments, IReadOnlyDictionary`2<int, PostCondition> defaultPostConditions);
    private InjectableArgument GetField(object value);
    private void ValidateArgTypes(string argTypes, string nameSpace, string className, string name);
    private void ValidateCondition(IDictionary`2<object, object> condition);
    private KeyValuePair`2<string, MethodBehavior> CreateBehavior(object behavior);
    public void AddCsrfProtectionToConfiguration(CsrfProtectionData csrfData);
}
internal class SecurityCodeScan.Config.ConfigurationManager : object {
    [CompilerGeneratedAttribute]
private static ConfigurationReader <Reader>k__BackingField;
    private static Lazy`1<ConfigData> CachedBuiltInConfiguration;
    internal static ConfigurationReader Reader { get; internal set; }
    private static ConfigurationManager();
    [CompilerGeneratedAttribute]
internal static ConfigurationReader get_Reader();
    [CompilerGeneratedAttribute]
internal static void set_Reader(ConfigurationReader value);
    public Configuration GetBuiltInAndUserConfiguration();
    public Configuration GetProjectConfiguration(ImmutableArray`1<AdditionalText> additionalFiles);
}
internal class SecurityCodeScan.Config.ConfigurationReader : object {
    private static string BuiltinConfigName;
    private static string ConfigName;
    private static string UserConfigName;
    private static Lazy`1<string> UserConfigFileCached;
    private static Version ConfigVersion;
    private string UserConfigFile { get; }
    private static ConfigurationReader();
    private string get_UserConfigFile();
    private T DeserializeAndValidate(StreamReader reader);
    public ConfigData GetBuiltinConfiguration();
    public virtual ConfigData GetUserConfiguration();
    public ConfigData GetProjectConfiguration(ImmutableArray`1<AdditionalText> additionalFiles);
}
internal class SecurityCodeScan.Config.CsrfAttributeCondition : object {
    public static CsrfAttributeCondition TRUE;
    public List`1<Pair> MustMatch;
    private static CsrfAttributeCondition();
    public static void AddCsrfAttributes(Dictionary`2<string, List`1<CsrfAttributeCondition>> destination, IEnumerable`1<CsrfAttributeData> source);
    private static CsrfAttributeCondition CreateCsrfAttributeCondition(Dictionary`2<object, object> conditions);
}
internal class SecurityCodeScan.Config.CsrfAttributeData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<object, object> <Condition>k__BackingField;
    public string Name { get; public set; }
    public Dictionary`2<object, object> Condition { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<object, object> get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(Dictionary`2<object, object> value);
}
internal class SecurityCodeScan.Config.CsrfClass : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CsrfIncludeExclude <Attributes>k__BackingField;
    public List`1<string> Name { get; public set; }
    public CsrfIncludeExclude Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(List`1<string> value);
    [CompilerGeneratedAttribute]
public CsrfIncludeExclude get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(CsrfIncludeExclude value);
}
internal class SecurityCodeScan.Config.CsrfController : IncludeExcludeAttributes {
    public HashSet`1<string> Names;
    public CsrfController(CsrfClass class);
}
internal class SecurityCodeScan.Config.CsrfIncludeExclude : object {
    [CompilerGeneratedAttribute]
private List`1<CsrfAttributeData> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CsrfAttributeData> <Exclude>k__BackingField;
    public List`1<CsrfAttributeData> Include { get; public set; }
    public List`1<CsrfAttributeData> Exclude { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CsrfAttributeData> get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(List`1<CsrfAttributeData> value);
    [CompilerGeneratedAttribute]
public List`1<CsrfAttributeData> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(List`1<CsrfAttributeData> value);
}
internal class SecurityCodeScan.Config.CsrfMessage : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Title { get; public set; }
    public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
internal class SecurityCodeScan.Config.CsrfMethod : object {
    [CompilerGeneratedAttribute]
private CsrfIncludeExclude <Attributes>k__BackingField;
    public CsrfIncludeExclude Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public CsrfIncludeExclude get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(CsrfIncludeExclude value);
}
internal class SecurityCodeScan.Config.CsrfNamedGroup : object {
    public string Name;
    public DiagnosticDescriptor Message;
    public Dictionary`2<string, List`1<CsrfAttributeCondition>> AntiCsrfAttributes;
    private CsrfController _Class;
    private IncludeExcludeAttributes _Method;
    private IncludeExcludeAttributes _Parameter;
    public CsrfController Class { get; }
    public IncludeExcludeAttributes Method { get; }
    public IncludeExcludeAttributes Parameter { get; }
    public CsrfNamedGroup(CsrfProtectionData configData);
    public CsrfController get_Class();
    public IncludeExcludeAttributes get_Method();
    public IncludeExcludeAttributes get_Parameter();
    public void AddFrom(CsrfProtectionData configData);
}
internal class SecurityCodeScan.Config.CsrfParameter : object {
    [CompilerGeneratedAttribute]
private CsrfIncludeExclude <Attributes>k__BackingField;
    public CsrfIncludeExclude Attributes { get; public set; }
    [CompilerGeneratedAttribute]
public CsrfIncludeExclude get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(CsrfIncludeExclude value);
}
internal class SecurityCodeScan.Config.CsrfProtectionData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CsrfMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CsrfAttributeData> <AntiCsrfAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private CsrfClass <Class>k__BackingField;
    [CompilerGeneratedAttribute]
private CsrfMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private CsrfParameter <Parameter>k__BackingField;
    public string Name { get; public set; }
    public CsrfMessage Message { get; public set; }
    public List`1<CsrfAttributeData> AntiCsrfAttributes { get; public set; }
    public CsrfClass Class { get; public set; }
    public CsrfMethod Method { get; public set; }
    public CsrfParameter Parameter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CsrfMessage get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(CsrfMessage value);
    [CompilerGeneratedAttribute]
public List`1<CsrfAttributeData> get_AntiCsrfAttributes();
    [CompilerGeneratedAttribute]
public void set_AntiCsrfAttributes(List`1<CsrfAttributeData> value);
    [CompilerGeneratedAttribute]
public CsrfClass get_Class();
    [CompilerGeneratedAttribute]
public void set_Class(CsrfClass value);
    [CompilerGeneratedAttribute]
public CsrfMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(CsrfMethod value);
    [CompilerGeneratedAttribute]
public CsrfParameter get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(CsrfParameter value);
}
internal class SecurityCodeScan.Config.FieldData : object {
    [CompilerGeneratedAttribute]
private object <Injectable>k__BackingField;
    public object Injectable { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Injectable();
    [CompilerGeneratedAttribute]
public void set_Injectable(object value);
}
internal class SecurityCodeScan.Config.IncludeExcludeAttributes : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<CsrfAttributeCondition>> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<CsrfAttributeCondition>> <Exclude>k__BackingField;
    public Dictionary`2<string, List`1<CsrfAttributeCondition>> Include { get; }
    public Dictionary`2<string, List`1<CsrfAttributeCondition>> Exclude { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<CsrfAttributeCondition>> get_Include();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<CsrfAttributeCondition>> get_Exclude();
}
internal class SecurityCodeScan.Config.MethodBehaviorData : Signature {
}
internal class SecurityCodeScan.Config.MethodData : object {
    [CompilerGeneratedAttribute]
private string <ArgTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <InjectableArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ConditionData <If>k__BackingField;
    public string ArgTypes { get; public set; }
    public Object[] InjectableArguments { get; public set; }
    public ConditionData If { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ArgTypes();
    [CompilerGeneratedAttribute]
public void set_ArgTypes(string value);
    [CompilerGeneratedAttribute]
public Object[] get_InjectableArguments();
    [CompilerGeneratedAttribute]
public void set_InjectableArguments(Object[] value);
    [CompilerGeneratedAttribute]
public ConditionData get_If();
    [CompilerGeneratedAttribute]
public void set_If(ConditionData value);
}
internal class SecurityCodeScan.Config.ProjectConfigData : ConfigData {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
}
internal class SecurityCodeScan.Config.Signature : object {
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodData <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldData <Field>k__BackingField;
    public string Namespace { get; public set; }
    public string ClassName { get; public set; }
    public string Name { get; public set; }
    public MethodData Method { get; public set; }
    public FieldData Field { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public void set_ClassName(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public MethodData get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodData value);
    [CompilerGeneratedAttribute]
public FieldData get_Field();
    [CompilerGeneratedAttribute]
public void set_Field(FieldData value);
}
internal class SecurityCodeScan.Config.TaintEntryPointData : Signature {
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SecurityCodeScan.Empty : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
}
