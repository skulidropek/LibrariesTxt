[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public interface Semver.Comparers.ISemVersionComparer {
}
internal class Semver.Comparers.PrecedenceComparer : Comparer`1<SemVersion> {
    public static ISemVersionComparer Instance;
    private static PrecedenceComparer();
    public sealed virtual bool Equals(SemVersion x, SemVersion y);
    private static bool Equals(IReadOnlyList`1<PrereleaseIdentifier> xIdentifiers, IReadOnlyList`1<PrereleaseIdentifier> yIdentifiers);
    public sealed virtual int GetHashCode(SemVersion v);
    public virtual int Compare(SemVersion x, SemVersion y);
}
internal class Semver.Comparers.SortOrderComparer : Comparer`1<SemVersion> {
    public static ISemVersionComparer Instance;
    private static SortOrderComparer();
    public sealed virtual bool Equals(SemVersion x, SemVersion y);
    public sealed virtual int GetHashCode(SemVersion v);
    public virtual int Compare(SemVersion x, SemVersion y);
}
internal class Semver.Comparers.UnbrokenSemVersionRangeComparer : Comparer`1<UnbrokenSemVersionRange> {
    public static UnbrokenSemVersionRangeComparer Instance;
    private static UnbrokenSemVersionRangeComparer();
    public virtual int Compare(UnbrokenSemVersionRange x, UnbrokenSemVersionRange y);
}
[IsReadOnlyAttribute]
public class Semver.MetadataIdentifier : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private MetadataIdentifier(string value, UnsafeOverload _);
    public MetadataIdentifier(string value);
    internal MetadataIdentifier(string value, string paramName);
    [CompilerGeneratedAttribute]
public string get_Value();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal static MetadataIdentifier CreateLoose(string value);
    internal static MetadataIdentifier CreateUnsafe(string value);
    public sealed virtual bool Equals(MetadataIdentifier value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static bool op_Equality(MetadataIdentifier left, MetadataIdentifier right);
    public static bool op_Inequality(MetadataIdentifier left, MetadataIdentifier right);
    public sealed virtual int CompareTo(MetadataIdentifier value);
    public sealed virtual int CompareTo(object value);
    public static string op_Implicit(MetadataIdentifier metadataIdentifier);
    public virtual string ToString();
}
internal static class Semver.Parsing.GeneralRangeParser : object {
    public static int CountSplitOnOrOperator(string range);
    [IteratorStateMachineAttribute("Semver.Parsing.GeneralRangeParser/<SplitOnOrOperator>d__1")]
public static IEnumerable`1<StringSegment> SplitOnOrOperator(string range);
    public static bool IsPossibleOperatorChar(char c, SemVersionRangeOptions rangeOptions);
    public static bool IsPossibleVersionChar(char c, SemVersionRangeOptions rangeOptions);
    public static Exception ParseOptionalSpaces(StringSegment& segment, Exception ex);
    public static void ParseOptionalWhitespace(StringSegment& segment);
    public static Exception ParseVersion(StringSegment& segment, SemVersionRangeOptions rangeOptions, SemVersionParsingOptions parseOptions, Exception ex, int maxLength, SemVersion& semver, WildcardVersion& wildcardVersion);
}
internal static class Semver.Parsing.NpmRangeParser : object {
    private static SemVersionRangeOptions StandardRangeOptions;
    private static SemVersionParsingOptions ParsingOptions;
    private static NpmRangeParser();
    public static Exception Parse(string range, bool includeAllPrerelease, Exception ex, int maxLength, SemVersionRange& semverRange);
    private static Exception Parse(string range, SemVersionRangeOptions rangeOptions, Exception ex, int maxLength, SemVersionRange& semverRange);
    private static Exception ParseUnbrokenRange(StringSegment segment, SemVersionRangeOptions rangeOptions, Exception ex, int maxLength, UnbrokenSemVersionRange& unbrokenRange);
    private static bool TrySplitOnHyphenRangeSeparator(StringSegment segment, StringSegment& segment1, StringSegment& segment2);
    private static Exception ParseHyphenRange(StringSegment beforeHyphenSegment, StringSegment afterHyphenSegment, SemVersionRangeOptions rangeOptions, bool includeAllPrerelease, Exception ex, int maxLength, LeftBoundedRange& leftBound, RightBoundedRange& rightBound);
    private static Exception ParseHyphenSegment(StringSegment segment, SemVersionRangeOptions rangeOptions, Exception ex, int maxLength, SemVersion& semver, WildcardVersion& wildcardVersion);
    private static Exception ParseComparison(StringSegment& segment, SemVersionRangeOptions rangeOptions, bool includeAllPrerelease, Exception ex, int maxLength, LeftBoundedRange& leftBound, RightBoundedRange& rightBound);
    public static Exception ParseNpmVersion(StringSegment& segment, SemVersionRangeOptions rangeOptions, Exception ex, int maxLength, SemVersion& semver, WildcardVersion& wildcardVersion);
    private static Exception GreaterThan(bool includeAllPrerelease, Exception ex, LeftBoundedRange& leftBound, StringSegment versionSegment, SemVersion semver, WildcardVersion wildcardVersion);
    private static Exception LessThan(RightBoundedRange& rightBound, SemVersion semver, WildcardVersion wildcardVersion);
    private static void WildcardLowerBound(bool includeAllPrerelease, LeftBoundedRange& leftBound, SemVersion semver, WildcardVersion wildcardVersion);
    private static Exception WildcardUpperBound(Exception ex, RightBoundedRange& rightBound, StringSegment versionSegment, SemVersion semver, WildcardVersion wildcardVersion);
    private static Exception ParseOperator(StringSegment& segment, Exception ex, StandardOperator& operator);
}
internal static class Semver.Parsing.PrereleaseIdentifiers : object {
    public static IReadOnlyList`1<PrereleaseIdentifier> Zero;
    private static PrereleaseIdentifiers();
}
internal static class Semver.Parsing.RangeError : object {
    private static string TooLongMessage;
    private static string InvalidOperatorMessage;
    private static string InvalidWhitespaceMessage;
    private static string MissingComparisonMessage;
    private static string MaxVersionMessage;
    private static string WildcardWithOperatorMessage;
    private static string PrereleaseWithWildcardVersionMessage;
    private static string UnexpectedInHyphenRangeMessage;
    private static string MissingVersionInHyphenRangeMessage;
    public static FormatException TooLong(string range, int maxLength);
    public static Exception InvalidOperator(StringSegment operator);
    public static Exception InvalidWhitespace(int position, string range);
    public static Exception MissingComparison(int position, string range);
    public static Exception MaxVersion(StringSegment version);
    public static Exception WildcardNotSupportedWithOperator(string range);
    public static Exception PrereleaseNotSupportedWithWildcardVersion(string range);
    public static Exception UnexpectedInHyphenRange(string unexpected);
    public static Exception MissingVersionInHyphenRange(string range);
    private static FormatException NewFormatException(string messageTemplate, Object[] args);
}
internal static class Semver.Parsing.SemVersionParser : object {
    private static string LeadingWhitespaceMessage;
    private static string TrailingWhitespaceMessage;
    private static string EmptyVersionMessage;
    private static string TooLongVersionMessage;
    private static string AllWhitespaceVersionMessage;
    private static string LeadingLowerVMessage;
    private static string LeadingUpperVMessage;
    private static string LeadingZeroInMajorMinorOrPatchMessage;
    private static string EmptyMajorMinorOrPatchMessage;
    private static string MajorMinorOrPatchOverflowMessage;
    private static string FourthVersionNumberMessage;
    private static string PrereleasePrefixedByDotMessage;
    private static string MissingPrereleaseIdentifierMessage;
    private static string LeadingZeroInPrereleaseMessage;
    private static string PrereleaseOverflowMessage;
    private static string InvalidCharacterInPrereleaseMessage;
    private static string MissingMetadataIdentifierMessage;
    private static string InvalidCharacterInMajorMinorOrPatchMessage;
    private static string InvalidCharacterInMetadataMessage;
    private static string InvalidWildcardInMajorMinorOrPatchMessage;
    private static string MinorOrPatchMustBeWildcardVersionMessage;
    private static string InvalidWildcardInPrereleaseMessage;
    private static string PrereleaseWildcardMustBeLast;
    public static Exception Parse(string version, SemVersionStyles style, Exception ex, int maxLength, SemVersion& semver);
    public static Exception Parse(StringSegment version, SemVersionStyles style, SemVersionParsingOptions options, Exception ex, int maxLength, SemVersion& semver, WildcardVersion& wildcardVersion);
    private static Exception ParseLeadingWhitespace(StringSegment version, StringSegment& segment, SemVersionStyles style, Exception ex);
    private static Exception ParseLeadingV(StringSegment version, StringSegment& segment, SemVersionStyles style, Exception ex);
    private static Exception ParseVersionNumber(string kind, StringSegment version, IEnumerator`1<StringSegment> versionNumbers, bool allowLeadingZeros, bool optional, bool wildcardRequired, SemVersionParsingOptions options, Exception ex, Int32& number, Boolean& isWildcard);
    private static Exception ParseVersionNumber(string kind, StringSegment version, StringSegment segment, bool allowLeadingZeros, bool wildcardRequired, SemVersionParsingOptions options, Exception ex, Int32& number, Boolean& isWildcard);
    private static Exception ParsePrerelease(StringSegment version, StringSegment segment, bool allowLeadingZero, SemVersionParsingOptions options, Exception ex, String& prerelease, IReadOnlyList`1& prereleaseIdentifiers, Boolean& isWildcard);
    private static Exception ParseMetadata(StringSegment version, StringSegment segment, Exception ex, String& metadata, IReadOnlyList`1& metadataIdentifiers);
    private static FormatException NewFormatException(string messageTemplate, Object[] args);
}
internal class Semver.Parsing.SemVersionParsingOptions : object {
    public static SemVersionParsingOptions None;
    [CompilerGeneratedAttribute]
private bool <AllowWildcardMajorMinorPatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowWildcardPrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MissingVersionsAreWildcards>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<char> <IsWildcard>k__BackingField;
    public bool AllowWildcardMajorMinorPatch { get; }
    public bool AllowWildcardPrerelease { get; }
    public bool MissingVersionsAreWildcards { get; }
    public Predicate`1<char> IsWildcard { get; }
    public SemVersionParsingOptions(bool allowWildcardMajorMinorPatch, bool allowWildcardPrerelease, bool missingVersionsAreWildcards, Predicate`1<char> isWildcard);
    private static SemVersionParsingOptions();
    [CompilerGeneratedAttribute]
public bool get_AllowWildcardMajorMinorPatch();
    [CompilerGeneratedAttribute]
public bool get_AllowWildcardPrerelease();
    [CompilerGeneratedAttribute]
public bool get_MissingVersionsAreWildcards();
    [CompilerGeneratedAttribute]
public Predicate`1<char> get_IsWildcard();
}
internal enum Semver.Parsing.StandardOperator : Enum {
    public int value__;
    public static StandardOperator None;
    public static StandardOperator Equals;
    public static StandardOperator LessThan;
    public static StandardOperator LessThanOrEqual;
    public static StandardOperator GreaterThan;
    public static StandardOperator GreaterThanOrEqual;
    public static StandardOperator Tilde;
    public static StandardOperator Caret;
}
internal static class Semver.Parsing.StandardRangeParser : object {
    private static SemVersionParsingOptions ParsingOptions;
    private static StandardRangeParser();
    public static Exception Parse(string range, SemVersionRangeOptions rangeOptions, Exception ex, int maxLength, SemVersionRange& semverRange);
    private static Exception ParseUnbrokenRange(StringSegment segment, SemVersionRangeOptions rangeOptions, Exception ex, int maxLength, UnbrokenSemVersionRange& unbrokenRange);
    private static Exception ParseComparison(StringSegment& segment, SemVersionRangeOptions rangeOptions, Boolean& includeAllPrerelease, Exception ex, int maxLength, LeftBoundedRange& leftBound, RightBoundedRange& rightBound);
    private static LeftBoundedRange WildcardLowerBound(SemVersion semver, bool prereleaseWildcard);
    private static Exception PrereleaseWildcardUpperBound(Exception ex, RightBoundedRange& rightBound, StringSegment versionSegment, SemVersion semver, bool prereleaseWildcard);
    [IteratorStateMachineAttribute("Semver.Parsing.StandardRangeParser/<PrereleaseWildcardUpperBoundPrereleaseIdentifiers>d__5")]
private static IEnumerable`1<PrereleaseIdentifier> PrereleaseWildcardUpperBoundPrereleaseIdentifiers(IReadOnlyList`1<PrereleaseIdentifier> identifiers);
    private static Exception ParseOperator(StringSegment& segment, Exception ex, StandardOperator& operator);
}
[FlagsAttribute]
internal enum Semver.Parsing.WildcardVersion : Enum {
    public byte value__;
    public static WildcardVersion None;
    public static WildcardVersion MajorWildcard;
    public static WildcardVersion MinorWildcard;
    public static WildcardVersion PatchWildcard;
    public static WildcardVersion PrereleaseWildcard;
    public static WildcardVersion MinorPatchWildcard;
    public static WildcardVersion MajorMinorPatchWildcard;
}
[ExtensionAttribute]
internal static class Semver.Parsing.WildcardVersionExtensions : object {
    [ExtensionAttribute]
public static bool HasOption(WildcardVersion wildcards, WildcardVersion flag);
    [ExtensionAttribute]
public static void RemoveOption(WildcardVersion& wildcards, WildcardVersion flag);
}
[IsReadOnlyAttribute]
public class Semver.PrereleaseIdentifier : ValueType {
    internal static PrereleaseIdentifier Zero;
    internal static PrereleaseIdentifier Hyphen;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NumericValue>k__BackingField;
    public string Value { get; }
    public Nullable`1<int> NumericValue { get; }
    private PrereleaseIdentifier(string value, Nullable`1<int> numericValue);
    public PrereleaseIdentifier(string value, bool allowLeadingZeros);
    internal PrereleaseIdentifier(string value, bool allowLeadingZeros, string paramName);
    public PrereleaseIdentifier(int value);
    private static PrereleaseIdentifier();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NumericValue();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
internal static PrereleaseIdentifier CreateLoose(string value);
    internal static PrereleaseIdentifier CreateUnsafe(string value, Nullable`1<int> numericValue);
    public sealed virtual bool Equals(PrereleaseIdentifier value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static bool op_Equality(PrereleaseIdentifier left, PrereleaseIdentifier right);
    public static bool op_Inequality(PrereleaseIdentifier left, PrereleaseIdentifier right);
    public sealed virtual int CompareTo(PrereleaseIdentifier value);
    public sealed virtual int CompareTo(object value);
    public static string op_Implicit(PrereleaseIdentifier prereleaseIdentifier);
    public virtual string ToString();
    internal PrereleaseIdentifier NextIdentifier();
}
[IsReadOnlyAttribute]
internal class Semver.Ranges.LeftBoundedRange : ValueType {
    public static LeftBoundedRange Unbounded;
    [CompilerGeneratedAttribute]
private SemVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inclusive>k__BackingField;
    public SemVersion Version { get; }
    public bool Inclusive { get; }
    public bool IncludesPrerelease { get; }
    public LeftBoundedRange(SemVersion version, bool inclusive);
    private static LeftBoundedRange();
    [CompilerGeneratedAttribute]
public SemVersion get_Version();
    [CompilerGeneratedAttribute]
public bool get_Inclusive();
    public bool get_IncludesPrerelease();
    public bool Contains(SemVersion version);
    public LeftBoundedRange Min(LeftBoundedRange other);
    public LeftBoundedRange Max(LeftBoundedRange other);
    public sealed virtual bool Equals(LeftBoundedRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LeftBoundedRange left, LeftBoundedRange right);
    public static bool op_Inequality(LeftBoundedRange left, LeftBoundedRange right);
    public int CompareTo(RightBoundedRange other);
    public int CompareTo(LeftBoundedRange other);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class Semver.Ranges.RightBoundedRange : ValueType {
    public static RightBoundedRange Unbounded;
    [CompilerGeneratedAttribute]
private SemVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inclusive>k__BackingField;
    public SemVersion Version { get; }
    public bool Inclusive { get; }
    public bool IncludesPrerelease { get; }
    public RightBoundedRange(SemVersion version, bool inclusive);
    private static RightBoundedRange();
    [CompilerGeneratedAttribute]
public SemVersion get_Version();
    [CompilerGeneratedAttribute]
public bool get_Inclusive();
    public bool get_IncludesPrerelease();
    public bool Contains(SemVersion version);
    public RightBoundedRange Min(RightBoundedRange other);
    public RightBoundedRange Max(RightBoundedRange other);
    public sealed virtual bool Equals(RightBoundedRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RightBoundedRange left, RightBoundedRange right);
    public static bool op_Inequality(RightBoundedRange left, RightBoundedRange right);
    public int CompareTo(RightBoundedRange other);
    public virtual string ToString();
}
public class Semver.SemVersion : object {
    internal static SemVersion Min;
    internal static SemVersion MinRelease;
    internal static SemVersion Max;
    internal static string InvalidSemVersionStylesMessage;
    private static string InvalidMajorVersionMessage;
    private static string InvalidMinorVersionMessage;
    private static string InvalidPatchVersionMessage;
    private static string PrereleaseIdentifierIsDefaultMessage;
    private static string MetadataIdentifierIsDefaultMessage;
    internal static int MaxVersionLength;
    private static Regex ParseRegex;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PrereleaseIdentifier> <PrereleaseIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetadataIdentifier> <MetadataIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private static ISemVersionComparer <PrecedenceComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ISemVersionComparer <SortOrderComparer>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public string Prerelease { get; }
    public IReadOnlyList`1<PrereleaseIdentifier> PrereleaseIdentifiers { get; }
    internal bool PrereleaseIsZero { get; }
    public bool IsPrerelease { get; }
    public bool IsRelease { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This property is obsolete. Use Metadata instead.")]
public string Build { get; }
    public string Metadata { get; }
    public IReadOnlyList`1<MetadataIdentifier> MetadataIdentifiers { get; }
    public static ISemVersionComparer PrecedenceComparer { get; }
    public static ISemVersionComparer SortOrderComparer { get; }
    public SemVersion(int major);
    public SemVersion(int major, int minor);
    public SemVersion(int major, int minor, int patch);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor is obsolete. Use another constructor or SemVersion.ParsedFrom() instead.")]
public SemVersion(int major, int minor, int patch, string prerelease, string build);
    public SemVersion(int major, int minor, int patch, IEnumerable`1<PrereleaseIdentifier> prerelease, IEnumerable`1<MetadataIdentifier> metadata);
    public SemVersion(int major, int minor, int patch, IEnumerable`1<string> prerelease, IEnumerable`1<string> metadata);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor is obsolete. Use SemVersion.FromVersion() instead.")]
public SemVersion(Version version);
    internal SemVersion(int major, int minor, int patch, string prerelease, IReadOnlyList`1<PrereleaseIdentifier> prereleaseIdentifiers, string metadata, IReadOnlyList`1<MetadataIdentifier> metadataIdentifiers);
    private static SemVersion();
    public static SemVersion ParsedFrom(int major, int minor, int patch, string prerelease, string metadata, bool allowLeadingZeros);
    public static SemVersion FromVersion(Version version);
    public Version ToVersion();
    public static SemVersion Parse(string version, SemVersionStyles style, int maxLength);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use Parse() overload with SemVersionStyles instead.")]
public static SemVersion Parse(string version, bool strict);
    public static bool TryParse(string version, SemVersionStyles style, SemVersion& semver, int maxLength);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use TryParse() overload with SemVersionStyles instead.")]
public static bool TryParse(string version, SemVersion& semver, bool strict);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use CompareSortOrder() or ComparePrecedence() instead.")]
public static int Compare(SemVersion versionA, SemVersion versionB);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use With() or With...() method instead.")]
public SemVersion Change(Nullable`1<int> major, Nullable`1<int> minor, Nullable`1<int> patch, string prerelease, string build);
    public SemVersion With(Nullable`1<int> major, Nullable`1<int> minor, Nullable`1<int> patch, IEnumerable`1<PrereleaseIdentifier> prerelease, IEnumerable`1<MetadataIdentifier> metadata);
    public SemVersion WithParsedFrom(Nullable`1<int> major, Nullable`1<int> minor, Nullable`1<int> patch, string prerelease, string metadata, bool allowLeadingZeros);
    public SemVersion WithMajor(int major);
    public SemVersion WithMinor(int minor);
    public SemVersion WithPatch(int patch);
    public SemVersion WithPrereleaseParsedFrom(string prerelease, bool allowLeadingZeros);
    public SemVersion WithPrerelease(string prereleaseIdentifier, String[] prereleaseIdentifiers);
    public SemVersion WithPrerelease(IEnumerable`1<string> prereleaseIdentifiers);
    public SemVersion WithPrerelease(PrereleaseIdentifier prereleaseIdentifier, PrereleaseIdentifier[] prereleaseIdentifiers);
    public SemVersion WithPrerelease(IEnumerable`1<PrereleaseIdentifier> prereleaseIdentifiers);
    public SemVersion WithoutPrerelease();
    public SemVersion WithMetadataParsedFrom(string metadata);
    public SemVersion WithMetadata(string metadataIdentifier, String[] metadataIdentifiers);
    public SemVersion WithMetadata(IEnumerable`1<string> metadataIdentifiers);
    public SemVersion WithMetadata(MetadataIdentifier metadataIdentifier, MetadataIdentifier[] metadataIdentifiers);
    public SemVersion WithMetadata(IEnumerable`1<MetadataIdentifier> metadataIdentifiers);
    public SemVersion WithoutMetadata();
    public SemVersion WithoutPrereleaseOrMetadata();
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    [CompilerGeneratedAttribute]
public string get_Prerelease();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PrereleaseIdentifier> get_PrereleaseIdentifiers();
    internal bool get_PrereleaseIsZero();
    public bool get_IsPrerelease();
    public bool get_IsRelease();
    public string get_Build();
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetadataIdentifier> get_MetadataIdentifiers();
    public virtual string ToString();
    public static bool Equals(SemVersion versionA, SemVersion versionB);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SemVersion other);
    public bool PrecedenceEquals(SemVersion other);
    public static bool PrecedenceEquals(SemVersion left, SemVersion right);
    internal bool MajorMinorPatchEquals(SemVersion other);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use PrecedenceEquals() instead.")]
public bool PrecedenceMatches(SemVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SemVersion left, SemVersion right);
    public static bool op_Inequality(SemVersion left, SemVersion right);
    [CompilerGeneratedAttribute]
public static ISemVersionComparer get_PrecedenceComparer();
    [CompilerGeneratedAttribute]
public static ISemVersionComparer get_SortOrderComparer();
    public int ComparePrecedenceTo(SemVersion other);
    public int CompareSortOrderTo(SemVersion other);
    public static int ComparePrecedence(SemVersion left, SemVersion right);
    public static int CompareSortOrder(SemVersion left, SemVersion right);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use CompareSortOrderTo() or ComparePrecedenceTo() instead.")]
public sealed virtual int CompareTo(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use CompareSortOrderTo() or ComparePrecedenceTo() instead.")]
public sealed virtual int CompareTo(SemVersion other);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Method is obsolete. Use ComparePrecedenceTo() or CompareSortOrderTo() instead.")]
public int CompareByPrecedence(SemVersion other);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute]
private static int CompareComponents(string a, string b, bool nonEmptyIsLower);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Operator is obsolete. Use CompareSortOrder() or ComparePrecedence() instead.")]
public static bool op_GreaterThan(SemVersion left, SemVersion right);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Operator is obsolete. Use CompareSortOrder() or ComparePrecedence() instead.")]
public static bool op_GreaterThanOrEqual(SemVersion left, SemVersion right);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Operator is obsolete. Use CompareSortOrder() or ComparePrecedence() instead.")]
public static bool op_LessThan(SemVersion left, SemVersion right);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Operator is obsolete. Use CompareSortOrder() or ComparePrecedence() instead.")]
public static bool op_LessThanOrEqual(SemVersion left, SemVersion right);
    public bool Satisfies(Predicate`1<SemVersion> predicate);
    public bool Satisfies(SemVersionRange range);
    public bool Satisfies(UnbrokenSemVersionRange range);
    public bool Satisfies(string range, SemVersionRangeOptions options, int maxLength);
    public bool Satisfies(string range, int maxLength);
    public bool SatisfiesNpm(string range, bool includeAllPrerelease, int maxLength);
    public bool SatisfiesNpm(string range, int maxLength);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Implicit conversion from string is obsolete. Use Parse() or TryParse() method instead.")]
public static SemVersion op_Implicit(string version);
}
[DefaultMemberAttribute("Item")]
public class Semver.SemVersionRange : object {
    internal static int MaxRangeLength;
    internal static string InvalidOptionsMessage;
    internal static string InvalidMaxLengthMessage;
    [CompilerGeneratedAttribute]
private static SemVersionRange <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private static SemVersionRange <AllRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static SemVersionRange <All>k__BackingField;
    private IReadOnlyList`1<UnbrokenSemVersionRange> ranges;
    public static SemVersionRange Empty { get; }
    public static SemVersionRange AllRelease { get; }
    public static SemVersionRange All { get; }
    public int Count { get; }
    public UnbrokenSemVersionRange Item { get; }
    private SemVersionRange(UnbrokenSemVersionRange range);
    private SemVersionRange(IReadOnlyList`1<UnbrokenSemVersionRange> ranges);
    private static SemVersionRange();
    [CompilerGeneratedAttribute]
public static SemVersionRange get_Empty();
    [CompilerGeneratedAttribute]
public static SemVersionRange get_AllRelease();
    [CompilerGeneratedAttribute]
public static SemVersionRange get_All();
    public static SemVersionRange Equals(SemVersion version);
    public static SemVersionRange GreaterThan(SemVersion version, bool includeAllPrerelease);
    public static SemVersionRange AtLeast(SemVersion version, bool includeAllPrerelease);
    public static SemVersionRange LessThan(SemVersion version, bool includeAllPrerelease);
    public static SemVersionRange AtMost(SemVersion version, bool includeAllPrerelease);
    public static SemVersionRange Inclusive(SemVersion start, SemVersion end, bool includeAllPrerelease);
    public static SemVersionRange InclusiveOfStart(SemVersion start, SemVersion end, bool includeAllPrerelease);
    public static SemVersionRange InclusiveOfEnd(SemVersion start, SemVersion end, bool includeAllPrerelease);
    public static SemVersionRange Exclusive(SemVersion start, SemVersion end, bool includeAllPrerelease);
    private static SemVersionRange Create(UnbrokenSemVersionRange range);
    internal static SemVersionRange Create(List`1<UnbrokenSemVersionRange> ranges);
    public static SemVersionRange Create(IEnumerable`1<UnbrokenSemVersionRange> ranges);
    public static SemVersionRange Create(UnbrokenSemVersionRange[] ranges);
    public bool Contains(SemVersion version);
    public static Predicate`1<SemVersion> op_Implicit(SemVersionRange range);
    public static SemVersionRange Parse(string range, SemVersionRangeOptions options, int maxLength);
    public static SemVersionRange Parse(string range, int maxLength);
    public static bool TryParse(string range, SemVersionRangeOptions options, SemVersionRange& semverRange, int maxLength);
    public static bool TryParse(string range, SemVersionRange& semverRange, int maxLength);
    public static SemVersionRange ParseNpm(string range, bool includeAllPrerelease, int maxLength);
    public static SemVersionRange ParseNpm(string range, int maxLength);
    public static bool TryParseNpm(string range, bool includeAllPrerelease, SemVersionRange& semverRange, int maxLength);
    public static bool TryParseNpm(string range, SemVersionRange& semverRange, int maxLength);
    public sealed virtual int get_Count();
    public sealed virtual UnbrokenSemVersionRange get_Item(int index);
    public sealed virtual IEnumerator`1<UnbrokenSemVersionRange> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(SemVersionRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SemVersionRange left, SemVersionRange right);
    public static bool op_Inequality(SemVersionRange left, SemVersionRange right);
    public virtual string ToString();
}
[FlagsAttribute]
public enum Semver.SemVersionRangeOptions : Enum {
    public int value__;
    public static SemVersionRangeOptions Strict;
    public static SemVersionRangeOptions AllowLeadingZeros;
    public static SemVersionRangeOptions AllowLowerV;
    public static SemVersionRangeOptions AllowUpperV;
    public static SemVersionRangeOptions AllowV;
    public static SemVersionRangeOptions OptionalPatch;
    public static SemVersionRangeOptions OptionalMinorPatch;
    public static SemVersionRangeOptions IncludeAllPrerelease;
    public static SemVersionRangeOptions AllowMetadata;
    public static SemVersionRangeOptions Loose;
}
[ExtensionAttribute]
internal static class Semver.SemVersionRangeOptionsExtensions : object {
    private static SemVersionRangeOptions OptionsThatAreStyles;
    private static SemVersionRangeOptions OptionalMinorWithoutPatch;
    internal static SemVersionRangeOptions AllFlags;
    [ExtensionAttribute]
public static bool IsValid(SemVersionRangeOptions options);
    [ExtensionAttribute]
public static bool HasOption(SemVersionRangeOptions options, SemVersionRangeOptions flag);
    [ExtensionAttribute]
public static SemVersionStyles ToStyles(SemVersionRangeOptions options);
}
[FlagsAttribute]
public enum Semver.SemVersionStyles : Enum {
    public int value__;
    public static SemVersionStyles Strict;
    public static SemVersionStyles AllowLeadingZeros;
    public static SemVersionStyles AllowLeadingWhitespace;
    public static SemVersionStyles AllowTrailingWhitespace;
    public static SemVersionStyles AllowWhitespace;
    public static SemVersionStyles AllowLowerV;
    public static SemVersionStyles AllowUpperV;
    public static SemVersionStyles AllowV;
    public static SemVersionStyles OptionalPatch;
    public static SemVersionStyles OptionalMinorPatch;
    public static SemVersionStyles Any;
}
[ExtensionAttribute]
internal static class Semver.SemVersionStylesExtensions : object {
    internal static SemVersionStyles AllowAll;
    private static SemVersionStyles OptionalMinorWithoutPatch;
    [ExtensionAttribute]
public static bool IsValid(SemVersionStyles styles);
    [ExtensionAttribute]
public static bool HasStyle(SemVersionStyles styles, SemVersionStyles flag);
}
public class Semver.UnbrokenSemVersionRange : object {
    [CompilerGeneratedAttribute]
private static UnbrokenSemVersionRange <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnbrokenSemVersionRange <AllRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static UnbrokenSemVersionRange <All>k__BackingField;
    internal LeftBoundedRange LeftBound;
    internal RightBoundedRange RightBound;
    private bool allPrereleaseCoveredByEnds;
    private string toStringCache;
    [CompilerGeneratedAttribute]
private bool <IncludeAllPrerelease>k__BackingField;
    private static string InvalidMetadataMessage;
    public static UnbrokenSemVersionRange Empty { get; }
    public static UnbrokenSemVersionRange AllRelease { get; }
    public static UnbrokenSemVersionRange All { get; }
    public SemVersion Start { get; }
    public bool StartInclusive { get; }
    public SemVersion End { get; }
    public bool EndInclusive { get; }
    public bool IncludeAllPrerelease { get; }
    private UnbrokenSemVersionRange(LeftBoundedRange leftBound, RightBoundedRange rightBound, bool includeAllPrerelease, bool allPrereleaseCoveredByEnds);
    private static UnbrokenSemVersionRange();
    [CompilerGeneratedAttribute]
public static UnbrokenSemVersionRange get_Empty();
    [CompilerGeneratedAttribute]
public static UnbrokenSemVersionRange get_AllRelease();
    [CompilerGeneratedAttribute]
public static UnbrokenSemVersionRange get_All();
    public static UnbrokenSemVersionRange Equals(SemVersion version);
    public static UnbrokenSemVersionRange GreaterThan(SemVersion version, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange AtLeast(SemVersion version, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange LessThan(SemVersion version, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange AtMost(SemVersion version, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange Inclusive(SemVersion start, SemVersion end, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange InclusiveOfStart(SemVersion start, SemVersion end, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange InclusiveOfEnd(SemVersion start, SemVersion end, bool includeAllPrerelease);
    public static UnbrokenSemVersionRange Exclusive(SemVersion start, SemVersion end, bool includeAllPrerelease);
    private static UnbrokenSemVersionRange Create(SemVersion startVersion, bool startInclusive, SemVersion endVersion, bool endInclusive, bool includeAllPrerelease);
    internal static UnbrokenSemVersionRange Create(LeftBoundedRange start, RightBoundedRange end, bool includeAllPrerelease);
    public SemVersion get_Start();
    public bool get_StartInclusive();
    public SemVersion get_End();
    public bool get_EndInclusive();
    [CompilerGeneratedAttribute]
public bool get_IncludeAllPrerelease();
    public bool Contains(SemVersion version);
    public static Predicate`1<SemVersion> op_Implicit(UnbrokenSemVersionRange range);
    public sealed virtual bool Equals(UnbrokenSemVersionRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(UnbrokenSemVersionRange left, UnbrokenSemVersionRange right);
    public static bool op_Inequality(UnbrokenSemVersionRange left, UnbrokenSemVersionRange right);
    public virtual string ToString();
    private string ToStringInternal();
    private bool TryToSpecialString(bool includesPrereleaseNotCoveredByEnds, String& result);
    internal bool Overlaps(UnbrokenSemVersionRange other);
    internal bool OverlapsOrAbuts(UnbrokenSemVersionRange other);
    internal bool Contains(UnbrokenSemVersionRange other);
    internal bool TryUnion(UnbrokenSemVersionRange other, UnbrokenSemVersionRange& union);
    private static bool IsEmpty(LeftBoundedRange start, RightBoundedRange end, bool includeAllPrerelease);
    private static SemVersion Validate(SemVersion version, string paramName);
}
[ExtensionAttribute]
internal static class Semver.Utility.CharExtensions : object {
    [ExtensionAttribute]
public static bool IsDigit(char c);
    [ExtensionAttribute]
public static bool IsAlphaOrHyphen(char c);
}
internal class Semver.Utility.CombinedHashCode : ValueType {
    private static int RandomSeed;
    private int hash;
    private CombinedHashCode(int hash);
    private static CombinedHashCode();
    public static CombinedHashCode Create(T1 value1);
    public static CombinedHashCode Create(T1 value1, T2 value2);
    public static CombinedHashCode Create(T1 value1, T2 value2, T3 value3);
    public static CombinedHashCode Create(T1 value1, T2 value2, T3 value3, T4 value4);
    public static CombinedHashCode Create(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static CombinedHashCode CreateForItems(IEnumerable`1<T> values);
    public void Add(T value);
    public static int op_Implicit(CombinedHashCode hashCode);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
public virtual int GetHashCode();
    private static int CombineValue(int hash1, T value);
}
[ExcludeFromCodeCoverageAttribute]
internal static class Semver.Utility.DebugChecks : object {
    [ConditionalAttribute("DEBUG")]
public static void IsValid(SemVersionStyles style, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void IsValid(SemVersionRangeOptions rangeOptions, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void IsValidMaxLength(int maxLength, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void IsNotWildcardVersionWithPrerelease(WildcardVersion wildcardVersion, SemVersion semver);
    [ConditionalAttribute("DEBUG")]
public static void IsNotEmpty(StringSegment segment, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void IsNotNull(T value, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void IsNotFailedException(Exception exception, string className, string methodName);
    [ConditionalAttribute("DEBUG")]
public static void NoMetadata(SemVersion version, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void IsValidVersionNumber(int versionNumber, string kind, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void ContainsNoDefaultValues(IEnumerable`1<T> values, string kind, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void AreEqualWhenJoinedWithDots(string value, string param1Name, IReadOnlyList`1<T> values, string param2Name);
}
[ExtensionAttribute]
internal static class Semver.Utility.EnumerableExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToReadOnlyList(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Prepend(IEnumerable`1<TSource> source, TSource element);
}
[AttributeUsageAttribute("749")]
internal class Semver.Utility.ExcludeFromCodeCoverageAttribute : Attribute {
}
internal static class Semver.Utility.IdentifierString : object {
    public static int Compare(string left, string right);
}
[ExtensionAttribute]
internal static class Semver.Utility.IntExtensions : object {
    [ExtensionAttribute]
public static int DecimalDigits(int n);
}
[ExtensionAttribute]
internal static class Semver.Utility.ListExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> AsReadOnly(List`1<T> list);
}
internal static class Semver.Utility.ReadOnlyList`1 : object {
    public static IReadOnlyList`1<T> Empty;
    private static ReadOnlyList`1();
}
[ExtensionAttribute]
internal static class Semver.Utility.StringExtensions : object {
    private static int DisplayLimit;
    [ExtensionAttribute]
public static bool IsDigits(string value);
    [ExtensionAttribute]
public static bool IsAlphanumericOrHyphens(string value);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> SplitAndMapToReadOnlyList(string value, char splitOn, Func`2<string, T> func);
    [ExtensionAttribute]
public static string TrimLeadingZeros(string value);
    [ExtensionAttribute]
public static StringSegment Slice(string value, int offset, int length);
    [ExtensionAttribute]
public static string LimitLength(string value);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Semver.Utility.StringSegment : ValueType {
    public string Source;
    public int Offset;
    public int Length;
    private static int DisplayLimit;
    public bool IsEmpty { get; }
    public char Item { get; }
    public StringSegment(string source, int offset, int length);
    public bool get_IsEmpty();
    public char get_Item(int i);
    public StringSegment TrimStartSpaces();
    public StringSegment TrimStartWhitespace();
    public StringSegment TrimEndWhitespace();
    public StringSegment TrimLeadingZeros();
    public StringSegment Subsegment(int start, int length);
    public StringSegment Subsegment(int start);
    public StringSegment EmptySubsegment();
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int SplitCount(char c);
    [IteratorStateMachineAttribute("Semver.Utility.StringSegment/<Split>d__19")]
public IEnumerable`1<StringSegment> Split(char c);
    public void SplitBeforeFirst(char c, StringSegment& left, StringSegment& right);
    public static StringSegment op_Implicit(string value);
    public virtual string ToString();
    public string ToStringLimitLength();
}
[ExcludeFromCodeCoverageAttribute]
internal static class Semver.Utility.Unreachable : object {
    public static ArgumentException InvalidEnum(StandardOperator operator);
    public static ArgumentException InvalidEnum(WildcardVersion wildcardVersion);
}
[IsReadOnlyAttribute]
internal class Semver.Utility.UnsafeOverload : ValueType {
    public static UnsafeOverload Marker;
    private static UnsafeOverload();
}
internal static class Semver.Utility.VersionParsing : object {
    public static Exception FailedException;
    private static VersionParsing();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
