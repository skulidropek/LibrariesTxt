[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.AccessorExpression : Expression {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Receiver>k__BackingField;
    public string MemberName { get; }
    public Expression Receiver { get; }
    public AccessorExpression(Expression receiver, string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public Expression get_Receiver();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.AmbientNameExpression : Expression {
    private bool _requiresEscape;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBuiltIn>k__BackingField;
    public string PropertyName { get; }
    public bool IsBuiltIn { get; }
    public AmbientNameExpression(string name, bool isBuiltIn);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public bool get_IsBuiltIn();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.ArrayExpression : Expression {
    [CompilerGeneratedAttribute]
private Element[] <Elements>k__BackingField;
    public Element[] Elements { get; }
    public ArrayExpression(Element[] elements);
    [CompilerGeneratedAttribute]
public Element[] get_Elements();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.CallExpression : Expression {
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatorName>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression[] <Operands>k__BackingField;
    public bool IgnoreCase { get; }
    public string OperatorName { get; }
    public Expression[] Operands { get; }
    public CallExpression(bool ignoreCase, string operatorName, Expression[] operands);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public string get_OperatorName();
    [CompilerGeneratedAttribute]
public Expression[] get_Operands();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.ConstantExpression : Expression {
    [CompilerGeneratedAttribute]
private LogEventPropertyValue <Constant>k__BackingField;
    public LogEventPropertyValue Constant { get; }
    public ConstantExpression(LogEventPropertyValue constant);
    [CompilerGeneratedAttribute]
public LogEventPropertyValue get_Constant();
    public virtual string ToString();
}
internal abstract class Serilog.Expressions.Ast.Element : object {
}
internal abstract class Serilog.Expressions.Ast.Expression : object {
    [NullableContextAttribute("1")]
public abstract virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.IndexerExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Receiver>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Index>k__BackingField;
    public Expression Receiver { get; }
    public Expression Index { get; }
    public IndexerExpression(Expression receiver, Expression index);
    [CompilerGeneratedAttribute]
public Expression get_Receiver();
    [CompilerGeneratedAttribute]
public Expression get_Index();
    public virtual string ToString();
}
internal enum Serilog.Expressions.Ast.IndexerWildcard : Enum {
    public int value__;
    public static IndexerWildcard Undefined;
    public static IndexerWildcard Any;
    public static IndexerWildcard All;
}
internal class Serilog.Expressions.Ast.IndexerWildcardExpression : Expression {
    [CompilerGeneratedAttribute]
private IndexerWildcard <Wildcard>k__BackingField;
    public IndexerWildcard Wildcard { get; }
    public IndexerWildcardExpression(IndexerWildcard wildcard);
    [CompilerGeneratedAttribute]
public IndexerWildcard get_Wildcard();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.IndexOfMatchExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Corpus>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    public Expression Corpus { get; }
    public Regex Regex { get; }
    public IndexOfMatchExpression(Expression corpus, Regex regex);
    [CompilerGeneratedAttribute]
public Expression get_Corpus();
    [CompilerGeneratedAttribute]
public Regex get_Regex();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.ItemElement : Element {
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public Expression Value { get; }
    public ItemElement(Expression value);
    [CompilerGeneratedAttribute]
public Expression get_Value();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.LambdaExpression : Expression {
    [CompilerGeneratedAttribute]
private ParameterExpression[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Body>k__BackingField;
    public ParameterExpression[] Parameters { get; }
    public Expression Body { get; }
    public LambdaExpression(ParameterExpression[] parameters, Expression body);
    [CompilerGeneratedAttribute]
public ParameterExpression[] get_Parameters();
    [CompilerGeneratedAttribute]
public Expression get_Body();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.LocalNameExpression : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public LocalNameExpression(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual string ToString();
}
internal abstract class Serilog.Expressions.Ast.Member : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.ObjectExpression : Expression {
    [CompilerGeneratedAttribute]
private Member[] <Members>k__BackingField;
    public Member[] Members { get; }
    public ObjectExpression(Member[] members);
    [CompilerGeneratedAttribute]
public Member[] get_Members();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.ParameterExpression : Expression {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public ParameterExpression(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.PropertyMember : Member {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public string Name { get; }
    public Expression Value { get; }
    public PropertyMember(string name, Expression value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Expression get_Value();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.SpreadElement : Element {
    [CompilerGeneratedAttribute]
private Expression <Content>k__BackingField;
    public Expression Content { get; }
    public SpreadElement(Expression content);
    [CompilerGeneratedAttribute]
public Expression get_Content();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Ast.SpreadMember : Member {
    [CompilerGeneratedAttribute]
private Expression <Content>k__BackingField;
    public Expression Content { get; }
    public SpreadMember(Expression content);
    [CompilerGeneratedAttribute]
public Expression get_Content();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.BuiltInProperty : object {
    public static string Exception;
    public static string Level;
    public static string Timestamp;
    public static string Message;
    public static string MessageTemplate;
    public static string Properties;
    public static string Renderings;
    public static string EventId;
    public static string TraceId;
    public static string SpanId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Arrays.ConstantArrayEvaluator : IdentityTransformer {
    private static ConstantArrayEvaluator Instance;
    private static ConstantArrayEvaluator();
    public static Expression Rewrite(Expression expression);
    protected virtual Expression Transform(ArrayExpression ax);
}
internal static class Serilog.Expressions.Compilation.DefaultFunctionNameResolver : object {
    [NullableContextAttribute("1")]
public static NameResolver Build(NameResolver additionalNameResolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Compilation.ExpressionCompiler : object {
    public static Expression Translate(Expression expression);
    public static Evaluatable Compile(Expression expression, IFormatProvider formatProvider, NameResolver nameResolver);
}
public static class Serilog.Expressions.Compilation.Linq.EventIdHash : object {
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static UInt32 Compute(string messageTemplate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Linq.ExpressionConstantMapper : ExpressionVisitor {
    private IDictionary`2<object, Expression> _mapping;
    public ExpressionConstantMapper(IDictionary`2<object, Expression> mapping);
    protected virtual Expression VisitConstant(ConstantExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Compilation.Linq.Intrinsics : object {
    private static LogEventPropertyValue NegativeOne;
    private static LogEventPropertyValue Tombstone;
    private static Intrinsics();
    public static List`1<LogEventPropertyValue> CollectSequenceElements(LogEventPropertyValue[] elements);
    [NullableContextAttribute("2")]
public static List`1<LogEventPropertyValue> ExtendSequenceValueWithItem(List`1<LogEventPropertyValue> elements, LogEventPropertyValue element);
    [NullableContextAttribute("2")]
public static List`1<LogEventPropertyValue> ExtendSequenceValueWithSpread(List`1<LogEventPropertyValue> elements, LogEventPropertyValue content);
    public static LogEventPropertyValue ConstructSequenceValue(List`1<LogEventPropertyValue> elements);
    public static List`1<LogEventProperty> CollectStructureProperties(String[] names, LogEventPropertyValue[] values);
    public static LogEventPropertyValue ConstructStructureValue(List`1<LogEventProperty> properties);
    public static List`1<LogEventProperty> ExtendStructureValueWithSpread(List`1<LogEventProperty> properties, LogEventPropertyValue content);
    public static List`1<LogEventProperty> ExtendStructureValueWithProperty(List`1<LogEventProperty> properties, string name, LogEventPropertyValue value);
    public static LogEventPropertyValue CompleteStructureValue(List`1<LogEventProperty> properties);
    public static bool CoerceToScalarBoolean(LogEventPropertyValue value);
    public static LogEventPropertyValue IndexOfMatch(LogEventPropertyValue value, Regex regex);
    public static LogEventPropertyValue GetPropertyValue(EvaluationContext ctx, string propertyName);
    public static LogEventPropertyValue GetLocalValue(EvaluationContext ctx, string localName);
    public static LogEventPropertyValue TryGetStructurePropertyValue(StringComparison sc, LogEventPropertyValue maybeStructure, string name);
    public static string RenderMessage(CompiledMessageToken formatter, EvaluationContext ctx);
    [NullableContextAttribute("2")]
public static LogEventPropertyValue GetRenderings(LogEvent logEvent, IFormatProvider formatProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Serilog.Expressions.Compilation.Linq.LinqExpressionCompiler : SerilogExpressionTransformer`1<Expression> {
    private NameResolver _nameResolver;
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    private static MethodInfo CollectSequenceElementsMethod;
    private static MethodInfo ExtendSequenceValueWithSpreadMethod;
    private static MethodInfo ExtendSequenceValueWithItemMethod;
    private static MethodInfo ConstructSequenceValueMethod;
    private static MethodInfo CollectStructurePropertiesMethod;
    private static MethodInfo ConstructStructureValueMethod;
    private static MethodInfo CompleteStructureValueMethod;
    private static MethodInfo ExtendStructureValueWithSpreadMethod;
    private static MethodInfo ExtendStructureValueWithPropertyMethod;
    private static MethodInfo CoerceToScalarBooleanMethod;
    private static MethodInfo IndexOfMatchMethod;
    private static MethodInfo TryGetStructurePropertyValueMethod;
    private static PropertyInfo EvaluationContextLogEventProperty;
    [CompilerGeneratedAttribute]
private ParameterExpression <Context>k__BackingField;
    private ParameterExpression Context { get; }
    private LinqExpressionCompiler(IFormatProvider formatProvider, NameResolver nameResolver);
    private static LinqExpressionCompiler();
    [CompilerGeneratedAttribute]
private ParameterExpression get_Context();
    public static Evaluatable Compile(Expression expression, IFormatProvider formatProvider, NameResolver nameResolver);
    private Expression Splice(Expression`1<Evaluatable> lambda);
    protected virtual Expression Transform(CallExpression call);
    private static string DescribeRequirements(IReadOnlyList`1<ValueTuple`2<string, bool>> parameters);
    private static Expression CompileLogical(Func`3<Expression, Expression, Expression> apply, Expression lhs, Expression rhs);
    protected virtual Expression Transform(AccessorExpression spx);
    protected virtual Expression Transform(ConstantExpression cx);
    protected virtual Expression Transform(AmbientNameExpression px);
    protected virtual Expression Transform(LocalNameExpression nlx);
    protected virtual Expression Transform(LambdaExpression lmx);
    protected virtual Expression Transform(ParameterExpression prx);
    protected virtual Expression Transform(IndexerWildcardExpression wx);
    protected virtual Expression Transform(ArrayExpression ax);
    protected virtual Expression Transform(ObjectExpression ox);
    protected virtual Expression Transform(IndexerExpression ix);
    protected virtual Expression Transform(IndexOfMatchExpression mx);
    [CompilerGeneratedAttribute]
internal static string <DescribeRequirements>g__DescribeArgument|22_0(ValueTuple`2<string, bool> p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Linq.ParameterReplacementVisitor : ExpressionVisitor {
    private ParameterExpression[] _from;
    private ParameterExpression[] _to;
    private ParameterReplacementVisitor(ParameterExpression[] from, ParameterExpression[] to);
    public static Expression ReplaceParameters(LambdaExpression lambda, ParameterExpression[] newParameters);
    protected virtual Expression VisitParameter(ParameterExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.OrderedNameResolver : NameResolver {
    private NameResolver[] _orderedResolvers;
    public OrderedNameResolver(IEnumerable`1<NameResolver> orderedResolvers);
    public virtual bool TryResolveFunctionName(string name, MethodInfo& implementation);
    public virtual bool TryBindFunctionParameter(ParameterInfo parameter, Object& boundValue);
    public virtual bool TryResolveBuiltInPropertyName(string alias, String& target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Compilation.Pattern : object {
    public static bool IsAmbientProperty(Expression expression, string name, bool isBuiltIn);
    public static bool IsStringConstant(Expression expression, String& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Properties.PropertiesObjectAccessorTransformer : IdentityTransformer {
    public static Expression Rewrite(Expression actual);
    protected virtual Expression Transform(AccessorExpression ax);
    protected virtual Expression Transform(IndexerExpression ix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Text.LikeSyntaxTransformer : IdentityTransformer {
    private static LikeSyntaxTransformer Instance;
    private static LikeSyntaxTransformer();
    public static Expression Rewrite(Expression expression);
    protected virtual Expression Transform(CallExpression call);
    private Expression TryCompileLikeExpression(bool ignoreCase, Expression corpus, Expression like);
    private static string LikeToRegex(string like);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Text.TextMatchingTransformer : IdentityTransformer {
    private static TextMatchingTransformer Instance;
    private static TextMatchingTransformer();
    public static Expression Rewrite(Expression expression);
    protected virtual Expression Transform(CallExpression call);
    private Expression TryCompileIndexOfMatch(bool ignoreCase, Expression corpus, Expression regex);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Serilog.Expressions.Compilation.Transformations.IdentityTransformer : SerilogExpressionTransformer`1<Expression> {
    private bool TryTransform(Expression expr, Expression& result);
    protected virtual Expression Transform(CallExpression call);
    protected virtual Expression Transform(ConstantExpression cx);
    protected virtual Expression Transform(AmbientNameExpression px);
    protected virtual Expression Transform(LocalNameExpression nlx);
    protected virtual Expression Transform(AccessorExpression spx);
    protected virtual Expression Transform(LambdaExpression lmx);
    protected virtual Expression Transform(ParameterExpression prx);
    protected virtual Expression Transform(IndexerWildcardExpression wx);
    protected virtual Expression Transform(ArrayExpression ax);
    protected virtual Expression Transform(ObjectExpression ox);
    protected virtual Expression Transform(IndexerExpression ix);
    protected virtual Expression Transform(IndexOfMatchExpression mx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Transformations.NodeReplacer : IdentityTransformer {
    private Expression _source;
    private Expression _dest;
    private NodeReplacer(Expression source, Expression dest);
    public static Expression Replace(Expression expr, Expression source, Expression dest);
    protected virtual Expression Transform(Expression x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Serilog.Expressions.Compilation.Transformations.SerilogExpressionTransformer`1 : object {
    protected virtual TResult Transform(Expression expression);
    protected abstract virtual TResult Transform(CallExpression call);
    protected abstract virtual TResult Transform(ConstantExpression cx);
    protected abstract virtual TResult Transform(AmbientNameExpression px);
    protected abstract virtual TResult Transform(LocalNameExpression nlx);
    protected abstract virtual TResult Transform(AccessorExpression spx);
    protected abstract virtual TResult Transform(LambdaExpression lmx);
    protected abstract virtual TResult Transform(ParameterExpression prx);
    protected abstract virtual TResult Transform(IndexerWildcardExpression wx);
    protected abstract virtual TResult Transform(ArrayExpression ax);
    protected abstract virtual TResult Transform(ObjectExpression ox);
    protected abstract virtual TResult Transform(IndexerExpression ix);
    protected abstract virtual TResult Transform(IndexOfMatchExpression mx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Variadics.VariadicCallRewriter : IdentityTransformer {
    private static VariadicCallRewriter Instance;
    private static VariadicCallRewriter();
    public static Expression Rewrite(Expression expression);
    protected virtual Expression Transform(CallExpression call);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Compilation.Wildcards.WildcardComprehensionTransformer : IdentityTransformer {
    private int _nextParameter;
    public static Expression Rewrite(Expression root);
    protected virtual Expression Transform(CallExpression lx);
    protected virtual Expression Transform(IndexerExpression ix);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Serilog.Expressions.Compilation.Wildcards.WildcardSearch : SerilogExpressionTransformer`1<IndexerExpression> {
    private static WildcardSearch Instance;
    private static WildcardSearch();
    public static IndexerExpression FindWildcardIndexer(Expression fx);
    protected virtual IndexerExpression Transform(IndexerExpression ix);
    protected virtual IndexerExpression Transform(ConstantExpression cx);
    protected virtual IndexerExpression Transform(AmbientNameExpression px);
    protected virtual IndexerExpression Transform(LocalNameExpression nlx);
    protected virtual IndexerExpression Transform(AccessorExpression spx);
    protected virtual IndexerExpression Transform(LambdaExpression lmx);
    protected virtual IndexerExpression Transform(ParameterExpression prx);
    protected virtual IndexerExpression Transform(IndexerWildcardExpression wx);
    protected virtual IndexerExpression Transform(ArrayExpression ax);
    protected virtual IndexerExpression Transform(CallExpression call);
    protected virtual IndexerExpression Transform(IndexOfMatchExpression mx);
    protected virtual IndexerExpression Transform(ObjectExpression ox);
}
public class Serilog.Expressions.CompiledExpression : MulticastDelegate {
    public CompiledExpression(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual LogEventPropertyValue Invoke(LogEvent logEvent);
    public virtual IAsyncResult BeginInvoke(LogEvent logEvent, AsyncCallback callback, object object);
    public virtual LogEventPropertyValue EndInvoke(IAsyncResult result);
}
internal class Serilog.Expressions.Evaluatable : MulticastDelegate {
    public Evaluatable(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual LogEventPropertyValue Invoke(EvaluationContext ctx);
    public virtual IAsyncResult BeginInvoke(EvaluationContext ctx, AsyncCallback callback, object object);
    public virtual LogEventPropertyValue EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Serilog.Expressions.EvaluationContext : ValueType {
    [CompilerGeneratedAttribute]
private LogEvent <LogEvent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Locals <Locals>k__BackingField;
    public LogEvent LogEvent { get; }
    [NullableAttribute("2")]
public Locals Locals { get; }
    public EvaluationContext(LogEvent logEvent, Locals locals);
    [CompilerGeneratedAttribute]
public LogEvent get_LogEvent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Locals get_Locals();
}
public static class Serilog.Expressions.ExpressionResult : object {
    [NullableContextAttribute("2")]
public static bool IsTrue(LogEventPropertyValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Serilog.Expressions.Helpers : object {
    [ExtensionAttribute]
public static bool Contains(string this, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string Replace(string this, string oldValue, string newValue, StringComparison comparisonType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Serilog.Expressions.LoggingFilterSwitch : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Tuple`2 modreq(System.Runtime.CompilerServices.IsVolatile) _filter;
    public string Expression { get; public set; }
    public LoggingFilterSwitch(string expression);
    public string get_Expression();
    public void set_Expression(string value);
    [NullableContextAttribute("1")]
public sealed virtual bool IsEnabled(LogEvent logEvent);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Serilog.Expressions.NameResolver : object {
    public virtual bool TryResolveFunctionName(string name, MethodInfo& implementation);
    public virtual bool TryBindFunctionParameter(ParameterInfo parameter, Object& boundValue);
    public virtual bool TryResolveBuiltInPropertyName(string alias, String& target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Operators : object {
    [CompilerGeneratedAttribute]
private static StringComparer <OperatorComparer>k__BackingField;
    public static string OpCoalesce;
    public static string OpConcat;
    public static string OpContains;
    public static string OpElementAt;
    public static string OpEndsWith;
    public static string OpIndexOf;
    public static string OpIndexOfMatch;
    public static string OpInspect;
    public static string OpIsMatch;
    public static string OpIsDefined;
    public static string OpLastIndexOf;
    public static string OpLength;
    public static string OpNow;
    public static string OpReplace;
    public static string OpRound;
    public static string OpStartsWith;
    public static string OpSubstring;
    public static string OpTagOf;
    public static string OpToString;
    public static string OpTypeOf;
    public static string OpUndefined;
    public static string OpUtcDateTime;
    public static string IntermediateOpLike;
    public static string IntermediateOpNotLike;
    public static string RuntimeOpAdd;
    public static string RuntimeOpSubtract;
    public static string RuntimeOpMultiply;
    public static string RuntimeOpDivide;
    public static string RuntimeOpModulo;
    public static string RuntimeOpPower;
    public static string RuntimeOpAnd;
    public static string RuntimeOpOr;
    public static string RuntimeOpLessThanOrEqual;
    public static string RuntimeOpLessThan;
    public static string RuntimeOpGreaterThan;
    public static string RuntimeOpGreaterThanOrEqual;
    public static string RuntimeOpEqual;
    public static string RuntimeOpNotEqual;
    public static string RuntimeOpNegate;
    public static string RuntimeOpNot;
    public static string RuntimeOpAny;
    public static string RuntimeOpAll;
    public static string RuntimeOpIsNull;
    public static string RuntimeOpIsNotNull;
    public static string RuntimeOpIn;
    public static string RuntimeOpNotIn;
    public static string RuntimeOpStrictNot;
    public static string RuntimeOpIfThenElse;
    public static HashSet`1<string> WildcardComparators;
    private static StringComparer OperatorComparer { get; }
    private static Operators();
    [CompilerGeneratedAttribute]
private static StringComparer get_OperatorComparer();
    public static bool SameOperator(string op1, string op2);
    public static string ToRuntimeWildcardOperator(IndexerWildcard wildcard);
}
internal static class Serilog.Expressions.Parsing.Combinators : object {
    [NullableContextAttribute("1")]
public static TokenListParser`2<TKind, TResult> ChainModified(TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, TResult> operand, TokenListParser`2<TKind, TModifier> modify, Func`5<TOperator, TResult, TResult, TModifier, TResult> apply);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Serilog.Expressions.Parsing.ExpressionKeyword : ValueType {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionToken <Token>k__BackingField;
    public string Text { get; }
    public ExpressionToken Token { get; }
    public ExpressionKeyword(string text, ExpressionToken token);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public ExpressionToken get_Token();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Parsing.ExpressionParser : object {
    private ExpressionTokenizer _tokenizer;
    public Expression Parse(string expression);
    public bool TryParse(string filterExpression, Expression& root, String& error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Parsing.ExpressionTextParsers : object {
    private static TextParser`1<ExpressionToken> LessOrEqual;
    private static TextParser`1<ExpressionToken> GreaterOrEqual;
    private static TextParser`1<ExpressionToken> NotEqual;
    private static TextParser`1<ExpressionToken> Spread;
    public static TextParser`1<ExpressionToken> CompoundOperator;
    public static TextParser`1<string> HexInteger;
    private static TextParser`1<char> StringContentChar;
    public static TextParser`1<string> String;
    public static TextParser`1<TextSpan> Real;
    private static ExpressionTextParsers();
}
internal enum Serilog.Expressions.Parsing.ExpressionToken : Enum {
    public int value__;
    public static ExpressionToken None;
    public static ExpressionToken Identifier;
    [TokenAttribute]
public static ExpressionToken BuiltInIdentifier;
    public static ExpressionToken String;
    public static ExpressionToken Number;
    [TokenAttribute]
public static ExpressionToken HexNumber;
    [TokenAttribute]
public static ExpressionToken Comma;
    [TokenAttribute]
public static ExpressionToken Period;
    [TokenAttribute]
public static ExpressionToken Spread;
    [TokenAttribute]
public static ExpressionToken LBracket;
    [TokenAttribute]
public static ExpressionToken RBracket;
    [TokenAttribute]
public static ExpressionToken LParen;
    [TokenAttribute]
public static ExpressionToken RParen;
    [TokenAttribute]
public static ExpressionToken LBrace;
    [TokenAttribute]
public static ExpressionToken RBrace;
    [TokenAttribute]
public static ExpressionToken Colon;
    [TokenAttribute]
public static ExpressionToken QuestionMark;
    [TokenAttribute]
public static ExpressionToken Plus;
    [TokenAttribute]
public static ExpressionToken Minus;
    [TokenAttribute]
public static ExpressionToken Asterisk;
    [TokenAttribute]
public static ExpressionToken ForwardSlash;
    [TokenAttribute]
public static ExpressionToken Percent;
    [TokenAttribute]
public static ExpressionToken Caret;
    [TokenAttribute]
public static ExpressionToken LessThan;
    [TokenAttribute]
public static ExpressionToken LessThanOrEqual;
    [TokenAttribute]
public static ExpressionToken GreaterThan;
    [TokenAttribute]
public static ExpressionToken GreaterThanOrEqual;
    [TokenAttribute]
public static ExpressionToken Equal;
    [TokenAttribute]
public static ExpressionToken NotEqual;
    [TokenAttribute]
public static ExpressionToken And;
    [TokenAttribute]
public static ExpressionToken In;
    [TokenAttribute]
public static ExpressionToken Is;
    [TokenAttribute]
public static ExpressionToken Like;
    [TokenAttribute]
public static ExpressionToken Not;
    [TokenAttribute]
public static ExpressionToken Or;
    [TokenAttribute]
public static ExpressionToken True;
    [TokenAttribute]
public static ExpressionToken False;
    [TokenAttribute]
public static ExpressionToken Null;
    [TokenAttribute]
public static ExpressionToken If;
    [TokenAttribute]
public static ExpressionToken Then;
    [TokenAttribute]
public static ExpressionToken Else;
    [TokenAttribute]
public static ExpressionToken CI;
    [TokenAttribute]
public static ExpressionToken Text;
    [TokenAttribute]
public static ExpressionToken DoubleLBrace;
    [TokenAttribute]
public static ExpressionToken DoubleRBrace;
    [TokenAttribute]
public static ExpressionToken LBraceHash;
    [TokenAttribute]
public static ExpressionToken Format;
    [TokenAttribute]
public static ExpressionToken End;
    [TokenAttribute]
public static ExpressionToken Each;
    [TokenAttribute]
public static ExpressionToken Delimit;
}
internal class Serilog.Expressions.Parsing.ExpressionTokenizer : Tokenizer`1<ExpressionToken> {
    [NullableAttribute("1")]
private ExpressionToken[] _singleCharOps;
    [NullableAttribute("1")]
private ExpressionKeyword[] _keywords;
    public TokenList`1<ExpressionToken> GreedyTokenize(TextSpan textSpan);
    public IEnumerable`1<Result`1<ExpressionToken>> LazyTokenize(TextSpan span);
    [IteratorStateMachineAttribute("Serilog.Expressions.Parsing.ExpressionTokenizer/<Tokenize>d__5")]
protected virtual IEnumerable`1<Result`1<ExpressionToken>> Tokenize(TextSpan stringSpan);
    private bool IsDelimiter(Result`1<char> next);
    private bool TryGetKeyword(TextSpan span, ExpressionToken& keyword);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Parsing.ExpressionTokenParsers : object {
    private static TokenListParser`2<ExpressionToken, string> Add;
    private static TokenListParser`2<ExpressionToken, string> Subtract;
    private static TokenListParser`2<ExpressionToken, string> Multiply;
    private static TokenListParser`2<ExpressionToken, string> Divide;
    private static TokenListParser`2<ExpressionToken, string> Modulo;
    private static TokenListParser`2<ExpressionToken, string> Power;
    private static TokenListParser`2<ExpressionToken, string> And;
    private static TokenListParser`2<ExpressionToken, string> Or;
    private static TokenListParser`2<ExpressionToken, string> Lte;
    private static TokenListParser`2<ExpressionToken, string> Lt;
    private static TokenListParser`2<ExpressionToken, string> Gt;
    private static TokenListParser`2<ExpressionToken, string> Gte;
    private static TokenListParser`2<ExpressionToken, string> Eq;
    private static TokenListParser`2<ExpressionToken, string> Neq;
    private static TokenListParser`2<ExpressionToken, string> Negate;
    private static TokenListParser`2<ExpressionToken, string> Not;
    private static TokenListParser`2<ExpressionToken, string> Like;
    private static TokenListParser`2<ExpressionToken, string> NotLike;
    private static TokenListParser`2<ExpressionToken, string> In;
    private static TokenListParser`2<ExpressionToken, string> NotIn;
    private static TokenListParser`2<ExpressionToken, Func`2<Expression, Expression>> PropertyPathStep;
    private static TokenListParser`2<ExpressionToken, Expression> Wildcard;
    private static TokenListParser`2<ExpressionToken, Func`2<Expression, Expression>> PropertyPathIndexerStep;
    private static TokenListParser`2<ExpressionToken, Expression> Function;
    private static TokenListParser`2<ExpressionToken, Element> ArrayElement;
    private static TokenListParser`2<ExpressionToken, Expression> ArrayLiteral;
    private static TokenListParser`2<ExpressionToken, Member> IdentifierMember;
    private static TokenListParser`2<ExpressionToken, Member> StringMember;
    private static TokenListParser`2<ExpressionToken, Member> SpreadMember;
    private static TokenListParser`2<ExpressionToken, Member> ObjectMember;
    private static TokenListParser`2<ExpressionToken, Expression> ObjectLiteral;
    private static TokenListParser`2<ExpressionToken, Expression> RootProperty;
    private static TokenListParser`2<ExpressionToken, Expression> String;
    private static TokenListParser`2<ExpressionToken, Expression> HexNumber;
    private static TokenListParser`2<ExpressionToken, Expression> Number;
    private static TokenListParser`2<ExpressionToken, Expression> Conditional;
    private static TokenListParser`2<ExpressionToken, Expression> Literal;
    private static TokenListParser`2<ExpressionToken, Expression> Item;
    private static TokenListParser`2<ExpressionToken, Expression> Factor;
    private static TokenListParser`2<ExpressionToken, Expression> Path;
    private static TokenListParser`2<ExpressionToken, Expression> Operand;
    private static TokenListParser`2<ExpressionToken, Expression> InnerTerm;
    private static TokenListParser`2<ExpressionToken, Expression> Term;
    private static TokenListParser`2<ExpressionToken, Expression> Comparand;
    private static TokenListParser`2<ExpressionToken, Expression> Comparison;
    private static TokenListParser`2<ExpressionToken, Expression> Conjunction;
    private static TokenListParser`2<ExpressionToken, Expression> Disjunction;
    public static TokenListParser`2<ExpressionToken, Expression> Expr;
    private static ExpressionTokenParsers();
    [NullableContextAttribute("0")]
public static TokenListParserResult`2<ExpressionToken, Expression> TryParse(TokenList`1<ExpressionToken> input);
    [NullableContextAttribute("0")]
public static TokenListParserResult`2<ExpressionToken, Expression> TryPartialParse(TokenList`1<ExpressionToken> input);
    private static Expression MakeBinary(string operatorName, Expression leftOperand, Expression rightOperand);
    private static Expression MakeUnary(string operatorName, Expression operand);
}
[ExtensionAttribute]
internal static class Serilog.Expressions.Parsing.ParserExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TokenListParser`2<TTokenKind, TResult> SelectCatch(TokenListParser`2<TTokenKind, TArg> parser, Func`2<TArg, TResult> trySelector, string errorMessage);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Runtime.Coerce : object {
    [NullableAttribute("1")]
private static Type[] NumericTypes;
    private static Coerce();
    public static bool Numeric(LogEventPropertyValue value, Decimal& numeric);
    public static bool Boolean(LogEventPropertyValue value, Boolean& boolean);
    public static bool IsTrue(LogEventPropertyValue value);
    public static bool String(LogEventPropertyValue value, String& str);
    [NullableContextAttribute("1")]
public static bool Predicate(LogEventPropertyValue value, Func`2& predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Expressions.Runtime.Locals : object {
    [NullableAttribute("2")]
private Locals _others;
    private string _name;
    private LogEventPropertyValue _value;
    private Locals(Locals others, string name, LogEventPropertyValue value);
    public static Locals Set(Locals others, string name, LogEventPropertyValue value);
    public static bool TryGetValue(Locals locals, string name, LogEventPropertyValue& value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Serilog.Expressions.Runtime.RuntimeOperators : object {
    [NullableAttribute("1")]
private static LogEventPropertyValue ConstantTrue;
    [NullableAttribute("1")]
private static LogEventPropertyValue ConstantFalse;
    private static RuntimeOperators();
    [NullableContextAttribute("1")]
internal static LogEventPropertyValue ScalarBoolean(bool value);
    public static LogEventPropertyValue Undefined();
    public static LogEventPropertyValue _Internal_Add(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Subtract(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Multiply(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Divide(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Modulo(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Power(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_And(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Or(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_LessThanOrEqual(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_LessThan(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_GreaterThan(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_GreaterThanOrEqual(LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Equal(StringComparison sc, LogEventPropertyValue left, LogEventPropertyValue right);
    private static bool UnboxedEqualHelper(StringComparison sc, LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_In(StringComparison sc, LogEventPropertyValue item, LogEventPropertyValue collection);
    public static LogEventPropertyValue _Internal_NotIn(StringComparison sc, LogEventPropertyValue item, LogEventPropertyValue collection);
    public static LogEventPropertyValue _Internal_NotEqual(StringComparison sc, LogEventPropertyValue left, LogEventPropertyValue right);
    public static LogEventPropertyValue _Internal_Negate(LogEventPropertyValue value);
    public static LogEventPropertyValue Round(LogEventPropertyValue value, LogEventPropertyValue places);
    public static LogEventPropertyValue _Internal_Not(LogEventPropertyValue value);
    public static LogEventPropertyValue _Internal_StrictNot(LogEventPropertyValue value);
    public static LogEventPropertyValue Contains(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    public static LogEventPropertyValue IndexOf(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    public static LogEventPropertyValue LastIndexOf(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    public static LogEventPropertyValue Length(LogEventPropertyValue value);
    public static LogEventPropertyValue StartsWith(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    public static LogEventPropertyValue EndsWith(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    [NullableContextAttribute("1")]
public static LogEventPropertyValue IsDefined(LogEventPropertyValue value);
    public static LogEventPropertyValue ElementAt(StringComparison sc, LogEventPropertyValue collection, LogEventPropertyValue index);
    public static LogEventPropertyValue _Internal_Any(LogEventPropertyValue collection, LogEventPropertyValue predicate);
    public static LogEventPropertyValue _Internal_All(LogEventPropertyValue collection, LogEventPropertyValue predicate);
    public static LogEventPropertyValue TagOf(LogEventPropertyValue value);
    [NullableContextAttribute("1")]
public static LogEventPropertyValue TypeOf(LogEventPropertyValue value);
    [NullableContextAttribute("1")]
public static LogEventPropertyValue _Internal_IsNull(LogEventPropertyValue value);
    [NullableContextAttribute("1")]
public static LogEventPropertyValue _Internal_IsNotNull(LogEventPropertyValue value);
    public static LogEventPropertyValue Coalesce(LogEventPropertyValue value0, LogEventPropertyValue value1);
    public static LogEventPropertyValue Substring(LogEventPropertyValue value, LogEventPropertyValue startIndex, LogEventPropertyValue length);
    public static LogEventPropertyValue Concat(LogEventPropertyValue string0, LogEventPropertyValue string1);
    public static LogEventPropertyValue Replace(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle, LogEventPropertyValue replacement);
    public static LogEventPropertyValue IndexOfMatch(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    public static LogEventPropertyValue IsMatch(StringComparison sc, LogEventPropertyValue haystack, LogEventPropertyValue needle);
    public static LogEventPropertyValue _Internal_IfThenElse(LogEventPropertyValue condition, LogEventPropertyValue consequent, LogEventPropertyValue alternative);
    public static LogEventPropertyValue ToString(IFormatProvider formatProvider, LogEventPropertyValue value, LogEventPropertyValue format);
    public static LogEventPropertyValue UtcDateTime(LogEventPropertyValue dateTime);
    public static LogEventPropertyValue Now();
    public static LogEventPropertyValue Inspect(LogEventPropertyValue value, LogEventPropertyValue deep);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Serilog.Expressions.SerilogExpression : object {
    public static CompiledExpression Compile(string expression, IFormatProvider formatProvider, NameResolver nameResolver);
    public static bool TryCompile(string expression, CompiledExpression& result, String& error);
    public static bool TryCompile(string expression, IFormatProvider formatProvider, NameResolver nameResolver, CompiledExpression& result, String& error);
    private static bool TryCompileImpl(string expression, IFormatProvider formatProvider, NameResolver nameResolver, CompiledExpression& result, String& error);
    public static string EscapeLikeExpressionContent(string text);
    public static string EscapeStringContent(string text);
    public static bool IsValidIdentifier(string identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Expressions.StaticMemberNameResolver : NameResolver {
    private IReadOnlyDictionary`2<string, MethodInfo> _methods;
    public StaticMemberNameResolver(Type type);
    public virtual bool TryResolveFunctionName(string name, MethodInfo& implementation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Serilog.LoggerEnrichmentConfigurationExtensions : object {
    [ExtensionAttribute]
public static LoggerConfiguration When(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration, string expression, Action`1<LoggerEnrichmentConfiguration> configureEnricher);
    [ExtensionAttribute]
public static LoggerConfiguration WithComputed(LoggerEnrichmentConfiguration loggerEnrichmentConfiguration, string propertyName, string expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Serilog.LoggerFilterConfigurationExtensions : object {
    [ExtensionAttribute]
public static LoggerConfiguration ByIncludingOnly(LoggerFilterConfiguration loggerFilterConfiguration, string expression);
    [ExtensionAttribute]
public static LoggerConfiguration ByExcluding(LoggerFilterConfiguration loggerFilterConfiguration, string expression);
    [ExtensionAttribute]
public static LoggerConfiguration ControlledBy(LoggerFilterConfiguration loggerFilterConfiguration, LoggingFilterSwitch switch);
}
[ExtensionAttribute]
public static class Serilog.LoggerSinkConfigurationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LoggerConfiguration Conditional(LoggerSinkConfiguration loggerSinkConfiguration, string expression, Action`1<LoggerSinkConfiguration> configureSink);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Serilog.ParserConstruction.Combinators : object {
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Apply(TokenListParser`2<TKind, Token`1<TKind>> parser, TextParser`1<U> valueParser);
    [ExtensionAttribute]
public static TextParser`1<T> AtEnd(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> AtEnd(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T[]> AtLeastOnce(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> AtLeastOnceDelimitedBy(TokenListParser`2<TKind, T> parser, TokenListParser`2<TKind, U> delimiter);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> IgnoreThen(TokenListParser`2<TKind, T> first, TokenListParser`2<TKind, U> second);
    [ExtensionAttribute]
public static TextParser`1<U> IgnoreThen(TextParser`1<T> first, TextParser`1<U> second);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> Many(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T[]> Many(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T[]> ManyDelimitedBy(TokenListParser`2<TKind, T> parser, TokenListParser`2<TKind, U> delimiter, TokenListParser`2<TKind, U> end);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Named(TokenListParser`2<TKind, T> parser, string name);
    [ExtensionAttribute]
public static TextParser`1<T> Named(TextParser`1<T> parser, string name);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> OptionalOrDefault(TokenListParser`2<TKind, T> parser, T defaultValue);
    [ExtensionAttribute]
public static TextParser`1<T> OptionalOrDefault(TextParser`1<T> parser, T defaultValue);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Or(TokenListParser`2<TKind, T> lhs, TokenListParser`2<TKind, T> rhs);
    [ExtensionAttribute]
public static TextParser`1<T> Or(TextParser`1<T> lhs, TextParser`1<T> rhs);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Select(TokenListParser`2<TKind, T> parser, Func`2<T, U> selector);
    [ExtensionAttribute]
public static TextParser`1<U> Select(TextParser`1<T> parser, Func`2<T, U> selector);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Cast(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, V> SelectMany(TokenListParser`2<TKind, T> parser, Func`2<T, TokenListParser`2<TKind, U>> selector, Func`3<T, U, V> projector);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Then(TokenListParser`2<TKind, T> first, Func`2<T, TokenListParser`2<TKind, U>> second);
    [ExtensionAttribute]
public static TextParser`1<U> Then(TextParser`1<T> first, Func`2<T, TextParser`1<U>> second);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, T> Try(TokenListParser`2<TKind, T> parser);
    [ExtensionAttribute]
public static TextParser`1<T> Try(TextParser`1<T> parser);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, U> Value(TokenListParser`2<TKind, T> parser, U value);
    [ExtensionAttribute]
public static TextParser`1<U> Value(TextParser`1<T> parser, U value);
    [ExtensionAttribute]
public static TokenListParser`2<TKind, TResult> Chain(TokenListParser`2<TKind, TResult> parser, TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, TOperand> operand, Func`4<TOperator, TResult, TOperand, TResult> apply);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Display.Presentation : object {
    private static string FormatKind(object kind);
    private static TokenAttribute TryGetTokenAttribute(Type type);
    [NullableContextAttribute("2")]
private static TokenAttribute TryGetTokenAttribute(TKind kind);
    public static string FormatExpectation(TKind kind);
    public static string FormatAppearance(TKind kind, string value);
    public static string FormatLiteral(char literal);
    public static string FormatLiteral(string literal);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("260")]
internal class Serilog.ParserConstruction.Display.TokenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Example>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Category { get; public set; }
    public string Example { get; public set; }
    public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_Example();
    [CompilerGeneratedAttribute]
public void set_Example(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
[IsReadOnlyAttribute]
internal class Serilog.ParserConstruction.Model.Position : ValueType {
    [CompilerGeneratedAttribute]
private int <Absolute>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private static Position <Zero>k__BackingField;
    public int Absolute { get; }
    public int Line { get; }
    public int Column { get; }
    public static Position Zero { get; }
    public static Position Empty { get; }
    public bool HasValue { get; }
    private Position(int absolute, int line, int column);
    private static Position();
    [CompilerGeneratedAttribute]
public int get_Absolute();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public static Position get_Zero();
    public static Position get_Empty();
    public bool get_HasValue();
    public Position Advance(char overChar);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Model.Result : object {
    public static Result`1<T> Empty(TextSpan remainder);
    [NullableContextAttribute("1")]
public static Result`1<T> Empty(TextSpan remainder, String[] expectations);
    [NullableContextAttribute("1")]
public static Result`1<T> Value(T value, TextSpan location, TextSpan remainder);
    public static Result`1<U> CastEmpty(Result`1<T> result);
    public static Result`1<T> CombineEmpty(Result`1<T> first, Result`1<T> second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.ParserConstruction.Model.Result`1 : ValueType {
    private T _value;
    [CompilerGeneratedAttribute]
private TextSpan <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Remainder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Expectations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Backtrack>k__BackingField;
    public TextSpan Location { get; }
    public TextSpan Remainder { get; }
    public bool HasValue { get; }
    public Position ErrorPosition { get; }
    [NullableAttribute("2")]
public string ErrorMessage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Expectations { get; }
    internal bool Backtrack { get; internal set; }
    public T Value { get; }
    internal Result`1(T value, TextSpan location, TextSpan remainder, bool backtrack);
    [NullableContextAttribute("2")]
internal Result`1(TextSpan remainder, string errorMessage, String[] expectations, bool backtrack);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextSpan get_Location();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextSpan get_Remainder();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValue();
    public Position get_ErrorPosition();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Expectations();
    internal bool IsPartial(TextSpan from);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_Backtrack();
    [CompilerGeneratedAttribute]
internal void set_Backtrack(bool value);
    public T get_Value();
    public virtual string ToString();
    public string FormatErrorMessageFragment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Serilog.ParserConstruction.Model.TextSpan : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("2")]
public string Source { get; }
    public Position Position { get; }
    public int Length { get; }
    public static TextSpan None { get; }
    public bool IsAtEnd { get; }
    public TextSpan(string source);
    public TextSpan(string source, Position position, int length);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public Position get_Position();
    [CompilerGeneratedAttribute]
public int get_Length();
    public static TextSpan get_None();
    public bool get_IsAtEnd();
    private void EnsureHasValue();
    [NullableContextAttribute("0")]
public Result`1<char> ConsumeChar();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TextSpan other);
    public static bool op_Equality(TextSpan lhs, TextSpan rhs);
    public static bool op_Inequality(TextSpan lhs, TextSpan rhs);
    public TextSpan Until(TextSpan next);
    private TextSpan First(int length);
    public virtual string ToString();
    public string ToStringValue();
    public bool EqualsValueIgnoreCase(string otherValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Serilog.ParserConstruction.Model.Token`1 : ValueType {
    [CompilerGeneratedAttribute]
private TKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public TKind Kind { get; }
    public TextSpan Span { get; }
    public Position Position { get; }
    private bool HasValue { get; }
    public Token`1(TKind kind, TextSpan span);
    [CompilerGeneratedAttribute]
public TKind get_Kind();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    public string ToStringValue();
    public Position get_Position();
    private bool get_HasValue();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class Serilog.ParserConstruction.Model.TokenList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Token`1[] _tokens;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static TokenList`1<TKind> <Empty>k__BackingField;
    public int Position { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TokenList`1<TKind> Empty { get; }
    public bool IsAtEnd { get; }
    public TokenList`1(Token`1[] tokens);
    private TokenList`1(Token`1[] tokens, int position);
    private static TokenList`1();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public static TokenList`1<TKind> get_Empty();
    public bool get_IsAtEnd();
    private void EnsureHasValue();
    public TokenListParserResult`2<TKind, Token`1<TKind>> ConsumeToken();
    [IteratorStateMachineAttribute("Serilog.ParserConstruction.Model.TokenList`1/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<Token`1<TKind>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TokenList`1<TKind> other);
    public static bool op_Equality(TokenList`1<TKind> lhs, TokenList`1<TKind> rhs);
    public static bool op_Inequality(TokenList`1<TKind> lhs, TokenList`1<TKind> rhs);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal Position ComputeEndOfInputPosition();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Model.TokenListParserResult : object {
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder);
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder, String[] expectations);
    public static TokenListParserResult`2<TKind, T> Empty(TokenList`1<TKind> remainder, string errorMessage);
    public static TokenListParserResult`2<TKind, T> Value(T value, TokenList`1<TKind> location, TokenList`1<TKind> remainder);
    public static TokenListParserResult`2<TKind, U> CastEmpty(TokenListParserResult`2<TKind, T> result);
    public static TokenListParserResult`2<TKind, T> CombineEmpty(TokenListParserResult`2<TKind, T> first, TokenListParserResult`2<TKind, T> second);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Serilog.ParserConstruction.Model.TokenListParserResult`2 : ValueType {
    [NullableAttribute("1")]
private T _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private TokenList`1<TKind> <Location>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private TokenList`1<TKind> <Remainder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <SubTokenErrorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Expectations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Backtrack>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TokenList`1<TKind> Location { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TokenList`1<TKind> Remainder { get; }
    public bool HasValue { get; }
    public Position ErrorPosition { get; }
    public Position SubTokenErrorPosition { get; }
    public string ErrorMessage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Expectations { get; }
    [NullableAttribute("1")]
public T Value { get; }
    internal bool Backtrack { get; internal set; }
    [NullableContextAttribute("1")]
internal TokenListParserResult`2(T value, TokenList`1<TKind> location, TokenList`1<TKind> remainder, bool backtrack);
    internal TokenListParserResult`2(TokenList`1<TKind> location, TokenList`1<TKind> remainder, Position errorPosition, string errorMessage, String[] expectations, bool backtrack);
    internal TokenListParserResult`2(TokenList`1<TKind> remainder, Position errorPosition, string errorMessage, String[] expectations, bool backtrack);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenList`1<TKind> get_Location();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TokenList`1<TKind> get_Remainder();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValue();
    public Position get_ErrorPosition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Position get_SubTokenErrorPosition();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Expectations();
    [NullableContextAttribute("1")]
public T get_Value();
    internal bool IsPartial(TokenList`1<TKind> from);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_Backtrack();
    [CompilerGeneratedAttribute]
internal void set_Backtrack(bool value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private string FormatErrorMessageFragment();
}
internal class Serilog.ParserConstruction.Model.Unit : ValueType {
    public static Unit Value { get; }
    public static Unit get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Parse : object {
    public static TokenListParser`2<TKind, T> Chain(TokenListParser`2<TKind, TOperator> operator, TokenListParser`2<TKind, T> operand, Func`4<TOperator, T, T, T> apply);
    public static TokenListParser`2<TKind, Unit> Not(TokenListParser`2<TKind, T> parser);
    public static TokenListParser`2<TKind, T> Ref(Func`1<TokenListParser`2<TKind, T>> reference);
    public static TextParser`1<T> Return(T value);
    public static TokenListParser`2<TKind, T> Return(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.ParserConstruction.ParseException : Exception {
    [CompilerGeneratedAttribute]
private Position <ErrorPosition>k__BackingField;
    public Position ErrorPosition { get; }
    public ParseException(string message, Position errorPosition);
    public ParseException(string message, Position errorPosition, Exception innerException);
    [CompilerGeneratedAttribute]
public Position get_ErrorPosition();
}
[ExtensionAttribute]
internal static class Serilog.ParserConstruction.ParserExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TokenListParserResult`2<TKind, T> TryParse(TokenListParser`2<TKind, T> parser, TokenList`1<TKind> input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Parsers.Character : object {
    [CompilerGeneratedAttribute]
private static TextParser`1<char> <Digit>k__BackingField;
    public static TextParser`1<char> Digit { get; }
    private static Character();
    private static TextParser`1<char> Matching(Func`2<char, bool> predicate, String[] expectations);
    public static TextParser`1<char> Matching(Func`2<char, bool> predicate, string name);
    private static TextParser`1<char> Except(Func`2<char, bool> predicate, string description);
    public static TextParser`1<char> EqualTo(char ch);
    public static TextParser`1<char> Except(char ch);
    [CompilerGeneratedAttribute]
public static TextParser`1<char> get_Digit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Parsers.Numerics : object {
    private static String[] ExpectedDigit;
    private static String[] ExpectedSignOrDigit;
    [CompilerGeneratedAttribute]
private static TextParser`1<UInt32> <NaturalUInt32>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextParser`1<TextSpan> <Integer>k__BackingField;
    public static TextParser`1<UInt32> NaturalUInt32 { get; }
    public static TextParser`1<TextSpan> Integer { get; }
    private static Numerics();
    [CompilerGeneratedAttribute]
public static TextParser`1<UInt32> get_NaturalUInt32();
    [CompilerGeneratedAttribute]
public static TextParser`1<TextSpan> get_Integer();
}
internal static class Serilog.ParserConstruction.Parsers.Span : object {
    [NullableContextAttribute("1")]
public static TextParser`1<TextSpan> EqualTo(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Parsers.Token : object {
    public static TokenListParser`2<TKind, Token`1<TKind>> EqualTo(TKind kind);
    public static TokenListParser`2<TKind, Token`1[]> Sequence(TKind[] kinds);
}
internal class Serilog.ParserConstruction.TextParser`1 : MulticastDelegate {
    public TextParser`1(object object, IntPtr method);
    public virtual Result`1<T> Invoke(TextSpan input);
    public virtual IAsyncResult BeginInvoke(TextSpan input, AsyncCallback callback, object object);
    public virtual Result`1<T> EndInvoke(IAsyncResult result);
}
internal abstract class Serilog.ParserConstruction.Tokenizer`1 : object {
    [NullableContextAttribute("1")]
public TokenList`1<TKind> Tokenize(string source);
    [NullableContextAttribute("1")]
public Result`1<TokenList`1<TKind>> TryTokenize(string source);
    protected abstract virtual IEnumerable`1<Result`1<TKind>> Tokenize(TextSpan span);
    protected static Result`1<char> SkipWhiteSpace(TextSpan span);
}
internal class Serilog.ParserConstruction.TokenListParser`2 : MulticastDelegate {
    public TokenListParser`2(object object, IntPtr method);
    public virtual TokenListParserResult`2<TKind, T> Invoke(TokenList`1<TKind> input);
    public virtual IAsyncResult BeginInvoke(TokenList`1<TKind> input, AsyncCallback callback, object object);
    public virtual TokenListParserResult`2<TKind, T> EndInvoke(IAsyncResult result);
}
internal static class Serilog.ParserConstruction.Util.CharInfo : object {
    public static bool IsLatinDigit(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.ParserConstruction.Util.Friendly : object {
    public static string List(IEnumerable`1<string> items);
    public static string Clip(string value, int maxLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Pipeline.ComputedPropertyEnricher : object {
    private string _propertyName;
    private CompiledExpression _computeValue;
    public ComputedPropertyEnricher(string propertyName, CompiledExpression computeValue);
    public sealed virtual void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Ast.Conditional : Template {
    [CompilerGeneratedAttribute]
private Expression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private Template <Consequent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Template <Alternative>k__BackingField;
    public Expression Condition { get; }
    public Template Consequent { get; }
    [NullableAttribute("2")]
public Template Alternative { get; }
    public Conditional(Expression condition, Template consequent, Template alternative);
    [CompilerGeneratedAttribute]
public Expression get_Condition();
    [CompilerGeneratedAttribute]
public Template get_Consequent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Template get_Alternative();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Ast.FormattedExpression : Template {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Alignment> <Alignment>k__BackingField;
    public Expression Expression { get; }
    [NullableAttribute("2")]
public string Format { get; }
    public Nullable`1<Alignment> Alignment { get; }
    public FormattedExpression(Expression expression, string format, Nullable`1<Alignment> alignment);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public Nullable`1<Alignment> get_Alignment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Ast.LiteralText : Template {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public LiteralText(string text);
    [CompilerGeneratedAttribute]
public string get_Text();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Ast.Repetition : Template {
    [CompilerGeneratedAttribute]
private Expression <Enumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BindingNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Template <Body>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Template <Delimiter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Template <Alternative>k__BackingField;
    public Expression Enumerable { get; }
    public String[] BindingNames { get; }
    public Template Body { get; }
    [NullableAttribute("2")]
public Template Delimiter { get; }
    [NullableAttribute("2")]
public Template Alternative { get; }
    public Repetition(Expression enumerable, String[] bindingNames, Template body, Template delimiter, Template alternative);
    [CompilerGeneratedAttribute]
public Expression get_Enumerable();
    [CompilerGeneratedAttribute]
public String[] get_BindingNames();
    [CompilerGeneratedAttribute]
public Template get_Body();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Template get_Delimiter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Template get_Alternative();
}
internal abstract class Serilog.Templates.Ast.Template : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Ast.TemplateBlock : Template {
    [CompilerGeneratedAttribute]
private Template[] <Elements>k__BackingField;
    public Template[] Elements { get; }
    public TemplateBlock(Template[] elements);
    [CompilerGeneratedAttribute]
public Template[] get_Elements();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledConditional : CompiledTemplate {
    private Evaluatable _condition;
    private CompiledTemplate _consequent;
    [NullableAttribute("2")]
private CompiledTemplate _alternative;
    public CompiledConditional(Evaluatable condition, CompiledTemplate consequent, CompiledTemplate alternative);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledExceptionToken : CompiledTemplate {
    private static string StackFrameLinePrefix;
    private Style _text;
    private Style _secondaryText;
    public CompiledExceptionToken(TemplateTheme theme);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledFormattedExpression : CompiledTemplate {
    private ThemedJsonValueFormatter _jsonFormatter;
    private Evaluatable _expression;
    [NullableAttribute("2")]
private string _format;
    private Nullable`1<Alignment> _alignment;
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    private Style _secondaryText;
    public CompiledFormattedExpression(Evaluatable expression, string format, Nullable`1<Alignment> alignment, IFormatProvider formatProvider, TemplateTheme theme);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
    private void EvaluateUnaligned(EvaluationContext ctx, TextWriter output, IFormatProvider formatProvider, Int32& invisibleCharacterCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledLevelToken : CompiledTemplate {
    [NullableAttribute("2")]
private string _format;
    private Nullable`1<Alignment> _alignment;
    private Style[] _levelStyles;
    public CompiledLevelToken(string format, Nullable`1<Alignment> alignment, TemplateTheme theme);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
    private void EvaluateUnaligned(EvaluationContext ctx, TextWriter output, Int32& invisibleCharacterCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledLiteralText : CompiledTemplate {
    private string _text;
    private Style _style;
    public CompiledLiteralText(string text, TemplateTheme theme);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledMessageToken : CompiledTemplate {
    [NullableAttribute("2")]
private IFormatProvider _formatProvider;
    private Nullable`1<Alignment> _alignment;
    private Style _text;
    private Style _invalid;
    private Style _null;
    private Style _bool;
    private Style _string;
    private Style _num;
    private Style _scalar;
    private ThemedJsonValueFormatter _jsonFormatter;
    public CompiledMessageToken(IFormatProvider formatProvider, Nullable`1<Alignment> alignment, TemplateTheme theme);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
    private void EvaluateUnaligned(EvaluationContext ctx, TextWriter output, Int32& invisibleCharacterCount);
    private void EvaluateProperty(IReadOnlyDictionary`2<string, LogEventPropertyValue> properties, PropertyToken pt, TextWriter output, Int32& invisibleCharacterCount);
    private void EvaluatePropertyUnaligned(LogEventPropertyValue propertyValue, TextWriter output, string format, Int32& invisibleCharacterCount);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledRepetition : CompiledTemplate {
    [NullableAttribute("1")]
private Evaluatable _enumerable;
    private string _keyOrElementName;
    private string _valueOrIndexName;
    [NullableAttribute("1")]
private CompiledTemplate _body;
    private CompiledTemplate _delimiter;
    private CompiledTemplate _alternative;
    public CompiledRepetition(Evaluatable enumerable, string keyOrElementName, string valueOrIndexName, CompiledTemplate body, CompiledTemplate delimiter, CompiledTemplate alternative);
    [NullableContextAttribute("1")]
public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
internal abstract class Serilog.Templates.Compilation.CompiledTemplate : object {
    [NullableContextAttribute("1")]
public abstract virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledTemplateBlock : CompiledTemplate {
    private CompiledTemplate[] _elements;
    public CompiledTemplateBlock(CompiledTemplate[] elements);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.CompiledTimestampToken : CompiledTemplate {
    private string _format;
    private Nullable`1<Alignment> _alignment;
    private IFormatProvider _formatProvider;
    private Style _secondaryText;
    public CompiledTimestampToken(string format, Nullable`1<Alignment> alignment, IFormatProvider formatProvider, TemplateTheme theme);
    [NullableContextAttribute("1")]
public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
    [NullableContextAttribute("1")]
private void EvaluateUnaligned(EvaluationContext ctx, TextWriter output, IFormatProvider formatProvider, Int32& invisibleCharacterCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.NameResolution.ExpressionLocalNameBinder : IdentityTransformer {
    private IReadOnlyCollection`1<string> _localNames;
    private ExpressionLocalNameBinder(IReadOnlyCollection`1<string> localNames);
    public static Expression BindLocalValueNames(Expression expression, IReadOnlyCollection`1<string> locals);
    protected virtual Expression Transform(AmbientNameExpression px);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.NameResolution.TemplateLocalNameBinder : object {
    public static Template BindLocalValueNames(Template template);
    private Template Transform(Template template, Stack`1<string> locals);
    private Template Transform(TemplateBlock block, Stack`1<string> locals);
    private Template Transform(FormattedExpression fx, Stack`1<string> locals);
    private Template Transform(Conditional cond, Stack`1<string> locals);
    private Template Transform(Repetition rep, Stack`1<string> locals);
}
internal static class Serilog.Templates.Compilation.TemplateCompiler : object {
    [NullableContextAttribute("1")]
public static CompiledTemplate Compile(Template template, IFormatProvider formatProvider, NameResolver nameResolver, TemplateTheme theme, EncodedTemplateFactory encoder);
}
internal static class Serilog.Templates.Compilation.TemplateFunctionNameResolver : object {
    [NullableContextAttribute("1")]
public static NameResolver Build(NameResolver additionalNameResolver, Template template);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder : SerilogExpressionTransformer`1<IEnumerable`1<string>> {
    public IEnumerable`1<string> FindReferencedProperties(Expression expression);
    protected virtual IEnumerable`1<string> Transform(CallExpression call);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__2")]
protected virtual IEnumerable`1<string> Transform(ConstantExpression cx);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__3")]
protected virtual IEnumerable`1<string> Transform(AmbientNameExpression px);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__4")]
protected virtual IEnumerable`1<string> Transform(LocalNameExpression nlx);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__5")]
protected virtual IEnumerable`1<string> Transform(AccessorExpression spx);
    protected virtual IEnumerable`1<string> Transform(LambdaExpression lmx);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__7")]
protected virtual IEnumerable`1<string> Transform(ParameterExpression prx);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__8")]
protected virtual IEnumerable`1<string> Transform(IndexerWildcardExpression wx);
    protected virtual IEnumerable`1<string> Transform(ArrayExpression ax);
    protected virtual IEnumerable`1<string> Transform(ObjectExpression ox);
    [IteratorStateMachineAttribute("Serilog.Templates.Compilation.UnreferencedProperties.ExpressionReferencedPropertiesFinder/<Transform>d__11")]
protected virtual IEnumerable`1<string> Transform(IndexerExpression ix);
    protected virtual IEnumerable`1<string> Transform(IndexOfMatchExpression mx);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <Transform>b__9_0(ItemElement i);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <Transform>b__9_1(SpreadElement i);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <Transform>b__10_0(PropertyMember m);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <Transform>b__10_1(SpreadMember m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.UnreferencedProperties.TemplateReferencedPropertiesFinder : object {
    private ExpressionReferencedPropertiesFinder _rpf;
    public IEnumerable`1<string> FindReferencedProperties(Template template);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.UnreferencedProperties.UnreferencedPropertiesFunction : NameResolver {
    private static string FunctionName;
    private HashSet`1<string> _referencedInTemplate;
    public UnreferencedPropertiesFunction(Template template);
    public virtual bool TryBindFunctionParameter(ParameterInfo parameter, Object& boundValue);
    public virtual bool TryResolveFunctionName(string name, MethodInfo& implementation);
    public static LogEventPropertyValue Implementation(UnreferencedPropertiesFunction self, LogEvent logEvent, LogEventPropertyValue deep);
    private static bool TemplateContainsPropertyName(MessageTemplate messageTemplate, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Compilation.Unsafe.UnsafeOutputFunction : NameResolver {
    private static string FunctionName;
    public virtual bool TryResolveFunctionName(string name, MethodInfo& implementation);
    [NullableContextAttribute("2")]
public static LogEventPropertyValue Implementation(LogEventPropertyValue inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Encoding.EncodedCompiledTemplate : CompiledTemplate {
    private CompiledTemplate _inner;
    private TemplateOutputEncoder _encoder;
    public EncodedCompiledTemplate(CompiledTemplate inner, TemplateOutputEncoder encoder);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Encoding.EncodedTemplateFactory : object {
    [NullableAttribute("2")]
private TemplateOutputEncoder _encoder;
    [NullableContextAttribute("2")]
public EncodedTemplateFactory(TemplateOutputEncoder encoder);
    public CompiledTemplate Wrap(CompiledTemplate inner);
    public CompiledTemplate MakeCompiledFormattedExpression(Evaluatable expression, string format, Nullable`1<Alignment> alignment, IFormatProvider formatProvider, TemplateTheme theme);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Encoding.EscapableEncodedCompiledFormattedExpression : CompiledTemplate {
    private static int _nextSubstituteLocalNameSuffix;
    private string _substituteLocalName;
    private Evaluatable _expression;
    private TemplateOutputEncoder _encoder;
    private CompiledFormattedExpression _inner;
    public EscapableEncodedCompiledFormattedExpression(Evaluatable expression, string format, Nullable`1<Alignment> alignment, IFormatProvider formatProvider, TemplateTheme theme, TemplateOutputEncoder encoder);
    [NullableContextAttribute("2")]
private LogEventPropertyValue GetSubstituteLocalValue(EvaluationContext context);
    public virtual void Evaluate(EvaluationContext ctx, TextWriter output);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Serilog.Templates.Encoding.PreEncodedValue : object {
    [CompilerGeneratedAttribute]
private LogEventPropertyValue <Inner>k__BackingField;
    public LogEventPropertyValue Inner { get; }
    public PreEncodedValue(LogEventPropertyValue inner);
    [CompilerGeneratedAttribute]
public LogEventPropertyValue get_Inner();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public abstract class Serilog.Templates.Encoding.TemplateOutputEncoder : object {
    [NullableContextAttribute("1")]
public abstract virtual string Encode(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Templates.ExpressionTemplate : object {
    private CompiledTemplate _compiled;
    private ExpressionTemplate(CompiledTemplate compiled);
    [NullableContextAttribute("2")]
public ExpressionTemplate(string template, IFormatProvider formatProvider, NameResolver nameResolver, TemplateTheme theme, bool applyThemeWhenOutputIsRedirected, TemplateOutputEncoder encoder);
    public static bool TryParse(string template, ExpressionTemplate& result, String& error);
    [NullableContextAttribute("2")]
public static bool TryParse(string template, IFormatProvider formatProvider, NameResolver nameResolver, TemplateTheme theme, bool applyThemeWhenOutputIsRedirected, TemplateOutputEncoder encoder, ExpressionTemplate& result, String& error);
    private static TemplateTheme SelectTheme(TemplateTheme supplied, bool applyThemeWhenOutputIsRedirected);
    public sealed virtual void Format(LogEvent logEvent, TextWriter output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Serilog.Templates.Parsing.TemplateParser : object {
    private TemplateTokenizer _tokenizer;
    private TemplateTokenParsers _templateTokenParsers;
    public bool TryParse(string template, Template& parsed, String& error);
}
internal class Serilog.Templates.Parsing.TemplateTokenizer : Tokenizer`1<ExpressionToken> {
    [NullableAttribute("1")]
private ExpressionTokenizer _expressionTokenizer;
    [IteratorStateMachineAttribute("Serilog.Templates.Parsing.TemplateTokenizer/<Tokenize>d__1")]
protected virtual IEnumerable`1<Result`1<ExpressionToken>> Tokenize(TextSpan span);
    [IteratorStateMachineAttribute("Serilog.Templates.Parsing.TemplateTokenizer/<TokenizeHole>d__2")]
private IEnumerable`1<Result`1<ExpressionToken>> TokenizeHole(TextSpan span);
}
internal class Serilog.Templates.Parsing.TemplateTokenParsers : object {
    [NullableAttribute("1")]
private TokenListParser`2<ExpressionToken, Template> _template;
    public TokenListParserResult`2<ExpressionToken, Template> TryParse(TokenList`1<ExpressionToken> input);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static TokenListParser`2<ExpressionToken, Expression> <.ctor>g__Directive|1_11(bool hasArgument, ExpressionToken[] signifiers);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static Template <.ctor>g__LeftReduceConditional|1_12(ValueTuple`2[] first, Template last);
}
[ExtensionAttribute]
internal static class Serilog.Templates.Rendering.AlignmentExtensions : object {
    [ExtensionAttribute]
public static Alignment Widen(Alignment alignment, int amount);
}
internal static class Serilog.Templates.Rendering.Casing : object {
    [NullableContextAttribute("1")]
public static string Format(string value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Templates.Rendering.LevelRenderer : object {
    private static String[][] TitleCaseLevelMap;
    private static String[][] LowercaseLevelMap;
    private static String[][] UppercaseLevelMap;
    private static LevelRenderer();
    public static string GetLevelMoniker(LogEventLevel value, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Templates.Rendering.Padding : object {
    private static Char[] PaddingChars;
    private static Padding();
    public static void Apply(TextWriter output, string value, Alignment alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Serilog.Templates.Themes.Style : ValueType {
    [NullableAttribute("2")]
private string _ansiStyle;
    public Style(string ansiStyle);
    internal StyleReset Set(TextWriter output, Int32& invisibleCharacterCount);
    [NullableContextAttribute("2")]
public string GetAnsiStyle();
}
[IsReadOnlyAttribute]
internal class Serilog.Templates.Themes.StyleReset : ValueType {
    [NullableAttribute("1")]
private static string AnsiStyleResetSequence;
    public static int ResetCharCount;
    [NullableAttribute("2")]
private TextWriter _output;
    [NullableContextAttribute("1")]
public StyleReset(TextWriter output);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Serilog.Templates.Themes.TemplateTheme : object {
    [CompilerGeneratedAttribute]
private static TemplateTheme <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemplateTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemplateTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemplateTheme <None>k__BackingField;
    private Dictionary`2<TemplateThemeStyle, Style> _styles;
    public static TemplateTheme Code { get; }
    public static TemplateTheme Grayscale { get; }
    public static TemplateTheme Literate { get; }
    internal static TemplateTheme None { get; }
    public TemplateTheme(IReadOnlyDictionary`2<TemplateThemeStyle, string> ansiStyles);
    public TemplateTheme(TemplateTheme baseTheme, IReadOnlyDictionary`2<TemplateThemeStyle, string> ansiStyles);
    private static TemplateTheme();
    [CompilerGeneratedAttribute]
public static TemplateTheme get_Code();
    [CompilerGeneratedAttribute]
public static TemplateTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static TemplateTheme get_Literate();
    [CompilerGeneratedAttribute]
internal static TemplateTheme get_None();
    internal Style GetStyle(TemplateThemeStyle templateThemeStyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Serilog.Templates.Themes.TemplateThemes : object {
    [CompilerGeneratedAttribute]
private static TemplateTheme <Literate>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemplateTheme <Grayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemplateTheme <Code>k__BackingField;
    public static TemplateTheme Literate { get; }
    public static TemplateTheme Grayscale { get; }
    public static TemplateTheme Code { get; }
    private static TemplateThemes();
    [CompilerGeneratedAttribute]
public static TemplateTheme get_Literate();
    [CompilerGeneratedAttribute]
public static TemplateTheme get_Grayscale();
    [CompilerGeneratedAttribute]
public static TemplateTheme get_Code();
}
public enum Serilog.Templates.Themes.TemplateThemeStyle : Enum {
    public int value__;
    public static TemplateThemeStyle Text;
    public static TemplateThemeStyle SecondaryText;
    public static TemplateThemeStyle TertiaryText;
    public static TemplateThemeStyle Invalid;
    public static TemplateThemeStyle Null;
    public static TemplateThemeStyle Name;
    public static TemplateThemeStyle String;
    public static TemplateThemeStyle Number;
    public static TemplateThemeStyle Boolean;
    public static TemplateThemeStyle Scalar;
    public static TemplateThemeStyle LevelVerbose;
    public static TemplateThemeStyle LevelDebug;
    public static TemplateThemeStyle LevelInformation;
    public static TemplateThemeStyle LevelWarning;
    public static TemplateThemeStyle LevelError;
    public static TemplateThemeStyle LevelFatal;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Serilog.Templates.Themes.ThemedJsonValueFormatter : LogEventPropertyValueVisitor`2<TextWriter, int> {
    private static string TypeTagPropertyName;
    private Style _null;
    private Style _bool;
    private Style _num;
    private Style _string;
    private Style _scalar;
    private Style _tertiary;
    private Style _name;
    public ThemedJsonValueFormatter(TemplateTheme theme);
    public int Format(LogEventPropertyValue value, TextWriter output);
    protected virtual int VisitScalarValue(TextWriter state, ScalarValue scalar);
    protected virtual int VisitSequenceValue(TextWriter state, SequenceValue sequence);
    protected virtual int VisitStructureValue(TextWriter state, StructureValue structure);
    protected virtual int VisitDictionaryValue(TextWriter state, DictionaryValue dictionary);
    private int FormatLiteralValue(ScalarValue scalar, TextWriter output);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
